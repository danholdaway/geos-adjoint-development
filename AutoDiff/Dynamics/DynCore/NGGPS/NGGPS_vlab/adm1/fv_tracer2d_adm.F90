!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
!***********************************************************************
!*                   GNU General Public License                        *
!* This file is a part of fvGFS.                                       *
!*                                                                     *
!* fvGFS is free software; you can redistribute it and/or modify it    *
!* and are expected to follow the terms of the GNU General Public      *
!* License as published by the Free Software Foundation; either        *
!* version 2 of the License, or (at your option) any later version.    *
!*                                                                     *
!* fvGFS is distributed in the hope that it will be useful, but        *
!* WITHOUT ANY WARRANTY; without even the implied warranty of          *
!* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU   *
!* General Public License for more details.                            *
!*                                                                     *
!* For the full text of the GNU General Public License,                *
!* write to: Free Software Foundation, Inc.,                           *
!*           675 Mass Ave, Cambridge, MA 02139, USA.                   *
!* or see:   http://www.gnu.org/licenses/gpl.html                      *
!***********************************************************************
MODULE FV_TRACER2D_MOD_B
  USE TP_CORE_MOD_B, ONLY : fv_tp_2d, fv_tp_2d_adm, fv_tp_2d, &
& fv_tp_2d_adm, copy_corners, copy_corners_adm
  USE FV_MP_MOD_B, ONLY : mp_reduce_max
  USE FV_MP_MOD_B, ONLY : ng, mp_gather, is_master
  USE FV_MP_MOD_B, ONLY : group_halo_update_type
  USE FV_MP_MOD_B, ONLY : start_group_halo_update, &
& start_group_halo_update_adm, complete_group_halo_update
  USE MPP_DOMAINS_MOD_B, ONLY : mpp_update_domains, &
& mpp_update_domains_adm, cgrid_ne, domain2d, mpp_get_boundary, &
& mpp_get_boundary_adm
  USE FV_TIMING_MOD, ONLY : timing_on, timing_off
  USE BOUNDARY_MOD_B, ONLY : nested_grid_bc_apply_intt, &
& nested_grid_bc_apply_intt_adm
  USE FV_ARRAYS_MOD_B, ONLY : fv_grid_type, fv_flags_type, fv_nest_type,&
& fv_atmos_type, fv_grid_bounds_type
  USE MPP_MOD, ONLY : mpp_error, fatal, mpp_broadcast, mpp_send, &
& mpp_recv, mpp_sum, mpp_max
  IMPLICIT NONE
!subroutine offline_tracer_advection(q, ple0, ple1, mfx, mfy, cx, cy, &
!                                    gridstruct, flagstruct, bd, domain, &
!                                    ak, bk, ptop, npx, npy, npz,   &
!                                    nq, hord, kord, q_split, k_split, dt, z_tracer, fill, &
!                                    split_damp_tr)
!
!      use fv_mapz_mod,        only: map1_q2
!      use fv_fill_mod,        only: fillz
!
!      integer, intent(IN) :: npx
!      integer, intent(IN) :: npy
!      integer, intent(IN) :: npz
!      integer, intent(IN) :: nq    ! number of tracers to be advected
!      integer, intent(IN) :: hord
!      logical, intent(IN) :: split_damp_tr
!      integer, intent(IN) :: kord
!      integer, intent(IN) :: q_split
!      integer, intent(IN) :: k_split
!      logical, intent(IN) :: z_tracer
!      logical, intent(IN) :: fill
!      type(fv_grid_bounds_type), intent(IN   ) :: bd
!      type(fv_flags_type), intent(INOUT) :: flagstruct
!      type(fv_grid_type), intent(IN), target :: gridstruct
!      type(domain2D), intent(INOUT) :: domain
!
!      real, intent(IN   ) :: dt
!      real, intent(IN   ) ::ple0(bd%is:bd%ie,bd%js:bd%je,npz+1)      ! DELP before dyn_core
!      real, intent(INOUT) ::ple1(bd%is:bd%ie,bd%js:bd%je,npz+1)      ! DELP after dyn_core
!      real, intent(IN   ) ::  cx(bd%is:bd%ie,bd%js:bd%je,npz)        ! Courant Number X-Dir
!      real, intent(IN   ) ::  cy(bd%is:bd%ie,bd%js:bd%je,npz)        ! Courant Number Y-Dir
!      real, intent(IN   ) :: mfx(bd%is:bd%ie,bd%js:bd%je,npz)        ! Mass Flux X-Dir
!      real, intent(IN   ) :: mfy(bd%is:bd%ie,bd%js:bd%je,npz)        ! Mass Flux Y-Dir
!      real, intent(INOUT) ::   q(bd%is:bd%ie,bd%js:bd%je,npz,nq)     ! Tracers
!      real, intent(IN   ) ::  ak(npz+1)                  ! AK for remapping
!      real, intent(IN   ) ::  bk(npz+1)                  ! BK for remapping
!      real, intent(IN   ) :: ptop
!! Local Arrays
!      real ::   xL(bd%isd:bd%ied+1,bd%jsd:bd%jed  ,npz)  ! X-Dir for MPP Updates
!      real ::   yL(bd%isd:bd%ied  ,bd%jsd:bd%jed+1,npz)  ! Y-Dir for MPP Updates
!      real ::  cxL(bd%is :bd%ie +1,bd%jsd:bd%jed  ,npz)  ! Courant Number X-Dir
!      real ::  cyL(bd%isd:bd%ied  ,bd%js :bd%je +1,npz)  ! Courant Number Y-Dir
!      real :: mfxL(bd%is :bd%ie +1,bd%js :bd%je   ,npz)  ! Mass Flux X-Dir
!      real :: mfyL(bd%is :bd%ie   ,bd%js :bd%je +1,npz)  ! Mass Flux Y-Dir
!      real ::  dpL(bd%is :bd%ie   ,bd%js :bd%je   ,npz)  ! Pressure Thickness
!      real ::  dpA(bd%is :bd%ie   ,bd%js :bd%je   ,npz)  ! Pressure Thickness
!! Local Tracer Arrays
!      real ::   q1(bd%is:bd%ie  ,bd%js:bd%je, npz   )! 2D Tracers
!      real ::   q2(bd%isd:bd%ied  ,bd%jsd:bd%jed     ,nq)! 2D Tracers
!      real ::   q3(bd%isd:bd%ied  ,bd%jsd:bd%jed, npz,nq)! 3D Tracers
!! Local Buffer Arrarys
!      real :: wbuffer(bd%js:bd%je,npz)
!      real :: sbuffer(bd%is:bd%ie,npz)
!      real :: ebuffer(bd%js:bd%je,npz)
!      real :: nbuffer(bd%is:bd%ie,npz)
!! Local Remap Arrays
!      real  pe1(bd%is:bd%ie,npz+1)
!      real  pe2(bd%is:bd%ie,npz+1)
!      real  dp2(bd%is:bd%ie,bd%js:bd%je,npz)
!
!! Local indices
!      integer     :: i,j,k,n,iq
!
!      real :: scalingFactor
!
!      type(group_halo_update_type), save :: i_pack
!
!      integer :: is,  ie,  js,  je
!      integer :: isd, ied, jsd, jed
!
!      is  = bd%is
!      ie  = bd%ie
!      js  = bd%js
!      je  = bd%je
!      isd = bd%isd
!      ied = bd%ied
!      jsd = bd%jsd
!      jed = bd%jed
!
!! Time-step
!! Fill CX/CY C-Grid boundaries and update ghost regions
!    xL(is:ie,js:je,:) = cx(:,:,:)
!    yL(is:ie,js:je,:) = cy(:,:,:)
!    call mpp_get_boundary(xL, yL, domain, &
!                          wbufferx=wbuffer, ebufferx=ebuffer, &
!                          sbuffery=sbuffer, nbuffery=nbuffer, &
!                          gridtype=CGRID_NE )
!    xL(ie+1,js:je,:) = ebuffer
!    yL(is:ie,je+1,:) = nbuffer
!    call mpp_update_domains( xL, yL, domain, gridtype=CGRID_NE, complete=.true.)
!    cxL(is:ie+1,jsd:jed,:) = xL(is:ie+1,jsd:jed,:)
!    cyL(isd:ied,js:je+1,:) = yL(isd:ied,js:je+1,:)
!
!! Fill MFX/MFY C-Grid boundaries
!    xL(is:ie,js:je,:) = mfx(:,:,:)
!    yL(is:ie,js:je,:) = mfy(:,:,:)
!    call mpp_get_boundary(xL, yL, domain, &
!                          wbufferx=wbuffer, ebufferx=ebuffer, &
!                          sbuffery=sbuffer, nbuffery=nbuffer, &
!                          gridtype=CGRID_NE )
!    xL(ie+1,js:je,:) = ebuffer
!    yL(is:ie,je+1,:) = nbuffer
!    mfxL(is:ie+1,js:je,:) = xL(is:ie+1,js:je,:)
!    mfyL(is:ie,js:je+1,:) = yL(is:ie,js:je+1,:)
!
!! Fill local tracers and pressure thickness
!    dpL(:,:,:) = ple0(:,:,2:npz+1) - ple0(:,:,1:npz)
!    q3(is:ie,js:je,:,:) = q(is:ie,js:je,:,:)
!
!    if ( z_tracer ) then
!!$omp parallel do default(shared) private(q2)
!       do k=1,npz
!         do iq=1,nq
!            do j=js,je
!               do i=is,ie                   ! To_do list:
!                  q2(i,j,iq) = q3(i,j,k,iq) ! The data copying can be avoided if q is
!! re-dimensioned as q(i,j,nq,k)
!               enddo
!            enddo
!         enddo
!         call start_group_halo_update(i_pack, q2, domain)
!         call tracer_2d_1L(q2, dpL(is,js,k), mfxL(is,js,k), mfyL(is,js,k), cxL(is,js,k), cyL(is,js,k), &
!                         gridstruct, bd, domain, npx, npy, npz, nq,    &
!                         flagstruct%hord_tr, q_split, dt, 0, i_pack, &
!                         flagstruct%nord_tr, flagstruct%trdm2, &
!                         flagstruct%hord_tr_pert, flagstruct%nord_tr_pert, flagstruct%trdm2_pert, split_damp_tr, dpA=dpA)
!         do iq=1,nq
!            do j=js,je
!               do i=is,ie                   ! To_do list:
!                  q3(i,j,k,iq) = q2(i,j,iq) ! The data copying can be avoided if q is
!! re-dimensioned as q(i,j,nq,k)
!               enddo
!            enddo
!         enddo
!       enddo
!    else
!         call start_group_halo_update(i_pack, q3, domain)
!         call tracer_2d(q3, dpL, mfxL, mfyL, cxL, cyL, gridstruct, bd, domain, npx, npy, npz, nq,    &
!                        flagstruct%hord_tr, q_split, dt, 0, i_pack, &
!                        flagstruct%nord_tr, flagstruct%trdm2, &
!                        flagstruct%hord_tr_pert, flagstruct%nord_tr_pert, flagstruct%trdm2_pert, split_damp_tr, dpA=dpA)
!    endif
!
!!------------------------------------------------------------------
!! Re-Map constituents
!! Do remapping one tracer at a time; seems to be faster
!! It requires less memory than mapn_ppm
!!------------------------------------------------------------------
!
!       do iq=1,nq
!          do j=js,je
!! pressures mapping from (dpA is new delp after tracer_2d)
!             pe1(:,1) = ptop
!             do k=2,npz+1
!               pe1(:,k) = pe1(:,k-1) + dpA(:,j,k-1)
!             enddo
!! pressures mapping to
!             pe2(:,1) = ptop
!             pe2(:,npz+1) = pe1(:,npz+1)
!             do k=2,npz
!                 pe2(:  ,k) = ak(k) + bk(k)*pe1(:,npz+1)
!             enddo
!             do k=1,npz
!                dp2(:,j,k) = pe2(:,k+1) - pe2(:,k)
!             enddo
!             call map1_q2(npz, pe1, q3(isd:ied,jsd:jed,1,iq),      &
!                          npz, pe2, q1(:,j,:), dp2(:,j,:), &
!                          is, ie, 0, kord, j,              &
!                          isd, ied, jsd, jed, 0.) 
!             if (fill) call fillz(ie-is+1, npz, 1, q1(:,j,:), dp2(:,j,:))
!          enddo
!! Rescale tracers based on ple1 at destination timestep
!!------------------------------------------------------
!
!          scalingFactor = calcScalingFactor(q1, dp2, ple1, npx, npy, npz, gridstruct, bd)
!!scalingFactors = computeScalingFactors(q1, dp2, ple1, npx, npy, npz)
!
!! Return tracers
!!---------------
!          q(is:ie,js:je,1:npz,iq) = q1(is:ie,js:je,1:npz) * scalingFactor
!!do k =1,npz
!!do j = js,je
!!do i = is,ie
!!q(i,j,k,iq) = q1(i,j,k)
!!enddo
!!enddo
!!enddo
!
!       enddo
!
!end subroutine offline_tracer_advection
!------------------------------------------------------------------------------------
!         function calcScalingFactor(q1, dp2, ple1, npx, npy, npz, gridstruct, bd) result(scaling)
!         use mpp_mod, only: mpp_sum
!         integer, intent(in) :: npx
!         integer, intent(in) :: npy
!         integer, intent(in) :: npz
!         type(fv_grid_bounds_type), intent(IN   ) :: bd
!         real, intent(in) :: q1(bd%is:bd%ie  ,bd%js:bd%je, npz)
!         real, intent(in) :: dp2(bd%is:bd%ie,bd%js:bd%je,npz)
!         real, intent(in) :: ple1(bd%is:bd%ie,bd%js:bd%je,npz+1)
!         type(fv_grid_type), intent(IN   ) :: gridstruct
!         real :: scaling
!
!         integer :: k
!         real :: partialSums(2,npz), globalSums(2)
!         real, parameter :: TINY_DENOMINATOR = 1.0e-30
!
!!-------
!! Compute partial sum on local array first to minimize communication.
!! This algorithm will not be strongly repdroducible under changes do domain
!! decomposition, but uses far less communication bandwidth (and memory BW)
!! then the preceding implementation.
!!-------
!         do k = 1, npz
!! numerator
!            partialSums(1,k) = sum(q1(:,:,k)*dp2(:,:,k)*gridstruct%area(bd%is:bd%ie,bd%js:bd%je))
!! denominator
!            partialSums(2,k) = sum(q1(:,:,k)*(ple1(:,:,k+1)-ple1(:,:,k))*gridstruct%area(bd%is:bd%ie,bd%js:bd%je))
!         end do
!
!         globalSums(1) = sum(partialSums(1,:))
!         globalSums(2) = sum(partialSums(2,:))
!
!         call mpp_sum(globalSums, 2)
!
!         if (globalSums(2) > TINY_DENOMINATOR) then
!            scaling =  globalSums(1) / globalSums(2)
!!#################################################################
!! This line was added to ensure strong reproducibility of the code
!!#################################################################
!            scaling = REAL(scaling, KIND=kind(1.00))
!         else
!            scaling = 1.0
!         end if
!
!         end function calcScalingFactor
  PRIVATE 
!, offline_tracer_advection
  PUBLIC tracer_2d, tracer_2d_nested, tracer_2d_1l
  PUBLIC tracer_2d_fwd, tracer_2d_bwd, tracer_2d_nested_fwd, &
& tracer_2d_nested_bwd, tracer_2d_1l_fwd, tracer_2d_1l_bwd
  REAL, DIMENSION(:, :, :), ALLOCATABLE :: nest_fx_west_accum, &
& nest_fx_east_accum, nest_fx_south_accum, nest_fx_north_accum
  EXTERNAL TRACER_2D_ADM
  EXTERNAL TRACER_2D_1L_ADM
  EXTERNAL TRACER_2D_NESTED_ADM

CONTAINS
!  Differentiation of tracer_2d_1l in reverse (adjoint) mode, forward sweep (with options split(a2b_edge_mod.a2b_ord4 a2b_edge
!_mod.a2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_cor
!e_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mod
!.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Raylei
!gh_Super fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_geos f
!v_grid_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_map
!z_mod.compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.ma
!pn_tracer_fb fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_
!limiters fv_mapz_mod.ppm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod
!.moist_cv fv_mapz_mod.moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.trac
!er_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.R
!iem_Solver_c nh_utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SIM
!3p0_solver nh_utils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nest
!_halo_nh sw_core_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_v
!ect sw_core_mod.fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v sw
!_core_mod.compute_divergence_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_core_m
!od.fv_tp_2d tp_core_mod.copy_corners tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_
!corner_fb fv_grid_utils_mod.great_circle_dist sw_core_mod.edge_interpolate4)):
!   gradient     of useful results: q dp1
!   with respect to varying inputs: q dp1 mfx mfy cx cy
!-----------------------------------------------------------------------
! !ROUTINE: Perform 2D horizontal-to-lagrangian transport
!-----------------------------------------------------------------------
  SUBROUTINE TRACER_2D_1L_FWD(q, dp1, mfx, mfy, cx, cy, gridstruct, bd, &
&   domain, npx, npy, npz, nq, hord, q_split, dt, id_divg, q_pack, &
&   nord_tr, trdm, hord_pert, nord_tr_pert, trdm_pert, split_damp_tr, &
&   dpa)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
! number of tracers to be advected
    INTEGER, INTENT(IN) :: nq
    INTEGER, INTENT(IN) :: hord, nord_tr
    INTEGER, INTENT(IN) :: hord_pert, nord_tr_pert
    LOGICAL, INTENT(IN) :: split_damp_tr
    INTEGER, INTENT(IN) :: q_split
    INTEGER, INTENT(IN) :: id_divg
    REAL, INTENT(IN) :: dt, trdm, trdm_pert
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: q_pack
! Tracers
    REAL, INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, nq)
! DELP before dyn_core
    REAL, INTENT(INOUT) :: dp1(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! Mass Flux X-Dir
    REAL, INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
! Mass Flux Y-Dir
    REAL, INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
! Courant Number X-Dir
    REAL, INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
! Courant Number Y-Dir
    REAL, INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
! DELP after advection
    REAL, OPTIONAL, INTENT(OUT) :: dpa(bd%is:bd%ie, bd%js:bd%je)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
! Local Arrays
! 3D tracers
    REAL :: qn2(bd%isd:bd%ied, bd%jsd:bd%jed, nq)
    REAL :: dp2(bd%is:bd%ie, bd%js:bd%je)
    REAL :: fx(bd%is:bd%ie+1, bd%js:bd%je)
    REAL :: fy(bd%is:bd%ie, bd%js:bd%je+1)
    REAL :: ra_x(bd%is:bd%ie, bd%jsd:bd%jed)
    REAL :: ra_y(bd%isd:bd%ied, bd%js:bd%je)
    REAL :: xfx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL :: yfx(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL :: cmax(npz)
    REAL :: frac
    INTEGER :: nsplt
    INTEGER :: i, j, k, it, iq
    REAL, DIMENSION(:, :), POINTER :: area, rarea
    REAL, DIMENSION(:, :, :), POINTER :: sin_sg
    REAL, DIMENSION(:, :), POINTER :: dxa, dya, dx, dy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC INT
    INTRINSIC REAL
    INTRINSIC PRESENT
    REAL :: max1
    REAL :: x1
    REAL :: z1
    REAL :: y3
    REAL :: y2
    REAL :: y1
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    area => gridstruct%area
    rarea => gridstruct%rarea
    sin_sg => gridstruct%sin_sg
    dxa => gridstruct%dxa
    dya => gridstruct%dya
    dx => gridstruct%dx
    dy => gridstruct%dy
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,jsd,jed,npz,cx,xfx,dxa,dy, &
!$OMP                                  sin_sg,cy,yfx,dya,dx,cmax)
    DO k=1,npz
      DO j=jsd,jed
        DO i=is,ie+1
          IF (cx(i, j, k) .GT. 0.) THEN
            xfx(i, j, k) = cx(i, j, k)*dxa(i-1, j)*dy(i, j)*sin_sg(i-1, &
&             j, 3)
            CALL PUSHCONTROL1B(1)
          ELSE
            xfx(i, j, k) = cx(i, j, k)*dxa(i, j)*dy(i, j)*sin_sg(i, j, 1&
&             )
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      DO j=js,je+1
        DO i=isd,ied
          IF (cy(i, j, k) .GT. 0.) THEN
            yfx(i, j, k) = cy(i, j, k)*dya(i, j-1)*dx(i, j)*sin_sg(i, j-&
&             1, 4)
            CALL PUSHCONTROL1B(1)
          ELSE
            yfx(i, j, k) = cy(i, j, k)*dya(i, j)*dx(i, j)*sin_sg(i, j, 2&
&             )
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      cmax(k) = 0.
      IF (k .LT. npz/6) THEN
        DO j=js,je
          DO i=is,ie
            IF (cx(i, j, k) .GE. 0.) THEN
              y1 = cx(i, j, k)
            ELSE
              y1 = -cx(i, j, k)
            END IF
            IF (cy(i, j, k) .GE. 0.) THEN
              z1 = cy(i, j, k)
            ELSE
              z1 = -cy(i, j, k)
            END IF
            IF (cmax(k) .LT. y1) THEN
              IF (y1 .LT. z1) THEN
                CALL PUSHCONTROL2B(0)
                cmax(k) = z1
              ELSE
                CALL PUSHCONTROL2B(1)
                cmax(k) = y1
              END IF
            ELSE IF (cmax(k) .LT. z1) THEN
              CALL PUSHCONTROL2B(2)
              cmax(k) = z1
            ELSE
              CALL PUSHCONTROL2B(3)
              cmax(k) = cmax(k)
            END IF
          END DO
        END DO
        CALL PUSHCONTROL1B(1)
      ELSE
        DO j=js,je
          DO i=is,ie
            IF (cx(i, j, k) .GE. 0.) THEN
              x1 = cx(i, j, k)
            ELSE
              x1 = -cx(i, j, k)
            END IF
            IF (cy(i, j, k) .GE. 0.) THEN
              y3 = cy(i, j, k)
            ELSE
              y3 = -cy(i, j, k)
            END IF
            IF (x1 .LT. y3) THEN
              max1 = y3
            ELSE
              max1 = x1
            END IF
            y2 = max1 + 1. - sin_sg(i, j, 5)
            IF (cmax(k) .LT. y2) THEN
              CALL PUSHCONTROL1B(0)
              cmax(k) = y2
            ELSE
              CALL PUSHCONTROL1B(1)
              cmax(k) = cmax(k)
            END IF
          END DO
        END DO
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
! k-loop
    CALL MP_REDUCE_MAX(cmax, npz)
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,jsd,jed,npz,cx,xfx, &
!$OMP                                  cy,yfx,mfx,mfy,cmax)   &
!$OMP                          private(nsplt, frac)
    DO k=1,npz
      nsplt = INT(1. + cmax(k))
      IF (nsplt .GT. 1) THEN
        CALL PUSHREAL4(frac)
        frac = 1./REAL(nsplt)
        DO j=jsd,jed
          DO i=is,ie+1
            CALL PUSHREAL4(cx(i, j, k))
            cx(i, j, k) = cx(i, j, k)*frac
            xfx(i, j, k) = xfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je
          DO i=is,ie+1
            CALL PUSHREAL4(mfx(i, j, k))
            mfx(i, j, k) = mfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je+1
          DO i=isd,ied
            CALL PUSHREAL4(cy(i, j, k))
            cy(i, j, k) = cy(i, j, k)*frac
            yfx(i, j, k) = yfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je+1
          DO i=is,ie
            CALL PUSHREAL4(mfy(i, j, k))
            mfy(i, j, k) = mfy(i, j, k)*frac
          END DO
        END DO
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
! Begin k-independent tracer transport; can not be OpenMPed because the mpp_update call.
    DO k=1,npz
!$OMP parallel do default(none) shared(k,is,ie,js,je,isd,ied,jsd,jed,xfx,area,yfx,ra_x,ra_y)
      DO j=jsd,jed
        DO i=is,ie
          CALL PUSHREAL4(ra_x(i, j))
          ra_x(i, j) = area(i, j) + xfx(i, j, k) - xfx(i+1, j, k)
        END DO
        IF (j .GE. js .AND. j .LE. je) THEN
          DO i=isd,ied
            CALL PUSHREAL4(ra_y(i, j))
            ra_y(i, j) = area(i, j) + yfx(i, j, k) - yfx(i, j+1, k)
          END DO
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
      nsplt = INT(1. + cmax(k))
      DO it=1,nsplt
!$OMP parallel do default(none) shared(k,is,ie,js,je,rarea,mfx,mfy,dp1,dp2)
        DO j=js,je
          DO i=is,ie
            CALL PUSHREAL4(dp2(i, j))
            dp2(i, j) = dp1(i, j, k) + (mfx(i, j, k)-mfx(i+1, j, k)+mfy(&
&             i, j, k)-mfy(i, j+1, k))*rarea(i, j)
          END DO
        END DO
!$OMP parallel do default(none) shared(k,nsplt,it,is,ie,js,je,isd,ied,jsd,jed,npx,npy,cx,xfx,hord,trdm, &
!$OMP                                  nord_tr,nq,gridstruct,bd,cy,yfx,mfx,mfy,qn2,q,ra_x,ra_y,dp1,dp2,rarea) &
!$OMP                          private(fx,fy)
        DO iq=1,nq
          IF (nsplt .NE. 1) THEN
            IF (it .EQ. 1) THEN
              DO j=jsd,jed
                DO i=isd,ied
                  CALL PUSHREAL4(qn2(i, j, iq))
                  qn2(i, j, iq) = q(i, j, k, iq)
                END DO
              END DO
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            IF (hord .EQ. hord_pert) THEN
              CALL FV_TP_2D_FWD(qn2(isd:ied, jsd:jed, iq), cx(is:ie+1&
&                            , jsd:jed, k), cy(isd:ied, js:je+1, k), npx&
&                            , npy, hord, fx, fy, xfx(is:ie+1, jsd:jed, &
&                            k), yfx(isd:ied, js:je+1, k), gridstruct, &
&                            bd, ra_x, ra_y, mfx=mfx(is:ie+1, js:je, k)&
&                            , mfy=mfy(is:ie, js:je+1, k))
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREAL4ARRAY(fy, (bd%ie-bd%is+1)*(bd%je-bd%js+2))
              CALL PUSHREAL4ARRAY(fx, (bd%ie-bd%is+2)*(bd%je-bd%js+1))
              CALL PUSHREAL4ARRAY(qn2(isd:ied, jsd:jed, iq), (ied-isd+1)&
&                           *(jed-jsd+1))
              CALL FV_TP_2D(qn2(isd:ied, jsd:jed, iq), cx(is:ie+1, jsd:&
&                     jed, k), cy(isd:ied, js:je+1, k), npx, npy, &
&                     hord_pert, fx, fy, xfx(is:ie+1, jsd:jed, k), yfx(&
&                     isd:ied, js:je+1, k), gridstruct, bd, ra_x, ra_y, &
&                     mfx=mfx(is:ie+1, js:je, k), mfy=mfy(is:ie, js:je+1&
&                     , k))
              CALL PUSHCONTROL1B(1)
            END IF
            IF (it .LT. nsplt) THEN
! not last call
              DO j=js,je
                DO i=is,ie
                  CALL PUSHREAL4(qn2(i, j, iq))
                  qn2(i, j, iq) = (qn2(i, j, iq)*dp1(i, j, k)+(fx(i, j)-&
&                   fx(i+1, j)+fy(i, j)-fy(i, j+1))*rarea(i, j))/dp2(i, &
&                   j)
                END DO
              END DO
              CALL PUSHCONTROL2B(2)
            ELSE
              DO j=js,je
                DO i=is,ie
                  CALL PUSHREAL4(q(i, j, k, iq))
                  q(i, j, k, iq) = (qn2(i, j, iq)*dp1(i, j, k)+(fx(i, j)&
&                   -fx(i+1, j)+fy(i, j)-fy(i, j+1))*rarea(i, j))/dp2(i&
&                   , j)
                END DO
              END DO
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            IF (hord .EQ. hord_pert) THEN
              CALL FV_TP_2D_FWD(q(isd:ied, jsd:jed, k, iq), cx(is:ie+&
&                            1, jsd:jed, k), cy(isd:ied, js:je+1, k), &
&                            npx, npy, hord, fx, fy, xfx(is:ie+1, jsd:&
&                            jed, k), yfx(isd:ied, js:je+1, k), &
&                            gridstruct, bd, ra_x, ra_y, mfx=mfx(is:ie+1&
&                            , js:je, k), mfy=mfy(is:ie, js:je+1, k))
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHREAL4ARRAY(fy, (bd%ie-bd%is+1)*(bd%je-bd%js+2))
              CALL PUSHREAL4ARRAY(fx, (bd%ie-bd%is+2)*(bd%je-bd%js+1))
              CALL PUSHREAL4ARRAY(q(isd:ied, jsd:jed, k, iq), (ied-isd+1&
&                           )*(jed-jsd+1))
              CALL FV_TP_2D(q(isd:ied, jsd:jed, k, iq), cx(is:ie+1, jsd:&
&                     jed, k), cy(isd:ied, js:je+1, k), npx, npy, &
&                     hord_pert, fx, fy, xfx(is:ie+1, jsd:jed, k), yfx(&
&                     isd:ied, js:je+1, k), gridstruct, bd, ra_x, ra_y, &
&                     mfx=mfx(is:ie+1, js:je, k), mfy=mfy(is:ie, js:je+1&
&                     , k))
              CALL PUSHCONTROL1B(0)
            END IF
            DO j=js,je
              DO i=is,ie
                CALL PUSHREAL4(q(i, j, k, iq))
                q(i, j, k, iq) = (q(i, j, k, iq)*dp1(i, j, k)+(fx(i, j)-&
&                 fx(i+1, j)+fy(i, j)-fy(i, j+1))*rarea(i, j))/dp2(i, j)
              END DO
            END DO
            CALL PUSHCONTROL2B(0)
          END IF
        END DO
!  tracer-loop
        IF (it .LT. nsplt) THEN
! not last call
          DO j=js,je
            DO i=is,ie
              CALL PUSHREAL4(dp1(i, j, k))
              dp1(i, j, k) = dp2(i, j)
            END DO
          END DO
          CALL PUSHREAL4ARRAY(qn2, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                       nq)
          CALL MPP_UPDATE_DOMAINS(qn2, domain)
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
      CALL PUSHINTEGER4(it - 1)
    END DO
    CALL PUSHREAL4ARRAY(xfx, (bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*npz)
    CALL PUSHREAL4ARRAY(dp2, (bd%ie-bd%is+1)*(bd%je-bd%js+1))
    CALL PUSHREAL4(frac)
    CALL PUSHREAL4ARRAY(qn2, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*nq)
    CALL PUSHREAL4ARRAY(ra_x, (bd%ie-bd%is+1)*(bd%jed-bd%jsd+1))
    CALL PUSHREAL4ARRAY(ra_y, (bd%ied-bd%isd+1)*(bd%je-bd%js+1))
    CALL PUSHREAL4ARRAY(yfx, (bd%ied-bd%isd+1)*(bd%je-bd%js+2)*npz)
    CALL PUSHREAL4ARRAY(fx, (bd%ie-bd%is+2)*(bd%je-bd%js+1))
    CALL PUSHREAL4ARRAY(fy, (bd%ie-bd%is+1)*(bd%je-bd%js+2))
  END SUBROUTINE TRACER_2D_1L_FWD
!  Differentiation of tracer_2d_1l in reverse (adjoint) mode, backward sweep (with options split(a2b_edge_mod.a2b_ord4 a2b_edg
!e_mod.a2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_co
!re_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mo
!d.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayle
!igh_Super fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_geos 
!fv_grid_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_ma
!pz_mod.compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.m
!apn_tracer_fb fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs
!_limiters fv_mapz_mod.ppm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mo
!d.moist_cv fv_mapz_mod.moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tra
!cer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.
!Riem_Solver_c nh_utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SI
!M3p0_solver nh_utils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nes
!t_halo_nh sw_core_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_
!vect sw_core_mod.fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v s
!w_core_mod.compute_divergence_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_core_
!mod.fv_tp_2d tp_core_mod.copy_corners tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap
!_corner_fb fv_grid_utils_mod.great_circle_dist sw_core_mod.edge_interpolate4)):
!   gradient     of useful results: q dp1
!   with respect to varying inputs: q dp1 mfx mfy cx cy
!-----------------------------------------------------------------------
! !ROUTINE: Perform 2D horizontal-to-lagrangian transport
!-----------------------------------------------------------------------
  SUBROUTINE TRACER_2D_1L_BWD(q, q_ad, dp1, dp1_ad, mfx, mfx_ad, mfy, &
&   mfy_ad, cx, cx_ad, cy, cy_ad, gridstruct, bd, domain, npx, npy, npz&
&   , nq, hord, q_split, dt, id_divg, q_pack, nord_tr, trdm, hord_pert, &
&   nord_tr_pert, trdm_pert, split_damp_tr, dpa)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
    INTEGER, INTENT(IN) :: nq
    INTEGER, INTENT(IN) :: hord, nord_tr
    INTEGER, INTENT(IN) :: hord_pert, nord_tr_pert
    LOGICAL, INTENT(IN) :: split_damp_tr
    INTEGER, INTENT(IN) :: q_split
    INTEGER, INTENT(IN) :: id_divg
    REAL, INTENT(IN) :: dt, trdm, trdm_pert
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: q_pack
    REAL, INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, nq)
    REAL, INTENT(INOUT) :: q_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz, nq)
    REAL, INTENT(INOUT) :: dp1(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: dp1_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL, INTENT(INOUT) :: mfx_ad(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL, INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
    REAL, INTENT(INOUT) :: mfy_ad(bd%is:bd%ie, bd%js:bd%je+1, npz)
    REAL, INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: cx_ad(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL, INTENT(INOUT) :: cy_ad(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL, OPTIONAL, INTENT(OUT) :: dpa(bd%is:bd%ie, bd%js:bd%je)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    REAL :: qn2(bd%isd:bd%ied, bd%jsd:bd%jed, nq)
    REAL :: qn2_ad(bd%isd:bd%ied, bd%jsd:bd%jed, nq)
    REAL :: dp2(bd%is:bd%ie, bd%js:bd%je)
    REAL :: dp2_ad(bd%is:bd%ie, bd%js:bd%je)
    REAL :: fx(bd%is:bd%ie+1, bd%js:bd%je)
    REAL :: fx_ad(bd%is:bd%ie+1, bd%js:bd%je)
    REAL :: fy(bd%is:bd%ie, bd%js:bd%je+1)
    REAL :: fy_ad(bd%is:bd%ie, bd%js:bd%je+1)
    REAL :: ra_x(bd%is:bd%ie, bd%jsd:bd%jed)
    REAL :: ra_x_ad(bd%is:bd%ie, bd%jsd:bd%jed)
    REAL :: ra_y(bd%isd:bd%ied, bd%js:bd%je)
    REAL :: ra_y_ad(bd%isd:bd%ied, bd%js:bd%je)
    REAL :: xfx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL :: xfx_ad(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL :: yfx(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL :: yfx_ad(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL :: cmax(npz)
    REAL :: frac
    INTEGER :: nsplt
    INTEGER :: i, j, k, it, iq
    REAL, DIMENSION(:, :), POINTER :: area, rarea
    REAL, DIMENSION(:, :, :), POINTER :: sin_sg
    REAL, DIMENSION(:, :), POINTER :: dxa, dya, dx, dy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC INT
    INTRINSIC REAL
    INTRINSIC PRESENT
    REAL :: max1
    REAL :: temp_ad
    REAL :: temp_ad0
    REAL :: temp_ad1
    REAL :: temp_ad2
    REAL :: temp_ad3
    REAL :: temp
    REAL :: temp_ad4
    REAL :: temp_ad5
    INTEGER :: branch
    INTEGER :: ad_to
    REAL :: x1
    REAL :: z1
    REAL :: y3
    REAL :: y2
    REAL :: y1
    CALL POPREAL4ARRAY(fy, (bd%ie-bd%is+1)*(bd%je-bd%js+2))
    CALL POPREAL4ARRAY(fx, (bd%ie-bd%is+2)*(bd%je-bd%js+1))
    CALL POPREAL4ARRAY(yfx, (bd%ied-bd%isd+1)*(bd%je-bd%js+2)*npz)
    CALL POPREAL4ARRAY(ra_y, (bd%ied-bd%isd+1)*(bd%je-bd%js+1))
    CALL POPREAL4ARRAY(ra_x, (bd%ie-bd%is+1)*(bd%jed-bd%jsd+1))
    CALL POPREAL4ARRAY(qn2, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*nq)
    CALL POPREAL4(frac)
    CALL POPREAL4ARRAY(dp2, (bd%ie-bd%is+1)*(bd%je-bd%js+1))
    CALL POPREAL4ARRAY(xfx, (bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*npz)
    js = bd%js
    rarea => gridstruct%rarea
    jsd = bd%jsd
    ied = bd%ied
    ie = bd%ie
    isd = bd%isd
    is = bd%is
    je = bd%je
    jed = bd%jed
    mfx_ad = 0.0
    mfy_ad = 0.0
    cx_ad = 0.0
    cy_ad = 0.0
    xfx_ad = 0.0
    dp2_ad = 0.0
    qn2_ad = 0.0
    ra_x_ad = 0.0
    ra_y_ad = 0.0
    yfx_ad = 0.0
    fx_ad = 0.0
    fy_ad = 0.0
    DO k=npz,1,-1
      CALL POPINTEGER4(ad_to)
      DO it=ad_to,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          CALL POPREAL4ARRAY(qn2, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*nq&
&                     )
          CALL MPP_UPDATE_DOMAINS_ADM(qn2, qn2_ad, domain)
          DO j=je,js,-1
            DO i=ie,is,-1
              CALL POPREAL4(dp1(i, j, k))
              dp2_ad(i, j) = dp2_ad(i, j) + dp1_ad(i, j, k)
              dp1_ad(i, j, k) = 0.0
            END DO
          END DO
        END IF
        DO iq=nq,1,-1
          CALL POPCONTROL2B(branch)
          IF (branch .EQ. 0) THEN
            DO j=je,js,-1
              DO i=ie,is,-1
                CALL POPREAL4(q(i, j, k, iq))
                temp_ad4 = q_ad(i, j, k, iq)/dp2(i, j)
                temp = q(i, j, k, iq)
                temp_ad5 = rarea(i, j)*temp_ad4
                dp1_ad(i, j, k) = dp1_ad(i, j, k) + temp*temp_ad4
                fx_ad(i, j) = fx_ad(i, j) + temp_ad5
                fx_ad(i+1, j) = fx_ad(i+1, j) - temp_ad5
                fy_ad(i, j) = fy_ad(i, j) + temp_ad5
                fy_ad(i, j+1) = fy_ad(i, j+1) - temp_ad5
                dp2_ad(i, j) = dp2_ad(i, j) - (temp*dp1(i, j, k)+rarea(i&
&                 , j)*(fx(i, j)-fx(i+1, j)+fy(i, j)-fy(i, j+1)))*&
&                 temp_ad4/dp2(i, j)
                q_ad(i, j, k, iq) = dp1(i, j, k)*temp_ad4
              END DO
            END DO
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL4ARRAY(q(isd:ied, jsd:jed, k, iq), (ied-isd+1)&
&                          *(jed-jsd+1))
              CALL POPREAL4ARRAY(fx, (bd%ie-bd%is+2)*(bd%je-bd%js+1))
              CALL POPREAL4ARRAY(fy, (bd%ie-bd%is+1)*(bd%je-bd%js+2))
              CALL FV_TP_2D_ADM(q(isd:ied, jsd:jed, k, iq), q_ad(isd:ied&
&                         , jsd:jed, k, iq), cx(is:ie+1, jsd:jed, k), &
&                         cx_ad(is:ie+1, jsd:jed, k), cy(isd:ied, js:je+&
&                         1, k), cy_ad(isd:ied, js:je+1, k), npx, npy, &
&                         hord_pert, fx, fx_ad, fy, fy_ad, xfx(is:ie+1, &
&                         jsd:jed, k), xfx_ad(is:ie+1, jsd:jed, k), yfx(&
&                         isd:ied, js:je+1, k), yfx_ad(isd:ied, js:je+1&
&                         , k), gridstruct, bd, ra_x, ra_x_ad, ra_y, &
&                         ra_y_ad, mfx(is:ie+1, js:je, k), mfx_ad(is:ie+&
&                         1, js:je, k), mfy(is:ie, js:je+1, k), mfy_ad(&
&                         is:ie, js:je+1, k))
            ELSE
              CALL FV_TP_2D_BWD(q(isd:ied, jsd:jed, k, iq), q_ad(isd:&
&                            ied, jsd:jed, k, iq), cx(is:ie+1, jsd:jed, &
&                            k), cx_ad(is:ie+1, jsd:jed, k), cy(isd:ied&
&                            , js:je+1, k), cy_ad(isd:ied, js:je+1, k), &
&                            npx, npy, hord, fx, fx_ad, fy, fy_ad, xfx(&
&                            is:ie+1, jsd:jed, k), xfx_ad(is:ie+1, jsd:&
&                            jed, k), yfx(isd:ied, js:je+1, k), yfx_ad(&
&                            isd:ied, js:je+1, k), gridstruct, bd, ra_x&
&                            , ra_x_ad, ra_y, ra_y_ad, mfx(is:ie+1, js:&
&                            je, k), mfx_ad(is:ie+1, js:je, k), mfy(is:&
&                            ie, js:je+1, k), mfy_ad(is:ie, js:je+1, k))
            END IF
          ELSE
            IF (branch .EQ. 1) THEN
              DO j=je,js,-1
                DO i=ie,is,-1
                  CALL POPREAL4(q(i, j, k, iq))
                  temp_ad2 = q_ad(i, j, k, iq)/dp2(i, j)
                  temp_ad3 = rarea(i, j)*temp_ad2
                  qn2_ad(i, j, iq) = qn2_ad(i, j, iq) + dp1(i, j, k)*&
&                   temp_ad2
                  dp1_ad(i, j, k) = dp1_ad(i, j, k) + qn2(i, j, iq)*&
&                   temp_ad2
                  fx_ad(i, j) = fx_ad(i, j) + temp_ad3
                  fx_ad(i+1, j) = fx_ad(i+1, j) - temp_ad3
                  fy_ad(i, j) = fy_ad(i, j) + temp_ad3
                  fy_ad(i, j+1) = fy_ad(i, j+1) - temp_ad3
                  dp2_ad(i, j) = dp2_ad(i, j) - (qn2(i, j, iq)*dp1(i, j&
&                   , k)+rarea(i, j)*(fx(i, j)-fx(i+1, j)+fy(i, j)-fy(i&
&                   , j+1)))*temp_ad2/dp2(i, j)
                  q_ad(i, j, k, iq) = 0.0
                END DO
              END DO
            ELSE
              DO j=je,js,-1
                DO i=ie,is,-1
                  CALL POPREAL4(qn2(i, j, iq))
                  temp_ad0 = qn2_ad(i, j, iq)/dp2(i, j)
                  temp_ad1 = rarea(i, j)*temp_ad0
                  dp1_ad(i, j, k) = dp1_ad(i, j, k) + qn2(i, j, iq)*&
&                   temp_ad0
                  fx_ad(i, j) = fx_ad(i, j) + temp_ad1
                  fx_ad(i+1, j) = fx_ad(i+1, j) - temp_ad1
                  fy_ad(i, j) = fy_ad(i, j) + temp_ad1
                  fy_ad(i, j+1) = fy_ad(i, j+1) - temp_ad1
                  dp2_ad(i, j) = dp2_ad(i, j) - (qn2(i, j, iq)*dp1(i, j&
&                   , k)+rarea(i, j)*(fx(i, j)-fx(i+1, j)+fy(i, j)-fy(i&
&                   , j+1)))*temp_ad0/dp2(i, j)
                  qn2_ad(i, j, iq) = dp1(i, j, k)*temp_ad0
                END DO
              END DO
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL FV_TP_2D_BWD(qn2(isd:ied, jsd:jed, iq), qn2_ad(isd&
&                            :ied, jsd:jed, iq), cx(is:ie+1, jsd:jed, k)&
&                            , cx_ad(is:ie+1, jsd:jed, k), cy(isd:ied, &
&                            js:je+1, k), cy_ad(isd:ied, js:je+1, k), &
&                            npx, npy, hord, fx, fx_ad, fy, fy_ad, xfx(&
&                            is:ie+1, jsd:jed, k), xfx_ad(is:ie+1, jsd:&
&                            jed, k), yfx(isd:ied, js:je+1, k), yfx_ad(&
&                            isd:ied, js:je+1, k), gridstruct, bd, ra_x&
&                            , ra_x_ad, ra_y, ra_y_ad, mfx(is:ie+1, js:&
&                            je, k), mfx_ad(is:ie+1, js:je, k), mfy(is:&
&                            ie, js:je+1, k), mfy_ad(is:ie, js:je+1, k))
            ELSE
              CALL POPREAL4ARRAY(qn2(isd:ied, jsd:jed, iq), (ied-isd+1)*&
&                          (jed-jsd+1))
              CALL POPREAL4ARRAY(fx, (bd%ie-bd%is+2)*(bd%je-bd%js+1))
              CALL POPREAL4ARRAY(fy, (bd%ie-bd%is+1)*(bd%je-bd%js+2))
              CALL FV_TP_2D_ADM(qn2(isd:ied, jsd:jed, iq), qn2_ad(isd:&
&                         ied, jsd:jed, iq), cx(is:ie+1, jsd:jed, k), &
&                         cx_ad(is:ie+1, jsd:jed, k), cy(isd:ied, js:je+&
&                         1, k), cy_ad(isd:ied, js:je+1, k), npx, npy, &
&                         hord_pert, fx, fx_ad, fy, fy_ad, xfx(is:ie+1, &
&                         jsd:jed, k), xfx_ad(is:ie+1, jsd:jed, k), yfx(&
&                         isd:ied, js:je+1, k), yfx_ad(isd:ied, js:je+1&
&                         , k), gridstruct, bd, ra_x, ra_x_ad, ra_y, &
&                         ra_y_ad, mfx(is:ie+1, js:je, k), mfx_ad(is:ie+&
&                         1, js:je, k), mfy(is:ie, js:je+1, k), mfy_ad(&
&                         is:ie, js:je+1, k))
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              DO j=jed,jsd,-1
                DO i=ied,isd,-1
                  CALL POPREAL4(qn2(i, j, iq))
                  q_ad(i, j, k, iq) = q_ad(i, j, k, iq) + qn2_ad(i, j, &
&                   iq)
                  qn2_ad(i, j, iq) = 0.0
                END DO
              END DO
            END IF
          END IF
        END DO
        DO j=je,js,-1
          DO i=ie,is,-1
            CALL POPREAL4(dp2(i, j))
            temp_ad = rarea(i, j)*dp2_ad(i, j)
            dp1_ad(i, j, k) = dp1_ad(i, j, k) + dp2_ad(i, j)
            mfx_ad(i, j, k) = mfx_ad(i, j, k) + temp_ad
            mfx_ad(i+1, j, k) = mfx_ad(i+1, j, k) - temp_ad
            mfy_ad(i, j, k) = mfy_ad(i, j, k) + temp_ad
            mfy_ad(i, j+1, k) = mfy_ad(i, j+1, k) - temp_ad
            dp2_ad(i, j) = 0.0
          END DO
        END DO
      END DO
      DO j=jed,jsd,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          DO i=ied,isd,-1
            CALL POPREAL4(ra_y(i, j))
            yfx_ad(i, j, k) = yfx_ad(i, j, k) + ra_y_ad(i, j)
            yfx_ad(i, j+1, k) = yfx_ad(i, j+1, k) - ra_y_ad(i, j)
            ra_y_ad(i, j) = 0.0
          END DO
        END IF
        DO i=ie,is,-1
          CALL POPREAL4(ra_x(i, j))
          xfx_ad(i, j, k) = xfx_ad(i, j, k) + ra_x_ad(i, j)
          xfx_ad(i+1, j, k) = xfx_ad(i+1, j, k) - ra_x_ad(i, j)
          ra_x_ad(i, j) = 0.0
        END DO
      END DO
    END DO
    DO k=npz,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        DO j=je+1,js,-1
          DO i=ie,is,-1
            CALL POPREAL4(mfy(i, j, k))
            mfy_ad(i, j, k) = frac*mfy_ad(i, j, k)
          END DO
        END DO
        DO j=je+1,js,-1
          DO i=ied,isd,-1
            yfx_ad(i, j, k) = frac*yfx_ad(i, j, k)
            CALL POPREAL4(cy(i, j, k))
            cy_ad(i, j, k) = frac*cy_ad(i, j, k)
          END DO
        END DO
        DO j=je,js,-1
          DO i=ie+1,is,-1
            CALL POPREAL4(mfx(i, j, k))
            mfx_ad(i, j, k) = frac*mfx_ad(i, j, k)
          END DO
        END DO
        DO j=jed,jsd,-1
          DO i=ie+1,is,-1
            xfx_ad(i, j, k) = frac*xfx_ad(i, j, k)
            CALL POPREAL4(cx(i, j, k))
            cx_ad(i, j, k) = frac*cx_ad(i, j, k)
          END DO
        END DO
        CALL POPREAL4(frac)
      END IF
    END DO
    dxa => gridstruct%dxa
    dx => gridstruct%dx
    dy => gridstruct%dy
    sin_sg => gridstruct%sin_sg
    dya => gridstruct%dya
    DO k=npz,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO j=je,js,-1
          DO i=ie,is,-1
            CALL POPCONTROL1B(branch)
          END DO
        END DO
      ELSE
        DO j=je,js,-1
          DO i=ie,is,-1
            CALL POPCONTROL2B(branch)
          END DO
        END DO
      END IF
      DO j=je+1,js,-1
        DO i=ied,isd,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            cy_ad(i, j, k) = cy_ad(i, j, k) + dya(i, j)*dx(i, j)*sin_sg(&
&             i, j, 2)*yfx_ad(i, j, k)
            yfx_ad(i, j, k) = 0.0
          ELSE
            cy_ad(i, j, k) = cy_ad(i, j, k) + dya(i, j-1)*dx(i, j)*&
&             sin_sg(i, j-1, 4)*yfx_ad(i, j, k)
            yfx_ad(i, j, k) = 0.0
          END IF
        END DO
      END DO
      DO j=jed,jsd,-1
        DO i=ie+1,is,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            cx_ad(i, j, k) = cx_ad(i, j, k) + dxa(i, j)*dy(i, j)*sin_sg(&
&             i, j, 1)*xfx_ad(i, j, k)
            xfx_ad(i, j, k) = 0.0
          ELSE
            cx_ad(i, j, k) = cx_ad(i, j, k) + dxa(i-1, j)*dy(i, j)*&
&             sin_sg(i-1, j, 3)*xfx_ad(i, j, k)
            xfx_ad(i, j, k) = 0.0
          END IF
        END DO
      END DO
    END DO
  END SUBROUTINE TRACER_2D_1L_BWD
!-----------------------------------------------------------------------
! !ROUTINE: Perform 2D horizontal-to-lagrangian transport
!-----------------------------------------------------------------------
  SUBROUTINE TRACER_2D_1L(q, dp1, mfx, mfy, cx, cy, gridstruct, bd, &
&   domain, npx, npy, npz, nq, hord, q_split, dt, id_divg, q_pack, &
&   nord_tr, trdm, hord_pert, nord_tr_pert, trdm_pert, split_damp_tr, &
&   dpa)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
! number of tracers to be advected
    INTEGER, INTENT(IN) :: nq
    INTEGER, INTENT(IN) :: hord, nord_tr
    INTEGER, INTENT(IN) :: hord_pert, nord_tr_pert
    LOGICAL, INTENT(IN) :: split_damp_tr
    INTEGER, INTENT(IN) :: q_split
    INTEGER, INTENT(IN) :: id_divg
    REAL, INTENT(IN) :: dt, trdm, trdm_pert
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: q_pack
! Tracers
    REAL, INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, nq)
! DELP before dyn_core
    REAL, INTENT(INOUT) :: dp1(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! Mass Flux X-Dir
    REAL, INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
! Mass Flux Y-Dir
    REAL, INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
! Courant Number X-Dir
    REAL, INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
! Courant Number Y-Dir
    REAL, INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
! DELP after advection
    REAL, OPTIONAL, INTENT(OUT) :: dpa(bd%is:bd%ie, bd%js:bd%je)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
! Local Arrays
! 3D tracers
    REAL :: qn2(bd%isd:bd%ied, bd%jsd:bd%jed, nq)
    REAL :: dp2(bd%is:bd%ie, bd%js:bd%je)
    REAL :: fx(bd%is:bd%ie+1, bd%js:bd%je)
    REAL :: fy(bd%is:bd%ie, bd%js:bd%je+1)
    REAL :: ra_x(bd%is:bd%ie, bd%jsd:bd%jed)
    REAL :: ra_y(bd%isd:bd%ied, bd%js:bd%je)
    REAL :: xfx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL :: yfx(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL :: cmax(npz)
    REAL :: frac
    INTEGER :: nsplt
    INTEGER :: i, j, k, it, iq
    REAL, DIMENSION(:, :), POINTER :: area, rarea
    REAL, DIMENSION(:, :, :), POINTER :: sin_sg
    REAL, DIMENSION(:, :), POINTER :: dxa, dya, dx, dy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC INT
    INTRINSIC REAL
    INTRINSIC PRESENT
    REAL :: max1
    REAL :: x1
    REAL :: z1
    REAL :: y3
    REAL :: y2
    REAL :: y1
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    area => gridstruct%area
    rarea => gridstruct%rarea
    sin_sg => gridstruct%sin_sg
    dxa => gridstruct%dxa
    dya => gridstruct%dya
    dx => gridstruct%dx
    dy => gridstruct%dy
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,jsd,jed,npz,cx,xfx,dxa,dy, &
!$OMP                                  sin_sg,cy,yfx,dya,dx,cmax)
    DO k=1,npz
      DO j=jsd,jed
        DO i=is,ie+1
          IF (cx(i, j, k) .GT. 0.) THEN
            xfx(i, j, k) = cx(i, j, k)*dxa(i-1, j)*dy(i, j)*sin_sg(i-1, &
&             j, 3)
          ELSE
            xfx(i, j, k) = cx(i, j, k)*dxa(i, j)*dy(i, j)*sin_sg(i, j, 1&
&             )
          END IF
        END DO
      END DO
      DO j=js,je+1
        DO i=isd,ied
          IF (cy(i, j, k) .GT. 0.) THEN
            yfx(i, j, k) = cy(i, j, k)*dya(i, j-1)*dx(i, j)*sin_sg(i, j-&
&             1, 4)
          ELSE
            yfx(i, j, k) = cy(i, j, k)*dya(i, j)*dx(i, j)*sin_sg(i, j, 2&
&             )
          END IF
        END DO
      END DO
      cmax(k) = 0.
      IF (k .LT. npz/6) THEN
        DO j=js,je
          DO i=is,ie
            IF (cx(i, j, k) .GE. 0.) THEN
              y1 = cx(i, j, k)
            ELSE
              y1 = -cx(i, j, k)
            END IF
            IF (cy(i, j, k) .GE. 0.) THEN
              z1 = cy(i, j, k)
            ELSE
              z1 = -cy(i, j, k)
            END IF
            IF (cmax(k) .LT. y1) THEN
              IF (y1 .LT. z1) THEN
                cmax(k) = z1
              ELSE
                cmax(k) = y1
              END IF
            ELSE IF (cmax(k) .LT. z1) THEN
              cmax(k) = z1
            ELSE
              cmax(k) = cmax(k)
            END IF
          END DO
        END DO
      ELSE
        DO j=js,je
          DO i=is,ie
            IF (cx(i, j, k) .GE. 0.) THEN
              x1 = cx(i, j, k)
            ELSE
              x1 = -cx(i, j, k)
            END IF
            IF (cy(i, j, k) .GE. 0.) THEN
              y3 = cy(i, j, k)
            ELSE
              y3 = -cy(i, j, k)
            END IF
            IF (x1 .LT. y3) THEN
              max1 = y3
            ELSE
              max1 = x1
            END IF
            y2 = max1 + 1. - sin_sg(i, j, 5)
            IF (cmax(k) .LT. y2) THEN
              cmax(k) = y2
            ELSE
              cmax(k) = cmax(k)
            END IF
          END DO
        END DO
      END IF
    END DO
! k-loop
    CALL MP_REDUCE_MAX(cmax, npz)
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,jsd,jed,npz,cx,xfx, &
!$OMP                                  cy,yfx,mfx,mfy,cmax)   &
!$OMP                          private(nsplt, frac)
    DO k=1,npz
      nsplt = INT(1. + cmax(k))
      IF (nsplt .GT. 1) THEN
        frac = 1./REAL(nsplt)
        DO j=jsd,jed
          DO i=is,ie+1
            cx(i, j, k) = cx(i, j, k)*frac
            xfx(i, j, k) = xfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je
          DO i=is,ie+1
            mfx(i, j, k) = mfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je+1
          DO i=isd,ied
            cy(i, j, k) = cy(i, j, k)*frac
            yfx(i, j, k) = yfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je+1
          DO i=is,ie
            mfy(i, j, k) = mfy(i, j, k)*frac
          END DO
        END DO
      END IF
    END DO
    CALL TIMING_ON('COMM_TOTAL')
    CALL TIMING_ON('COMM_TRACER')
    CALL COMPLETE_GROUP_HALO_UPDATE(q_pack, domain)
    CALL TIMING_OFF('COMM_TRACER')
    CALL TIMING_OFF('COMM_TOTAL')
! Begin k-independent tracer transport; can not be OpenMPed because the mpp_update call.
    DO k=1,npz
!$OMP parallel do default(none) shared(k,is,ie,js,je,isd,ied,jsd,jed,xfx,area,yfx,ra_x,ra_y)
      DO j=jsd,jed
        DO i=is,ie
          ra_x(i, j) = area(i, j) + xfx(i, j, k) - xfx(i+1, j, k)
        END DO
        IF (j .GE. js .AND. j .LE. je) THEN
          DO i=isd,ied
            ra_y(i, j) = area(i, j) + yfx(i, j, k) - yfx(i, j+1, k)
          END DO
        END IF
      END DO
      nsplt = INT(1. + cmax(k))
      DO it=1,nsplt
!$OMP parallel do default(none) shared(k,is,ie,js,je,rarea,mfx,mfy,dp1,dp2)
        DO j=js,je
          DO i=is,ie
            dp2(i, j) = dp1(i, j, k) + (mfx(i, j, k)-mfx(i+1, j, k)+mfy(&
&             i, j, k)-mfy(i, j+1, k))*rarea(i, j)
          END DO
        END DO
!$OMP parallel do default(none) shared(k,nsplt,it,is,ie,js,je,isd,ied,jsd,jed,npx,npy,cx,xfx,hord,trdm, &
!$OMP                                  nord_tr,nq,gridstruct,bd,cy,yfx,mfx,mfy,qn2,q,ra_x,ra_y,dp1,dp2,rarea) &
!$OMP                          private(fx,fy)
        DO iq=1,nq
          IF (nsplt .NE. 1) THEN
            IF (it .EQ. 1) THEN
              DO j=jsd,jed
                DO i=isd,ied
                  qn2(i, j, iq) = q(i, j, k, iq)
                END DO
              END DO
            END IF
            IF (hord .EQ. hord_pert) THEN
              CALL FV_TP_2D(qn2(isd:ied, jsd:jed, iq), cx(is:ie+1, &
&                        jsd:jed, k), cy(isd:ied, js:je+1, k), npx, npy&
&                        , hord, fx, fy, xfx(is:ie+1, jsd:jed, k), yfx(&
&                        isd:ied, js:je+1, k), gridstruct, bd, ra_x, &
&                        ra_y, mfx=mfx(is:ie+1, js:je, k), mfy=mfy(is:ie&
&                        , js:je+1, k))
            ELSE
              CALL FV_TP_2D(qn2(isd:ied, jsd:jed, iq), cx(is:ie+1, jsd:&
&                     jed, k), cy(isd:ied, js:je+1, k), npx, npy, &
&                     hord_pert, fx, fy, xfx(is:ie+1, jsd:jed, k), yfx(&
&                     isd:ied, js:je+1, k), gridstruct, bd, ra_x, ra_y, &
&                     mfx=mfx(is:ie+1, js:je, k), mfy=mfy(is:ie, js:je+1&
&                     , k))
            END IF
            IF (it .LT. nsplt) THEN
! not last call
              DO j=js,je
                DO i=is,ie
                  qn2(i, j, iq) = (qn2(i, j, iq)*dp1(i, j, k)+(fx(i, j)-&
&                   fx(i+1, j)+fy(i, j)-fy(i, j+1))*rarea(i, j))/dp2(i, &
&                   j)
                END DO
              END DO
            ELSE
              DO j=js,je
                DO i=is,ie
                  q(i, j, k, iq) = (qn2(i, j, iq)*dp1(i, j, k)+(fx(i, j)&
&                   -fx(i+1, j)+fy(i, j)-fy(i, j+1))*rarea(i, j))/dp2(i&
&                   , j)
                END DO
              END DO
            END IF
          ELSE
            IF (hord .EQ. hord_pert) THEN
              CALL FV_TP_2D(q(isd:ied, jsd:jed, k, iq), cx(is:ie+1, &
&                        jsd:jed, k), cy(isd:ied, js:je+1, k), npx, npy&
&                        , hord, fx, fy, xfx(is:ie+1, jsd:jed, k), yfx(&
&                        isd:ied, js:je+1, k), gridstruct, bd, ra_x, &
&                        ra_y, mfx=mfx(is:ie+1, js:je, k), mfy=mfy(is:ie&
&                        , js:je+1, k))
            ELSE
              CALL FV_TP_2D(q(isd:ied, jsd:jed, k, iq), cx(is:ie+1, jsd:&
&                     jed, k), cy(isd:ied, js:je+1, k), npx, npy, &
&                     hord_pert, fx, fy, xfx(is:ie+1, jsd:jed, k), yfx(&
&                     isd:ied, js:je+1, k), gridstruct, bd, ra_x, ra_y, &
&                     mfx=mfx(is:ie+1, js:je, k), mfy=mfy(is:ie, js:je+1&
&                     , k))
            END IF
            DO j=js,je
              DO i=is,ie
                q(i, j, k, iq) = (q(i, j, k, iq)*dp1(i, j, k)+(fx(i, j)-&
&                 fx(i+1, j)+fy(i, j)-fy(i, j+1))*rarea(i, j))/dp2(i, j)
              END DO
            END DO
          END IF
        END DO
!  tracer-loop
        IF (it .LT. nsplt) THEN
! not last call
          DO j=js,je
            DO i=is,ie
              dp1(i, j, k) = dp2(i, j)
            END DO
          END DO
          CALL TIMING_ON('COMM_TOTAL')
          CALL TIMING_ON('COMM_TRACER')
          CALL MPP_UPDATE_DOMAINS(qn2, domain)
          CALL TIMING_OFF('COMM_TRACER')
          CALL TIMING_OFF('COMM_TOTAL')
        END IF
      END DO
    END DO
! time-split loop
! k-loop
    IF (PRESENT(dpa)) dpa = dp2
  END SUBROUTINE TRACER_2D_1L
!  Differentiation of tracer_2d in reverse (adjoint) mode, forward sweep (with options split(a2b_edge_mod.a2b_ord4 a2b_edge_mo
!d.a2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_m
!od.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mod.mi
!x_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayleigh_
!Super fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_geos fv_g
!rid_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_mapz_m
!od.compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_
!tracer_fb fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_lim
!iters fv_mapz_mod.ppm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.mo
!ist_cv fv_mapz_mod.moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer_
!2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.Riem
!_Solver_c nh_utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SIM3p0
!_solver nh_utils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nest_ha
!lo_nh sw_core_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_vect
! sw_core_mod.fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v sw_co
!re_mod.compute_divergence_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_core_mod.
!fv_tp_2d tp_core_mod.copy_corners tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_cor
!ner_fb fv_grid_utils_mod.great_circle_dist sw_core_mod.edge_interpolate4)):
!   gradient     of useful results: q dp1
!   with respect to varying inputs: q dp1 mfx mfy cx cy
  SUBROUTINE TRACER_2D_FWD(q, dp1, mfx, mfy, cx, cy, gridstruct, bd, &
&   domain, npx, npy, npz, nq, hord, q_split, dt, id_divg, q_pack, &
&   nord_tr, trdm, hord_pert, nord_tr_pert, trdm_pert, split_damp_tr, &
&   dpa)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
! number of tracers to be advected
    INTEGER, INTENT(IN) :: nq
    INTEGER, INTENT(IN) :: hord, nord_tr
    INTEGER, INTENT(IN) :: hord_pert, nord_tr_pert
    LOGICAL, INTENT(IN) :: split_damp_tr
    INTEGER, INTENT(IN) :: q_split
    INTEGER, INTENT(IN) :: id_divg
    REAL, INTENT(IN) :: dt, trdm, trdm_pert
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: q_pack
! Tracers
    REAL, INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, nq)
! DELP before dyn_core
    REAL, INTENT(INOUT) :: dp1(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! Mass Flux X-Dir
    REAL, INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
! Mass Flux Y-Dir
    REAL, INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
! Courant Number X-Dir
    REAL, INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
! Courant Number Y-Dir
    REAL, INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
! DELP after advection
    REAL, OPTIONAL, INTENT(OUT) :: dpa(bd%is:bd%ie, bd%js:bd%je, npz)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
! Local Arrays
    REAL :: dp2(bd%is:bd%ie, bd%js:bd%je)
    REAL :: fx(bd%is:bd%ie+1, bd%js:bd%je)
    REAL :: fy(bd%is:bd%ie, bd%js:bd%je+1)
    REAL :: ra_x(bd%is:bd%ie, bd%jsd:bd%jed)
    REAL :: ra_y(bd%isd:bd%ied, bd%js:bd%je)
    REAL :: xfx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL :: yfx(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL :: cmax(npz)
    REAL :: c_global
    REAL :: frac, rdt
    INTEGER :: ksplt(npz)
    INTEGER :: nsplt
    INTEGER :: i, j, k, it, iq
    REAL, DIMENSION(:, :), POINTER :: area, rarea
    REAL, DIMENSION(:, :, :), POINTER :: sin_sg
    REAL, DIMENSION(:, :), POINTER :: dxa, dya, dx, dy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC INT
    INTRINSIC REAL
    INTRINSIC PRESENT
    REAL :: max1
    LOGICAL :: res
    REAL :: x1
    REAL :: z1
    REAL :: y3
    REAL :: y2
    REAL :: y1
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    area => gridstruct%area
    rarea => gridstruct%rarea
    sin_sg => gridstruct%sin_sg
    dxa => gridstruct%dxa
    dya => gridstruct%dya
    dx => gridstruct%dx
    dy => gridstruct%dy
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,jsd,jed,npz,cx,xfx,dxa,dy, &
!$OMP                                  sin_sg,cy,yfx,dya,dx,cmax,q_split,ksplt)
    DO k=1,npz
      DO j=jsd,jed
        DO i=is,ie+1
          IF (cx(i, j, k) .GT. 0.) THEN
            xfx(i, j, k) = cx(i, j, k)*dxa(i-1, j)*dy(i, j)*sin_sg(i-1, &
&             j, 3)
            CALL PUSHCONTROL1B(1)
          ELSE
            xfx(i, j, k) = cx(i, j, k)*dxa(i, j)*dy(i, j)*sin_sg(i, j, 1&
&             )
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      DO j=js,je+1
        DO i=isd,ied
          IF (cy(i, j, k) .GT. 0.) THEN
            yfx(i, j, k) = cy(i, j, k)*dya(i, j-1)*dx(i, j)*sin_sg(i, j-&
&             1, 4)
            CALL PUSHCONTROL1B(1)
          ELSE
            yfx(i, j, k) = cy(i, j, k)*dya(i, j)*dx(i, j)*sin_sg(i, j, 2&
&             )
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      IF (q_split .EQ. 0) THEN
        cmax(k) = 0.
        IF (k .LT. npz/6) THEN
          DO j=js,je
            DO i=is,ie
              IF (cx(i, j, k) .GE. 0.) THEN
                y1 = cx(i, j, k)
              ELSE
                y1 = -cx(i, j, k)
              END IF
              IF (cy(i, j, k) .GE. 0.) THEN
                z1 = cy(i, j, k)
              ELSE
                z1 = -cy(i, j, k)
              END IF
              IF (cmax(k) .LT. y1) THEN
                IF (y1 .LT. z1) THEN
                  CALL PUSHCONTROL2B(0)
                  cmax(k) = z1
                ELSE
                  CALL PUSHCONTROL2B(1)
                  cmax(k) = y1
                END IF
              ELSE IF (cmax(k) .LT. z1) THEN
                CALL PUSHCONTROL2B(2)
                cmax(k) = z1
              ELSE
                CALL PUSHCONTROL2B(3)
                cmax(k) = cmax(k)
              END IF
            END DO
          END DO
          CALL PUSHCONTROL2B(0)
        ELSE
          DO j=js,je
            DO i=is,ie
              IF (cx(i, j, k) .GE. 0.) THEN
                x1 = cx(i, j, k)
              ELSE
                x1 = -cx(i, j, k)
              END IF
              IF (cy(i, j, k) .GE. 0.) THEN
                y3 = cy(i, j, k)
              ELSE
                y3 = -cy(i, j, k)
              END IF
              IF (x1 .LT. y3) THEN
                max1 = y3
              ELSE
                max1 = x1
              END IF
              y2 = max1 + 1. - sin_sg(i, j, 5)
              IF (cmax(k) .LT. y2) THEN
                CALL PUSHCONTROL1B(0)
                cmax(k) = y2
              ELSE
                CALL PUSHCONTROL1B(1)
                cmax(k) = cmax(k)
              END IF
            END DO
          END DO
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(2)
      END IF
      ksplt(k) = 1
    END DO
!--------------------------------------------------------------------------------
! Determine global nsplt:
    IF (q_split .EQ. 0) THEN
      CALL MP_REDUCE_MAX(cmax, npz)
! find global max courant number and define nsplt to scale cx,cy,mfx,mfy
      c_global = cmax(1)
      IF (npz .NE. 1) THEN
! if NOT shallow water test case
        DO k=2,npz
          IF (cmax(k) .LT. c_global) THEN
            CALL PUSHCONTROL1B(0)
            c_global = c_global
          ELSE
            CALL PUSHCONTROL1B(1)
            c_global = cmax(k)
          END IF
        END DO
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      nsplt = INT(1. + c_global)
      res = IS_MASTER()
      IF (res .AND. nsplt .GT. 4) THEN
        CALL PUSHCONTROL1B(0)
        WRITE(*, *) 'Tracer_2d_split=', nsplt, c_global
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    ELSE
      CALL PUSHCONTROL1B(1)
      nsplt = q_split
    END IF
!--------------------------------------------------------------------------------
    IF (nsplt .NE. 1) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,jsd,jed,npz,cx,xfx,mfx,cy,yfx,mfy,cmax,nsplt,ksplt) &
!$OMP                          private( frac )
      DO k=1,npz
        ksplt(k) = INT(1. + cmax(k))
        CALL PUSHREAL4(frac)
        frac = 1./REAL(ksplt(k))
        DO j=jsd,jed
          DO i=is,ie+1
            CALL PUSHREAL4(cx(i, j, k))
            cx(i, j, k) = cx(i, j, k)*frac
            xfx(i, j, k) = xfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je
          DO i=is,ie+1
            CALL PUSHREAL4(mfx(i, j, k))
            mfx(i, j, k) = mfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je+1
          DO i=isd,ied
            CALL PUSHREAL4(cy(i, j, k))
            cy(i, j, k) = cy(i, j, k)*frac
            yfx(i, j, k) = yfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je+1
          DO i=is,ie
            CALL PUSHREAL4(mfy(i, j, k))
            mfy(i, j, k) = mfy(i, j, k)*frac
          END DO
        END DO
      END DO
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    DO it=1,nsplt
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,jsd,jed,npz,dp1,mfx,mfy,rarea,nq,ksplt,&
!$OMP                                  area,xfx,yfx,q,cx,cy,npx,npy,hord,gridstruct,bd,it,nsplt,nord_tr,trdm) &
!$OMP                          private(dp2, ra_x, ra_y, fx, fy)
      DO k=1,npz
! ksplt
        IF (it .LE. ksplt(k)) THEN
          DO j=js,je
            DO i=is,ie
              CALL PUSHREAL4(dp2(i, j))
              dp2(i, j) = dp1(i, j, k) + (mfx(i, j, k)-mfx(i+1, j, k)+&
&               mfy(i, j, k)-mfy(i, j+1, k))*rarea(i, j)
            END DO
          END DO
          DO j=jsd,jed
            DO i=is,ie
              CALL PUSHREAL4(ra_x(i, j))
              ra_x(i, j) = area(i, j) + xfx(i, j, k) - xfx(i+1, j, k)
            END DO
          END DO
          DO j=js,je
            DO i=isd,ied
              CALL PUSHREAL4(ra_y(i, j))
              ra_y(i, j) = area(i, j) + yfx(i, j, k) - yfx(i, j+1, k)
            END DO
          END DO
          DO iq=1,nq
            IF (hord .EQ. hord_pert .AND. (.NOT.split_damp_tr)) THEN
              IF (it .EQ. 1 .AND. trdm .GT. 1.e-4) THEN
                CALL FV_TP_2D_FWD(q(isd:ied, jsd:jed, k, iq), cx(is:&
&                              ie+1, jsd:jed, k), cy(isd:ied, js:je+1, k&
&                              ), npx, npy, hord, fx, fy, xfx(is:ie+1, &
&                              jsd:jed, k), yfx(isd:ied, js:je+1, k), &
&                              gridstruct, bd, ra_x, ra_y, mfx=mfx(is:ie&
&                              +1, js:je, k), mfy=mfy(is:ie, js:je+1, k)&
&                              , mass=dp1(isd:ied, jsd:jed, k), nord=&
&                              nord_tr, damp_c=trdm)
                CALL PUSHCONTROL2B(3)
              ELSE
                CALL FV_TP_2D_FWD(q(isd:ied, jsd:jed, k, iq), cx(is:&
&                              ie+1, jsd:jed, k), cy(isd:ied, js:je+1, k&
&                              ), npx, npy, hord, fx, fy, xfx(is:ie+1, &
&                              jsd:jed, k), yfx(isd:ied, js:je+1, k), &
&                              gridstruct, bd, ra_x, ra_y, mfx=mfx(is:ie&
&                              +1, js:je, k), mfy=mfy(is:ie, js:je+1, k)&
&                             )
                CALL PUSHCONTROL2B(2)
              END IF
            ELSE IF (it .EQ. 1 .AND. trdm_pert .GT. 1.e-4) THEN
              CALL PUSHREAL4ARRAY(fy, (bd%ie-bd%is+1)*(bd%je-bd%js+2))
              CALL PUSHREAL4ARRAY(fx, (bd%ie-bd%is+2)*(bd%je-bd%js+1))
              CALL PUSHREAL4ARRAY(q(isd:ied, jsd:jed, k, iq), (ied-isd+1&
&                           )*(jed-jsd+1))
              CALL FV_TP_2D(q(isd:ied, jsd:jed, k, iq), cx(is:ie+1, jsd:&
&                     jed, k), cy(isd:ied, js:je+1, k), npx, npy, &
&                     hord_pert, fx, fy, xfx(is:ie+1, jsd:jed, k), yfx(&
&                     isd:ied, js:je+1, k), gridstruct, bd, ra_x, ra_y, &
&                     mfx=mfx(is:ie+1, js:je, k), mfy=mfy(is:ie, js:je+1&
&                     , k), mass=dp1(isd:ied, jsd:jed, k), nord=&
&                     nord_tr_pert, damp_c=trdm_pert)
              CALL PUSHCONTROL2B(1)
            ELSE
              CALL PUSHREAL4ARRAY(fy, (bd%ie-bd%is+1)*(bd%je-bd%js+2))
              CALL PUSHREAL4ARRAY(fx, (bd%ie-bd%is+2)*(bd%je-bd%js+1))
              CALL PUSHREAL4ARRAY(q(isd:ied, jsd:jed, k, iq), (ied-isd+1&
&                           )*(jed-jsd+1))
              CALL FV_TP_2D(q(isd:ied, jsd:jed, k, iq), cx(is:ie+1, jsd:&
&                     jed, k), cy(isd:ied, js:je+1, k), npx, npy, &
&                     hord_pert, fx, fy, xfx(is:ie+1, jsd:jed, k), yfx(&
&                     isd:ied, js:je+1, k), gridstruct, bd, ra_x, ra_y, &
&                     mfx=mfx(is:ie+1, js:je, k), mfy=mfy(is:ie, js:je+1&
&                     , k))
              CALL PUSHCONTROL2B(0)
            END IF
            DO j=js,je
              DO i=is,ie
                CALL PUSHREAL4(q(i, j, k, iq))
                q(i, j, k, iq) = (q(i, j, k, iq)*dp1(i, j, k)+(fx(i, j)-&
&                 fx(i+1, j)+fy(i, j)-fy(i, j+1))*rarea(i, j))/dp2(i, j)
              END DO
            END DO
          END DO
          IF (it .NE. nsplt) THEN
            DO j=js,je
              DO i=is,ie
                CALL PUSHREAL4(dp1(i, j, k))
                dp1(i, j, k) = dp2(i, j)
              END DO
            END DO
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
      END DO
! npz
      IF (it .NE. nsplt) THEN
        CALL PUSHREAL4ARRAY(q, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*npz*&
&                     nq)
        CALL START_GROUP_HALO_UPDATE(q_pack, q, domain)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    CALL PUSHREAL4ARRAY(xfx, (bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*npz)
    CALL PUSHREAL4ARRAY(dp2, (bd%ie-bd%is+1)*(bd%je-bd%js+1))
    CALL PUSHREAL4(frac)
    CALL PUSHREAL4ARRAY(ra_x, (bd%ie-bd%is+1)*(bd%jed-bd%jsd+1))
    CALL PUSHREAL4ARRAY(ra_y, (bd%ied-bd%isd+1)*(bd%je-bd%js+1))
    CALL PUSHREAL4ARRAY(yfx, (bd%ied-bd%isd+1)*(bd%je-bd%js+2)*npz)
    CALL PUSHINTEGER4(nsplt)
    CALL PUSHREAL4ARRAY(fx, (bd%ie-bd%is+2)*(bd%je-bd%js+1))
    CALL PUSHREAL4ARRAY(fy, (bd%ie-bd%is+1)*(bd%je-bd%js+2))
  END SUBROUTINE TRACER_2D_FWD
!  Differentiation of tracer_2d in reverse (adjoint) mode, backward sweep (with options split(a2b_edge_mod.a2b_ord4 a2b_edge_m
!od.a2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_
!mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mod.m
!ix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayleigh
!_Super fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_geos fv_
!grid_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_mapz_
!mod.compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn
!_tracer_fb fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_li
!miters fv_mapz_mod.ppm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.m
!oist_cv fv_mapz_mod.moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer
!_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.Rie
!m_Solver_c nh_utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SIM3p
!0_solver nh_utils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nest_h
!alo_nh sw_core_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_vec
!t sw_core_mod.fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v sw_c
!ore_mod.compute_divergence_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_core_mod
!.fv_tp_2d tp_core_mod.copy_corners tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_co
!rner_fb fv_grid_utils_mod.great_circle_dist sw_core_mod.edge_interpolate4)):
!   gradient     of useful results: q dp1
!   with respect to varying inputs: q dp1 mfx mfy cx cy
  SUBROUTINE TRACER_2D_BWD(q, q_ad, dp1, dp1_ad, mfx, mfx_ad, mfy, &
&   mfy_ad, cx, cx_ad, cy, cy_ad, gridstruct, bd, domain, npx, npy, npz&
&   , nq, hord, q_split, dt, id_divg, q_pack, nord_tr, trdm, hord_pert, &
&   nord_tr_pert, trdm_pert, split_damp_tr, dpa)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
    INTEGER, INTENT(IN) :: nq
    INTEGER, INTENT(IN) :: hord, nord_tr
    INTEGER, INTENT(IN) :: hord_pert, nord_tr_pert
    LOGICAL, INTENT(IN) :: split_damp_tr
    INTEGER, INTENT(IN) :: q_split
    INTEGER, INTENT(IN) :: id_divg
    REAL, INTENT(IN) :: dt, trdm, trdm_pert
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: q_pack
    REAL, INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, nq)
    REAL, INTENT(INOUT) :: q_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz, nq)
    REAL, INTENT(INOUT) :: dp1(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: dp1_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL, INTENT(INOUT) :: mfx_ad(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL, INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
    REAL, INTENT(INOUT) :: mfy_ad(bd%is:bd%ie, bd%js:bd%je+1, npz)
    REAL, INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: cx_ad(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL, INTENT(INOUT) :: cy_ad(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL, OPTIONAL, INTENT(OUT) :: dpa(bd%is:bd%ie, bd%js:bd%je, npz)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    REAL :: dp2(bd%is:bd%ie, bd%js:bd%je)
    REAL :: dp2_ad(bd%is:bd%ie, bd%js:bd%je)
    REAL :: fx(bd%is:bd%ie+1, bd%js:bd%je)
    REAL :: fx_ad(bd%is:bd%ie+1, bd%js:bd%je)
    REAL :: fy(bd%is:bd%ie, bd%js:bd%je+1)
    REAL :: fy_ad(bd%is:bd%ie, bd%js:bd%je+1)
    REAL :: ra_x(bd%is:bd%ie, bd%jsd:bd%jed)
    REAL :: ra_x_ad(bd%is:bd%ie, bd%jsd:bd%jed)
    REAL :: ra_y(bd%isd:bd%ied, bd%js:bd%je)
    REAL :: ra_y_ad(bd%isd:bd%ied, bd%js:bd%je)
    REAL :: xfx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL :: xfx_ad(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL :: yfx(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL :: yfx_ad(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL :: cmax(npz)
    REAL :: c_global
    REAL :: frac, rdt
    INTEGER :: ksplt(npz)
    INTEGER :: nsplt
    INTEGER :: i, j, k, it, iq
    REAL, DIMENSION(:, :), POINTER :: area, rarea
    REAL, DIMENSION(:, :, :), POINTER :: sin_sg
    REAL, DIMENSION(:, :), POINTER :: dxa, dya, dx, dy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC INT
    INTRINSIC REAL
    INTRINSIC PRESENT
    REAL :: max1
    REAL :: temp_ad
    REAL :: temp
    REAL :: temp_ad0
    REAL :: temp_ad1
    INTEGER :: branch
    REAL :: x1
    REAL :: z1
    REAL :: y3
    REAL :: y2
    REAL :: y1
    CALL POPREAL4ARRAY(fy, (bd%ie-bd%is+1)*(bd%je-bd%js+2))
    CALL POPREAL4ARRAY(fx, (bd%ie-bd%is+2)*(bd%je-bd%js+1))
    CALL POPINTEGER4(nsplt)
    CALL POPREAL4ARRAY(yfx, (bd%ied-bd%isd+1)*(bd%je-bd%js+2)*npz)
    CALL POPREAL4ARRAY(ra_y, (bd%ied-bd%isd+1)*(bd%je-bd%js+1))
    CALL POPREAL4ARRAY(ra_x, (bd%ie-bd%is+1)*(bd%jed-bd%jsd+1))
    CALL POPREAL4(frac)
    CALL POPREAL4ARRAY(dp2, (bd%ie-bd%is+1)*(bd%je-bd%js+1))
    CALL POPREAL4ARRAY(xfx, (bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*npz)
    js = bd%js
    rarea => gridstruct%rarea
    jsd = bd%jsd
    ied = bd%ied
    ie = bd%ie
    isd = bd%isd
    is = bd%is
    je = bd%je
    jed = bd%jed
    mfx_ad = 0.0
    mfy_ad = 0.0
    cx_ad = 0.0
    cy_ad = 0.0
    xfx_ad = 0.0
    dp2_ad = 0.0
    ra_x_ad = 0.0
    ra_y_ad = 0.0
    yfx_ad = 0.0
    fx_ad = 0.0
    fy_ad = 0.0
    DO it=nsplt,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        CALL POPREAL4ARRAY(q, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*npz*nq&
&                   )
        CALL START_GROUP_HALO_UPDATE_ADM(q_pack, q, q_ad, domain)
      END IF
      DO k=npz,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .NE. 1) THEN
            DO j=je,js,-1
              DO i=ie,is,-1
                CALL POPREAL4(dp1(i, j, k))
                dp2_ad(i, j) = dp2_ad(i, j) + dp1_ad(i, j, k)
                dp1_ad(i, j, k) = 0.0
              END DO
            END DO
          END IF
          DO iq=nq,1,-1
            DO j=je,js,-1
              DO i=ie,is,-1
                CALL POPREAL4(q(i, j, k, iq))
                temp_ad0 = q_ad(i, j, k, iq)/dp2(i, j)
                temp = q(i, j, k, iq)
                temp_ad1 = rarea(i, j)*temp_ad0
                dp1_ad(i, j, k) = dp1_ad(i, j, k) + temp*temp_ad0
                fx_ad(i, j) = fx_ad(i, j) + temp_ad1
                fx_ad(i+1, j) = fx_ad(i+1, j) - temp_ad1
                fy_ad(i, j) = fy_ad(i, j) + temp_ad1
                fy_ad(i, j+1) = fy_ad(i, j+1) - temp_ad1
                dp2_ad(i, j) = dp2_ad(i, j) - (temp*dp1(i, j, k)+rarea(i&
&                 , j)*(fx(i, j)-fx(i+1, j)+fy(i, j)-fy(i, j+1)))*&
&                 temp_ad0/dp2(i, j)
                q_ad(i, j, k, iq) = dp1(i, j, k)*temp_ad0
              END DO
            END DO
            CALL POPCONTROL2B(branch)
            IF (branch .LT. 2) THEN
              IF (branch .EQ. 0) THEN
                CALL POPREAL4ARRAY(q(isd:ied, jsd:jed, k, iq), (ied-isd+&
&                            1)*(jed-jsd+1))
                CALL POPREAL4ARRAY(fx, (bd%ie-bd%is+2)*(bd%je-bd%js+1))
                CALL POPREAL4ARRAY(fy, (bd%ie-bd%is+1)*(bd%je-bd%js+2))
                CALL FV_TP_2D_ADM(q(isd:ied, jsd:jed, k, iq), q_ad(isd:&
&                           ied, jsd:jed, k, iq), cx(is:ie+1, jsd:jed, k&
&                           ), cx_ad(is:ie+1, jsd:jed, k), cy(isd:ied, &
&                           js:je+1, k), cy_ad(isd:ied, js:je+1, k), npx&
&                           , npy, hord_pert, fx, fx_ad, fy, fy_ad, xfx(&
&                           is:ie+1, jsd:jed, k), xfx_ad(is:ie+1, jsd:&
&                           jed, k), yfx(isd:ied, js:je+1, k), yfx_ad(&
&                           isd:ied, js:je+1, k), gridstruct, bd, ra_x, &
&                           ra_x_ad, ra_y, ra_y_ad, mfx(is:ie+1, js:je, &
&                           k), mfx_ad(is:ie+1, js:je, k), mfy(is:ie, js&
&                           :je+1, k), mfy_ad(is:ie, js:je+1, k))
              ELSE
                CALL POPREAL4ARRAY(q(isd:ied, jsd:jed, k, iq), (ied-isd+&
&                            1)*(jed-jsd+1))
                CALL POPREAL4ARRAY(fx, (bd%ie-bd%is+2)*(bd%je-bd%js+1))
                CALL POPREAL4ARRAY(fy, (bd%ie-bd%is+1)*(bd%je-bd%js+2))
                CALL FV_TP_2D_ADM(q(isd:ied, jsd:jed, k, iq), q_ad(isd:&
&                           ied, jsd:jed, k, iq), cx(is:ie+1, jsd:jed, k&
&                           ), cx_ad(is:ie+1, jsd:jed, k), cy(isd:ied, &
&                           js:je+1, k), cy_ad(isd:ied, js:je+1, k), npx&
&                           , npy, hord_pert, fx, fx_ad, fy, fy_ad, xfx(&
&                           is:ie+1, jsd:jed, k), xfx_ad(is:ie+1, jsd:&
&                           jed, k), yfx(isd:ied, js:je+1, k), yfx_ad(&
&                           isd:ied, js:je+1, k), gridstruct, bd, ra_x, &
&                           ra_x_ad, ra_y, ra_y_ad, mfx(is:ie+1, js:je, &
&                           k), mfx_ad(is:ie+1, js:je, k), mfy(is:ie, js&
&                           :je+1, k), mfy_ad(is:ie, js:je+1, k), dp1(&
&                           isd:ied, jsd:jed, k), dp1_ad(isd:ied, jsd:&
&                           jed, k), nord=nord_tr_pert, damp_c=trdm_pert&
&                          )
              END IF
            ELSE IF (branch .EQ. 2) THEN
              CALL FV_TP_2D_BWD(q(isd:ied, jsd:jed, k, iq), q_ad(isd:&
&                            ied, jsd:jed, k, iq), cx(is:ie+1, jsd:jed, &
&                            k), cx_ad(is:ie+1, jsd:jed, k), cy(isd:ied&
&                            , js:je+1, k), cy_ad(isd:ied, js:je+1, k), &
&                            npx, npy, hord, fx, fx_ad, fy, fy_ad, xfx(&
&                            is:ie+1, jsd:jed, k), xfx_ad(is:ie+1, jsd:&
&                            jed, k), yfx(isd:ied, js:je+1, k), yfx_ad(&
&                            isd:ied, js:je+1, k), gridstruct, bd, ra_x&
&                            , ra_x_ad, ra_y, ra_y_ad, mfx(is:ie+1, js:&
&                            je, k), mfx_ad(is:ie+1, js:je, k), mfy(is:&
&                            ie, js:je+1, k), mfy_ad(is:ie, js:je+1, k))
            ELSE
              CALL FV_TP_2D_BWD(q(isd:ied, jsd:jed, k, iq), q_ad(isd:&
&                            ied, jsd:jed, k, iq), cx(is:ie+1, jsd:jed, &
&                            k), cx_ad(is:ie+1, jsd:jed, k), cy(isd:ied&
&                            , js:je+1, k), cy_ad(isd:ied, js:je+1, k), &
&                            npx, npy, hord, fx, fx_ad, fy, fy_ad, xfx(&
&                            is:ie+1, jsd:jed, k), xfx_ad(is:ie+1, jsd:&
&                            jed, k), yfx(isd:ied, js:je+1, k), yfx_ad(&
&                            isd:ied, js:je+1, k), gridstruct, bd, ra_x&
&                            , ra_x_ad, ra_y, ra_y_ad, mfx(is:ie+1, js:&
&                            je, k), mfx_ad(is:ie+1, js:je, k), mfy(is:&
&                            ie, js:je+1, k), mfy_ad(is:ie, js:je+1, k)&
&                            , dp1(isd:ied, jsd:jed, k), dp1_ad(isd:ied&
&                            , jsd:jed, k), nord=nord_tr, damp_c=trdm)
            END IF
          END DO
          DO j=je,js,-1
            DO i=ied,isd,-1
              CALL POPREAL4(ra_y(i, j))
              yfx_ad(i, j, k) = yfx_ad(i, j, k) + ra_y_ad(i, j)
              yfx_ad(i, j+1, k) = yfx_ad(i, j+1, k) - ra_y_ad(i, j)
              ra_y_ad(i, j) = 0.0
            END DO
          END DO
          DO j=jed,jsd,-1
            DO i=ie,is,-1
              CALL POPREAL4(ra_x(i, j))
              xfx_ad(i, j, k) = xfx_ad(i, j, k) + ra_x_ad(i, j)
              xfx_ad(i+1, j, k) = xfx_ad(i+1, j, k) - ra_x_ad(i, j)
              ra_x_ad(i, j) = 0.0
            END DO
          END DO
          DO j=je,js,-1
            DO i=ie,is,-1
              CALL POPREAL4(dp2(i, j))
              temp_ad = rarea(i, j)*dp2_ad(i, j)
              dp1_ad(i, j, k) = dp1_ad(i, j, k) + dp2_ad(i, j)
              mfx_ad(i, j, k) = mfx_ad(i, j, k) + temp_ad
              mfx_ad(i+1, j, k) = mfx_ad(i+1, j, k) - temp_ad
              mfy_ad(i, j, k) = mfy_ad(i, j, k) + temp_ad
              mfy_ad(i, j+1, k) = mfy_ad(i, j+1, k) - temp_ad
              dp2_ad(i, j) = 0.0
            END DO
          END DO
        END IF
      END DO
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      DO k=npz,1,-1
        DO j=je+1,js,-1
          DO i=ie,is,-1
            CALL POPREAL4(mfy(i, j, k))
            mfy_ad(i, j, k) = frac*mfy_ad(i, j, k)
          END DO
        END DO
        DO j=je+1,js,-1
          DO i=ied,isd,-1
            yfx_ad(i, j, k) = frac*yfx_ad(i, j, k)
            CALL POPREAL4(cy(i, j, k))
            cy_ad(i, j, k) = frac*cy_ad(i, j, k)
          END DO
        END DO
        DO j=je,js,-1
          DO i=ie+1,is,-1
            CALL POPREAL4(mfx(i, j, k))
            mfx_ad(i, j, k) = frac*mfx_ad(i, j, k)
          END DO
        END DO
        DO j=jed,jsd,-1
          DO i=ie+1,is,-1
            xfx_ad(i, j, k) = frac*xfx_ad(i, j, k)
            CALL POPREAL4(cx(i, j, k))
            cx_ad(i, j, k) = frac*cx_ad(i, j, k)
          END DO
        END DO
        CALL POPREAL4(frac)
      END DO
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO k=npz,2,-1
          CALL POPCONTROL1B(branch)
        END DO
      END IF
    END IF
    dxa => gridstruct%dxa
    dx => gridstruct%dx
    dy => gridstruct%dy
    sin_sg => gridstruct%sin_sg
    dya => gridstruct%dya
    DO k=npz,1,-1
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        DO j=je,js,-1
          DO i=ie,is,-1
            CALL POPCONTROL2B(branch)
          END DO
        END DO
      ELSE IF (branch .EQ. 1) THEN
        DO j=je,js,-1
          DO i=ie,is,-1
            CALL POPCONTROL1B(branch)
          END DO
        END DO
      END IF
      DO j=je+1,js,-1
        DO i=ied,isd,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            cy_ad(i, j, k) = cy_ad(i, j, k) + dya(i, j)*dx(i, j)*sin_sg(&
&             i, j, 2)*yfx_ad(i, j, k)
            yfx_ad(i, j, k) = 0.0
          ELSE
            cy_ad(i, j, k) = cy_ad(i, j, k) + dya(i, j-1)*dx(i, j)*&
&             sin_sg(i, j-1, 4)*yfx_ad(i, j, k)
            yfx_ad(i, j, k) = 0.0
          END IF
        END DO
      END DO
      DO j=jed,jsd,-1
        DO i=ie+1,is,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            cx_ad(i, j, k) = cx_ad(i, j, k) + dxa(i, j)*dy(i, j)*sin_sg(&
&             i, j, 1)*xfx_ad(i, j, k)
            xfx_ad(i, j, k) = 0.0
          ELSE
            cx_ad(i, j, k) = cx_ad(i, j, k) + dxa(i-1, j)*dy(i, j)*&
&             sin_sg(i-1, j, 3)*xfx_ad(i, j, k)
            xfx_ad(i, j, k) = 0.0
          END IF
        END DO
      END DO
    END DO
  END SUBROUTINE TRACER_2D_BWD
  SUBROUTINE TRACER_2D(q, dp1, mfx, mfy, cx, cy, gridstruct, bd, domain&
&   , npx, npy, npz, nq, hord, q_split, dt, id_divg, q_pack, nord_tr, &
&   trdm, hord_pert, nord_tr_pert, trdm_pert, split_damp_tr, dpa)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
! number of tracers to be advected
    INTEGER, INTENT(IN) :: nq
    INTEGER, INTENT(IN) :: hord, nord_tr
    INTEGER, INTENT(IN) :: hord_pert, nord_tr_pert
    LOGICAL, INTENT(IN) :: split_damp_tr
    INTEGER, INTENT(IN) :: q_split
    INTEGER, INTENT(IN) :: id_divg
    REAL, INTENT(IN) :: dt, trdm, trdm_pert
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: q_pack
! Tracers
    REAL, INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, nq)
! DELP before dyn_core
    REAL, INTENT(INOUT) :: dp1(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! Mass Flux X-Dir
    REAL, INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
! Mass Flux Y-Dir
    REAL, INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
! Courant Number X-Dir
    REAL, INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
! Courant Number Y-Dir
    REAL, INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
! DELP after advection
    REAL, OPTIONAL, INTENT(OUT) :: dpa(bd%is:bd%ie, bd%js:bd%je, npz)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
! Local Arrays
    REAL :: dp2(bd%is:bd%ie, bd%js:bd%je)
    REAL :: fx(bd%is:bd%ie+1, bd%js:bd%je)
    REAL :: fy(bd%is:bd%ie, bd%js:bd%je+1)
    REAL :: ra_x(bd%is:bd%ie, bd%jsd:bd%jed)
    REAL :: ra_y(bd%isd:bd%ied, bd%js:bd%je)
    REAL :: xfx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL :: yfx(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL :: cmax(npz)
    REAL :: c_global
    REAL :: frac, rdt
    INTEGER :: ksplt(npz)
    INTEGER :: nsplt
    INTEGER :: i, j, k, it, iq
    REAL, DIMENSION(:, :), POINTER :: area, rarea
    REAL, DIMENSION(:, :, :), POINTER :: sin_sg
    REAL, DIMENSION(:, :), POINTER :: dxa, dya, dx, dy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC INT
    INTRINSIC REAL
    INTRINSIC PRESENT
    REAL :: max1
    REAL :: x1
    REAL :: z1
    REAL :: y3
    REAL :: y2
    REAL :: y1
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    area => gridstruct%area
    rarea => gridstruct%rarea
    sin_sg => gridstruct%sin_sg
    dxa => gridstruct%dxa
    dya => gridstruct%dya
    dx => gridstruct%dx
    dy => gridstruct%dy
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,jsd,jed,npz,cx,xfx,dxa,dy, &
!$OMP                                  sin_sg,cy,yfx,dya,dx,cmax,q_split,ksplt)
    DO k=1,npz
      DO j=jsd,jed
        DO i=is,ie+1
          IF (cx(i, j, k) .GT. 0.) THEN
            xfx(i, j, k) = cx(i, j, k)*dxa(i-1, j)*dy(i, j)*sin_sg(i-1, &
&             j, 3)
          ELSE
            xfx(i, j, k) = cx(i, j, k)*dxa(i, j)*dy(i, j)*sin_sg(i, j, 1&
&             )
          END IF
        END DO
      END DO
      DO j=js,je+1
        DO i=isd,ied
          IF (cy(i, j, k) .GT. 0.) THEN
            yfx(i, j, k) = cy(i, j, k)*dya(i, j-1)*dx(i, j)*sin_sg(i, j-&
&             1, 4)
          ELSE
            yfx(i, j, k) = cy(i, j, k)*dya(i, j)*dx(i, j)*sin_sg(i, j, 2&
&             )
          END IF
        END DO
      END DO
      IF (q_split .EQ. 0) THEN
        cmax(k) = 0.
        IF (k .LT. npz/6) THEN
          DO j=js,je
            DO i=is,ie
              IF (cx(i, j, k) .GE. 0.) THEN
                y1 = cx(i, j, k)
              ELSE
                y1 = -cx(i, j, k)
              END IF
              IF (cy(i, j, k) .GE. 0.) THEN
                z1 = cy(i, j, k)
              ELSE
                z1 = -cy(i, j, k)
              END IF
              IF (cmax(k) .LT. y1) THEN
                IF (y1 .LT. z1) THEN
                  cmax(k) = z1
                ELSE
                  cmax(k) = y1
                END IF
              ELSE IF (cmax(k) .LT. z1) THEN
                cmax(k) = z1
              ELSE
                cmax(k) = cmax(k)
              END IF
            END DO
          END DO
        ELSE
          DO j=js,je
            DO i=is,ie
              IF (cx(i, j, k) .GE. 0.) THEN
                x1 = cx(i, j, k)
              ELSE
                x1 = -cx(i, j, k)
              END IF
              IF (cy(i, j, k) .GE. 0.) THEN
                y3 = cy(i, j, k)
              ELSE
                y3 = -cy(i, j, k)
              END IF
              IF (x1 .LT. y3) THEN
                max1 = y3
              ELSE
                max1 = x1
              END IF
              y2 = max1 + 1. - sin_sg(i, j, 5)
              IF (cmax(k) .LT. y2) THEN
                cmax(k) = y2
              ELSE
                cmax(k) = cmax(k)
              END IF
            END DO
          END DO
        END IF
      END IF
      ksplt(k) = 1
    END DO
!--------------------------------------------------------------------------------
! Determine global nsplt:
    IF (q_split .EQ. 0) THEN
      CALL MP_REDUCE_MAX(cmax, npz)
! find global max courant number and define nsplt to scale cx,cy,mfx,mfy
      c_global = cmax(1)
      IF (npz .NE. 1) THEN
! if NOT shallow water test case
        DO k=2,npz
          IF (cmax(k) .LT. c_global) THEN
            c_global = c_global
          ELSE
            c_global = cmax(k)
          END IF
        END DO
      END IF
      nsplt = INT(1. + c_global)
      IF (IS_MASTER() .AND. nsplt .GT. 4) WRITE(*, *) 'Tracer_2d_split='&
&                                         , nsplt, c_global
    ELSE
      nsplt = q_split
    END IF
!--------------------------------------------------------------------------------
    IF (nsplt .NE. 1) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,jsd,jed,npz,cx,xfx,mfx,cy,yfx,mfy,cmax,nsplt,ksplt) &
!$OMP                          private( frac )
      DO k=1,npz
        ksplt(k) = INT(1. + cmax(k))
        frac = 1./REAL(ksplt(k))
        DO j=jsd,jed
          DO i=is,ie+1
            cx(i, j, k) = cx(i, j, k)*frac
            xfx(i, j, k) = xfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je
          DO i=is,ie+1
            mfx(i, j, k) = mfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je+1
          DO i=isd,ied
            cy(i, j, k) = cy(i, j, k)*frac
            yfx(i, j, k) = yfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je+1
          DO i=is,ie
            mfy(i, j, k) = mfy(i, j, k)*frac
          END DO
        END DO
      END DO
    END IF
    DO it=1,nsplt
      CALL TIMING_ON('COMM_TOTAL')
      CALL TIMING_ON('COMM_TRACER')
      CALL COMPLETE_GROUP_HALO_UPDATE(q_pack, domain)
      CALL TIMING_OFF('COMM_TRACER')
      CALL TIMING_OFF('COMM_TOTAL')
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,jsd,jed,npz,dp1,mfx,mfy,rarea,nq,ksplt,&
!$OMP                                  area,xfx,yfx,q,cx,cy,npx,npy,hord,gridstruct,bd,it,nsplt,nord_tr,trdm) &
!$OMP                          private(dp2, ra_x, ra_y, fx, fy)
      DO k=1,npz
! ksplt
        IF (it .LE. ksplt(k)) THEN
          DO j=js,je
            DO i=is,ie
              dp2(i, j) = dp1(i, j, k) + (mfx(i, j, k)-mfx(i+1, j, k)+&
&               mfy(i, j, k)-mfy(i, j+1, k))*rarea(i, j)
            END DO
          END DO
          DO j=jsd,jed
            DO i=is,ie
              ra_x(i, j) = area(i, j) + xfx(i, j, k) - xfx(i+1, j, k)
            END DO
          END DO
          DO j=js,je
            DO i=isd,ied
              ra_y(i, j) = area(i, j) + yfx(i, j, k) - yfx(i, j+1, k)
            END DO
          END DO
          DO iq=1,nq
            IF (hord .EQ. hord_pert .AND. (.NOT.split_damp_tr)) THEN
              IF (it .EQ. 1 .AND. trdm .GT. 1.e-4) THEN
                CALL FV_TP_2D(q(isd:ied, jsd:jed, k, iq), cx(is:ie+1&
&                          , jsd:jed, k), cy(isd:ied, js:je+1, k), npx, &
&                          npy, hord, fx, fy, xfx(is:ie+1, jsd:jed, k), &
&                          yfx(isd:ied, js:je+1, k), gridstruct, bd, &
&                          ra_x, ra_y, mfx(is:ie+1, js:je, k), mfy(is:ie&
&                          , js:je+1, k), dp1(isd:ied, jsd:jed, k), &
&                          nord_tr, trdm)
              ELSE
                CALL FV_TP_2D(q(isd:ied, jsd:jed, k, iq), cx(is:ie+1&
&                          , jsd:jed, k), cy(isd:ied, js:je+1, k), npx, &
&                          npy, hord, fx, fy, xfx(is:ie+1, jsd:jed, k), &
&                          yfx(isd:ied, js:je+1, k), gridstruct, bd, &
&                          ra_x, ra_y, mfx=mfx(is:ie+1, js:je, k), mfy=&
&                          mfy(is:ie, js:je+1, k))
              END IF
            ELSE IF (it .EQ. 1 .AND. trdm_pert .GT. 1.e-4) THEN
              CALL FV_TP_2D(q(isd:ied, jsd:jed, k, iq), cx(is:ie+1, jsd:&
&                     jed, k), cy(isd:ied, js:je+1, k), npx, npy, &
&                     hord_pert, fx, fy, xfx(is:ie+1, jsd:jed, k), yfx(&
&                     isd:ied, js:je+1, k), gridstruct, bd, ra_x, ra_y, &
&                     mfx(is:ie+1, js:je, k), mfy(is:ie, js:je+1, k), &
&                     dp1(isd:ied, jsd:jed, k), nord_tr_pert, trdm_pert)
            ELSE
              CALL FV_TP_2D(q(isd:ied, jsd:jed, k, iq), cx(is:ie+1, jsd:&
&                     jed, k), cy(isd:ied, js:je+1, k), npx, npy, &
&                     hord_pert, fx, fy, xfx(is:ie+1, jsd:jed, k), yfx(&
&                     isd:ied, js:je+1, k), gridstruct, bd, ra_x, ra_y, &
&                     mfx=mfx(is:ie+1, js:je, k), mfy=mfy(is:ie, js:je+1&
&                     , k))
            END IF
            DO j=js,je
              DO i=is,ie
                q(i, j, k, iq) = (q(i, j, k, iq)*dp1(i, j, k)+(fx(i, j)-&
&                 fx(i+1, j)+fy(i, j)-fy(i, j+1))*rarea(i, j))/dp2(i, j)
              END DO
            END DO
          END DO
          IF (it .NE. nsplt) THEN
            DO j=js,je
              DO i=is,ie
                dp1(i, j, k) = dp2(i, j)
              END DO
            END DO
          END IF
        END IF
      END DO
! npz
      IF (it .NE. nsplt) THEN
        CALL TIMING_ON('COMM_TOTAL')
        CALL TIMING_ON('COMM_TRACER')
        CALL START_GROUP_HALO_UPDATE(q_pack, q, domain)
        CALL TIMING_OFF('COMM_TRACER')
        CALL TIMING_OFF('COMM_TOTAL')
      END IF
    END DO
! nsplt
    IF (PRESENT(dpa)) dpa = dp1(bd%is:bd%ie, bd%js:bd%je, 1:npz)
  END SUBROUTINE TRACER_2D
!  Differentiation of tracer_2d_nested in reverse (adjoint) mode, forward sweep (with options split(a2b_edge_mod.a2b_ord4 a2b_
!edge_mod.a2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn
!_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core
!_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Ra
!yleigh_Super fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_ge
!os fv_grid_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv
!_mapz_mod.compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mo
!d.mapn_tracer fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod
!.cs_limiters fv_mapz_mod.ppm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz
!_mod.moist_cv fv_mapz_mod.moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.
!tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_m
!od.Riem_Solver_c nh_utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod
!.SIM3p0_solver nh_utils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.
!nest_halo_nh sw_core_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a
!2c_vect sw_core_mod.fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v_f
!b sw_core_mod.compute_divergence_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_co
!re_mod.fv_tp_2d tp_core_mod.copy_corners tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.ext
!rap_corner_fb fv_grid_utils_mod.great_circle_dist sw_core_mod.edge_interpolate4)):
!   gradient     of useful results: q dp1
!   with respect to varying inputs: q dp1 mfx mfy cx cy
  SUBROUTINE TRACER_2D_NESTED_FWD(q, dp1, mfx, mfy, cx, cy, gridstruct, &
&   bd, domain, npx, npy, npz, nq, hord, q_split, dt, id_divg, q_pack, &
&   nord_tr, trdm, k_split, neststruct, parent_grid, hord_pert, &
&   nord_tr_pert, trdm_pert, split_damp_tr)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
! number of tracers to be advected
    INTEGER, INTENT(IN) :: nq
    INTEGER, INTENT(IN) :: hord, nord_tr
    INTEGER, INTENT(IN) :: hord_pert, nord_tr_pert
    LOGICAL, INTENT(IN) :: split_damp_tr
    INTEGER, INTENT(IN) :: q_split, k_split
    INTEGER, INTENT(IN) :: id_divg
    REAL, INTENT(IN) :: dt, trdm, trdm_pert
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: q_pack
! Tracers
    REAL, INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, nq)
! DELP before dyn_core
    REAL, INTENT(INOUT) :: dp1(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! Mass Flux X-Dir
    REAL, INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
! Mass Flux Y-Dir
    REAL, INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
! Courant Number X-Dir
    REAL, INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
! Courant Number Y-Dir
    REAL, INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_NEST_TYPE), INTENT(INOUT) :: neststruct
    TYPE(FV_ATMOS_TYPE), INTENT(INOUT) :: parent_grid
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
! Local Arrays
    REAL :: dp2(bd%is:bd%ie, bd%js:bd%je)
    REAL :: fx(bd%is:bd%ie+1, bd%js:bd%je)
    REAL :: fy(bd%is:bd%ie, bd%js:bd%je+1)
    REAL :: ra_x(bd%is:bd%ie, bd%jsd:bd%jed)
    REAL :: ra_y(bd%isd:bd%ied, bd%js:bd%je)
    REAL :: xfx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL :: yfx(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL :: cmax(npz)
    REAL :: cmax_t
    REAL :: c_global
    REAL :: frac, rdt
    INTEGER :: nsplt, nsplt_parent
    INTEGER, SAVE :: msg_split_steps=1
    INTEGER :: i, j, k, it, iq
    REAL, DIMENSION(:, :), POINTER :: area, rarea
    REAL, DIMENSION(:, :, :), POINTER :: sin_sg
    REAL, DIMENSION(:, :), POINTER :: dxa, dya, dx, dy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC INT
    INTRINSIC REAL
    REAL :: max1
    REAL :: arg1
    REAL :: arg2
    LOGICAL :: res
    INTERFACE 
        SUBROUTINE PUSHPOINTER8(pp)
          REAL, POINTER :: pp
        END SUBROUTINE PUSHPOINTER8
        SUBROUTINE LOOKPOINTER8(pp)
          REAL, POINTER :: pp
        END SUBROUTINE LOOKPOINTER8
        SUBROUTINE POPPOINTER8(pp)
          REAL, POINTER :: pp
        END SUBROUTINE POPPOINTER8
    END INTERFACE

    REAL :: x2
    REAL :: x1
    REAL :: y2
    REAL :: y1
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    area => gridstruct%area
    rarea => gridstruct%rarea
    sin_sg => gridstruct%sin_sg
    dxa => gridstruct%dxa
    dya => gridstruct%dya
    dx => gridstruct%dx
    dy => gridstruct%dy
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,jsd,jed,npz,cx,xfx,dxa,dy, &
!$OMP                                  sin_sg,cy,yfx,dya,dx)
    DO k=1,npz
      DO j=jsd,jed
        DO i=is,ie+1
          IF (cx(i, j, k) .GT. 0.) THEN
            xfx(i, j, k) = cx(i, j, k)*dxa(i-1, j)*dy(i, j)*sin_sg(i-1, &
&             j, 3)
            CALL PUSHCONTROL1B(1)
          ELSE
            xfx(i, j, k) = cx(i, j, k)*dxa(i, j)*dy(i, j)*sin_sg(i, j, 1&
&             )
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      DO j=js,je+1
        DO i=isd,ied
          IF (cy(i, j, k) .GT. 0.) THEN
            yfx(i, j, k) = cy(i, j, k)*dya(i, j-1)*dx(i, j)*sin_sg(i, j-&
&             1, 4)
            CALL PUSHCONTROL1B(1)
          ELSE
            yfx(i, j, k) = cy(i, j, k)*dya(i, j)*dx(i, j)*sin_sg(i, j, 2&
&             )
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
    END DO
!--------------------------------------------------------------------------------
    IF (q_split .EQ. 0) THEN
! Determine nsplt
!$OMP parallel do default(none) shared(is,ie,js,je,npz,cmax,cx,cy,sin_sg) &
!$OMP                          private(cmax_t )
      DO k=1,npz
        cmax(k) = 0.
        IF (k .LT. 4) THEN
! Top layers: C < max( abs(c_x), abs(c_y) )
          DO j=js,je
            DO i=is,ie
              IF (cx(i, j, k) .GE. 0.) THEN
                x1 = cx(i, j, k)
              ELSE
                x1 = -cx(i, j, k)
              END IF
              IF (cy(i, j, k) .GE. 0.) THEN
                y1 = cy(i, j, k)
              ELSE
                y1 = -cy(i, j, k)
              END IF
              IF (x1 .LT. y1) THEN
                cmax_t = y1
              ELSE
                cmax_t = x1
              END IF
              IF (cmax_t .LT. cmax(k)) THEN
                CALL PUSHCONTROL1B(0)
                cmax(k) = cmax(k)
              ELSE
                CALL PUSHCONTROL1B(1)
                cmax(k) = cmax_t
              END IF
            END DO
          END DO
          CALL PUSHCONTROL1B(1)
        ELSE
          DO j=js,je
            DO i=is,ie
              IF (cx(i, j, k) .GE. 0.) THEN
                x2 = cx(i, j, k)
              ELSE
                x2 = -cx(i, j, k)
              END IF
              IF (cy(i, j, k) .GE. 0.) THEN
                y2 = cy(i, j, k)
              ELSE
                y2 = -cy(i, j, k)
              END IF
              IF (x2 .LT. y2) THEN
                max1 = y2
              ELSE
                max1 = x2
              END IF
              cmax_t = max1 + 1. - sin_sg(i, j, 5)
              IF (cmax_t .LT. cmax(k)) THEN
                CALL PUSHCONTROL1B(0)
                cmax(k) = cmax(k)
              ELSE
                CALL PUSHCONTROL1B(1)
                cmax(k) = cmax_t
              END IF
            END DO
          END DO
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
      CALL MP_REDUCE_MAX(cmax, npz)
! find global max courant number and define nsplt to scale cx,cy,mfx,mfy
      c_global = cmax(1)
      IF (npz .NE. 1) THEN
! if NOT shallow water test case
        DO k=2,npz
          IF (cmax(k) .LT. c_global) THEN
            CALL PUSHCONTROL1B(0)
            c_global = c_global
          ELSE
            CALL PUSHCONTROL1B(1)
            c_global = cmax(k)
          END IF
        END DO
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      nsplt = INT(1. + c_global)
      res = IS_MASTER()
      IF (res .AND. nsplt .GT. 3) THEN
        CALL PUSHCONTROL1B(0)
        WRITE(*, *) 'Tracer_2d_split=', nsplt, c_global
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    ELSE
      nsplt = q_split
      CALL PUSHCONTROL1B(1)
    END IF
!--------------------------------------------------------------------------------
    frac = 1./REAL(nsplt)
    IF (nsplt .NE. 1) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,jsd,jed,npz,cx,frac,xfx,mfx,cy,yfx,mfy)
      DO k=1,npz
        DO j=jsd,jed
          DO i=is,ie+1
            CALL PUSHREAL4(cx(i, j, k))
            cx(i, j, k) = cx(i, j, k)*frac
            xfx(i, j, k) = xfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je
          DO i=is,ie+1
            CALL PUSHREAL4(mfx(i, j, k))
            mfx(i, j, k) = mfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je+1
          DO i=isd,ied
            CALL PUSHREAL4(cy(i, j, k))
            cy(i, j, k) = cy(i, j, k)*frac
            yfx(i, j, k) = yfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je+1
          DO i=is,ie
            CALL PUSHREAL4(mfy(i, j, k))
            mfy(i, j, k) = mfy(i, j, k)*frac
          END DO
        END DO
      END DO
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    DO it=1,nsplt
      IF (gridstruct%nested) neststruct%tracer_nest_timestep = &
&         neststruct%tracer_nest_timestep + 1
      IF (gridstruct%nested) THEN
        DO iq=1,nq
          arg1 = REAL(neststruct%tracer_nest_timestep) + REAL(nsplt*&
&           k_split)
          arg2 = REAL(nsplt*k_split)
          CALL PUSHREAL4ARRAY(q(isd:ied, jsd:jed, :, iq), (ied-isd+1)*(&
&                       jed-jsd+1)*npz)
          CALL NESTED_GRID_BC_APPLY_INTT(q(isd:ied, jsd:jed, :, iq), 0, &
&                                  0, npx, npy, npz, bd, REAL(neststruct&
&                                  %tracer_nest_timestep) + REAL(nsplt*&
&                                  k_split), REAL(nsplt*k_split), &
&                                  neststruct%q_bc(iq), bctype=&
&                                  neststruct%nestbctype)
        END DO
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,jsd,jed,npz,dp1,mfx,mfy,rarea,nq, &
!$OMP                                  area,xfx,yfx,q,cx,cy,npx,npy,hord,gridstruct,bd,it,nsplt,nord_tr,trdm) &
!$OMP                          private(dp2, ra_x, ra_y, fx, fy)
      DO k=1,npz
        DO j=js,je
          DO i=is,ie
            CALL PUSHREAL4(dp2(i, j))
            dp2(i, j) = dp1(i, j, k) + (mfx(i, j, k)-mfx(i+1, j, k)+mfy(&
&             i, j, k)-mfy(i, j+1, k))*rarea(i, j)
          END DO
        END DO
        DO j=jsd,jed
          DO i=is,ie
            CALL PUSHREAL4(ra_x(i, j))
            ra_x(i, j) = area(i, j) + xfx(i, j, k) - xfx(i+1, j, k)
          END DO
        END DO
        DO j=js,je
          DO i=isd,ied
            CALL PUSHREAL4(ra_y(i, j))
            ra_y(i, j) = area(i, j) + yfx(i, j, k) - yfx(i, j+1, k)
          END DO
        END DO
        DO iq=1,nq
          IF (hord .EQ. hord_pert .AND. (.NOT.split_damp_tr)) THEN
            IF (it .EQ. 1 .AND. trdm .GT. 1.e-4) THEN
              CALL FV_TP_2D_FWD(q(isd:ied, jsd:jed, k, iq), cx(is:ie+&
&                            1, jsd:jed, k), cy(isd:ied, js:je+1, k), &
&                            npx, npy, hord, fx, fy, xfx(is:ie+1, jsd:&
&                            jed, k), yfx(isd:ied, js:je+1, k), &
&                            gridstruct, bd, ra_x, ra_y, mfx=mfx(is:ie+1&
&                            , js:je, k), mfy=mfy(is:ie, js:je+1, k), &
&                            mass=dp1(isd:ied, jsd:jed, k), nord=nord_tr&
&                            , damp_c=trdm)
              CALL PUSHCONTROL2B(3)
            ELSE
              CALL FV_TP_2D_FWD(q(isd:ied, jsd:jed, k, iq), cx(is:ie+&
&                            1, jsd:jed, k), cy(isd:ied, js:je+1, k), &
&                            npx, npy, hord, fx, fy, xfx(is:ie+1, jsd:&
&                            jed, k), yfx(isd:ied, js:je+1, k), &
&                            gridstruct, bd, ra_x, ra_y, mfx=mfx(is:ie+1&
&                            , js:je, k), mfy=mfy(is:ie, js:je+1, k))
              CALL PUSHCONTROL2B(2)
            END IF
          ELSE IF (it .EQ. 1 .AND. trdm_pert .GT. 1.e-4) THEN
            CALL PUSHREAL4ARRAY(fy, (bd%ie-bd%is+1)*(bd%je-bd%js+2))
            CALL PUSHREAL4ARRAY(fx, (bd%ie-bd%is+2)*(bd%je-bd%js+1))
            CALL PUSHREAL4ARRAY(q(isd:ied, jsd:jed, k, iq), (ied-isd+1)*&
&                         (jed-jsd+1))
            CALL FV_TP_2D(q(isd:ied, jsd:jed, k, iq), cx(is:ie+1, jsd:&
&                   jed, k), cy(isd:ied, js:je+1, k), npx, npy, &
&                   hord_pert, fx, fy, xfx(is:ie+1, jsd:jed, k), yfx(isd&
&                   :ied, js:je+1, k), gridstruct, bd, ra_x, ra_y, mfx=&
&                   mfx(is:ie+1, js:je, k), mfy=mfy(is:ie, js:je+1, k), &
&                   mass=dp1(isd:ied, jsd:jed, k), nord=nord_tr_pert, &
&                   damp_c=trdm_pert)
            CALL PUSHCONTROL2B(1)
          ELSE
            CALL PUSHREAL4ARRAY(fy, (bd%ie-bd%is+1)*(bd%je-bd%js+2))
            CALL PUSHREAL4ARRAY(fx, (bd%ie-bd%is+2)*(bd%je-bd%js+1))
            CALL PUSHREAL4ARRAY(q(isd:ied, jsd:jed, k, iq), (ied-isd+1)*&
&                         (jed-jsd+1))
            CALL FV_TP_2D(q(isd:ied, jsd:jed, k, iq), cx(is:ie+1, jsd:&
&                   jed, k), cy(isd:ied, js:je+1, k), npx, npy, &
&                   hord_pert, fx, fy, xfx(is:ie+1, jsd:jed, k), yfx(isd&
&                   :ied, js:je+1, k), gridstruct, bd, ra_x, ra_y, mfx=&
&                   mfx(is:ie+1, js:je, k), mfy=mfy(is:ie, js:je+1, k))
            CALL PUSHCONTROL2B(0)
          END IF
          DO j=js,je
            DO i=is,ie
              CALL PUSHREAL4(q(i, j, k, iq))
              q(i, j, k, iq) = (q(i, j, k, iq)*dp1(i, j, k)+(fx(i, j)-fx&
&               (i+1, j)+fy(i, j)-fy(i, j+1))*rarea(i, j))/dp2(i, j)
            END DO
          END DO
        END DO
      END DO
! npz
      IF (it .NE. nsplt) THEN
        CALL PUSHREAL4ARRAY(q, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*npz*&
&                     nq)
        CALL START_GROUP_HALO_UPDATE(q_pack, q, domain)
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!Apply nested-grid BCs
      IF (gridstruct%nested) THEN
        DO iq=1,nq
          arg1 = REAL(neststruct%tracer_nest_timestep)
          arg2 = REAL(nsplt*k_split)
          CALL PUSHREAL4ARRAY(q(isd:ied, jsd:jed, :, iq), (ied-isd+1)*(&
&                       jed-jsd+1)*npz)
          CALL NESTED_GRID_BC_APPLY_INTT(q(isd:ied, jsd:jed, :, iq), 0, &
&                                  0, npx, npy, npz, bd, REAL(neststruct&
&                                  %tracer_nest_timestep), REAL(nsplt*&
&                                  k_split), neststruct%q_bc(iq), bctype&
&                                  =neststruct%nestbctype)
        END DO
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
! nsplt
    IF (id_divg .GT. 0) THEN
      rdt = 1./(frac*dt)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,dp1,xfx,yfx,rarea,rdt)
      DO k=1,npz
        DO j=js,je
          DO i=is,ie
            CALL PUSHREAL4(dp1(i, j, k))
            dp1(i, j, k) = (xfx(i+1, j, k)-xfx(i, j, k)+yfx(i, j+1, k)-&
&             yfx(i, j, k))*rarea(i, j)*rdt
          END DO
        END DO
      END DO
      CALL PUSHINTEGER4(js)
      CALL PUSHREAL4ARRAY(xfx, (bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*npz)
      !CALL PUSHPOINTER8(rarea)
      CALL PUSHREAL4ARRAY(dp2, (bd%ie-bd%is+1)*(bd%je-bd%js+1))
      CALL PUSHREAL4(frac)
      CALL PUSHINTEGER4(ie)
      CALL PUSHREAL4ARRAY(ra_x, (bd%ie-bd%is+1)*(bd%jed-bd%jsd+1))
      CALL PUSHREAL4ARRAY(ra_y, (bd%ied-bd%isd+1)*(bd%je-bd%js+1))
      CALL PUSHREAL4ARRAY(yfx, (bd%ied-bd%isd+1)*(bd%je-bd%js+2)*npz)
      CALL PUSHINTEGER4(is)
      CALL PUSHREAL4(rdt)
      CALL PUSHINTEGER4(nsplt)
      CALL PUSHREAL4ARRAY(fx, (bd%ie-bd%is+2)*(bd%je-bd%js+1))
      CALL PUSHREAL4ARRAY(fy, (bd%ie-bd%is+1)*(bd%je-bd%js+2))
      CALL PUSHINTEGER4(je)
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHINTEGER4(js)
      CALL PUSHREAL4ARRAY(xfx, (bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*npz)
      !CALL PUSHPOINTER8(rarea)
      CALL PUSHREAL4ARRAY(dp2, (bd%ie-bd%is+1)*(bd%je-bd%js+1))
      CALL PUSHREAL4(frac)
      CALL PUSHINTEGER4(ie)
      CALL PUSHREAL4ARRAY(ra_x, (bd%ie-bd%is+1)*(bd%jed-bd%jsd+1))
      CALL PUSHREAL4ARRAY(ra_y, (bd%ied-bd%isd+1)*(bd%je-bd%js+1))
      CALL PUSHREAL4ARRAY(yfx, (bd%ied-bd%isd+1)*(bd%je-bd%js+2)*npz)
      CALL PUSHINTEGER4(is)
      CALL PUSHINTEGER4(nsplt)
      CALL PUSHREAL4ARRAY(fx, (bd%ie-bd%is+2)*(bd%je-bd%js+1))
      CALL PUSHREAL4ARRAY(fy, (bd%ie-bd%is+1)*(bd%je-bd%js+2))
      CALL PUSHINTEGER4(je)
      CALL PUSHCONTROL1B(0)
    END IF
  END SUBROUTINE TRACER_2D_NESTED_FWD
!  Differentiation of tracer_2d_nested in reverse (adjoint) mode, backward sweep (with options split(a2b_edge_mod.a2b_ord4 a2b
!_edge_mod.a2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dy
!n_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_cor
!e_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.R
!ayleigh_Super fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_g
!eos fv_grid_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian f
!v_mapz_mod.compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_m
!od.mapn_tracer fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mo
!d.cs_limiters fv_mapz_mod.ppm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_map
!z_mod.moist_cv fv_mapz_mod.moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod
!.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_
!mod.Riem_Solver_c nh_utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mo
!d.SIM3p0_solver nh_utils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod
!.nest_halo_nh sw_core_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2
!a2c_vect sw_core_mod.fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v_
!fb sw_core_mod.compute_divergence_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_c
!ore_mod.fv_tp_2d tp_core_mod.copy_corners tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.ex
!trap_corner_fb fv_grid_utils_mod.great_circle_dist sw_core_mod.edge_interpolate4)):
!   gradient     of useful results: q dp1
!   with respect to varying inputs: q dp1 mfx mfy cx cy
  SUBROUTINE TRACER_2D_NESTED_BWD(q, q_ad, dp1, dp1_ad, mfx, mfx_ad, mfy&
&   , mfy_ad, cx, cx_ad, cy, cy_ad, gridstruct, bd, domain, npx, npy, &
&   npz, nq, hord, q_split, dt, id_divg, q_pack, nord_tr, trdm, k_split&
&   , neststruct, parent_grid, hord_pert, nord_tr_pert, trdm_pert, &
&   split_damp_tr)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
    INTEGER, INTENT(IN) :: nq
    INTEGER, INTENT(IN) :: hord, nord_tr
    INTEGER, INTENT(IN) :: hord_pert, nord_tr_pert
    LOGICAL, INTENT(IN) :: split_damp_tr
    INTEGER, INTENT(IN) :: q_split, k_split
    INTEGER, INTENT(IN) :: id_divg
    REAL, INTENT(IN) :: dt, trdm, trdm_pert
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: q_pack
    REAL, INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, nq)
    REAL, INTENT(INOUT) :: q_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz, nq)
    REAL, INTENT(INOUT) :: dp1(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: dp1_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL, INTENT(INOUT) :: mfx_ad(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL, INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
    REAL, INTENT(INOUT) :: mfy_ad(bd%is:bd%ie, bd%js:bd%je+1, npz)
    REAL, INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: cx_ad(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL, INTENT(INOUT) :: cy_ad(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_NEST_TYPE), INTENT(INOUT) :: neststruct
    TYPE(FV_ATMOS_TYPE), INTENT(INOUT) :: parent_grid
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    REAL :: dp2(bd%is:bd%ie, bd%js:bd%je)
    REAL :: dp2_ad(bd%is:bd%ie, bd%js:bd%je)
    REAL :: fx(bd%is:bd%ie+1, bd%js:bd%je)
    REAL :: fx_ad(bd%is:bd%ie+1, bd%js:bd%je)
    REAL :: fy(bd%is:bd%ie, bd%js:bd%je+1)
    REAL :: fy_ad(bd%is:bd%ie, bd%js:bd%je+1)
    REAL :: ra_x(bd%is:bd%ie, bd%jsd:bd%jed)
    REAL :: ra_x_ad(bd%is:bd%ie, bd%jsd:bd%jed)
    REAL :: ra_y(bd%isd:bd%ied, bd%js:bd%je)
    REAL :: ra_y_ad(bd%isd:bd%ied, bd%js:bd%je)
    REAL :: xfx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL :: xfx_ad(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL :: yfx(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL :: yfx_ad(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL :: cmax(npz)
    REAL :: cmax_t
    REAL :: c_global
    REAL :: frac, rdt
    INTEGER :: nsplt, nsplt_parent
    INTEGER, SAVE :: msg_split_steps=1
    INTEGER :: i, j, k, it, iq
    REAL, DIMENSION(:, :), POINTER :: area, rarea
    REAL, DIMENSION(:, :, :), POINTER :: sin_sg
    REAL, DIMENSION(:, :), POINTER :: dxa, dya, dx, dy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC INT
    INTRINSIC REAL
    REAL :: max1
    REAL :: arg1
    REAL :: arg2
    REAL :: temp_ad
    REAL :: temp
    REAL :: temp_ad0
    REAL :: temp_ad1
    REAL :: temp_ad2
    INTEGER :: branch
    INTERFACE 
        SUBROUTINE PUSHPOINTER8(pp)
          REAL, POINTER :: pp
        END SUBROUTINE PUSHPOINTER8
        SUBROUTINE LOOKPOINTER8(pp)
          REAL, POINTER :: pp
        END SUBROUTINE LOOKPOINTER8
        SUBROUTINE POPPOINTER8(pp)
          REAL, POINTER :: pp
        END SUBROUTINE POPPOINTER8
    END INTERFACE

    REAL :: x2
    REAL :: x1
    REAL :: y2
    REAL :: y1
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPINTEGER4(je)
      CALL POPREAL4ARRAY(fy, (bd%ie-bd%is+1)*(bd%je-bd%js+2))
      CALL POPREAL4ARRAY(fx, (bd%ie-bd%is+2)*(bd%je-bd%js+1))
      CALL POPINTEGER4(nsplt)
      CALL POPINTEGER4(is)
      CALL POPREAL4ARRAY(yfx, (bd%ied-bd%isd+1)*(bd%je-bd%js+2)*npz)
      CALL POPREAL4ARRAY(ra_y, (bd%ied-bd%isd+1)*(bd%je-bd%js+1))
      CALL POPREAL4ARRAY(ra_x, (bd%ie-bd%is+1)*(bd%jed-bd%jsd+1))
      CALL POPINTEGER4(ie)
      CALL POPREAL4(frac)
      CALL POPREAL4ARRAY(dp2, (bd%ie-bd%is+1)*(bd%je-bd%js+1))
      rarea => gridstruct%rarea
      !CALL ADMM_REBASE(rarea)
      CALL POPREAL4ARRAY(xfx, (bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*npz)
      CALL POPINTEGER4(js)
      xfx_ad = 0.0
      yfx_ad = 0.0
    ELSE
      CALL POPINTEGER4(je)
      CALL POPREAL4ARRAY(fy, (bd%ie-bd%is+1)*(bd%je-bd%js+2))
      CALL POPREAL4ARRAY(fx, (bd%ie-bd%is+2)*(bd%je-bd%js+1))
      CALL POPINTEGER4(nsplt)
      CALL POPREAL4(rdt)
      CALL POPINTEGER4(is)
      CALL POPREAL4ARRAY(yfx, (bd%ied-bd%isd+1)*(bd%je-bd%js+2)*npz)
      CALL POPREAL4ARRAY(ra_y, (bd%ied-bd%isd+1)*(bd%je-bd%js+1))
      CALL POPREAL4ARRAY(ra_x, (bd%ie-bd%is+1)*(bd%jed-bd%jsd+1))
      CALL POPINTEGER4(ie)
      CALL POPREAL4(frac)
      CALL POPREAL4ARRAY(dp2, (bd%ie-bd%is+1)*(bd%je-bd%js+1))
      rarea => gridstruct%rarea
      !CALL ADMM_REBASE(rarea)
      CALL POPREAL4ARRAY(xfx, (bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*npz)
      CALL POPINTEGER4(js)
      xfx_ad = 0.0
      yfx_ad = 0.0
      DO k=npz,1,-1
        DO j=je,js,-1
          DO i=ie,is,-1
            CALL POPREAL4(dp1(i, j, k))
            temp_ad2 = rarea(i, j)*rdt*dp1_ad(i, j, k)
            xfx_ad(i+1, j, k) = xfx_ad(i+1, j, k) + temp_ad2
            xfx_ad(i, j, k) = xfx_ad(i, j, k) - temp_ad2
            yfx_ad(i, j+1, k) = yfx_ad(i, j+1, k) + temp_ad2
            yfx_ad(i, j, k) = yfx_ad(i, j, k) - temp_ad2
            dp1_ad(i, j, k) = 0.0
          END DO
        END DO
      END DO
    END IF
    jsd = bd%jsd
    ied = bd%ied
    isd = bd%isd
    jed = bd%jed
    mfx_ad = 0.0
    mfy_ad = 0.0
    cx_ad = 0.0
    cy_ad = 0.0
    dp2_ad = 0.0
    ra_x_ad = 0.0
    ra_y_ad = 0.0
    fx_ad = 0.0
    fy_ad = 0.0
    DO it=nsplt,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        DO iq=nq,1,-1
          CALL POPREAL4ARRAY(q(isd:ied, jsd:jed, :, iq), (ied-isd+1)*(&
&                      jed-jsd+1)*npz)
          CALL NESTED_GRID_BC_APPLY_INTT_ADM(q(isd:ied, jsd:jed, :, iq)&
&                                      , q_ad(isd:ied, jsd:jed, :, iq), &
&                                      0, 0, npx, npy, npz, bd, arg1, &
&                                      arg2, neststruct%q_bc(iq), &
&                                      neststruct%nestbctype)
        END DO
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL4ARRAY(q, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*npz*nq&
&                   )
        CALL START_GROUP_HALO_UPDATE_ADM(q_pack, q, q_ad, domain)
      END IF
      DO k=npz,1,-1
        DO iq=nq,1,-1
          DO j=je,js,-1
            DO i=ie,is,-1
              CALL POPREAL4(q(i, j, k, iq))
              temp_ad0 = q_ad(i, j, k, iq)/dp2(i, j)
              temp = q(i, j, k, iq)
              temp_ad1 = rarea(i, j)*temp_ad0
              dp1_ad(i, j, k) = dp1_ad(i, j, k) + temp*temp_ad0
              fx_ad(i, j) = fx_ad(i, j) + temp_ad1
              fx_ad(i+1, j) = fx_ad(i+1, j) - temp_ad1
              fy_ad(i, j) = fy_ad(i, j) + temp_ad1
              fy_ad(i, j+1) = fy_ad(i, j+1) - temp_ad1
              dp2_ad(i, j) = dp2_ad(i, j) - (temp*dp1(i, j, k)+rarea(i, &
&               j)*(fx(i, j)-fx(i+1, j)+fy(i, j)-fy(i, j+1)))*temp_ad0/&
&               dp2(i, j)
              q_ad(i, j, k, iq) = dp1(i, j, k)*temp_ad0
            END DO
          END DO
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              CALL POPREAL4ARRAY(q(isd:ied, jsd:jed, k, iq), (ied-isd+1)&
&                          *(jed-jsd+1))
              CALL POPREAL4ARRAY(fx, (bd%ie-bd%is+2)*(bd%je-bd%js+1))
              CALL POPREAL4ARRAY(fy, (bd%ie-bd%is+1)*(bd%je-bd%js+2))
              CALL FV_TP_2D_ADM(q(isd:ied, jsd:jed, k, iq), q_ad(isd:ied&
&                         , jsd:jed, k, iq), cx(is:ie+1, jsd:jed, k), &
&                         cx_ad(is:ie+1, jsd:jed, k), cy(isd:ied, js:je+&
&                         1, k), cy_ad(isd:ied, js:je+1, k), npx, npy, &
&                         hord_pert, fx, fx_ad, fy, fy_ad, xfx(is:ie+1, &
&                         jsd:jed, k), xfx_ad(is:ie+1, jsd:jed, k), yfx(&
&                         isd:ied, js:je+1, k), yfx_ad(isd:ied, js:je+1&
&                         , k), gridstruct, bd, ra_x, ra_x_ad, ra_y, &
&                         ra_y_ad, mfx(is:ie+1, js:je, k), mfx_ad(is:ie+&
&                         1, js:je, k), mfy(is:ie, js:je+1, k), mfy_ad(&
&                         is:ie, js:je+1, k))
            ELSE
              CALL POPREAL4ARRAY(q(isd:ied, jsd:jed, k, iq), (ied-isd+1)&
&                          *(jed-jsd+1))
              CALL POPREAL4ARRAY(fx, (bd%ie-bd%is+2)*(bd%je-bd%js+1))
              CALL POPREAL4ARRAY(fy, (bd%ie-bd%is+1)*(bd%je-bd%js+2))
              CALL FV_TP_2D_ADM(q(isd:ied, jsd:jed, k, iq), q_ad(isd:ied&
&                         , jsd:jed, k, iq), cx(is:ie+1, jsd:jed, k), &
&                         cx_ad(is:ie+1, jsd:jed, k), cy(isd:ied, js:je+&
&                         1, k), cy_ad(isd:ied, js:je+1, k), npx, npy, &
&                         hord_pert, fx, fx_ad, fy, fy_ad, xfx(is:ie+1, &
&                         jsd:jed, k), xfx_ad(is:ie+1, jsd:jed, k), yfx(&
&                         isd:ied, js:je+1, k), yfx_ad(isd:ied, js:je+1&
&                         , k), gridstruct, bd, ra_x, ra_x_ad, ra_y, &
&                         ra_y_ad, mfx(is:ie+1, js:je, k), mfx_ad(is:ie+&
&                         1, js:je, k), mfy(is:ie, js:je+1, k), mfy_ad(&
&                         is:ie, js:je+1, k), dp1(isd:ied, jsd:jed, k), &
&                         dp1_ad(isd:ied, jsd:jed, k), nord=nord_tr_pert&
&                         , damp_c=trdm_pert)
            END IF
          ELSE IF (branch .EQ. 2) THEN
            CALL FV_TP_2D_BWD(q(isd:ied, jsd:jed, k, iq), q_ad(isd:&
&                          ied, jsd:jed, k, iq), cx(is:ie+1, jsd:jed, k)&
&                          , cx_ad(is:ie+1, jsd:jed, k), cy(isd:ied, js:&
&                          je+1, k), cy_ad(isd:ied, js:je+1, k), npx, &
&                          npy, hord, fx, fx_ad, fy, fy_ad, xfx(is:ie+1&
&                          , jsd:jed, k), xfx_ad(is:ie+1, jsd:jed, k), &
&                          yfx(isd:ied, js:je+1, k), yfx_ad(isd:ied, js:&
&                          je+1, k), gridstruct, bd, ra_x, ra_x_ad, ra_y&
&                          , ra_y_ad, mfx(is:ie+1, js:je, k), mfx_ad(is:&
&                          ie+1, js:je, k), mfy(is:ie, js:je+1, k), &
&                          mfy_ad(is:ie, js:je+1, k))
          ELSE
            CALL FV_TP_2D_BWD(q(isd:ied, jsd:jed, k, iq), q_ad(isd:&
&                          ied, jsd:jed, k, iq), cx(is:ie+1, jsd:jed, k)&
&                          , cx_ad(is:ie+1, jsd:jed, k), cy(isd:ied, js:&
&                          je+1, k), cy_ad(isd:ied, js:je+1, k), npx, &
&                          npy, hord, fx, fx_ad, fy, fy_ad, xfx(is:ie+1&
&                          , jsd:jed, k), xfx_ad(is:ie+1, jsd:jed, k), &
&                          yfx(isd:ied, js:je+1, k), yfx_ad(isd:ied, js:&
&                          je+1, k), gridstruct, bd, ra_x, ra_x_ad, ra_y&
&                          , ra_y_ad, mfx(is:ie+1, js:je, k), mfx_ad(is:&
&                          ie+1, js:je, k), mfy(is:ie, js:je+1, k), &
&                          mfy_ad(is:ie, js:je+1, k), dp1(isd:ied, jsd:&
&                          jed, k), dp1_ad(isd:ied, jsd:jed, k), nord=&
&                          nord_tr, damp_c=trdm)
          END IF
        END DO
        DO j=je,js,-1
          DO i=ied,isd,-1
            CALL POPREAL4(ra_y(i, j))
            yfx_ad(i, j, k) = yfx_ad(i, j, k) + ra_y_ad(i, j)
            yfx_ad(i, j+1, k) = yfx_ad(i, j+1, k) - ra_y_ad(i, j)
            ra_y_ad(i, j) = 0.0
          END DO
        END DO
        DO j=jed,jsd,-1
          DO i=ie,is,-1
            CALL POPREAL4(ra_x(i, j))
            xfx_ad(i, j, k) = xfx_ad(i, j, k) + ra_x_ad(i, j)
            xfx_ad(i+1, j, k) = xfx_ad(i+1, j, k) - ra_x_ad(i, j)
            ra_x_ad(i, j) = 0.0
          END DO
        END DO
        DO j=je,js,-1
          DO i=ie,is,-1
            CALL POPREAL4(dp2(i, j))
            temp_ad = rarea(i, j)*dp2_ad(i, j)
            dp1_ad(i, j, k) = dp1_ad(i, j, k) + dp2_ad(i, j)
            mfx_ad(i, j, k) = mfx_ad(i, j, k) + temp_ad
            mfx_ad(i+1, j, k) = mfx_ad(i+1, j, k) - temp_ad
            mfy_ad(i, j, k) = mfy_ad(i, j, k) + temp_ad
            mfy_ad(i, j+1, k) = mfy_ad(i, j+1, k) - temp_ad
            dp2_ad(i, j) = 0.0
          END DO
        END DO
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        DO iq=nq,1,-1
          CALL POPREAL4ARRAY(q(isd:ied, jsd:jed, :, iq), (ied-isd+1)*(&
&                      jed-jsd+1)*npz)
          CALL NESTED_GRID_BC_APPLY_INTT_ADM(q(isd:ied, jsd:jed, :, iq)&
&                                      , q_ad(isd:ied, jsd:jed, :, iq), &
&                                      0, 0, npx, npy, npz, bd, arg1, &
&                                      arg2, neststruct%q_bc(iq), &
&                                      neststruct%nestbctype)
        END DO
      END IF
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      DO k=npz,1,-1
        DO j=je+1,js,-1
          DO i=ie,is,-1
            CALL POPREAL4(mfy(i, j, k))
            mfy_ad(i, j, k) = frac*mfy_ad(i, j, k)
          END DO
        END DO
        DO j=je+1,js,-1
          DO i=ied,isd,-1
            yfx_ad(i, j, k) = frac*yfx_ad(i, j, k)
            CALL POPREAL4(cy(i, j, k))
            cy_ad(i, j, k) = frac*cy_ad(i, j, k)
          END DO
        END DO
        DO j=je,js,-1
          DO i=ie+1,is,-1
            CALL POPREAL4(mfx(i, j, k))
            mfx_ad(i, j, k) = frac*mfx_ad(i, j, k)
          END DO
        END DO
        DO j=jed,jsd,-1
          DO i=ie+1,is,-1
            xfx_ad(i, j, k) = frac*xfx_ad(i, j, k)
            CALL POPREAL4(cx(i, j, k))
            cx_ad(i, j, k) = frac*cx_ad(i, j, k)
          END DO
        END DO
      END DO
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO k=npz,2,-1
          CALL POPCONTROL1B(branch)
        END DO
      END IF
      sin_sg => gridstruct%sin_sg
      DO k=npz,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          DO j=je,js,-1
            DO i=ie,is,-1
              CALL POPCONTROL1B(branch)
            END DO
          END DO
        ELSE
          DO j=je,js,-1
            DO i=ie,is,-1
              CALL POPCONTROL1B(branch)
            END DO
          END DO
        END IF
      END DO
    ELSE
      sin_sg => gridstruct%sin_sg
    END IF
    dxa => gridstruct%dxa
    dx => gridstruct%dx
    dy => gridstruct%dy
    dya => gridstruct%dya
    DO k=npz,1,-1
      DO j=je+1,js,-1
        DO i=ied,isd,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            cy_ad(i, j, k) = cy_ad(i, j, k) + dya(i, j)*dx(i, j)*sin_sg(&
&             i, j, 2)*yfx_ad(i, j, k)
            yfx_ad(i, j, k) = 0.0
          ELSE
            cy_ad(i, j, k) = cy_ad(i, j, k) + dya(i, j-1)*dx(i, j)*&
&             sin_sg(i, j-1, 4)*yfx_ad(i, j, k)
            yfx_ad(i, j, k) = 0.0
          END IF
        END DO
      END DO
      DO j=jed,jsd,-1
        DO i=ie+1,is,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            cx_ad(i, j, k) = cx_ad(i, j, k) + dxa(i, j)*dy(i, j)*sin_sg(&
&             i, j, 1)*xfx_ad(i, j, k)
            xfx_ad(i, j, k) = 0.0
          ELSE
            cx_ad(i, j, k) = cx_ad(i, j, k) + dxa(i-1, j)*dy(i, j)*&
&             sin_sg(i-1, j, 3)*xfx_ad(i, j, k)
            xfx_ad(i, j, k) = 0.0
          END IF
        END DO
      END DO
    END DO
  END SUBROUTINE TRACER_2D_NESTED_BWD
  SUBROUTINE TRACER_2D_NESTED(q, dp1, mfx, mfy, cx, cy, gridstruct, bd, &
&   domain, npx, npy, npz, nq, hord, q_split, dt, id_divg, q_pack, &
&   nord_tr, trdm, k_split, neststruct, parent_grid, hord_pert, &
&   nord_tr_pert, trdm_pert, split_damp_tr)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
! number of tracers to be advected
    INTEGER, INTENT(IN) :: nq
    INTEGER, INTENT(IN) :: hord, nord_tr
    INTEGER, INTENT(IN) :: hord_pert, nord_tr_pert
    LOGICAL, INTENT(IN) :: split_damp_tr
    INTEGER, INTENT(IN) :: q_split, k_split
    INTEGER, INTENT(IN) :: id_divg
    REAL, INTENT(IN) :: dt, trdm, trdm_pert
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: q_pack
! Tracers
    REAL, INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, nq)
! DELP before dyn_core
    REAL, INTENT(INOUT) :: dp1(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! Mass Flux X-Dir
    REAL, INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
! Mass Flux Y-Dir
    REAL, INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
! Courant Number X-Dir
    REAL, INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
! Courant Number Y-Dir
    REAL, INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_NEST_TYPE), INTENT(INOUT) :: neststruct
    TYPE(FV_ATMOS_TYPE), INTENT(INOUT) :: parent_grid
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
! Local Arrays
    REAL :: dp2(bd%is:bd%ie, bd%js:bd%je)
    REAL :: fx(bd%is:bd%ie+1, bd%js:bd%je)
    REAL :: fy(bd%is:bd%ie, bd%js:bd%je+1)
    REAL :: ra_x(bd%is:bd%ie, bd%jsd:bd%jed)
    REAL :: ra_y(bd%isd:bd%ied, bd%js:bd%je)
    REAL :: xfx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL :: yfx(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL :: cmax(npz)
    REAL :: cmax_t
    REAL :: c_global
    REAL :: frac, rdt
    INTEGER :: nsplt, nsplt_parent
    INTEGER, SAVE :: msg_split_steps=1
    INTEGER :: i, j, k, it, iq
    REAL, DIMENSION(:, :), POINTER :: area, rarea
    REAL, DIMENSION(:, :, :), POINTER :: sin_sg
    REAL, DIMENSION(:, :), POINTER :: dxa, dya, dx, dy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC INT
    INTRINSIC REAL
    REAL :: max1
    REAL :: arg1
    REAL :: arg2
    REAL :: x2
    REAL :: x1
    REAL :: y2
    REAL :: y1
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    area => gridstruct%area
    rarea => gridstruct%rarea
    sin_sg => gridstruct%sin_sg
    dxa => gridstruct%dxa
    dya => gridstruct%dya
    dx => gridstruct%dx
    dy => gridstruct%dy
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,jsd,jed,npz,cx,xfx,dxa,dy, &
!$OMP                                  sin_sg,cy,yfx,dya,dx)
    DO k=1,npz
      DO j=jsd,jed
        DO i=is,ie+1
          IF (cx(i, j, k) .GT. 0.) THEN
            xfx(i, j, k) = cx(i, j, k)*dxa(i-1, j)*dy(i, j)*sin_sg(i-1, &
&             j, 3)
          ELSE
            xfx(i, j, k) = cx(i, j, k)*dxa(i, j)*dy(i, j)*sin_sg(i, j, 1&
&             )
          END IF
        END DO
      END DO
      DO j=js,je+1
        DO i=isd,ied
          IF (cy(i, j, k) .GT. 0.) THEN
            yfx(i, j, k) = cy(i, j, k)*dya(i, j-1)*dx(i, j)*sin_sg(i, j-&
&             1, 4)
          ELSE
            yfx(i, j, k) = cy(i, j, k)*dya(i, j)*dx(i, j)*sin_sg(i, j, 2&
&             )
          END IF
        END DO
      END DO
    END DO
!--------------------------------------------------------------------------------
    IF (q_split .EQ. 0) THEN
! Determine nsplt
!$OMP parallel do default(none) shared(is,ie,js,je,npz,cmax,cx,cy,sin_sg) &
!$OMP                          private(cmax_t )
      DO k=1,npz
        cmax(k) = 0.
        IF (k .LT. 4) THEN
! Top layers: C < max( abs(c_x), abs(c_y) )
          DO j=js,je
            DO i=is,ie
              IF (cx(i, j, k) .GE. 0.) THEN
                x1 = cx(i, j, k)
              ELSE
                x1 = -cx(i, j, k)
              END IF
              IF (cy(i, j, k) .GE. 0.) THEN
                y1 = cy(i, j, k)
              ELSE
                y1 = -cy(i, j, k)
              END IF
              IF (x1 .LT. y1) THEN
                cmax_t = y1
              ELSE
                cmax_t = x1
              END IF
              IF (cmax_t .LT. cmax(k)) THEN
                cmax(k) = cmax(k)
              ELSE
                cmax(k) = cmax_t
              END IF
            END DO
          END DO
        ELSE
          DO j=js,je
            DO i=is,ie
              IF (cx(i, j, k) .GE. 0.) THEN
                x2 = cx(i, j, k)
              ELSE
                x2 = -cx(i, j, k)
              END IF
              IF (cy(i, j, k) .GE. 0.) THEN
                y2 = cy(i, j, k)
              ELSE
                y2 = -cy(i, j, k)
              END IF
              IF (x2 .LT. y2) THEN
                max1 = y2
              ELSE
                max1 = x2
              END IF
              cmax_t = max1 + 1. - sin_sg(i, j, 5)
              IF (cmax_t .LT. cmax(k)) THEN
                cmax(k) = cmax(k)
              ELSE
                cmax(k) = cmax_t
              END IF
            END DO
          END DO
        END IF
      END DO
      CALL MP_REDUCE_MAX(cmax, npz)
! find global max courant number and define nsplt to scale cx,cy,mfx,mfy
      c_global = cmax(1)
      IF (npz .NE. 1) THEN
! if NOT shallow water test case
        DO k=2,npz
          IF (cmax(k) .LT. c_global) THEN
            c_global = c_global
          ELSE
            c_global = cmax(k)
          END IF
        END DO
      END IF
      nsplt = INT(1. + c_global)
      IF (IS_MASTER() .AND. nsplt .GT. 3) WRITE(*, *) 'Tracer_2d_split='&
&                                         , nsplt, c_global
    ELSE
      nsplt = q_split
      IF (gridstruct%nested .AND. neststruct%nestbctype .GT. 1) THEN
        IF (q_split/parent_grid%flagstruct%q_split .LT. 1) THEN
          msg_split_steps = 1
        ELSE
          msg_split_steps = q_split/parent_grid%flagstruct%q_split
        END IF
      END IF
    END IF
!--------------------------------------------------------------------------------
    frac = 1./REAL(nsplt)
    IF (nsplt .NE. 1) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,jsd,jed,npz,cx,frac,xfx,mfx,cy,yfx,mfy)
      DO k=1,npz
        DO j=jsd,jed
          DO i=is,ie+1
            cx(i, j, k) = cx(i, j, k)*frac
            xfx(i, j, k) = xfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je
          DO i=is,ie+1
            mfx(i, j, k) = mfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je+1
          DO i=isd,ied
            cy(i, j, k) = cy(i, j, k)*frac
            yfx(i, j, k) = yfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je+1
          DO i=is,ie
            mfy(i, j, k) = mfy(i, j, k)*frac
          END DO
        END DO
      END DO
    END IF
    DO it=1,nsplt
      IF (gridstruct%nested) neststruct%tracer_nest_timestep = &
&         neststruct%tracer_nest_timestep + 1
      CALL TIMING_ON('COMM_TOTAL')
      CALL TIMING_ON('COMM_TRACER')
      CALL COMPLETE_GROUP_HALO_UPDATE(q_pack, domain)
      CALL TIMING_OFF('COMM_TRACER')
      CALL TIMING_OFF('COMM_TOTAL')
      IF (gridstruct%nested) THEN
        DO iq=1,nq
          arg1 = REAL(neststruct%tracer_nest_timestep) + REAL(nsplt*&
&           k_split)
          arg2 = REAL(nsplt*k_split)
          CALL NESTED_GRID_BC_APPLY_INTT(q(isd:ied, jsd:jed, :, iq), 0, &
&                                  0, npx, npy, npz, bd, arg1, arg2, &
&                                  neststruct%q_bc(iq), neststruct%&
&                                  nestbctype)
        END DO
      END IF
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,jsd,jed,npz,dp1,mfx,mfy,rarea,nq, &
!$OMP                                  area,xfx,yfx,q,cx,cy,npx,npy,hord,gridstruct,bd,it,nsplt,nord_tr,trdm) &
!$OMP                          private(dp2, ra_x, ra_y, fx, fy)
      DO k=1,npz
        DO j=js,je
          DO i=is,ie
            dp2(i, j) = dp1(i, j, k) + (mfx(i, j, k)-mfx(i+1, j, k)+mfy(&
&             i, j, k)-mfy(i, j+1, k))*rarea(i, j)
          END DO
        END DO
        DO j=jsd,jed
          DO i=is,ie
            ra_x(i, j) = area(i, j) + xfx(i, j, k) - xfx(i+1, j, k)
          END DO
        END DO
        DO j=js,je
          DO i=isd,ied
            ra_y(i, j) = area(i, j) + yfx(i, j, k) - yfx(i, j+1, k)
          END DO
        END DO
        DO iq=1,nq
          IF (hord .EQ. hord_pert .AND. (.NOT.split_damp_tr)) THEN
            IF (it .EQ. 1 .AND. trdm .GT. 1.e-4) THEN
              CALL FV_TP_2D(q(isd:ied, jsd:jed, k, iq), cx(is:ie+1, &
&                        jsd:jed, k), cy(isd:ied, js:je+1, k), npx, npy&
&                        , hord, fx, fy, xfx(is:ie+1, jsd:jed, k), yfx(&
&                        isd:ied, js:je+1, k), gridstruct, bd, ra_x, &
&                        ra_y, mfx(is:ie+1, js:je, k), mfy(is:ie, js:je+&
&                        1, k), dp1(isd:ied, jsd:jed, k), nord_tr, trdm)
            ELSE
              CALL FV_TP_2D(q(isd:ied, jsd:jed, k, iq), cx(is:ie+1, &
&                        jsd:jed, k), cy(isd:ied, js:je+1, k), npx, npy&
&                        , hord, fx, fy, xfx(is:ie+1, jsd:jed, k), yfx(&
&                        isd:ied, js:je+1, k), gridstruct, bd, ra_x, &
&                        ra_y, mfx=mfx(is:ie+1, js:je, k), mfy=mfy(is:ie&
&                        , js:je+1, k))
            END IF
          ELSE IF (it .EQ. 1 .AND. trdm_pert .GT. 1.e-4) THEN
            CALL FV_TP_2D(q(isd:ied, jsd:jed, k, iq), cx(is:ie+1, jsd:&
&                   jed, k), cy(isd:ied, js:je+1, k), npx, npy, &
&                   hord_pert, fx, fy, xfx(is:ie+1, jsd:jed, k), yfx(isd&
&                   :ied, js:je+1, k), gridstruct, bd, ra_x, ra_y, mfx(&
&                   is:ie+1, js:je, k), mfy(is:ie, js:je+1, k), dp1(isd:&
&                   ied, jsd:jed, k), nord_tr_pert, trdm_pert)
          ELSE
            CALL FV_TP_2D(q(isd:ied, jsd:jed, k, iq), cx(is:ie+1, jsd:&
&                   jed, k), cy(isd:ied, js:je+1, k), npx, npy, &
&                   hord_pert, fx, fy, xfx(is:ie+1, jsd:jed, k), yfx(isd&
&                   :ied, js:je+1, k), gridstruct, bd, ra_x, ra_y, mfx=&
&                   mfx(is:ie+1, js:je, k), mfy=mfy(is:ie, js:je+1, k))
          END IF
          DO j=js,je
            DO i=is,ie
              q(i, j, k, iq) = (q(i, j, k, iq)*dp1(i, j, k)+(fx(i, j)-fx&
&               (i+1, j)+fy(i, j)-fy(i, j+1))*rarea(i, j))/dp2(i, j)
            END DO
          END DO
        END DO
      END DO
! npz
      IF (it .NE. nsplt) THEN
        CALL TIMING_ON('COMM_TOTAL')
        CALL TIMING_ON('COMM_TRACER')
        CALL START_GROUP_HALO_UPDATE(q_pack, q, domain)
        CALL TIMING_OFF('COMM_TRACER')
        CALL TIMING_OFF('COMM_TOTAL')
      END IF
!Apply nested-grid BCs
      IF (gridstruct%nested) THEN
        DO iq=1,nq
          arg1 = REAL(neststruct%tracer_nest_timestep)
          arg2 = REAL(nsplt*k_split)
          CALL NESTED_GRID_BC_APPLY_INTT(q(isd:ied, jsd:jed, :, iq), 0, &
&                                  0, npx, npy, npz, bd, arg1, arg2, &
&                                  neststruct%q_bc(iq), neststruct%&
&                                  nestbctype)
        END DO
      END IF
    END DO
! nsplt
    IF (id_divg .GT. 0) THEN
      rdt = 1./(frac*dt)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,dp1,xfx,yfx,rarea,rdt)
      DO k=1,npz
        DO j=js,je
          DO i=is,ie
            dp1(i, j, k) = (xfx(i+1, j, k)-xfx(i, j, k)+yfx(i, j+1, k)-&
&             yfx(i, j, k))*rarea(i, j)*rdt
          END DO
        END DO
      END DO
    END IF
  END SUBROUTINE TRACER_2D_NESTED
END MODULE FV_TRACER2D_MOD_B
