!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
MODULE FV_RESTART_MOD_B
  IMPLICIT NONE
  PRIVATE 
  PUBLIC d2c_setup, d2a_setup
  PUBLIC d2c_setup_fwd, d2c_setup_bwd
  EXTERNAL D2C_SETUP_ADM

CONTAINS
!  Differentiation of d2c_setup in reverse (adjoint) mode, forward sweep (with options split(a2b_edge_mod.a2b_ord4 a2b_edge_mo
!d.a2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_m
!od.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mod.mi
!x_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayleigh_
!Super fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_geos fv_g
!rid_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_mapz_m
!od.compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_
!tracer_fb fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_lim
!iters fv_mapz_mod.ppm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.mo
!ist_cv fv_mapz_mod.moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer_
!2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.Riem
!_Solver_c nh_utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SIM3p0
!_solver nh_utils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nest_ha
!lo_nh sw_core_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_vect
! sw_core_mod.fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v sw_co
!re_mod.compute_divergence_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_core_mod.
!fv_tp_2d tp_core_mod.copy_corners tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_cor
!ner_fb fv_grid_utils_mod.great_circle_dist sw_core_mod.edge_interpolate4)):
!   gradient     of useful results: u v uc vc
!   with respect to varying inputs: u v uc vc
  SUBROUTINE D2C_SETUP_FWD(u, v, ua, va, uc, vc, dord4, isd, ied, jsd, &
&   jed, is, ie, js, je, npx, npy, grid_type, nested, se_corner, &
&   sw_corner, ne_corner, nw_corner, rsin_u, rsin_v, cosa_s, rsin2)
    IMPLICIT NONE
    LOGICAL, INTENT(IN) :: dord4
    INTEGER, INTENT(IN) :: isd, ied, jsd, jed, is, ie, js, je, npx, npy&
&   , grid_type
    REAL, INTENT(IN) :: u(isd:ied, jsd:jed+1)
    REAL, INTENT(IN) :: v(isd:ied+1, jsd:jed)
    REAL, DIMENSION(isd:ied, jsd:jed), INTENT(OUT) :: ua
    REAL, DIMENSION(isd:ied, jsd:jed), INTENT(OUT) :: va
    REAL, DIMENSION(isd:ied+1, jsd:jed) :: uc
    REAL, DIMENSION(isd:ied, jsd:jed+1) :: vc
    LOGICAL, INTENT(IN) :: nested, se_corner, sw_corner, ne_corner, &
&   nw_corner
    REAL, INTENT(IN) :: rsin_u(isd:ied+1, jsd:jed)
    REAL, INTENT(IN) :: rsin_v(isd:ied, jsd:jed+1)
    REAL, INTENT(IN) :: cosa_s(isd:ied, jsd:jed)
    REAL, INTENT(IN) :: rsin2(isd:ied, jsd:jed)
! Local 
    REAL, DIMENSION(isd:ied, jsd:jed) :: utmp, vtmp
    REAL, PARAMETER :: t11=27./28., t12=-(13./28.), t13=3./7., t14=6./7.&
&   , t15=3./28.
    REAL, PARAMETER :: a1=0.5625
    REAL, PARAMETER :: a2=-0.0625
    REAL, PARAMETER :: c1=-(2./14.)
    REAL, PARAMETER :: c2=11./14.
    REAL, PARAMETER :: c3=5./14.
    INTEGER :: npt, i, j, ifirst, ilast, id
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: max5
    INTEGER :: max6
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    INTEGER :: min5
    INTEGER :: min6
    INTEGER :: ad_from
    INTEGER :: ad_from0
    IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
      npt = 4
    ELSE
      npt = -2
    END IF
    IF (nested) THEN
      CALL PUSHINTEGER4(j)
      DO j=jsd,jed
        CALL PUSHINTEGER4(i)
      END DO
      CALL PUSHCONTROL2B(0)
    ELSE
!----------
! Interior:
!----------
      IF (npt .LT. js - 1) THEN
        max1 = js - 1
      ELSE
        max1 = npt
      END IF
      IF (npy - npt .GT. je + 1) THEN
        min1 = je + 1
      ELSE
        min1 = npy - npt
      END IF
      DO j=max1,min1
        IF (npt .LT. isd) THEN
          max2 = isd
        ELSE
          max2 = npt
        END IF
        IF (npx - npt .GT. ied) THEN
          min2 = ied
        ELSE
          min2 = npx - npt
        END IF
        ad_from = max2
        i = min2 + 1
        CALL PUSHINTEGER4(i - 1)
        CALL PUSHINTEGER4(ad_from)
      END DO
      IF (npt .LT. jsd) THEN
        max3 = jsd
      ELSE
        max3 = npt
      END IF
      IF (npy - npt .GT. jed) THEN
        min3 = jed
      ELSE
        min3 = npy - npt
      END IF
      DO j=max3,min3
        IF (npt .LT. is - 1) THEN
          max4 = is - 1
        ELSE
          max4 = npt
        END IF
        IF (npx - npt .GT. ie + 1) THEN
          min4 = ie + 1
        ELSE
          min4 = npx - npt
        END IF
        ad_from0 = max4
        i = min4 + 1
        CALL PUSHINTEGER4(i - 1)
        CALL PUSHINTEGER4(ad_from0)
      END DO
!----------
! edges:
!----------
      IF (grid_type .LT. 3) THEN
        IF (js .EQ. 1 .OR. jsd .LT. npt) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (je + 1 .EQ. npy .OR. jed .GE. npy - npt) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (is .EQ. 1 .OR. isd .LT. npt) THEN
          IF (npt .LT. jsd) THEN
            max5 = jsd
          ELSE
            max5 = npt
          END IF
          IF (npy - npt .GT. jed) THEN
            min5 = jed
          ELSE
            min5 = npy - npt
          END IF
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (ie + 1 .EQ. npx .OR. ied .GE. npx - npt) THEN
          IF (npt .LT. jsd) THEN
            max6 = jsd
          ELSE
            max6 = npt
          END IF
          IF (npy - npt .GT. jed) THEN
            min6 = jed
          ELSE
            min6 = npy - npt
          END IF
          CALL PUSHCONTROL2B(3)
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
      ELSE
        CALL PUSHCONTROL2B(1)
      END IF
    END IF
! A -> C
!--------------
! Fix the edges
!--------------
! Xdir:
    IF (sw_corner) THEN
      CALL PUSHINTEGER4(i)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (se_corner) THEN
      CALL PUSHINTEGER4(i)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (ne_corner) THEN
      CALL PUSHINTEGER4(i)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nw_corner) THEN
      CALL PUSHINTEGER4(i)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
      IF (3 .LT. is - 1) THEN
        ifirst = is - 1
      ELSE
        ifirst = 3
      END IF
      IF (npx - 2 .GT. ie + 2) THEN
        CALL PUSHCONTROL1B(1)
        ilast = ie + 2
      ELSE
        CALL PUSHCONTROL1B(1)
        ilast = npx - 2
      END IF
    ELSE
      CALL PUSHCONTROL1B(0)
      ifirst = is - 1
      ilast = ie + 2
    END IF
!---------------------------------------------
! 4th order interpolation for interior points:
!---------------------------------------------
    DO j=js-1,je+1
      CALL PUSHINTEGER4(i)
    END DO
    IF (grid_type .LT. 3) THEN
! Xdir:
      IF (is .EQ. 1 .AND. (.NOT.nested)) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (ie + 1 .EQ. npx .AND. (.NOT.nested)) THEN
        CALL PUSHCONTROL2B(0)
      ELSE
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(2)
    END IF
!------
! Ydir:
!------
    IF (sw_corner) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nw_corner) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (se_corner) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (ne_corner) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (grid_type .LT. 3) THEN
      DO j=js-1,je+2
        IF (j .EQ. 1 .AND. (.NOT.nested)) THEN
          CALL PUSHINTEGER4(i)
          CALL PUSHCONTROL3B(4)
        ELSE IF ((j .EQ. 0 .OR. j .EQ. npy - 1) .AND. (.NOT.nested)) &
&       THEN
          CALL PUSHINTEGER4(i)
          CALL PUSHCONTROL3B(3)
        ELSE IF ((j .EQ. 2 .OR. j .EQ. npy + 1) .AND. (.NOT.nested)) &
&       THEN
          CALL PUSHINTEGER4(i)
          CALL PUSHCONTROL3B(2)
        ELSE IF (j .EQ. npy .AND. (.NOT.nested)) THEN
          CALL PUSHINTEGER4(i)
          CALL PUSHCONTROL3B(1)
        ELSE
          CALL PUSHINTEGER4(i)
          CALL PUSHCONTROL3B(0)
        END IF
      END DO
      CALL PUSHINTEGER4(max1)
      CALL PUSHINTEGER4(max3)
      CALL PUSHINTEGER4(max5)
      CALL PUSHINTEGER4(max6)
      CALL PUSHINTEGER4(ilast)
      CALL PUSHINTEGER4(min1)
      CALL PUSHINTEGER4(min3)
      CALL PUSHINTEGER4(min5)
      CALL PUSHINTEGER4(min6)
      CALL PUSHINTEGER4(ifirst)
      CALL PUSHCONTROL1B(0)
    ELSE
! 4th order interpolation:
      DO j=js-1,je+2
        CALL PUSHINTEGER4(i)
      END DO
      CALL PUSHINTEGER4(max1)
      CALL PUSHINTEGER4(max3)
      CALL PUSHINTEGER4(max5)
      CALL PUSHINTEGER4(max6)
      CALL PUSHINTEGER4(ilast)
      CALL PUSHINTEGER4(min1)
      CALL PUSHINTEGER4(min3)
      CALL PUSHINTEGER4(min5)
      CALL PUSHINTEGER4(min6)
      CALL PUSHINTEGER4(ifirst)
      CALL PUSHCONTROL1B(1)
    END IF
  END SUBROUTINE D2C_SETUP_FWD
!  Differentiation of d2c_setup in reverse (adjoint) mode, backward sweep (with options split(a2b_edge_mod.a2b_ord4 a2b_edge_m
!od.a2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_
!mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mod.m
!ix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayleigh
!_Super fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_geos fv_
!grid_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_mapz_
!mod.compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn
!_tracer_fb fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_li
!miters fv_mapz_mod.ppm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.m
!oist_cv fv_mapz_mod.moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer
!_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.Rie
!m_Solver_c nh_utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SIM3p
!0_solver nh_utils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nest_h
!alo_nh sw_core_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_vec
!t sw_core_mod.fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v sw_c
!ore_mod.compute_divergence_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_core_mod
!.fv_tp_2d tp_core_mod.copy_corners tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_co
!rner_fb fv_grid_utils_mod.great_circle_dist sw_core_mod.edge_interpolate4)):
!   gradient     of useful results: u v uc vc
!   with respect to varying inputs: u v uc vc
  SUBROUTINE D2C_SETUP_BWD(u, u_ad, v, v_ad, ua, va, uc, uc_ad, vc, &
&   vc_ad, dord4, isd, ied, jsd, jed, is, ie, js, je, npx, npy, &
&   grid_type, nested, se_corner, sw_corner, ne_corner, nw_corner, &
&   rsin_u, rsin_v, cosa_s, rsin2)
    IMPLICIT NONE
    LOGICAL, INTENT(IN) :: dord4
    INTEGER, INTENT(IN) :: isd, ied, jsd, jed, is, ie, js, je, npx, npy&
&   , grid_type
    REAL, INTENT(IN) :: u(isd:ied, jsd:jed+1)
    REAL :: u_ad(isd:ied, jsd:jed+1)
    REAL, INTENT(IN) :: v(isd:ied+1, jsd:jed)
    REAL :: v_ad(isd:ied+1, jsd:jed)
    REAL, DIMENSION(isd:ied, jsd:jed), INTENT(OUT) :: ua
    REAL, DIMENSION(isd:ied, jsd:jed), INTENT(OUT) :: va
    REAL, DIMENSION(isd:ied+1, jsd:jed) :: uc
    REAL, DIMENSION(isd:ied+1, jsd:jed) :: uc_ad
    REAL, DIMENSION(isd:ied, jsd:jed+1) :: vc
    REAL, DIMENSION(isd:ied, jsd:jed+1) :: vc_ad
    LOGICAL, INTENT(IN) :: nested, se_corner, sw_corner, ne_corner, &
&   nw_corner
    REAL, INTENT(IN) :: rsin_u(isd:ied+1, jsd:jed)
    REAL, INTENT(IN) :: rsin_v(isd:ied, jsd:jed+1)
    REAL, INTENT(IN) :: cosa_s(isd:ied, jsd:jed)
    REAL, INTENT(IN) :: rsin2(isd:ied, jsd:jed)
    REAL, DIMENSION(isd:ied, jsd:jed) :: utmp, vtmp
    REAL, DIMENSION(isd:ied, jsd:jed) :: utmp_ad, vtmp_ad
    REAL, PARAMETER :: t11=27./28., t12=-(13./28.), t13=3./7., t14=6./7.&
&   , t15=3./28.
    REAL, PARAMETER :: a1=0.5625
    REAL, PARAMETER :: a2=-0.0625
    REAL, PARAMETER :: c1=-(2./14.)
    REAL, PARAMETER :: c2=11./14.
    REAL, PARAMETER :: c3=5./14.
    INTEGER :: npt, i, j, ifirst, ilast, id
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: max5
    INTEGER :: max6
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    INTEGER :: min5
    INTEGER :: min6
    REAL :: temp_ad
    REAL :: temp_ad0
    REAL :: temp_ad1
    REAL :: temp_ad2
    INTEGER :: ad_from
    INTEGER :: ad_to
    INTEGER :: ad_from0
    INTEGER :: ad_to0
    INTEGER :: branch
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPINTEGER4(ifirst)
      CALL POPINTEGER4(min6)
      CALL POPINTEGER4(min5)
      CALL POPINTEGER4(min3)
      CALL POPINTEGER4(min1)
      CALL POPINTEGER4(ilast)
      CALL POPINTEGER4(max6)
      CALL POPINTEGER4(max5)
      CALL POPINTEGER4(max3)
      CALL POPINTEGER4(max1)
      vtmp_ad = 0.0
      DO j=je+2,js-1,-1
        CALL POPCONTROL3B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) THEN
            DO i=ie+1,is-1,-1
              vtmp_ad(i, j-2) = vtmp_ad(i, j-2) + a2*vc_ad(i, j)
              vtmp_ad(i, j+1) = vtmp_ad(i, j+1) + a2*vc_ad(i, j)
              vtmp_ad(i, j-1) = vtmp_ad(i, j-1) + a1*vc_ad(i, j)
              vtmp_ad(i, j) = vtmp_ad(i, j) + a1*vc_ad(i, j)
              vc_ad(i, j) = 0.0
            END DO
            CALL POPINTEGER4(i)
          ELSE
            DO i=ie+1,is-1,-1
              temp_ad2 = rsin_v(i, npy)*vc_ad(i, npy)
              vtmp_ad(i, npy-1) = vtmp_ad(i, npy-1) + t14*temp_ad2
              vtmp_ad(i, npy) = vtmp_ad(i, npy) + t14*temp_ad2
              vtmp_ad(i, npy-2) = vtmp_ad(i, npy-2) + t12*temp_ad2
              vtmp_ad(i, npy+1) = vtmp_ad(i, npy+1) + t12*temp_ad2
              vtmp_ad(i, npy-3) = vtmp_ad(i, npy-3) + t15*temp_ad2
              vtmp_ad(i, npy+2) = vtmp_ad(i, npy+2) + t15*temp_ad2
              vc_ad(i, npy) = 0.0
            END DO
            CALL POPINTEGER4(i)
          END IF
        ELSE IF (branch .EQ. 2) THEN
          DO i=ie+1,is-1,-1
            vtmp_ad(i, j+1) = vtmp_ad(i, j+1) + c1*vc_ad(i, j)
            vtmp_ad(i, j) = vtmp_ad(i, j) + c2*vc_ad(i, j)
            vtmp_ad(i, j-1) = vtmp_ad(i, j-1) + c3*vc_ad(i, j)
            vc_ad(i, j) = 0.0
          END DO
          CALL POPINTEGER4(i)
        ELSE IF (branch .EQ. 3) THEN
          DO i=ie+1,is-1,-1
            vtmp_ad(i, j-2) = vtmp_ad(i, j-2) + c1*vc_ad(i, j)
            vtmp_ad(i, j-1) = vtmp_ad(i, j-1) + c2*vc_ad(i, j)
            vtmp_ad(i, j) = vtmp_ad(i, j) + c3*vc_ad(i, j)
            vc_ad(i, j) = 0.0
          END DO
          CALL POPINTEGER4(i)
        ELSE
          DO i=ie+1,is-1,-1
            temp_ad1 = rsin_v(i, 1)*vc_ad(i, 1)
            vtmp_ad(i, 0) = vtmp_ad(i, 0) + t14*temp_ad1
            vtmp_ad(i, 1) = vtmp_ad(i, 1) + t14*temp_ad1
            vtmp_ad(i, -1) = vtmp_ad(i, -1) + t12*temp_ad1
            vtmp_ad(i, 2) = vtmp_ad(i, 2) + t12*temp_ad1
            vtmp_ad(i, -2) = vtmp_ad(i, -2) + t15*temp_ad1
            vtmp_ad(i, 3) = vtmp_ad(i, 3) + t15*temp_ad1
            vc_ad(i, 1) = 0.0
          END DO
          CALL POPINTEGER4(i)
        END IF
      END DO
    ELSE
      CALL POPINTEGER4(ifirst)
      CALL POPINTEGER4(min6)
      CALL POPINTEGER4(min5)
      CALL POPINTEGER4(min3)
      CALL POPINTEGER4(min1)
      CALL POPINTEGER4(ilast)
      CALL POPINTEGER4(max6)
      CALL POPINTEGER4(max5)
      CALL POPINTEGER4(max3)
      CALL POPINTEGER4(max1)
      vtmp_ad = 0.0
      DO j=je+2,js-1,-1
        DO i=ie+1,is-1,-1
          vtmp_ad(i, j-2) = vtmp_ad(i, j-2) + a2*vc_ad(i, j)
          vtmp_ad(i, j+1) = vtmp_ad(i, j+1) + a2*vc_ad(i, j)
          vtmp_ad(i, j-1) = vtmp_ad(i, j-1) + a1*vc_ad(i, j)
          vtmp_ad(i, j) = vtmp_ad(i, j) + a1*vc_ad(i, j)
          vc_ad(i, j) = 0.0
        END DO
        CALL POPINTEGER4(i)
      END DO
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      utmp_ad = 0.0
      DO j=2,0,-1
        utmp_ad(ie-j, npy) = utmp_ad(ie-j, npy) - vtmp_ad(npx, npy+j)
        vtmp_ad(npx, npy+j) = 0.0
      END DO
    ELSE
      utmp_ad = 0.0
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO j=0,-2,-1
        utmp_ad(ie+j, 0) = utmp_ad(ie+j, 0) + vtmp_ad(npx, j)
        vtmp_ad(npx, j) = 0.0
      END DO
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO j=2,0,-1
        utmp_ad(j+1, npy) = utmp_ad(j+1, npy) + vtmp_ad(0, npy+j)
        vtmp_ad(0, npy+j) = 0.0
      END DO
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO j=0,-2,-1
        utmp_ad(1-j, 0) = utmp_ad(1-j, 0) - vtmp_ad(0, j)
        vtmp_ad(0, j) = 0.0
      END DO
    END IF
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      DO j=je+1,js-1,-1
        utmp_ad(npx, j) = utmp_ad(npx, j) + c3*uc_ad(npx+1, j)
        utmp_ad(npx+1, j) = utmp_ad(npx+1, j) + c2*uc_ad(npx+1, j)
        utmp_ad(npx+2, j) = utmp_ad(npx+2, j) + c1*uc_ad(npx+1, j)
        uc_ad(npx+1, j) = 0.0
        temp_ad0 = rsin_u(npx, j)*uc_ad(npx, j)
        utmp_ad(npx-1, j) = utmp_ad(npx-1, j) + t14*temp_ad0
        utmp_ad(npx, j) = utmp_ad(npx, j) + t14*temp_ad0
        utmp_ad(npx-2, j) = utmp_ad(npx-2, j) + t12*temp_ad0
        utmp_ad(npx+1, j) = utmp_ad(npx+1, j) + t12*temp_ad0
        utmp_ad(npx-3, j) = utmp_ad(npx-3, j) + t15*temp_ad0
        utmp_ad(npx+2, j) = utmp_ad(npx+2, j) + t15*temp_ad0
        uc_ad(npx, j) = 0.0
        utmp_ad(npx-3, j) = utmp_ad(npx-3, j) + c1*uc_ad(npx-1, j)
        utmp_ad(npx-2, j) = utmp_ad(npx-2, j) + c2*uc_ad(npx-1, j)
        utmp_ad(npx-1, j) = utmp_ad(npx-1, j) + c3*uc_ad(npx-1, j)
        uc_ad(npx-1, j) = 0.0
      END DO
    ELSE IF (branch .NE. 1) THEN
      GOTO 100
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO j=je+1,js-1,-1
        utmp_ad(3, j) = utmp_ad(3, j) + c1*uc_ad(2, j)
        utmp_ad(2, j) = utmp_ad(2, j) + c2*uc_ad(2, j)
        utmp_ad(1, j) = utmp_ad(1, j) + c3*uc_ad(2, j)
        uc_ad(2, j) = 0.0
        temp_ad = rsin_u(1, j)*uc_ad(1, j)
        utmp_ad(0, j) = utmp_ad(0, j) + t14*temp_ad
        utmp_ad(1, j) = utmp_ad(1, j) + t14*temp_ad
        utmp_ad(-1, j) = utmp_ad(-1, j) + t12*temp_ad
        utmp_ad(2, j) = utmp_ad(2, j) + t12*temp_ad
        utmp_ad(-2, j) = utmp_ad(-2, j) + t15*temp_ad
        utmp_ad(3, j) = utmp_ad(3, j) + t15*temp_ad
        uc_ad(1, j) = 0.0
        utmp_ad(-2, j) = utmp_ad(-2, j) + c1*uc_ad(0, j)
        utmp_ad(-1, j) = utmp_ad(-1, j) + c2*uc_ad(0, j)
        utmp_ad(0, j) = utmp_ad(0, j) + c3*uc_ad(0, j)
        uc_ad(0, j) = 0.0
      END DO
    END IF
 100 DO j=je+1,js-1,-1
      DO i=ilast,ifirst,-1
        utmp_ad(i-1, j) = utmp_ad(i-1, j) + a1*uc_ad(i, j)
        utmp_ad(i, j) = utmp_ad(i, j) + a1*uc_ad(i, j)
        utmp_ad(i-2, j) = utmp_ad(i-2, j) + a2*uc_ad(i, j)
        utmp_ad(i+1, j) = utmp_ad(i+1, j) + a2*uc_ad(i, j)
        uc_ad(i, j) = 0.0
      END DO
      CALL POPINTEGER4(i)
    END DO
    CALL POPCONTROL1B(branch)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO i=0,-2,-1
        vtmp_ad(0, je+i) = vtmp_ad(0, je+i) + utmp_ad(i, npy)
        utmp_ad(i, npy) = 0.0
      END DO
      CALL POPINTEGER4(i)
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO i=2,0,-1
        vtmp_ad(npx, je-i) = vtmp_ad(npx, je-i) - utmp_ad(npx+i, npy)
        utmp_ad(npx+i, npy) = 0.0
      END DO
      CALL POPINTEGER4(i)
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO i=2,0,-1
        vtmp_ad(npx, i+1) = vtmp_ad(npx, i+1) + utmp_ad(npx+i, 0)
        utmp_ad(npx+i, 0) = 0.0
      END DO
      CALL POPINTEGER4(i)
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO i=0,-2,-1
        vtmp_ad(0, 1-i) = vtmp_ad(0, 1-i) - utmp_ad(i, 0)
        utmp_ad(i, 0) = 0.0
      END DO
      CALL POPINTEGER4(i)
    END IF
    CALL POPCONTROL2B(branch)
    IF (branch .LT. 2) THEN
      IF (branch .EQ. 0) THEN
        DO j=jed,jsd,-1
          i = ied
          v_ad(i, j) = v_ad(i, j) + 0.5*vtmp_ad(i, j)
          v_ad(i+1, j) = v_ad(i+1, j) + 0.5*vtmp_ad(i, j)
          vtmp_ad(i, j) = 0.0
          i = isd
          v_ad(i, j) = v_ad(i, j) + 0.5*vtmp_ad(i, j)
          v_ad(i+1, j) = v_ad(i+1, j) + 0.5*vtmp_ad(i, j)
          vtmp_ad(i, j) = 0.0
          DO i=ied-1,isd+1,-1
            v_ad(i-1, j) = v_ad(i-1, j) + a2*vtmp_ad(i, j)
            v_ad(i+2, j) = v_ad(i+2, j) + a2*vtmp_ad(i, j)
            v_ad(i, j) = v_ad(i, j) + a1*vtmp_ad(i, j)
            v_ad(i+1, j) = v_ad(i+1, j) + a1*vtmp_ad(i, j)
            vtmp_ad(i, j) = 0.0
          END DO
          CALL POPINTEGER4(i)
        END DO
        CALL POPINTEGER4(j)
        DO i=ied,isd,-1
          j = jed
          u_ad(i, j) = u_ad(i, j) + 0.5*utmp_ad(i, j)
          u_ad(i, j+1) = u_ad(i, j+1) + 0.5*utmp_ad(i, j)
          utmp_ad(i, j) = 0.0
          j = jsd
          u_ad(i, j) = u_ad(i, j) + 0.5*utmp_ad(i, j)
          u_ad(i, j+1) = u_ad(i, j+1) + 0.5*utmp_ad(i, j)
          utmp_ad(i, j) = 0.0
        END DO
        DO j=jed-1,jsd+1,-1
          DO i=ied,isd,-1
            u_ad(i, j-1) = u_ad(i, j-1) + a2*utmp_ad(i, j)
            u_ad(i, j+2) = u_ad(i, j+2) + a2*utmp_ad(i, j)
            u_ad(i, j) = u_ad(i, j) + a1*utmp_ad(i, j)
            u_ad(i, j+1) = u_ad(i, j+1) + a1*utmp_ad(i, j)
            utmp_ad(i, j) = 0.0
          END DO
        END DO
        GOTO 110
      END IF
    ELSE
      IF (branch .NE. 2) THEN
        DO j=min6,max6,-1
          DO i=ied,npx-npt+1,-1
            v_ad(i, j) = v_ad(i, j) + 0.5*vtmp_ad(i, j)
            v_ad(i+1, j) = v_ad(i+1, j) + 0.5*vtmp_ad(i, j)
            vtmp_ad(i, j) = 0.0
            u_ad(i, j) = u_ad(i, j) + 0.5*utmp_ad(i, j)
            u_ad(i, j+1) = u_ad(i, j+1) + 0.5*utmp_ad(i, j)
            utmp_ad(i, j) = 0.0
          END DO
        END DO
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO j=min5,max5,-1
          DO i=npt-1,isd,-1
            v_ad(i, j) = v_ad(i, j) + 0.5*vtmp_ad(i, j)
            v_ad(i+1, j) = v_ad(i+1, j) + 0.5*vtmp_ad(i, j)
            vtmp_ad(i, j) = 0.0
            u_ad(i, j) = u_ad(i, j) + 0.5*utmp_ad(i, j)
            u_ad(i, j+1) = u_ad(i, j+1) + 0.5*utmp_ad(i, j)
            utmp_ad(i, j) = 0.0
          END DO
        END DO
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO j=jed,npy-npt+1,-1
          DO i=ied,isd,-1
            v_ad(i, j) = v_ad(i, j) + 0.5*vtmp_ad(i, j)
            v_ad(i+1, j) = v_ad(i+1, j) + 0.5*vtmp_ad(i, j)
            vtmp_ad(i, j) = 0.0
            u_ad(i, j) = u_ad(i, j) + 0.5*utmp_ad(i, j)
            u_ad(i, j+1) = u_ad(i, j+1) + 0.5*utmp_ad(i, j)
            utmp_ad(i, j) = 0.0
          END DO
        END DO
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO j=npt-1,jsd,-1
          DO i=ied,isd,-1
            v_ad(i, j) = v_ad(i, j) + 0.5*vtmp_ad(i, j)
            v_ad(i+1, j) = v_ad(i+1, j) + 0.5*vtmp_ad(i, j)
            vtmp_ad(i, j) = 0.0
            u_ad(i, j) = u_ad(i, j) + 0.5*utmp_ad(i, j)
            u_ad(i, j+1) = u_ad(i, j+1) + 0.5*utmp_ad(i, j)
            utmp_ad(i, j) = 0.0
          END DO
        END DO
      END IF
    END IF
    DO j=min3,max3,-1
      CALL POPINTEGER4(ad_from0)
      CALL POPINTEGER4(ad_to0)
      DO i=ad_to0,ad_from0,-1
        v_ad(i-1, j) = v_ad(i-1, j) + a2*vtmp_ad(i, j)
        v_ad(i+2, j) = v_ad(i+2, j) + a2*vtmp_ad(i, j)
        v_ad(i, j) = v_ad(i, j) + a1*vtmp_ad(i, j)
        v_ad(i+1, j) = v_ad(i+1, j) + a1*vtmp_ad(i, j)
        vtmp_ad(i, j) = 0.0
      END DO
    END DO
    DO j=min1,max1,-1
      CALL POPINTEGER4(ad_from)
      CALL POPINTEGER4(ad_to)
      DO i=ad_to,ad_from,-1
        u_ad(i, j-1) = u_ad(i, j-1) + a2*utmp_ad(i, j)
        u_ad(i, j+2) = u_ad(i, j+2) + a2*utmp_ad(i, j)
        u_ad(i, j) = u_ad(i, j) + a1*utmp_ad(i, j)
        u_ad(i, j+1) = u_ad(i, j+1) + a1*utmp_ad(i, j)
        utmp_ad(i, j) = 0.0
      END DO
    END DO
 110 CONTINUE
  END SUBROUTINE D2C_SETUP_BWD
  SUBROUTINE D2C_SETUP(u, v, ua, va, uc, vc, dord4, isd, ied, jsd, jed, &
&   is, ie, js, je, npx, npy, grid_type, nested, se_corner, sw_corner, &
&   ne_corner, nw_corner, rsin_u, rsin_v, cosa_s, rsin2)
    IMPLICIT NONE
    LOGICAL, INTENT(IN) :: dord4
    INTEGER, INTENT(IN) :: isd, ied, jsd, jed, is, ie, js, je, npx, npy&
&   , grid_type
    REAL, INTENT(IN) :: u(isd:ied, jsd:jed+1)
    REAL, INTENT(IN) :: v(isd:ied+1, jsd:jed)
    REAL, DIMENSION(isd:ied, jsd:jed), INTENT(OUT) :: ua
    REAL, DIMENSION(isd:ied, jsd:jed), INTENT(OUT) :: va
    REAL, DIMENSION(isd:ied+1, jsd:jed), INTENT(OUT) :: uc
    REAL, DIMENSION(isd:ied, jsd:jed+1), INTENT(OUT) :: vc
    LOGICAL, INTENT(IN) :: nested, se_corner, sw_corner, ne_corner, &
&   nw_corner
    REAL, INTENT(IN) :: rsin_u(isd:ied+1, jsd:jed)
    REAL, INTENT(IN) :: rsin_v(isd:ied, jsd:jed+1)
    REAL, INTENT(IN) :: cosa_s(isd:ied, jsd:jed)
    REAL, INTENT(IN) :: rsin2(isd:ied, jsd:jed)
! Local 
    REAL, DIMENSION(isd:ied, jsd:jed) :: utmp, vtmp
    REAL, PARAMETER :: t11=27./28., t12=-(13./28.), t13=3./7., t14=6./7.&
&   , t15=3./28.
    REAL, PARAMETER :: a1=0.5625
    REAL, PARAMETER :: a2=-0.0625
    REAL, PARAMETER :: c1=-(2./14.)
    REAL, PARAMETER :: c2=11./14.
    REAL, PARAMETER :: c3=5./14.
    INTEGER :: npt, i, j, ifirst, ilast, id
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: max5
    INTEGER :: max6
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    INTEGER :: min5
    INTEGER :: min6
    IF (dord4) THEN
      id = 1
    ELSE
      id = 0
    END IF
    IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
      npt = 4
    ELSE
      npt = -2
    END IF
    IF (nested) THEN
      DO j=jsd+1,jed-1
        DO i=isd,ied
          utmp(i, j) = a2*(u(i, j-1)+u(i, j+2)) + a1*(u(i, j)+u(i, j+1))
        END DO
      END DO
      DO i=isd,ied
        j = jsd
        utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
        j = jed
        utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
      END DO
      DO j=jsd,jed
        DO i=isd+1,ied-1
          vtmp(i, j) = a2*(v(i-1, j)+v(i+2, j)) + a1*(v(i, j)+v(i+1, j))
        END DO
        i = isd
        vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
        i = ied
        vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
      END DO
      DO j=jsd,jed
        DO i=isd,ied
          ua(i, j) = (utmp(i, j)-vtmp(i, j)*cosa_s(i, j))*rsin2(i, j)
          va(i, j) = (vtmp(i, j)-utmp(i, j)*cosa_s(i, j))*rsin2(i, j)
        END DO
      END DO
    ELSE
!----------
! Interior:
!----------
      utmp = 0.
      vtmp = 0.
      IF (npt .LT. js - 1) THEN
        max1 = js - 1
      ELSE
        max1 = npt
      END IF
      IF (npy - npt .GT. je + 1) THEN
        min1 = je + 1
      ELSE
        min1 = npy - npt
      END IF
      DO j=max1,min1
        IF (npt .LT. isd) THEN
          max2 = isd
        ELSE
          max2 = npt
        END IF
        IF (npx - npt .GT. ied) THEN
          min2 = ied
        ELSE
          min2 = npx - npt
        END IF
        DO i=max2,min2
          utmp(i, j) = a2*(u(i, j-1)+u(i, j+2)) + a1*(u(i, j)+u(i, j+1))
        END DO
      END DO
      IF (npt .LT. jsd) THEN
        max3 = jsd
      ELSE
        max3 = npt
      END IF
      IF (npy - npt .GT. jed) THEN
        min3 = jed
      ELSE
        min3 = npy - npt
      END IF
      DO j=max3,min3
        IF (npt .LT. is - 1) THEN
          max4 = is - 1
        ELSE
          max4 = npt
        END IF
        IF (npx - npt .GT. ie + 1) THEN
          min4 = ie + 1
        ELSE
          min4 = npx - npt
        END IF
        DO i=max4,min4
          vtmp(i, j) = a2*(v(i-1, j)+v(i+2, j)) + a1*(v(i, j)+v(i+1, j))
        END DO
      END DO
!----------
! edges:
!----------
      IF (grid_type .LT. 3) THEN
        IF (js .EQ. 1 .OR. jsd .LT. npt) THEN
          DO j=jsd,npt-1
            DO i=isd,ied
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
        END IF
        IF (je + 1 .EQ. npy .OR. jed .GE. npy - npt) THEN
          DO j=npy-npt+1,jed
            DO i=isd,ied
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
        END IF
        IF (is .EQ. 1 .OR. isd .LT. npt) THEN
          IF (npt .LT. jsd) THEN
            max5 = jsd
          ELSE
            max5 = npt
          END IF
          IF (npy - npt .GT. jed) THEN
            min5 = jed
          ELSE
            min5 = npy - npt
          END IF
          DO j=max5,min5
            DO i=isd,npt-1
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
        END IF
        IF (ie + 1 .EQ. npx .OR. ied .GE. npx - npt) THEN
          IF (npt .LT. jsd) THEN
            max6 = jsd
          ELSE
            max6 = npt
          END IF
          IF (npy - npt .GT. jed) THEN
            min6 = jed
          ELSE
            min6 = npy - npt
          END IF
          DO j=max6,min6
            DO i=npx-npt+1,ied
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
        END IF
      END IF
      DO j=js-1-id,je+1+id
        DO i=is-1-id,ie+1+id
          ua(i, j) = (utmp(i, j)-vtmp(i, j)*cosa_s(i, j))*rsin2(i, j)
          va(i, j) = (vtmp(i, j)-utmp(i, j)*cosa_s(i, j))*rsin2(i, j)
        END DO
      END DO
    END IF
! A -> C
!--------------
! Fix the edges
!--------------
! Xdir:
    IF (sw_corner) THEN
      DO i=-2,0
        utmp(i, 0) = -vtmp(0, 1-i)
      END DO
    END IF
    IF (se_corner) THEN
      DO i=0,2
        utmp(npx+i, 0) = vtmp(npx, i+1)
      END DO
    END IF
    IF (ne_corner) THEN
      DO i=0,2
        utmp(npx+i, npy) = -vtmp(npx, je-i)
      END DO
    END IF
    IF (nw_corner) THEN
      DO i=-2,0
        utmp(i, npy) = vtmp(0, je+i)
      END DO
    END IF
    IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
      IF (3 .LT. is - 1) THEN
        ifirst = is - 1
      ELSE
        ifirst = 3
      END IF
      IF (npx - 2 .GT. ie + 2) THEN
        ilast = ie + 2
      ELSE
        ilast = npx - 2
      END IF
    ELSE
      ifirst = is - 1
      ilast = ie + 2
    END IF
!---------------------------------------------
! 4th order interpolation for interior points:
!---------------------------------------------
    DO j=js-1,je+1
      DO i=ifirst,ilast
        uc(i, j) = a1*(utmp(i-1, j)+utmp(i, j)) + a2*(utmp(i-2, j)+utmp(&
&         i+1, j))
      END DO
    END DO
    IF (grid_type .LT. 3) THEN
! Xdir:
      IF (is .EQ. 1 .AND. (.NOT.nested)) THEN
        DO j=js-1,je+1
          uc(0, j) = c1*utmp(-2, j) + c2*utmp(-1, j) + c3*utmp(0, j)
          uc(1, j) = (t14*(utmp(0, j)+utmp(1, j))+t12*(utmp(-1, j)+utmp(&
&           2, j))+t15*(utmp(-2, j)+utmp(3, j)))*rsin_u(1, j)
          uc(2, j) = c1*utmp(3, j) + c2*utmp(2, j) + c3*utmp(1, j)
        END DO
      END IF
      IF (ie + 1 .EQ. npx .AND. (.NOT.nested)) THEN
        DO j=js-1,je+1
          uc(npx-1, j) = c1*utmp(npx-3, j) + c2*utmp(npx-2, j) + c3*utmp&
&           (npx-1, j)
          uc(npx, j) = (t14*(utmp(npx-1, j)+utmp(npx, j))+t12*(utmp(npx-&
&           2, j)+utmp(npx+1, j))+t15*(utmp(npx-3, j)+utmp(npx+2, j)))*&
&           rsin_u(npx, j)
          uc(npx+1, j) = c3*utmp(npx, j) + c2*utmp(npx+1, j) + c1*utmp(&
&           npx+2, j)
        END DO
      END IF
    END IF
!------
! Ydir:
!------
    IF (sw_corner) THEN
      DO j=-2,0
        vtmp(0, j) = -utmp(1-j, 0)
      END DO
    END IF
    IF (nw_corner) THEN
      DO j=0,2
        vtmp(0, npy+j) = utmp(j+1, npy)
      END DO
    END IF
    IF (se_corner) THEN
      DO j=-2,0
        vtmp(npx, j) = utmp(ie+j, 0)
      END DO
    END IF
    IF (ne_corner) THEN
      DO j=0,2
        vtmp(npx, npy+j) = -utmp(ie-j, npy)
      END DO
    END IF
    IF (grid_type .LT. 3) THEN
      DO j=js-1,je+2
        IF (j .EQ. 1 .AND. (.NOT.nested)) THEN
          DO i=is-1,ie+1
            vc(i, 1) = (t14*(vtmp(i, 0)+vtmp(i, 1))+t12*(vtmp(i, -1)+&
&             vtmp(i, 2))+t15*(vtmp(i, -2)+vtmp(i, 3)))*rsin_v(i, 1)
          END DO
        ELSE IF ((j .EQ. 0 .OR. j .EQ. npy - 1) .AND. (.NOT.nested)) &
&       THEN
          DO i=is-1,ie+1
            vc(i, j) = c1*vtmp(i, j-2) + c2*vtmp(i, j-1) + c3*vtmp(i, j)
          END DO
        ELSE IF ((j .EQ. 2 .OR. j .EQ. npy + 1) .AND. (.NOT.nested)) &
&       THEN
          DO i=is-1,ie+1
            vc(i, j) = c1*vtmp(i, j+1) + c2*vtmp(i, j) + c3*vtmp(i, j-1)
          END DO
        ELSE IF (j .EQ. npy .AND. (.NOT.nested)) THEN
          DO i=is-1,ie+1
            vc(i, npy) = (t14*(vtmp(i, npy-1)+vtmp(i, npy))+t12*(vtmp(i&
&             , npy-2)+vtmp(i, npy+1))+t15*(vtmp(i, npy-3)+vtmp(i, npy+2&
&             )))*rsin_v(i, npy)
          END DO
        ELSE
! 4th order interpolation for interior points:
          DO i=is-1,ie+1
            vc(i, j) = a2*(vtmp(i, j-2)+vtmp(i, j+1)) + a1*(vtmp(i, j-1)&
&             +vtmp(i, j))
          END DO
        END IF
      END DO
    ELSE
! 4th order interpolation:
      DO j=js-1,je+2
        DO i=is-1,ie+1
          vc(i, j) = a2*(vtmp(i, j-2)+vtmp(i, j+1)) + a1*(vtmp(i, j-1)+&
&           vtmp(i, j))
        END DO
      END DO
    END IF
  END SUBROUTINE D2C_SETUP
  SUBROUTINE D2A_SETUP(u, v, ua, va, dord4, isd, ied, jsd, jed, is, ie, &
&   js, je, npx, npy, grid_type, nested, cosa_s, rsin2)
    IMPLICIT NONE
    LOGICAL, INTENT(IN) :: dord4
    INTEGER, INTENT(IN) :: isd, ied, jsd, jed, is, ie, js, je, npx, npy&
&   , grid_type
    REAL, INTENT(IN) :: u(isd:ied, jsd:jed+1)
    REAL, INTENT(IN) :: v(isd:ied+1, jsd:jed)
    REAL, DIMENSION(isd:ied, jsd:jed), INTENT(OUT) :: ua
    REAL, DIMENSION(isd:ied, jsd:jed), INTENT(OUT) :: va
    REAL, INTENT(IN) :: cosa_s(isd:ied, jsd:jed)
    REAL, INTENT(IN) :: rsin2(isd:ied, jsd:jed)
    LOGICAL, INTENT(IN) :: nested
! Local 
    REAL, DIMENSION(isd:ied, jsd:jed) :: utmp, vtmp
    REAL, PARAMETER :: t11=27./28., t12=-(13./28.), t13=3./7., t14=6./7.&
&   , t15=3./28.
    REAL, PARAMETER :: a1=0.5625
    REAL, PARAMETER :: a2=-0.0625
    REAL, PARAMETER :: c1=-(2./14.)
    REAL, PARAMETER :: c2=11./14.
    REAL, PARAMETER :: c3=5./14.
    INTEGER :: npt, i, j, ifirst, ilast, id
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: max5
    INTEGER :: max6
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    INTEGER :: min5
    INTEGER :: min6
    IF (dord4) THEN
      id = 1
    ELSE
      id = 0
    END IF
    IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
      npt = 4
    ELSE
      npt = -2
    END IF
    IF (nested) THEN
      DO j=jsd+1,jed-1
        DO i=isd,ied
          utmp(i, j) = a2*(u(i, j-1)+u(i, j+2)) + a1*(u(i, j)+u(i, j+1))
        END DO
      END DO
      DO i=isd,ied
        j = jsd
        utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
        j = jed
        utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
      END DO
      DO j=jsd,jed
        DO i=isd+1,ied-1
          vtmp(i, j) = a2*(v(i-1, j)+v(i+2, j)) + a1*(v(i, j)+v(i+1, j))
        END DO
        i = isd
        vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
        i = ied
        vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
      END DO
    ELSE
      IF (npt .LT. js - 1) THEN
        max1 = js - 1
      ELSE
        max1 = npt
      END IF
      IF (npy - npt .GT. je + 1) THEN
        min1 = je + 1
      ELSE
        min1 = npy - npt
      END IF
!----------
! Interior:
!----------
      DO j=max1,min1
        IF (npt .LT. isd) THEN
          max2 = isd
        ELSE
          max2 = npt
        END IF
        IF (npx - npt .GT. ied) THEN
          min2 = ied
        ELSE
          min2 = npx - npt
        END IF
        DO i=max2,min2
          utmp(i, j) = a2*(u(i, j-1)+u(i, j+2)) + a1*(u(i, j)+u(i, j+1))
        END DO
      END DO
      IF (npt .LT. jsd) THEN
        max3 = jsd
      ELSE
        max3 = npt
      END IF
      IF (npy - npt .GT. jed) THEN
        min3 = jed
      ELSE
        min3 = npy - npt
      END IF
      DO j=max3,min3
        IF (npt .LT. is - 1) THEN
          max4 = is - 1
        ELSE
          max4 = npt
        END IF
        IF (npx - npt .GT. ie + 1) THEN
          min4 = ie + 1
        ELSE
          min4 = npx - npt
        END IF
        DO i=max4,min4
          vtmp(i, j) = a2*(v(i-1, j)+v(i+2, j)) + a1*(v(i, j)+v(i+1, j))
        END DO
      END DO
!----------
! edges:
!----------
      IF (grid_type .LT. 3) THEN
        IF (js .EQ. 1 .OR. jsd .LT. npt) THEN
          DO j=jsd,npt-1
            DO i=isd,ied
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
        END IF
        IF (je + 1 .EQ. npy .OR. jed .GE. npy - npt) THEN
          DO j=npy-npt+1,jed
            DO i=isd,ied
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
        END IF
        IF (is .EQ. 1 .OR. isd .LT. npt) THEN
          IF (npt .LT. jsd) THEN
            max5 = jsd
          ELSE
            max5 = npt
          END IF
          IF (npy - npt .GT. jed) THEN
            min5 = jed
          ELSE
            min5 = npy - npt
          END IF
          DO j=max5,min5
            DO i=isd,npt-1
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
        END IF
        IF (ie + 1 .EQ. npx .OR. ied .GE. npx - npt) THEN
          IF (npt .LT. jsd) THEN
            max6 = jsd
          ELSE
            max6 = npt
          END IF
          IF (npy - npt .GT. jed) THEN
            min6 = jed
          ELSE
            min6 = npy - npt
          END IF
          DO j=max6,min6
            DO i=npx-npt+1,ied
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
        END IF
      END IF
    END IF
    DO j=js-1-id,je+1+id
      DO i=is-1-id,ie+1+id
        ua(i, j) = (utmp(i, j)-vtmp(i, j)*cosa_s(i, j))*rsin2(i, j)
        va(i, j) = (vtmp(i, j)-utmp(i, j)*cosa_s(i, j))*rsin2(i, j)
      END DO
    END DO
  END SUBROUTINE D2A_SETUP
END MODULE FV_RESTART_MOD_B
