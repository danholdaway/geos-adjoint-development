!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
MODULE FV_MP_MOD_B
  USE MPP_DOMAINS_MOD_B, ONLY : group_halo_update_type => &
& mpp_group_update_type
  USE MPP_DOMAINS_MOD_B, ONLY : domain2d
  IMPLICIT NONE
!      subroutine complete_var_group_update_3d(group, group_tl, domain)
!        type(group_halo_update_type), intent(inout) :: group, group_tl
!        !real, dimension(:,:,:),       intent(inout) :: array
!        type(domain2D),               intent(inout) :: domain
!      
!      ! Arguments: 
!      !  (inout)   group - The data type that store information for group update. 
!      !                    This data will be used in do_group_pass.
!      !  (inout)   array - The array which is having its halos points exchanged.
!      !  (in)      domain - contains domain information.
!      
!        !array = 2*array
!      
!      end subroutine complete_var_group_update_3d
!      
!      subroutine complete_var_group_update_4d(group, group_tl, domain)
!        type(group_halo_update_type), intent(inout) :: group, group_tl
!        !real, dimension(:,:,:,:),     intent(inout) :: array
!        type(domain2D),               intent(inout) :: domain
!      
!      ! Arguments: 
!      !  (inout)   group - The data type that store information for group update. 
!      !                    This data will be used in do_group_pass.
!      !  (inout)   array - The array which is having its halos points exchanged.
!      !  (in)      domain - contains domain information.
!      
!        integer :: dirflag
!      
!        !array = 2*array
!      
!      end subroutine complete_var_group_update_4d
!      
!      
!      
!      subroutine complete_vector_group_update_2d(group, group_tl, domain)
!        type(group_halo_update_type), intent(inout) :: group, group_tl
!        !real,       dimension(:,:),   intent(inout) :: u_cmpt, v_cmpt
!        type(domain2d),               intent(inout) :: domain
!      
!      ! Arguments: 
!      !  (inout)   group - The data type that store information for group update. 
!      !                    This data will be used in do_group_pass.
!      !  (inout)   u_cmpt - The nominal zonal (u) component of the vector pair which
!      !                     is having its halos points exchanged.
!      !  (inout)   v_cmpt - The nominal meridional (v) component of the vector pair
!      !                     which is having its halos points exchanged. 
!      !  (in)      domain - Contains domain decomposition information.
!      
!        !u_cmpt = 2*u_cmpt
!        !v_cmpt = 2*v_cmpt
!      
!      end subroutine complete_vector_group_update_2d
!      
!      subroutine complete_vector_group_update_3d(group, group_tl, domain)
!        type(group_halo_update_type), intent(inout) :: group, group_tl
!        !real,       dimension(:,:,:), intent(inout) :: u_cmpt, v_cmpt
!        type(domain2d),               intent(inout) :: domain
!
!      
!      ! Arguments: 
!      !  (inout)   group - The data type that store information for group update. 
!      !                    This data will be used in do_group_pass.
!      !  (inout)   u_cmpt - The nominal zonal (u) component of the vector pair which
!      !                     is having its halos points exchanged.
!      !  (inout)   v_cmpt - The nominal meridional (v) component of the vector pair
!      !                     which is having its halos points exchanged. 
!      !  (in)      domain - Contains domain decomposition information.
!      
!        !u_cmpt = 2*u_cmpt
!        !v_cmpt = 2*v_cmpt
!      
!      end subroutine complete_vector_group_update_3d
  PUBLIC 
!dummy
  LOGICAL :: mp_gather
  INTEGER :: is, ie, js, je, isd, ied, jsd, jed, isc, iec, jsc, jec
  INTEGER :: mpp_broadcast
!dummy
  INTEGER :: mp_bcst
  INTEGER, PARAMETER :: xdir=1
  INTEGER, PARAMETER :: ydir=2
  INTEGER, PARAMETER :: ng=3
  INTERFACE START_GROUP_HALO_UPDATE
      MODULE PROCEDURE START_VAR_GROUP_UPDATE_2D
      MODULE PROCEDURE START_VAR_GROUP_UPDATE_3D
      MODULE PROCEDURE START_VAR_GROUP_UPDATE_4D
      MODULE PROCEDURE START_VECTOR_GROUP_UPDATE_2D
      MODULE PROCEDURE START_VECTOR_GROUP_UPDATE_3D
  END INTERFACE START_GROUP_HALO_UPDATE

  INTERFACE START_GROUP_HALO_UPDATE_ADM
      MODULE PROCEDURE START_VAR_GROUP_UPDATE_3D_ADM
      MODULE PROCEDURE START_VAR_GROUP_UPDATE_4D_ADM
      MODULE PROCEDURE START_VECTOR_GROUP_UPDATE_3D_ADM
  END INTERFACE

  INTERFACE MP_REDUCE_MAX
      MODULE PROCEDURE MP_REDUCE_MAX_R4_1D
      MODULE PROCEDURE MP_REDUCE_MAX_R4
      MODULE PROCEDURE MP_REDUCE_MAX_R8_1D
      MODULE PROCEDURE MP_REDUCE_MAX_R8
      MODULE PROCEDURE MP_REDUCE_MAX_I4
  END INTERFACE

  INTERFACE MP_REDUCE_SUM
      MODULE PROCEDURE MP_REDUCE_SUM_R4
      MODULE PROCEDURE MP_REDUCE_SUM_R4_1D
      MODULE PROCEDURE MP_REDUCE_SUM_R8
      MODULE PROCEDURE MP_REDUCE_SUM_R8_1D
  END INTERFACE

  INTERFACE MP_REDUCE_SUM_ADM
      MODULE PROCEDURE MP_REDUCE_SUM_R8_ADM
  END INTERFACE

  INTERFACE FILL_CORNERS
      MODULE PROCEDURE FILL_CORNERS_2D_R4
      MODULE PROCEDURE FILL_CORNERS_2D_R8
      MODULE PROCEDURE FILL_CORNERS_XY_2D_R4
      MODULE PROCEDURE FILL_CORNERS_XY_2D_R8
      MODULE PROCEDURE FILL_CORNERS_XY_3D_R4
      MODULE PROCEDURE FILL_CORNERS_XY_3D_R8
  END INTERFACE

  INTERFACE FILL_CORNERS_ADM
      MODULE PROCEDURE FILL_CORNERS_2D_R8_ADM
      MODULE PROCEDURE FILL_CORNERS_XY_2D_R8_ADM
  END INTERFACE

  INTERFACE FILL_CORNERS_AGRID
      MODULE PROCEDURE FILL_CORNERS_AGRID_R4
      MODULE PROCEDURE FILL_CORNERS_AGRID_R8
  END INTERFACE

  INTERFACE FILL_CORNERS_AGRID_ADM
      MODULE PROCEDURE FILL_CORNERS_AGRID_R8_ADM
  END INTERFACE

  INTERFACE FILL_CORNERS_CGRID
      MODULE PROCEDURE FILL_CORNERS_CGRID_R4
      MODULE PROCEDURE FILL_CORNERS_CGRID_R8
  END INTERFACE

  INTERFACE FILL_CORNERS_CGRID_ADM
      MODULE PROCEDURE FILL_CORNERS_CGRID_R8_ADM
  END INTERFACE

  INTERFACE FILL_CORNERS_DGRID
      MODULE PROCEDURE FILL_CORNERS_DGRID_R4
      MODULE PROCEDURE FILL_CORNERS_DGRID_R8
  END INTERFACE

  INTERFACE FILL_CORNERS_DGRID_ADM
      MODULE PROCEDURE FILL_CORNERS_DGRID_R8_ADM
  END INTERFACE


CONTAINS
  LOGICAL FUNCTION IS_MASTER()
    IMPLICIT NONE
    IF (1 .EQ. 1) is_master = .true.
  END FUNCTION IS_MASTER
! FILL CORNERS
! ------------
  SUBROUTINE FILL_CORNERS_2D_R4(q, npx, npy, fill, agrid, bgrid)
    IMPLICIT NONE
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: q
    INTEGER, INTENT(IN) :: npx, npy
! X-Dir or Y-Dir 
    INTEGER, INTENT(IN) :: fill
    LOGICAL, OPTIONAL, INTENT(IN) :: agrid, bgrid
    INTEGER :: i, j
    INTRINSIC PRESENT
    IF (PRESENT(bgrid)) THEN
      IF (bgrid) THEN
        SELECT CASE  (fill) 
        CASE (xdir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-i, 1-j) = q(1-j, i+1)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-i, npy+j) = q(1-j&
&                 , npy-i)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx+i, 1-j) = q(npx&
&                 +j, i+1)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx+i, npy+j)&
&                = q(npx+j, npy-i)
            END DO
          END DO
        CASE (ydir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-j, 1-i) = q(i+1, 1-j)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-j, npy+i) = q(i+1&
&                 , npy+j)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx+j, 1-i) = q(npx&
&                 -i, 1-j)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx+j, npy+i)&
&                = q(npx-i, npy+j)
            END DO
          END DO
        CASE DEFAULT
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-i, 1-j) = q(1-j, i+1)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-i, npy+j) = q(1-j&
&                 , npy-i)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx+i, 1-j) = q(npx&
&                 +j, i+1)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx+i, npy+j)&
&                = q(npx+j, npy-i)
            END DO
          END DO
        END SELECT
      END IF
    ELSE IF (PRESENT(agrid)) THEN
      IF (agrid) THEN
        SELECT CASE  (fill) 
        CASE (xdir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-i, 1-j) = q(1-j, i)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-i, npy-1+j) = q(1&
&                 -j, npy-1-i+1)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx-1+i, 1-j) = q(&
&                 npx-1+j, i)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx-1+i, npy-&
&               1+j) = q(npx-1+j, npy-1-i+1)
            END DO
          END DO
        CASE (ydir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-j, 1-i) = q(i, 1-j)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-j, npy-1+i) = q(i&
&                 , npy-1+j)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx-1+j, 1-i) = q(&
&                 npx-1-i+1, 1-j)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx-1+j, npy-&
&               1+i) = q(npx-1-i+1, npy-1+j)
            END DO
          END DO
        CASE DEFAULT
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-j, 1-i) = q(i, 1-j)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-j, npy-1+i) = q(i&
&                 , npy-1+j)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx-1+j, 1-i) = q(&
&                 npx-1-i+1, 1-j)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx-1+j, npy-&
&               1+i) = q(npx-1-i+1, npy-1+j)
            END DO
          END DO
        END SELECT
      END IF
    END IF
  END SUBROUTINE FILL_CORNERS_2D_R4
!  Differentiation of fill_corners_2d_r8 in reverse (adjoint) mode (with options split(a2b_edge_mod.a2b_ord4 a2b_edge_mod.a2b_
!ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_g
!rad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mod.mix_dp d
!yn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayleigh_Super 
!fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_geos fv_grid_ut
!ils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_mapz_mod.com
!pute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer
!_fb fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_limiters 
!fv_mapz_mod.ppm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.moist_cv
! fv_mapz_mod.moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer_2d fv_
!tracer2d_mod.tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.Riem_Solve
!r_c nh_utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SIM3p0_solve
!r nh_utils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nest_halo_nh 
!sw_core_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_vect sw_co
!re_mod.fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v sw_core_mod
!.compute_divergence_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_core_mod.fv_tp_
!2d_fb tp_core_mod.copy_corners tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_corner
! fv_grid_utils_mod.great_circle_dist sw_core_mod.edge_interpolate4)):
!   gradient     of useful results: q
!   with respect to varying inputs: q
  SUBROUTINE FILL_CORNERS_2D_R8_ADM(q, q_ad, npx, npy, fill, agrid, &
&   bgrid)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: q
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: q_ad
    INTEGER, INTENT(IN) :: npx, npy
! X-Dir or Y-Dir 
    INTEGER, INTENT(IN) :: fill
    LOGICAL, OPTIONAL, INTENT(IN) :: agrid, bgrid
    INTEGER :: i, j
    INTRINSIC PRESENT
    REAL(kind=8) :: tmp
    REAL(kind=8) :: tmp_ad
    REAL(kind=8) :: tmp0
    REAL(kind=8) :: tmp_ad0
    REAL(kind=8) :: tmp1
    REAL(kind=8) :: tmp_ad1
    REAL(kind=8) :: tmp2
    REAL(kind=8) :: tmp_ad2
    REAL(kind=8) :: tmp3
    REAL(kind=8) :: tmp_ad3
    REAL(kind=8) :: tmp4
    REAL(kind=8) :: tmp_ad4
    REAL(kind=8) :: tmp5
    REAL(kind=8) :: tmp_ad5
    REAL(kind=8) :: tmp6
    REAL(kind=8) :: tmp_ad6
    REAL(kind=8) :: tmp7
    REAL(kind=8) :: tmp_ad7
    REAL(kind=8) :: tmp8
    REAL(kind=8) :: tmp_ad8
    REAL(kind=8) :: tmp9
    REAL(kind=8) :: tmp_ad9
    REAL(kind=8) :: tmp10
    REAL(kind=8) :: tmp_ad10
    REAL(kind=8) :: tmp11
    REAL(kind=8) :: tmp_ad11
    REAL(kind=8) :: tmp12
    REAL(kind=8) :: tmp_ad12
    REAL(kind=8) :: tmp13
    REAL(kind=8) :: tmp_ad13
    REAL(kind=8) :: tmp14
    REAL(kind=8) :: tmp_ad14
    REAL(kind=8) :: tmp15
    REAL(kind=8) :: tmp_ad15
    REAL(kind=8) :: tmp16
    REAL(kind=8) :: tmp_ad16
    REAL(kind=8) :: tmp17
    REAL(kind=8) :: tmp_ad17
    REAL(kind=8) :: tmp18
    REAL(kind=8) :: tmp_ad18
    REAL(kind=8) :: tmp19
    REAL(kind=8) :: tmp_ad19
    REAL(kind=8) :: tmp20
    REAL(kind=8) :: tmp_ad20
    REAL(kind=8) :: tmp21
    REAL(kind=8) :: tmp_ad21
    REAL(kind=8) :: tmp22
    REAL(kind=8) :: tmp_ad22
    INTEGER :: branch
    IF (PRESENT(bgrid)) THEN
      IF (bgrid) THEN
        SELECT CASE  (fill) 
        CASE (xdir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) THEN
                CALL PUSHCONTROL1B(1)
              ELSE
                CALL PUSHCONTROL1B(0)
              END IF
            END DO
          END DO
          DO j=ng,1,-1
            DO i=ng,1,-1
              CALL POPCONTROL1B(branch)
              IF (branch .NE. 0) THEN
                tmp_ad2 = q_ad(npx+i, npy+j)
                q_ad(npx+i, npy+j) = 0.0_8
                q_ad(npx+j, npy-i) = q_ad(npx+j, npy-i) + tmp_ad2
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                tmp_ad1 = q_ad(npx+i, 1-j)
                q_ad(npx+i, 1-j) = 0.0_8
                q_ad(npx+j, i+1) = q_ad(npx+j, i+1) + tmp_ad1
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                tmp_ad0 = q_ad(1-i, npy+j)
                q_ad(1-i, npy+j) = 0.0_8
                q_ad(1-j, npy-i) = q_ad(1-j, npy-i) + tmp_ad0
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                tmp_ad = q_ad(1-i, 1-j)
                q_ad(1-i, 1-j) = 0.0_8
                q_ad(1-j, i+1) = q_ad(1-j, i+1) + tmp_ad
              END IF
            END DO
          END DO
        CASE (ydir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) THEN
                CALL PUSHCONTROL1B(1)
              ELSE
                CALL PUSHCONTROL1B(0)
              END IF
            END DO
          END DO
          DO j=ng,1,-1
            DO i=ng,1,-1
              CALL POPCONTROL1B(branch)
              IF (branch .NE. 0) THEN
                tmp_ad6 = q_ad(npx+j, npy+i)
                q_ad(npx+j, npy+i) = 0.0_8
                q_ad(npx-i, npy+j) = q_ad(npx-i, npy+j) + tmp_ad6
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                tmp_ad5 = q_ad(npx+j, 1-i)
                q_ad(npx+j, 1-i) = 0.0_8
                q_ad(npx-i, 1-j) = q_ad(npx-i, 1-j) + tmp_ad5
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                tmp_ad4 = q_ad(1-j, npy+i)
                q_ad(1-j, npy+i) = 0.0_8
                q_ad(i+1, npy+j) = q_ad(i+1, npy+j) + tmp_ad4
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                tmp_ad3 = q_ad(1-j, 1-i)
                q_ad(1-j, 1-i) = 0.0_8
                q_ad(i+1, 1-j) = q_ad(i+1, 1-j) + tmp_ad3
              END IF
            END DO
          END DO
        CASE DEFAULT
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) THEN
                CALL PUSHCONTROL1B(1)
              ELSE
                CALL PUSHCONTROL1B(0)
              END IF
            END DO
          END DO
          DO j=ng,1,-1
            DO i=ng,1,-1
              CALL POPCONTROL1B(branch)
              IF (branch .NE. 0) THEN
                tmp_ad10 = q_ad(npx+i, npy+j)
                q_ad(npx+i, npy+j) = 0.0_8
                q_ad(npx+j, npy-i) = q_ad(npx+j, npy-i) + tmp_ad10
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                tmp_ad9 = q_ad(npx+i, 1-j)
                q_ad(npx+i, 1-j) = 0.0_8
                q_ad(npx+j, i+1) = q_ad(npx+j, i+1) + tmp_ad9
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                tmp_ad8 = q_ad(1-i, npy+j)
                q_ad(1-i, npy+j) = 0.0_8
                q_ad(1-j, npy-i) = q_ad(1-j, npy-i) + tmp_ad8
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                tmp_ad7 = q_ad(1-i, 1-j)
                q_ad(1-i, 1-j) = 0.0_8
                q_ad(1-j, i+1) = q_ad(1-j, i+1) + tmp_ad7
              END IF
            END DO
          END DO
        END SELECT
      END IF
    ELSE IF (PRESENT(agrid)) THEN
      IF (agrid) THEN
        SELECT CASE  (fill) 
        CASE (xdir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) THEN
                CALL PUSHCONTROL1B(1)
              ELSE
                CALL PUSHCONTROL1B(0)
              END IF
            END DO
          END DO
          DO j=ng,1,-1
            DO i=ng,1,-1
              CALL POPCONTROL1B(branch)
              IF (branch .NE. 0) THEN
                tmp_ad14 = q_ad(npx-1+i, npy-1+j)
                q_ad(npx-1+i, npy-1+j) = 0.0_8
                q_ad(npx-1+j, npy-1-i+1) = q_ad(npx-1+j, npy-1-i+1) + &
&                 tmp_ad14
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                tmp_ad13 = q_ad(npx-1+i, 1-j)
                q_ad(npx-1+i, 1-j) = 0.0_8
                q_ad(npx-1+j, i) = q_ad(npx-1+j, i) + tmp_ad13
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                tmp_ad12 = q_ad(1-i, npy-1+j)
                q_ad(1-i, npy-1+j) = 0.0_8
                q_ad(1-j, npy-1-i+1) = q_ad(1-j, npy-1-i+1) + tmp_ad12
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                tmp_ad11 = q_ad(1-i, 1-j)
                q_ad(1-i, 1-j) = 0.0_8
                q_ad(1-j, i) = q_ad(1-j, i) + tmp_ad11
              END IF
            END DO
          END DO
        CASE (ydir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) THEN
                CALL PUSHCONTROL1B(1)
              ELSE
                CALL PUSHCONTROL1B(0)
              END IF
            END DO
          END DO
          DO j=ng,1,-1
            DO i=ng,1,-1
              CALL POPCONTROL1B(branch)
              IF (branch .NE. 0) THEN
                tmp_ad18 = q_ad(npx-1+j, npy-1+i)
                q_ad(npx-1+j, npy-1+i) = 0.0_8
                q_ad(npx-1-i+1, npy-1+j) = q_ad(npx-1-i+1, npy-1+j) + &
&                 tmp_ad18
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                tmp_ad17 = q_ad(npx-1+j, 1-i)
                q_ad(npx-1+j, 1-i) = 0.0_8
                q_ad(npx-1-i+1, 1-j) = q_ad(npx-1-i+1, 1-j) + tmp_ad17
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                tmp_ad16 = q_ad(1-j, npy-1+i)
                q_ad(1-j, npy-1+i) = 0.0_8
                q_ad(i, npy-1+j) = q_ad(i, npy-1+j) + tmp_ad16
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                tmp_ad15 = q_ad(1-j, 1-i)
                q_ad(1-j, 1-i) = 0.0_8
                q_ad(i, 1-j) = q_ad(i, 1-j) + tmp_ad15
              END IF
            END DO
          END DO
        CASE DEFAULT
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) THEN
                CALL PUSHCONTROL1B(1)
              ELSE
                CALL PUSHCONTROL1B(0)
              END IF
            END DO
          END DO
          DO j=ng,1,-1
            DO i=ng,1,-1
              CALL POPCONTROL1B(branch)
              IF (branch .NE. 0) THEN
                tmp_ad22 = q_ad(npx-1+j, npy-1+i)
                q_ad(npx-1+j, npy-1+i) = 0.0_8
                q_ad(npx-1-i+1, npy-1+j) = q_ad(npx-1-i+1, npy-1+j) + &
&                 tmp_ad22
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                tmp_ad21 = q_ad(npx-1+j, 1-i)
                q_ad(npx-1+j, 1-i) = 0.0_8
                q_ad(npx-1-i+1, 1-j) = q_ad(npx-1-i+1, 1-j) + tmp_ad21
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                tmp_ad20 = q_ad(1-j, npy-1+i)
                q_ad(1-j, npy-1+i) = 0.0_8
                q_ad(i, npy-1+j) = q_ad(i, npy-1+j) + tmp_ad20
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                tmp_ad19 = q_ad(1-j, 1-i)
                q_ad(1-j, 1-i) = 0.0_8
                q_ad(i, 1-j) = q_ad(i, 1-j) + tmp_ad19
              END IF
            END DO
          END DO
        END SELECT
      END IF
    END IF
  END SUBROUTINE FILL_CORNERS_2D_R8_ADM
  SUBROUTINE FILL_CORNERS_2D_R8(q, npx, npy, fill, agrid, bgrid)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: q
    INTEGER, INTENT(IN) :: npx, npy
! X-Dir or Y-Dir 
    INTEGER, INTENT(IN) :: fill
    LOGICAL, OPTIONAL, INTENT(IN) :: agrid, bgrid
    INTEGER :: i, j
    INTRINSIC PRESENT
    IF (PRESENT(bgrid)) THEN
      IF (bgrid) THEN
        SELECT CASE  (fill) 
        CASE (xdir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-i, 1-j) = q(1-j, i+1)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-i, npy+j) = q(1-j&
&                 , npy-i)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx+i, 1-j) = q(npx&
&                 +j, i+1)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx+i, npy+j)&
&                = q(npx+j, npy-i)
            END DO
          END DO
        CASE (ydir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-j, 1-i) = q(i+1, 1-j)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-j, npy+i) = q(i+1&
&                 , npy+j)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx+j, 1-i) = q(npx&
&                 -i, 1-j)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx+j, npy+i)&
&                = q(npx-i, npy+j)
            END DO
          END DO
        CASE DEFAULT
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-i, 1-j) = q(1-j, i+1)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-i, npy+j) = q(1-j&
&                 , npy-i)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx+i, 1-j) = q(npx&
&                 +j, i+1)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx+i, npy+j)&
&                = q(npx+j, npy-i)
            END DO
          END DO
        END SELECT
      END IF
    ELSE IF (PRESENT(agrid)) THEN
      IF (agrid) THEN
        SELECT CASE  (fill) 
        CASE (xdir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-i, 1-j) = q(1-j, i)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-i, npy-1+j) = q(1&
&                 -j, npy-1-i+1)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx-1+i, 1-j) = q(&
&                 npx-1+j, i)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx-1+i, npy-&
&               1+j) = q(npx-1+j, npy-1-i+1)
            END DO
          END DO
        CASE (ydir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-j, 1-i) = q(i, 1-j)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-j, npy-1+i) = q(i&
&                 , npy-1+j)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx-1+j, 1-i) = q(&
&                 npx-1-i+1, 1-j)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx-1+j, npy-&
&               1+i) = q(npx-1-i+1, npy-1+j)
            END DO
          END DO
        CASE DEFAULT
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-j, 1-i) = q(i, 1-j)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-j, npy-1+i) = q(i&
&                 , npy-1+j)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx-1+j, 1-i) = q(&
&                 npx-1-i+1, 1-j)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx-1+j, npy-&
&               1+i) = q(npx-1-i+1, npy-1+j)
            END DO
          END DO
        END SELECT
      END IF
    END IF
  END SUBROUTINE FILL_CORNERS_2D_R8
  SUBROUTINE FILL_CORNERS_XY_2D_R4(x, y, npx, npy, dgrid, agrid, cgrid, &
&   vector)
    IMPLICIT NONE
!(isd:ied  ,jsd:jed+1)
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
!(isd:ied+1,jsd:jed  )
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    INTEGER, INTENT(IN) :: npx, npy
    LOGICAL, OPTIONAL, INTENT(IN) :: dgrid, agrid, cgrid, vector
    INTEGER :: i, j
    REAL(kind=4) :: mysign
    INTRINSIC PRESENT
    mysign = 1.0
    IF (PRESENT(vector)) THEN
      IF (vector) mysign = -1.0
    END IF
    IF (PRESENT(dgrid)) THEN
      CALL FILL_CORNERS_DGRID(x, y, npx, npy, mysign)
    ELSE IF (PRESENT(cgrid)) THEN
      CALL FILL_CORNERS_CGRID(x, y, npx, npy, mysign)
    ELSE IF (PRESENT(agrid)) THEN
      CALL FILL_CORNERS_AGRID(x, y, npx, npy, mysign)
    ELSE
      CALL FILL_CORNERS_AGRID(x, y, npx, npy, mysign)
    END IF
  END SUBROUTINE FILL_CORNERS_XY_2D_R4
!  Differentiation of fill_corners_xy_2d_r8 in reverse (adjoint) mode (with options split(a2b_edge_mod.a2b_ord4 a2b_edge_mod.a
!2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_mod.
!p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mod.mix_d
!p dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayleigh_Sup
!er fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_geos fv_grid
!_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_mapz_mod.
!compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tra
!cer_fb fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_limite
!rs fv_mapz_mod.ppm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.moist
!_cv fv_mapz_mod.moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer_2d 
!fv_tracer2d_mod.tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.Riem_So
!lver_c nh_utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SIM3p0_so
!lver nh_utils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nest_halo_
!nh sw_core_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_vect sw
!_core_mod.fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v sw_core_
!mod.compute_divergence_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_core_mod.fv_
!tp_2d_fb tp_core_mod.copy_corners tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_corner
!_fb fv_grid_utils_mod.great_circle_dist sw_core_mod.edge_interpolate4)):
!   gradient     of useful results: x y
!   with respect to varying inputs: x y
  SUBROUTINE FILL_CORNERS_XY_2D_R8_ADM(x, x_ad, y, y_ad, npx, npy, dgrid&
&   , agrid, cgrid, vector)
    IMPLICIT NONE
!(isd:ied  ,jsd:jed+1)
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x_ad
!(isd:ied+1,jsd:jed  )
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y_ad
    INTEGER, INTENT(IN) :: npx, npy
    LOGICAL, OPTIONAL, INTENT(IN) :: dgrid, agrid, cgrid, vector
    INTEGER :: i, j
    REAL(kind=8) :: mysign
    INTRINSIC PRESENT
    INTEGER :: branch
    mysign = 1.0
    IF (PRESENT(vector)) THEN
      IF (vector) THEN
        CALL PUSHCONTROL1B(0)
        mysign = -1.0
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (PRESENT(dgrid)) THEN
      CALL FILL_CORNERS_DGRID_ADM(x, x_ad, y, y_ad, npx, npy, mysign)
    ELSE IF (PRESENT(cgrid)) THEN
      CALL FILL_CORNERS_CGRID_ADM(x, x_ad, y, y_ad, npx, npy, mysign)
    ELSE IF (PRESENT(agrid)) THEN
      CALL FILL_CORNERS_AGRID_ADM(x, x_ad, y, y_ad, npx, npy, mysign)
    ELSE
      CALL FILL_CORNERS_AGRID_ADM(x, x_ad, y, y_ad, npx, npy, mysign)
    END IF
    CALL POPCONTROL1B(branch)
  END SUBROUTINE FILL_CORNERS_XY_2D_R8_ADM
  SUBROUTINE FILL_CORNERS_XY_2D_R8(x, y, npx, npy, dgrid, agrid, cgrid, &
&   vector)
    IMPLICIT NONE
!(isd:ied  ,jsd:jed+1)
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
!(isd:ied+1,jsd:jed  )
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    INTEGER, INTENT(IN) :: npx, npy
    LOGICAL, OPTIONAL, INTENT(IN) :: dgrid, agrid, cgrid, vector
    INTEGER :: i, j
    REAL(kind=8) :: mysign
    INTRINSIC PRESENT
    mysign = 1.0
    IF (PRESENT(vector)) THEN
      IF (vector) mysign = -1.0
    END IF
    IF (PRESENT(dgrid)) THEN
      CALL FILL_CORNERS_DGRID(x, y, npx, npy, mysign)
    ELSE IF (PRESENT(cgrid)) THEN
      CALL FILL_CORNERS_CGRID(x, y, npx, npy, mysign)
    ELSE IF (PRESENT(agrid)) THEN
      CALL FILL_CORNERS_AGRID(x, y, npx, npy, mysign)
    ELSE
      CALL FILL_CORNERS_AGRID(x, y, npx, npy, mysign)
    END IF
  END SUBROUTINE FILL_CORNERS_XY_2D_R8
  SUBROUTINE FILL_CORNERS_XY_3D_R4(x, y, npx, npy, npz, dgrid, agrid, &
&   cgrid, vector)
    IMPLICIT NONE
!(isd:ied  ,jsd:jed+1)
    REAL(kind=4), DIMENSION(isd:, jsd:, :), INTENT(INOUT) :: x
!(isd:ied+1,jsd:jed  )
    REAL(kind=4), DIMENSION(isd:, jsd:, :), INTENT(INOUT) :: y
    INTEGER, INTENT(IN) :: npx, npy, npz
    LOGICAL, OPTIONAL, INTENT(IN) :: dgrid, agrid, cgrid, vector
    INTEGER :: i, j, k
    REAL(kind=4) :: mysign
    INTRINSIC PRESENT
    mysign = 1.0
    IF (PRESENT(vector)) THEN
      IF (vector) mysign = -1.0
    END IF
    IF (PRESENT(dgrid)) THEN
      DO k=1,npz
        CALL FILL_CORNERS_DGRID(x(:, :, k), y(:, :, k), npx, npy, mysign&
&                        )
      END DO
    ELSE IF (PRESENT(cgrid)) THEN
      DO k=1,npz
        CALL FILL_CORNERS_CGRID(x(:, :, k), y(:, :, k), npx, npy, mysign&
&                        )
      END DO
    ELSE IF (PRESENT(agrid)) THEN
      DO k=1,npz
        CALL FILL_CORNERS_AGRID(x(:, :, k), y(:, :, k), npx, npy, mysign&
&                        )
      END DO
    ELSE
      DO k=1,npz
        CALL FILL_CORNERS_AGRID(x(:, :, k), y(:, :, k), npx, npy, mysign&
&                        )
      END DO
    END IF
  END SUBROUTINE FILL_CORNERS_XY_3D_R4
  SUBROUTINE FILL_CORNERS_XY_3D_R8(x, y, npx, npy, npz, dgrid, agrid, &
&   cgrid, vector)
    IMPLICIT NONE
!(isd:ied  ,jsd:jed+1)
    REAL(kind=8), DIMENSION(isd:, jsd:, :), INTENT(INOUT) :: x
!(isd:ied+1,jsd:jed  )
    REAL(kind=8), DIMENSION(isd:, jsd:, :), INTENT(INOUT) :: y
    INTEGER, INTENT(IN) :: npx, npy, npz
    LOGICAL, OPTIONAL, INTENT(IN) :: dgrid, agrid, cgrid, vector
    INTEGER :: i, j, k
    REAL(kind=8) :: mysign
    INTRINSIC PRESENT
    mysign = 1.0
    IF (PRESENT(vector)) THEN
      IF (vector) mysign = -1.0
    END IF
    IF (PRESENT(dgrid)) THEN
      DO k=1,npz
        CALL FILL_CORNERS_DGRID(x(:, :, k), y(:, :, k), npx, npy, mysign&
&                        )
      END DO
    ELSE IF (PRESENT(cgrid)) THEN
      DO k=1,npz
        CALL FILL_CORNERS_CGRID(x(:, :, k), y(:, :, k), npx, npy, mysign&
&                        )
      END DO
    ELSE IF (PRESENT(agrid)) THEN
      DO k=1,npz
        CALL FILL_CORNERS_AGRID(x(:, :, k), y(:, :, k), npx, npy, mysign&
&                        )
      END DO
    ELSE
      DO k=1,npz
        CALL FILL_CORNERS_AGRID(x(:, :, k), y(:, :, k), npx, npy, mysign&
&                        )
      END DO
    END IF
  END SUBROUTINE FILL_CORNERS_XY_3D_R8
! FILL CORNERS AGRID
! ------------------
  SUBROUTINE FILL_CORNERS_AGRID_R4(x, y, npx, npy, mysign)
    IMPLICIT NONE
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    INTEGER, INTENT(IN) :: npx, npy
    REAL(kind=4), INTENT(IN) :: mysign
    INTEGER :: i, j
    DO j=1,ng
      DO i=1,ng
!SW Corner
        IF (is .EQ. 1 .AND. js .EQ. 1) x(1-i, 1-j) = mysign*y(1-j, i)
!NW Corner
        IF (is .EQ. 1 .AND. je .EQ. npy - 1) x(1-i, npy-1+j) = y(1-j, &
&           npy-1-i+1)
!SE Corner
        IF (ie .EQ. npx - 1 .AND. js .EQ. 1) x(npx-1+i, 1-j) = y(npx-1+j&
&           , i)
!NE Corner
        IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) x(npx-1+i, npy-1+j)&
&          = mysign*y(npx-1+j, npy-1-i+1)
      END DO
    END DO
    DO j=1,ng
      DO i=1,ng
!SW Corner
        IF (is .EQ. 1 .AND. js .EQ. 1) y(1-j, 1-i) = mysign*x(i, 1-j)
!NW Corner
        IF (is .EQ. 1 .AND. je .EQ. npy - 1) y(1-j, npy-1+i) = x(i, npy-&
&           1+j)
!SE Corner
        IF (ie .EQ. npx - 1 .AND. js .EQ. 1) y(npx-1+j, 1-i) = x(npx-1-i&
&           +1, 1-j)
!NE Corner
        IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) y(npx-1+j, npy-1+i)&
&          = mysign*x(npx-1-i+1, npy-1+j)
      END DO
    END DO
  END SUBROUTINE FILL_CORNERS_AGRID_R4
!  Differentiation of fill_corners_agrid_r8 in reverse (adjoint) mode (with options split(a2b_edge_mod.a2b_ord4 a2b_edge_mod.a
!2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_mod.
!p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mod.mix_d
!p dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayleigh_Sup
!er fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_geos fv_grid
!_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_mapz_mod.
!compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tra
!cer_fb fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_limite
!rs fv_mapz_mod.ppm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.moist
!_cv fv_mapz_mod.moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer_2d 
!fv_tracer2d_mod.tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.Riem_So
!lver_c nh_utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SIM3p0_so
!lver nh_utils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nest_halo_
!nh sw_core_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_vect sw
!_core_mod.fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v sw_core_
!mod.compute_divergence_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_core_mod.fv_
!tp_2d_fb tp_core_mod.copy_corners tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_corner
!_fb fv_grid_utils_mod.great_circle_dist sw_core_mod.edge_interpolate4)):
!   gradient     of useful results: x y
!   with respect to varying inputs: x y
  SUBROUTINE FILL_CORNERS_AGRID_R8_ADM(x, x_ad, y, y_ad, npx, npy, &
&   mysign)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x_ad
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y_ad
    INTEGER, INTENT(IN) :: npx, npy
    REAL(kind=8), INTENT(IN) :: mysign
    INTEGER :: i, j
    INTEGER :: branch
    DO j=1,ng
      DO i=1,ng
!SW Corner
        IF (is .EQ. 1 .AND. js .EQ. 1) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!NW Corner
        IF (is .EQ. 1 .AND. je .EQ. npy - 1) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!SE Corner
        IF (ie .EQ. npx - 1 .AND. js .EQ. 1) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!NE Corner
        IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) THEN
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
    END DO
    DO j=1,ng
      DO i=1,ng
!SW Corner
        IF (is .EQ. 1 .AND. js .EQ. 1) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!NW Corner
        IF (is .EQ. 1 .AND. je .EQ. npy - 1) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!SE Corner
        IF (ie .EQ. npx - 1 .AND. js .EQ. 1) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!NE Corner
        IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) THEN
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
    END DO
    DO j=ng,1,-1
      DO i=ng,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          x_ad(npx-1-i+1, npy-1+j) = x_ad(npx-1-i+1, npy-1+j) + mysign*&
&           y_ad(npx-1+j, npy-1+i)
          y_ad(npx-1+j, npy-1+i) = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          x_ad(npx-1-i+1, 1-j) = x_ad(npx-1-i+1, 1-j) + y_ad(npx-1+j, 1-&
&           i)
          y_ad(npx-1+j, 1-i) = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          x_ad(i, npy-1+j) = x_ad(i, npy-1+j) + y_ad(1-j, npy-1+i)
          y_ad(1-j, npy-1+i) = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          x_ad(i, 1-j) = x_ad(i, 1-j) + mysign*y_ad(1-j, 1-i)
          y_ad(1-j, 1-i) = 0.0_8
        END IF
      END DO
    END DO
    DO j=ng,1,-1
      DO i=ng,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          y_ad(npx-1+j, npy-1-i+1) = y_ad(npx-1+j, npy-1-i+1) + mysign*&
&           x_ad(npx-1+i, npy-1+j)
          x_ad(npx-1+i, npy-1+j) = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          y_ad(npx-1+j, i) = y_ad(npx-1+j, i) + x_ad(npx-1+i, 1-j)
          x_ad(npx-1+i, 1-j) = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          y_ad(1-j, npy-1-i+1) = y_ad(1-j, npy-1-i+1) + x_ad(1-i, npy-1+&
&           j)
          x_ad(1-i, npy-1+j) = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          y_ad(1-j, i) = y_ad(1-j, i) + mysign*x_ad(1-i, 1-j)
          x_ad(1-i, 1-j) = 0.0_8
        END IF
      END DO
    END DO
  END SUBROUTINE FILL_CORNERS_AGRID_R8_ADM
  SUBROUTINE FILL_CORNERS_AGRID_R8(x, y, npx, npy, mysign)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    INTEGER, INTENT(IN) :: npx, npy
    REAL(kind=8), INTENT(IN) :: mysign
    INTEGER :: i, j
    DO j=1,ng
      DO i=1,ng
!SW Corner
        IF (is .EQ. 1 .AND. js .EQ. 1) x(1-i, 1-j) = mysign*y(1-j, i)
!NW Corner
        IF (is .EQ. 1 .AND. je .EQ. npy - 1) x(1-i, npy-1+j) = y(1-j, &
&           npy-1-i+1)
!SE Corner
        IF (ie .EQ. npx - 1 .AND. js .EQ. 1) x(npx-1+i, 1-j) = y(npx-1+j&
&           , i)
!NE Corner
        IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) x(npx-1+i, npy-1+j)&
&          = mysign*y(npx-1+j, npy-1-i+1)
      END DO
    END DO
    DO j=1,ng
      DO i=1,ng
!SW Corner
        IF (is .EQ. 1 .AND. js .EQ. 1) y(1-j, 1-i) = mysign*x(i, 1-j)
!NW Corner
        IF (is .EQ. 1 .AND. je .EQ. npy - 1) y(1-j, npy-1+i) = x(i, npy-&
&           1+j)
!SE Corner
        IF (ie .EQ. npx - 1 .AND. js .EQ. 1) y(npx-1+j, 1-i) = x(npx-1-i&
&           +1, 1-j)
!NE Corner
        IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) y(npx-1+j, npy-1+i)&
&          = mysign*x(npx-1-i+1, npy-1+j)
      END DO
    END DO
  END SUBROUTINE FILL_CORNERS_AGRID_R8
! FILL CORNERS CGRID
! ------------------
  SUBROUTINE FILL_CORNERS_CGRID_R4(x, y, npx, npy, mysign)
    IMPLICIT NONE
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    INTEGER, INTENT(IN) :: npx, npy
    REAL(kind=4), INTENT(IN) :: mysign
    INTEGER :: i, j
    DO j=1,ng
      DO i=1,ng
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) x(1-i, 1-j) = y(j, 1-i)
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) x(1-i, npy-1+j) = mysign*y(&
&           j, npy+i)
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) x(npx+i, 1-j) = mysign*y(&
&           npx-j, 1-i)
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) x(npx+i, npy-1+j) = y&
&           (npx-j, npy+i)
      END DO
    END DO
    DO j=1,ng
      DO i=1,ng
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) y(1-i, 1-j) = x(1-j, i)
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) y(1-i, npy+j) = mysign*x(1-&
&           j, npy-i)
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) y(npx-1+i, 1-j) = mysign*x(&
&           npx+j, i)
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) y(npx-1+i, npy+j) = x&
&           (npx+j, npy-i)
      END DO
    END DO
  END SUBROUTINE FILL_CORNERS_CGRID_R4
!  Differentiation of fill_corners_cgrid_r8 in reverse (adjoint) mode (with options split(a2b_edge_mod.a2b_ord4 a2b_edge_mod.a
!2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_mod.
!p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mod.mix_d
!p dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayleigh_Sup
!er fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_geos fv_grid
!_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_mapz_mod.
!compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tra
!cer_fb fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_limite
!rs fv_mapz_mod.ppm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.moist
!_cv fv_mapz_mod.moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer_2d 
!fv_tracer2d_mod.tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.Riem_So
!lver_c nh_utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SIM3p0_so
!lver nh_utils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nest_halo_
!nh sw_core_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_vect sw
!_core_mod.fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v sw_core_
!mod.compute_divergence_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_core_mod.fv_
!tp_2d_fb tp_core_mod.copy_corners tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_corner
!_fb fv_grid_utils_mod.great_circle_dist sw_core_mod.edge_interpolate4)):
!   gradient     of useful results: x y
!   with respect to varying inputs: x y
  SUBROUTINE FILL_CORNERS_CGRID_R8_ADM(x, x_ad, y, y_ad, npx, npy, &
&   mysign)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x_ad
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y_ad
    INTEGER, INTENT(IN) :: npx, npy
    REAL(kind=8), INTENT(IN) :: mysign
    INTEGER :: i, j
    INTEGER :: branch
    DO j=1,ng
      DO i=1,ng
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) THEN
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
    END DO
    DO j=1,ng
      DO i=1,ng
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) THEN
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
    END DO
    DO j=ng,1,-1
      DO i=ng,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          x_ad(npx+j, npy-i) = x_ad(npx+j, npy-i) + y_ad(npx-1+i, npy+j)
          y_ad(npx-1+i, npy+j) = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          x_ad(npx+j, i) = x_ad(npx+j, i) + mysign*y_ad(npx-1+i, 1-j)
          y_ad(npx-1+i, 1-j) = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          x_ad(1-j, npy-i) = x_ad(1-j, npy-i) + mysign*y_ad(1-i, npy+j)
          y_ad(1-i, npy+j) = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          x_ad(1-j, i) = x_ad(1-j, i) + y_ad(1-i, 1-j)
          y_ad(1-i, 1-j) = 0.0_8
        END IF
      END DO
    END DO
    DO j=ng,1,-1
      DO i=ng,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          y_ad(npx-j, npy+i) = y_ad(npx-j, npy+i) + x_ad(npx+i, npy-1+j)
          x_ad(npx+i, npy-1+j) = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          y_ad(npx-j, 1-i) = y_ad(npx-j, 1-i) + mysign*x_ad(npx+i, 1-j)
          x_ad(npx+i, 1-j) = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          y_ad(j, npy+i) = y_ad(j, npy+i) + mysign*x_ad(1-i, npy-1+j)
          x_ad(1-i, npy-1+j) = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          y_ad(j, 1-i) = y_ad(j, 1-i) + x_ad(1-i, 1-j)
          x_ad(1-i, 1-j) = 0.0_8
        END IF
      END DO
    END DO
  END SUBROUTINE FILL_CORNERS_CGRID_R8_ADM
  SUBROUTINE FILL_CORNERS_CGRID_R8(x, y, npx, npy, mysign)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    INTEGER, INTENT(IN) :: npx, npy
    REAL(kind=8), INTENT(IN) :: mysign
    INTEGER :: i, j
    DO j=1,ng
      DO i=1,ng
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) x(1-i, 1-j) = y(j, 1-i)
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) x(1-i, npy-1+j) = mysign*y(&
&           j, npy+i)
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) x(npx+i, 1-j) = mysign*y(&
&           npx-j, 1-i)
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) x(npx+i, npy-1+j) = y&
&           (npx-j, npy+i)
      END DO
    END DO
    DO j=1,ng
      DO i=1,ng
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) y(1-i, 1-j) = x(1-j, i)
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) y(1-i, npy+j) = mysign*x(1-&
&           j, npy-i)
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) y(npx-1+i, 1-j) = mysign*x(&
&           npx+j, i)
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) y(npx-1+i, npy+j) = x&
&           (npx+j, npy-i)
      END DO
    END DO
  END SUBROUTINE FILL_CORNERS_CGRID_R8
! FILL CORNERS DGRID
! ------------------
  SUBROUTINE FILL_CORNERS_DGRID_R4(x, y, npx, npy, mysign)
    IMPLICIT NONE
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    INTEGER, INTENT(IN) :: npx, npy
    REAL(kind=4), INTENT(IN) :: mysign
    INTEGER :: i, j
    DO j=1,ng
      DO i=1,ng
!   if ((is  ==  1) .and. (js  ==  1)) x(1-i    ,1-j  ) =        y(j+1  ,1-i    )  !SW Corner 
!   if ((is  ==  1) .and. (je+1==npy)) x(1-i    ,npy+j) = mySign*y(j+1  ,npy-1+i)  !NW Corner
!   if ((ie+1==npx) .and. (js  ==  1)) x(npx-1+i,1-j  ) = mySign*y(npx-j,1-i    )  !SE Corner
!   if ((ie+1==npx) .and. (je+1==npy)) x(npx-1+i,npy+j) =        y(npx-j,npy-1+i)  !NE Corner
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) x(1-i, 1-j) = mysign*y(1-j, i)
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) x(1-i, npy+j) = y(1-j, npy-&
&           i)
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) x(npx-1+i, 1-j) = y(npx+j, &
&           i)
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) x(npx-1+i, npy+j) = &
&           mysign*y(npx+j, npy-i)
      END DO
    END DO
    DO j=1,ng
      DO i=1,ng
!  if ((is  ==  1) .and. (js  ==  1)) y(1-i    ,1-j    ) =        x(1-j    ,i+1  )  !SW Corner 
!  if ((is  ==  1) .and. (je+1==npy)) y(1-i    ,npy-1+j) = mySign*x(1-j    ,npy-i)  !NW Corner
!  if ((ie+1==npx) .and. (js  ==  1)) y(npx+i  ,1-j    ) = mySign*x(npx-1+j,i+1  )  !SE Corner
!  if ((ie+1==npx) .and. (je+1==npy)) y(npx+i  ,npy-1+j) =        x(npx-1+j,npy-i)  !NE Corner
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) y(1-i, 1-j) = mysign*x(j, 1-i)
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) y(1-i, npy-1+j) = x(j, npy+&
&           i)
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) y(npx+i, 1-j) = x(npx-j, 1-&
&           i)
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) y(npx+i, npy-1+j) = &
&           mysign*x(npx-j, npy+i)
      END DO
    END DO
  END SUBROUTINE FILL_CORNERS_DGRID_R4
!  Differentiation of fill_corners_dgrid_r8 in reverse (adjoint) mode (with options split(a2b_edge_mod.a2b_ord4 a2b_edge_mod.a
!2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_mod.
!p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mod.mix_d
!p dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayleigh_Sup
!er fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_geos fv_grid
!_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_mapz_mod.
!compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tra
!cer_fb fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_limite
!rs fv_mapz_mod.ppm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.moist
!_cv fv_mapz_mod.moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer_2d 
!fv_tracer2d_mod.tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.Riem_So
!lver_c nh_utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SIM3p0_so
!lver nh_utils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nest_halo_
!nh sw_core_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_vect sw
!_core_mod.fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v sw_core_
!mod.compute_divergence_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_core_mod.fv_
!tp_2d_fb tp_core_mod.copy_corners tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_corner
!_fb fv_grid_utils_mod.great_circle_dist sw_core_mod.edge_interpolate4)):
!   gradient     of useful results: x y
!   with respect to varying inputs: x y
  SUBROUTINE FILL_CORNERS_DGRID_R8_ADM(x, x_ad, y, y_ad, npx, npy, &
&   mysign)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x_ad
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y_ad
    INTEGER, INTENT(IN) :: npx, npy
    REAL(kind=8), INTENT(IN) :: mysign
    INTEGER :: i, j
    INTEGER :: branch
    DO j=1,ng
      DO i=1,ng
!   if ((is  ==  1) .and. (js  ==  1)) x(1-i    ,1-j  ) =        y(j+1  ,1-i    )  !SW Corner 
!   if ((is  ==  1) .and. (je+1==npy)) x(1-i    ,npy+j) = mySign*y(j+1  ,npy-1+i)  !NW Corner
!   if ((ie+1==npx) .and. (js  ==  1)) x(npx-1+i,1-j  ) = mySign*y(npx-j,1-i    )  !SE Corner
!   if ((ie+1==npx) .and. (je+1==npy)) x(npx-1+i,npy+j) =        y(npx-j,npy-1+i)  !NE Corner
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) THEN
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
    END DO
    DO j=1,ng
      DO i=1,ng
!  if ((is  ==  1) .and. (js  ==  1)) y(1-i    ,1-j    ) =        x(1-j    ,i+1  )  !SW Corner 
!  if ((is  ==  1) .and. (je+1==npy)) y(1-i    ,npy-1+j) = mySign*x(1-j    ,npy-i)  !NW Corner
!  if ((ie+1==npx) .and. (js  ==  1)) y(npx+i  ,1-j    ) = mySign*x(npx-1+j,i+1  )  !SE Corner
!  if ((ie+1==npx) .and. (je+1==npy)) y(npx+i  ,npy-1+j) =        x(npx-1+j,npy-i)  !NE Corner
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) THEN
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
    END DO
    DO j=ng,1,-1
      DO i=ng,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          x_ad(npx-j, npy+i) = x_ad(npx-j, npy+i) + mysign*y_ad(npx+i, &
&           npy-1+j)
          y_ad(npx+i, npy-1+j) = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          x_ad(npx-j, 1-i) = x_ad(npx-j, 1-i) + y_ad(npx+i, 1-j)
          y_ad(npx+i, 1-j) = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          x_ad(j, npy+i) = x_ad(j, npy+i) + y_ad(1-i, npy-1+j)
          y_ad(1-i, npy-1+j) = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          x_ad(j, 1-i) = x_ad(j, 1-i) + mysign*y_ad(1-i, 1-j)
          y_ad(1-i, 1-j) = 0.0_8
        END IF
      END DO
    END DO
    DO j=ng,1,-1
      DO i=ng,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          y_ad(npx+j, npy-i) = y_ad(npx+j, npy-i) + mysign*x_ad(npx-1+i&
&           , npy+j)
          x_ad(npx-1+i, npy+j) = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          y_ad(npx+j, i) = y_ad(npx+j, i) + x_ad(npx-1+i, 1-j)
          x_ad(npx-1+i, 1-j) = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          y_ad(1-j, npy-i) = y_ad(1-j, npy-i) + x_ad(1-i, npy+j)
          x_ad(1-i, npy+j) = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          y_ad(1-j, i) = y_ad(1-j, i) + mysign*x_ad(1-i, 1-j)
          x_ad(1-i, 1-j) = 0.0_8
        END IF
      END DO
    END DO
  END SUBROUTINE FILL_CORNERS_DGRID_R8_ADM
  SUBROUTINE FILL_CORNERS_DGRID_R8(x, y, npx, npy, mysign)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    INTEGER, INTENT(IN) :: npx, npy
    REAL(kind=8), INTENT(IN) :: mysign
    INTEGER :: i, j
    DO j=1,ng
      DO i=1,ng
!   if ((is  ==  1) .and. (js  ==  1)) x(1-i    ,1-j  ) =        y(j+1  ,1-i    )  !SW Corner 
!   if ((is  ==  1) .and. (je+1==npy)) x(1-i    ,npy+j) = mySign*y(j+1  ,npy-1+i)  !NW Corner
!   if ((ie+1==npx) .and. (js  ==  1)) x(npx-1+i,1-j  ) = mySign*y(npx-j,1-i    )  !SE Corner
!   if ((ie+1==npx) .and. (je+1==npy)) x(npx-1+i,npy+j) =        y(npx-j,npy-1+i)  !NE Corner
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) x(1-i, 1-j) = mysign*y(1-j, i)
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) x(1-i, npy+j) = y(1-j, npy-&
&           i)
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) x(npx-1+i, 1-j) = y(npx+j, &
&           i)
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) x(npx-1+i, npy+j) = &
&           mysign*y(npx+j, npy-i)
      END DO
    END DO
    DO j=1,ng
      DO i=1,ng
!  if ((is  ==  1) .and. (js  ==  1)) y(1-i    ,1-j    ) =        x(1-j    ,i+1  )  !SW Corner 
!  if ((is  ==  1) .and. (je+1==npy)) y(1-i    ,npy-1+j) = mySign*x(1-j    ,npy-i)  !NW Corner
!  if ((ie+1==npx) .and. (js  ==  1)) y(npx+i  ,1-j    ) = mySign*x(npx-1+j,i+1  )  !SE Corner
!  if ((ie+1==npx) .and. (je+1==npy)) y(npx+i  ,npy-1+j) =        x(npx-1+j,npy-i)  !NE Corner
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) y(1-i, 1-j) = mysign*x(j, 1-i)
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) y(1-i, npy-1+j) = x(j, npy+&
&           i)
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) y(npx+i, 1-j) = x(npx-j, 1-&
&           i)
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) y(npx+i, npy-1+j) = &
&           mysign*x(npx-j, npy+i)
      END DO
    END DO
  END SUBROUTINE FILL_CORNERS_DGRID_R8
! MP REDUCE SUM
! -------------
  SUBROUTINE MP_REDUCE_SUM_R4(mysum)
    IMPLICIT NONE
    REAL(kind=4), INTENT(INOUT) :: mysum
    REAL(kind=4) :: gsum
    mysum = 2*mysum
  END SUBROUTINE MP_REDUCE_SUM_R4
!  Differentiation of mp_reduce_sum_r8 in reverse (adjoint) mode (with options split(a2b_edge_mod.a2b_ord4 a2b_edge_mod.a2b_or
!d2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_gra
!d_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mod.mix_dp dyn
!_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayleigh_Super fv
!_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_geos fv_grid_util
!s_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_mapz_mod.compu
!te_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer_f
!b fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_limiters fv
!_mapz_mod.ppm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.moist_cv f
!v_mapz_mod.moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer_2d fv_tr
!acer2d_mod.tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.Riem_Solver_
!c nh_utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SIM3p0_solver 
!nh_utils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nest_halo_nh sw
!_core_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_vect sw_core
!_mod.fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v sw_core_mod.c
!ompute_divergence_damping_fb sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_core_mod.fv_tp_2d
!_fb tp_core_mod.copy_corners tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_corner f
!v_grid_utils_mod.great_circle_dist sw_core_mod.edge_interpolate4)):
!   gradient     of useful results: mysum
!   with respect to varying inputs: mysum
  SUBROUTINE MP_REDUCE_SUM_R8_ADM(mysum, mysum_ad)
    IMPLICIT NONE
    REAL(kind=8), INTENT(INOUT) :: mysum
    REAL(kind=8), INTENT(INOUT) :: mysum_ad
    REAL(kind=8) :: gsum
    mysum_ad = 2*mysum_ad
  END SUBROUTINE MP_REDUCE_SUM_R8_ADM
  SUBROUTINE MP_REDUCE_SUM_R8(mysum)
    IMPLICIT NONE
    REAL(kind=8), INTENT(INOUT) :: mysum
    REAL(kind=8) :: gsum
    mysum = 2*mysum
  END SUBROUTINE MP_REDUCE_SUM_R8
  SUBROUTINE MP_REDUCE_SUM_R4_1D(mysum, sum1d, npts)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npts
    REAL(kind=4), INTENT(IN) :: sum1d(npts)
    REAL(kind=4), INTENT(INOUT) :: mysum
    REAL(kind=4) :: gsum
    INTEGER :: i
    mysum = 2*mysum
  END SUBROUTINE MP_REDUCE_SUM_R4_1D
  SUBROUTINE MP_REDUCE_SUM_R8_1D(mysum, sum1d, npts)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npts
    REAL(kind=8), INTENT(IN) :: sum1d(npts)
    REAL(kind=8), INTENT(INOUT) :: mysum
    REAL(kind=8) :: gsum
    INTEGER :: i
    mysum = 2*mysum
  END SUBROUTINE MP_REDUCE_SUM_R8_1D
! MP REDUCE MAX
! -------------
  SUBROUTINE MP_REDUCE_MAX_R4_1D(mymax, npts)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npts
    REAL(kind=4), INTENT(INOUT) :: mymax(npts)
    REAL(kind=4) :: gmax(npts)
    mymax = 2*mymax
  END SUBROUTINE MP_REDUCE_MAX_R4_1D
  SUBROUTINE MP_REDUCE_MAX_R8_1D(mymax, npts)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npts
    REAL(kind=8), INTENT(INOUT) :: mymax(npts)
    REAL(kind=8) :: gmax(npts)
    mymax = 2*mymax
  END SUBROUTINE MP_REDUCE_MAX_R8_1D
  SUBROUTINE MP_REDUCE_MAX_R4(mymax)
    IMPLICIT NONE
    REAL(kind=4), INTENT(INOUT) :: mymax
    REAL(kind=4) :: gmax
    mymax = 2*mymax
  END SUBROUTINE MP_REDUCE_MAX_R4
  SUBROUTINE MP_REDUCE_MAX_R8(mymax)
    IMPLICIT NONE
    REAL(kind=8), INTENT(INOUT) :: mymax
    REAL(kind=8) :: gmax
    mymax = 2*mymax
  END SUBROUTINE MP_REDUCE_MAX_R8
  SUBROUTINE MP_REDUCE_MAX_I4(mymax)
    IMPLICIT NONE
    INTEGER, INTENT(INOUT) :: mymax
    INTEGER :: gmax
    mymax = 2*mymax
  END SUBROUTINE MP_REDUCE_MAX_I4
! start_group_halo_update
! -----------------------
  SUBROUTINE START_VAR_GROUP_UPDATE_2D(group, array, domain, flags, &
&   position, whalo, ehalo, shalo, nhalo, complete)
    IMPLICIT NONE
!, group_tl
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: group
    REAL, DIMENSION(:, :), INTENT(INOUT) :: array
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    INTEGER, OPTIONAL, INTENT(IN) :: flags
    INTEGER, OPTIONAL, INTENT(IN) :: position
    INTEGER, OPTIONAL, INTENT(IN) :: whalo, ehalo, shalo, nhalo
    LOGICAL, OPTIONAL, INTENT(IN) :: complete
    REAL :: d_type
    LOGICAL :: is_complete
! Arguments: 
!  (inout)   group - The data type that store information for group update. 
!                    This data will be used in do_group_pass.
!  (inout)   array - The array which is having its halos points exchanged.
!  (in)      domain - contains domain information.
!  (in)      flags  - An optional integer indicating which directions the
!                       data should be sent.  
!  (in)      position - An optional argument indicating the position.  This is
!                       may be CORNER, but is CENTER by default.
!  (in)      complete - An optional argument indicating whether the halo updates
!                       should be initiated immediately or wait for second 
!                       pass_..._start call.  Omitting complete is the same as 
!                       setting complete to .true.
    array = 2*array
  END SUBROUTINE START_VAR_GROUP_UPDATE_2D
!  Differentiation of start_var_group_update_3d in reverse (adjoint) mode (with options split(a2b_edge_mod.a2b_ord4 a2b_edge_m
!od.a2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_
!mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mod.m
!ix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayleigh
!_Super fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_geos fv_
!grid_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_mapz_
!mod.compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn
!_tracer_fb fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_li
!miters fv_mapz_mod.ppm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.m
!oist_cv fv_mapz_mod.moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer
!_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.Rie
!m_Solver_c nh_utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SIM3p
!0_solver nh_utils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nest_h
!alo_nh sw_core_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_vec
!t sw_core_mod.fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v sw_c
!ore_mod.compute_divergence_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_core_mod
!.fv_tp_2d tp_core_mod.copy_corners tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_co
!rner_fb fv_grid_utils_mod.great_circle_dist sw_core_mod.edge_interpolate4)):
!   gradient     of useful results: array
!   with respect to varying inputs: array
  SUBROUTINE START_VAR_GROUP_UPDATE_3D_ADM(group, array, array_ad, &
&   domain, flags, position, whalo, ehalo, shalo, nhalo, complete)
    IMPLICIT NONE
!, group_tl
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: group
    REAL, DIMENSION(:, :, :), INTENT(INOUT) :: array
    REAL, DIMENSION(:, :, :), INTENT(INOUT) :: array_ad
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    INTEGER, OPTIONAL, INTENT(IN) :: flags
    INTEGER, OPTIONAL, INTENT(IN) :: position
    INTEGER, OPTIONAL, INTENT(IN) :: whalo, ehalo, shalo, nhalo
    LOGICAL, OPTIONAL, INTENT(IN) :: complete
    REAL :: d_type
    LOGICAL :: is_complete
! Arguments: 
!  (inout)   group - The data type that store information for group update. 
!                    This data will be used in do_group_pass.
!  (inout)   array - The array which is having its halos points exchanged.
!  (in)      domain - contains domain information.
!  (in)      flags  - An optional integer indicating which directions the
!                       data should be sent.  
!  (in)      position - An optional argument indicating the position.  This is
!                       may be CORNER, but is CENTER by default.
!  (in)      complete - An optional argument indicating whether the halo updates
!                       should be initiated immediately or wait for second 
!                       pass_..._start call.  Omitting complete is the same as 
!                       setting complete to .true.
    array_ad = 2*array_ad
  END SUBROUTINE START_VAR_GROUP_UPDATE_3D_ADM
  SUBROUTINE START_VAR_GROUP_UPDATE_3D(group, array, domain, flags, &
&   position, whalo, ehalo, shalo, nhalo, complete)
    IMPLICIT NONE
!, group_tl
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: group
    REAL, DIMENSION(:, :, :), INTENT(INOUT) :: array
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    INTEGER, OPTIONAL, INTENT(IN) :: flags
    INTEGER, OPTIONAL, INTENT(IN) :: position
    INTEGER, OPTIONAL, INTENT(IN) :: whalo, ehalo, shalo, nhalo
    LOGICAL, OPTIONAL, INTENT(IN) :: complete
    REAL :: d_type
    LOGICAL :: is_complete
! Arguments: 
!  (inout)   group - The data type that store information for group update. 
!                    This data will be used in do_group_pass.
!  (inout)   array - The array which is having its halos points exchanged.
!  (in)      domain - contains domain information.
!  (in)      flags  - An optional integer indicating which directions the
!                       data should be sent.  
!  (in)      position - An optional argument indicating the position.  This is
!                       may be CORNER, but is CENTER by default.
!  (in)      complete - An optional argument indicating whether the halo updates
!                       should be initiated immediately or wait for second 
!                       pass_..._start call.  Omitting complete is the same as 
!                       setting complete to .true.
    array = 2*array
  END SUBROUTINE START_VAR_GROUP_UPDATE_3D
!  Differentiation of start_var_group_update_4d in reverse (adjoint) mode (with options split(a2b_edge_mod.a2b_ord4 a2b_edge_m
!od.a2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_
!mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mod.m
!ix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayleigh
!_Super fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_geos fv_
!grid_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_mapz_
!mod.compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn
!_tracer_fb fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_li
!miters fv_mapz_mod.ppm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.m
!oist_cv fv_mapz_mod.moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer
!_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.Rie
!m_Solver_c nh_utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SIM3p
!0_solver nh_utils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nest_h
!alo_nh sw_core_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_vec
!t sw_core_mod.fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v sw_c
!ore_mod.compute_divergence_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_core_mod
!.fv_tp_2d tp_core_mod.copy_corners tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_co
!rner_fb fv_grid_utils_mod.great_circle_dist sw_core_mod.edge_interpolate4)):
!   gradient     of useful results: array
!   with respect to varying inputs: array
  SUBROUTINE START_VAR_GROUP_UPDATE_4D_ADM(group, array, array_ad, &
&   domain, flags, position, whalo, ehalo, shalo, nhalo, complete)
    IMPLICIT NONE
!, group_tl
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: group
    REAL, DIMENSION(:, :, :, :), INTENT(INOUT) :: array
    REAL, DIMENSION(:, :, :, :), INTENT(INOUT) :: array_ad
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    INTEGER, OPTIONAL, INTENT(IN) :: flags
    INTEGER, OPTIONAL, INTENT(IN) :: position
    INTEGER, OPTIONAL, INTENT(IN) :: whalo, ehalo, shalo, nhalo
    LOGICAL, OPTIONAL, INTENT(IN) :: complete
    REAL :: d_type
    LOGICAL :: is_complete
! Arguments: 
!  (inout)   group - The data type that store information for group update. 
!                    This data will be used in do_group_pass.
!  (inout)   array - The array which is having its halos points exchanged.
!  (in)      domain - contains domain information.
!  (in)      flags  - An optional integer indicating which directions the
!                       data should be sent.  
!  (in)      position - An optional argument indicating the position.  This is
!                       may be CORNER, but is CENTER by default.
!  (in)      complete - An optional argument indicating whether the halo updates
!                       should be initiated immediately or wait for second 
!                       pass_..._start call.  Omitting complete is the same as 
!                       setting complete to .true.
    INTEGER :: dirflag
    array_ad = 2*array_ad
  END SUBROUTINE START_VAR_GROUP_UPDATE_4D_ADM
  SUBROUTINE START_VAR_GROUP_UPDATE_4D(group, array, domain, flags, &
&   position, whalo, ehalo, shalo, nhalo, complete)
    IMPLICIT NONE
!, group_tl
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: group
    REAL, DIMENSION(:, :, :, :), INTENT(INOUT) :: array
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    INTEGER, OPTIONAL, INTENT(IN) :: flags
    INTEGER, OPTIONAL, INTENT(IN) :: position
    INTEGER, OPTIONAL, INTENT(IN) :: whalo, ehalo, shalo, nhalo
    LOGICAL, OPTIONAL, INTENT(IN) :: complete
    REAL :: d_type
    LOGICAL :: is_complete
! Arguments: 
!  (inout)   group - The data type that store information for group update. 
!                    This data will be used in do_group_pass.
!  (inout)   array - The array which is having its halos points exchanged.
!  (in)      domain - contains domain information.
!  (in)      flags  - An optional integer indicating which directions the
!                       data should be sent.  
!  (in)      position - An optional argument indicating the position.  This is
!                       may be CORNER, but is CENTER by default.
!  (in)      complete - An optional argument indicating whether the halo updates
!                       should be initiated immediately or wait for second 
!                       pass_..._start call.  Omitting complete is the same as 
!                       setting complete to .true.
    INTEGER :: dirflag
    array = 2*array
  END SUBROUTINE START_VAR_GROUP_UPDATE_4D
  SUBROUTINE START_VECTOR_GROUP_UPDATE_2D(group, u_cmpt, v_cmpt, domain&
&   , flags, gridtype, whalo, ehalo, shalo, nhalo, complete)
    IMPLICIT NONE
!, group_tl
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: group
    REAL, DIMENSION(:, :), INTENT(INOUT) :: u_cmpt, v_cmpt
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    INTEGER, OPTIONAL, INTENT(IN) :: flags
    INTEGER, OPTIONAL, INTENT(IN) :: gridtype
    INTEGER, OPTIONAL, INTENT(IN) :: whalo, ehalo, shalo, nhalo
    LOGICAL, OPTIONAL, INTENT(IN) :: complete
    REAL :: d_type
    LOGICAL :: is_complete
! Arguments: 
!  (inout)   group - The data type that store information for group update. 
!                    This data will be used in do_group_pass.
!  (inout)   u_cmpt - The nominal zonal (u) component of the vector pair which
!                     is having its halos points exchanged.
!  (inout)   v_cmpt - The nominal meridional (v) component of the vector pair
!                     which is having its halos points exchanged. 
!  (in)      domain - Contains domain decomposition information.
!  (in)      flags - An optional integer indicating which directions the
!                        data should be sent. 
!  (in)      gridtype - An optional flag, which may be one of A_GRID, BGRID_NE,
!                      CGRID_NE or DGRID_NE, indicating where the two components of the
!                      vector are discretized. 
!  (in)      complete - An optional argument indicating whether the halo updates
!                       should be initiated immediately or wait for second 
!                       pass_..._start call.  Omitting complete is the same as 
!                       setting complete to .true.
    u_cmpt = 2*u_cmpt
    v_cmpt = 2*v_cmpt
  END SUBROUTINE START_VECTOR_GROUP_UPDATE_2D
!  Differentiation of start_vector_group_update_3d in reverse (adjoint) mode (with options split(a2b_edge_mod.a2b_ord4 a2b_edg
!e_mod.a2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_co
!re_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mo
!d.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayle
!igh_Super fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_geos 
!fv_grid_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_ma
!pz_mod.compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.m
!apn_tracer_fb fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs
!_limiters fv_mapz_mod.ppm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mo
!d.moist_cv fv_mapz_mod.moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tra
!cer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.
!Riem_Solver_c nh_utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SI
!M3p0_solver nh_utils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nes
!t_halo_nh sw_core_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_
!vect sw_core_mod.fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v s
!w_core_mod.compute_divergence_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_core_
!mod.fv_tp_2d tp_core_mod.copy_corners tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap
!_corner_fb fv_grid_utils_mod.great_circle_dist sw_core_mod.edge_interpolate4)):
!   gradient     of useful results: u_cmpt v_cmpt
!   with respect to varying inputs: u_cmpt v_cmpt
  SUBROUTINE START_VECTOR_GROUP_UPDATE_3D_ADM(group, u_cmpt, u_cmpt_ad, &
&   v_cmpt, v_cmpt_ad, domain, flags, gridtype, whalo, ehalo, shalo, &
&   nhalo, complete)
    IMPLICIT NONE
!, group_tl
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: group
    REAL, DIMENSION(:, :, :), INTENT(INOUT) :: u_cmpt, v_cmpt
    REAL, DIMENSION(:, :, :), INTENT(INOUT) :: u_cmpt_ad, v_cmpt_ad
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    INTEGER, OPTIONAL, INTENT(IN) :: flags
    INTEGER, OPTIONAL, INTENT(IN) :: gridtype
    INTEGER, OPTIONAL, INTENT(IN) :: whalo, ehalo, shalo, nhalo
    LOGICAL, OPTIONAL, INTENT(IN) :: complete
    REAL :: d_type
    LOGICAL :: is_complete
! Arguments: 
!  (inout)   group - The data type that store information for group update. 
!                    This data will be used in do_group_pass.
!  (inout)   u_cmpt - The nominal zonal (u) component of the vector pair which
!                     is having its halos points exchanged.
!  (inout)   v_cmpt - The nominal meridional (v) component of the vector pair
!                     which is having its halos points exchanged. 
!  (in)      domain - Contains domain decomposition information.
!  (in)      flags - An optional integer indicating which directions the
!                        data should be sent. 
!  (in)      gridtype - An optional flag, which may be one of A_GRID, BGRID_NE,
!                      CGRID_NE or DGRID_NE, indicating where the two components of the
!                      vector are discretized. 
!  (in)      complete - An optional argument indicating whether the halo updates
!                       should be initiated immediately or wait for second 
!                       pass_..._start call.  Omitting complete is the same as 
!                       setting complete to .true.
    v_cmpt_ad = 2*v_cmpt_ad
    u_cmpt_ad = 2*u_cmpt_ad
  END SUBROUTINE START_VECTOR_GROUP_UPDATE_3D_ADM
  SUBROUTINE START_VECTOR_GROUP_UPDATE_3D(group, u_cmpt, v_cmpt, domain&
&   , flags, gridtype, whalo, ehalo, shalo, nhalo, complete)
    IMPLICIT NONE
!, group_tl
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: group
    REAL, DIMENSION(:, :, :), INTENT(INOUT) :: u_cmpt, v_cmpt
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    INTEGER, OPTIONAL, INTENT(IN) :: flags
    INTEGER, OPTIONAL, INTENT(IN) :: gridtype
    INTEGER, OPTIONAL, INTENT(IN) :: whalo, ehalo, shalo, nhalo
    LOGICAL, OPTIONAL, INTENT(IN) :: complete
    REAL :: d_type
    LOGICAL :: is_complete
! Arguments: 
!  (inout)   group - The data type that store information for group update. 
!                    This data will be used in do_group_pass.
!  (inout)   u_cmpt - The nominal zonal (u) component of the vector pair which
!                     is having its halos points exchanged.
!  (inout)   v_cmpt - The nominal meridional (v) component of the vector pair
!                     which is having its halos points exchanged. 
!  (in)      domain - Contains domain decomposition information.
!  (in)      flags - An optional integer indicating which directions the
!                        data should be sent. 
!  (in)      gridtype - An optional flag, which may be one of A_GRID, BGRID_NE,
!                      CGRID_NE or DGRID_NE, indicating where the two components of the
!                      vector are discretized. 
!  (in)      complete - An optional argument indicating whether the halo updates
!                       should be initiated immediately or wait for second 
!                       pass_..._start call.  Omitting complete is the same as 
!                       setting complete to .true.
    u_cmpt = 2*u_cmpt
    v_cmpt = 2*v_cmpt
  END SUBROUTINE START_VECTOR_GROUP_UPDATE_3D
! complete_group_halo_update
! --------------------------
  SUBROUTINE COMPLETE_GROUP_HALO_UPDATE(group, domain)
    IMPLICIT NONE
! Arguments: 
!  (inout)   group - The data type that store information for group update. 
!                    This data will be used in do_group_pass.
!  (inout)   array - The array which is having its halos points exchanged.
!  (in)      domain - contains domain information.
!array = 2*array
!, group_tl
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: group
!real, dimension(:,:),         intent(inout) :: array
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
  END SUBROUTINE COMPLETE_GROUP_HALO_UPDATE
END MODULE FV_MP_MOD_B
