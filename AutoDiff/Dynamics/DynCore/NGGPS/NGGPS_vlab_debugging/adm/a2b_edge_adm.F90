!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
!***********************************************************************
!*                   GNU General Public License                        *
!* This file is a part of fvGFS.                                       *
!*                                                                     *
!* fvGFS is free software; you can redistribute it and/or modify it    *
!* and are expected to follow the terms of the GNU General Public      *
!* License as published by the Free Software Foundation; either        *
!* version 2 of the License, or (at your option) any later version.    *
!*                                                                     *
!* fvGFS is distributed in the hope that it will be useful, but        *
!* WITHOUT ANY WARRANTY; without even the implied warranty of          *
!* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU   *
!* General Public License for more details.                            *
!*                                                                     *
!* For the full text of the GNU General Public License,                *
!* write to: Free Software Foundation, Inc.,                           *
!*           675 Mass Ave, Cambridge, MA 02139, USA.                   *
!* or see:   http://www.gnu.org/licenses/gpl.html                      *
!***********************************************************************
MODULE A2B_EDGE_MOD_B
  USE FV_GRID_UTILS_MOD_B, ONLY : great_circle_dist
  USE FV_ARRAYS_MOD_B, ONLY : fv_grid_type, r_grid
  IMPLICIT NONE
  REAL, PARAMETER :: r3=1./3.
!----------------------------
! 4-pt Lagrange interpolation
!----------------------------
!  9/16
  REAL, PARAMETER :: a1=0.5625
! -1/16
  REAL, PARAMETER :: a2=-0.0625
!----------------------
! PPM volume mean form:
!----------------------
! 0.58333333
  REAL, PARAMETER :: b1=7./12.
  REAL, PARAMETER :: b2=-(1./12.)
  PRIVATE 
  PUBLIC a2b_ord2, a2b_ord4
  PUBLIC a2b_ord2_fwd, a2b_ord2_bwd, a2b_ord4_fwd, a2b_ord4_bwd
  EXTERNAL A2B_ORD2_ADM
  EXTERNAL A2B_ORD4_ADM

CONTAINS
!  Differentiation of a2b_ord4 in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord4 a2b_edge_mod
!.a2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_mo
!d.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mod.mix
!_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayleigh_S
!uper fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_geos fv_gr
!id_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_mapz_mo
!d.compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer 
!fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_limiters fv_mapz_mod.p
!pm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.moist_cv fv_mapz_mod.
!moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.
!tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.Riem_Solver_c nh_utils_
!mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SIM3p0_solver nh_utils_mo
!d.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nest_halo_nh sw_core_mod.c
!_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.fill3_
!4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v sw_core_mod.compute_divergence
!_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_core_mod.fv_tp_2d tp_core_mod.copy_corners 
!tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_corner fv_grid_utils_mod.great_circle_dist sw_core_m
!od.edge_interpolate4)):
!   gradient     of useful results: qin qout
!   with respect to varying inputs: qin qout
  SUBROUTINE A2B_ORD4_FWD(qin, qout, gridstruct, npx, npy, is, ie, js, &
&   je, ng, replace)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, is, ie, js, je, ng
! A-grid field
    REAL, INTENT(INOUT) :: qin(is-ng:ie+ng, js-ng:je+ng)
! Output  B-grid field
    REAL, INTENT(INOUT) :: qout(is-ng:ie+ng, js-ng:je+ng)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    LOGICAL, OPTIONAL, INTENT(IN) :: replace
! local: compact 4-pt cubic
    REAL, PARAMETER :: c1=2./3.
    REAL, PARAMETER :: c2=-(1./6.)
! Parabolic spline
! real, parameter:: c1 =  0.75
! real, parameter:: c2 = -0.25
    REAL :: qx(is:ie+1, js-ng:je+ng)
    REAL :: qy(is-ng:ie+ng, js:je+1)
    REAL :: qxx(is-ng:ie+ng, js-ng:je+ng)
    REAL :: qyy(is-ng:ie+ng, js-ng:je+ng)
    REAL :: g_in, g_ou
    REAL :: p0(2)
    REAL :: q1(is-1:ie+1), q2(js-1:je+1)
    INTEGER :: i, j, is1, js1, is2, js2, ie1, je1
    REAL, DIMENSION(:, :, :), POINTER :: grid, agrid
    REAL, DIMENSION(:, :), POINTER :: dxa, dya
    REAL(kind=r_grid), DIMENSION(:), POINTER :: edge_w, edge_e, edge_s, &
&   edge_n
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC PRESENT
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: max5
    INTEGER :: max6
    INTEGER :: max7
    INTEGER :: max8
    INTEGER :: max9
    INTEGER :: max10
    INTEGER :: max11
    INTEGER :: max12
    INTEGER :: max13
    INTEGER :: max14
    INTEGER :: max15
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    INTEGER :: min5
    INTEGER :: min6
    INTEGER :: min7
    INTEGER :: min8
    INTEGER :: min9
    INTEGER :: min10
    INTEGER :: min11
    INTEGER :: min12
    INTEGER :: min13
    INTEGER :: min14
    INTEGER :: min15
    REAL :: result1
    REAL :: result2
    REAL :: result3
    INTEGER :: ad_from
    INTEGER :: ad_from0
    INTEGER :: ad_from1
    INTEGER :: ad_from2
    INTEGER :: ad_from3
    INTERFACE 
        SUBROUTINE PUSHPOINTER8(pp)
          REAL, POINTER :: pp
        END SUBROUTINE PUSHPOINTER8
        SUBROUTINE LOOKPOINTER8(pp)
          REAL, POINTER :: pp
        END SUBROUTINE LOOKPOINTER8
        SUBROUTINE POPPOINTER8(pp)
          REAL, POINTER :: pp
        END SUBROUTINE POPPOINTER8
    END INTERFACE

    edge_w => gridstruct%edge_w
    edge_e => gridstruct%edge_e
    edge_s => gridstruct%edge_s
    edge_n => gridstruct%edge_n
    grid => gridstruct%grid
    dxa => gridstruct%dxa
    dya => gridstruct%dya
    IF (gridstruct%grid_type .LT. 3) THEN
      IF (1 .LT. is - 1) THEN
        is1 = is - 1
      ELSE
        is1 = 1
      END IF
      IF (1 .LT. js - 1) THEN
        js1 = js - 1
      ELSE
        js1 = 1
      END IF
      IF (2 .LT. is) THEN
        is2 = is
      ELSE
        is2 = 2
      END IF
      IF (2 .LT. js) THEN
        js2 = js
      ELSE
        js2 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        ie1 = ie + 1
      ELSE
        ie1 = npx - 1
      END IF
      IF (npy - 1 .GT. je + 1) THEN
        je1 = je + 1
      ELSE
        je1 = npy - 1
      END IF
! Corners:
! 3-way extrapolation
      IF (gridstruct%nested) THEN
        DO j=js-2,je+2
          DO i=is,ie+1
            qx(i, j) = b2*(qin(i-2, j)+qin(i+1, j)) + b1*(qin(i-1, j)+&
&             qin(i, j))
          END DO
        END DO
        CALL PUSHCONTROL2B(0)
      ELSE
        IF (gridstruct%sw_corner) THEN
          p0(1:2) = grid(1, 1, 1:2)
          result1 = EXTRAP_CORNER_FWD(p0, agrid(1, 1, 1:2), agrid(2, 2, &
&           1:2), qin(1, 1), qin(2, 2))
          result2 = EXTRAP_CORNER_FWD(p0, agrid(0, 1, 1:2), agrid(-1, 2&
&           , 1:2), qin(0, 1), qin(-1, 2))
          result3 = EXTRAP_CORNER_FWD(p0, agrid(1, 0, 1:2), agrid(2, -1&
&           , 1:2), qin(1, 0), qin(2, -1))
          CALL PUSHREAL8(qout(1, 1))
          qout(1, 1) = (result1+result2+result3)*r3
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (gridstruct%se_corner) THEN
          p0(1:2) = grid(npx, 1, 1:2)
          result1 = EXTRAP_CORNER_FWD(p0, agrid(npx-1, 1, 1:2), agrid(&
&           npx-2, 2, 1:2), qin(npx-1, 1), qin(npx-2, 2))
          result2 = EXTRAP_CORNER_FWD(p0, agrid(npx-1, 0, 1:2), agrid(&
&           npx-2, -1, 1:2), qin(npx-1, 0), qin(npx-2, -1))
          result3 = EXTRAP_CORNER_FWD(p0, agrid(npx, 1, 1:2), agrid(npx+&
&           1, 2, 1:2), qin(npx, 1), qin(npx+1, 2))
          CALL PUSHREAL8(qout(npx, 1))
          qout(npx, 1) = (result1+result2+result3)*r3
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (gridstruct%ne_corner) THEN
          p0(1:2) = grid(npx, npy, 1:2)
          result1 = EXTRAP_CORNER_FWD(p0, agrid(npx-1, npy-1, 1:2), &
&           agrid(npx-2, npy-2, 1:2), qin(npx-1, npy-1), qin(npx-2, npy-&
&           2))
          result2 = EXTRAP_CORNER_FWD(p0, agrid(npx, npy-1, 1:2), agrid(&
&           npx+1, npy-2, 1:2), qin(npx, npy-1), qin(npx+1, npy-2))
          result3 = EXTRAP_CORNER_FWD(p0, agrid(npx-1, npy, 1:2), agrid(&
&           npx-2, npy+1, 1:2), qin(npx-1, npy), qin(npx-2, npy+1))
          CALL PUSHREAL8(qout(npx, npy))
          qout(npx, npy) = (result1+result2+result3)*r3
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (gridstruct%nw_corner) THEN
          p0(1:2) = grid(1, npy, 1:2)
          result1 = EXTRAP_CORNER_FWD(p0, agrid(1, npy-1, 1:2), agrid(2&
&           , npy-2, 1:2), qin(1, npy-1), qin(2, npy-2))
          result2 = EXTRAP_CORNER_FWD(p0, agrid(0, npy-1, 1:2), agrid(-1&
&           , npy-2, 1:2), qin(0, npy-1), qin(-1, npy-2))
          result3 = EXTRAP_CORNER_FWD(p0, agrid(1, npy, 1:2), agrid(2, &
&           npy+1, 1:2), qin(1, npy), qin(2, npy+1))
          CALL PUSHREAL8(qout(1, npy))
          qout(1, npy) = (result1+result2+result3)*r3
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        IF (1 .LT. js - 2) THEN
          max1 = js - 2
        ELSE
          max1 = 1
        END IF
        IF (npy - 1 .GT. je + 2) THEN
          min1 = je + 2
        ELSE
          min1 = npy - 1
        END IF
!------------
! X-Interior:
!------------
        DO j=max1,min1
          IF (3 .LT. is) THEN
            max2 = is
          ELSE
            max2 = 3
          END IF
          IF (npx - 2 .GT. ie + 1) THEN
            min2 = ie + 1
          ELSE
            min2 = npx - 2
          END IF
          ad_from = max2
          DO i=ad_from,min2
            qx(i, j) = b2*(qin(i-2, j)+qin(i+1, j)) + b1*(qin(i-1, j)+&
&             qin(i, j))
          END DO
          CALL PUSHINTEGER4(i - 1)
          CALL PUSHINTEGER4(ad_from)
        END DO
! *** West Edges:
        IF (is .EQ. 1) THEN
          DO j=js1,je1
            q2(j) = (qin(0, j)*dxa(1, j)+qin(1, j)*dxa(0, j))/(dxa(0, j)&
&             +dxa(1, j))
          END DO
          DO j=js2,je1
            CALL PUSHREAL8(qout(1, j))
            qout(1, j) = edge_w(j)*q2(j-1) + (1.-edge_w(j))*q2(j)
          END DO
          IF (1 .LT. js - 2) THEN
            max3 = js - 2
          ELSE
            max3 = 1
          END IF
          IF (npy - 1 .GT. je + 2) THEN
            min3 = je + 2
          ELSE
            min3 = npy - 1
          END IF
!
          DO j=max3,min3
            g_in = dxa(2, j)/dxa(1, j)
            g_ou = dxa(-1, j)/dxa(0, j)
            qx(1, j) = 0.5*(((2.+g_in)*qin(1, j)-qin(2, j))/(1.+g_in)+((&
&             2.+g_ou)*qin(0, j)-qin(-1, j))/(1.+g_ou))
            qx(2, j) = (3.*(g_in*qin(1, j)+qin(2, j))-(g_in*qx(1, j)+qx(&
&             3, j)))/(2.+2.*g_in)
          END DO
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
! East Edges:
        IF (ie + 1 .EQ. npx) THEN
          DO j=js1,je1
            q2(j) = (qin(npx-1, j)*dxa(npx, j)+qin(npx, j)*dxa(npx-1, j)&
&             )/(dxa(npx-1, j)+dxa(npx, j))
          END DO
          DO j=js2,je1
            CALL PUSHREAL8(qout(npx, j))
            qout(npx, j) = edge_e(j)*q2(j-1) + (1.-edge_e(j))*q2(j)
          END DO
          IF (1 .LT. js - 2) THEN
            max4 = js - 2
          ELSE
            max4 = 1
          END IF
          IF (npy - 1 .GT. je + 2) THEN
            min4 = je + 2
          ELSE
            min4 = npy - 1
          END IF
!
          DO j=max4,min4
            g_in = dxa(npx-2, j)/dxa(npx-1, j)
            g_ou = dxa(npx+1, j)/dxa(npx, j)
            qx(npx, j) = 0.5*(((2.+g_in)*qin(npx-1, j)-qin(npx-2, j))/(&
&             1.+g_in)+((2.+g_ou)*qin(npx, j)-qin(npx+1, j))/(1.+g_ou))
            qx(npx-1, j) = (3.*(qin(npx-2, j)+g_in*qin(npx-1, j))-(g_in*&
&             qx(npx, j)+qx(npx-2, j)))/(2.+2.*g_in)
          END DO
          CALL PUSHCONTROL2B(1)
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
      END IF
!------------
! Y-Interior:
!------------
      IF (gridstruct%nested) THEN
        DO j=js,je+1
          DO i=is-2,ie+2
            qy(i, j) = b2*(qin(i, j-2)+qin(i, j+1)) + b1*(qin(i, j-1)+&
&             qin(i, j))
          END DO
        END DO
        CALL PUSHCONTROL2B(0)
      ELSE
        IF (3 .LT. js) THEN
          max5 = js
        ELSE
          max5 = 3
        END IF
        IF (npy - 2 .GT. je + 1) THEN
          min5 = je + 1
        ELSE
          min5 = npy - 2
        END IF
        DO j=max5,min5
          IF (1 .LT. is - 2) THEN
            max6 = is - 2
          ELSE
            max6 = 1
          END IF
          IF (npx - 1 .GT. ie + 2) THEN
            min6 = ie + 2
          ELSE
            min6 = npx - 1
          END IF
          ad_from0 = max6
          DO i=ad_from0,min6
            qy(i, j) = b2*(qin(i, j-2)+qin(i, j+1)) + b1*(qin(i, j-1)+&
&             qin(i, j))
          END DO
          CALL PUSHINTEGER4(i - 1)
          CALL PUSHINTEGER4(ad_from0)
        END DO
! South Edges:
        IF (js .EQ. 1) THEN
          DO i=is1,ie1
            q1(i) = (qin(i, 0)*dya(i, 1)+qin(i, 1)*dya(i, 0))/(dya(i, 0)&
&             +dya(i, 1))
          END DO
          DO i=is2,ie1
            CALL PUSHREAL8(qout(i, 1))
            qout(i, 1) = edge_s(i)*q1(i-1) + (1.-edge_s(i))*q1(i)
          END DO
          IF (1 .LT. is - 2) THEN
            max7 = is - 2
          ELSE
            max7 = 1
          END IF
          IF (npx - 1 .GT. ie + 2) THEN
            min7 = ie + 2
          ELSE
            min7 = npx - 1
          END IF
!
          DO i=max7,min7
            g_in = dya(i, 2)/dya(i, 1)
            g_ou = dya(i, -1)/dya(i, 0)
            qy(i, 1) = 0.5*(((2.+g_in)*qin(i, 1)-qin(i, 2))/(1.+g_in)+((&
&             2.+g_ou)*qin(i, 0)-qin(i, -1))/(1.+g_ou))
            qy(i, 2) = (3.*(g_in*qin(i, 1)+qin(i, 2))-(g_in*qy(i, 1)+qy(&
&             i, 3)))/(2.+2.*g_in)
          END DO
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
! North Edges:
        IF (je + 1 .EQ. npy) THEN
          DO i=is1,ie1
            q1(i) = (qin(i, npy-1)*dya(i, npy)+qin(i, npy)*dya(i, npy-1)&
&             )/(dya(i, npy-1)+dya(i, npy))
          END DO
          DO i=is2,ie1
            CALL PUSHREAL8(qout(i, npy))
            qout(i, npy) = edge_n(i)*q1(i-1) + (1.-edge_n(i))*q1(i)
          END DO
          IF (1 .LT. is - 2) THEN
            max8 = is - 2
          ELSE
            max8 = 1
          END IF
          IF (npx - 1 .GT. ie + 2) THEN
            min8 = ie + 2
          ELSE
            min8 = npx - 1
          END IF
!
          DO i=max8,min8
            g_in = dya(i, npy-2)/dya(i, npy-1)
            g_ou = dya(i, npy+1)/dya(i, npy)
            qy(i, npy) = 0.5*(((2.+g_in)*qin(i, npy-1)-qin(i, npy-2))/(&
&             1.+g_in)+((2.+g_ou)*qin(i, npy)-qin(i, npy+1))/(1.+g_ou))
            qy(i, npy-1) = (3.*(qin(i, npy-2)+g_in*qin(i, npy-1))-(g_in*&
&             qy(i, npy)+qy(i, npy-2)))/(2.+2.*g_in)
          END DO
          CALL PUSHCONTROL2B(1)
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
      END IF
!--------------------------------------
      IF (gridstruct%nested) THEN
        DO j=js,je+1
          DO i=is,ie+1
            qxx(i, j) = a2*(qx(i, j-2)+qx(i, j+1)) + a1*(qx(i, j-1)+qx(i&
&             , j))
          END DO
        END DO
        DO j=js,je+1
          DO i=is,ie+1
            qyy(i, j) = a2*(qy(i-2, j)+qy(i+1, j)) + a1*(qy(i-1, j)+qy(i&
&             , j))
          END DO
          DO i=is,ie+1
! averaging
            CALL PUSHREAL8(qout(i, j))
            qout(i, j) = 0.5*(qxx(i, j)+qyy(i, j))
          END DO
        END DO
        CALL PUSHCONTROL2B(0)
      ELSE
        IF (3 .LT. js) THEN
          max9 = js
        ELSE
          max9 = 3
        END IF
        IF (npy - 2 .GT. je + 1) THEN
          min9 = je + 1
        ELSE
          min9 = npy - 2
        END IF
        DO j=max9,min9
          IF (2 .LT. is) THEN
            max10 = is
          ELSE
            max10 = 2
          END IF
          IF (npx - 1 .GT. ie + 1) THEN
            min10 = ie + 1
          ELSE
            min10 = npx - 1
          END IF
          ad_from1 = max10
          DO i=ad_from1,min10
            qxx(i, j) = a2*(qx(i, j-2)+qx(i, j+1)) + a1*(qx(i, j-1)+qx(i&
&             , j))
          END DO
          CALL PUSHINTEGER4(i - 1)
          CALL PUSHINTEGER4(ad_from1)
        END DO
        IF (js .EQ. 1) THEN
          IF (2 .LT. is) THEN
            max11 = is
          ELSE
            max11 = 2
          END IF
          IF (npx - 1 .GT. ie + 1) THEN
            min11 = ie + 1
          ELSE
            min11 = npx - 1
          END IF
          DO i=max11,min11
            qxx(i, 2) = c1*(qx(i, 1)+qx(i, 2)) + c2*(qout(i, 1)+qxx(i, 3&
&             ))
          END DO
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (je + 1 .EQ. npy) THEN
          IF (2 .LT. is) THEN
            max12 = is
          ELSE
            max12 = 2
          END IF
          IF (npx - 1 .GT. ie + 1) THEN
            min12 = ie + 1
          ELSE
            min12 = npx - 1
          END IF
          DO i=max12,min12
            qxx(i, npy-1) = c1*(qx(i, npy-2)+qx(i, npy-1)) + c2*(qout(i&
&             , npy)+qxx(i, npy-2))
          END DO
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        IF (2 .LT. js) THEN
          max13 = js
        ELSE
          max13 = 2
        END IF
        IF (npy - 1 .GT. je + 1) THEN
          min13 = je + 1
        ELSE
          min13 = npy - 1
        END IF
        DO j=max13,min13
          IF (3 .LT. is) THEN
            max14 = is
          ELSE
            max14 = 3
          END IF
          IF (npx - 2 .GT. ie + 1) THEN
            min14 = ie + 1
          ELSE
            min14 = npx - 2
          END IF
          ad_from2 = max14
          DO i=ad_from2,min14
            qyy(i, j) = a2*(qy(i-2, j)+qy(i+1, j)) + a1*(qy(i-1, j)+qy(i&
&             , j))
          END DO
          CALL PUSHINTEGER4(i - 1)
          CALL PUSHINTEGER4(ad_from2)
          IF (is .EQ. 1) THEN
            qyy(2, j) = c1*(qy(1, j)+qy(2, j)) + c2*(qout(1, j)+qyy(3, j&
&             ))
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (ie + 1 .EQ. npx) THEN
            qyy(npx-1, j) = c1*(qy(npx-2, j)+qy(npx-1, j)) + c2*(qout(&
&             npx, j)+qyy(npx-2, j))
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
          IF (2 .LT. is) THEN
            max15 = is
          ELSE
            max15 = 2
          END IF
          IF (npx - 1 .GT. ie + 1) THEN
            min15 = ie + 1
          ELSE
            min15 = npx - 1
          END IF
          ad_from3 = max15
          DO i=ad_from3,min15
! averaging
            CALL PUSHREAL8(qout(i, j))
            qout(i, j) = 0.5*(qxx(i, j)+qyy(i, j))
          END DO
          CALL PUSHINTEGER4(i - 1)
          CALL PUSHINTEGER4(ad_from3)
        END DO
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
! grid_type>=3
!------------------------
! Doubly periodic domain:
!------------------------
! X-sweep: PPM
      DO j=js-2,je+2
        DO i=is,ie+1
          qx(i, j) = b1*(qin(i-1, j)+qin(i, j)) + b2*(qin(i-2, j)+qin(i+&
&           1, j))
        END DO
      END DO
! Y-sweep: PPM
      DO j=js,je+1
        DO i=is-2,ie+2
          qy(i, j) = b1*(qin(i, j-1)+qin(i, j)) + b2*(qin(i, j-2)+qin(i&
&           , j+1))
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie+1
          CALL PUSHREAL8(qout(i, j))
          qout(i, j) = 0.5*(a1*(qx(i, j-1)+qx(i, j)+qy(i-1, j)+qy(i, j))&
&           +a2*(qx(i, j-2)+qx(i, j+1)+qy(i-2, j)+qy(i+1, j)))
        END DO
      END DO
      CALL PUSHCONTROL2B(2)
    END IF
    IF (PRESENT(replace)) THEN
      IF (replace) THEN
        DO j=js,je+1
          DO i=is,ie+1
            CALL PUSHREAL8(qin(i, j))
            qin(i, j) = qout(i, j)
          END DO
        END DO
        CALL PUSHINTEGER4(max11)
        CALL PUSHINTEGER4(max12)
        CALL PUSHINTEGER4(max1)
        CALL PUSHINTEGER4(max13)
        CALL PUSHINTEGER4(max3)
        CALL PUSHINTEGER4(max4)
        CALL PUSHINTEGER4(max5)
        CALL PUSHINTEGER4(max7)
        CALL PUSHINTEGER4(max8)
        CALL PUSHINTEGER4(max9)
        !CALL PUSHPOINTER8(agrid)
        CALL PUSHINTEGER4(is1)
        CALL PUSHINTEGER4(is2)
        CALL PUSHINTEGER4(min11)
        CALL PUSHINTEGER4(min12)
        CALL PUSHINTEGER4(min13)
        CALL PUSHINTEGER4(je1)
        CALL PUSHINTEGER4(js1)
        CALL PUSHINTEGER4(js2)
        CALL PUSHINTEGER4(min1)
        CALL PUSHINTEGER4(min3)
        CALL PUSHINTEGER4(ie1)
        CALL PUSHINTEGER4(min4)
        CALL PUSHINTEGER4(min5)
        CALL PUSHINTEGER4(min7)
        CALL PUSHINTEGER4(min8)
        CALL PUSHINTEGER4(min9)
        CALL PUSHCONTROL2B(2)
      ELSE
        CALL PUSHINTEGER4(max11)
        CALL PUSHINTEGER4(max12)
        CALL PUSHINTEGER4(max1)
        CALL PUSHINTEGER4(max13)
        CALL PUSHINTEGER4(max3)
        CALL PUSHINTEGER4(max4)
        CALL PUSHINTEGER4(max5)
        CALL PUSHINTEGER4(max7)
        CALL PUSHINTEGER4(max8)
        CALL PUSHINTEGER4(max9)
        !CALL PUSHPOINTER8(agrid)
        CALL PUSHINTEGER4(is1)
        CALL PUSHINTEGER4(is2)
        CALL PUSHINTEGER4(min11)
        CALL PUSHINTEGER4(min12)
        CALL PUSHINTEGER4(min13)
        CALL PUSHINTEGER4(je1)
        CALL PUSHINTEGER4(js1)
        CALL PUSHINTEGER4(js2)
        CALL PUSHINTEGER4(min1)
        CALL PUSHINTEGER4(min3)
        CALL PUSHINTEGER4(ie1)
        CALL PUSHINTEGER4(min4)
        CALL PUSHINTEGER4(min5)
        CALL PUSHINTEGER4(min7)
        CALL PUSHINTEGER4(min8)
        CALL PUSHINTEGER4(min9)
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHINTEGER4(max11)
      CALL PUSHINTEGER4(max12)
      CALL PUSHINTEGER4(max1)
      CALL PUSHINTEGER4(max13)
      CALL PUSHINTEGER4(max3)
      CALL PUSHINTEGER4(max4)
      CALL PUSHINTEGER4(max5)
      CALL PUSHINTEGER4(max7)
      CALL PUSHINTEGER4(max8)
      CALL PUSHINTEGER4(max9)
      !CALL PUSHPOINTER8(agrid)
      CALL PUSHINTEGER4(is1)
      CALL PUSHINTEGER4(is2)
      CALL PUSHINTEGER4(min11)
      CALL PUSHINTEGER4(min12)
      CALL PUSHINTEGER4(min13)
      CALL PUSHINTEGER4(je1)
      CALL PUSHINTEGER4(js1)
      CALL PUSHINTEGER4(js2)
      CALL PUSHINTEGER4(min1)
      CALL PUSHINTEGER4(min3)
      CALL PUSHINTEGER4(ie1)
      CALL PUSHINTEGER4(min4)
      CALL PUSHINTEGER4(min5)
      CALL PUSHINTEGER4(min7)
      CALL PUSHINTEGER4(min8)
      CALL PUSHINTEGER4(min9)
      CALL PUSHCONTROL2B(0)
    END IF
  END SUBROUTINE A2B_ORD4_FWD
!  Differentiation of a2b_ord4 in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord4 a2b_edge_mo
!d.a2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_m
!od.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mod.mi
!x_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayleigh_
!Super fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_geos fv_g
!rid_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_mapz_m
!od.compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer
! fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_limiters fv_mapz_mod.
!ppm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.moist_cv fv_mapz_mod
!.moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer_2d fv_tracer2d_mod
!.tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.Riem_Solver_c nh_utils
!_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SIM3p0_solver nh_utils_m
!od.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nest_halo_nh sw_core_mod.
!c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.fill3
!_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v sw_core_mod.compute_divergenc
!e_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_core_mod.fv_tp_2d tp_core_mod.copy_corners
! tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_corner fv_grid_utils_mod.great_circle_dist sw_core_
!mod.edge_interpolate4)):
!   gradient     of useful results: qin qout
!   with respect to varying inputs: qin qout
  SUBROUTINE A2B_ORD4_BWD(qin, qin_ad, qout, qout_ad, gridstruct, npx, &
&   npy, is, ie, js, je, ng, replace)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, is, ie, js, je, ng
    REAL, INTENT(INOUT) :: qin(is-ng:ie+ng, js-ng:je+ng)
    REAL, INTENT(INOUT) :: qin_ad(is-ng:ie+ng, js-ng:je+ng)
    REAL, INTENT(INOUT) :: qout(is-ng:ie+ng, js-ng:je+ng)
    REAL, INTENT(INOUT) :: qout_ad(is-ng:ie+ng, js-ng:je+ng)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    LOGICAL, OPTIONAL, INTENT(IN) :: replace
    REAL, PARAMETER :: c1=2./3.
    REAL, PARAMETER :: c2=-(1./6.)
    REAL :: qx(is:ie+1, js-ng:je+ng)
    REAL :: qx_ad(is:ie+1, js-ng:je+ng)
    REAL :: qy(is-ng:ie+ng, js:je+1)
    REAL :: qy_ad(is-ng:ie+ng, js:je+1)
    REAL :: qxx(is-ng:ie+ng, js-ng:je+ng)
    REAL :: qxx_ad(is-ng:ie+ng, js-ng:je+ng)
    REAL :: qyy(is-ng:ie+ng, js-ng:je+ng)
    REAL :: qyy_ad(is-ng:ie+ng, js-ng:je+ng)
    REAL :: g_in, g_ou
    REAL :: p0(2)
    REAL :: q1(is-1:ie+1), q2(js-1:je+1)
    REAL :: q1_ad(is-1:ie+1), q2_ad(js-1:je+1)
    INTEGER :: i, j, is1, js1, is2, js2, ie1, je1
    REAL, DIMENSION(:, :, :), POINTER :: grid, agrid
    REAL, DIMENSION(:, :), POINTER :: dxa, dya
    REAL(kind=r_grid), DIMENSION(:), POINTER :: edge_w, edge_e, edge_s, &
&   edge_n
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC PRESENT
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: max5
    INTEGER :: max6
    INTEGER :: max7
    INTEGER :: max8
    INTEGER :: max9
    INTEGER :: max10
    INTEGER :: max11
    INTEGER :: max12
    INTEGER :: max13
    INTEGER :: max14
    INTEGER :: max15
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    INTEGER :: min5
    INTEGER :: min6
    INTEGER :: min7
    INTEGER :: min8
    INTEGER :: min9
    INTEGER :: min10
    INTEGER :: min11
    INTEGER :: min12
    INTEGER :: min13
    INTEGER :: min14
    INTEGER :: min15
    REAL :: result1
    REAL :: result1_ad
    REAL :: result2
    REAL :: result2_ad
    REAL :: result3
    REAL :: result3_ad
    REAL :: temp_ad
    REAL :: temp_ad0
    REAL :: temp_ad1
    REAL :: temp_ad2
    REAL :: temp_ad3
    REAL :: temp_ad4
    REAL :: temp_ad5
    REAL :: temp_ad6
    REAL :: temp_ad7
    REAL :: temp_ad8
    REAL :: temp_ad9
    REAL :: temp_ad10
    REAL :: temp_ad11
    REAL :: temp_ad12
    REAL :: temp_ad13
    REAL :: temp_ad14
    REAL :: temp_ad15
    REAL :: temp_ad16
    REAL :: temp_ad17
    REAL :: temp_ad18
    REAL :: temp_ad19
    REAL :: temp_ad20
    REAL :: temp_ad21
    REAL :: temp_ad22
    REAL :: temp_ad23
    REAL :: temp_ad24
    REAL :: temp_ad25
    INTEGER :: ad_from
    INTEGER :: ad_to
    INTEGER :: ad_from0
    INTEGER :: ad_to0
    INTEGER :: ad_from1
    INTEGER :: ad_to1
    INTEGER :: ad_from2
    INTEGER :: ad_to2
    INTEGER :: ad_from3
    INTEGER :: ad_to3
    INTEGER :: branch
    INTERFACE 
        SUBROUTINE PUSHPOINTER8(pp)
          REAL, POINTER :: pp
        END SUBROUTINE PUSHPOINTER8
        SUBROUTINE LOOKPOINTER8(pp)
          REAL, POINTER :: pp
        END SUBROUTINE LOOKPOINTER8
        SUBROUTINE POPPOINTER8(pp)
          REAL, POINTER :: pp
        END SUBROUTINE POPPOINTER8
    END INTERFACE

    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPINTEGER4(min9)
      CALL POPINTEGER4(min8)
      CALL POPINTEGER4(min7)
      CALL POPINTEGER4(min5)
      CALL POPINTEGER4(min4)
      CALL POPINTEGER4(ie1)
      CALL POPINTEGER4(min3)
      CALL POPINTEGER4(min1)
      CALL POPINTEGER4(js2)
      CALL POPINTEGER4(js1)
      CALL POPINTEGER4(je1)
      CALL POPINTEGER4(min13)
      CALL POPINTEGER4(min12)
      CALL POPINTEGER4(min11)
      CALL POPINTEGER4(is2)
      CALL POPINTEGER4(is1)
      agrid => gridstruct%agrid
      !CALL ADMM_REBASE(agrid)
      CALL POPINTEGER4(max9)
      CALL POPINTEGER4(max8)
      CALL POPINTEGER4(max7)
      CALL POPINTEGER4(max5)
      CALL POPINTEGER4(max4)
      CALL POPINTEGER4(max3)
      CALL POPINTEGER4(max13)
      CALL POPINTEGER4(max1)
      CALL POPINTEGER4(max12)
      CALL POPINTEGER4(max11)
    ELSE IF (branch .EQ. 1) THEN
      CALL POPINTEGER4(min9)
      CALL POPINTEGER4(min8)
      CALL POPINTEGER4(min7)
      CALL POPINTEGER4(min5)
      CALL POPINTEGER4(min4)
      CALL POPINTEGER4(ie1)
      CALL POPINTEGER4(min3)
      CALL POPINTEGER4(min1)
      CALL POPINTEGER4(js2)
      CALL POPINTEGER4(js1)
      CALL POPINTEGER4(je1)
      CALL POPINTEGER4(min13)
      CALL POPINTEGER4(min12)
      CALL POPINTEGER4(min11)
      CALL POPINTEGER4(is2)
      CALL POPINTEGER4(is1)
      agrid => gridstruct%agrid
      !CALL ADMM_REBASE(agrid)
      CALL POPINTEGER4(max9)
      CALL POPINTEGER4(max8)
      CALL POPINTEGER4(max7)
      CALL POPINTEGER4(max5)
      CALL POPINTEGER4(max4)
      CALL POPINTEGER4(max3)
      CALL POPINTEGER4(max13)
      CALL POPINTEGER4(max1)
      CALL POPINTEGER4(max12)
      CALL POPINTEGER4(max11)
    ELSE
      CALL POPINTEGER4(min9)
      CALL POPINTEGER4(min8)
      CALL POPINTEGER4(min7)
      CALL POPINTEGER4(min5)
      CALL POPINTEGER4(min4)
      CALL POPINTEGER4(ie1)
      CALL POPINTEGER4(min3)
      CALL POPINTEGER4(min1)
      CALL POPINTEGER4(js2)
      CALL POPINTEGER4(js1)
      CALL POPINTEGER4(je1)
      CALL POPINTEGER4(min13)
      CALL POPINTEGER4(min12)
      CALL POPINTEGER4(min11)
      CALL POPINTEGER4(is2)
      CALL POPINTEGER4(is1)
      agrid => gridstruct%agrid
      !CALL ADMM_REBASE(agrid)
      CALL POPINTEGER4(max9)
      CALL POPINTEGER4(max8)
      CALL POPINTEGER4(max7)
      CALL POPINTEGER4(max5)
      CALL POPINTEGER4(max4)
      CALL POPINTEGER4(max3)
      CALL POPINTEGER4(max13)
      CALL POPINTEGER4(max1)
      CALL POPINTEGER4(max12)
      CALL POPINTEGER4(max11)
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          CALL POPREAL8(qin(i, j))
          qout_ad(i, j) = qout_ad(i, j) + qin_ad(i, j)
          qin_ad(i, j) = 0.0_8
        END DO
      END DO
    END IF
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      qy_ad = 0.0_8
      qxx_ad = 0.0_8
      qyy_ad = 0.0_8
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          CALL POPREAL8(qout(i, j))
          qxx_ad(i, j) = qxx_ad(i, j) + 0.5*qout_ad(i, j)
          qyy_ad(i, j) = qyy_ad(i, j) + 0.5*qout_ad(i, j)
          qout_ad(i, j) = 0.0_8
        END DO
        DO i=ie+1,is,-1
          qy_ad(i-2, j) = qy_ad(i-2, j) + a2*qyy_ad(i, j)
          qy_ad(i+1, j) = qy_ad(i+1, j) + a2*qyy_ad(i, j)
          qy_ad(i-1, j) = qy_ad(i-1, j) + a1*qyy_ad(i, j)
          qy_ad(i, j) = qy_ad(i, j) + a1*qyy_ad(i, j)
          qyy_ad(i, j) = 0.0_8
        END DO
      END DO
      qx_ad = 0.0_8
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          qx_ad(i, j-2) = qx_ad(i, j-2) + a2*qxx_ad(i, j)
          qx_ad(i, j+1) = qx_ad(i, j+1) + a2*qxx_ad(i, j)
          qx_ad(i, j-1) = qx_ad(i, j-1) + a1*qxx_ad(i, j)
          qx_ad(i, j) = qx_ad(i, j) + a1*qxx_ad(i, j)
          qxx_ad(i, j) = 0.0_8
        END DO
      END DO
    ELSE IF (branch .EQ. 1) THEN
      qy_ad = 0.0_8
      qxx_ad = 0.0_8
      qyy_ad = 0.0_8
      DO j=min13,max13,-1
        CALL POPINTEGER4(ad_from3)
        CALL POPINTEGER4(ad_to3)
        DO i=ad_to3,ad_from3,-1
          CALL POPREAL8(qout(i, j))
          qxx_ad(i, j) = qxx_ad(i, j) + 0.5*qout_ad(i, j)
          qyy_ad(i, j) = qyy_ad(i, j) + 0.5*qout_ad(i, j)
          qout_ad(i, j) = 0.0_8
        END DO
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          qy_ad(npx-2, j) = qy_ad(npx-2, j) + c1*qyy_ad(npx-1, j)
          qy_ad(npx-1, j) = qy_ad(npx-1, j) + c1*qyy_ad(npx-1, j)
          qout_ad(npx, j) = qout_ad(npx, j) + c2*qyy_ad(npx-1, j)
          qyy_ad(npx-2, j) = qyy_ad(npx-2, j) + c2*qyy_ad(npx-1, j)
          qyy_ad(npx-1, j) = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          qy_ad(1, j) = qy_ad(1, j) + c1*qyy_ad(2, j)
          qy_ad(2, j) = qy_ad(2, j) + c1*qyy_ad(2, j)
          qout_ad(1, j) = qout_ad(1, j) + c2*qyy_ad(2, j)
          qyy_ad(3, j) = qyy_ad(3, j) + c2*qyy_ad(2, j)
          qyy_ad(2, j) = 0.0_8
        END IF
        CALL POPINTEGER4(ad_from2)
        CALL POPINTEGER4(ad_to2)
        DO i=ad_to2,ad_from2,-1
          qy_ad(i-2, j) = qy_ad(i-2, j) + a2*qyy_ad(i, j)
          qy_ad(i+1, j) = qy_ad(i+1, j) + a2*qyy_ad(i, j)
          qy_ad(i-1, j) = qy_ad(i-1, j) + a1*qyy_ad(i, j)
          qy_ad(i, j) = qy_ad(i, j) + a1*qyy_ad(i, j)
          qyy_ad(i, j) = 0.0_8
        END DO
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        qx_ad = 0.0_8
      ELSE
        qx_ad = 0.0_8
        DO i=min12,max12,-1
          qx_ad(i, npy-2) = qx_ad(i, npy-2) + c1*qxx_ad(i, npy-1)
          qx_ad(i, npy-1) = qx_ad(i, npy-1) + c1*qxx_ad(i, npy-1)
          qout_ad(i, npy) = qout_ad(i, npy) + c2*qxx_ad(i, npy-1)
          qxx_ad(i, npy-2) = qxx_ad(i, npy-2) + c2*qxx_ad(i, npy-1)
          qxx_ad(i, npy-1) = 0.0_8
        END DO
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO i=min11,max11,-1
          qx_ad(i, 1) = qx_ad(i, 1) + c1*qxx_ad(i, 2)
          qx_ad(i, 2) = qx_ad(i, 2) + c1*qxx_ad(i, 2)
          qout_ad(i, 1) = qout_ad(i, 1) + c2*qxx_ad(i, 2)
          qxx_ad(i, 3) = qxx_ad(i, 3) + c2*qxx_ad(i, 2)
          qxx_ad(i, 2) = 0.0_8
        END DO
      END IF
      DO j=min9,max9,-1
        CALL POPINTEGER4(ad_from1)
        CALL POPINTEGER4(ad_to1)
        DO i=ad_to1,ad_from1,-1
          qx_ad(i, j-2) = qx_ad(i, j-2) + a2*qxx_ad(i, j)
          qx_ad(i, j+1) = qx_ad(i, j+1) + a2*qxx_ad(i, j)
          qx_ad(i, j-1) = qx_ad(i, j-1) + a1*qxx_ad(i, j)
          qx_ad(i, j) = qx_ad(i, j) + a1*qxx_ad(i, j)
          qxx_ad(i, j) = 0.0_8
        END DO
      END DO
    ELSE
      qx_ad = 0.0_8
      qy_ad = 0.0_8
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          CALL POPREAL8(qout(i, j))
          temp_ad23 = 0.5*qout_ad(i, j)
          temp_ad24 = a1*temp_ad23
          temp_ad25 = a2*temp_ad23
          qx_ad(i, j-1) = qx_ad(i, j-1) + temp_ad24
          qx_ad(i, j) = qx_ad(i, j) + temp_ad24
          qy_ad(i-1, j) = qy_ad(i-1, j) + temp_ad24
          qy_ad(i, j) = qy_ad(i, j) + temp_ad24
          qx_ad(i, j-2) = qx_ad(i, j-2) + temp_ad25
          qx_ad(i, j+1) = qx_ad(i, j+1) + temp_ad25
          qy_ad(i-2, j) = qy_ad(i-2, j) + temp_ad25
          qy_ad(i+1, j) = qy_ad(i+1, j) + temp_ad25
          qout_ad(i, j) = 0.0_8
        END DO
      END DO
      DO j=je+1,js,-1
        DO i=ie+2,is-2,-1
          qin_ad(i, j-1) = qin_ad(i, j-1) + b1*qy_ad(i, j)
          qin_ad(i, j) = qin_ad(i, j) + b1*qy_ad(i, j)
          qin_ad(i, j-2) = qin_ad(i, j-2) + b2*qy_ad(i, j)
          qin_ad(i, j+1) = qin_ad(i, j+1) + b2*qy_ad(i, j)
          qy_ad(i, j) = 0.0_8
        END DO
      END DO
      DO j=je+2,js-2,-1
        DO i=ie+1,is,-1
          qin_ad(i-1, j) = qin_ad(i-1, j) + b1*qx_ad(i, j)
          qin_ad(i, j) = qin_ad(i, j) + b1*qx_ad(i, j)
          qin_ad(i-2, j) = qin_ad(i-2, j) + b2*qx_ad(i, j)
          qin_ad(i+1, j) = qin_ad(i+1, j) + b2*qx_ad(i, j)
          qx_ad(i, j) = 0.0_8
        END DO
      END DO
      GOTO 100
    END IF
    dya => gridstruct%dya
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      DO j=je+1,js,-1
        DO i=ie+2,is-2,-1
          qin_ad(i, j-2) = qin_ad(i, j-2) + b2*qy_ad(i, j)
          qin_ad(i, j+1) = qin_ad(i, j+1) + b2*qy_ad(i, j)
          qin_ad(i, j-1) = qin_ad(i, j-1) + b1*qy_ad(i, j)
          qin_ad(i, j) = qin_ad(i, j) + b1*qy_ad(i, j)
          qy_ad(i, j) = 0.0_8
        END DO
      END DO
    ELSE
      IF (branch .EQ. 1) THEN
        DO i=min8,max8,-1
          g_in = dya(i, npy-2)/dya(i, npy-1)
          temp_ad19 = qy_ad(i, npy-1)/(g_in*2.+2.)
          qin_ad(i, npy-2) = qin_ad(i, npy-2) + 3.*temp_ad19
          qy_ad(i, npy) = qy_ad(i, npy) - g_in*temp_ad19
          qy_ad(i, npy-2) = qy_ad(i, npy-2) - temp_ad19
          qy_ad(i, npy-1) = 0.0_8
          g_ou = dya(i, npy+1)/dya(i, npy)
          temp_ad21 = 0.5*qy_ad(i, npy)
          temp_ad20 = temp_ad21/(g_in+1.)
          qin_ad(i, npy-1) = qin_ad(i, npy-1) + (g_in+2.)*temp_ad20 + 3.&
&           *g_in*temp_ad19
          temp_ad22 = temp_ad21/(g_ou+1.)
          qin_ad(i, npy-2) = qin_ad(i, npy-2) - temp_ad20
          qin_ad(i, npy) = qin_ad(i, npy) + (g_ou+2.)*temp_ad22
          qin_ad(i, npy+1) = qin_ad(i, npy+1) - temp_ad22
          qy_ad(i, npy) = 0.0_8
        END DO
        edge_n => gridstruct%edge_n
        q1_ad = 0.0_8
        DO i=ie1,is2,-1
          CALL POPREAL8(qout(i, npy))
          q1_ad(i-1) = q1_ad(i-1) + edge_n(i)*qout_ad(i, npy)
          q1_ad(i) = q1_ad(i) + (1.-edge_n(i))*qout_ad(i, npy)
          qout_ad(i, npy) = 0.0_8
        END DO
        DO i=ie1,is1,-1
          temp_ad18 = q1_ad(i)/(dya(i, npy-1)+dya(i, npy))
          qin_ad(i, npy-1) = qin_ad(i, npy-1) + dya(i, npy)*temp_ad18
          qin_ad(i, npy) = qin_ad(i, npy) + dya(i, npy-1)*temp_ad18
          q1_ad(i) = 0.0_8
        END DO
      ELSE
        q1_ad = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO i=min7,max7,-1
          g_in = dya(i, 2)/dya(i, 1)
          temp_ad14 = qy_ad(i, 2)/(g_in*2.+2.)
          qin_ad(i, 1) = qin_ad(i, 1) + 3.*g_in*temp_ad14
          qin_ad(i, 2) = qin_ad(i, 2) + 3.*temp_ad14
          qy_ad(i, 1) = qy_ad(i, 1) - g_in*temp_ad14
          qy_ad(i, 3) = qy_ad(i, 3) - temp_ad14
          qy_ad(i, 2) = 0.0_8
          g_ou = dya(i, -1)/dya(i, 0)
          temp_ad15 = 0.5*qy_ad(i, 1)
          temp_ad16 = temp_ad15/(g_in+1.)
          temp_ad17 = temp_ad15/(g_ou+1.)
          qin_ad(i, 1) = qin_ad(i, 1) + (g_in+2.)*temp_ad16
          qin_ad(i, 2) = qin_ad(i, 2) - temp_ad16
          qin_ad(i, 0) = qin_ad(i, 0) + (g_ou+2.)*temp_ad17
          qin_ad(i, -1) = qin_ad(i, -1) - temp_ad17
          qy_ad(i, 1) = 0.0_8
        END DO
        edge_s => gridstruct%edge_s
        DO i=ie1,is2,-1
          CALL POPREAL8(qout(i, 1))
          q1_ad(i-1) = q1_ad(i-1) + edge_s(i)*qout_ad(i, 1)
          q1_ad(i) = q1_ad(i) + (1.-edge_s(i))*qout_ad(i, 1)
          qout_ad(i, 1) = 0.0_8
        END DO
        DO i=ie1,is1,-1
          temp_ad13 = q1_ad(i)/(dya(i, 0)+dya(i, 1))
          qin_ad(i, 0) = qin_ad(i, 0) + dya(i, 1)*temp_ad13
          qin_ad(i, 1) = qin_ad(i, 1) + dya(i, 0)*temp_ad13
          q1_ad(i) = 0.0_8
        END DO
      END IF
      DO j=min5,max5,-1
        CALL POPINTEGER4(ad_from0)
        CALL POPINTEGER4(ad_to0)
        DO i=ad_to0,ad_from0,-1
          qin_ad(i, j-2) = qin_ad(i, j-2) + b2*qy_ad(i, j)
          qin_ad(i, j+1) = qin_ad(i, j+1) + b2*qy_ad(i, j)
          qin_ad(i, j-1) = qin_ad(i, j-1) + b1*qy_ad(i, j)
          qin_ad(i, j) = qin_ad(i, j) + b1*qy_ad(i, j)
          qy_ad(i, j) = 0.0_8
        END DO
      END DO
    END IF
    dxa => gridstruct%dxa
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      DO j=je+2,js-2,-1
        DO i=ie+1,is,-1
          qin_ad(i-2, j) = qin_ad(i-2, j) + b2*qx_ad(i, j)
          qin_ad(i+1, j) = qin_ad(i+1, j) + b2*qx_ad(i, j)
          qin_ad(i-1, j) = qin_ad(i-1, j) + b1*qx_ad(i, j)
          qin_ad(i, j) = qin_ad(i, j) + b1*qx_ad(i, j)
          qx_ad(i, j) = 0.0_8
        END DO
      END DO
    ELSE
      IF (branch .EQ. 1) THEN
        DO j=min4,max4,-1
          g_in = dxa(npx-2, j)/dxa(npx-1, j)
          temp_ad9 = qx_ad(npx-1, j)/(g_in*2.+2.)
          qin_ad(npx-2, j) = qin_ad(npx-2, j) + 3.*temp_ad9
          qx_ad(npx, j) = qx_ad(npx, j) - g_in*temp_ad9
          qx_ad(npx-2, j) = qx_ad(npx-2, j) - temp_ad9
          qx_ad(npx-1, j) = 0.0_8
          g_ou = dxa(npx+1, j)/dxa(npx, j)
          temp_ad11 = 0.5*qx_ad(npx, j)
          temp_ad10 = temp_ad11/(g_in+1.)
          qin_ad(npx-1, j) = qin_ad(npx-1, j) + (g_in+2.)*temp_ad10 + 3.&
&           *g_in*temp_ad9
          temp_ad12 = temp_ad11/(g_ou+1.)
          qin_ad(npx-2, j) = qin_ad(npx-2, j) - temp_ad10
          qin_ad(npx, j) = qin_ad(npx, j) + (g_ou+2.)*temp_ad12
          qin_ad(npx+1, j) = qin_ad(npx+1, j) - temp_ad12
          qx_ad(npx, j) = 0.0_8
        END DO
        edge_e => gridstruct%edge_e
        q2_ad = 0.0_8
        DO j=je1,js2,-1
          CALL POPREAL8(qout(npx, j))
          q2_ad(j-1) = q2_ad(j-1) + edge_e(j)*qout_ad(npx, j)
          q2_ad(j) = q2_ad(j) + (1.-edge_e(j))*qout_ad(npx, j)
          qout_ad(npx, j) = 0.0_8
        END DO
        DO j=je1,js1,-1
          temp_ad8 = q2_ad(j)/(dxa(npx-1, j)+dxa(npx, j))
          qin_ad(npx-1, j) = qin_ad(npx-1, j) + dxa(npx, j)*temp_ad8
          qin_ad(npx, j) = qin_ad(npx, j) + dxa(npx-1, j)*temp_ad8
          q2_ad(j) = 0.0_8
        END DO
      ELSE
        q2_ad = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO j=min3,max3,-1
          g_in = dxa(2, j)/dxa(1, j)
          temp_ad4 = qx_ad(2, j)/(g_in*2.+2.)
          qin_ad(1, j) = qin_ad(1, j) + 3.*g_in*temp_ad4
          qin_ad(2, j) = qin_ad(2, j) + 3.*temp_ad4
          qx_ad(1, j) = qx_ad(1, j) - g_in*temp_ad4
          qx_ad(3, j) = qx_ad(3, j) - temp_ad4
          qx_ad(2, j) = 0.0_8
          g_ou = dxa(-1, j)/dxa(0, j)
          temp_ad5 = 0.5*qx_ad(1, j)
          temp_ad6 = temp_ad5/(g_in+1.)
          temp_ad7 = temp_ad5/(g_ou+1.)
          qin_ad(1, j) = qin_ad(1, j) + (g_in+2.)*temp_ad6
          qin_ad(2, j) = qin_ad(2, j) - temp_ad6
          qin_ad(0, j) = qin_ad(0, j) + (g_ou+2.)*temp_ad7
          qin_ad(-1, j) = qin_ad(-1, j) - temp_ad7
          qx_ad(1, j) = 0.0_8
        END DO
        edge_w => gridstruct%edge_w
        DO j=je1,js2,-1
          CALL POPREAL8(qout(1, j))
          q2_ad(j-1) = q2_ad(j-1) + edge_w(j)*qout_ad(1, j)
          q2_ad(j) = q2_ad(j) + (1.-edge_w(j))*qout_ad(1, j)
          qout_ad(1, j) = 0.0_8
        END DO
        DO j=je1,js1,-1
          temp_ad3 = q2_ad(j)/(dxa(0, j)+dxa(1, j))
          qin_ad(0, j) = qin_ad(0, j) + dxa(1, j)*temp_ad3
          qin_ad(1, j) = qin_ad(1, j) + dxa(0, j)*temp_ad3
          q2_ad(j) = 0.0_8
        END DO
      END IF
      DO j=min1,max1,-1
        CALL POPINTEGER4(ad_from)
        CALL POPINTEGER4(ad_to)
        DO i=ad_to,ad_from,-1
          qin_ad(i-2, j) = qin_ad(i-2, j) + b2*qx_ad(i, j)
          qin_ad(i+1, j) = qin_ad(i+1, j) + b2*qx_ad(i, j)
          qin_ad(i-1, j) = qin_ad(i-1, j) + b1*qx_ad(i, j)
          qin_ad(i, j) = qin_ad(i, j) + b1*qx_ad(i, j)
          qx_ad(i, j) = 0.0_8
        END DO
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        CALL POPREAL8(qout(1, npy))
        temp_ad2 = r3*qout_ad(1, npy)
        result1_ad = temp_ad2
        result2_ad = temp_ad2
        result3_ad = temp_ad2
        qout_ad(1, npy) = 0.0_8
        CALL EXTRAP_CORNER_BWD(p0, agrid(1, npy, 1:2), agrid(2, npy+1, 1&
&                        :2), qin(1, npy), qin_ad(1, npy), qin(2, npy+1)&
&                        , qin_ad(2, npy+1), result3_ad)
        CALL EXTRAP_CORNER_BWD(p0, agrid(0, npy-1, 1:2), agrid(-1, npy-2&
&                        , 1:2), qin(0, npy-1), qin_ad(0, npy-1), qin(-1&
&                        , npy-2), qin_ad(-1, npy-2), result2_ad)
        CALL EXTRAP_CORNER_BWD(p0, agrid(1, npy-1, 1:2), agrid(2, npy-2&
&                        , 1:2), qin(1, npy-1), qin_ad(1, npy-1), qin(2&
&                        , npy-2), qin_ad(2, npy-2), result1_ad)
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(qout(npx, npy))
        temp_ad1 = r3*qout_ad(npx, npy)
        result1_ad = temp_ad1
        result2_ad = temp_ad1
        result3_ad = temp_ad1
        qout_ad(npx, npy) = 0.0_8
        CALL EXTRAP_CORNER_BWD(p0, agrid(npx-1, npy, 1:2), agrid(npx-2, &
&                        npy+1, 1:2), qin(npx-1, npy), qin_ad(npx-1, npy&
&                        ), qin(npx-2, npy+1), qin_ad(npx-2, npy+1), &
&                        result3_ad)
        CALL EXTRAP_CORNER_BWD(p0, agrid(npx, npy-1, 1:2), agrid(npx+1, &
&                        npy-2, 1:2), qin(npx, npy-1), qin_ad(npx, npy-1&
&                        ), qin(npx+1, npy-2), qin_ad(npx+1, npy-2), &
&                        result2_ad)
        CALL EXTRAP_CORNER_BWD(p0, agrid(npx-1, npy-1, 1:2), agrid(npx-2&
&                        , npy-2, 1:2), qin(npx-1, npy-1), qin_ad(npx-1&
&                        , npy-1), qin(npx-2, npy-2), qin_ad(npx-2, npy-&
&                        2), result1_ad)
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(qout(npx, 1))
        temp_ad0 = r3*qout_ad(npx, 1)
        result1_ad = temp_ad0
        result2_ad = temp_ad0
        result3_ad = temp_ad0
        qout_ad(npx, 1) = 0.0_8
        CALL EXTRAP_CORNER_BWD(p0, agrid(npx, 1, 1:2), agrid(npx+1, 2, 1&
&                        :2), qin(npx, 1), qin_ad(npx, 1), qin(npx+1, 2)&
&                        , qin_ad(npx+1, 2), result3_ad)
        CALL EXTRAP_CORNER_BWD(p0, agrid(npx-1, 0, 1:2), agrid(npx-2, -1&
&                        , 1:2), qin(npx-1, 0), qin_ad(npx-1, 0), qin(&
&                        npx-2, -1), qin_ad(npx-2, -1), result2_ad)
        CALL EXTRAP_CORNER_BWD(p0, agrid(npx-1, 1, 1:2), agrid(npx-2, 2&
&                        , 1:2), qin(npx-1, 1), qin_ad(npx-1, 1), qin(&
&                        npx-2, 2), qin_ad(npx-2, 2), result1_ad)
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(qout(1, 1))
        temp_ad = r3*qout_ad(1, 1)
        result1_ad = temp_ad
        result2_ad = temp_ad
        result3_ad = temp_ad
        qout_ad(1, 1) = 0.0_8
        CALL EXTRAP_CORNER_BWD(p0, agrid(1, 0, 1:2), agrid(2, -1, 1:2), &
&                        qin(1, 0), qin_ad(1, 0), qin(2, -1), qin_ad(2, &
&                        -1), result3_ad)
        CALL EXTRAP_CORNER_BWD(p0, agrid(0, 1, 1:2), agrid(-1, 2, 1:2), &
&                        qin(0, 1), qin_ad(0, 1), qin(-1, 2), qin_ad(-1&
&                        , 2), result2_ad)
        CALL EXTRAP_CORNER_BWD(p0, agrid(1, 1, 1:2), agrid(2, 2, 1:2), &
&                        qin(1, 1), qin_ad(1, 1), qin(2, 2), qin_ad(2, 2&
&                        ), result1_ad)
      END IF
    END IF
 100 CONTINUE
  END SUBROUTINE A2B_ORD4_BWD
  SUBROUTINE A2B_ORD4(qin, qout, gridstruct, npx, npy, is, ie, js, je, &
&   ng, replace)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, is, ie, js, je, ng
! A-grid field
    REAL, INTENT(INOUT) :: qin(is-ng:ie+ng, js-ng:je+ng)
! Output  B-grid field
    REAL, INTENT(INOUT) :: qout(is-ng:ie+ng, js-ng:je+ng)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    LOGICAL, OPTIONAL, INTENT(IN) :: replace
! local: compact 4-pt cubic
    REAL, PARAMETER :: c1=2./3.
    REAL, PARAMETER :: c2=-(1./6.)
! Parabolic spline
! real, parameter:: c1 =  0.75
! real, parameter:: c2 = -0.25
    REAL :: qx(is:ie+1, js-ng:je+ng)
    REAL :: qy(is-ng:ie+ng, js:je+1)
    REAL :: qxx(is-ng:ie+ng, js-ng:je+ng)
    REAL :: qyy(is-ng:ie+ng, js-ng:je+ng)
    REAL :: g_in, g_ou
    REAL :: p0(2)
    REAL :: q1(is-1:ie+1), q2(js-1:je+1)
    INTEGER :: i, j, is1, js1, is2, js2, ie1, je1
    REAL, DIMENSION(:, :, :), POINTER :: grid, agrid
    REAL, DIMENSION(:, :), POINTER :: dxa, dya
    REAL(kind=r_grid), DIMENSION(:), POINTER :: edge_w, edge_e, edge_s, &
&   edge_n
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC PRESENT
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: max5
    INTEGER :: max6
    INTEGER :: max7
    INTEGER :: max8
    INTEGER :: max9
    INTEGER :: max10
    INTEGER :: max11
    INTEGER :: max12
    INTEGER :: max13
    INTEGER :: max14
    INTEGER :: max15
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    INTEGER :: min5
    INTEGER :: min6
    INTEGER :: min7
    INTEGER :: min8
    INTEGER :: min9
    INTEGER :: min10
    INTEGER :: min11
    INTEGER :: min12
    INTEGER :: min13
    INTEGER :: min14
    INTEGER :: min15
    REAL :: result1
    REAL :: result2
    REAL :: result3
    edge_w => gridstruct%edge_w
    edge_e => gridstruct%edge_e
    edge_s => gridstruct%edge_s
    edge_n => gridstruct%edge_n
    grid => gridstruct%grid
    agrid => gridstruct%agrid
    dxa => gridstruct%dxa
    dya => gridstruct%dya
    IF (gridstruct%grid_type .LT. 3) THEN
      IF (1 .LT. is - 1) THEN
        is1 = is - 1
      ELSE
        is1 = 1
      END IF
      IF (1 .LT. js - 1) THEN
        js1 = js - 1
      ELSE
        js1 = 1
      END IF
      IF (2 .LT. is) THEN
        is2 = is
      ELSE
        is2 = 2
      END IF
      IF (2 .LT. js) THEN
        js2 = js
      ELSE
        js2 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        ie1 = ie + 1
      ELSE
        ie1 = npx - 1
      END IF
      IF (npy - 1 .GT. je + 1) THEN
        je1 = je + 1
      ELSE
        je1 = npy - 1
      END IF
! Corners:
! 3-way extrapolation
      IF (gridstruct%nested) THEN
        DO j=js-2,je+2
          DO i=is,ie+1
            qx(i, j) = b2*(qin(i-2, j)+qin(i+1, j)) + b1*(qin(i-1, j)+&
&             qin(i, j))
          END DO
        END DO
      ELSE
        IF (gridstruct%sw_corner) THEN
          p0(1:2) = grid(1, 1, 1:2)
          result1 = EXTRAP_CORNER(p0, agrid(1, 1, 1:2), agrid(2, 2, 1:2)&
&           , qin(1, 1), qin(2, 2))
          result2 = EXTRAP_CORNER(p0, agrid(0, 1, 1:2), agrid(-1, 2, 1:2&
&           ), qin(0, 1), qin(-1, 2))
          result3 = EXTRAP_CORNER(p0, agrid(1, 0, 1:2), agrid(2, -1, 1:2&
&           ), qin(1, 0), qin(2, -1))
          qout(1, 1) = (result1+result2+result3)*r3
        END IF
        IF (gridstruct%se_corner) THEN
          p0(1:2) = grid(npx, 1, 1:2)
          result1 = EXTRAP_CORNER(p0, agrid(npx-1, 1, 1:2), agrid(npx-2&
&           , 2, 1:2), qin(npx-1, 1), qin(npx-2, 2))
          result2 = EXTRAP_CORNER(p0, agrid(npx-1, 0, 1:2), agrid(npx-2&
&           , -1, 1:2), qin(npx-1, 0), qin(npx-2, -1))
          result3 = EXTRAP_CORNER(p0, agrid(npx, 1, 1:2), agrid(npx+1, 2&
&           , 1:2), qin(npx, 1), qin(npx+1, 2))
          qout(npx, 1) = (result1+result2+result3)*r3
        END IF
        IF (gridstruct%ne_corner) THEN
          p0(1:2) = grid(npx, npy, 1:2)
          result1 = EXTRAP_CORNER(p0, agrid(npx-1, npy-1, 1:2), agrid(&
&           npx-2, npy-2, 1:2), qin(npx-1, npy-1), qin(npx-2, npy-2))
          result2 = EXTRAP_CORNER(p0, agrid(npx, npy-1, 1:2), agrid(npx+&
&           1, npy-2, 1:2), qin(npx, npy-1), qin(npx+1, npy-2))
          result3 = EXTRAP_CORNER(p0, agrid(npx-1, npy, 1:2), agrid(npx-&
&           2, npy+1, 1:2), qin(npx-1, npy), qin(npx-2, npy+1))
          qout(npx, npy) = (result1+result2+result3)*r3
        END IF
        IF (gridstruct%nw_corner) THEN
          p0(1:2) = grid(1, npy, 1:2)
          result1 = EXTRAP_CORNER(p0, agrid(1, npy-1, 1:2), agrid(2, npy&
&           -2, 1:2), qin(1, npy-1), qin(2, npy-2))
          result2 = EXTRAP_CORNER(p0, agrid(0, npy-1, 1:2), agrid(-1, &
&           npy-2, 1:2), qin(0, npy-1), qin(-1, npy-2))
          result3 = EXTRAP_CORNER(p0, agrid(1, npy, 1:2), agrid(2, npy+1&
&           , 1:2), qin(1, npy), qin(2, npy+1))
          qout(1, npy) = (result1+result2+result3)*r3
        END IF
        IF (1 .LT. js - 2) THEN
          max1 = js - 2
        ELSE
          max1 = 1
        END IF
        IF (npy - 1 .GT. je + 2) THEN
          min1 = je + 2
        ELSE
          min1 = npy - 1
        END IF
!------------
! X-Interior:
!------------
        DO j=max1,min1
          IF (3 .LT. is) THEN
            max2 = is
          ELSE
            max2 = 3
          END IF
          IF (npx - 2 .GT. ie + 1) THEN
            min2 = ie + 1
          ELSE
            min2 = npx - 2
          END IF
          DO i=max2,min2
            qx(i, j) = b2*(qin(i-2, j)+qin(i+1, j)) + b1*(qin(i-1, j)+&
&             qin(i, j))
          END DO
        END DO
! *** West Edges:
        IF (is .EQ. 1) THEN
          DO j=js1,je1
            q2(j) = (qin(0, j)*dxa(1, j)+qin(1, j)*dxa(0, j))/(dxa(0, j)&
&             +dxa(1, j))
          END DO
          DO j=js2,je1
            qout(1, j) = edge_w(j)*q2(j-1) + (1.-edge_w(j))*q2(j)
          END DO
          IF (1 .LT. js - 2) THEN
            max3 = js - 2
          ELSE
            max3 = 1
          END IF
          IF (npy - 1 .GT. je + 2) THEN
            min3 = je + 2
          ELSE
            min3 = npy - 1
          END IF
!
          DO j=max3,min3
            g_in = dxa(2, j)/dxa(1, j)
            g_ou = dxa(-1, j)/dxa(0, j)
            qx(1, j) = 0.5*(((2.+g_in)*qin(1, j)-qin(2, j))/(1.+g_in)+((&
&             2.+g_ou)*qin(0, j)-qin(-1, j))/(1.+g_ou))
            qx(2, j) = (3.*(g_in*qin(1, j)+qin(2, j))-(g_in*qx(1, j)+qx(&
&             3, j)))/(2.+2.*g_in)
          END DO
        END IF
! East Edges:
        IF (ie + 1 .EQ. npx) THEN
          DO j=js1,je1
            q2(j) = (qin(npx-1, j)*dxa(npx, j)+qin(npx, j)*dxa(npx-1, j)&
&             )/(dxa(npx-1, j)+dxa(npx, j))
          END DO
          DO j=js2,je1
            qout(npx, j) = edge_e(j)*q2(j-1) + (1.-edge_e(j))*q2(j)
          END DO
          IF (1 .LT. js - 2) THEN
            max4 = js - 2
          ELSE
            max4 = 1
          END IF
          IF (npy - 1 .GT. je + 2) THEN
            min4 = je + 2
          ELSE
            min4 = npy - 1
          END IF
!
          DO j=max4,min4
            g_in = dxa(npx-2, j)/dxa(npx-1, j)
            g_ou = dxa(npx+1, j)/dxa(npx, j)
            qx(npx, j) = 0.5*(((2.+g_in)*qin(npx-1, j)-qin(npx-2, j))/(&
&             1.+g_in)+((2.+g_ou)*qin(npx, j)-qin(npx+1, j))/(1.+g_ou))
            qx(npx-1, j) = (3.*(qin(npx-2, j)+g_in*qin(npx-1, j))-(g_in*&
&             qx(npx, j)+qx(npx-2, j)))/(2.+2.*g_in)
          END DO
        END IF
      END IF
!------------
! Y-Interior:
!------------
      IF (gridstruct%nested) THEN
        DO j=js,je+1
          DO i=is-2,ie+2
            qy(i, j) = b2*(qin(i, j-2)+qin(i, j+1)) + b1*(qin(i, j-1)+&
&             qin(i, j))
          END DO
        END DO
      ELSE
        IF (3 .LT. js) THEN
          max5 = js
        ELSE
          max5 = 3
        END IF
        IF (npy - 2 .GT. je + 1) THEN
          min5 = je + 1
        ELSE
          min5 = npy - 2
        END IF
        DO j=max5,min5
          IF (1 .LT. is - 2) THEN
            max6 = is - 2
          ELSE
            max6 = 1
          END IF
          IF (npx - 1 .GT. ie + 2) THEN
            min6 = ie + 2
          ELSE
            min6 = npx - 1
          END IF
          DO i=max6,min6
            qy(i, j) = b2*(qin(i, j-2)+qin(i, j+1)) + b1*(qin(i, j-1)+&
&             qin(i, j))
          END DO
        END DO
! South Edges:
        IF (js .EQ. 1) THEN
          DO i=is1,ie1
            q1(i) = (qin(i, 0)*dya(i, 1)+qin(i, 1)*dya(i, 0))/(dya(i, 0)&
&             +dya(i, 1))
          END DO
          DO i=is2,ie1
            qout(i, 1) = edge_s(i)*q1(i-1) + (1.-edge_s(i))*q1(i)
          END DO
          IF (1 .LT. is - 2) THEN
            max7 = is - 2
          ELSE
            max7 = 1
          END IF
          IF (npx - 1 .GT. ie + 2) THEN
            min7 = ie + 2
          ELSE
            min7 = npx - 1
          END IF
!
          DO i=max7,min7
            g_in = dya(i, 2)/dya(i, 1)
            g_ou = dya(i, -1)/dya(i, 0)
            qy(i, 1) = 0.5*(((2.+g_in)*qin(i, 1)-qin(i, 2))/(1.+g_in)+((&
&             2.+g_ou)*qin(i, 0)-qin(i, -1))/(1.+g_ou))
            qy(i, 2) = (3.*(g_in*qin(i, 1)+qin(i, 2))-(g_in*qy(i, 1)+qy(&
&             i, 3)))/(2.+2.*g_in)
          END DO
        END IF
! North Edges:
        IF (je + 1 .EQ. npy) THEN
          DO i=is1,ie1
            q1(i) = (qin(i, npy-1)*dya(i, npy)+qin(i, npy)*dya(i, npy-1)&
&             )/(dya(i, npy-1)+dya(i, npy))
          END DO
          DO i=is2,ie1
            qout(i, npy) = edge_n(i)*q1(i-1) + (1.-edge_n(i))*q1(i)
          END DO
          IF (1 .LT. is - 2) THEN
            max8 = is - 2
          ELSE
            max8 = 1
          END IF
          IF (npx - 1 .GT. ie + 2) THEN
            min8 = ie + 2
          ELSE
            min8 = npx - 1
          END IF
!
          DO i=max8,min8
            g_in = dya(i, npy-2)/dya(i, npy-1)
            g_ou = dya(i, npy+1)/dya(i, npy)
            qy(i, npy) = 0.5*(((2.+g_in)*qin(i, npy-1)-qin(i, npy-2))/(&
&             1.+g_in)+((2.+g_ou)*qin(i, npy)-qin(i, npy+1))/(1.+g_ou))
            qy(i, npy-1) = (3.*(qin(i, npy-2)+g_in*qin(i, npy-1))-(g_in*&
&             qy(i, npy)+qy(i, npy-2)))/(2.+2.*g_in)
          END DO
        END IF
      END IF
!--------------------------------------
      IF (gridstruct%nested) THEN
        DO j=js,je+1
          DO i=is,ie+1
            qxx(i, j) = a2*(qx(i, j-2)+qx(i, j+1)) + a1*(qx(i, j-1)+qx(i&
&             , j))
          END DO
        END DO
        DO j=js,je+1
          DO i=is,ie+1
            qyy(i, j) = a2*(qy(i-2, j)+qy(i+1, j)) + a1*(qy(i-1, j)+qy(i&
&             , j))
          END DO
          DO i=is,ie+1
! averaging
            qout(i, j) = 0.5*(qxx(i, j)+qyy(i, j))
          END DO
        END DO
      ELSE
        IF (3 .LT. js) THEN
          max9 = js
        ELSE
          max9 = 3
        END IF
        IF (npy - 2 .GT. je + 1) THEN
          min9 = je + 1
        ELSE
          min9 = npy - 2
        END IF
        DO j=max9,min9
          IF (2 .LT. is) THEN
            max10 = is
          ELSE
            max10 = 2
          END IF
          IF (npx - 1 .GT. ie + 1) THEN
            min10 = ie + 1
          ELSE
            min10 = npx - 1
          END IF
          DO i=max10,min10
            qxx(i, j) = a2*(qx(i, j-2)+qx(i, j+1)) + a1*(qx(i, j-1)+qx(i&
&             , j))
          END DO
        END DO
        IF (js .EQ. 1) THEN
          IF (2 .LT. is) THEN
            max11 = is
          ELSE
            max11 = 2
          END IF
          IF (npx - 1 .GT. ie + 1) THEN
            min11 = ie + 1
          ELSE
            min11 = npx - 1
          END IF
          DO i=max11,min11
            qxx(i, 2) = c1*(qx(i, 1)+qx(i, 2)) + c2*(qout(i, 1)+qxx(i, 3&
&             ))
          END DO
        END IF
        IF (je + 1 .EQ. npy) THEN
          IF (2 .LT. is) THEN
            max12 = is
          ELSE
            max12 = 2
          END IF
          IF (npx - 1 .GT. ie + 1) THEN
            min12 = ie + 1
          ELSE
            min12 = npx - 1
          END IF
          DO i=max12,min12
            qxx(i, npy-1) = c1*(qx(i, npy-2)+qx(i, npy-1)) + c2*(qout(i&
&             , npy)+qxx(i, npy-2))
          END DO
        END IF
        IF (2 .LT. js) THEN
          max13 = js
        ELSE
          max13 = 2
        END IF
        IF (npy - 1 .GT. je + 1) THEN
          min13 = je + 1
        ELSE
          min13 = npy - 1
        END IF
        DO j=max13,min13
          IF (3 .LT. is) THEN
            max14 = is
          ELSE
            max14 = 3
          END IF
          IF (npx - 2 .GT. ie + 1) THEN
            min14 = ie + 1
          ELSE
            min14 = npx - 2
          END IF
          DO i=max14,min14
            qyy(i, j) = a2*(qy(i-2, j)+qy(i+1, j)) + a1*(qy(i-1, j)+qy(i&
&             , j))
          END DO
          IF (is .EQ. 1) qyy(2, j) = c1*(qy(1, j)+qy(2, j)) + c2*(qout(1&
&             , j)+qyy(3, j))
          IF (ie + 1 .EQ. npx) qyy(npx-1, j) = c1*(qy(npx-2, j)+qy(npx-1&
&             , j)) + c2*(qout(npx, j)+qyy(npx-2, j))
          IF (2 .LT. is) THEN
            max15 = is
          ELSE
            max15 = 2
          END IF
          IF (npx - 1 .GT. ie + 1) THEN
            min15 = ie + 1
          ELSE
            min15 = npx - 1
          END IF
          DO i=max15,min15
! averaging
            qout(i, j) = 0.5*(qxx(i, j)+qyy(i, j))
          END DO
        END DO
      END IF
    ELSE
! grid_type>=3
!------------------------
! Doubly periodic domain:
!------------------------
! X-sweep: PPM
      DO j=js-2,je+2
        DO i=is,ie+1
          qx(i, j) = b1*(qin(i-1, j)+qin(i, j)) + b2*(qin(i-2, j)+qin(i+&
&           1, j))
        END DO
      END DO
! Y-sweep: PPM
      DO j=js,je+1
        DO i=is-2,ie+2
          qy(i, j) = b1*(qin(i, j-1)+qin(i, j)) + b2*(qin(i, j-2)+qin(i&
&           , j+1))
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie+1
          qout(i, j) = 0.5*(a1*(qx(i, j-1)+qx(i, j)+qy(i-1, j)+qy(i, j))&
&           +a2*(qx(i, j-2)+qx(i, j+1)+qy(i-2, j)+qy(i+1, j)))
        END DO
      END DO
    END IF
    IF (PRESENT(replace)) THEN
      IF (replace) THEN
        DO j=js,je+1
          DO i=is,ie+1
            qin(i, j) = qout(i, j)
          END DO
        END DO
      END IF
    END IF
  END SUBROUTINE A2B_ORD4
!  Differentiation of a2b_ord2 in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord4 a2b_edge_mod
!.a2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_mo
!d.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mod.mix
!_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayleigh_S
!uper fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_geos fv_gr
!id_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_mapz_mo
!d.compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer 
!fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_limiters fv_mapz_mod.p
!pm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.moist_cv fv_mapz_mod.
!moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.
!tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.Riem_Solver_c nh_utils_
!mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SIM3p0_solver nh_utils_mo
!d.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nest_halo_nh sw_core_mod.c
!_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.fill3_
!4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v sw_core_mod.compute_divergence
!_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_core_mod.fv_tp_2d tp_core_mod.copy_corners 
!tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_corner fv_grid_utils_mod.great_circle_dist sw_core_m
!od.edge_interpolate4)):
!   gradient     of useful results: qin qout
!   with respect to varying inputs: qin qout
  SUBROUTINE A2B_ORD2_FWD(qin, qout, gridstruct, npx, npy, is, ie, js, &
&   je, ng, replace)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, is, ie, js, je, ng
! A-grid field
    REAL, INTENT(INOUT) :: qin(is-ng:ie+ng, js-ng:je+ng)
! Output  B-grid field
    REAL :: qout(is-ng:ie+ng, js-ng:je+ng)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    LOGICAL, OPTIONAL, INTENT(IN) :: replace
! local:
    REAL :: q1(npx), q2(npy)
    INTEGER :: i, j
    INTEGER :: is1, js1, is2, js2, ie1, je1
    REAL, DIMENSION(:, :, :), POINTER :: grid, agrid
    REAL, DIMENSION(:, :), POINTER :: dxa, dya
    REAL(kind=r_grid), DIMENSION(:), POINTER :: edge_w, edge_e, edge_s, &
&   edge_n
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC PRESENT
    edge_w => gridstruct%edge_w
    edge_e => gridstruct%edge_e
    edge_s => gridstruct%edge_s
    edge_n => gridstruct%edge_n
    IF (gridstruct%grid_type .LT. 3) THEN
      IF (gridstruct%nested) THEN
        DO j=js-2,je+1+2
          DO i=is-2,ie+1+2
            CALL PUSHREAL8(qout(i, j))
            qout(i, j) = 0.25*(qin(i-1, j-1)+qin(i, j-1)+qin(i-1, j)+qin&
&             (i, j))
          END DO
        END DO
        CALL PUSHCONTROL2B(0)
      ELSE
        IF (1 .LT. is - 1) THEN
          is1 = is - 1
        ELSE
          is1 = 1
        END IF
        IF (1 .LT. js - 1) THEN
          js1 = js - 1
        ELSE
          js1 = 1
        END IF
        IF (2 .LT. is) THEN
          is2 = is
        ELSE
          is2 = 2
        END IF
        IF (2 .LT. js) THEN
          js2 = js
        ELSE
          js2 = 2
        END IF
        IF (npx - 1 .GT. ie + 1) THEN
          ie1 = ie + 1
        ELSE
          ie1 = npx - 1
        END IF
        IF (npy - 1 .GT. je + 1) THEN
          je1 = je + 1
        ELSE
          je1 = npy - 1
        END IF
        DO j=js2,je1
          DO i=is2,ie1
            CALL PUSHREAL8(qout(i, j))
            qout(i, j) = 0.25*(qin(i-1, j-1)+qin(i, j-1)+qin(i-1, j)+qin&
&             (i, j))
          END DO
        END DO
! Fix the 4 Corners:
        IF (gridstruct%sw_corner) THEN
          CALL PUSHREAL8(qout(1, 1))
          qout(1, 1) = r3*(qin(1, 1)+qin(1, 0)+qin(0, 1))
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (gridstruct%se_corner) THEN
          CALL PUSHREAL8(qout(npx, 1))
          qout(npx, 1) = r3*(qin(npx-1, 1)+qin(npx-1, 0)+qin(npx, 1))
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (gridstruct%ne_corner) THEN
          CALL PUSHREAL8(qout(npx, npy))
          qout(npx, npy) = r3*(qin(npx-1, npy-1)+qin(npx, npy-1)+qin(npx&
&           -1, npy))
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (gridstruct%nw_corner) THEN
          CALL PUSHREAL8(qout(1, npy))
          qout(1, npy) = r3*(qin(1, npy-1)+qin(0, npy-1)+qin(1, npy))
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
! *** West Edges:
        IF (is .EQ. 1) THEN
          DO j=js1,je1
            q2(j) = 0.5*(qin(0, j)+qin(1, j))
          END DO
          DO j=js2,je1
            CALL PUSHREAL8(qout(1, j))
            qout(1, j) = edge_w(j)*q2(j-1) + (1.-edge_w(j))*q2(j)
          END DO
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
! East Edges:
        IF (ie + 1 .EQ. npx) THEN
          DO j=js1,je1
            q2(j) = 0.5*(qin(npx-1, j)+qin(npx, j))
          END DO
          DO j=js2,je1
            CALL PUSHREAL8(qout(npx, j))
            qout(npx, j) = edge_e(j)*q2(j-1) + (1.-edge_e(j))*q2(j)
          END DO
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
! South Edges:
        IF (js .EQ. 1) THEN
          DO i=is1,ie1
            q1(i) = 0.5*(qin(i, 0)+qin(i, 1))
          END DO
          DO i=is2,ie1
            CALL PUSHREAL8(qout(i, 1))
            qout(i, 1) = edge_s(i)*q1(i-1) + (1.-edge_s(i))*q1(i)
          END DO
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
! North Edges:
        IF (je + 1 .EQ. npy) THEN
          DO i=is1,ie1
            q1(i) = 0.5*(qin(i, npy-1)+qin(i, npy))
          END DO
          DO i=is2,ie1
            CALL PUSHREAL8(qout(i, npy))
            qout(i, npy) = edge_n(i)*q1(i-1) + (1.-edge_n(i))*q1(i)
          END DO
          CALL PUSHCONTROL2B(1)
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
      END IF
    ELSE
      DO j=js,je+1
        DO i=is,ie+1
          CALL PUSHREAL8(qout(i, j))
          qout(i, j) = 0.25*(qin(i-1, j-1)+qin(i, j-1)+qin(i-1, j)+qin(i&
&           , j))
        END DO
      END DO
      CALL PUSHCONTROL2B(3)
    END IF
    IF (PRESENT(replace)) THEN
      IF (replace) THEN
        DO j=js,je+1
          DO i=is,ie+1
            CALL PUSHREAL8(qin(i, j))
            qin(i, j) = qout(i, j)
          END DO
        END DO
        CALL PUSHINTEGER4(is1)
        CALL PUSHINTEGER4(is2)
        CALL PUSHINTEGER4(je1)
        CALL PUSHINTEGER4(js1)
        CALL PUSHINTEGER4(js2)
        CALL PUSHINTEGER4(ie1)
        CALL PUSHCONTROL2B(2)
      ELSE
        CALL PUSHINTEGER4(is1)
        CALL PUSHINTEGER4(is2)
        CALL PUSHINTEGER4(je1)
        CALL PUSHINTEGER4(js1)
        CALL PUSHINTEGER4(js2)
        CALL PUSHINTEGER4(ie1)
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHINTEGER4(is1)
      CALL PUSHINTEGER4(is2)
      CALL PUSHINTEGER4(je1)
      CALL PUSHINTEGER4(js1)
      CALL PUSHINTEGER4(js2)
      CALL PUSHINTEGER4(ie1)
      CALL PUSHCONTROL2B(0)
    END IF
  END SUBROUTINE A2B_ORD2_FWD
!  Differentiation of a2b_ord2 in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord4 a2b_edge_mo
!d.a2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_m
!od.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mod.mi
!x_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayleigh_
!Super fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_geos fv_g
!rid_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_mapz_m
!od.compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer
! fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_limiters fv_mapz_mod.
!ppm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.moist_cv fv_mapz_mod
!.moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer_2d fv_tracer2d_mod
!.tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.Riem_Solver_c nh_utils
!_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SIM3p0_solver nh_utils_m
!od.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nest_halo_nh sw_core_mod.
!c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.fill3
!_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v sw_core_mod.compute_divergenc
!e_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_core_mod.fv_tp_2d tp_core_mod.copy_corners
! tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_corner fv_grid_utils_mod.great_circle_dist sw_core_
!mod.edge_interpolate4)):
!   gradient     of useful results: qin qout
!   with respect to varying inputs: qin qout
  SUBROUTINE A2B_ORD2_BWD(qin, qin_ad, qout, qout_ad, gridstruct, npx, &
&   npy, is, ie, js, je, ng, replace)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, is, ie, js, je, ng
    REAL, INTENT(INOUT) :: qin(is-ng:ie+ng, js-ng:je+ng)
    REAL, INTENT(INOUT) :: qin_ad(is-ng:ie+ng, js-ng:je+ng)
    REAL :: qout(is-ng:ie+ng, js-ng:je+ng)
    REAL :: qout_ad(is-ng:ie+ng, js-ng:je+ng)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    LOGICAL, OPTIONAL, INTENT(IN) :: replace
    REAL :: q1(npx), q2(npy)
    REAL :: q1_ad(npx), q2_ad(npy)
    INTEGER :: i, j
    INTEGER :: is1, js1, is2, js2, ie1, je1
    REAL, DIMENSION(:, :, :), POINTER :: grid, agrid
    REAL, DIMENSION(:, :), POINTER :: dxa, dya
    REAL(kind=r_grid), DIMENSION(:), POINTER :: edge_w, edge_e, edge_s, &
&   edge_n
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC PRESENT
    REAL :: temp_ad
    REAL :: temp_ad0
    REAL :: temp_ad1
    REAL :: temp_ad2
    REAL :: temp_ad3
    REAL :: temp_ad4
    REAL :: temp_ad5
    INTEGER :: branch
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPINTEGER4(ie1)
      CALL POPINTEGER4(js2)
      CALL POPINTEGER4(js1)
      CALL POPINTEGER4(je1)
      CALL POPINTEGER4(is2)
      CALL POPINTEGER4(is1)
    ELSE IF (branch .EQ. 1) THEN
      CALL POPINTEGER4(ie1)
      CALL POPINTEGER4(js2)
      CALL POPINTEGER4(js1)
      CALL POPINTEGER4(je1)
      CALL POPINTEGER4(is2)
      CALL POPINTEGER4(is1)
    ELSE
      CALL POPINTEGER4(ie1)
      CALL POPINTEGER4(js2)
      CALL POPINTEGER4(js1)
      CALL POPINTEGER4(je1)
      CALL POPINTEGER4(is2)
      CALL POPINTEGER4(is1)
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          CALL POPREAL8(qin(i, j))
          qout_ad(i, j) = qout_ad(i, j) + qin_ad(i, j)
          qin_ad(i, j) = 0.0_8
        END DO
      END DO
    END IF
    edge_n => gridstruct%edge_n
    CALL POPCONTROL2B(branch)
    IF (branch .LT. 2) THEN
      IF (branch .EQ. 0) THEN
        DO j=je+3,js-2,-1
          DO i=ie+3,is-2,-1
            CALL POPREAL8(qout(i, j))
            temp_ad = 0.25*qout_ad(i, j)
            qin_ad(i-1, j-1) = qin_ad(i-1, j-1) + temp_ad
            qin_ad(i, j-1) = qin_ad(i, j-1) + temp_ad
            qin_ad(i-1, j) = qin_ad(i-1, j) + temp_ad
            qin_ad(i, j) = qin_ad(i, j) + temp_ad
            qout_ad(i, j) = 0.0_8
          END DO
        END DO
        GOTO 100
      ELSE
        q1_ad = 0.0_8
        DO i=ie1,is2,-1
          CALL POPREAL8(qout(i, npy))
          q1_ad(i-1) = q1_ad(i-1) + edge_n(i)*qout_ad(i, npy)
          q1_ad(i) = q1_ad(i) + (1.-edge_n(i))*qout_ad(i, npy)
          qout_ad(i, npy) = 0.0_8
        END DO
        DO i=ie1,is1,-1
          qin_ad(i, npy-1) = qin_ad(i, npy-1) + 0.5*q1_ad(i)
          qin_ad(i, npy) = qin_ad(i, npy) + 0.5*q1_ad(i)
          q1_ad(i) = 0.0_8
        END DO
      END IF
    ELSE IF (branch .EQ. 2) THEN
      q1_ad = 0.0_8
    ELSE
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          CALL POPREAL8(qout(i, j))
          temp_ad5 = 0.25*qout_ad(i, j)
          qin_ad(i-1, j-1) = qin_ad(i-1, j-1) + temp_ad5
          qin_ad(i, j-1) = qin_ad(i, j-1) + temp_ad5
          qin_ad(i-1, j) = qin_ad(i-1, j) + temp_ad5
          qin_ad(i, j) = qin_ad(i, j) + temp_ad5
          qout_ad(i, j) = 0.0_8
        END DO
      END DO
      GOTO 100
    END IF
    edge_s => gridstruct%edge_s
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO i=ie1,is2,-1
        CALL POPREAL8(qout(i, 1))
        q1_ad(i-1) = q1_ad(i-1) + edge_s(i)*qout_ad(i, 1)
        q1_ad(i) = q1_ad(i) + (1.-edge_s(i))*qout_ad(i, 1)
        qout_ad(i, 1) = 0.0_8
      END DO
      DO i=ie1,is1,-1
        qin_ad(i, 0) = qin_ad(i, 0) + 0.5*q1_ad(i)
        qin_ad(i, 1) = qin_ad(i, 1) + 0.5*q1_ad(i)
        q1_ad(i) = 0.0_8
      END DO
    END IF
    edge_e => gridstruct%edge_e
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      q2_ad = 0.0_8
      DO j=je1,js2,-1
        CALL POPREAL8(qout(npx, j))
        q2_ad(j-1) = q2_ad(j-1) + edge_e(j)*qout_ad(npx, j)
        q2_ad(j) = q2_ad(j) + (1.-edge_e(j))*qout_ad(npx, j)
        qout_ad(npx, j) = 0.0_8
      END DO
      DO j=je1,js1,-1
        qin_ad(npx-1, j) = qin_ad(npx-1, j) + 0.5*q2_ad(j)
        qin_ad(npx, j) = qin_ad(npx, j) + 0.5*q2_ad(j)
        q2_ad(j) = 0.0_8
      END DO
    ELSE
      q2_ad = 0.0_8
    END IF
    edge_w => gridstruct%edge_w
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO j=je1,js2,-1
        CALL POPREAL8(qout(1, j))
        q2_ad(j-1) = q2_ad(j-1) + edge_w(j)*qout_ad(1, j)
        q2_ad(j) = q2_ad(j) + (1.-edge_w(j))*qout_ad(1, j)
        qout_ad(1, j) = 0.0_8
      END DO
      DO j=je1,js1,-1
        qin_ad(0, j) = qin_ad(0, j) + 0.5*q2_ad(j)
        qin_ad(1, j) = qin_ad(1, j) + 0.5*q2_ad(j)
        q2_ad(j) = 0.0_8
      END DO
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(qout(1, npy))
      temp_ad4 = r3*qout_ad(1, npy)
      qin_ad(1, npy-1) = qin_ad(1, npy-1) + temp_ad4
      qin_ad(0, npy-1) = qin_ad(0, npy-1) + temp_ad4
      qin_ad(1, npy) = qin_ad(1, npy) + temp_ad4
      qout_ad(1, npy) = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(qout(npx, npy))
      temp_ad3 = r3*qout_ad(npx, npy)
      qin_ad(npx-1, npy-1) = qin_ad(npx-1, npy-1) + temp_ad3
      qin_ad(npx, npy-1) = qin_ad(npx, npy-1) + temp_ad3
      qin_ad(npx-1, npy) = qin_ad(npx-1, npy) + temp_ad3
      qout_ad(npx, npy) = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(qout(npx, 1))
      temp_ad2 = r3*qout_ad(npx, 1)
      qin_ad(npx-1, 1) = qin_ad(npx-1, 1) + temp_ad2
      qin_ad(npx-1, 0) = qin_ad(npx-1, 0) + temp_ad2
      qin_ad(npx, 1) = qin_ad(npx, 1) + temp_ad2
      qout_ad(npx, 1) = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(qout(1, 1))
      temp_ad1 = r3*qout_ad(1, 1)
      qin_ad(1, 1) = qin_ad(1, 1) + temp_ad1
      qin_ad(1, 0) = qin_ad(1, 0) + temp_ad1
      qin_ad(0, 1) = qin_ad(0, 1) + temp_ad1
      qout_ad(1, 1) = 0.0_8
    END IF
    DO j=je1,js2,-1
      DO i=ie1,is2,-1
        CALL POPREAL8(qout(i, j))
        temp_ad0 = 0.25*qout_ad(i, j)
        qin_ad(i-1, j-1) = qin_ad(i-1, j-1) + temp_ad0
        qin_ad(i, j-1) = qin_ad(i, j-1) + temp_ad0
        qin_ad(i-1, j) = qin_ad(i-1, j) + temp_ad0
        qin_ad(i, j) = qin_ad(i, j) + temp_ad0
        qout_ad(i, j) = 0.0_8
      END DO
    END DO
 100 CONTINUE
  END SUBROUTINE A2B_ORD2_BWD
  SUBROUTINE A2B_ORD2(qin, qout, gridstruct, npx, npy, is, ie, js, je, &
&   ng, replace)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, is, ie, js, je, ng
! A-grid field
    REAL, INTENT(INOUT) :: qin(is-ng:ie+ng, js-ng:je+ng)
! Output  B-grid field
    REAL, INTENT(OUT) :: qout(is-ng:ie+ng, js-ng:je+ng)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    LOGICAL, OPTIONAL, INTENT(IN) :: replace
! local:
    REAL :: q1(npx), q2(npy)
    INTEGER :: i, j
    INTEGER :: is1, js1, is2, js2, ie1, je1
    REAL, DIMENSION(:, :, :), POINTER :: grid, agrid
    REAL, DIMENSION(:, :), POINTER :: dxa, dya
    REAL(kind=r_grid), DIMENSION(:), POINTER :: edge_w, edge_e, edge_s, &
&   edge_n
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC PRESENT
    edge_w => gridstruct%edge_w
    edge_e => gridstruct%edge_e
    edge_s => gridstruct%edge_s
    edge_n => gridstruct%edge_n
    grid => gridstruct%grid
    agrid => gridstruct%agrid
    dxa => gridstruct%dxa
    dya => gridstruct%dya
    IF (gridstruct%grid_type .LT. 3) THEN
      IF (gridstruct%nested) THEN
        DO j=js-2,je+1+2
          DO i=is-2,ie+1+2
            qout(i, j) = 0.25*(qin(i-1, j-1)+qin(i, j-1)+qin(i-1, j)+qin&
&             (i, j))
          END DO
        END DO
      ELSE
        IF (1 .LT. is - 1) THEN
          is1 = is - 1
        ELSE
          is1 = 1
        END IF
        IF (1 .LT. js - 1) THEN
          js1 = js - 1
        ELSE
          js1 = 1
        END IF
        IF (2 .LT. is) THEN
          is2 = is
        ELSE
          is2 = 2
        END IF
        IF (2 .LT. js) THEN
          js2 = js
        ELSE
          js2 = 2
        END IF
        IF (npx - 1 .GT. ie + 1) THEN
          ie1 = ie + 1
        ELSE
          ie1 = npx - 1
        END IF
        IF (npy - 1 .GT. je + 1) THEN
          je1 = je + 1
        ELSE
          je1 = npy - 1
        END IF
        DO j=js2,je1
          DO i=is2,ie1
            qout(i, j) = 0.25*(qin(i-1, j-1)+qin(i, j-1)+qin(i-1, j)+qin&
&             (i, j))
          END DO
        END DO
! Fix the 4 Corners:
        IF (gridstruct%sw_corner) qout(1, 1) = r3*(qin(1, 1)+qin(1, 0)+&
&           qin(0, 1))
        IF (gridstruct%se_corner) qout(npx, 1) = r3*(qin(npx-1, 1)+qin(&
&           npx-1, 0)+qin(npx, 1))
        IF (gridstruct%ne_corner) qout(npx, npy) = r3*(qin(npx-1, npy-1)&
&           +qin(npx, npy-1)+qin(npx-1, npy))
        IF (gridstruct%nw_corner) qout(1, npy) = r3*(qin(1, npy-1)+qin(0&
&           , npy-1)+qin(1, npy))
! *** West Edges:
        IF (is .EQ. 1) THEN
          DO j=js1,je1
            q2(j) = 0.5*(qin(0, j)+qin(1, j))
          END DO
          DO j=js2,je1
            qout(1, j) = edge_w(j)*q2(j-1) + (1.-edge_w(j))*q2(j)
          END DO
        END IF
! East Edges:
        IF (ie + 1 .EQ. npx) THEN
          DO j=js1,je1
            q2(j) = 0.5*(qin(npx-1, j)+qin(npx, j))
          END DO
          DO j=js2,je1
            qout(npx, j) = edge_e(j)*q2(j-1) + (1.-edge_e(j))*q2(j)
          END DO
        END IF
! South Edges:
        IF (js .EQ. 1) THEN
          DO i=is1,ie1
            q1(i) = 0.5*(qin(i, 0)+qin(i, 1))
          END DO
          DO i=is2,ie1
            qout(i, 1) = edge_s(i)*q1(i-1) + (1.-edge_s(i))*q1(i)
          END DO
        END IF
! North Edges:
        IF (je + 1 .EQ. npy) THEN
          DO i=is1,ie1
            q1(i) = 0.5*(qin(i, npy-1)+qin(i, npy))
          END DO
          DO i=is2,ie1
            qout(i, npy) = edge_n(i)*q1(i-1) + (1.-edge_n(i))*q1(i)
          END DO
        END IF
      END IF
    ELSE
      DO j=js,je+1
        DO i=is,ie+1
          qout(i, j) = 0.25*(qin(i-1, j-1)+qin(i, j-1)+qin(i-1, j)+qin(i&
&           , j))
        END DO
      END DO
    END IF
    IF (PRESENT(replace)) THEN
      IF (replace) THEN
        DO j=js,je+1
          DO i=is,ie+1
            qin(i, j) = qout(i, j)
          END DO
        END DO
      END IF
    END IF
  END SUBROUTINE A2B_ORD2
!  Differentiation of extrap_corner in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord4 a2b_edg
!e_mod.a2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_co
!re_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mo
!d.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayle
!igh_Super fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_geos 
!fv_grid_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_ma
!pz_mod.compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tr
!acer fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_limiters fv_mapz_
!mod.ppm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.moist_cv fv_mapz
!_mod.moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer_2d fv_tracer2d
!_mod.tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.Riem_Solver_c nh_u
!tils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SIM3p0_solver nh_uti
!ls_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nest_halo_nh sw_core_
!mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.f
!ill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v sw_core_mod.compute_diver
!gence_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_core_mod.fv_tp_2d tp_core_mod.copy_cor
!ners tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_corner fv_grid_utils_mod.great_circle_dist sw_c
!ore_mod.edge_interpolate4)):
!   gradient     of useful results: extrap_corner q1 q2
!   with respect to varying inputs: q1 q2
  REAL FUNCTION EXTRAP_CORNER_FWD(p0, p1, p2, q1, q2)
    IMPLICIT NONE
    REAL, DIMENSION(2), INTENT(IN) :: p0, p1, p2
    REAL, INTENT(IN) :: q1, q2
    REAL :: x1, x2
    INTRINSIC REAL
    REAL(r_grid), DIMENSION(2) :: arg1
    REAL(r_grid), DIMENSION(2) :: arg2
    REAL :: extrap_corner
    arg1(:) = REAL(p1, kind=r_grid)
    arg2(:) = REAL(p0, kind=r_grid)
    x1 = GREAT_CIRCLE_DIST(REAL(p1, kind=r_grid), REAL(p0, kind=r_grid))
    arg1(:) = REAL(p2, kind=r_grid)
    arg2(:) = REAL(p0, kind=r_grid)
    x2 = GREAT_CIRCLE_DIST(REAL(p2, kind=r_grid), REAL(p0, kind=r_grid))
    extrap_corner = q1 + x1/(x2-x1)*(q1-q2)
    CALL PUSHREAL8(x1)
    CALL PUSHREAL8(x2)
    extrap_corner_fwd = extrap_corner
  END FUNCTION EXTRAP_CORNER_FWD
!  Differentiation of extrap_corner in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord4 a2b_ed
!ge_mod.a2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_c
!ore_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_m
!od.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayl
!eigh_Super fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_dynamics_mod.fv3_to_geos
! fv_grid_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_m
!apz_mod.compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_t
!racer fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_limiters fv_mapz
!_mod.ppm_profile fv_mapz_mod.ppm_limiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.moist_cv fv_map
!z_mod.moist_cp fv_mapz_mod.map1_cubic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer_2d fv_tracer2
!d_mod.tracer_2d_nested nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.Riem_Solver_c nh_
!utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SIM3p0_solver nh_ut
!ils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nest_halo_nh sw_core
!_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.
!fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v sw_core_mod.compute_dive
!rgence_damping sw_core_mod.smag_corner sw_core_mod.del6_vt_flux tp_core_mod.mp_ghost_ew tp_core_mod.fv_tp_2d tp_core_mod.copy_co
!rners tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_corner fv_grid_utils_mod.great_circle_dist sw_
!core_mod.edge_interpolate4)):
!   gradient     of useful results: extrap_corner q1 q2
!   with respect to varying inputs: q1 q2
  SUBROUTINE EXTRAP_CORNER_BWD(p0, p1, p2, q1, q1_ad, q2, q2_ad, &
&   extrap_corner_ad)
    IMPLICIT NONE
    REAL, DIMENSION(2), INTENT(IN) :: p0, p1, p2
    REAL, INTENT(IN) :: q1, q2
    REAL :: q1_ad, q2_ad
    REAL :: x1, x2
    INTRINSIC REAL
    REAL(r_grid), DIMENSION(2) :: arg1
    REAL(r_grid), DIMENSION(2) :: arg2
    REAL :: temp_ad
    REAL :: extrap_corner_ad
    REAL :: extrap_corner
    CALL POPREAL8(x2)
    CALL POPREAL8(x1)
    temp_ad = x1*extrap_corner_ad/(x2-x1)
    q1_ad = q1_ad + temp_ad + extrap_corner_ad
    q2_ad = q2_ad - temp_ad
  END SUBROUTINE EXTRAP_CORNER_BWD
  REAL FUNCTION EXTRAP_CORNER(p0, p1, p2, q1, q2)
    IMPLICIT NONE
    REAL, DIMENSION(2), INTENT(IN) :: p0, p1, p2
    REAL, INTENT(IN) :: q1, q2
    REAL :: x1, x2
    INTRINSIC REAL
    REAL(r_grid), DIMENSION(2) :: arg1
    REAL(r_grid), DIMENSION(2) :: arg2
    arg1(:) = REAL(p1, kind=r_grid)
    arg2(:) = REAL(p0, kind=r_grid)
    x1 = GREAT_CIRCLE_DIST(arg1(:), arg2(:))
    arg1(:) = REAL(p2, kind=r_grid)
    arg2(:) = REAL(p0, kind=r_grid)
    x2 = GREAT_CIRCLE_DIST(arg1(:), arg2(:))
    extrap_corner = q1 + x1/(x2-x1)*(q1-q2)
  END FUNCTION EXTRAP_CORNER
END MODULE A2B_EDGE_MOD_B
