!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.13 (r6666) - 27 Nov 2017 17:09
!
MODULE FV_MP_MOD_DIFF
  USE MPP_DOMAINS_MOD_DIFF, ONLY : group_halo_update_type => &
& mpp_group_update_type
  USE MPP_DOMAINS_MOD_DIFF, ONLY : domain2d
  IMPLICIT NONE
!      subroutine complete_var_group_update_3d(group, group_tl, domain)
!        type(group_halo_update_type), intent(inout) :: group, group_tl
!        !real, dimension(:,:,:),       intent(inout) :: array
!        type(domain2D),               intent(inout) :: domain
!      
!      ! Arguments: 
!      !  (inout)   group - The data type that store information for group update. 
!      !                    This data will be used in do_group_pass.
!      !  (inout)   array - The array which is having its halos points exchanged.
!      !  (in)      domain - contains domain information.
!      
!        !array = 2*array
!      
!      end subroutine complete_var_group_update_3d
!      
!      subroutine complete_var_group_update_4d(group, group_tl, domain)
!        type(group_halo_update_type), intent(inout) :: group, group_tl
!        !real, dimension(:,:,:,:),     intent(inout) :: array
!        type(domain2D),               intent(inout) :: domain
!      
!      ! Arguments: 
!      !  (inout)   group - The data type that store information for group update. 
!      !                    This data will be used in do_group_pass.
!      !  (inout)   array - The array which is having its halos points exchanged.
!      !  (in)      domain - contains domain information.
!      
!        integer :: dirflag
!      
!        !array = 2*array
!      
!      end subroutine complete_var_group_update_4d
!      
!      
!      
!      subroutine complete_vector_group_update_2d(group, group_tl, domain)
!        type(group_halo_update_type), intent(inout) :: group, group_tl
!        !real,       dimension(:,:),   intent(inout) :: u_cmpt, v_cmpt
!        type(domain2d),               intent(inout) :: domain
!      
!      ! Arguments: 
!      !  (inout)   group - The data type that store information for group update. 
!      !                    This data will be used in do_group_pass.
!      !  (inout)   u_cmpt - The nominal zonal (u) component of the vector pair which
!      !                     is having its halos points exchanged.
!      !  (inout)   v_cmpt - The nominal meridional (v) component of the vector pair
!      !                     which is having its halos points exchanged. 
!      !  (in)      domain - Contains domain decomposition information.
!      
!        !u_cmpt = 2*u_cmpt
!        !v_cmpt = 2*v_cmpt
!      
!      end subroutine complete_vector_group_update_2d
!      
!      subroutine complete_vector_group_update_3d(group, group_tl, domain)
!        type(group_halo_update_type), intent(inout) :: group, group_tl
!        !real,       dimension(:,:,:), intent(inout) :: u_cmpt, v_cmpt
!        type(domain2d),               intent(inout) :: domain
!
!      
!      ! Arguments: 
!      !  (inout)   group - The data type that store information for group update. 
!      !                    This data will be used in do_group_pass.
!      !  (inout)   u_cmpt - The nominal zonal (u) component of the vector pair which
!      !                     is having its halos points exchanged.
!      !  (inout)   v_cmpt - The nominal meridional (v) component of the vector pair
!      !                     which is having its halos points exchanged. 
!      !  (in)      domain - Contains domain decomposition information.
!      
!        !u_cmpt = 2*u_cmpt
!        !v_cmpt = 2*v_cmpt
!      
!      end subroutine complete_vector_group_update_3d
  PUBLIC 
!dummy
  LOGICAL :: mp_gather
  INTEGER :: is, ie, js, je, isd, ied, jsd, jed, isc, iec, jsc, jec
  INTEGER :: mpp_broadcast
!dummy
  INTEGER :: mp_bcst
  INTEGER, PARAMETER :: xdir=1
  INTEGER, PARAMETER :: ydir=2
  INTEGER, PARAMETER :: ng=3
  INTERFACE START_GROUP_HALO_UPDATE
      MODULE PROCEDURE START_VAR_GROUP_UPDATE_2D
      MODULE PROCEDURE START_VAR_GROUP_UPDATE_3D
      MODULE PROCEDURE START_VAR_GROUP_UPDATE_4D
      MODULE PROCEDURE START_VECTOR_GROUP_UPDATE_2D
      MODULE PROCEDURE START_VECTOR_GROUP_UPDATE_3D
  END INTERFACE START_GROUP_HALO_UPDATE

  INTERFACE START_GROUP_HALO_UPDATE_TLM
      MODULE PROCEDURE START_VAR_GROUP_UPDATE_3D_TLM
      MODULE PROCEDURE START_VAR_GROUP_UPDATE_4D_TLM
      MODULE PROCEDURE START_VECTOR_GROUP_UPDATE_3D_TLM
  END INTERFACE

  INTERFACE MP_REDUCE_MAX
      MODULE PROCEDURE MP_REDUCE_MAX_R4_1D
      MODULE PROCEDURE MP_REDUCE_MAX_R4
      MODULE PROCEDURE MP_REDUCE_MAX_R8_1D
      MODULE PROCEDURE MP_REDUCE_MAX_R8
      MODULE PROCEDURE MP_REDUCE_MAX_I4
  END INTERFACE

  INTERFACE MP_REDUCE_SUM
      MODULE PROCEDURE MP_REDUCE_SUM_R4
      MODULE PROCEDURE MP_REDUCE_SUM_R4_1D
      MODULE PROCEDURE MP_REDUCE_SUM_R8
      MODULE PROCEDURE MP_REDUCE_SUM_R8_1D
  END INTERFACE

  INTERFACE FILL_CORNERS
      MODULE PROCEDURE FILL_CORNERS_2D_R4
      MODULE PROCEDURE FILL_CORNERS_2D_R8
      MODULE PROCEDURE FILL_CORNERS_XY_2D_R4
      MODULE PROCEDURE FILL_CORNERS_XY_2D_R8
      MODULE PROCEDURE FILL_CORNERS_XY_3D_R4
      MODULE PROCEDURE FILL_CORNERS_XY_3D_R8
  END INTERFACE

  INTERFACE FILL_CORNERS_TLM
      MODULE PROCEDURE FILL_CORNERS_2D_R4_TLM
      MODULE PROCEDURE FILL_CORNERS_XY_2D_R4_TLM
  END INTERFACE

  INTERFACE FILL_CORNERS_AGRID
      MODULE PROCEDURE FILL_CORNERS_AGRID_R4
      MODULE PROCEDURE FILL_CORNERS_AGRID_R8
  END INTERFACE

  INTERFACE FILL_CORNERS_AGRID_TLM
      MODULE PROCEDURE FILL_CORNERS_AGRID_R4_TLM
  END INTERFACE

  INTERFACE FILL_CORNERS_CGRID
      MODULE PROCEDURE FILL_CORNERS_CGRID_R4
      MODULE PROCEDURE FILL_CORNERS_CGRID_R8
  END INTERFACE

  INTERFACE FILL_CORNERS_CGRID_TLM
      MODULE PROCEDURE FILL_CORNERS_CGRID_R4_TLM
  END INTERFACE

  INTERFACE FILL_CORNERS_DGRID
      MODULE PROCEDURE FILL_CORNERS_DGRID_R4
      MODULE PROCEDURE FILL_CORNERS_DGRID_R8
  END INTERFACE

  INTERFACE FILL_CORNERS_DGRID_TLM
      MODULE PROCEDURE FILL_CORNERS_DGRID_R4_TLM
  END INTERFACE


CONTAINS
  LOGICAL FUNCTION IS_MASTER()
    IMPLICIT NONE
    IF (1 .EQ. 1) is_master = .true.
  END FUNCTION IS_MASTER
!  Differentiation of fill_corners_2d_r4 in forward (tangent) mode:
!   variations   of useful results: q
!   with respect to varying inputs: q
! FILL CORNERS
! ------------
  SUBROUTINE FILL_CORNERS_2D_R4_TLM(q, q_tl, npx, npy, fill, agrid, &
&   bgrid)
    IMPLICIT NONE
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: q
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: q_tl
    INTEGER, INTENT(IN) :: npx, npy
! X-Dir or Y-Dir 
    INTEGER, INTENT(IN) :: fill
    LOGICAL, OPTIONAL, INTENT(IN) :: agrid, bgrid
    INTEGER :: i, j
    INTRINSIC PRESENT
    IF (PRESENT(bgrid)) THEN
      IF (bgrid) THEN
        SELECT CASE  (fill) 
        CASE (xdir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) THEN
                q_tl(1-i, 1-j) = q_tl(1-j, i+1)
                q(1-i, 1-j) = q(1-j, i+1)
              END IF
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) THEN
                q_tl(1-i, npy+j) = q_tl(1-j, npy-i)
                q(1-i, npy+j) = q(1-j, npy-i)
              END IF
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) THEN
                q_tl(npx+i, 1-j) = q_tl(npx+j, i+1)
                q(npx+i, 1-j) = q(npx+j, i+1)
              END IF
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) THEN
                q_tl(npx+i, npy+j) = q_tl(npx+j, npy-i)
                q(npx+i, npy+j) = q(npx+j, npy-i)
              END IF
            END DO
          END DO
        CASE (ydir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) THEN
                q_tl(1-j, 1-i) = q_tl(i+1, 1-j)
                q(1-j, 1-i) = q(i+1, 1-j)
              END IF
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) THEN
                q_tl(1-j, npy+i) = q_tl(i+1, npy+j)
                q(1-j, npy+i) = q(i+1, npy+j)
              END IF
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) THEN
                q_tl(npx+j, 1-i) = q_tl(npx-i, 1-j)
                q(npx+j, 1-i) = q(npx-i, 1-j)
              END IF
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) THEN
                q_tl(npx+j, npy+i) = q_tl(npx-i, npy+j)
                q(npx+j, npy+i) = q(npx-i, npy+j)
              END IF
            END DO
          END DO
        CASE DEFAULT
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) THEN
                q_tl(1-i, 1-j) = q_tl(1-j, i+1)
                q(1-i, 1-j) = q(1-j, i+1)
              END IF
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) THEN
                q_tl(1-i, npy+j) = q_tl(1-j, npy-i)
                q(1-i, npy+j) = q(1-j, npy-i)
              END IF
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) THEN
                q_tl(npx+i, 1-j) = q_tl(npx+j, i+1)
                q(npx+i, 1-j) = q(npx+j, i+1)
              END IF
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) THEN
                q_tl(npx+i, npy+j) = q_tl(npx+j, npy-i)
                q(npx+i, npy+j) = q(npx+j, npy-i)
              END IF
            END DO
          END DO
        END SELECT
      END IF
    ELSE IF (PRESENT(agrid)) THEN
      IF (agrid) THEN
        SELECT CASE  (fill) 
        CASE (xdir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) THEN
                q_tl(1-i, 1-j) = q_tl(1-j, i)
                q(1-i, 1-j) = q(1-j, i)
              END IF
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) THEN
                q_tl(1-i, npy-1+j) = q_tl(1-j, npy-1-i+1)
                q(1-i, npy-1+j) = q(1-j, npy-1-i+1)
              END IF
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) THEN
                q_tl(npx-1+i, 1-j) = q_tl(npx-1+j, i)
                q(npx-1+i, 1-j) = q(npx-1+j, i)
              END IF
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) THEN
                q_tl(npx-1+i, npy-1+j) = q_tl(npx-1+j, npy-1-i+1)
                q(npx-1+i, npy-1+j) = q(npx-1+j, npy-1-i+1)
              END IF
            END DO
          END DO
        CASE (ydir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) THEN
                q_tl(1-j, 1-i) = q_tl(i, 1-j)
                q(1-j, 1-i) = q(i, 1-j)
              END IF
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) THEN
                q_tl(1-j, npy-1+i) = q_tl(i, npy-1+j)
                q(1-j, npy-1+i) = q(i, npy-1+j)
              END IF
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) THEN
                q_tl(npx-1+j, 1-i) = q_tl(npx-1-i+1, 1-j)
                q(npx-1+j, 1-i) = q(npx-1-i+1, 1-j)
              END IF
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) THEN
                q_tl(npx-1+j, npy-1+i) = q_tl(npx-1-i+1, npy-1+j)
                q(npx-1+j, npy-1+i) = q(npx-1-i+1, npy-1+j)
              END IF
            END DO
          END DO
        CASE DEFAULT
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) THEN
                q_tl(1-j, 1-i) = q_tl(i, 1-j)
                q(1-j, 1-i) = q(i, 1-j)
              END IF
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) THEN
                q_tl(1-j, npy-1+i) = q_tl(i, npy-1+j)
                q(1-j, npy-1+i) = q(i, npy-1+j)
              END IF
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) THEN
                q_tl(npx-1+j, 1-i) = q_tl(npx-1-i+1, 1-j)
                q(npx-1+j, 1-i) = q(npx-1-i+1, 1-j)
              END IF
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) THEN
                q_tl(npx-1+j, npy-1+i) = q_tl(npx-1-i+1, npy-1+j)
                q(npx-1+j, npy-1+i) = q(npx-1-i+1, npy-1+j)
              END IF
            END DO
          END DO
        END SELECT
      END IF
    END IF
  END SUBROUTINE FILL_CORNERS_2D_R4_TLM
! FILL CORNERS
! ------------
  SUBROUTINE FILL_CORNERS_2D_R4(q, npx, npy, fill, agrid, bgrid)
    IMPLICIT NONE
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: q
    INTEGER, INTENT(IN) :: npx, npy
! X-Dir or Y-Dir 
    INTEGER, INTENT(IN) :: fill
    LOGICAL, OPTIONAL, INTENT(IN) :: agrid, bgrid
    INTEGER :: i, j
    INTRINSIC PRESENT
    IF (PRESENT(bgrid)) THEN
      IF (bgrid) THEN
        SELECT CASE  (fill) 
        CASE (xdir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-i, 1-j) = q(1-j, i+1)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-i, npy+j) = q(1-j&
&                 , npy-i)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx+i, 1-j) = q(npx&
&                 +j, i+1)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx+i, npy+j)&
&                = q(npx+j, npy-i)
            END DO
          END DO
        CASE (ydir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-j, 1-i) = q(i+1, 1-j)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-j, npy+i) = q(i+1&
&                 , npy+j)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx+j, 1-i) = q(npx&
&                 -i, 1-j)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx+j, npy+i)&
&                = q(npx-i, npy+j)
            END DO
          END DO
        CASE DEFAULT
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-i, 1-j) = q(1-j, i+1)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-i, npy+j) = q(1-j&
&                 , npy-i)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx+i, 1-j) = q(npx&
&                 +j, i+1)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx+i, npy+j)&
&                = q(npx+j, npy-i)
            END DO
          END DO
        END SELECT
      END IF
    ELSE IF (PRESENT(agrid)) THEN
      IF (agrid) THEN
        SELECT CASE  (fill) 
        CASE (xdir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-i, 1-j) = q(1-j, i)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-i, npy-1+j) = q(1&
&                 -j, npy-1-i+1)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx-1+i, 1-j) = q(&
&                 npx-1+j, i)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx-1+i, npy-&
&               1+j) = q(npx-1+j, npy-1-i+1)
            END DO
          END DO
        CASE (ydir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-j, 1-i) = q(i, 1-j)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-j, npy-1+i) = q(i&
&                 , npy-1+j)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx-1+j, 1-i) = q(&
&                 npx-1-i+1, 1-j)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx-1+j, npy-&
&               1+i) = q(npx-1-i+1, npy-1+j)
            END DO
          END DO
        CASE DEFAULT
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-j, 1-i) = q(i, 1-j)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-j, npy-1+i) = q(i&
&                 , npy-1+j)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx-1+j, 1-i) = q(&
&                 npx-1-i+1, 1-j)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx-1+j, npy-&
&               1+i) = q(npx-1-i+1, npy-1+j)
            END DO
          END DO
        END SELECT
      END IF
    END IF
  END SUBROUTINE FILL_CORNERS_2D_R4
  SUBROUTINE FILL_CORNERS_2D_R8(q, npx, npy, fill, agrid, bgrid)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: q
    INTEGER, INTENT(IN) :: npx, npy
! X-Dir or Y-Dir 
    INTEGER, INTENT(IN) :: fill
    LOGICAL, OPTIONAL, INTENT(IN) :: agrid, bgrid
    INTEGER :: i, j
    INTRINSIC PRESENT
    IF (PRESENT(bgrid)) THEN
      IF (bgrid) THEN
        SELECT CASE  (fill) 
        CASE (xdir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-i, 1-j) = q(1-j, i+1)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-i, npy+j) = q(1-j&
&                 , npy-i)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx+i, 1-j) = q(npx&
&                 +j, i+1)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx+i, npy+j)&
&                = q(npx+j, npy-i)
            END DO
          END DO
        CASE (ydir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-j, 1-i) = q(i+1, 1-j)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-j, npy+i) = q(i+1&
&                 , npy+j)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx+j, 1-i) = q(npx&
&                 -i, 1-j)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx+j, npy+i)&
&                = q(npx-i, npy+j)
            END DO
          END DO
        CASE DEFAULT
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-i, 1-j) = q(1-j, i+1)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-i, npy+j) = q(1-j&
&                 , npy-i)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx+i, 1-j) = q(npx&
&                 +j, i+1)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx+i, npy+j)&
&                = q(npx+j, npy-i)
            END DO
          END DO
        END SELECT
      END IF
    ELSE IF (PRESENT(agrid)) THEN
      IF (agrid) THEN
        SELECT CASE  (fill) 
        CASE (xdir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-i, 1-j) = q(1-j, i)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-i, npy-1+j) = q(1&
&                 -j, npy-1-i+1)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx-1+i, 1-j) = q(&
&                 npx-1+j, i)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx-1+i, npy-&
&               1+j) = q(npx-1+j, npy-1-i+1)
            END DO
          END DO
        CASE (ydir) 
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-j, 1-i) = q(i, 1-j)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-j, npy-1+i) = q(i&
&                 , npy-1+j)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx-1+j, 1-i) = q(&
&                 npx-1-i+1, 1-j)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx-1+j, npy-&
&               1+i) = q(npx-1-i+1, npy-1+j)
            END DO
          END DO
        CASE DEFAULT
          DO j=1,ng
            DO i=1,ng
!SW Corner 
              IF (is .EQ. 1 .AND. js .EQ. 1) q(1-j, 1-i) = q(i, 1-j)
!NW Corner
              IF (is .EQ. 1 .AND. je .EQ. npy - 1) q(1-j, npy-1+i) = q(i&
&                 , npy-1+j)
!SE Corner
              IF (ie .EQ. npx - 1 .AND. js .EQ. 1) q(npx-1+j, 1-i) = q(&
&                 npx-1-i+1, 1-j)
!NE Corner
              IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) q(npx-1+j, npy-&
&               1+i) = q(npx-1-i+1, npy-1+j)
            END DO
          END DO
        END SELECT
      END IF
    END IF
  END SUBROUTINE FILL_CORNERS_2D_R8
!  Differentiation of fill_corners_xy_2d_r4 in forward (tangent) mode:
!   variations   of useful results: x y
!   with respect to varying inputs: x y
  SUBROUTINE FILL_CORNERS_XY_2D_R4_TLM(x, x_tl, y, y_tl, npx, npy, dgrid&
&   , agrid, cgrid, vector)
    IMPLICIT NONE
!(isd:ied  ,jsd:jed+1)
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x_tl
!(isd:ied+1,jsd:jed  )
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y_tl
    INTEGER, INTENT(IN) :: npx, npy
    LOGICAL, OPTIONAL, INTENT(IN) :: dgrid, agrid, cgrid, vector
    INTEGER :: i, j
    REAL(kind=4) :: mysign
    INTRINSIC PRESENT
    mysign = 1.0
    IF (PRESENT(vector)) THEN
      IF (vector) mysign = -1.0
    END IF
    IF (PRESENT(dgrid)) THEN
      CALL FILL_CORNERS_DGRID_TLM(x, x_tl, y, y_tl, npx, npy, mysign)
    ELSE IF (PRESENT(cgrid)) THEN
      CALL FILL_CORNERS_CGRID_TLM(x, x_tl, y, y_tl, npx, npy, mysign)
    ELSE IF (PRESENT(agrid)) THEN
      CALL FILL_CORNERS_AGRID_TLM(x, x_tl, y, y_tl, npx, npy, mysign)
    ELSE
      CALL FILL_CORNERS_AGRID_TLM(x, x_tl, y, y_tl, npx, npy, mysign)
    END IF
  END SUBROUTINE FILL_CORNERS_XY_2D_R4_TLM
  SUBROUTINE FILL_CORNERS_XY_2D_R4(x, y, npx, npy, dgrid, agrid, cgrid, &
&   vector)
    IMPLICIT NONE
!(isd:ied  ,jsd:jed+1)
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
!(isd:ied+1,jsd:jed  )
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    INTEGER, INTENT(IN) :: npx, npy
    LOGICAL, OPTIONAL, INTENT(IN) :: dgrid, agrid, cgrid, vector
    INTEGER :: i, j
    REAL(kind=4) :: mysign
    INTRINSIC PRESENT
    mysign = 1.0
    IF (PRESENT(vector)) THEN
      IF (vector) mysign = -1.0
    END IF
    IF (PRESENT(dgrid)) THEN
      CALL FILL_CORNERS_DGRID(x, y, npx, npy, mysign)
    ELSE IF (PRESENT(cgrid)) THEN
      CALL FILL_CORNERS_CGRID(x, y, npx, npy, mysign)
    ELSE IF (PRESENT(agrid)) THEN
      CALL FILL_CORNERS_AGRID(x, y, npx, npy, mysign)
    ELSE
      CALL FILL_CORNERS_AGRID(x, y, npx, npy, mysign)
    END IF
  END SUBROUTINE FILL_CORNERS_XY_2D_R4
  SUBROUTINE FILL_CORNERS_XY_2D_R8(x, y, npx, npy, dgrid, agrid, cgrid, &
&   vector)
    IMPLICIT NONE
!(isd:ied  ,jsd:jed+1)
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
!(isd:ied+1,jsd:jed  )
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    INTEGER, INTENT(IN) :: npx, npy
    LOGICAL, OPTIONAL, INTENT(IN) :: dgrid, agrid, cgrid, vector
    INTEGER :: i, j
    REAL(kind=8) :: mysign
    INTRINSIC PRESENT
    mysign = 1.0
    IF (PRESENT(vector)) THEN
      IF (vector) mysign = -1.0
    END IF
    IF (PRESENT(dgrid)) THEN
      CALL FILL_CORNERS_DGRID(x, y, npx, npy, mysign)
    ELSE IF (PRESENT(cgrid)) THEN
      CALL FILL_CORNERS_CGRID(x, y, npx, npy, mysign)
    ELSE IF (PRESENT(agrid)) THEN
      CALL FILL_CORNERS_AGRID(x, y, npx, npy, mysign)
    ELSE
      CALL FILL_CORNERS_AGRID(x, y, npx, npy, mysign)
    END IF
  END SUBROUTINE FILL_CORNERS_XY_2D_R8
  SUBROUTINE FILL_CORNERS_XY_3D_R4(x, y, npx, npy, npz, dgrid, agrid, &
&   cgrid, vector)
    IMPLICIT NONE
!(isd:ied  ,jsd:jed+1)
    REAL(kind=4), DIMENSION(isd:, jsd:, :), INTENT(INOUT) :: x
!(isd:ied+1,jsd:jed  )
    REAL(kind=4), DIMENSION(isd:, jsd:, :), INTENT(INOUT) :: y
    INTEGER, INTENT(IN) :: npx, npy, npz
    LOGICAL, OPTIONAL, INTENT(IN) :: dgrid, agrid, cgrid, vector
    INTEGER :: i, j, k
    REAL(kind=4) :: mysign
    INTRINSIC PRESENT
    mysign = 1.0
    IF (PRESENT(vector)) THEN
      IF (vector) mysign = -1.0
    END IF
    IF (PRESENT(dgrid)) THEN
      DO k=1,npz
        CALL FILL_CORNERS_DGRID(x(:, :, k), y(:, :, k), npx, npy, mysign&
&                        )
      END DO
    ELSE IF (PRESENT(cgrid)) THEN
      DO k=1,npz
        CALL FILL_CORNERS_CGRID(x(:, :, k), y(:, :, k), npx, npy, mysign&
&                        )
      END DO
    ELSE IF (PRESENT(agrid)) THEN
      DO k=1,npz
        CALL FILL_CORNERS_AGRID(x(:, :, k), y(:, :, k), npx, npy, mysign&
&                        )
      END DO
    ELSE
      DO k=1,npz
        CALL FILL_CORNERS_AGRID(x(:, :, k), y(:, :, k), npx, npy, mysign&
&                        )
      END DO
    END IF
  END SUBROUTINE FILL_CORNERS_XY_3D_R4
  SUBROUTINE FILL_CORNERS_XY_3D_R8(x, y, npx, npy, npz, dgrid, agrid, &
&   cgrid, vector)
    IMPLICIT NONE
!(isd:ied  ,jsd:jed+1)
    REAL(kind=8), DIMENSION(isd:, jsd:, :), INTENT(INOUT) :: x
!(isd:ied+1,jsd:jed  )
    REAL(kind=8), DIMENSION(isd:, jsd:, :), INTENT(INOUT) :: y
    INTEGER, INTENT(IN) :: npx, npy, npz
    LOGICAL, OPTIONAL, INTENT(IN) :: dgrid, agrid, cgrid, vector
    INTEGER :: i, j, k
    REAL(kind=8) :: mysign
    INTRINSIC PRESENT
    mysign = 1.0
    IF (PRESENT(vector)) THEN
      IF (vector) mysign = -1.0
    END IF
    IF (PRESENT(dgrid)) THEN
      DO k=1,npz
        CALL FILL_CORNERS_DGRID(x(:, :, k), y(:, :, k), npx, npy, mysign&
&                        )
      END DO
    ELSE IF (PRESENT(cgrid)) THEN
      DO k=1,npz
        CALL FILL_CORNERS_CGRID(x(:, :, k), y(:, :, k), npx, npy, mysign&
&                        )
      END DO
    ELSE IF (PRESENT(agrid)) THEN
      DO k=1,npz
        CALL FILL_CORNERS_AGRID(x(:, :, k), y(:, :, k), npx, npy, mysign&
&                        )
      END DO
    ELSE
      DO k=1,npz
        CALL FILL_CORNERS_AGRID(x(:, :, k), y(:, :, k), npx, npy, mysign&
&                        )
      END DO
    END IF
  END SUBROUTINE FILL_CORNERS_XY_3D_R8
!  Differentiation of fill_corners_agrid_r4 in forward (tangent) mode:
!   variations   of useful results: x y
!   with respect to varying inputs: x y
! FILL CORNERS AGRID
! ------------------
  SUBROUTINE FILL_CORNERS_AGRID_R4_TLM(x, x_tl, y, y_tl, npx, npy, &
&   mysign)
    IMPLICIT NONE
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x_tl
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y_tl
    INTEGER, INTENT(IN) :: npx, npy
    REAL(kind=4), INTENT(IN) :: mysign
    INTEGER :: i, j
    DO j=1,ng
      DO i=1,ng
!SW Corner
        IF (is .EQ. 1 .AND. js .EQ. 1) THEN
          x_tl(1-i, 1-j) = mysign*y_tl(1-j, i)
          x(1-i, 1-j) = mysign*y(1-j, i)
        END IF
!NW Corner
        IF (is .EQ. 1 .AND. je .EQ. npy - 1) THEN
          x_tl(1-i, npy-1+j) = y_tl(1-j, npy-1-i+1)
          x(1-i, npy-1+j) = y(1-j, npy-1-i+1)
        END IF
!SE Corner
        IF (ie .EQ. npx - 1 .AND. js .EQ. 1) THEN
          x_tl(npx-1+i, 1-j) = y_tl(npx-1+j, i)
          x(npx-1+i, 1-j) = y(npx-1+j, i)
        END IF
!NE Corner
        IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) THEN
          x_tl(npx-1+i, npy-1+j) = mysign*y_tl(npx-1+j, npy-1-i+1)
          x(npx-1+i, npy-1+j) = mysign*y(npx-1+j, npy-1-i+1)
        END IF
      END DO
    END DO
    DO j=1,ng
      DO i=1,ng
!SW Corner
        IF (is .EQ. 1 .AND. js .EQ. 1) THEN
          y_tl(1-j, 1-i) = mysign*x_tl(i, 1-j)
          y(1-j, 1-i) = mysign*x(i, 1-j)
        END IF
!NW Corner
        IF (is .EQ. 1 .AND. je .EQ. npy - 1) THEN
          y_tl(1-j, npy-1+i) = x_tl(i, npy-1+j)
          y(1-j, npy-1+i) = x(i, npy-1+j)
        END IF
!SE Corner
        IF (ie .EQ. npx - 1 .AND. js .EQ. 1) THEN
          y_tl(npx-1+j, 1-i) = x_tl(npx-1-i+1, 1-j)
          y(npx-1+j, 1-i) = x(npx-1-i+1, 1-j)
        END IF
!NE Corner
        IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) THEN
          y_tl(npx-1+j, npy-1+i) = mysign*x_tl(npx-1-i+1, npy-1+j)
          y(npx-1+j, npy-1+i) = mysign*x(npx-1-i+1, npy-1+j)
        END IF
      END DO
    END DO
  END SUBROUTINE FILL_CORNERS_AGRID_R4_TLM
! FILL CORNERS AGRID
! ------------------
  SUBROUTINE FILL_CORNERS_AGRID_R4(x, y, npx, npy, mysign)
    IMPLICIT NONE
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    INTEGER, INTENT(IN) :: npx, npy
    REAL(kind=4), INTENT(IN) :: mysign
    INTEGER :: i, j
    DO j=1,ng
      DO i=1,ng
!SW Corner
        IF (is .EQ. 1 .AND. js .EQ. 1) x(1-i, 1-j) = mysign*y(1-j, i)
!NW Corner
        IF (is .EQ. 1 .AND. je .EQ. npy - 1) x(1-i, npy-1+j) = y(1-j, &
&           npy-1-i+1)
!SE Corner
        IF (ie .EQ. npx - 1 .AND. js .EQ. 1) x(npx-1+i, 1-j) = y(npx-1+j&
&           , i)
!NE Corner
        IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) x(npx-1+i, npy-1+j)&
&          = mysign*y(npx-1+j, npy-1-i+1)
      END DO
    END DO
    DO j=1,ng
      DO i=1,ng
!SW Corner
        IF (is .EQ. 1 .AND. js .EQ. 1) y(1-j, 1-i) = mysign*x(i, 1-j)
!NW Corner
        IF (is .EQ. 1 .AND. je .EQ. npy - 1) y(1-j, npy-1+i) = x(i, npy-&
&           1+j)
!SE Corner
        IF (ie .EQ. npx - 1 .AND. js .EQ. 1) y(npx-1+j, 1-i) = x(npx-1-i&
&           +1, 1-j)
!NE Corner
        IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) y(npx-1+j, npy-1+i)&
&          = mysign*x(npx-1-i+1, npy-1+j)
      END DO
    END DO
  END SUBROUTINE FILL_CORNERS_AGRID_R4
  SUBROUTINE FILL_CORNERS_AGRID_R8(x, y, npx, npy, mysign)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    INTEGER, INTENT(IN) :: npx, npy
    REAL(kind=8), INTENT(IN) :: mysign
    INTEGER :: i, j
    DO j=1,ng
      DO i=1,ng
!SW Corner
        IF (is .EQ. 1 .AND. js .EQ. 1) x(1-i, 1-j) = mysign*y(1-j, i)
!NW Corner
        IF (is .EQ. 1 .AND. je .EQ. npy - 1) x(1-i, npy-1+j) = y(1-j, &
&           npy-1-i+1)
!SE Corner
        IF (ie .EQ. npx - 1 .AND. js .EQ. 1) x(npx-1+i, 1-j) = y(npx-1+j&
&           , i)
!NE Corner
        IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) x(npx-1+i, npy-1+j)&
&          = mysign*y(npx-1+j, npy-1-i+1)
      END DO
    END DO
    DO j=1,ng
      DO i=1,ng
!SW Corner
        IF (is .EQ. 1 .AND. js .EQ. 1) y(1-j, 1-i) = mysign*x(i, 1-j)
!NW Corner
        IF (is .EQ. 1 .AND. je .EQ. npy - 1) y(1-j, npy-1+i) = x(i, npy-&
&           1+j)
!SE Corner
        IF (ie .EQ. npx - 1 .AND. js .EQ. 1) y(npx-1+j, 1-i) = x(npx-1-i&
&           +1, 1-j)
!NE Corner
        IF (ie .EQ. npx - 1 .AND. je .EQ. npy - 1) y(npx-1+j, npy-1+i)&
&          = mysign*x(npx-1-i+1, npy-1+j)
      END DO
    END DO
  END SUBROUTINE FILL_CORNERS_AGRID_R8
!  Differentiation of fill_corners_cgrid_r4 in forward (tangent) mode:
!   variations   of useful results: x y
!   with respect to varying inputs: x y
! FILL CORNERS CGRID
! ------------------
  SUBROUTINE FILL_CORNERS_CGRID_R4_TLM(x, x_tl, y, y_tl, npx, npy, &
&   mysign)
    IMPLICIT NONE
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x_tl
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y_tl
    INTEGER, INTENT(IN) :: npx, npy
    REAL(kind=4), INTENT(IN) :: mysign
    INTEGER :: i, j
    DO j=1,ng
      DO i=1,ng
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) THEN
          x_tl(1-i, 1-j) = y_tl(j, 1-i)
          x(1-i, 1-j) = y(j, 1-i)
        END IF
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) THEN
          x_tl(1-i, npy-1+j) = mysign*y_tl(j, npy+i)
          x(1-i, npy-1+j) = mysign*y(j, npy+i)
        END IF
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) THEN
          x_tl(npx+i, 1-j) = mysign*y_tl(npx-j, 1-i)
          x(npx+i, 1-j) = mysign*y(npx-j, 1-i)
        END IF
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) THEN
          x_tl(npx+i, npy-1+j) = y_tl(npx-j, npy+i)
          x(npx+i, npy-1+j) = y(npx-j, npy+i)
        END IF
      END DO
    END DO
    DO j=1,ng
      DO i=1,ng
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) THEN
          y_tl(1-i, 1-j) = x_tl(1-j, i)
          y(1-i, 1-j) = x(1-j, i)
        END IF
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) THEN
          y_tl(1-i, npy+j) = mysign*x_tl(1-j, npy-i)
          y(1-i, npy+j) = mysign*x(1-j, npy-i)
        END IF
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) THEN
          y_tl(npx-1+i, 1-j) = mysign*x_tl(npx+j, i)
          y(npx-1+i, 1-j) = mysign*x(npx+j, i)
        END IF
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) THEN
          y_tl(npx-1+i, npy+j) = x_tl(npx+j, npy-i)
          y(npx-1+i, npy+j) = x(npx+j, npy-i)
        END IF
      END DO
    END DO
  END SUBROUTINE FILL_CORNERS_CGRID_R4_TLM
! FILL CORNERS CGRID
! ------------------
  SUBROUTINE FILL_CORNERS_CGRID_R4(x, y, npx, npy, mysign)
    IMPLICIT NONE
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    INTEGER, INTENT(IN) :: npx, npy
    REAL(kind=4), INTENT(IN) :: mysign
    INTEGER :: i, j
    DO j=1,ng
      DO i=1,ng
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) x(1-i, 1-j) = y(j, 1-i)
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) x(1-i, npy-1+j) = mysign*y(&
&           j, npy+i)
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) x(npx+i, 1-j) = mysign*y(&
&           npx-j, 1-i)
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) x(npx+i, npy-1+j) = y&
&           (npx-j, npy+i)
      END DO
    END DO
    DO j=1,ng
      DO i=1,ng
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) y(1-i, 1-j) = x(1-j, i)
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) y(1-i, npy+j) = mysign*x(1-&
&           j, npy-i)
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) y(npx-1+i, 1-j) = mysign*x(&
&           npx+j, i)
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) y(npx-1+i, npy+j) = x&
&           (npx+j, npy-i)
      END DO
    END DO
  END SUBROUTINE FILL_CORNERS_CGRID_R4
  SUBROUTINE FILL_CORNERS_CGRID_R8(x, y, npx, npy, mysign)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    INTEGER, INTENT(IN) :: npx, npy
    REAL(kind=8), INTENT(IN) :: mysign
    INTEGER :: i, j
    DO j=1,ng
      DO i=1,ng
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) x(1-i, 1-j) = y(j, 1-i)
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) x(1-i, npy-1+j) = mysign*y(&
&           j, npy+i)
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) x(npx+i, 1-j) = mysign*y(&
&           npx-j, 1-i)
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) x(npx+i, npy-1+j) = y&
&           (npx-j, npy+i)
      END DO
    END DO
    DO j=1,ng
      DO i=1,ng
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) y(1-i, 1-j) = x(1-j, i)
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) y(1-i, npy+j) = mysign*x(1-&
&           j, npy-i)
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) y(npx-1+i, 1-j) = mysign*x(&
&           npx+j, i)
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) y(npx-1+i, npy+j) = x&
&           (npx+j, npy-i)
      END DO
    END DO
  END SUBROUTINE FILL_CORNERS_CGRID_R8
!  Differentiation of fill_corners_dgrid_r4 in forward (tangent) mode:
!   variations   of useful results: x y
!   with respect to varying inputs: x y
! FILL CORNERS DGRID
! ------------------
  SUBROUTINE FILL_CORNERS_DGRID_R4_TLM(x, x_tl, y, y_tl, npx, npy, &
&   mysign)
    IMPLICIT NONE
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x_tl
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y_tl
    INTEGER, INTENT(IN) :: npx, npy
    REAL(kind=4), INTENT(IN) :: mysign
    INTEGER :: i, j
    DO j=1,ng
      DO i=1,ng
!   if ((is  ==  1) .and. (js  ==  1)) x(1-i    ,1-j  ) =        y(j+1  ,1-i    )  !SW Corner 
!   if ((is  ==  1) .and. (je+1==npy)) x(1-i    ,npy+j) = mySign*y(j+1  ,npy-1+i)  !NW Corner
!   if ((ie+1==npx) .and. (js  ==  1)) x(npx-1+i,1-j  ) = mySign*y(npx-j,1-i    )  !SE Corner
!   if ((ie+1==npx) .and. (je+1==npy)) x(npx-1+i,npy+j) =        y(npx-j,npy-1+i)  !NE Corner
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) THEN
          x_tl(1-i, 1-j) = mysign*y_tl(1-j, i)
          x(1-i, 1-j) = mysign*y(1-j, i)
        END IF
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) THEN
          x_tl(1-i, npy+j) = y_tl(1-j, npy-i)
          x(1-i, npy+j) = y(1-j, npy-i)
        END IF
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) THEN
          x_tl(npx-1+i, 1-j) = y_tl(npx+j, i)
          x(npx-1+i, 1-j) = y(npx+j, i)
        END IF
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) THEN
          x_tl(npx-1+i, npy+j) = mysign*y_tl(npx+j, npy-i)
          x(npx-1+i, npy+j) = mysign*y(npx+j, npy-i)
        END IF
      END DO
    END DO
    DO j=1,ng
      DO i=1,ng
!  if ((is  ==  1) .and. (js  ==  1)) y(1-i    ,1-j    ) =        x(1-j    ,i+1  )  !SW Corner 
!  if ((is  ==  1) .and. (je+1==npy)) y(1-i    ,npy-1+j) = mySign*x(1-j    ,npy-i)  !NW Corner
!  if ((ie+1==npx) .and. (js  ==  1)) y(npx+i  ,1-j    ) = mySign*x(npx-1+j,i+1  )  !SE Corner
!  if ((ie+1==npx) .and. (je+1==npy)) y(npx+i  ,npy-1+j) =        x(npx-1+j,npy-i)  !NE Corner
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) THEN
          y_tl(1-i, 1-j) = mysign*x_tl(j, 1-i)
          y(1-i, 1-j) = mysign*x(j, 1-i)
        END IF
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) THEN
          y_tl(1-i, npy-1+j) = x_tl(j, npy+i)
          y(1-i, npy-1+j) = x(j, npy+i)
        END IF
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) THEN
          y_tl(npx+i, 1-j) = x_tl(npx-j, 1-i)
          y(npx+i, 1-j) = x(npx-j, 1-i)
        END IF
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) THEN
          y_tl(npx+i, npy-1+j) = mysign*x_tl(npx-j, npy+i)
          y(npx+i, npy-1+j) = mysign*x(npx-j, npy+i)
        END IF
      END DO
    END DO
  END SUBROUTINE FILL_CORNERS_DGRID_R4_TLM
! FILL CORNERS DGRID
! ------------------
  SUBROUTINE FILL_CORNERS_DGRID_R4(x, y, npx, npy, mysign)
    IMPLICIT NONE
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
    REAL(kind=4), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    INTEGER, INTENT(IN) :: npx, npy
    REAL(kind=4), INTENT(IN) :: mysign
    INTEGER :: i, j
    DO j=1,ng
      DO i=1,ng
!   if ((is  ==  1) .and. (js  ==  1)) x(1-i    ,1-j  ) =        y(j+1  ,1-i    )  !SW Corner 
!   if ((is  ==  1) .and. (je+1==npy)) x(1-i    ,npy+j) = mySign*y(j+1  ,npy-1+i)  !NW Corner
!   if ((ie+1==npx) .and. (js  ==  1)) x(npx-1+i,1-j  ) = mySign*y(npx-j,1-i    )  !SE Corner
!   if ((ie+1==npx) .and. (je+1==npy)) x(npx-1+i,npy+j) =        y(npx-j,npy-1+i)  !NE Corner
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) x(1-i, 1-j) = mysign*y(1-j, i)
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) x(1-i, npy+j) = y(1-j, npy-&
&           i)
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) x(npx-1+i, 1-j) = y(npx+j, &
&           i)
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) x(npx-1+i, npy+j) = &
&           mysign*y(npx+j, npy-i)
      END DO
    END DO
    DO j=1,ng
      DO i=1,ng
!  if ((is  ==  1) .and. (js  ==  1)) y(1-i    ,1-j    ) =        x(1-j    ,i+1  )  !SW Corner 
!  if ((is  ==  1) .and. (je+1==npy)) y(1-i    ,npy-1+j) = mySign*x(1-j    ,npy-i)  !NW Corner
!  if ((ie+1==npx) .and. (js  ==  1)) y(npx+i  ,1-j    ) = mySign*x(npx-1+j,i+1  )  !SE Corner
!  if ((ie+1==npx) .and. (je+1==npy)) y(npx+i  ,npy-1+j) =        x(npx-1+j,npy-i)  !NE Corner
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) y(1-i, 1-j) = mysign*x(j, 1-i)
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) y(1-i, npy-1+j) = x(j, npy+&
&           i)
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) y(npx+i, 1-j) = x(npx-j, 1-&
&           i)
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) y(npx+i, npy-1+j) = &
&           mysign*x(npx-j, npy+i)
      END DO
    END DO
  END SUBROUTINE FILL_CORNERS_DGRID_R4
  SUBROUTINE FILL_CORNERS_DGRID_R8(x, y, npx, npy, mysign)
    IMPLICIT NONE
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: x
    REAL(kind=8), DIMENSION(isd:, jsd:), INTENT(INOUT) :: y
    INTEGER, INTENT(IN) :: npx, npy
    REAL(kind=8), INTENT(IN) :: mysign
    INTEGER :: i, j
    DO j=1,ng
      DO i=1,ng
!   if ((is  ==  1) .and. (js  ==  1)) x(1-i    ,1-j  ) =        y(j+1  ,1-i    )  !SW Corner 
!   if ((is  ==  1) .and. (je+1==npy)) x(1-i    ,npy+j) = mySign*y(j+1  ,npy-1+i)  !NW Corner
!   if ((ie+1==npx) .and. (js  ==  1)) x(npx-1+i,1-j  ) = mySign*y(npx-j,1-i    )  !SE Corner
!   if ((ie+1==npx) .and. (je+1==npy)) x(npx-1+i,npy+j) =        y(npx-j,npy-1+i)  !NE Corner
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) x(1-i, 1-j) = mysign*y(1-j, i)
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) x(1-i, npy+j) = y(1-j, npy-&
&           i)
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) x(npx-1+i, 1-j) = y(npx+j, &
&           i)
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) x(npx-1+i, npy+j) = &
&           mysign*y(npx+j, npy-i)
      END DO
    END DO
    DO j=1,ng
      DO i=1,ng
!  if ((is  ==  1) .and. (js  ==  1)) y(1-i    ,1-j    ) =        x(1-j    ,i+1  )  !SW Corner 
!  if ((is  ==  1) .and. (je+1==npy)) y(1-i    ,npy-1+j) = mySign*x(1-j    ,npy-i)  !NW Corner
!  if ((ie+1==npx) .and. (js  ==  1)) y(npx+i  ,1-j    ) = mySign*x(npx-1+j,i+1  )  !SE Corner
!  if ((ie+1==npx) .and. (je+1==npy)) y(npx+i  ,npy-1+j) =        x(npx-1+j,npy-i)  !NE Corner
!SW Corner 
        IF (is .EQ. 1 .AND. js .EQ. 1) y(1-i, 1-j) = mysign*x(j, 1-i)
!NW Corner
        IF (is .EQ. 1 .AND. je + 1 .EQ. npy) y(1-i, npy-1+j) = x(j, npy+&
&           i)
!SE Corner
        IF (ie + 1 .EQ. npx .AND. js .EQ. 1) y(npx+i, 1-j) = x(npx-j, 1-&
&           i)
!NE Corner
        IF (ie + 1 .EQ. npx .AND. je + 1 .EQ. npy) y(npx+i, npy-1+j) = &
&           mysign*x(npx-j, npy+i)
      END DO
    END DO
  END SUBROUTINE FILL_CORNERS_DGRID_R8
! MP REDUCE SUM
! -------------
  SUBROUTINE MP_REDUCE_SUM_R4(mysum)
    IMPLICIT NONE
    REAL(kind=4), INTENT(INOUT) :: mysum
    REAL(kind=4) :: gsum
    mysum = 2*mysum
  END SUBROUTINE MP_REDUCE_SUM_R4
  SUBROUTINE MP_REDUCE_SUM_R8(mysum)
    IMPLICIT NONE
    REAL(kind=8), INTENT(INOUT) :: mysum
    REAL(kind=8) :: gsum
    mysum = 2*mysum
  END SUBROUTINE MP_REDUCE_SUM_R8
  SUBROUTINE MP_REDUCE_SUM_R4_1D(mysum, sum1d, npts)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npts
    REAL(kind=4), INTENT(IN) :: sum1d(npts)
    REAL(kind=4), INTENT(INOUT) :: mysum
    REAL(kind=4) :: gsum
    INTEGER :: i
    mysum = 2*mysum
  END SUBROUTINE MP_REDUCE_SUM_R4_1D
  SUBROUTINE MP_REDUCE_SUM_R8_1D(mysum, sum1d, npts)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npts
    REAL(kind=8), INTENT(IN) :: sum1d(npts)
    REAL(kind=8), INTENT(INOUT) :: mysum
    REAL(kind=8) :: gsum
    INTEGER :: i
    mysum = 2*mysum
  END SUBROUTINE MP_REDUCE_SUM_R8_1D
! MP REDUCE MAX
! -------------
  SUBROUTINE MP_REDUCE_MAX_R4_1D(mymax, npts)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npts
    REAL(kind=4), INTENT(INOUT) :: mymax(npts)
    REAL(kind=4) :: gmax(npts)
    mymax = 2*mymax
  END SUBROUTINE MP_REDUCE_MAX_R4_1D
  SUBROUTINE MP_REDUCE_MAX_R8_1D(mymax, npts)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npts
    REAL(kind=8), INTENT(INOUT) :: mymax(npts)
    REAL(kind=8) :: gmax(npts)
    mymax = 2*mymax
  END SUBROUTINE MP_REDUCE_MAX_R8_1D
  SUBROUTINE MP_REDUCE_MAX_R4(mymax)
    IMPLICIT NONE
    REAL(kind=4), INTENT(INOUT) :: mymax
    REAL(kind=4) :: gmax
    mymax = 2*mymax
  END SUBROUTINE MP_REDUCE_MAX_R4
  SUBROUTINE MP_REDUCE_MAX_R8(mymax)
    IMPLICIT NONE
    REAL(kind=8), INTENT(INOUT) :: mymax
    REAL(kind=8) :: gmax
    mymax = 2*mymax
  END SUBROUTINE MP_REDUCE_MAX_R8
  SUBROUTINE MP_REDUCE_MAX_I4(mymax)
    IMPLICIT NONE
    INTEGER, INTENT(INOUT) :: mymax
    INTEGER :: gmax
    mymax = 2*mymax
  END SUBROUTINE MP_REDUCE_MAX_I4
! start_group_halo_update
! -----------------------
  SUBROUTINE START_VAR_GROUP_UPDATE_2D(group, array, domain, flags, &
&   position, whalo, ehalo, shalo, nhalo, complete)
    IMPLICIT NONE
!, group_tl
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: group
    REAL, DIMENSION(:, :), INTENT(INOUT) :: array
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    INTEGER, OPTIONAL, INTENT(IN) :: flags
    INTEGER, OPTIONAL, INTENT(IN) :: position
    INTEGER, OPTIONAL, INTENT(IN) :: whalo, ehalo, shalo, nhalo
    LOGICAL, OPTIONAL, INTENT(IN) :: complete
    REAL :: d_type
    LOGICAL :: is_complete
! Arguments: 
!  (inout)   group - The data type that store information for group update. 
!                    This data will be used in do_group_pass.
!  (inout)   array - The array which is having its halos points exchanged.
!  (in)      domain - contains domain information.
!  (in)      flags  - An optional integer indicating which directions the
!                       data should be sent.  
!  (in)      position - An optional argument indicating the position.  This is
!                       may be CORNER, but is CENTER by default.
!  (in)      complete - An optional argument indicating whether the halo updates
!                       should be initiated immediately or wait for second 
!                       pass_..._start call.  Omitting complete is the same as 
!                       setting complete to .true.
    array = 2*array
  END SUBROUTINE START_VAR_GROUP_UPDATE_2D
!  Differentiation of start_var_group_update_3d in forward (tangent) mode:
!   variations   of useful results: array
!   with respect to varying inputs: array
  SUBROUTINE START_VAR_GROUP_UPDATE_3D_TLM(group, array, array_tl, &
&   domain, flags, position, whalo, ehalo, shalo, nhalo, complete)
    IMPLICIT NONE
!, group_tl
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: group
    REAL, DIMENSION(:, :, :), INTENT(INOUT) :: array
    REAL, DIMENSION(:, :, :), INTENT(INOUT) :: array_tl
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    INTEGER, OPTIONAL, INTENT(IN) :: flags
    INTEGER, OPTIONAL, INTENT(IN) :: position
    INTEGER, OPTIONAL, INTENT(IN) :: whalo, ehalo, shalo, nhalo
    LOGICAL, OPTIONAL, INTENT(IN) :: complete
    REAL :: d_type
    LOGICAL :: is_complete
! Arguments: 
!  (inout)   group - The data type that store information for group update. 
!                    This data will be used in do_group_pass.
!  (inout)   array - The array which is having its halos points exchanged.
!  (in)      domain - contains domain information.
!  (in)      flags  - An optional integer indicating which directions the
!                       data should be sent.  
!  (in)      position - An optional argument indicating the position.  This is
!                       may be CORNER, but is CENTER by default.
!  (in)      complete - An optional argument indicating whether the halo updates
!                       should be initiated immediately or wait for second 
!                       pass_..._start call.  Omitting complete is the same as 
!                       setting complete to .true.
    array_tl = 2*array_tl
    array = 2*array
  END SUBROUTINE START_VAR_GROUP_UPDATE_3D_TLM
  SUBROUTINE START_VAR_GROUP_UPDATE_3D(group, array, domain, flags, &
&   position, whalo, ehalo, shalo, nhalo, complete)
    IMPLICIT NONE
!, group_tl
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: group
    REAL, DIMENSION(:, :, :), INTENT(INOUT) :: array
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    INTEGER, OPTIONAL, INTENT(IN) :: flags
    INTEGER, OPTIONAL, INTENT(IN) :: position
    INTEGER, OPTIONAL, INTENT(IN) :: whalo, ehalo, shalo, nhalo
    LOGICAL, OPTIONAL, INTENT(IN) :: complete
    REAL :: d_type
    LOGICAL :: is_complete
! Arguments: 
!  (inout)   group - The data type that store information for group update. 
!                    This data will be used in do_group_pass.
!  (inout)   array - The array which is having its halos points exchanged.
!  (in)      domain - contains domain information.
!  (in)      flags  - An optional integer indicating which directions the
!                       data should be sent.  
!  (in)      position - An optional argument indicating the position.  This is
!                       may be CORNER, but is CENTER by default.
!  (in)      complete - An optional argument indicating whether the halo updates
!                       should be initiated immediately or wait for second 
!                       pass_..._start call.  Omitting complete is the same as 
!                       setting complete to .true.
    array = 2*array
  END SUBROUTINE START_VAR_GROUP_UPDATE_3D
!  Differentiation of start_var_group_update_4d in forward (tangent) mode:
!   variations   of useful results: array
!   with respect to varying inputs: array
  SUBROUTINE START_VAR_GROUP_UPDATE_4D_TLM(group, array, array_tl, &
&   domain, flags, position, whalo, ehalo, shalo, nhalo, complete)
    IMPLICIT NONE
!, group_tl
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: group
    REAL, DIMENSION(:, :, :, :), INTENT(INOUT) :: array
    REAL, DIMENSION(:, :, :, :), INTENT(INOUT) :: array_tl
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    INTEGER, OPTIONAL, INTENT(IN) :: flags
    INTEGER, OPTIONAL, INTENT(IN) :: position
    INTEGER, OPTIONAL, INTENT(IN) :: whalo, ehalo, shalo, nhalo
    LOGICAL, OPTIONAL, INTENT(IN) :: complete
    REAL :: d_type
    LOGICAL :: is_complete
! Arguments: 
!  (inout)   group - The data type that store information for group update. 
!                    This data will be used in do_group_pass.
!  (inout)   array - The array which is having its halos points exchanged.
!  (in)      domain - contains domain information.
!  (in)      flags  - An optional integer indicating which directions the
!                       data should be sent.  
!  (in)      position - An optional argument indicating the position.  This is
!                       may be CORNER, but is CENTER by default.
!  (in)      complete - An optional argument indicating whether the halo updates
!                       should be initiated immediately or wait for second 
!                       pass_..._start call.  Omitting complete is the same as 
!                       setting complete to .true.
    INTEGER :: dirflag
    array_tl = 2*array_tl
    array = 2*array
  END SUBROUTINE START_VAR_GROUP_UPDATE_4D_TLM
  SUBROUTINE START_VAR_GROUP_UPDATE_4D(group, array, domain, flags, &
&   position, whalo, ehalo, shalo, nhalo, complete)
    IMPLICIT NONE
!, group_tl
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: group
    REAL, DIMENSION(:, :, :, :), INTENT(INOUT) :: array
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    INTEGER, OPTIONAL, INTENT(IN) :: flags
    INTEGER, OPTIONAL, INTENT(IN) :: position
    INTEGER, OPTIONAL, INTENT(IN) :: whalo, ehalo, shalo, nhalo
    LOGICAL, OPTIONAL, INTENT(IN) :: complete
    REAL :: d_type
    LOGICAL :: is_complete
! Arguments: 
!  (inout)   group - The data type that store information for group update. 
!                    This data will be used in do_group_pass.
!  (inout)   array - The array which is having its halos points exchanged.
!  (in)      domain - contains domain information.
!  (in)      flags  - An optional integer indicating which directions the
!                       data should be sent.  
!  (in)      position - An optional argument indicating the position.  This is
!                       may be CORNER, but is CENTER by default.
!  (in)      complete - An optional argument indicating whether the halo updates
!                       should be initiated immediately or wait for second 
!                       pass_..._start call.  Omitting complete is the same as 
!                       setting complete to .true.
    INTEGER :: dirflag
    array = 2*array
  END SUBROUTINE START_VAR_GROUP_UPDATE_4D
  SUBROUTINE START_VECTOR_GROUP_UPDATE_2D(group, u_cmpt, v_cmpt, domain&
&   , flags, gridtype, whalo, ehalo, shalo, nhalo, complete)
    IMPLICIT NONE
!, group_tl
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: group
    REAL, DIMENSION(:, :), INTENT(INOUT) :: u_cmpt, v_cmpt
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    INTEGER, OPTIONAL, INTENT(IN) :: flags
    INTEGER, OPTIONAL, INTENT(IN) :: gridtype
    INTEGER, OPTIONAL, INTENT(IN) :: whalo, ehalo, shalo, nhalo
    LOGICAL, OPTIONAL, INTENT(IN) :: complete
    REAL :: d_type
    LOGICAL :: is_complete
! Arguments: 
!  (inout)   group - The data type that store information for group update. 
!                    This data will be used in do_group_pass.
!  (inout)   u_cmpt - The nominal zonal (u) component of the vector pair which
!                     is having its halos points exchanged.
!  (inout)   v_cmpt - The nominal meridional (v) component of the vector pair
!                     which is having its halos points exchanged. 
!  (in)      domain - Contains domain decomposition information.
!  (in)      flags - An optional integer indicating which directions the
!                        data should be sent. 
!  (in)      gridtype - An optional flag, which may be one of A_GRID, BGRID_NE,
!                      CGRID_NE or DGRID_NE, indicating where the two components of the
!                      vector are discretized. 
!  (in)      complete - An optional argument indicating whether the halo updates
!                       should be initiated immediately or wait for second 
!                       pass_..._start call.  Omitting complete is the same as 
!                       setting complete to .true.
    u_cmpt = 2*u_cmpt
    v_cmpt = 2*v_cmpt
  END SUBROUTINE START_VECTOR_GROUP_UPDATE_2D
!  Differentiation of start_vector_group_update_3d in forward (tangent) mode:
!   variations   of useful results: u_cmpt v_cmpt
!   with respect to varying inputs: u_cmpt v_cmpt
  SUBROUTINE START_VECTOR_GROUP_UPDATE_3D_TLM(group, u_cmpt, u_cmpt_tl, &
&   v_cmpt, v_cmpt_tl, domain, flags, gridtype, whalo, ehalo, shalo, &
&   nhalo, complete)
    IMPLICIT NONE
!, group_tl
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: group
    REAL, DIMENSION(:, :, :), INTENT(INOUT) :: u_cmpt, v_cmpt
    REAL, DIMENSION(:, :, :), INTENT(INOUT) :: u_cmpt_tl, v_cmpt_tl
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    INTEGER, OPTIONAL, INTENT(IN) :: flags
    INTEGER, OPTIONAL, INTENT(IN) :: gridtype
    INTEGER, OPTIONAL, INTENT(IN) :: whalo, ehalo, shalo, nhalo
    LOGICAL, OPTIONAL, INTENT(IN) :: complete
    REAL :: d_type
    LOGICAL :: is_complete
! Arguments: 
!  (inout)   group - The data type that store information for group update. 
!                    This data will be used in do_group_pass.
!  (inout)   u_cmpt - The nominal zonal (u) component of the vector pair which
!                     is having its halos points exchanged.
!  (inout)   v_cmpt - The nominal meridional (v) component of the vector pair
!                     which is having its halos points exchanged. 
!  (in)      domain - Contains domain decomposition information.
!  (in)      flags - An optional integer indicating which directions the
!                        data should be sent. 
!  (in)      gridtype - An optional flag, which may be one of A_GRID, BGRID_NE,
!                      CGRID_NE or DGRID_NE, indicating where the two components of the
!                      vector are discretized. 
!  (in)      complete - An optional argument indicating whether the halo updates
!                       should be initiated immediately or wait for second 
!                       pass_..._start call.  Omitting complete is the same as 
!                       setting complete to .true.
    u_cmpt_tl = 2*u_cmpt_tl
    u_cmpt = 2*u_cmpt
    v_cmpt_tl = 2*v_cmpt_tl
    v_cmpt = 2*v_cmpt
  END SUBROUTINE START_VECTOR_GROUP_UPDATE_3D_TLM
  SUBROUTINE START_VECTOR_GROUP_UPDATE_3D(group, u_cmpt, v_cmpt, domain&
&   , flags, gridtype, whalo, ehalo, shalo, nhalo, complete)
    IMPLICIT NONE
!, group_tl
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: group
    REAL, DIMENSION(:, :, :), INTENT(INOUT) :: u_cmpt, v_cmpt
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    INTEGER, OPTIONAL, INTENT(IN) :: flags
    INTEGER, OPTIONAL, INTENT(IN) :: gridtype
    INTEGER, OPTIONAL, INTENT(IN) :: whalo, ehalo, shalo, nhalo
    LOGICAL, OPTIONAL, INTENT(IN) :: complete
    REAL :: d_type
    LOGICAL :: is_complete
! Arguments: 
!  (inout)   group - The data type that store information for group update. 
!                    This data will be used in do_group_pass.
!  (inout)   u_cmpt - The nominal zonal (u) component of the vector pair which
!                     is having its halos points exchanged.
!  (inout)   v_cmpt - The nominal meridional (v) component of the vector pair
!                     which is having its halos points exchanged. 
!  (in)      domain - Contains domain decomposition information.
!  (in)      flags - An optional integer indicating which directions the
!                        data should be sent. 
!  (in)      gridtype - An optional flag, which may be one of A_GRID, BGRID_NE,
!                      CGRID_NE or DGRID_NE, indicating where the two components of the
!                      vector are discretized. 
!  (in)      complete - An optional argument indicating whether the halo updates
!                       should be initiated immediately or wait for second 
!                       pass_..._start call.  Omitting complete is the same as 
!                       setting complete to .true.
    u_cmpt = 2*u_cmpt
    v_cmpt = 2*v_cmpt
  END SUBROUTINE START_VECTOR_GROUP_UPDATE_3D
! complete_group_halo_update
! --------------------------
  SUBROUTINE COMPLETE_GROUP_HALO_UPDATE(group, domain)
    IMPLICIT NONE
! Arguments: 
!  (inout)   group - The data type that store information for group update. 
!                    This data will be used in do_group_pass.
!  (inout)   array - The array which is having its halos points exchanged.
!  (in)      domain - contains domain information.
!array = 2*array
!, group_tl
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: group
!real, dimension(:,:),         intent(inout) :: array
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
  END SUBROUTINE COMPLETE_GROUP_HALO_UPDATE
END MODULE FV_MP_MOD_DIFF
