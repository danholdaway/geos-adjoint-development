!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
MODULE FV_GRID_UTILS_MOD_D
  USE FV_ARRAYS_MOD_D, ONLY : real4, real8, fvprc
  USE FV_ARRAYS_MOD_D, ONLY : fv_grid_type, fv_grid_bounds_type, r_grid
  USE MPP_DOMAINS_MOD_D, ONLY : domain2d, dgrid_ne, mpp_update_domains, &
& mpp_update_domains_tlm
  USE MPP_DOMAINS_MOD_D, ONLY : mpp_global_sum, mpp_global_sum_tlm, &
& bitwise_exact_sum
  USE FV_MP_MOD_D, ONLY : mp_reduce_sum
  USE FV_TIMING_MOD, ONLY : timing_on, timing_off
  IMPLICIT NONE
! real(FVPRC) function g_sum(domain, p, ifirst, ilast, jfirst, jlast, ngc, area, mode, reproduce)
!! Fast version of globalsum 
!      integer, intent(IN) :: ifirst, ilast
!      integer, intent(IN) :: jfirst, jlast, ngc
!      integer, intent(IN) :: mode  ! if ==1 divided by area
!      logical, intent(in), optional :: reproduce
!      real(FVPRC), intent(IN) :: p(ifirst:ilast,jfirst:jlast)      ! field to be summed
!      real(kind=R_GRID), intent(IN) :: area(ifirst-ngc:ilast+ngc,jfirst-ngc:jlast+ngc)
!      type(domain2d), intent(IN) :: domain
!      integer :: i,j
!      real(FVPRC) gsum
!      !logical, SAVE :: g_sum_initialized = .false.
!      real(kind=R_GRID) :: global_area
!        
!      global_area = 1.0 !Not acutally needed
!
!      gsum = 0.
!      do j=jfirst,jlast
!         do i=ifirst,ilast
!            gsum = gsum + p(i,j)*area(i,j)
!         enddo
!      enddo
!
!      if ( mode==1 ) then
!           g_sum = gsum / global_area
!      else
!           g_sum = gsum
!      endif
!
! end function g_sum
  PRIVATE 
  REAL(fvprc), PARAMETER :: big_number=1.e8
  REAL(fvprc), PARAMETER :: ptop_min=1.e-8
  INTEGER, PARAMETER :: f_p=SELECTED_REAL_KIND(20)
  PUBLIC f_p, big_number, ptop_min
  PUBLIC great_circle_dist
  PUBLIC cubed_to_latlon
  PUBLIC cubed_to_latlon_tlm
  PUBLIC c2l_ord2
  PUBLIC c2l_ord2_tlm
  PUBLIC c2l_ord4
  PUBLIC c2l_ord4_tlm
  PUBLIC g_sum
  PUBLIC g_sum_tlm

CONTAINS
!  Differentiation of cubed_to_latlon in forward (tangent) mode (with options r8):
!   variations   of useful results: u v
!   with respect to varying inputs: u v
  SUBROUTINE CUBED_TO_LATLON_TLM(u, u_tl, v, v_tl, ua, va, gridstruct, &
&   npx, npy, km, mode, grid_type, domain, nested, c2l_ord, bd)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: km, npx, npy, grid_type, c2l_ord
! update if present
    INTEGER, INTENT(IN) :: mode
    TYPE(FV_GRID_TYPE), INTENT(IN) :: gridstruct
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, km)
    REAL(fvprc), INTENT(INOUT) :: u_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   km)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(INOUT) :: v_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   km)
    REAL(fvprc), INTENT(OUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(OUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    LOGICAL, INTENT(IN) :: nested
    IF (c2l_ord .EQ. 2) THEN
      CALL C2L_ORD2(u, v, ua, va, gridstruct, km, grid_type, bd)
    ELSE
      CALL C2L_ORD4_TLM(u, u_tl, v, v_tl, ua, va, gridstruct, npx, npy, &
&                 km, grid_type, domain, nested, mode, bd)
    END IF
  END SUBROUTINE CUBED_TO_LATLON_TLM
  SUBROUTINE CUBED_TO_LATLON(u, v, ua, va, gridstruct, npx, npy, km, &
&   mode, grid_type, domain, nested, c2l_ord, bd)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: km, npx, npy, grid_type, c2l_ord
! update if present
    INTEGER, INTENT(IN) :: mode
    TYPE(FV_GRID_TYPE), INTENT(IN) :: gridstruct
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, km)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(OUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(OUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    LOGICAL, INTENT(IN) :: nested
    IF (c2l_ord .EQ. 2) THEN
      CALL C2L_ORD2(u, v, ua, va, gridstruct, km, grid_type, bd)
    ELSE
      CALL C2L_ORD4(u, v, ua, va, gridstruct, npx, npy, km, grid_type, &
&             domain, nested, mode, bd)
    END IF
  END SUBROUTINE CUBED_TO_LATLON
!  Differentiation of c2l_ord4 in forward (tangent) mode (with options r8):
!   variations   of useful results: u v
!   with respect to varying inputs: u v
  SUBROUTINE C2L_ORD4_TLM(u, u_tl, v, v_tl, ua, va, gridstruct, npx, npy&
&   , km, grid_type, domain, nested, mode, bd)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: km, npx, npy, grid_type
! update if present
    INTEGER, INTENT(IN) :: mode
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, km)
    REAL(fvprc), INTENT(INOUT) :: u_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   km)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(INOUT) :: v_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   km)
    REAL(fvprc), INTENT(OUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(OUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    LOGICAL, INTENT(IN) :: nested
! Local 
! 4-pt Lagrange interpolation
    REAL(fvprc), SAVE :: a1=0.5625
    REAL(fvprc), SAVE :: a2=-0.0625
    REAL(fvprc), SAVE :: c1=1.125
    REAL(fvprc), SAVE :: c2=-0.125
    REAL(fvprc) :: utmp(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: vtmp(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: wu(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: wv(bd%is:bd%ie+1, bd%js:bd%je)
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    IF (mode .GT. 0) CALL MPP_UPDATE_DOMAINS_TLM(u, u_tl, v, v_tl, &
&                                          domain, gridtype=dgrid_ne)
!call timing_on('COMM_TOTAL')
!call timing_off('COMM_TOTAL')
!$OMP parallel do default(none) shared(is,ie,js,je,km,npx,npy,grid_type,nested,c2,c1, &
!$OMP                                  u,v,gridstruct,ua,va,a1,a2)         &
!$OMP                          private(utmp, vtmp, wu, wv)
    DO k=1,km
      IF (grid_type .LT. 4) THEN
!nested
        IF (nested) THEN
          IF (1 .LT. js) THEN
            max1 = js
          ELSE
            max1 = 1
          END IF
          IF (npy - 1 .GT. je) THEN
            min1 = je
          ELSE
            min1 = npy - 1
          END IF
          DO j=max1,min1
            IF (1 .LT. is) THEN
              max2 = is
            ELSE
              max2 = 1
            END IF
            IF (npx - 1 .GT. ie) THEN
              min2 = ie
            ELSE
              min2 = npx - 1
            END IF
            DO i=max2,min2
              utmp(i, j) = c2*(u(i, j-1, k)+u(i, j+2, k)) + c1*(u(i, j, &
&               k)+u(i, j+1, k))
              vtmp(i, j) = c2*(v(i-1, j, k)+v(i+2, j, k)) + c1*(v(i, j, &
&               k)+v(i+1, j, k))
            END DO
          END DO
        ELSE
          IF (2 .LT. js) THEN
            max3 = js
          ELSE
            max3 = 2
          END IF
          IF (npy - 2 .GT. je) THEN
            min3 = je
          ELSE
            min3 = npy - 2
          END IF
          DO j=max3,min3
            IF (2 .LT. is) THEN
              max4 = is
            ELSE
              max4 = 2
            END IF
            IF (npx - 2 .GT. ie) THEN
              min4 = ie
            ELSE
              min4 = npx - 2
            END IF
            DO i=max4,min4
              utmp(i, j) = c2*(u(i, j-1, k)+u(i, j+2, k)) + c1*(u(i, j, &
&               k)+u(i, j+1, k))
              vtmp(i, j) = c2*(v(i-1, j, k)+v(i+2, j, k)) + c1*(v(i, j, &
&               k)+v(i+1, j, k))
            END DO
          END DO
          IF (js .EQ. 1) THEN
            DO i=is,ie+1
              wv(i, 1) = v(i, 1, k)*gridstruct%dy(i, 1)
            END DO
            DO i=is,ie
              vtmp(i, 1) = 2.*(wv(i, 1)+wv(i+1, 1))/(gridstruct%dy(i, 1)&
&               +gridstruct%dy(i+1, 1))
              utmp(i, 1) = 2.*(u(i, 1, k)*gridstruct%dx(i, 1)+u(i, 2, k)&
&               *gridstruct%dx(i, 2))/(gridstruct%dx(i, 1)+gridstruct%dx&
&               (i, 2))
            END DO
          END IF
!!!         vtmp(i,1) = (wv(i,1) + wv(i+1,1)) * gridstruct%rdya(i,1)
!!!         utmp(i,1) = (u(i,1,k)*gridstruct%dx(i,1) + u(i,2,k)*gridstruct%dx(i,2)) * gridstruct%rdxa(i,1)
          IF (je + 1 .EQ. npy) THEN
            j = npy - 1
            DO i=is,ie+1
              wv(i, j) = v(i, j, k)*gridstruct%dy(i, j)
            END DO
            DO i=is,ie
              vtmp(i, j) = 2.*(wv(i, j)+wv(i+1, j))/(gridstruct%dy(i, j)&
&               +gridstruct%dy(i+1, j))
              utmp(i, j) = 2.*(u(i, j, k)*gridstruct%dx(i, j)+u(i, j+1, &
&               k)*gridstruct%dx(i, j+1))/(gridstruct%dx(i, j)+&
&               gridstruct%dx(i, j+1))
            END DO
          END IF
!!!         vtmp(i,j) = (wv(i,j) + wv(i+1,j)) * gridstruct%rdya(i,j)
!!!         utmp(i,j) = (u(i,j,k)*gridstruct%dx(i,j) + u(i,j+1,k)*gridstruct%dx(i,j+1)) * gridstruct%rdxa(i,j)
          IF (is .EQ. 1) THEN
            i = 1
            DO j=js,je
              wv(1, j) = v(1, j, k)*gridstruct%dy(1, j)
              wv(2, j) = v(2, j, k)*gridstruct%dy(2, j)
            END DO
            DO j=js,je+1
              wu(i, j) = u(i, j, k)*gridstruct%dx(i, j)
            END DO
            DO j=js,je
              utmp(i, j) = 2.*(wu(i, j)+wu(i, j+1))/(gridstruct%dx(i, j)&
&               +gridstruct%dx(i, j+1))
              vtmp(i, j) = 2.*(wv(1, j)+wv(2, j))/(gridstruct%dy(1, j)+&
&               gridstruct%dy(2, j))
            END DO
          END IF
!!!      utmp(i,j) = (wu(i,j) + wu(i,  j+1)) * gridstruct%rdxa(i,j)
!!!      vtmp(i,j) = (wv(i,j) + wv(i+1,j  )) * gridstruct%rdya(i,j)
          IF (ie + 1 .EQ. npx) THEN
            i = npx - 1
            DO j=js,je
              wv(i, j) = v(i, j, k)*gridstruct%dy(i, j)
              wv(i+1, j) = v(i+1, j, k)*gridstruct%dy(i+1, j)
            END DO
            DO j=js,je+1
              wu(i, j) = u(i, j, k)*gridstruct%dx(i, j)
            END DO
            DO j=js,je
              utmp(i, j) = 2.*(wu(i, j)+wu(i, j+1))/(gridstruct%dx(i, j)&
&               +gridstruct%dx(i, j+1))
              vtmp(i, j) = 2.*(wv(i, j)+wv(i+1, j))/(gridstruct%dy(i, j)&
&               +gridstruct%dy(i+1, j))
            END DO
          END IF
        END IF
!!!      utmp(i,j) = (wu(i,j) + wu(i,  j+1)) * gridstruct%rdxa(i,j)
!!!      vtmp(i,j) = (wv(i,j) + wv(i+1,j  )) * gridstruct%rdya(i,j)
!Transform local a-grid winds into latitude-longitude coordinates
        DO j=js,je
          DO i=is,ie
            ua(i, j, k) = gridstruct%a11(i, j)*utmp(i, j) + gridstruct%&
&             a12(i, j)*vtmp(i, j)
            va(i, j, k) = gridstruct%a21(i, j)*utmp(i, j) + gridstruct%&
&             a22(i, j)*vtmp(i, j)
          END DO
        END DO
      ELSE
! Simple Cartesian Geometry:
        DO j=js,je
          DO i=is,ie
            ua(i, j, k) = a2*(u(i, j-1, k)+u(i, j+2, k)) + a1*(u(i, j, k&
&             )+u(i, j+1, k))
            va(i, j, k) = a2*(v(i-1, j, k)+v(i+2, j, k)) + a1*(v(i, j, k&
&             )+v(i+1, j, k))
          END DO
        END DO
      END IF
    END DO
  END SUBROUTINE C2L_ORD4_TLM
  SUBROUTINE C2L_ORD4(u, v, ua, va, gridstruct, npx, npy, km, grid_type&
&   , domain, nested, mode, bd)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: km, npx, npy, grid_type
! update if present
    INTEGER, INTENT(IN) :: mode
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, km)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(OUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(OUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    LOGICAL, INTENT(IN) :: nested
! Local 
! 4-pt Lagrange interpolation
    REAL(fvprc), SAVE :: a1=0.5625
    REAL(fvprc), SAVE :: a2=-0.0625
    REAL(fvprc), SAVE :: c1=1.125
    REAL(fvprc), SAVE :: c2=-0.125
    REAL(fvprc) :: utmp(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: vtmp(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: wu(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: wv(bd%is:bd%ie+1, bd%js:bd%je)
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    IF (mode .GT. 0) CALL MPP_UPDATE_DOMAINS(u, v, domain, gridtype=&
&                                      dgrid_ne)
!call timing_on('COMM_TOTAL')
!call timing_off('COMM_TOTAL')
!$OMP parallel do default(none) shared(is,ie,js,je,km,npx,npy,grid_type,nested,c2,c1, &
!$OMP                                  u,v,gridstruct,ua,va,a1,a2)         &
!$OMP                          private(utmp, vtmp, wu, wv)
    DO k=1,km
      IF (grid_type .LT. 4) THEN
!nested
        IF (nested) THEN
          IF (1 .LT. js) THEN
            max1 = js
          ELSE
            max1 = 1
          END IF
          IF (npy - 1 .GT. je) THEN
            min1 = je
          ELSE
            min1 = npy - 1
          END IF
          DO j=max1,min1
            IF (1 .LT. is) THEN
              max2 = is
            ELSE
              max2 = 1
            END IF
            IF (npx - 1 .GT. ie) THEN
              min2 = ie
            ELSE
              min2 = npx - 1
            END IF
            DO i=max2,min2
              utmp(i, j) = c2*(u(i, j-1, k)+u(i, j+2, k)) + c1*(u(i, j, &
&               k)+u(i, j+1, k))
              vtmp(i, j) = c2*(v(i-1, j, k)+v(i+2, j, k)) + c1*(v(i, j, &
&               k)+v(i+1, j, k))
            END DO
          END DO
        ELSE
          IF (2 .LT. js) THEN
            max3 = js
          ELSE
            max3 = 2
          END IF
          IF (npy - 2 .GT. je) THEN
            min3 = je
          ELSE
            min3 = npy - 2
          END IF
          DO j=max3,min3
            IF (2 .LT. is) THEN
              max4 = is
            ELSE
              max4 = 2
            END IF
            IF (npx - 2 .GT. ie) THEN
              min4 = ie
            ELSE
              min4 = npx - 2
            END IF
            DO i=max4,min4
              utmp(i, j) = c2*(u(i, j-1, k)+u(i, j+2, k)) + c1*(u(i, j, &
&               k)+u(i, j+1, k))
              vtmp(i, j) = c2*(v(i-1, j, k)+v(i+2, j, k)) + c1*(v(i, j, &
&               k)+v(i+1, j, k))
            END DO
          END DO
          IF (js .EQ. 1) THEN
            DO i=is,ie+1
              wv(i, 1) = v(i, 1, k)*gridstruct%dy(i, 1)
            END DO
            DO i=is,ie
              vtmp(i, 1) = 2.*(wv(i, 1)+wv(i+1, 1))/(gridstruct%dy(i, 1)&
&               +gridstruct%dy(i+1, 1))
              utmp(i, 1) = 2.*(u(i, 1, k)*gridstruct%dx(i, 1)+u(i, 2, k)&
&               *gridstruct%dx(i, 2))/(gridstruct%dx(i, 1)+gridstruct%dx&
&               (i, 2))
            END DO
          END IF
!!!         vtmp(i,1) = (wv(i,1) + wv(i+1,1)) * gridstruct%rdya(i,1)
!!!         utmp(i,1) = (u(i,1,k)*gridstruct%dx(i,1) + u(i,2,k)*gridstruct%dx(i,2)) * gridstruct%rdxa(i,1)
          IF (je + 1 .EQ. npy) THEN
            j = npy - 1
            DO i=is,ie+1
              wv(i, j) = v(i, j, k)*gridstruct%dy(i, j)
            END DO
            DO i=is,ie
              vtmp(i, j) = 2.*(wv(i, j)+wv(i+1, j))/(gridstruct%dy(i, j)&
&               +gridstruct%dy(i+1, j))
              utmp(i, j) = 2.*(u(i, j, k)*gridstruct%dx(i, j)+u(i, j+1, &
&               k)*gridstruct%dx(i, j+1))/(gridstruct%dx(i, j)+&
&               gridstruct%dx(i, j+1))
            END DO
          END IF
!!!         vtmp(i,j) = (wv(i,j) + wv(i+1,j)) * gridstruct%rdya(i,j)
!!!         utmp(i,j) = (u(i,j,k)*gridstruct%dx(i,j) + u(i,j+1,k)*gridstruct%dx(i,j+1)) * gridstruct%rdxa(i,j)
          IF (is .EQ. 1) THEN
            i = 1
            DO j=js,je
              wv(1, j) = v(1, j, k)*gridstruct%dy(1, j)
              wv(2, j) = v(2, j, k)*gridstruct%dy(2, j)
            END DO
            DO j=js,je+1
              wu(i, j) = u(i, j, k)*gridstruct%dx(i, j)
            END DO
            DO j=js,je
              utmp(i, j) = 2.*(wu(i, j)+wu(i, j+1))/(gridstruct%dx(i, j)&
&               +gridstruct%dx(i, j+1))
              vtmp(i, j) = 2.*(wv(1, j)+wv(2, j))/(gridstruct%dy(1, j)+&
&               gridstruct%dy(2, j))
            END DO
          END IF
!!!      utmp(i,j) = (wu(i,j) + wu(i,  j+1)) * gridstruct%rdxa(i,j)
!!!      vtmp(i,j) = (wv(i,j) + wv(i+1,j  )) * gridstruct%rdya(i,j)
          IF (ie + 1 .EQ. npx) THEN
            i = npx - 1
            DO j=js,je
              wv(i, j) = v(i, j, k)*gridstruct%dy(i, j)
              wv(i+1, j) = v(i+1, j, k)*gridstruct%dy(i+1, j)
            END DO
            DO j=js,je+1
              wu(i, j) = u(i, j, k)*gridstruct%dx(i, j)
            END DO
            DO j=js,je
              utmp(i, j) = 2.*(wu(i, j)+wu(i, j+1))/(gridstruct%dx(i, j)&
&               +gridstruct%dx(i, j+1))
              vtmp(i, j) = 2.*(wv(i, j)+wv(i+1, j))/(gridstruct%dy(i, j)&
&               +gridstruct%dy(i+1, j))
            END DO
          END IF
        END IF
!!!      utmp(i,j) = (wu(i,j) + wu(i,  j+1)) * gridstruct%rdxa(i,j)
!!!      vtmp(i,j) = (wv(i,j) + wv(i+1,j  )) * gridstruct%rdya(i,j)
!Transform local a-grid winds into latitude-longitude coordinates
        DO j=js,je
          DO i=is,ie
            ua(i, j, k) = gridstruct%a11(i, j)*utmp(i, j) + gridstruct%&
&             a12(i, j)*vtmp(i, j)
            va(i, j, k) = gridstruct%a21(i, j)*utmp(i, j) + gridstruct%&
&             a22(i, j)*vtmp(i, j)
          END DO
        END DO
      ELSE
! Simple Cartesian Geometry:
        DO j=js,je
          DO i=is,ie
            ua(i, j, k) = a2*(u(i, j-1, k)+u(i, j+2, k)) + a1*(u(i, j, k&
&             )+u(i, j+1, k))
            va(i, j, k) = a2*(v(i-1, j, k)+v(i+2, j, k)) + a1*(v(i, j, k&
&             )+v(i+1, j, k))
          END DO
        END DO
      END IF
    END DO
  END SUBROUTINE C2L_ORD4
!  Differentiation of c2l_ord2 in forward (tangent) mode (with options r8):
!   variations   of useful results: ua va
!   with respect to varying inputs: u v ua va
  SUBROUTINE C2L_ORD2_TLM(u, u_tl, v, v_tl, ua, ua_tl, va, va_tl, &
&   gridstruct, km, grid_type, bd)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: km, grid_type
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, km)
    REAL(fvprc), INTENT(IN) :: u_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1, km)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(IN) :: v_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed, km)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
!
    REAL(fvprc), INTENT(OUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(OUT) :: ua_tl(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(OUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(OUT) :: va_tl(bd%isd:bd%ied, bd%jsd:bd%jed, km)
!--------------------------------------------------------------
! Local 
    REAL(fvprc) :: wu(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: wu_tl(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: wv(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: wv_tl(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: u1(bd%is:bd%ie), v1(bd%is:bd%ie)
    REAL(fvprc) :: u1_tl(bd%is:bd%ie), v1_tl(bd%is:bd%ie)
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
!  real(FVPRC), dimension(:,:), pointer :: a11, a12, a21, a22
!  real(FVPRC), dimension(:,:), pointer :: dx, dy, rdxa, rdya
!  a11 => gridstruct%a11
!  a12 => gridstruct%a12
!  a21 => gridstruct%a21
!  a22 => gridstruct%a22
!  dx   => gridstruct%dx
!  dy   => gridstruct%dy
!  rdxa => gridstruct%rdxa
!  rdya => gridstruct%rdya
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    wu_tl = 0.0_FVPRC
    v1_tl = 0.0_FVPRC
    wv_tl = 0.0_FVPRC
    u1_tl = 0.0_FVPRC
!$OMP parallel do default(none) shared(is,ie,js,je,km,grid_type,u,dx,v,dy,ua,va,a11,a12,a21,a22) &
!$OMP                          private(u1, v1, wu, wv)
    DO k=1,km
      IF (grid_type .LT. 4) THEN
        DO j=js,je+1
          DO i=is,ie
            wu_tl(i, j) = gridstruct%dx(i, j)*u_tl(i, j, k)
            wu(i, j) = u(i, j, k)*gridstruct%dx(i, j)
          END DO
        END DO
        DO j=js,je
          DO i=is,ie+1
            wv_tl(i, j) = gridstruct%dy(i, j)*v_tl(i, j, k)
            wv(i, j) = v(i, j, k)*gridstruct%dy(i, j)
          END DO
        END DO
        DO j=js,je
          DO i=is,ie
! Co-variant to Co-variant "vorticity-conserving" interpolation
            u1_tl(i) = 2.*(wu_tl(i, j)+wu_tl(i, j+1))/(gridstruct%dx(i, &
&             j)+gridstruct%dx(i, j+1))
            u1(i) = 2.*(wu(i, j)+wu(i, j+1))/(gridstruct%dx(i, j)+&
&             gridstruct%dx(i, j+1))
            v1_tl(i) = 2.*(wv_tl(i, j)+wv_tl(i+1, j))/(gridstruct%dy(i, &
&             j)+gridstruct%dy(i+1, j))
            v1(i) = 2.*(wv(i, j)+wv(i+1, j))/(gridstruct%dy(i, j)+&
&             gridstruct%dy(i+1, j))
!!!          u1(i) = (wu(i,j) + wu(i,j+1)) * gridstruct%rdxa(i,j)
!!!          v1(i) = (wv(i,j) + wv(i+1,j)) * gridstruct%rdya(i,j)
! Cubed (cell center co-variant winds) to lat-lon:
            ua_tl(i, j, k) = gridstruct%a11(i, j)*u1_tl(i) + gridstruct%&
&             a12(i, j)*v1_tl(i)
            ua(i, j, k) = gridstruct%a11(i, j)*u1(i) + gridstruct%a12(i&
&             , j)*v1(i)
            va_tl(i, j, k) = gridstruct%a21(i, j)*u1_tl(i) + gridstruct%&
&             a22(i, j)*v1_tl(i)
            va(i, j, k) = gridstruct%a21(i, j)*u1(i) + gridstruct%a22(i&
&             , j)*v1(i)
          END DO
        END DO
      ELSE
! 2nd order:
        DO j=js,je
          DO i=is,ie
            ua_tl(i, j, k) = 0.5*(u_tl(i, j, k)+u_tl(i, j+1, k))
            ua(i, j, k) = 0.5*(u(i, j, k)+u(i, j+1, k))
            va_tl(i, j, k) = 0.5*(v_tl(i, j, k)+v_tl(i+1, j, k))
            va(i, j, k) = 0.5*(v(i, j, k)+v(i+1, j, k))
          END DO
        END DO
      END IF
    END DO
  END SUBROUTINE C2L_ORD2_TLM
  SUBROUTINE C2L_ORD2(u, v, ua, va, gridstruct, km, grid_type, bd)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: km, grid_type
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, km)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, km)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
!
    REAL(fvprc), INTENT(OUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(OUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, km)
!--------------------------------------------------------------
! Local 
    REAL(fvprc) :: wu(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: wv(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: u1(bd%is:bd%ie), v1(bd%is:bd%ie)
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
!  real(FVPRC), dimension(:,:), pointer :: a11, a12, a21, a22
!  real(FVPRC), dimension(:,:), pointer :: dx, dy, rdxa, rdya
!  a11 => gridstruct%a11
!  a12 => gridstruct%a12
!  a21 => gridstruct%a21
!  a22 => gridstruct%a22
!  dx   => gridstruct%dx
!  dy   => gridstruct%dy
!  rdxa => gridstruct%rdxa
!  rdya => gridstruct%rdya
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
!$OMP parallel do default(none) shared(is,ie,js,je,km,grid_type,u,dx,v,dy,ua,va,a11,a12,a21,a22) &
!$OMP                          private(u1, v1, wu, wv)
    DO k=1,km
      IF (grid_type .LT. 4) THEN
        DO j=js,je+1
          DO i=is,ie
            wu(i, j) = u(i, j, k)*gridstruct%dx(i, j)
          END DO
        END DO
        DO j=js,je
          DO i=is,ie+1
            wv(i, j) = v(i, j, k)*gridstruct%dy(i, j)
          END DO
        END DO
        DO j=js,je
          DO i=is,ie
! Co-variant to Co-variant "vorticity-conserving" interpolation
            u1(i) = 2.*(wu(i, j)+wu(i, j+1))/(gridstruct%dx(i, j)+&
&             gridstruct%dx(i, j+1))
            v1(i) = 2.*(wv(i, j)+wv(i+1, j))/(gridstruct%dy(i, j)+&
&             gridstruct%dy(i+1, j))
!!!          u1(i) = (wu(i,j) + wu(i,j+1)) * gridstruct%rdxa(i,j)
!!!          v1(i) = (wv(i,j) + wv(i+1,j)) * gridstruct%rdya(i,j)
! Cubed (cell center co-variant winds) to lat-lon:
            ua(i, j, k) = gridstruct%a11(i, j)*u1(i) + gridstruct%a12(i&
&             , j)*v1(i)
            va(i, j, k) = gridstruct%a21(i, j)*u1(i) + gridstruct%a22(i&
&             , j)*v1(i)
          END DO
        END DO
      ELSE
! 2nd order:
        DO j=js,je
          DO i=is,ie
            ua(i, j, k) = 0.5*(u(i, j, k)+u(i, j+1, k))
            va(i, j, k) = 0.5*(v(i, j, k)+v(i+1, j, k))
          END DO
        END DO
      END IF
    END DO
  END SUBROUTINE C2L_ORD2
  REAL(fvprc) FUNCTION GREAT_CIRCLE_DIST(q1, q2, radius)
    IMPLICIT NONE
    REAL(kind=r_grid), INTENT(IN) :: q1(2), q2(2)
    REAL(kind=r_grid), INTENT(IN), OPTIONAL :: radius
    REAL(f_p) :: p1(2), p2(2)
    REAL(f_p) :: beta
    INTEGER :: n
    INTRINSIC SIN
    INTRINSIC COS
    INTRINSIC SQRT
    INTRINSIC ASIN
    INTRINSIC PRESENT
    REAL(f_p) :: arg1
    REAL(f_p) :: arg2
    REAL(f_p) :: arg3
    REAL(f_p) :: result1
    REAL(f_p) :: result2
    DO n=1,2
      p1(n) = q1(n)
      p2(n) = q2(n)
    END DO
    arg1 = (p1(2)-p2(2))/2.
    arg2 = (p1(1)-p2(1))/2.
    arg3 = SIN(arg1)**2 + COS(p1(2))*COS(p2(2))*SIN(arg2)**2
    result1 = SQRT(arg3)
    result2 = ASIN(result1)
    beta = result2*2.
    IF (PRESENT(radius)) THEN
      great_circle_dist = radius*beta
    ELSE
! Returns the angle
      great_circle_dist = beta
    END IF
  END FUNCTION GREAT_CIRCLE_DIST
!  Differentiation of g_sum in forward (tangent) mode (with options r8):
!   variations   of useful results: g_sum
!   with respect to varying inputs: p
  REAL(fvprc) FUNCTION G_SUM_TLM(domain, p, p_tl, ifirst, ilast, jfirst&
&   , jlast, ngc, area, mode, reproduce, g_sum)
    IMPLICIT NONE
! Fast version of globalsum 
    INTEGER, INTENT(IN) :: ifirst, ilast
    INTEGER, INTENT(IN) :: jfirst, jlast, ngc
! if ==1 divided by area
    INTEGER, INTENT(IN) :: mode
    LOGICAL, INTENT(IN), OPTIONAL :: reproduce
! field to be summed
    REAL(fvprc), INTENT(IN) :: p(ifirst:ilast, jfirst:jlast)
    REAL(fvprc), INTENT(IN) :: p_tl(ifirst:ilast, jfirst:jlast)
    REAL(kind=r_grid), INTENT(IN) :: area(ifirst-ngc:ilast+ngc, jfirst-&
&   ngc:jlast+ngc)
    TYPE(DOMAIN2D), INTENT(IN) :: domain
    INTEGER :: i, j
    REAL(fvprc) :: gsum
    REAL(fvprc) :: gsum_tl
! field to be summed
    REAL(fvprc) :: gsuma(ifirst:ilast, jfirst:jlast)
    REAL(fvprc) :: gsuma_tl(ifirst:ilast, jfirst:jlast)
    LOGICAL, SAVE :: g_sum_initialized=.false.
    REAL(kind=r_grid) :: global_area
    INTRINSIC PRESENT
    REAL(fvprc) :: g_sum
!if ( .not. g_sum_initialized ) then
!   global_area = mpp_global_sum(domain, area, flags=BITWISE_EXACT_SUM)
!   !if ( is_master() ) write(*,*) 'Global Area=',global_area
!   g_sum_initialized = .true.
!end if
    global_area = 10.e8
!-------------------------
! FMS global sum algorithm:
!-------------------------
    IF (PRESENT(reproduce)) THEN
      IF (reproduce) THEN
        gsum_tl = MPP_GLOBAL_SUM_TLM(domain, p(:, :)*area(ifirst:ilast, &
&         jfirst:jlast), area(ifirst:ilast, jfirst:jlast)*p_tl(:, :), &
&         flags=bitwise_exact_sum, mpp_global_sum_2d=gsum)
      ELSE
        gsum_tl = MPP_GLOBAL_SUM_TLM(domain, p(:, :)*area(ifirst:ilast, &
&         jfirst:jlast), area(ifirst:ilast, jfirst:jlast)*p_tl(:, :), &
&         mpp_global_sum_2d=gsum)
      END IF
    ELSE
!-------------------------
! Quick local sum algorithm
!-------------------------
      gsuma = 0.
      gsuma_tl = 0.0_FVPRC
      DO j=jfirst,jlast
        DO i=ifirst,ilast
          gsuma_tl(i, j) = gsuma_tl(i, j) + area(i, j)*p_tl(i, j)
          gsuma(i, j) = gsuma(i, j) + p(i, j)*area(i, j)
        END DO
      END DO
      gsum_tl = MPP_GLOBAL_SUM_TLM(domain, gsuma, gsuma_tl, &
&       mpp_global_sum_2d=gsum)
    END IF
    IF (mode .EQ. 1) THEN
      g_sum_tlm = gsum_tl/global_area
      g_sum = gsum/global_area
    ELSE
      g_sum_tlm = gsum_tl
      g_sum = gsum
    END IF
  END FUNCTION G_SUM_TLM
  REAL(fvprc) FUNCTION G_SUM(domain, p, ifirst, ilast, jfirst, jlast, &
&   ngc, area, mode, reproduce)
    IMPLICIT NONE
! Fast version of globalsum 
    INTEGER, INTENT(IN) :: ifirst, ilast
    INTEGER, INTENT(IN) :: jfirst, jlast, ngc
! if ==1 divided by area
    INTEGER, INTENT(IN) :: mode
    LOGICAL, INTENT(IN), OPTIONAL :: reproduce
! field to be summed
    REAL(fvprc), INTENT(IN) :: p(ifirst:ilast, jfirst:jlast)
    REAL(kind=r_grid), INTENT(IN) :: area(ifirst-ngc:ilast+ngc, jfirst-&
&   ngc:jlast+ngc)
    TYPE(DOMAIN2D), INTENT(IN) :: domain
    INTEGER :: i, j
    REAL(fvprc) :: gsum
! field to be summed
    REAL(fvprc) :: gsuma(ifirst:ilast, jfirst:jlast)
    LOGICAL, SAVE :: g_sum_initialized=.false.
    REAL(kind=r_grid) :: global_area
    INTRINSIC PRESENT
!if ( .not. g_sum_initialized ) then
!   global_area = mpp_global_sum(domain, area, flags=BITWISE_EXACT_SUM)
!   !if ( is_master() ) write(*,*) 'Global Area=',global_area
!   g_sum_initialized = .true.
!end if
    global_area = 10.e8
!-------------------------
! FMS global sum algorithm:
!-------------------------
    IF (PRESENT(reproduce)) THEN
      IF (reproduce) THEN
        gsum = MPP_GLOBAL_SUM(domain, p(:, :)*area(ifirst:ilast, jfirst:&
&         jlast), flags=bitwise_exact_sum)
      ELSE
        gsum = MPP_GLOBAL_SUM(domain, p(:, :)*area(ifirst:ilast, jfirst:&
&         jlast))
      END IF
    ELSE
!-------------------------
! Quick local sum algorithm
!-------------------------
      gsuma = 0.
      DO j=jfirst,jlast
        DO i=ifirst,ilast
          gsuma(i, j) = gsuma(i, j) + p(i, j)*area(i, j)
        END DO
      END DO
      gsum = MPP_GLOBAL_SUM(domain, gsuma)
    END IF
    IF (mode .EQ. 1) THEN
      g_sum = gsum/global_area
    ELSE
      g_sum = gsum
    END IF
  END FUNCTION G_SUM
END MODULE FV_GRID_UTILS_MOD_D
