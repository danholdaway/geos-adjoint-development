!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
MODULE FV_DYNAMICS_MOD_D
!#ifndef MAPL_MODE
!   use constants_mod,       only: grav, pi, radius, hlv, rdgas, omega, rvgas, cp_vapor
!#else
  USE MAPL_MOD
!#endif
  USE FV_ARRAYS_MOD_D, ONLY : real4, real8, fvprc, r_grid, tiny_number, &
& fv_timing_onoff
  USE DYN_CORE_MOD_D, ONLY : dyn_core, dyn_core_tlm, del2_cubed, &
& del2_cubed_tlm
  USE FV_MAPZ_MOD_D, ONLY : compute_total_energy, &
& compute_total_energy_tlm, lagrangian_to_eulerian, &
& lagrangian_to_eulerian_tlm
  USE FV_TRACER2D_MOD_D, ONLY : tracer_2d, tracer_2d_tlm, tracer_2d_1l, &
& tracer_2d_nested, tracer_2d_nested_tlm
  USE FV_GRID_UTILS_MOD_D, ONLY : cubed_to_latlon, cubed_to_latlon_tlm, &
& c2l_ord2, c2l_ord2_tlm, g_sum, g_sum_tlm
  USE FV_MP_MOD_D, ONLY : is_master
  USE FV_MP_MOD_D, ONLY : group_halo_update_type
  USE FV_MP_MOD_D, ONLY : start_group_halo_update, &
& start_group_halo_update_tlm, complete_group_halo_update
  USE FV_TIMING_MOD, ONLY : timing_on, timing_off
!   use diag_manager_mod,    only: send_data
  USE FV_DIAGNOSTICS_MOD, ONLY : fv_time, prt_mxm, range_check, &
& prt_minmax
  USE MPP_DOMAINS_MOD_D, ONLY : dgrid_ne, cgrid_ne, mpp_update_domains, &
& mpp_update_domains_tlm, domain2d
  USE FIELD_MANAGER_MOD, ONLY : model_atmos
  USE TRACER_MANAGER_MOD, ONLY : get_tracer_index
!   use fv_sg_mod,           only: neg_adj3
!   use fv_nesting_mod,      only: setup_nested_grid_BCs
  USE FV_ARRAYS_MOD_D, ONLY : fv_grid_type, fv_flags_type, fv_atmos_type&
& , fv_nest_type, fv_diag_type, fv_grid_bounds_type
  USE FV_NWP_NUDGE_MOD, ONLY : do_adiabatic_init
  IMPLICIT NONE
!#ifdef MAPL_MODE
! Include the MPI library definitons:
!  include 'mpif.h'
!#endif
  LOGICAL :: rf_initialized=.false.
  LOGICAL :: bad_range
!   real(FVPRC), allocatable ::  rf(:)
  INTEGER :: kmax=1
  REAL(fvprc) :: agrav
!#ifdef HIWPP
!   real(FVPRC), allocatable:: u00(:,:,:), v00(:,:,:)
!#endif
  PRIVATE 
  PUBLIC fv_dynamics
  PUBLIC fv_dynamics_tlm
!---- version number -----
!   character(len=128) :: version = '$Id: fv_dynamics.F90,v 1.2.2.2.2.2.30.1.4.1.2.1.20.2.46.4.4.2.2.3.2.1.6.1.2.1 2017/02/16 03:
!47:47 aoloso Exp $'
!   character(len=128) :: tagname = '$Name: Heracles-UNSTABLE_ncepdyn_Feb222017 $'
!#ifdef MAPL_MODE
  REAL(fvprc), PARAMETER :: radius=mapl_radius
  REAL(fvprc), PARAMETER :: pi=mapl_pi_r8
  REAL(fvprc), PARAMETER :: rdgas=mapl_rgas
  REAL(fvprc), PARAMETER :: grav=mapl_grav
  REAL(fvprc), PARAMETER :: hlv=mapl_alhl
  REAL(fvprc), PARAMETER :: cp_vapor=mapl_cp
  REAL(fvprc), PARAMETER :: rvgas=mapl_rvap
  REAL(fvprc), PARAMETER :: omega=mapl_omega

CONTAINS
!#endif
!-----------------------------------------------------------------------
!     fv_dynamics :: FV dynamical core driver
!-----------------------------------------------------------------------
  SUBROUTINE FV_DYNAMICS_DUMMY(npx, npy, npz, nq_tot, ng, bdt, consv_te&
&   , fill, reproduce_sum, kappa, cp_air, zvir, ptop, ks, ncnst, n_split&
&   , q_split, u, v, w, delz, hydrostatic, pt, delp, q, ps, pe, pk, peln&
&   , pkz, phis, q_con, omga, ua, va, uc, vc, ak, bk, mfx, mfy, cx, cy, &
&   ze0, hybrid_z, gridstruct, flagstruct, neststruct, idiag, bd, &
&   parent_grid, domain, time_total)
    IMPLICIT NONE
! Large time-step
    REAL(fvprc), INTENT(IN) :: bdt
    REAL(fvprc), INTENT(IN) :: consv_te
    REAL(fvprc), INTENT(IN) :: kappa, cp_air
    REAL(fvprc), INTENT(IN) :: zvir, ptop
    REAL(fvprc), INTENT(IN), OPTIONAL :: time_total
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
! transported tracers
    INTEGER, INTENT(IN) :: nq_tot
    INTEGER, INTENT(IN) :: ng
    INTEGER, INTENT(IN) :: ks
    INTEGER, INTENT(IN) :: ncnst
! small-step horizontal dynamics
    INTEGER, INTENT(IN) :: n_split
! tracer
    INTEGER, INTENT(IN) :: q_split
    LOGICAL, INTENT(IN) :: fill
    LOGICAL, INTENT(IN) :: reproduce_sum
    LOGICAL, INTENT(IN) :: hydrostatic
! Using hybrid_z for remapping
    LOGICAL, INTENT(IN) :: hybrid_z
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! D grid zonal wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz), INTENT(&
&   INOUT) :: u
! D grid meridional wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: v
!real(FVPRC), intent(inout) :: w( bd%isd:,bd%jsd:,1:)  !  W (m/s)
!  W (m/s) ! replaced previous line bma
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! temperature (K)
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! pressure thickness (pascal)
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! specific humidity and constituents
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, &
&   ncnst)
!real(FVPRC), intent(inout) :: delz(bd%isd:,bd%jsd:,1:)   ! delta-height (m); non-hydrostatic only
! replace previous line bma
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! height at edges (m); non-hydrostatic
    REAL(fvprc), INTENT(INOUT) :: ze0(bd%is:bd%ie, bd%js:bd%je, npz+1)
!-----------------------------------------------------------------------
! Auxilliary pressure arrays:    
! The 5 vars below can be re-computed from delp and ptop.
!-----------------------------------------------------------------------
! dyn_aux:
! Surface pressure (pascal)
    REAL(fvprc), INTENT(INOUT) :: ps(bd%isd:bd%ied, bd%jsd:bd%jed)
! edge pressure (pascal)
    REAL(fvprc), INTENT(INOUT) :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%&
&   je+1)
! pe**kappa
    REAL(fvprc), INTENT(INOUT) :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
! ln(pe)
    REAL(fvprc), INTENT(INOUT) :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
! finite-volume mean pk
    REAL(fvprc), INTENT(INOUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
!real(FVPRC), intent(inout):: q_con(bd%isd:, bd%jsd:, 1:)
!bma replaced previous line
    REAL(fvprc), INTENT(INOUT) :: q_con(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
!-----------------------------------------------------------------------
! Others:
!-----------------------------------------------------------------------
! Surface geopotential (g*Z_surf)
    REAL(fvprc), INTENT(INOUT) :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
! Vertical pressure velocity (pa/s)
    REAL(fvprc), INTENT(INOUT) :: omga(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! (uc,vc) mostly used as the C grid winds
    REAL(fvprc), INTENT(INOUT) :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: ua, va
    REAL(fvprc), DIMENSION(npz+1), INTENT(IN) :: ak, bk
! Accumulated Mass flux arrays: the "Flux Capacitor"
    REAL(fvprc), INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL(fvprc), INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
! Accumulated Courant number arrays
    REAL(fvprc), INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(INOUT) :: flagstruct
    TYPE(FV_NEST_TYPE), INTENT(INOUT) :: neststruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    TYPE(FV_ATMOS_TYPE), INTENT(INOUT) :: parent_grid
    TYPE(FV_DIAG_TYPE), INTENT(IN) :: idiag
    CALL FV_DYNAMICS(npx, npy, npz, nq_tot, ng, bdt, consv_te, fill, &
&              reproduce_sum, kappa, cp_air, zvir, ptop, ks, ncnst, &
&              n_split, q_split, u, v, w, delz, hydrostatic, pt, delp, q&
&              , ps, pe, pk, peln, pkz, phis, q_con, omga, ua, va, uc, &
&              vc, ak, bk, mfx, mfy, cx, cy, ze0, hybrid_z, gridstruct, &
&              flagstruct, neststruct, idiag, bd, parent_grid, domain, &
&              time_total)
  END SUBROUTINE FV_DYNAMICS_DUMMY
!  Differentiation of fv_dynamics in forward (tangent) mode (with options r8):
!   variations   of useful results: q u v w delp delz pt
!   with respect to varying inputs: q u v w delp delz pt
!   RW status of diff variables: peln:(loc) q:in-out u:in-out v:in-out
!                w:in-out ze0:(loc) delp:in-out ua:(loc) uc:(loc)
!                mfx:(loc) delz:in-out mfy:(loc) omga:(loc) va:(loc)
!                vc:(loc) pkz:(loc) pe:(loc) pk:(loc) ps:(loc)
!                pt:in-out cx:(loc) cy:(loc)
  SUBROUTINE FV_DYNAMICS_TLM(npx, npy, npz, nq_tot, ng, bdt, consv_te, &
&   fill, reproduce_sum, kappa, cp_air, zvir, ptop, ks, ncnst, n_split, &
&   q_split, u, u_tl, v, v_tl, w, w_tl, delz, delz_tl, hydrostatic, pt, &
&   pt_tl, delp, delp_tl, q, q_tl, ps, ps_tl, pe, pe_tl, pk, pk_tl, peln&
&   , peln_tl, pkz, pkz_tl, phis, q_con, omga, omga_tl, ua, ua_tl, va, &
&   va_tl, uc, uc_tl, vc, vc_tl, ak, bk, mfx, mfx_tl, mfy, mfy_tl, cx, &
&   cx_tl, cy, cy_tl, ze0, ze0_tl, hybrid_z, gridstruct, flagstruct, &
&   neststruct, idiag, bd, parent_grid, domain, time_total)
    IMPLICIT NONE
!#ifdef MAPL_MODE
!  t2 = MPI_Wtime(status)
!  dyn_timer = dyn_timer + (t2-t1)
!#endif
! Large time-step
    REAL(fvprc), INTENT(IN) :: bdt
    REAL(fvprc), INTENT(IN) :: consv_te
    REAL(fvprc), INTENT(IN) :: kappa, cp_air
    REAL(fvprc), INTENT(IN) :: zvir, ptop
    REAL(fvprc), INTENT(IN), OPTIONAL :: time_total
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
! transported tracers
    INTEGER, INTENT(IN) :: nq_tot
    INTEGER, INTENT(IN) :: ng
    INTEGER, INTENT(IN) :: ks
    INTEGER, INTENT(IN) :: ncnst
! small-step horizontal dynamics
    INTEGER, INTENT(IN) :: n_split
! tracer
    INTEGER, INTENT(IN) :: q_split
    LOGICAL, INTENT(IN) :: fill
    LOGICAL, INTENT(IN) :: reproduce_sum
    LOGICAL, INTENT(IN) :: hydrostatic
! Using hybrid_z for remapping
    LOGICAL, INTENT(IN) :: hybrid_z
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! D grid zonal wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz), INTENT(&
&   INOUT) :: u
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz), INTENT(&
&   INOUT) :: u_tl
! D grid meridional wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: v
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: v_tl
!real(FVPRC), intent(inout) :: w( bd%isd:,bd%jsd:,1:)  !  W (m/s)
!  W (m/s) ! replaced previous line bma
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: w_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! temperature (K)
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: pt_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
! pressure thickness (pascal)
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: delp_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
! specific humidity and constituents
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, &
&   ncnst)
    REAL(fvprc), INTENT(INOUT) :: q_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   , ncnst)
!real(FVPRC), intent(inout) :: delz(bd%isd:,bd%jsd:,1:)   ! delta-height (m); non-hydrostatic only
! replace previous line bma
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: delz_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
! height at edges (m); non-hydrostatic
    REAL(fvprc), INTENT(INOUT) :: ze0(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL(fvprc), INTENT(INOUT) :: ze0_tl(bd%is:bd%ie, bd%js:bd%je, npz+1&
&   )
!-----------------------------------------------------------------------
! Auxilliary pressure arrays:    
! The 5 vars below can be re-computed from delp and ptop.
!-----------------------------------------------------------------------
! dyn_aux:
! Surface pressure (pascal)
    REAL(fvprc), INTENT(INOUT) :: ps(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: ps_tl(bd%isd:bd%ied, bd%jsd:bd%jed)
! edge pressure (pascal)
    REAL(fvprc), INTENT(INOUT) :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%&
&   je+1)
    REAL(fvprc), INTENT(INOUT) :: pe_tl(bd%is-1:bd%ie+1, npz+1, bd%js-1:&
&   bd%je+1)
! pe**kappa
    REAL(fvprc), INTENT(INOUT) :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL(fvprc), INTENT(INOUT) :: pk_tl(bd%is:bd%ie, bd%js:bd%je, npz+1)
! ln(pe)
    REAL(fvprc), INTENT(INOUT) :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL(fvprc), INTENT(INOUT) :: peln_tl(bd%is:bd%ie, npz+1, bd%js:bd%&
&   je)
! finite-volume mean pk
    REAL(fvprc), INTENT(INOUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
    REAL(fvprc), INTENT(INOUT) :: pkz_tl(bd%is:bd%ie, bd%js:bd%je, npz)
!real(FVPRC), intent(inout):: q_con(bd%isd:, bd%jsd:, 1:)
!bma replaced previous line
    REAL(fvprc), INTENT(INOUT) :: q_con(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
!-----------------------------------------------------------------------
! Others:
!-----------------------------------------------------------------------
! Surface geopotential (g*Z_surf)
    REAL(fvprc), INTENT(INOUT) :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
! Vertical pressure velocity (pa/s)
    REAL(fvprc), INTENT(INOUT) :: omga(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: omga_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
! (uc,vc) mostly used as the C grid winds
    REAL(fvprc), INTENT(INOUT) :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: uc_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: vc_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: ua_tl, va_tl
    REAL(fvprc), DIMENSION(npz+1), INTENT(IN) :: ak, bk
! Accumulated Mass flux arrays: the "Flux Capacitor"
    REAL(fvprc), INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL(fvprc), INTENT(INOUT) :: mfx_tl(bd%is:bd%ie+1, bd%js:bd%je, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
    REAL(fvprc), INTENT(INOUT) :: mfy_tl(bd%is:bd%ie, bd%js:bd%je+1, npz&
&   )
! Accumulated Courant number arrays
    REAL(fvprc), INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: cx_tl(bd%is:bd%ie+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc), INTENT(INOUT) :: cy_tl(bd%isd:bd%ied, bd%js:bd%je+1, &
&   npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(INOUT) :: flagstruct
    TYPE(FV_NEST_TYPE), INTENT(INOUT) :: neststruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    TYPE(FV_ATMOS_TYPE), INTENT(INOUT) :: parent_grid
    TYPE(FV_DIAG_TYPE), INTENT(IN) :: idiag
! heat capacity of water at 0C
    REAL(fvprc), PARAMETER :: c_liq=4190.
! heat capacity of ice at 0C: c=c_ice+7.3*(T-Tice) 
    REAL(fvprc), PARAMETER :: c_ice=2106.
! 1384.5
    REAL(fvprc), PARAMETER :: cv_vap=cp_vapor-rvgas
! Local Arrays
    REAL(fvprc) :: ws(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: ws_tl(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: te_2d(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: te_2d_tl(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: teq(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: teq_tl(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: ps2(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: ps2_tl(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: m_fac(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: m_fac_tl(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: pfull(npz)
!real(FVPRC):: gz(bd%is:bd%ie)
    REAL(fvprc) :: dp1(bd%is:bd%ie, bd%js:bd%je, npz), dtdt_m(bd%is:bd%&
&   ie, bd%js:bd%je, npz), cappa(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
    REAL(fvprc) :: dp1_tl(bd%is:bd%ie, bd%js:bd%je, npz)
    REAL(fvprc) :: akap, rg, rdg, ph1, ph2, mdt, gam, amdt, u0
    REAL(fvprc) :: amdt_tl, u0_tl
    INTEGER :: i, j, k, n, iq, n_map, nq, nwat, k_split
! GFDL physics
    INTEGER :: sphum, liq_wat, ice_wat
    INTEGER :: rainwat, snowwat, graupel, cld_amt
    LOGICAL :: used, last_step, consv_am, do_omega
    INTEGER, PARAMETER :: max_packs=24
    TYPE(GROUP_HALO_UPDATE_TYPE), SAVE :: i_pack(max_packs)
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    REAL(fvprc) :: rcv, dt2, consv_fac, q_liq, q_sol, cvm
    REAL(fvprc) :: cv_air
    REAL(kind=8) :: t1, t2
    INTEGER :: status
    REAL(fvprc) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: gz_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: pkc(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: pkc_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: ptc(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: ptc_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: crx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: crx_tl(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: xfx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: xfx_tl(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: cry(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc) :: cry_tl(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc) :: yfx(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc) :: yfx_tl(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc) :: divgd(bd%isd:bd%ied+1, bd%jsd:bd%jed+1, npz)
    REAL(fvprc) :: divgd_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed+1, npz)
    REAL(fvprc) :: delpc(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: delpc_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: ut(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: ut_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: vt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: vt_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: zh(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: zh_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: pk3(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: pk3_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: du(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc) :: du_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc) :: dv(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: dv_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    INTEGER :: hord_tr, hord_tr_pert
    INTEGER :: kord_mt, kord_wz, kord_tr(ncnst), kord_tm
    INTEGER :: kord_mt_pert, kord_wz_pert, kord_tr_pert(ncnst), &
&   kord_tm_pert
    INTRINSIC LOG
    INTRINSIC EXP
    INTRINSIC ABS
    INTRINSIC REAL
    INTRINSIC ANY
    INTRINSIC COS
    REAL(fvprc) :: abs0
    REAL(fvprc) :: abs1
    REAL(fvprc) :: arg1
    REAL(fvprc) :: arg1_tl
    REAL(fvprc) :: arg2
    REAL(fvprc) :: arg2_tl
    REAL(fvprc) :: result1
    REAL(fvprc) :: result1_tl
    gz = 0.0
    pkc = 0.0
    ptc = 0.0
    crx = 0.0
    xfx = 0.0
    cry = 0.0
    yfx = 0.0
    divgd = 0.0
    delpc = 0.0
    ut = 0.0
    vt = 0.0
    zh = 0.0
    pk3 = 0.0
    du = 0.0
    dv = 0.0
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
!Compute the FV variables internally, for checkpointing purposes
    IF (hydrostatic) THEN
      CALL GEOS_TO_FV3_TLM(bd, npz, kappa, ptop, delp, delp_tl, pe, &
&                    pe_tl, pk, pk_tl, pkz, pkz_tl, peln, peln_tl, pt, &
&                    pt_tl)
    ELSE
      peln_tl = 0.0_FVPRC
      pkz_tl = 0.0_FVPRC
      pe_tl = 0.0_FVPRC
      pk_tl = 0.0_FVPRC
    END IF
!      dyn_timer = 0
!      comm_timer = 0
    cv_air = cp_air - rdgas
    agrav = 1./grav
    dt2 = 0.5*bdt
    consv_am = flagstruct%consv_am
    k_split = flagstruct%k_split
    nwat = flagstruct%nwat
    nq = nq_tot - flagstruct%dnats
    IF (.NOT.flagstruct%no_dycore) THEN
!#ifdef MAPL_MODE
!! Begin Dynamics timer for GEOS history processing
!      t1 = MPI_Wtime(status)
!#endif
!allocate ( dp1(is:ie, js:je, 1:npz) )
!#ifdef MOIST_CAPPA
!      allocate ( cappa(isd:ied,jsd:jed,npz) )
!#else
!      allocate ( cappa(isd:isd,jsd:jsd,1) )
!#endif
!#ifdef SW_DYNAMICS
!      akap  = 1.
!      pfull(1) = 0.5*flagstruct%p_ref
!#ifdef TEST_TRACER
!      sphum = get_tracer_index (MODEL_ATMOS, 'sphum')
!#endif
!#else
      IF (nwat .GE. 3) THEN
        sphum = GET_TRACER_INDEX(model_atmos, 'sphum')
        liq_wat = GET_TRACER_INDEX(model_atmos, 'liq_wat')
        ice_wat = GET_TRACER_INDEX(model_atmos, 'ice_wat')
        cld_amt = GET_TRACER_INDEX(model_atmos, 'cld_amt')
      END IF
      IF (nwat .EQ. 6) THEN
        rainwat = GET_TRACER_INDEX(model_atmos, 'rainwat')
        snowwat = GET_TRACER_INDEX(model_atmos, 'snowwat')
        graupel = GET_TRACER_INDEX(model_atmos, 'graupel')
      ELSE
        sphum = 1
! to cause trouble if (mis)used
        cld_amt = -1
      END IF
      akap = kappa
      rg = kappa*cp_air
      rcv = 1./(cp_air-rg)
!$OMP parallel do default(none) shared(npz,ak,bk,flagstruct,pfull) &
!$OMP                          private(ph1, ph2)
      DO k=1,npz
        ph1 = ak(k) + bk(k)*flagstruct%p_ref
        ph2 = ak(k+1) + bk(k+1)*flagstruct%p_ref
        pfull(k) = (ph2-ph1)/LOG(ph2/ph1)
      END DO
      IF (hydrostatic) THEN
        dp1_tl = 0.0_FVPRC
!$OMP parallel do default(none) shared(is,ie,js,je,npz,dp1,zvir,q,q_con,sphum,liq_wat, &
!$OMP                                  rainwat,ice_wat,snowwat,graupel )
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              dp1_tl(i, j, k) = zvir*q_tl(i, j, k, sphum)
              dp1(i, j, k) = zvir*q(i, j, k, sphum)
            END DO
          END DO
        END DO
      ELSE
!#ifdef USE_COND
!!#ifdef USE_NWAT3
!!               q_con(i,j,k) = q(i,j,k,liq_wat) + q(i,j,k,ice_wat)
!!#else
!               q_con(i,j,k) = q(i,j,k,liq_wat) + q(i,j,k,rainwat) + q(i,j,k,ice_wat)  &
!                            + q(i,j,k,snowwat) + q(i,j,k,graupel)
!!#endif
!#endif
        rdg = -(rdgas*agrav)
        dp1_tl = 0.0_FVPRC
!$OMP parallel do default(none) shared(is,ie,js,je,npz,dp1,zvir,q,q_con,sphum,liq_wat, &
!$OMP                                  rainwat,ice_wat,snowwat,graupel,pkz,cv_air,     & 
!$OMP                                  cappa,kappa,rdg,delp,pt,delz)                         &
!$OMP                          private(cvm, q_liq, q_sol)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              dp1_tl(i, j, k) = zvir*q_tl(i, j, k, sphum)
              dp1(i, j, k) = zvir*q(i, j, k, sphum)
!#ifdef USE_COND
!!#ifdef USE_NWAT3
!!               q_liq = q(i,j,k,liq_wat)
!!               q_sol = q(i,j,k,ice_wat)
!!#else
!               q_liq = q(i,j,k,liq_wat) + q(i,j,k,rainwat)
!               q_sol = q(i,j,k,ice_wat) + q(i,j,k,snowwat) + q(i,j,k,graupel)
!!#endif
!               q_con(i,j,k) = q_liq + q_Sol
!!#ifdef MOIST_CAPPA
!!!-------Simplified form ---------------------------------------------------------------------------------------
!!!              cappa(i,j,k) = rdgas/(rdgas+((1.-q(i,j,k,sphum)-q_con(i,j,k))*cv_air + q(i,j,k,sphum)*cv_vap + &
!!!                                               q_liq*c_liq + q_sol*c_ice )/(1.+dp1(i,j,k)))
!!!-------Simplified form ---------------------------------------------------------------------------------------
!!               cvm = (1.-(q(i,j,k,sphum)+q_Con(i,j,k)))*cv_air+q(i,j,k,sphum)*cv_vap+q_liq*c_liq+q_sol*c_ice
!!               cappa(i,j,k) = rdgas/(rdgas + cvm*(1.-q_con(i,j,k))/(1.+zvir*q(i,j,k,sphum)-q_con(i,j,k)))
!!               pkz(i,j,k) = exp(cappa(i,j,k)*log(rdg*delp(i,j,k)*pt(i,j,k)*    &
!!                            (1.+dp1(i,j,k)-q_con(i,j,k))/delz(i,j,k)) )
!!#else
!               pkz(i,j,k) = exp( kappa*log(rdg*delp(i,j,k)*pt(i,j,k)*    &
!                            (1.+dp1(i,j,k)-q_con(i,j,k))/delz(i,j,k)) )
!!#endif
!
!#else
              arg1_tl = (rdg*((delp_tl(i, j, k)*pt(i, j, k)+delp(i, j, k&
&               )*pt_tl(i, j, k))*(1.+dp1(i, j, k))+delp(i, j, k)*pt(i, &
&               j, k)*dp1_tl(i, j, k))*delz(i, j, k)-rdg*delp(i, j, k)*&
&               pt(i, j, k)*(1.+dp1(i, j, k))*delz_tl(i, j, k))/delz(i, &
&               j, k)**2
              arg1 = rdg*delp(i, j, k)*pt(i, j, k)*(1.+dp1(i, j, k))/&
&               delz(i, j, k)
              arg2_tl = kappa*arg1_tl/arg1
              arg2 = kappa*LOG(arg1)
              pkz_tl(i, j, k) = arg2_tl*EXP(arg2)
              pkz(i, j, k) = EXP(arg2)
            END DO
          END DO
        END DO
      END IF
!#endif
!      if ( flagstruct%fv_debug ) then
!!#ifdef MOIST_CAPPA
!!         call prt_mxm('cappa', cappa, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!!#endif
!         call prt_mxm('PS',        ps, is, ie, js, je, ng,   1, 0.01_FVPRC, gridstruct%area_64, domain)
!         call prt_mxm('T_dyn_b',   pt, is, ie, js, je, ng, npz, 1._FVPRC,   gridstruct%area_64, domain)
!         call prt_mxm('delz',    delz, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!         call prt_mxm('delp_b ', delp, is, ie, js, je, ng, npz, 0.01_FVPRC, gridstruct%area_64, domain)
!         call prt_mxm('pk_b',    pk, is, ie, js, je, 0, npz+1, 1._FVPRC,gridstruct%area_64, domain)
!         call prt_mxm('pkz_b',   pkz,is, ie, js, je, 0, npz,   1._FVPRC,gridstruct%area_64, domain)
!      endif
!---------------------
! Compute Total Energy
!---------------------
      IF (consv_te .GT. 0. .AND. (.NOT.do_adiabatic_init)) THEN
        CALL COMPUTE_TOTAL_ENERGY_TLM(is, ie, js, je, isd, ied, jsd, jed&
&                               , npz, u, u_tl, v, v_tl, w, w_tl, delz, &
&                               delz_tl, pt, pt_tl, delp, delp_tl, q, &
&                               q_tl, dp1, dp1_tl, pe, pe_tl, peln, &
&                               peln_tl, phis, gridstruct%rsin2, &
&                               gridstruct%cosa_s, zvir, cp_air, rg, hlv&
&                               , te_2d, te_2d_tl, ua, va, teq, teq_tl, &
&                               flagstruct%moist_phys, sphum, liq_wat, &
&                               rainwat, ice_wat, snowwat, graupel, &
&                               hydrostatic, idiag%id_te)
      ELSE
        teq_tl = 0.0_FVPRC
        te_2d_tl = 0.0_FVPRC
      END IF
!used = send_data(idiag%id_te, teq, fv_time)
!              te_den=1.E-9*g_sum(teq, is, ie, js, je, ng, area, 0)/(grav*4.*pi*radius**2)
!              if(is_master())  write(*,*) 'Total Energy Density (Giga J/m**2)=',te_den
      IF ((consv_am .OR. idiag%id_amdt .GT. 0) .AND. (.NOT.&
&         do_adiabatic_init)) THEN
        m_fac_tl = 0.0_FVPRC
        ps2_tl = 0.0_FVPRC
        ua_tl = 0.0_FVPRC
        CALL COMPUTE_AAM_TLM(npz, is, ie, js, je, isd, ied, jsd, jed, &
&                      gridstruct, bd, ptop, ua, ua_tl, va, va_tl, u, &
&                      u_tl, v, v_tl, delp, delp_tl, teq, teq_tl, ps2, &
&                      ps2_tl, m_fac, m_fac_tl)
      ELSE
        ua_tl = 0.0_FVPRC
        va_tl = 0.0_FVPRC
        ps2_tl = 0.0_FVPRC
        m_fac_tl = 0.0_FVPRC
      END IF
      IF (flagstruct%tau .GT. 0.) THEN
        IF (gridstruct%grid_type .LT. 4) THEN
          IF (bdt .GE. 0.) THEN
            abs0 = bdt
          ELSE
            abs0 = -bdt
          END IF
          CALL RAYLEIGH_SUPER_TLM(abs0, npx, npy, npz, ks, pfull, phis, &
&                           flagstruct%tau, u, u_tl, v, v_tl, w, w_tl, &
&                           pt, pt_tl, ua, ua_tl, va, va_tl, delz, &
&                           gridstruct%agrid, cp_air, rg, ptop, &
&                           hydrostatic, .true., flagstruct%rf_cutoff, &
&                           gridstruct, domain, bd)
        ELSE
          IF (bdt .GE. 0.) THEN
            abs1 = bdt
          ELSE
            abs1 = -bdt
          END IF
          CALL RAYLEIGH_FRICTION_TLM(abs1, npx, npy, npz, ks, pfull, &
&                              flagstruct%tau, u, u_tl, v, v_tl, w, w_tl&
&                              , pt, pt_tl, ua, ua_tl, va, va_tl, delz, &
&                              delz_tl, cp_air, rg, ptop, hydrostatic, &
&                              .true., flagstruct%rf_cutoff, gridstruct&
&                              , domain, bd)
        END IF
      END IF
!#endif
!We call this BEFORE converting pt to virtual potential temperature, 
!since we interpolate on (regular) temperature rather than theta.
!      if (gridstruct%nested .or. ANY(neststruct%child_grids)) then
!                                           if (fv_timing_onoff) call timing_on('NEST_BCs')
!         call setup_nested_grid_BCs(npx, npy, npz, cp_air, zvir, ncnst, sphum,     &
!              u, v, w, pt, delp, delz, q, uc, vc, pkz, &
!              neststruct%nested, flagstruct%inline_q, flagstruct%make_nh, ng, &
!              gridstruct, flagstruct, neststruct, &
!              neststruct%nest_timestep, neststruct%tracer_nest_timestep, domain, bd)
!                                           if (fv_timing_onoff) call timing_off('NEST_BCs')
!      endif
!#ifndef SW_DYNAMICS
! Convert pt to virtual potential temperature * CP
      IF (hydrostatic) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pt,cp_air,dp1,pkz)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              pt_tl(i, j, k) = (cp_air*(pt_tl(i, j, k)*(1.+dp1(i, j, k))&
&               +pt(i, j, k)*dp1_tl(i, j, k))*pkz(i, j, k)-cp_air*pt(i, &
&               j, k)*(1.+dp1(i, j, k))*pkz_tl(i, j, k))/pkz(i, j, k)**2
              pt(i, j, k) = cp_air*pt(i, j, k)*(1.+dp1(i, j, k))/pkz(i, &
&               j, k)
            END DO
          END DO
        END DO
      ELSE
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pt,cp_air,dp1,pkz,q_con)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
!#ifdef USE_COND
!           pt(i,j,k) = cp_air*pt(i,j,k)*(1.+dp1(i,j,k)-q_con(i,j,k))/pkz(i,j,k)
!#else
              pt_tl(i, j, k) = (cp_air*(pt_tl(i, j, k)*(1.+dp1(i, j, k))&
&               +pt(i, j, k)*dp1_tl(i, j, k))*pkz(i, j, k)-cp_air*pt(i, &
&               j, k)*(1.+dp1(i, j, k))*pkz_tl(i, j, k))/pkz(i, j, k)**2
              pt(i, j, k) = cp_air*pt(i, j, k)*(1.+dp1(i, j, k))/pkz(i, &
&               j, k)
            END DO
          END DO
        END DO
      END IF
!#endif
!#endif
      last_step = .false.
      mdt = bdt/REAL(k_split)
      IF (idiag%id_mdt .GT. 0) THEN
!allocate ( dtdt_m(is:ie,js:je,npz) )
!$OMP parallel do default(none) shared(is,ie,js,je,npz,dtdt_m)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              dtdt_m(i, j, k) = 0.
            END DO
          END DO
        END DO
        ze0_tl = 0.0_FVPRC
        uc_tl = 0.0_FVPRC
        mfx_tl = 0.0_FVPRC
        mfy_tl = 0.0_FVPRC
        omga_tl = 0.0_FVPRC
        vc_tl = 0.0_FVPRC
        ps_tl = 0.0_FVPRC
        cx_tl = 0.0_FVPRC
        cy_tl = 0.0_FVPRC
        pk3_tl = 0.0_FVPRC
        xfx_tl = 0.0_FVPRC
        ws_tl = 0.0_FVPRC
        gz_tl = 0.0_FVPRC
        du_tl = 0.0_FVPRC
        dv_tl = 0.0_FVPRC
        ptc_tl = 0.0_FVPRC
        ut_tl = 0.0_FVPRC
        divgd_tl = 0.0_FVPRC
        pkc_tl = 0.0_FVPRC
        delpc_tl = 0.0_FVPRC
        yfx_tl = 0.0_FVPRC
        vt_tl = 0.0_FVPRC
        zh_tl = 0.0_FVPRC
        crx_tl = 0.0_FVPRC
        cry_tl = 0.0_FVPRC
      ELSE
        ze0_tl = 0.0_FVPRC
        uc_tl = 0.0_FVPRC
        mfx_tl = 0.0_FVPRC
        mfy_tl = 0.0_FVPRC
        omga_tl = 0.0_FVPRC
        vc_tl = 0.0_FVPRC
        ps_tl = 0.0_FVPRC
        cx_tl = 0.0_FVPRC
        cy_tl = 0.0_FVPRC
        pk3_tl = 0.0_FVPRC
        xfx_tl = 0.0_FVPRC
        ws_tl = 0.0_FVPRC
        gz_tl = 0.0_FVPRC
        du_tl = 0.0_FVPRC
        dv_tl = 0.0_FVPRC
        ptc_tl = 0.0_FVPRC
        ut_tl = 0.0_FVPRC
        divgd_tl = 0.0_FVPRC
        pkc_tl = 0.0_FVPRC
        delpc_tl = 0.0_FVPRC
        yfx_tl = 0.0_FVPRC
        vt_tl = 0.0_FVPRC
        zh_tl = 0.0_FVPRC
        crx_tl = 0.0_FVPRC
        cry_tl = 0.0_FVPRC
      END IF
!if (fv_timing_onoff) call timing_on('  FV_DYN_LOOP')
! first level of time-split
      DO n_map=1,k_split
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
!#ifdef USE_COND
!      call start_group_halo_update(i_pack(11), i_pack(11+12), q_con, domain)
!!#ifdef MOIST_CAPPA
!!      call start_group_halo_update(i_pack(12), i_pack(12+12), cappa, domain)
!!#endif
!#endif
        CALL START_GROUP_HALO_UPDATE_TLM(i_pack(1), i_pack(1+12), delp, &
&                                  delp_tl, domain)
        CALL START_GROUP_HALO_UPDATE_TLM(i_pack(2), i_pack(2+12), pt, &
&                                  pt_tl, domain)
!#ifndef ROT3
        CALL START_GROUP_HALO_UPDATE_TLM(i_pack(8), i_pack(8+12), u, &
&                                  u_tl, v, v_tl, domain, gridtype=&
&                                  dgrid_ne)
!#endif
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!$OMP parallel do default(none) shared(is,ie,js,je,npz,dp1,delp)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              dp1_tl(i, j, k) = delp_tl(i, j, k)
              dp1(i, j, k) = delp(i, j, k)
            END DO
          END DO
        END DO
        IF (n_map .EQ. k_split) last_step = .true.
!#ifdef USE_COND
!                                           if (fv_timing_onoff) call timing_on('COMM_TOTAL')
!     call complete_group_halo_update(i_pack(11), i_pack(11+12), domain)
!!#ifdef MOIST_CAPPA
!!     call complete_group_halo_update(i_pack(12), i_pack(12+12), domain)
!!#endif
!                                           if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!#endif
        IF (fv_timing_onoff) CALL TIMING_ON('  DYN_CORE')
        CALL DYN_CORE_TLM(npx, npy, npz, ng, sphum, nq, mdt, n_split, &
&                   zvir, cp_air, akap, cappa, grav, hydrostatic, u, &
&                   u_tl, v, v_tl, w, w_tl, delz, delz_tl, pt, pt_tl, q&
&                   , q_tl, delp, delp_tl, pe, pe_tl, pk, pk_tl, phis, &
&                   ws, ws_tl, omga, omga_tl, ptop, pfull, ua, ua_tl, va&
&                   , va_tl, uc, uc_tl, vc, vc_tl, mfx, mfx_tl, mfy, &
&                   mfy_tl, cx, cx_tl, cy, cy_tl, pkz, pkz_tl, peln, &
&                   peln_tl, q_con, ak, bk, ks, gridstruct, flagstruct, &
&                   neststruct, idiag, bd, domain, n_map .EQ. 1, i_pack&
&                   , last_step, gz, gz_tl, pkc, pkc_tl, ptc, ptc_tl, &
&                   crx, crx_tl, xfx, xfx_tl, cry, cry_tl, yfx, yfx_tl, &
&                   divgd, divgd_tl, delpc, delpc_tl, ut, ut_tl, vt, &
&                   vt_tl, zh, zh_tl, pk3, pk3_tl, du, du_tl, dv, dv_tl&
&                   , time_total)
        IF (fv_timing_onoff) CALL TIMING_OFF('  DYN_CORE')
!  if ( flagstruct%fv_debug ) then
!       call prt_mxm('delp_a1',  delp, is, ie, js, je, ng, npz, 0.01_FVPRC, gridstruct%area_64, domain)
!       call prt_mxm('PT_dyn_a1',  pt, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!       call prt_mxm('pk_a1',   pk, is, ie, js, je, 0, npz+1, 1._FVPRC, gridstruct%area_64, domain)
!  endif
!#ifdef SW_DYNAMICS
!!$OMP parallel do default(none) shared(is,ie,js,je,delp,agrav)
!      do j=js,je
!         do i=is,ie
!            ps(i,j) = delp(i,j,1) * agrav
!         enddo
!      enddo
!#else
        IF (.NOT.flagstruct%inline_q .AND. nq .NE. 0) THEN
!--------------------------------------------------------
! Perform large-time-step scalar transport using the accumulated CFL and
! mass fluxes
          IF (fv_timing_onoff) CALL TIMING_ON('  tracer_2d')
          hord_tr = flagstruct%hord_tr
          hord_tr_pert = flagstruct%hord_tr_pert
          IF (last_step) hord_tr = hord_tr_pert
!!! CLEANUP: merge these two calls?
          IF (gridstruct%nested .OR. ANY(neststruct%child_grids)) THEN
            CALL TRACER_2D_NESTED_TLM(q, q_tl, dp1, dp1_tl, mfx, mfx_tl&
&                               , mfy, mfy_tl, cx, cx_tl, cy, cy_tl, &
&                               gridstruct, bd, domain, npx, npy, npz, &
&                               nq, hord_tr, hord_tr_pert, q_split, mdt&
&                               , idiag%id_divg, i_pack(10), i_pack(10+&
&                               12), flagstruct%z_tracer, k_split, &
&                               neststruct, parent_grid)
          ELSE
            CALL TRACER_2D_TLM(q, q_tl, dp1, dp1_tl, mfx, mfx_tl, mfy, &
&                        mfy_tl, cx, cx_tl, cy, cy_tl, gridstruct, bd, &
&                        domain, npx, npy, npz, 1, nq, hord_tr, &
&                        hord_tr_pert, q_split, mdt, idiag%id_divg, &
&                        i_pack(10), i_pack(10+12), flagstruct%z_tracer&
&                        , k_split)
          END IF
          IF (fv_timing_onoff) CALL TIMING_OFF('  tracer_2d')
        END IF
!used = send_data(idiag%id_divg, dp1, fv_time) 
!             if(flagstruct%fv_debug) call prt_mxm('divg',  dp1, is, ie, js, je, 0, npz, 1._FVPRC,gridstruct%area_64, domain)
        IF (npz .GT. 4) THEN
!------------------------------------------------------------------------
! Peroform vertical remapping from Lagrangian control-volume to
! the Eulerian coordinate as specified by the routine set_eta.
! Note that this finite-volume dycore is otherwise independent of the vertical
! Eulerian coordinate.
!------------------------------------------------------------------------
          DO iq=1,nq
            kord_tr(iq) = flagstruct%kord_tr
            kord_tr_pert(iq) = flagstruct%kord_tr_pert
! monotonic
            IF (iq .EQ. cld_amt) kord_tr(iq) = 9
            IF (iq .EQ. cld_amt) kord_tr_pert(iq) = 111
          END DO
          kord_mt = flagstruct%kord_mt
          kord_wz = flagstruct%kord_wz
          kord_tm = flagstruct%kord_tm
          kord_mt_pert = flagstruct%kord_mt_pert
          kord_wz_pert = flagstruct%kord_wz_pert
          kord_tm_pert = flagstruct%kord_tm_pert
          IF ((kord_tm .LT. 0 .AND. kord_tm_pert .GE. 0) .OR. (kord_tm &
&             .GE. 0 .AND. kord_tm_pert .LT. 0)) kord_tm = kord_tm_pert
!This would result in different anticipated paths through the code
          IF (last_step) THEN
!Does not matter how trajectory is remapped as it is about to be overwritten
            kord_mt = kord_mt_pert
            kord_wz = kord_wz_pert
            kord_tr = kord_tr_pert
            kord_tm = kord_tm_pert
          END IF
          do_omega = hydrostatic .AND. last_step
          IF (fv_timing_onoff) CALL TIMING_ON('  Remapping')
          CALL LAGRANGIAN_TO_EULERIAN_TLM(last_step, consv_te, ps, ps_tl&
&                                   , pe, pe_tl, delp, delp_tl, pkz, &
&                                   pkz_tl, pk, pk_tl, mdt, bdt, npz, is&
&                                   , ie, js, je, isd, ied, jsd, jed, nq&
&                                   , nwat, sphum, q_con, u, u_tl, v, &
&                                   v_tl, w, w_tl, delz, delz_tl, pt, &
&                                   pt_tl, q, q_tl, phis, zvir, cp_air, &
&                                   akap, cappa, kord_mt, kord_wz, &
&                                   kord_tr, kord_tm, kord_mt_pert, &
&                                   kord_wz_pert, kord_tr_pert, &
&                                   kord_tm_pert, peln, peln_tl, te_2d, &
&                                   te_2d_tl, ng, ua, ua_tl, va, omga, &
&                                   omga_tl, dp1, dp1_tl, ws, ws_tl, &
&                                   fill, reproduce_sum, idiag%id_mdt &
&                                   .GT. 0, dtdt_m, ptop, ak, bk, &
&                                   gridstruct, domain, ze0, ze0_tl, &
&                                   flagstruct%gmao_cubic, flagstruct%&
&                                   remap_t, flagstruct%do_sat_adj, &
&                                   hydrostatic, hybrid_z, do_omega, &
&                                   do_adiabatic_init)
          IF (fv_timing_onoff) CALL TIMING_OFF('  Remapping')
          IF (last_step) THEN
            IF (hydrostatic) THEN
!--------------------------
! Filter omega for physics:
!--------------------------
              IF (flagstruct%nf_omega .GT. 0) CALL DEL2_CUBED_TLM(omga, &
&                                                           omga_tl, &
&                                                           0.20*&
&                                                           gridstruct%&
&                                                           da_min, &
&                                                           gridstruct, &
&                                                           domain, npx&
&                                                           , npy, npz, &
&                                                           flagstruct%&
&                                                           nf_omega, bd&
&                                                          )
            ELSE
!$OMP parallel do default(none) shared(is,ie,js,je,npz,omga,delp,delz,w)
              DO k=1,npz
                DO j=js,je
                  DO i=is,ie
                    omga_tl(i, j, k) = (delp_tl(i, j, k)*delz(i, j, k)-&
&                     delp(i, j, k)*delz_tl(i, j, k))*w(i, j, k)/delz(i&
&                     , j, k)**2 + delp(i, j, k)*w_tl(i, j, k)/delz(i, j&
&                     , k)
                    omga(i, j, k) = delp(i, j, k)/delz(i, j, k)*w(i, j, &
&                     k)
                  END DO
                END DO
              END DO
            END IF
! Convert back to temperature
            IF (.NOT.flagstruct%remap_t) THEN
              IF (hydrostatic) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pt,pkz,cp_air,zvir,q,sphum)
                DO k=1,npz
                  DO j=js,je
                    DO i=is,ie
                      pt_tl(i, j, k) = ((pt_tl(i, j, k)*pkz(i, j, k)+pt(&
&                       i, j, k)*pkz_tl(i, j, k))*cp_air*(1.+zvir*q(i, j&
&                       , k, sphum))-pt(i, j, k)*pkz(i, j, k)*cp_air*&
&                       zvir*q_tl(i, j, k, sphum))/(cp_air*(1.+zvir*q(i&
&                       , j, k, sphum)))**2
                      pt(i, j, k) = pt(i, j, k)*pkz(i, j, k)/(cp_air*(1.&
&                       +zvir*q(i, j, k, sphum)))
                    END DO
                  END DO
                END DO
              ELSE
!$OMP parallel do default(none)  shared(is,ie,js,je,npz,pt,pkz,cp_air,zvir,q,sphum,q_con)
                DO k=1,npz
                  DO j=js,je
                    DO i=is,ie
!#ifdef USE_COND
!                     pt(i,j,k) = pt(i,j,k)*pkz(i,j,k)/(cp_air*(1.+zvir*q(i,j,k,sphum)-q_con(i,j,k)))
!#else
                      pt_tl(i, j, k) = ((pt_tl(i, j, k)*pkz(i, j, k)+pt(&
&                       i, j, k)*pkz_tl(i, j, k))*cp_air*(1.+zvir*q(i, j&
&                       , k, sphum))-pt(i, j, k)*pkz(i, j, k)*cp_air*&
&                       zvir*q_tl(i, j, k, sphum))/(cp_air*(1.+zvir*q(i&
&                       , j, k, sphum)))**2
                      pt(i, j, k) = pt(i, j, k)*pkz(i, j, k)/(cp_air*(1.&
&                       +zvir*q(i, j, k, sphum)))
                    END DO
                  END DO
                END DO
              END IF
            END IF
          END IF
        END IF
      END DO
!#endif
!#endif
! n_map loop
!if (fv_timing_onoff) call timing_off('  FV_DYN_LOOP')
      IF (idiag%id_mdt .GT. 0 .AND. (.NOT.do_adiabatic_init)) THEN
! Output temperature tendency due to inline moist physics:
!$OMP parallel do default(none) shared(is,ie,js,je,npz,dtdt_m,bdt)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              dtdt_m(i, j, k) = dtdt_m(i, j, k)/bdt
            END DO
          END DO
        END DO
      END IF
!used = send_data(idiag%id_mdt, dtdt_m, fv_time)
!deallocate ( dtdt_m )
!  if( nwat==6 ) then
!      call neg_adj3(is, ie, js, je, ng, npz,        &
!                    flagstruct%hydrostatic,         &
!                    peln, delz,                     &
!                    pt, delp, q(isd,jsd,1,sphum),   &
!                              q(isd,jsd,1,liq_wat), &
!                              q(isd,jsd,1,rainwat), &
!                              q(isd,jsd,1,ice_wat), &
!                              q(isd,jsd,1,snowwat), &
!                              q(isd,jsd,1,graupel), &
!                              q(isd,jsd,1,cld_amt), flagstruct%check_negative)
!!     if ( flagstruct%fv_debug ) then
!!       call prt_mxm('T_dyn_a3',    pt, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!!       call prt_mxm('SPHUM_dyn',   q(isd,jsd,1,sphum  ), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!       call prt_mxm('liq_wat_dyn', q(isd,jsd,1,liq_wat), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!       call prt_mxm('rainwat_dyn', q(isd,jsd,1,rainwat), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!       call prt_mxm('ice_wat_dyn', q(isd,jsd,1,ice_wat), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!       call prt_mxm('snowwat_dyn', q(isd,jsd,1,snowwat), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!       call prt_mxm('graupel_dyn', q(isd,jsd,1,graupel), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!     endif
!  endif
      IF ((consv_am .OR. idiag%id_amdt .GT. 0) .OR. (idiag%id_aam .GT. 0&
&         .AND. (.NOT.do_adiabatic_init))) THEN
        CALL COMPUTE_AAM_TLM(npz, is, ie, js, je, isd, ied, jsd, jed, &
&                      gridstruct, bd, ptop, ua, ua_tl, va, va_tl, u, &
&                      u_tl, v, v_tl, delp, delp_tl, te_2d, te_2d_tl, ps&
&                      , ps_tl, m_fac, m_fac_tl)
        IF (idiag%id_aam .GT. 0) THEN
!used = send_data(idiag%id_aam, te_2d, fv_time)
          IF (prt_minmax) gam = G_SUM(domain, te_2d, is, ie, js, je, ng&
&             , gridstruct%area_64, 0)
!if( is_master() ) write(6,*) 'Total AAM =', gam
        END IF
      END IF
      IF (consv_am .OR. (idiag%id_amdt .GT. 0 .AND. (.NOT.&
&         do_adiabatic_init))) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,te_2d,teq,dt2,ps2,ps,idiag) 
        DO j=js,je
          DO i=is,ie
! Note: the mountain torque computation contains also numerical error
! The numerical error is mostly from the zonal gradient of the terrain (zxg)
            te_2d_tl(i, j) = te_2d_tl(i, j) - teq_tl(i, j) + dt2*idiag%&
&             zxg(i, j)*(ps2_tl(i, j)+ps_tl(i, j))
            te_2d(i, j) = te_2d(i, j) - teq(i, j) + dt2*(ps2(i, j)+ps(i&
&             , j))*idiag%zxg(i, j)
          END DO
        END DO
!if( idiag%id_amdt>0 ) used = send_data(idiag%id_amdt, te_2d/bdt, fv_time)
        IF (consv_am .OR. prt_minmax) THEN
          amdt_tl = G_SUM_TLM(domain, te_2d, te_2d_tl, is, ie, js, je, &
&           ng, gridstruct%area_64, 0, g_sum=amdt)
          result1_tl = G_SUM_TLM(domain, m_fac, m_fac_tl, is, ie, js, je&
&           , ng, gridstruct%area_64, 0, g_sum=result1)
          u0_tl = -((radius*amdt_tl*result1-radius*amdt*result1_tl)/&
&           result1**2)
          u0 = -(radius*amdt/result1)
! truncate to enforce reproducibility
          u0 = REAL(u0, 4)
!if(is_master() .and. prt_minmax)         &
!        write(6,*) 'Dynamic AM tendency =', amdt/(bdt*1.e18), 'del-u (per yr)=', u0*365.*86400./bdt
!         write(6,*) 'Dynamic Angular Momentum tendency (Hadleys)=', amdt/(bdt*1.e18)
        ELSE
          u0_tl = 0.0_FVPRC
        END IF
!  consv_am
        IF (consv_am) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,m_fac,u0,gridstruct)
          DO j=js,je
            DO i=is,ie
              m_fac_tl(i, j) = COS(gridstruct%agrid(i, j, 2))*u0_tl
              m_fac(i, j) = u0*COS(gridstruct%agrid(i, j, 2))
            END DO
          END DO
!$OMP parallel do default(none) shared(is,ie,js,je,npz,hydrostatic,pt,m_fac,ua,cp_air, &
!$OMP                                  rcv,u,u0,gridstruct,v )
          IF (hydrostatic) THEN
            DO k=1,npz
              DO j=js,je
                DO i=is,ie
                  pt_tl(i, j, k) = pt_tl(i, j, k) - (m_fac_tl(i, j)*(0.5&
&                   *m_fac(i, j)+ua(i, j, k))+m_fac(i, j)*(0.5*m_fac_tl(&
&                   i, j)+ua_tl(i, j, k)))/cp_air
                  pt(i, j, k) = pt(i, j, k) - m_fac(i, j)*(0.5*m_fac(i, &
&                   j)+ua(i, j, k))/cp_air
                END DO
              END DO
            END DO
          ELSE
            DO k=1,npz
              DO j=js,je
                DO i=is,ie
                  pt_tl(i, j, k) = pt_tl(i, j, k) - rcv*(m_fac_tl(i, j)*&
&                   (0.5*m_fac(i, j)+ua(i, j, k))+m_fac(i, j)*(0.5*&
&                   m_fac_tl(i, j)+ua_tl(i, j, k)))
                  pt(i, j, k) = pt(i, j, k) - m_fac(i, j)*(0.5*m_fac(i, &
&                   j)+ua(i, j, k))*rcv
                END DO
              END DO
            END DO
          END IF
          DO k=1,npz
            DO j=js,je+1
              DO i=is,ie
                u_tl(i, j, k) = u_tl(i, j, k) + gridstruct%l2c_u(i, j)*&
&                 u0_tl
                u(i, j, k) = u(i, j, k) + u0*gridstruct%l2c_u(i, j)
              END DO
            END DO
            DO j=js,je
              DO i=is,ie+1
                v_tl(i, j, k) = v_tl(i, j, k) + gridstruct%l2c_v(i, j)*&
&                 u0_tl
                v(i, j, k) = v(i, j, k) + u0*gridstruct%l2c_v(i, j)
              END DO
            END DO
          END DO
        END IF
      END IF
    END IF
    CALL CUBED_TO_LATLON_TLM(u, u_tl, v, v_tl, ua, va, gridstruct, npx, &
&                      npy, npz, 1, gridstruct%grid_type, domain, &
&                      gridstruct%nested, flagstruct%c2l_ord, bd)
!     if ( flagstruct%fv_debug ) then
!       call prt_mxm('UA', ua, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!       call prt_mxm('VA', va, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!       call prt_mxm('TA', pt, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!     endif
!  if ( flagstruct%range_warn ) then
!       call range_check('UA_dyn', ua, is, ie, js, je, ng, npz, gridstruct%agrid,   &
!                         -220._FVPRC, 260._FVPRC, bad_range)
!       call range_check('VA_dyn', ua, is, ie, js, je, ng, npz, gridstruct%agrid,   &
!                         -220._FVPRC, 220._FVPRC, bad_range)
!!#ifndef SW_DYNAMICS
!       call range_check('TA_dyn', pt, is, ie, js, je, ng, npz, gridstruct%agrid,   &
!                         160._FVPRC, 330._FVPRC, bad_range)
!       if ( .not. hydrostatic ) &
!       call range_check('W_dyn', w, is, ie, js, je, ng, npz, gridstruct%agrid,   &
!                         -20._FVPRC, 20._FVPRC, bad_range)
!!#endif
!
!  endif
!deallocate ( dp1 )
!deallocate ( cappa )
!Convert back to potential temperature
    IF (hydrostatic) CALL FV3_TO_GEOS_TLM(bd, npz, pkz, pkz_tl, pt, &
&                                   pt_tl)
  END SUBROUTINE FV_DYNAMICS_TLM
  SUBROUTINE FV_DYNAMICS(npx, npy, npz, nq_tot, ng, bdt, consv_te, fill&
&   , reproduce_sum, kappa, cp_air, zvir, ptop, ks, ncnst, n_split, &
&   q_split, u, v, w, delz, hydrostatic, pt, delp, q, ps, pe, pk, peln, &
&   pkz, phis, q_con, omga, ua, va, uc, vc, ak, bk, mfx, mfy, cx, cy, &
&   ze0, hybrid_z, gridstruct, flagstruct, neststruct, idiag, bd, &
&   parent_grid, domain, time_total)
    IMPLICIT NONE
!#ifdef MAPL_MODE
!  t2 = MPI_Wtime(status)
!  dyn_timer = dyn_timer + (t2-t1)
!#endif
! Large time-step
    REAL(fvprc), INTENT(IN) :: bdt
    REAL(fvprc), INTENT(IN) :: consv_te
    REAL(fvprc), INTENT(IN) :: kappa, cp_air
    REAL(fvprc), INTENT(IN) :: zvir, ptop
    REAL(fvprc), INTENT(IN), OPTIONAL :: time_total
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
! transported tracers
    INTEGER, INTENT(IN) :: nq_tot
    INTEGER, INTENT(IN) :: ng
    INTEGER, INTENT(IN) :: ks
    INTEGER, INTENT(IN) :: ncnst
! small-step horizontal dynamics
    INTEGER, INTENT(IN) :: n_split
! tracer
    INTEGER, INTENT(IN) :: q_split
    LOGICAL, INTENT(IN) :: fill
    LOGICAL, INTENT(IN) :: reproduce_sum
    LOGICAL, INTENT(IN) :: hydrostatic
! Using hybrid_z for remapping
    LOGICAL, INTENT(IN) :: hybrid_z
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! D grid zonal wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz), INTENT(&
&   INOUT) :: u
! D grid meridional wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: v
!real(FVPRC), intent(inout) :: w( bd%isd:,bd%jsd:,1:)  !  W (m/s)
!  W (m/s) ! replaced previous line bma
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! temperature (K)
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! pressure thickness (pascal)
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! specific humidity and constituents
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, &
&   ncnst)
!real(FVPRC), intent(inout) :: delz(bd%isd:,bd%jsd:,1:)   ! delta-height (m); non-hydrostatic only
! replace previous line bma
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! height at edges (m); non-hydrostatic
    REAL(fvprc), INTENT(INOUT) :: ze0(bd%is:bd%ie, bd%js:bd%je, npz+1)
!-----------------------------------------------------------------------
! Auxilliary pressure arrays:    
! The 5 vars below can be re-computed from delp and ptop.
!-----------------------------------------------------------------------
! dyn_aux:
! Surface pressure (pascal)
    REAL(fvprc), INTENT(INOUT) :: ps(bd%isd:bd%ied, bd%jsd:bd%jed)
! edge pressure (pascal)
    REAL(fvprc), INTENT(INOUT) :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%&
&   je+1)
! pe**kappa
    REAL(fvprc), INTENT(INOUT) :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
! ln(pe)
    REAL(fvprc), INTENT(INOUT) :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
! finite-volume mean pk
    REAL(fvprc), INTENT(INOUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
!real(FVPRC), intent(inout):: q_con(bd%isd:, bd%jsd:, 1:)
!bma replaced previous line
    REAL(fvprc), INTENT(INOUT) :: q_con(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
!-----------------------------------------------------------------------
! Others:
!-----------------------------------------------------------------------
! Surface geopotential (g*Z_surf)
    REAL(fvprc), INTENT(INOUT) :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
! Vertical pressure velocity (pa/s)
    REAL(fvprc), INTENT(INOUT) :: omga(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! (uc,vc) mostly used as the C grid winds
    REAL(fvprc), INTENT(INOUT) :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: ua, va
    REAL(fvprc), DIMENSION(npz+1), INTENT(IN) :: ak, bk
! Accumulated Mass flux arrays: the "Flux Capacitor"
    REAL(fvprc), INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL(fvprc), INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
! Accumulated Courant number arrays
    REAL(fvprc), INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(INOUT) :: flagstruct
    TYPE(FV_NEST_TYPE), INTENT(INOUT) :: neststruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    TYPE(FV_ATMOS_TYPE), INTENT(INOUT) :: parent_grid
    TYPE(FV_DIAG_TYPE), INTENT(IN) :: idiag
! heat capacity of water at 0C
    REAL(fvprc), PARAMETER :: c_liq=4190.
! heat capacity of ice at 0C: c=c_ice+7.3*(T-Tice) 
    REAL(fvprc), PARAMETER :: c_ice=2106.
! 1384.5
    REAL(fvprc), PARAMETER :: cv_vap=cp_vapor-rvgas
! Local Arrays
    REAL(fvprc) :: ws(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: te_2d(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: teq(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: ps2(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: m_fac(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: pfull(npz)
!real(FVPRC):: gz(bd%is:bd%ie)
    REAL(fvprc) :: dp1(bd%is:bd%ie, bd%js:bd%je, npz), dtdt_m(bd%is:bd%&
&   ie, bd%js:bd%je, npz), cappa(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
    REAL(fvprc) :: akap, rg, rdg, ph1, ph2, mdt, gam, amdt, u0
    INTEGER :: i, j, k, n, iq, n_map, nq, nwat, k_split
! GFDL physics
    INTEGER :: sphum, liq_wat, ice_wat
    INTEGER :: rainwat, snowwat, graupel, cld_amt
    LOGICAL :: used, last_step, consv_am, do_omega
    INTEGER, PARAMETER :: max_packs=24
    TYPE(GROUP_HALO_UPDATE_TYPE), SAVE :: i_pack(max_packs)
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    REAL(fvprc) :: rcv, dt2, consv_fac, q_liq, q_sol, cvm
    REAL(fvprc) :: cv_air
    REAL(kind=8) :: t1, t2
    INTEGER :: status
    REAL(fvprc) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: pkc(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: ptc(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: crx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: xfx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: cry(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc) :: yfx(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc) :: divgd(bd%isd:bd%ied+1, bd%jsd:bd%jed+1, npz)
    REAL(fvprc) :: delpc(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: ut(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: vt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: zh(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: pk3(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: du(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc) :: dv(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    INTEGER :: hord_tr, hord_tr_pert
    INTEGER :: kord_mt, kord_wz, kord_tr(ncnst), kord_tm
    INTEGER :: kord_mt_pert, kord_wz_pert, kord_tr_pert(ncnst), &
&   kord_tm_pert
    INTRINSIC LOG
    INTRINSIC EXP
    INTRINSIC ABS
    INTRINSIC REAL
    INTRINSIC ANY
    INTRINSIC COS
    REAL(fvprc) :: abs0
    REAL(fvprc) :: abs1
    REAL(fvprc) :: arg1
    REAL(fvprc) :: arg2
    REAL(fvprc) :: result1
    gz = 0.0
    pkc = 0.0
    ptc = 0.0
    crx = 0.0
    xfx = 0.0
    cry = 0.0
    yfx = 0.0
    divgd = 0.0
    delpc = 0.0
    ut = 0.0
    vt = 0.0
    zh = 0.0
    pk3 = 0.0
    du = 0.0
    dv = 0.0
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
!Compute the FV variables internally, for checkpointing purposes
    IF (hydrostatic) CALL GEOS_TO_FV3(bd, npz, kappa, ptop, delp, pe, pk&
&                               , pkz, peln, pt)
!      dyn_timer = 0
!      comm_timer = 0
    cv_air = cp_air - rdgas
    agrav = 1./grav
    dt2 = 0.5*bdt
    consv_am = flagstruct%consv_am
    k_split = flagstruct%k_split
    nwat = flagstruct%nwat
    nq = nq_tot - flagstruct%dnats
    IF (.NOT.flagstruct%no_dycore) THEN
!#ifdef MAPL_MODE
!! Begin Dynamics timer for GEOS history processing
!      t1 = MPI_Wtime(status)
!#endif
!allocate ( dp1(is:ie, js:je, 1:npz) )
!#ifdef MOIST_CAPPA
!      allocate ( cappa(isd:ied,jsd:jed,npz) )
!#else
!      allocate ( cappa(isd:isd,jsd:jsd,1) )
!#endif
!#ifdef SW_DYNAMICS
!      akap  = 1.
!      pfull(1) = 0.5*flagstruct%p_ref
!#ifdef TEST_TRACER
!      sphum = get_tracer_index (MODEL_ATMOS, 'sphum')
!#endif
!#else
      IF (nwat .GE. 3) THEN
        sphum = GET_TRACER_INDEX(model_atmos, 'sphum')
        liq_wat = GET_TRACER_INDEX(model_atmos, 'liq_wat')
        ice_wat = GET_TRACER_INDEX(model_atmos, 'ice_wat')
        cld_amt = GET_TRACER_INDEX(model_atmos, 'cld_amt')
      END IF
      IF (nwat .EQ. 6) THEN
        rainwat = GET_TRACER_INDEX(model_atmos, 'rainwat')
        snowwat = GET_TRACER_INDEX(model_atmos, 'snowwat')
        graupel = GET_TRACER_INDEX(model_atmos, 'graupel')
      ELSE
        sphum = 1
! to cause trouble if (mis)used
        cld_amt = -1
      END IF
      akap = kappa
      rg = kappa*cp_air
      rcv = 1./(cp_air-rg)
!$OMP parallel do default(none) shared(npz,ak,bk,flagstruct,pfull) &
!$OMP                          private(ph1, ph2)
      DO k=1,npz
        ph1 = ak(k) + bk(k)*flagstruct%p_ref
        ph2 = ak(k+1) + bk(k+1)*flagstruct%p_ref
        pfull(k) = (ph2-ph1)/LOG(ph2/ph1)
      END DO
      IF (hydrostatic) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,dp1,zvir,q,q_con,sphum,liq_wat, &
!$OMP                                  rainwat,ice_wat,snowwat,graupel )
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              dp1(i, j, k) = zvir*q(i, j, k, sphum)
            END DO
          END DO
        END DO
      ELSE
!#ifdef USE_COND
!!#ifdef USE_NWAT3
!!               q_con(i,j,k) = q(i,j,k,liq_wat) + q(i,j,k,ice_wat)
!!#else
!               q_con(i,j,k) = q(i,j,k,liq_wat) + q(i,j,k,rainwat) + q(i,j,k,ice_wat)  &
!                            + q(i,j,k,snowwat) + q(i,j,k,graupel)
!!#endif
!#endif
        rdg = -(rdgas*agrav)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,dp1,zvir,q,q_con,sphum,liq_wat, &
!$OMP                                  rainwat,ice_wat,snowwat,graupel,pkz,cv_air,     & 
!$OMP                                  cappa,kappa,rdg,delp,pt,delz)                         &
!$OMP                          private(cvm, q_liq, q_sol)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              dp1(i, j, k) = zvir*q(i, j, k, sphum)
!#ifdef USE_COND
!!#ifdef USE_NWAT3
!!               q_liq = q(i,j,k,liq_wat)
!!               q_sol = q(i,j,k,ice_wat)
!!#else
!               q_liq = q(i,j,k,liq_wat) + q(i,j,k,rainwat)
!               q_sol = q(i,j,k,ice_wat) + q(i,j,k,snowwat) + q(i,j,k,graupel)
!!#endif
!               q_con(i,j,k) = q_liq + q_Sol
!!#ifdef MOIST_CAPPA
!!!-------Simplified form ---------------------------------------------------------------------------------------
!!!              cappa(i,j,k) = rdgas/(rdgas+((1.-q(i,j,k,sphum)-q_con(i,j,k))*cv_air + q(i,j,k,sphum)*cv_vap + &
!!!                                               q_liq*c_liq + q_sol*c_ice )/(1.+dp1(i,j,k)))
!!!-------Simplified form ---------------------------------------------------------------------------------------
!!               cvm = (1.-(q(i,j,k,sphum)+q_Con(i,j,k)))*cv_air+q(i,j,k,sphum)*cv_vap+q_liq*c_liq+q_sol*c_ice
!!               cappa(i,j,k) = rdgas/(rdgas + cvm*(1.-q_con(i,j,k))/(1.+zvir*q(i,j,k,sphum)-q_con(i,j,k)))
!!               pkz(i,j,k) = exp(cappa(i,j,k)*log(rdg*delp(i,j,k)*pt(i,j,k)*    &
!!                            (1.+dp1(i,j,k)-q_con(i,j,k))/delz(i,j,k)) )
!!#else
!               pkz(i,j,k) = exp( kappa*log(rdg*delp(i,j,k)*pt(i,j,k)*    &
!                            (1.+dp1(i,j,k)-q_con(i,j,k))/delz(i,j,k)) )
!!#endif
!
!#else
              arg1 = rdg*delp(i, j, k)*pt(i, j, k)*(1.+dp1(i, j, k))/&
&               delz(i, j, k)
              arg2 = kappa*LOG(arg1)
              pkz(i, j, k) = EXP(arg2)
            END DO
          END DO
        END DO
      END IF
!#endif
!      if ( flagstruct%fv_debug ) then
!!#ifdef MOIST_CAPPA
!!         call prt_mxm('cappa', cappa, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!!#endif
!         call prt_mxm('PS',        ps, is, ie, js, je, ng,   1, 0.01_FVPRC, gridstruct%area_64, domain)
!         call prt_mxm('T_dyn_b',   pt, is, ie, js, je, ng, npz, 1._FVPRC,   gridstruct%area_64, domain)
!         call prt_mxm('delz',    delz, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!         call prt_mxm('delp_b ', delp, is, ie, js, je, ng, npz, 0.01_FVPRC, gridstruct%area_64, domain)
!         call prt_mxm('pk_b',    pk, is, ie, js, je, 0, npz+1, 1._FVPRC,gridstruct%area_64, domain)
!         call prt_mxm('pkz_b',   pkz,is, ie, js, je, 0, npz,   1._FVPRC,gridstruct%area_64, domain)
!      endif
!---------------------
! Compute Total Energy
!---------------------
      IF (consv_te .GT. 0. .AND. (.NOT.do_adiabatic_init)) CALL &
&       COMPUTE_TOTAL_ENERGY(is, ie, js, je, isd, ied, jsd, jed, npz, u&
&                      , v, w, delz, pt, delp, q, dp1, pe, peln, phis, &
&                      gridstruct%rsin2, gridstruct%cosa_s, zvir, cp_air&
&                      , rg, hlv, te_2d, ua, va, teq, flagstruct%&
&                      moist_phys, sphum, liq_wat, rainwat, ice_wat, &
&                      snowwat, graupel, hydrostatic, idiag%id_te)
!used = send_data(idiag%id_te, teq, fv_time)
!              te_den=1.E-9*g_sum(teq, is, ie, js, je, ng, area, 0)/(grav*4.*pi*radius**2)
!              if(is_master())  write(*,*) 'Total Energy Density (Giga J/m**2)=',te_den
      IF ((consv_am .OR. idiag%id_amdt .GT. 0) .AND. (.NOT.&
&         do_adiabatic_init)) CALL COMPUTE_AAM(npz, is, ie, js, je, isd&
&                                        , ied, jsd, jed, gridstruct, bd&
&                                        , ptop, ua, va, u, v, delp, teq&
&                                        , ps2, m_fac)
      IF (flagstruct%tau .GT. 0.) THEN
        IF (gridstruct%grid_type .LT. 4) THEN
          IF (bdt .GE. 0.) THEN
            abs0 = bdt
          ELSE
            abs0 = -bdt
          END IF
          CALL RAYLEIGH_SUPER(abs0, npx, npy, npz, ks, pfull, phis, &
&                       flagstruct%tau, u, v, w, pt, ua, va, delz, &
&                       gridstruct%agrid, cp_air, rg, ptop, hydrostatic&
&                       , .true., flagstruct%rf_cutoff, gridstruct, &
&                       domain, bd)
        ELSE
          IF (bdt .GE. 0.) THEN
            abs1 = bdt
          ELSE
            abs1 = -bdt
          END IF
          CALL RAYLEIGH_FRICTION(abs1, npx, npy, npz, ks, pfull, &
&                          flagstruct%tau, u, v, w, pt, ua, va, delz, &
&                          cp_air, rg, ptop, hydrostatic, .true., &
&                          flagstruct%rf_cutoff, gridstruct, domain, bd)
        END IF
      END IF
!#endif
!We call this BEFORE converting pt to virtual potential temperature, 
!since we interpolate on (regular) temperature rather than theta.
!      if (gridstruct%nested .or. ANY(neststruct%child_grids)) then
!                                           if (fv_timing_onoff) call timing_on('NEST_BCs')
!         call setup_nested_grid_BCs(npx, npy, npz, cp_air, zvir, ncnst, sphum,     &
!              u, v, w, pt, delp, delz, q, uc, vc, pkz, &
!              neststruct%nested, flagstruct%inline_q, flagstruct%make_nh, ng, &
!              gridstruct, flagstruct, neststruct, &
!              neststruct%nest_timestep, neststruct%tracer_nest_timestep, domain, bd)
!                                           if (fv_timing_onoff) call timing_off('NEST_BCs')
!      endif
!#ifndef SW_DYNAMICS
! Convert pt to virtual potential temperature * CP
      IF (hydrostatic) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pt,cp_air,dp1,pkz)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              pt(i, j, k) = cp_air*pt(i, j, k)*(1.+dp1(i, j, k))/pkz(i, &
&               j, k)
            END DO
          END DO
        END DO
      ELSE
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pt,cp_air,dp1,pkz,q_con)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
!#ifdef USE_COND
!           pt(i,j,k) = cp_air*pt(i,j,k)*(1.+dp1(i,j,k)-q_con(i,j,k))/pkz(i,j,k)
!#else
              pt(i, j, k) = cp_air*pt(i, j, k)*(1.+dp1(i, j, k))/pkz(i, &
&               j, k)
            END DO
          END DO
        END DO
      END IF
!#endif
!#endif
      last_step = .false.
      mdt = bdt/REAL(k_split)
      IF (idiag%id_mdt .GT. 0) THEN
!allocate ( dtdt_m(is:ie,js:je,npz) )
!$OMP parallel do default(none) shared(is,ie,js,je,npz,dtdt_m)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              dtdt_m(i, j, k) = 0.
            END DO
          END DO
        END DO
      END IF
!if (fv_timing_onoff) call timing_on('  FV_DYN_LOOP')
! first level of time-split
      DO n_map=1,k_split
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
!#ifdef USE_COND
!      call start_group_halo_update(i_pack(11), i_pack(11+12), q_con, domain)
!!#ifdef MOIST_CAPPA
!!      call start_group_halo_update(i_pack(12), i_pack(12+12), cappa, domain)
!!#endif
!#endif
        CALL START_GROUP_HALO_UPDATE(i_pack(1), i_pack(1+12), delp, &
&                              domain)
        CALL START_GROUP_HALO_UPDATE(i_pack(2), i_pack(2+12), pt, domain&
&                             )
!#ifndef ROT3
        CALL START_GROUP_HALO_UPDATE(i_pack(8), i_pack(8+12), u, v, &
&                              domain, gridtype=dgrid_ne)
!#endif
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!$OMP parallel do default(none) shared(is,ie,js,je,npz,dp1,delp)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              dp1(i, j, k) = delp(i, j, k)
            END DO
          END DO
        END DO
        IF (n_map .EQ. k_split) last_step = .true.
!#ifdef USE_COND
!                                           if (fv_timing_onoff) call timing_on('COMM_TOTAL')
!     call complete_group_halo_update(i_pack(11), i_pack(11+12), domain)
!!#ifdef MOIST_CAPPA
!!     call complete_group_halo_update(i_pack(12), i_pack(12+12), domain)
!!#endif
!                                           if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!#endif
        IF (fv_timing_onoff) CALL TIMING_ON('  DYN_CORE')
        CALL DYN_CORE(npx, npy, npz, ng, sphum, nq, mdt, n_split, zvir, &
&               cp_air, akap, cappa, grav, hydrostatic, u, v, w, delz, &
&               pt, q, delp, pe, pk, phis, ws, omga, ptop, pfull, ua, va&
&               , uc, vc, mfx, mfy, cx, cy, pkz, peln, q_con, ak, bk, ks&
&               , gridstruct, flagstruct, neststruct, idiag, bd, domain&
&               , n_map .EQ. 1, i_pack, last_step, gz, pkc, ptc, crx, &
&               xfx, cry, yfx, divgd, delpc, ut, vt, zh, pk3, du, dv, &
&               time_total)
        IF (fv_timing_onoff) CALL TIMING_OFF('  DYN_CORE')
!  if ( flagstruct%fv_debug ) then
!       call prt_mxm('delp_a1',  delp, is, ie, js, je, ng, npz, 0.01_FVPRC, gridstruct%area_64, domain)
!       call prt_mxm('PT_dyn_a1',  pt, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!       call prt_mxm('pk_a1',   pk, is, ie, js, je, 0, npz+1, 1._FVPRC, gridstruct%area_64, domain)
!  endif
!#ifdef SW_DYNAMICS
!!$OMP parallel do default(none) shared(is,ie,js,je,delp,agrav)
!      do j=js,je
!         do i=is,ie
!            ps(i,j) = delp(i,j,1) * agrav
!         enddo
!      enddo
!#else
        IF (.NOT.flagstruct%inline_q .AND. nq .NE. 0) THEN
!--------------------------------------------------------
! Perform large-time-step scalar transport using the accumulated CFL and
! mass fluxes
          IF (fv_timing_onoff) CALL TIMING_ON('  tracer_2d')
          hord_tr = flagstruct%hord_tr
          hord_tr_pert = flagstruct%hord_tr_pert
          IF (last_step) hord_tr = hord_tr_pert
!!! CLEANUP: merge these two calls?
          IF (gridstruct%nested .OR. ANY(neststruct%child_grids)) THEN
            CALL TRACER_2D_NESTED(q, dp1, mfx, mfy, cx, cy, gridstruct, &
&                           bd, domain, npx, npy, npz, nq, hord_tr, &
&                           hord_tr_pert, q_split, mdt, idiag%id_divg, &
&                           i_pack(10), i_pack(10+12), flagstruct%&
&                           z_tracer, k_split, neststruct, parent_grid)
          ELSE
            CALL TRACER_2D(q, dp1, mfx, mfy, cx, cy, gridstruct, bd, &
&                    domain, npx, npy, npz, 1, nq, hord_tr, hord_tr_pert&
&                    , q_split, mdt, idiag%id_divg, i_pack(10), i_pack(&
&                    10+12), flagstruct%z_tracer, k_split)
          END IF
          IF (fv_timing_onoff) CALL TIMING_OFF('  tracer_2d')
        END IF
!used = send_data(idiag%id_divg, dp1, fv_time) 
!             if(flagstruct%fv_debug) call prt_mxm('divg',  dp1, is, ie, js, je, 0, npz, 1._FVPRC,gridstruct%area_64, domain)
        IF (npz .GT. 4) THEN
!------------------------------------------------------------------------
! Peroform vertical remapping from Lagrangian control-volume to
! the Eulerian coordinate as specified by the routine set_eta.
! Note that this finite-volume dycore is otherwise independent of the vertical
! Eulerian coordinate.
!------------------------------------------------------------------------
          DO iq=1,nq
            kord_tr(iq) = flagstruct%kord_tr
            kord_tr_pert(iq) = flagstruct%kord_tr_pert
! monotonic
            IF (iq .EQ. cld_amt) kord_tr(iq) = 9
            IF (iq .EQ. cld_amt) kord_tr_pert(iq) = 111
          END DO
          kord_mt = flagstruct%kord_mt
          kord_wz = flagstruct%kord_wz
          kord_tm = flagstruct%kord_tm
          kord_mt_pert = flagstruct%kord_mt_pert
          kord_wz_pert = flagstruct%kord_wz_pert
          kord_tm_pert = flagstruct%kord_tm_pert
          IF ((kord_tm .LT. 0 .AND. kord_tm_pert .GE. 0) .OR. (kord_tm &
&             .GE. 0 .AND. kord_tm_pert .LT. 0)) kord_tm = kord_tm_pert
!This would result in different anticipated paths through the code
          IF (last_step) THEN
!Does not matter how trajectory is remapped as it is about to be overwritten
            kord_mt = kord_mt_pert
            kord_wz = kord_wz_pert
            kord_tr = kord_tr_pert
            kord_tm = kord_tm_pert
          END IF
          do_omega = hydrostatic .AND. last_step
          IF (fv_timing_onoff) CALL TIMING_ON('  Remapping')
          CALL LAGRANGIAN_TO_EULERIAN(last_step, consv_te, ps, pe, delp&
&                               , pkz, pk, mdt, bdt, npz, is, ie, js, je&
&                               , isd, ied, jsd, jed, nq, nwat, sphum, &
&                               q_con, u, v, w, delz, pt, q, phis, zvir&
&                               , cp_air, akap, cappa, kord_mt, kord_wz&
&                               , kord_tr, kord_tm, kord_mt_pert, &
&                               kord_wz_pert, kord_tr_pert, kord_tm_pert&
&                               , peln, te_2d, ng, ua, va, omga, dp1, ws&
&                               , fill, reproduce_sum, idiag%id_mdt .GT.&
&                               0, dtdt_m, ptop, ak, bk, gridstruct, &
&                               domain, ze0, flagstruct%gmao_cubic, &
&                               flagstruct%remap_t, flagstruct%&
&                               do_sat_adj, hydrostatic, hybrid_z, &
&                               do_omega, do_adiabatic_init)
          IF (fv_timing_onoff) CALL TIMING_OFF('  Remapping')
          IF (last_step) THEN
            IF (hydrostatic) THEN
!--------------------------
! Filter omega for physics:
!--------------------------
              IF (flagstruct%nf_omega .GT. 0) CALL DEL2_CUBED(omga, 0.20&
&                                                       *gridstruct%&
&                                                       da_min, &
&                                                       gridstruct, &
&                                                       domain, npx, npy&
&                                                       , npz, &
&                                                       flagstruct%&
&                                                       nf_omega, bd)
            ELSE
!$OMP parallel do default(none) shared(is,ie,js,je,npz,omga,delp,delz,w)
              DO k=1,npz
                DO j=js,je
                  DO i=is,ie
                    omga(i, j, k) = delp(i, j, k)/delz(i, j, k)*w(i, j, &
&                     k)
                  END DO
                END DO
              END DO
            END IF
! Convert back to temperature
            IF (.NOT.flagstruct%remap_t) THEN
              IF (hydrostatic) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pt,pkz,cp_air,zvir,q,sphum)
                DO k=1,npz
                  DO j=js,je
                    DO i=is,ie
                      pt(i, j, k) = pt(i, j, k)*pkz(i, j, k)/(cp_air*(1.&
&                       +zvir*q(i, j, k, sphum)))
                    END DO
                  END DO
                END DO
              ELSE
!$OMP parallel do default(none)  shared(is,ie,js,je,npz,pt,pkz,cp_air,zvir,q,sphum,q_con)
                DO k=1,npz
                  DO j=js,je
                    DO i=is,ie
!#ifdef USE_COND
!                     pt(i,j,k) = pt(i,j,k)*pkz(i,j,k)/(cp_air*(1.+zvir*q(i,j,k,sphum)-q_con(i,j,k)))
!#else
                      pt(i, j, k) = pt(i, j, k)*pkz(i, j, k)/(cp_air*(1.&
&                       +zvir*q(i, j, k, sphum)))
                    END DO
                  END DO
                END DO
              END IF
            END IF
          END IF
        END IF
      END DO
!#endif
!#endif
! n_map loop
!if (fv_timing_onoff) call timing_off('  FV_DYN_LOOP')
      IF (idiag%id_mdt .GT. 0 .AND. (.NOT.do_adiabatic_init)) THEN
! Output temperature tendency due to inline moist physics:
!$OMP parallel do default(none) shared(is,ie,js,je,npz,dtdt_m,bdt)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              dtdt_m(i, j, k) = dtdt_m(i, j, k)/bdt
            END DO
          END DO
        END DO
      END IF
!used = send_data(idiag%id_mdt, dtdt_m, fv_time)
!deallocate ( dtdt_m )
!  if( nwat==6 ) then
!      call neg_adj3(is, ie, js, je, ng, npz,        &
!                    flagstruct%hydrostatic,         &
!                    peln, delz,                     &
!                    pt, delp, q(isd,jsd,1,sphum),   &
!                              q(isd,jsd,1,liq_wat), &
!                              q(isd,jsd,1,rainwat), &
!                              q(isd,jsd,1,ice_wat), &
!                              q(isd,jsd,1,snowwat), &
!                              q(isd,jsd,1,graupel), &
!                              q(isd,jsd,1,cld_amt), flagstruct%check_negative)
!!     if ( flagstruct%fv_debug ) then
!!       call prt_mxm('T_dyn_a3',    pt, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!!       call prt_mxm('SPHUM_dyn',   q(isd,jsd,1,sphum  ), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!       call prt_mxm('liq_wat_dyn', q(isd,jsd,1,liq_wat), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!       call prt_mxm('rainwat_dyn', q(isd,jsd,1,rainwat), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!       call prt_mxm('ice_wat_dyn', q(isd,jsd,1,ice_wat), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!       call prt_mxm('snowwat_dyn', q(isd,jsd,1,snowwat), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!       call prt_mxm('graupel_dyn', q(isd,jsd,1,graupel), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!     endif
!  endif
      IF ((consv_am .OR. idiag%id_amdt .GT. 0) .OR. (idiag%id_aam .GT. 0&
&         .AND. (.NOT.do_adiabatic_init))) THEN
        CALL COMPUTE_AAM(npz, is, ie, js, je, isd, ied, jsd, jed, &
&                  gridstruct, bd, ptop, ua, va, u, v, delp, te_2d, ps, &
&                  m_fac)
        IF (idiag%id_aam .GT. 0) THEN
!used = send_data(idiag%id_aam, te_2d, fv_time)
          IF (prt_minmax) gam = G_SUM(domain, te_2d, is, ie, js, je, ng&
&             , gridstruct%area_64, 0)
!if( is_master() ) write(6,*) 'Total AAM =', gam
        END IF
      END IF
      IF (consv_am .OR. (idiag%id_amdt .GT. 0 .AND. (.NOT.&
&         do_adiabatic_init))) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,te_2d,teq,dt2,ps2,ps,idiag) 
        DO j=js,je
          DO i=is,ie
! Note: the mountain torque computation contains also numerical error
! The numerical error is mostly from the zonal gradient of the terrain (zxg)
            te_2d(i, j) = te_2d(i, j) - teq(i, j) + dt2*(ps2(i, j)+ps(i&
&             , j))*idiag%zxg(i, j)
          END DO
        END DO
!if( idiag%id_amdt>0 ) used = send_data(idiag%id_amdt, te_2d/bdt, fv_time)
        IF (consv_am .OR. prt_minmax) THEN
          amdt = G_SUM(domain, te_2d, is, ie, js, je, ng, gridstruct%&
&           area_64, 0)
          result1 = G_SUM(domain, m_fac, is, ie, js, je, ng, gridstruct%&
&           area_64, 0)
          u0 = -(radius*amdt/result1)
! truncate to enforce reproducibility
          u0 = REAL(u0, 4)
!if(is_master() .and. prt_minmax)         &
!        write(6,*) 'Dynamic AM tendency =', amdt/(bdt*1.e18), 'del-u (per yr)=', u0*365.*86400./bdt
!         write(6,*) 'Dynamic Angular Momentum tendency (Hadleys)=', amdt/(bdt*1.e18)
        END IF
!  consv_am
        IF (consv_am) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,m_fac,u0,gridstruct)
          DO j=js,je
            DO i=is,ie
              m_fac(i, j) = u0*COS(gridstruct%agrid(i, j, 2))
            END DO
          END DO
!$OMP parallel do default(none) shared(is,ie,js,je,npz,hydrostatic,pt,m_fac,ua,cp_air, &
!$OMP                                  rcv,u,u0,gridstruct,v )
          IF (hydrostatic) THEN
            DO k=1,npz
              DO j=js,je
                DO i=is,ie
                  pt(i, j, k) = pt(i, j, k) - m_fac(i, j)*(0.5*m_fac(i, &
&                   j)+ua(i, j, k))/cp_air
                END DO
              END DO
            END DO
          ELSE
            DO k=1,npz
              DO j=js,je
                DO i=is,ie
                  pt(i, j, k) = pt(i, j, k) - m_fac(i, j)*(0.5*m_fac(i, &
&                   j)+ua(i, j, k))*rcv
                END DO
              END DO
            END DO
          END IF
          DO k=1,npz
            DO j=js,je+1
              DO i=is,ie
                u(i, j, k) = u(i, j, k) + u0*gridstruct%l2c_u(i, j)
              END DO
            END DO
            DO j=js,je
              DO i=is,ie+1
                v(i, j, k) = v(i, j, k) + u0*gridstruct%l2c_v(i, j)
              END DO
            END DO
          END DO
        END IF
      END IF
    END IF
    CALL CUBED_TO_LATLON(u, v, ua, va, gridstruct, npx, npy, npz, 1, &
&                  gridstruct%grid_type, domain, gridstruct%nested, &
&                  flagstruct%c2l_ord, bd)
!     if ( flagstruct%fv_debug ) then
!       call prt_mxm('UA', ua, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!       call prt_mxm('VA', va, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!       call prt_mxm('TA', pt, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!     endif
!  if ( flagstruct%range_warn ) then
!       call range_check('UA_dyn', ua, is, ie, js, je, ng, npz, gridstruct%agrid,   &
!                         -220._FVPRC, 260._FVPRC, bad_range)
!       call range_check('VA_dyn', ua, is, ie, js, je, ng, npz, gridstruct%agrid,   &
!                         -220._FVPRC, 220._FVPRC, bad_range)
!!#ifndef SW_DYNAMICS
!       call range_check('TA_dyn', pt, is, ie, js, je, ng, npz, gridstruct%agrid,   &
!                         160._FVPRC, 330._FVPRC, bad_range)
!       if ( .not. hydrostatic ) &
!       call range_check('W_dyn', w, is, ie, js, je, ng, npz, gridstruct%agrid,   &
!                         -20._FVPRC, 20._FVPRC, bad_range)
!!#endif
!
!  endif
!deallocate ( dp1 )
!deallocate ( cappa )
!Convert back to potential temperature
    IF (hydrostatic) CALL FV3_TO_GEOS(bd, npz, pkz, pt)
  END SUBROUTINE FV_DYNAMICS
!  Differentiation of rayleigh_super in forward (tangent) mode (with options r8):
!   variations   of useful results: u v w ua va pt
!   with respect to varying inputs: u v w ua va pt
  SUBROUTINE RAYLEIGH_SUPER_TLM(dt, npx, npy, npz, ks, pm, phis, tau, u&
&   , u_tl, v, v_tl, w, w_tl, pt, pt_tl, ua, ua_tl, va, va_tl, delz, &
&   agrid, cp, rg, ptop, hydrostatic, conserve, rf_cutoff, gridstruct, &
&   domain, bd)
    IMPLICIT NONE
!#endif
!deallocate ( u2f )
    REAL(fvprc), INTENT(IN) :: dt
! time scale (days)
    REAL(fvprc), INTENT(IN) :: tau
    REAL(fvprc), INTENT(IN) :: cp, rg, ptop, rf_cutoff
    INTEGER, INTENT(IN) :: npx, npy, npz, ks
    REAL(fvprc), DIMENSION(npz), INTENT(IN) :: pm
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: conserve
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! D grid zonal wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: u_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
! D grid meridional wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: v_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
! cell center vertical wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%isd, bd%jsd:bd%jsd, npz)
    REAL(fvprc), INTENT(INOUT) :: w_tl(bd%isd:bd%isd, bd%jsd:bd%jsd, npz&
&   )
! temp
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: pt_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
! 
    REAL(fvprc), INTENT(INOUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: ua_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
! 
    REAL(fvprc), INTENT(INOUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: va_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
! delta-height (m); non-hydrostatic only
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(IN) :: agrid(bd%isd:bd%ied, bd%jsd:bd%jed, 2)
! Surface geopotential (g*Z_surf)
    REAL(fvprc), INTENT(IN) :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
    TYPE(FV_GRID_TYPE), INTENT(IN) :: gridstruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
!
    REAL(fvprc) :: u2f(bd%isd:bd%ied, bd%jsd:bd%jed, kmax)
    REAL(fvprc) :: u2f_tl(bd%isd:bd%ied, bd%jsd:bd%jed, kmax)
! scaling velocity
    REAL(fvprc), PARAMETER :: u0=60.
    REAL(fvprc), PARAMETER :: sday=86400.
    REAL(fvprc) :: rcv, tau0
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    REAL(fvprc) :: rf(npz)
    INTRINSIC LOG
    INTRINSIC SIN
    INTRINSIC ABS
    INTRINSIC COS
    INTRINSIC SQRT
    REAL(fvprc) :: abs0
    REAL(fvprc) :: abs1
    REAL(fvprc) :: abs2
    REAL(fvprc) :: arg1
    REAL(fvprc) :: arg1_tl
    REAL(fvprc) :: result1
    REAL(fvprc) :: result1_tl
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    rcv = 1./(cp-rg)
    IF (.NOT.rf_initialized) THEN
!#ifdef HIWPP
!          allocate ( u00(is:ie,  js:je+1,npz) )
!          allocate ( v00(is:ie+1,js:je  ,npz) )
!!$OMP parallel do default(none) shared(is,ie,js,je,npz,u00,u,v00,v)
!          do k=1,npz
!             do j=js,je+1
!                do i=is,ie
!                   u00(i,j,k) = u(i,j,k)
!                enddo
!             enddo
!             do j=js,je
!                do i=is,ie+1
!                   v00(i,j,k) = v(i,j,k)
!                enddo
!             enddo
!          enddo
!#endif
!#ifdef SMALL_EARTH
!          tau0 = tau
!#else
      tau0 = tau*sday
!#endif
!allocate( rf(npz) )
      rf(:) = 0.
!if( is_master() ) write(6,*) 'Rayleigh friction E-folding time (days):'
      DO k=1,npz
        IF (pm(k) .LT. rf_cutoff) THEN
          arg1 = 0.5*pi*LOG(rf_cutoff/pm(k))/LOG(rf_cutoff/ptop)
          rf(k) = dt/tau0*SIN(arg1)**2
!if( is_master() ) write(6,*) k, 0.01*pm(k), dt/(rf(k)*sday)
          kmax = k
        ELSE
          EXIT
        END IF
      END DO
      rf_initialized = .true.
    END IF
    CALL C2L_ORD2_TLM(u, u_tl, v, v_tl, ua, ua_tl, va, va_tl, gridstruct&
&               , npz, gridstruct%grid_type, bd)
    u2f_tl = 0.0_FVPRC
!allocate( u2f(isd:ied,jsd:jed,kmax) )
!$OMP parallel do default(none) shared(is,ie,js,je,kmax,pm,rf_cutoff,hydrostatic,ua,va,agrid, &
!$OMP                                  u2f,rf,w)
    DO k=1,kmax
! p check
      IF (pm(k) .LT. rf_cutoff) THEN
        DO j=js,je
          IF (hydrostatic) THEN
            DO i=is,ie
              IF (ua(i, j, k) .GE. 0.) THEN
                abs0 = ua(i, j, k)
              ELSE
                abs0 = -ua(i, j, k)
              END IF
              IF (abs0 .GT. 35.*COS(agrid(i, j, 2))) THEN
                arg1_tl = 2*ua(i, j, k)*ua_tl(i, j, k) + 2*va(i, j, k)*&
&                 va_tl(i, j, k)
                arg1 = ua(i, j, k)**2 + va(i, j, k)**2
                IF (arg1 .EQ. 0.0_FVPRC) THEN
                  result1_tl = 0.0_FVPRC
                ELSE
                  result1_tl = arg1_tl/(2.0*SQRT(arg1))
                END IF
                result1 = SQRT(arg1)
                u2f_tl(i, j, k) = -(rf(k)*result1_tl/u0/(1.+rf(k)*&
&                 result1/u0)**2)
                u2f(i, j, k) = 1./(1.+rf(k)*result1/u0)
              ELSE
                u2f_tl(i, j, k) = 0.0_FVPRC
                u2f(i, j, k) = 1.
              END IF
            END DO
          ELSE
            DO i=is,ie
              IF (ua(i, j, k) .GE. 0.) THEN
                abs1 = ua(i, j, k)
              ELSE
                abs1 = -ua(i, j, k)
              END IF
              IF (w(i, j, k) .GE. 0.) THEN
                abs2 = w(i, j, k)
              ELSE
                abs2 = -w(i, j, k)
              END IF
              IF (abs1 .GT. 35.*COS(agrid(i, j, 2)) .OR. abs2 .GT. 7.5) &
&             THEN
                arg1_tl = 2*ua(i, j, k)*ua_tl(i, j, k) + 2*va(i, j, k)*&
&                 va_tl(i, j, k) + 2*w(i, j, k)*w_tl(i, j, k)
                arg1 = ua(i, j, k)**2 + va(i, j, k)**2 + w(i, j, k)**2
                IF (arg1 .EQ. 0.0_FVPRC) THEN
                  result1_tl = 0.0_FVPRC
                ELSE
                  result1_tl = arg1_tl/(2.0*SQRT(arg1))
                END IF
                result1 = SQRT(arg1)
                u2f_tl(i, j, k) = -(rf(k)*result1_tl/u0/(1.+rf(k)*&
&                 result1/u0)**2)
                u2f(i, j, k) = 1./(1.+rf(k)*result1/u0)
              ELSE
                u2f_tl(i, j, k) = 0.0_FVPRC
                u2f(i, j, k) = 1.
              END IF
            END DO
          END IF
        END DO
      END IF
    END DO
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
    CALL MPP_UPDATE_DOMAINS_TLM(u2f, u2f_tl, domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!$OMP parallel do default(none) shared(is,ie,js,je,kmax,pm,rf_cutoff,w,rf,u,v,u00,v00, &
!$OMP                                  conserve,hydrostatic,pt,ua,va,u2f,cp,rg,ptop,rcv)
    DO k=1,kmax
      IF (pm(k) .LT. rf_cutoff) THEN
!#ifdef HIWPP
!             do j=js,je
!                do i=is,ie
!                   w(i,j,k) = w(i,j,k)/(1.+rf(k))
!                enddo
!             enddo
!             do j=js,je+1
!                do i=is,ie
!                   u(i,j,k) = (u(i,j,k)+rf(k)*u00(i,j,k))/(1.+rf(k))
!                enddo
!             enddo
!             do j=js,je
!                do i=is,ie+1
!                   v(i,j,k) = (v(i,j,k)+rf(k)*v00(i,j,k))/(1.+rf(k))
!                enddo
!             enddo
!#else
! Add heat so as to conserve TE
        IF (conserve) THEN
          IF (hydrostatic) THEN
            DO j=js,je
              DO i=is,ie
                pt_tl(i, j, k) = pt_tl(i, j, k) + 0.5*((2*ua(i, j, k)*&
&                 ua_tl(i, j, k)+2*va(i, j, k)*va_tl(i, j, k))*(1.-u2f(i&
&                 , j, k)**2)-(ua(i, j, k)**2+va(i, j, k)**2)*2*u2f(i, j&
&                 , k)*u2f_tl(i, j, k))/(cp-rg*ptop/pm(k))
                pt(i, j, k) = pt(i, j, k) + 0.5*(ua(i, j, k)**2+va(i, j&
&                 , k)**2)*(1.-u2f(i, j, k)**2)/(cp-rg*ptop/pm(k))
              END DO
            END DO
          ELSE
            DO j=js,je
              DO i=is,ie
                pt_tl(i, j, k) = pt_tl(i, j, k) + 0.5*rcv*((2*ua(i, j, k&
&                 )*ua_tl(i, j, k)+2*va(i, j, k)*va_tl(i, j, k)+2*w(i, j&
&                 , k)*w_tl(i, j, k))*(1.-u2f(i, j, k)**2)-(ua(i, j, k)&
&                 **2+va(i, j, k)**2+w(i, j, k)**2)*2*u2f(i, j, k)*&
&                 u2f_tl(i, j, k))
                pt(i, j, k) = pt(i, j, k) + 0.5*(ua(i, j, k)**2+va(i, j&
&                 , k)**2+w(i, j, k)**2)*(1.-u2f(i, j, k)**2)*rcv
              END DO
            END DO
          END IF
        END IF
        DO j=js,je+1
          DO i=is,ie
            u_tl(i, j, k) = 0.5*((u2f_tl(i, j-1, k)+u2f_tl(i, j, k))*u(i&
&             , j, k)+(u2f(i, j-1, k)+u2f(i, j, k))*u_tl(i, j, k))
            u(i, j, k) = 0.5*(u2f(i, j-1, k)+u2f(i, j, k))*u(i, j, k)
          END DO
        END DO
        DO j=js,je
          DO i=is,ie+1
            v_tl(i, j, k) = 0.5*((u2f_tl(i-1, j, k)+u2f_tl(i, j, k))*v(i&
&             , j, k)+(u2f(i-1, j, k)+u2f(i, j, k))*v_tl(i, j, k))
            v(i, j, k) = 0.5*(u2f(i-1, j, k)+u2f(i, j, k))*v(i, j, k)
          END DO
        END DO
        IF (.NOT.hydrostatic) THEN
          DO j=js,je
            DO i=is,ie
              w_tl(i, j, k) = u2f_tl(i, j, k)*w(i, j, k) + u2f(i, j, k)*&
&               w_tl(i, j, k)
              w(i, j, k) = u2f(i, j, k)*w(i, j, k)
            END DO
          END DO
        END IF
      END IF
    END DO
  END SUBROUTINE RAYLEIGH_SUPER_TLM
  SUBROUTINE RAYLEIGH_SUPER(dt, npx, npy, npz, ks, pm, phis, tau, u, v, &
&   w, pt, ua, va, delz, agrid, cp, rg, ptop, hydrostatic, conserve, &
&   rf_cutoff, gridstruct, domain, bd)
    IMPLICIT NONE
!#endif
!deallocate ( u2f )
    REAL(fvprc), INTENT(IN) :: dt
! time scale (days)
    REAL(fvprc), INTENT(IN) :: tau
    REAL(fvprc), INTENT(IN) :: cp, rg, ptop, rf_cutoff
    INTEGER, INTENT(IN) :: npx, npy, npz, ks
    REAL(fvprc), DIMENSION(npz), INTENT(IN) :: pm
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: conserve
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! D grid zonal wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
! D grid meridional wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
! cell center vertical wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%isd, bd%jsd:bd%jsd, npz)
! temp
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! 
    REAL(fvprc), INTENT(INOUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! 
    REAL(fvprc), INTENT(INOUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! delta-height (m); non-hydrostatic only
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(IN) :: agrid(bd%isd:bd%ied, bd%jsd:bd%jed, 2)
! Surface geopotential (g*Z_surf)
    REAL(fvprc), INTENT(IN) :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
    TYPE(FV_GRID_TYPE), INTENT(IN) :: gridstruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
!
    REAL(fvprc) :: u2f(bd%isd:bd%ied, bd%jsd:bd%jed, kmax)
! scaling velocity
    REAL(fvprc), PARAMETER :: u0=60.
    REAL(fvprc), PARAMETER :: sday=86400.
    REAL(fvprc) :: rcv, tau0
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    REAL(fvprc) :: rf(npz)
    INTRINSIC LOG
    INTRINSIC SIN
    INTRINSIC ABS
    INTRINSIC COS
    INTRINSIC SQRT
    REAL(fvprc) :: abs0
    REAL(fvprc) :: abs1
    REAL(fvprc) :: abs2
    REAL(fvprc) :: arg1
    REAL(fvprc) :: result1
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    rcv = 1./(cp-rg)
    IF (.NOT.rf_initialized) THEN
!#ifdef HIWPP
!          allocate ( u00(is:ie,  js:je+1,npz) )
!          allocate ( v00(is:ie+1,js:je  ,npz) )
!!$OMP parallel do default(none) shared(is,ie,js,je,npz,u00,u,v00,v)
!          do k=1,npz
!             do j=js,je+1
!                do i=is,ie
!                   u00(i,j,k) = u(i,j,k)
!                enddo
!             enddo
!             do j=js,je
!                do i=is,ie+1
!                   v00(i,j,k) = v(i,j,k)
!                enddo
!             enddo
!          enddo
!#endif
!#ifdef SMALL_EARTH
!          tau0 = tau
!#else
      tau0 = tau*sday
!#endif
!allocate( rf(npz) )
      rf(:) = 0.
!if( is_master() ) write(6,*) 'Rayleigh friction E-folding time (days):'
      DO k=1,npz
        IF (pm(k) .LT. rf_cutoff) THEN
          arg1 = 0.5*pi*LOG(rf_cutoff/pm(k))/LOG(rf_cutoff/ptop)
          rf(k) = dt/tau0*SIN(arg1)**2
!if( is_master() ) write(6,*) k, 0.01*pm(k), dt/(rf(k)*sday)
          kmax = k
        ELSE
          GOTO 100
        END IF
      END DO
 100  rf_initialized = .true.
    END IF
    CALL C2L_ORD2(u, v, ua, va, gridstruct, npz, gridstruct%grid_type, &
&           bd)
!allocate( u2f(isd:ied,jsd:jed,kmax) )
!$OMP parallel do default(none) shared(is,ie,js,je,kmax,pm,rf_cutoff,hydrostatic,ua,va,agrid, &
!$OMP                                  u2f,rf,w)
    DO k=1,kmax
! p check
      IF (pm(k) .LT. rf_cutoff) THEN
        DO j=js,je
          IF (hydrostatic) THEN
            DO i=is,ie
              IF (ua(i, j, k) .GE. 0.) THEN
                abs0 = ua(i, j, k)
              ELSE
                abs0 = -ua(i, j, k)
              END IF
              IF (abs0 .GT. 35.*COS(agrid(i, j, 2))) THEN
                arg1 = ua(i, j, k)**2 + va(i, j, k)**2
                result1 = SQRT(arg1)
                u2f(i, j, k) = 1./(1.+rf(k)*result1/u0)
              ELSE
                u2f(i, j, k) = 1.
              END IF
            END DO
          ELSE
            DO i=is,ie
              IF (ua(i, j, k) .GE. 0.) THEN
                abs1 = ua(i, j, k)
              ELSE
                abs1 = -ua(i, j, k)
              END IF
              IF (w(i, j, k) .GE. 0.) THEN
                abs2 = w(i, j, k)
              ELSE
                abs2 = -w(i, j, k)
              END IF
              IF (abs1 .GT. 35.*COS(agrid(i, j, 2)) .OR. abs2 .GT. 7.5) &
&             THEN
                arg1 = ua(i, j, k)**2 + va(i, j, k)**2 + w(i, j, k)**2
                result1 = SQRT(arg1)
                u2f(i, j, k) = 1./(1.+rf(k)*result1/u0)
              ELSE
                u2f(i, j, k) = 1.
              END IF
            END DO
          END IF
        END DO
      END IF
    END DO
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
    CALL MPP_UPDATE_DOMAINS(u2f, domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!$OMP parallel do default(none) shared(is,ie,js,je,kmax,pm,rf_cutoff,w,rf,u,v,u00,v00, &
!$OMP                                  conserve,hydrostatic,pt,ua,va,u2f,cp,rg,ptop,rcv)
    DO k=1,kmax
      IF (pm(k) .LT. rf_cutoff) THEN
!#ifdef HIWPP
!             do j=js,je
!                do i=is,ie
!                   w(i,j,k) = w(i,j,k)/(1.+rf(k))
!                enddo
!             enddo
!             do j=js,je+1
!                do i=is,ie
!                   u(i,j,k) = (u(i,j,k)+rf(k)*u00(i,j,k))/(1.+rf(k))
!                enddo
!             enddo
!             do j=js,je
!                do i=is,ie+1
!                   v(i,j,k) = (v(i,j,k)+rf(k)*v00(i,j,k))/(1.+rf(k))
!                enddo
!             enddo
!#else
! Add heat so as to conserve TE
        IF (conserve) THEN
          IF (hydrostatic) THEN
            DO j=js,je
              DO i=is,ie
                pt(i, j, k) = pt(i, j, k) + 0.5*(ua(i, j, k)**2+va(i, j&
&                 , k)**2)*(1.-u2f(i, j, k)**2)/(cp-rg*ptop/pm(k))
              END DO
            END DO
          ELSE
            DO j=js,je
              DO i=is,ie
                pt(i, j, k) = pt(i, j, k) + 0.5*(ua(i, j, k)**2+va(i, j&
&                 , k)**2+w(i, j, k)**2)*(1.-u2f(i, j, k)**2)*rcv
              END DO
            END DO
          END IF
        END IF
        DO j=js,je+1
          DO i=is,ie
            u(i, j, k) = 0.5*(u2f(i, j-1, k)+u2f(i, j, k))*u(i, j, k)
          END DO
        END DO
        DO j=js,je
          DO i=is,ie+1
            v(i, j, k) = 0.5*(u2f(i-1, j, k)+u2f(i, j, k))*v(i, j, k)
          END DO
        END DO
        IF (.NOT.hydrostatic) THEN
          DO j=js,je
            DO i=is,ie
              w(i, j, k) = u2f(i, j, k)*w(i, j, k)
            END DO
          END DO
        END IF
      END IF
    END DO
  END SUBROUTINE RAYLEIGH_SUPER
!  Differentiation of rayleigh_friction in forward (tangent) mode (with options r8):
!   variations   of useful results: u v w ua delz va pt
!   with respect to varying inputs: u v w ua delz va pt
  SUBROUTINE RAYLEIGH_FRICTION_TLM(dt, npx, npy, npz, ks, pm, tau, u, &
&   u_tl, v, v_tl, w, w_tl, pt, pt_tl, ua, ua_tl, va, va_tl, delz, &
&   delz_tl, cp, rg, ptop, hydrostatic, conserve, rf_cutoff, gridstruct&
&   , domain, bd)
    IMPLICIT NONE
!deallocate ( u2f )
    REAL(fvprc), INTENT(IN) :: dt
! time scale (days)
    REAL(fvprc), INTENT(IN) :: tau
    REAL(fvprc), INTENT(IN) :: cp, rg, ptop, rf_cutoff
    INTEGER, INTENT(IN) :: npx, npy, npz, ks
    REAL(fvprc), DIMENSION(npz), INTENT(IN) :: pm
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: conserve
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! D grid zonal wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: u_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
! D grid meridional wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: v_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
! cell center vertical wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: w_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! temp
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: pt_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
! 
    REAL(fvprc), INTENT(INOUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: ua_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
! 
    REAL(fvprc), INTENT(INOUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: va_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
! delta-height (m); non-hydrostatic only
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: delz_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    TYPE(FV_GRID_TYPE), INTENT(IN) :: gridstruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
! local:
    REAL(fvprc) :: u2f(bd%isd:bd%ied, bd%jsd:bd%jed, kmax)
    REAL(fvprc) :: u2f_tl(bd%isd:bd%ied, bd%jsd:bd%jed, kmax)
    REAL(fvprc), PARAMETER :: sday=86400.
! scaling velocity  **2
    REAL(fvprc), PARAMETER :: u000=4900.
    REAL(fvprc) :: rcv
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    REAL(fvprc) :: rf(npz)
    INTRINSIC LOG
    INTRINSIC SIN
    INTRINSIC SQRT
    REAL(fvprc) :: arg1
    REAL(fvprc) :: arg1_tl
    REAL(fvprc) :: result1
    REAL(fvprc) :: result1_tl
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    rcv = 1./(cp-rg)
    IF (.NOT.rf_initialized) THEN
!allocate( rf(npz) )
!if( is_master() ) write(6,*) 'Rayleigh friction E-folding time (days):'
      DO k=1,npz
        IF (pm(k) .LT. rf_cutoff) THEN
          arg1 = 0.5*pi*LOG(rf_cutoff/pm(k))/LOG(rf_cutoff/ptop)
          rf(k) = dt/(tau*sday)*SIN(arg1)**2
!if( is_master() ) write(6,*) k, 0.01*pm(k), dt/(rf(k)*sday)
          kmax = k
        ELSE
          EXIT
        END IF
      END DO
      rf_initialized = .true.
    END IF
!allocate( u2f(isd:ied,jsd:jed,kmax) )
    CALL C2L_ORD2_TLM(u, u_tl, v, v_tl, ua, ua_tl, va, va_tl, gridstruct&
&               , npz, gridstruct%grid_type, bd)
    u2f = 0.
    u2f_tl = 0.0_FVPRC
!$OMP parallel do default(none) shared(is,ie,js,je,kmax,u2f,hydrostatic,ua,va,w)
    DO k=1,kmax
      IF (hydrostatic) THEN
        DO j=js,je
          DO i=is,ie
            u2f_tl(i, j, k) = 2*ua(i, j, k)*ua_tl(i, j, k) + 2*va(i, j, &
&             k)*va_tl(i, j, k)
            u2f(i, j, k) = ua(i, j, k)**2 + va(i, j, k)**2
          END DO
        END DO
      ELSE
        DO j=js,je
          DO i=is,ie
            u2f_tl(i, j, k) = 2*ua(i, j, k)*ua_tl(i, j, k) + 2*va(i, j, &
&             k)*va_tl(i, j, k) + 2*w(i, j, k)*w_tl(i, j, k)
            u2f(i, j, k) = ua(i, j, k)**2 + va(i, j, k)**2 + w(i, j, k)&
&             **2
          END DO
        END DO
      END IF
    END DO
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
    CALL MPP_UPDATE_DOMAINS_TLM(u2f, u2f_tl, domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!$OMP parallel do default(none) shared(is,ie,js,je,kmax,conserve,hydrostatic,pt,u2f,cp,rg, &
!$OMP                                  ptop,pm,rf,delz,rcv,u,v,w)
    DO k=1,kmax
      IF (conserve) THEN
        IF (hydrostatic) THEN
          DO j=js,je
            DO i=is,ie
              arg1_tl = u2f_tl(i, j, k)/u000
              arg1 = u2f(i, j, k)/u000
              IF (arg1 .EQ. 0.0_FVPRC) THEN
                result1_tl = 0.0_FVPRC
              ELSE
                result1_tl = arg1_tl/(2.0*SQRT(arg1))
              END IF
              result1 = SQRT(arg1)
              pt_tl(i, j, k) = pt_tl(i, j, k) + 0.5*u2f_tl(i, j, k)*(1.-&
&               1./(1.+rf(k)*result1)**2)/(cp-rg*ptop/pm(k)) + 0.5*u2f(i&
&               , j, k)*2*rf(k)*result1_tl/((cp-rg*ptop/pm(k))*(1.+rf(k)&
&               *result1)**3)
              pt(i, j, k) = pt(i, j, k) + 0.5*u2f(i, j, k)/(cp-rg*ptop/&
&               pm(k))*(1.-1./(1.+rf(k)*result1)**2)
            END DO
          END DO
        ELSE
          DO j=js,je
            DO i=is,ie
              delz_tl(i, j, k) = (delz_tl(i, j, k)*pt(i, j, k)-delz(i, j&
&               , k)*pt_tl(i, j, k))/pt(i, j, k)**2
              delz(i, j, k) = delz(i, j, k)/pt(i, j, k)
              arg1_tl = u2f_tl(i, j, k)/u000
              arg1 = u2f(i, j, k)/u000
              IF (arg1 .EQ. 0.0_FVPRC) THEN
                result1_tl = 0.0_FVPRC
              ELSE
                result1_tl = arg1_tl/(2.0*SQRT(arg1))
              END IF
              result1 = SQRT(arg1)
              pt_tl(i, j, k) = pt_tl(i, j, k) + 0.5*rcv*(u2f_tl(i, j, k)&
&               *(1.-1./(1.+rf(k)*result1)**2)+u2f(i, j, k)*2*rf(k)*&
&               result1_tl/(1.+rf(k)*result1)**3)
              pt(i, j, k) = pt(i, j, k) + 0.5*u2f(i, j, k)*rcv*(1.-1./(&
&               1.+rf(k)*result1)**2)
              delz_tl(i, j, k) = delz_tl(i, j, k)*pt(i, j, k) + delz(i, &
&               j, k)*pt_tl(i, j, k)
              delz(i, j, k) = delz(i, j, k)*pt(i, j, k)
            END DO
          END DO
        END IF
      END IF
      DO j=js-1,je+1
        DO i=is-1,ie+1
          arg1_tl = u2f_tl(i, j, k)/u000
          arg1 = u2f(i, j, k)/u000
          IF (arg1 .EQ. 0.0_FVPRC) THEN
            result1_tl = 0.0_FVPRC
          ELSE
            result1_tl = arg1_tl/(2.0*SQRT(arg1))
          END IF
          result1 = SQRT(arg1)
          u2f_tl(i, j, k) = rf(k)*result1_tl
          u2f(i, j, k) = rf(k)*result1
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          u_tl(i, j, k) = (u_tl(i, j, k)*(1.+0.5*(u2f(i, j-1, k)+u2f(i, &
&           j, k)))-u(i, j, k)*0.5*(u2f_tl(i, j-1, k)+u2f_tl(i, j, k)))/&
&           (1.+0.5*(u2f(i, j-1, k)+u2f(i, j, k)))**2
          u(i, j, k) = u(i, j, k)/(1.+0.5*(u2f(i, j-1, k)+u2f(i, j, k)))
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          v_tl(i, j, k) = (v_tl(i, j, k)*(1.+0.5*(u2f(i-1, j, k)+u2f(i, &
&           j, k)))-v(i, j, k)*0.5*(u2f_tl(i-1, j, k)+u2f_tl(i, j, k)))/&
&           (1.+0.5*(u2f(i-1, j, k)+u2f(i, j, k)))**2
          v(i, j, k) = v(i, j, k)/(1.+0.5*(u2f(i-1, j, k)+u2f(i, j, k)))
        END DO
      END DO
      IF (.NOT.hydrostatic) THEN
        DO j=js,je
          DO i=is,ie
            w_tl(i, j, k) = (w_tl(i, j, k)*(1.+u2f(i, j, k))-w(i, j, k)*&
&             u2f_tl(i, j, k))/(1.+u2f(i, j, k))**2
            w(i, j, k) = w(i, j, k)/(1.+u2f(i, j, k))
          END DO
        END DO
      END IF
    END DO
  END SUBROUTINE RAYLEIGH_FRICTION_TLM
  SUBROUTINE RAYLEIGH_FRICTION(dt, npx, npy, npz, ks, pm, tau, u, v, w, &
&   pt, ua, va, delz, cp, rg, ptop, hydrostatic, conserve, rf_cutoff, &
&   gridstruct, domain, bd)
    IMPLICIT NONE
!deallocate ( u2f )
    REAL(fvprc), INTENT(IN) :: dt
! time scale (days)
    REAL(fvprc), INTENT(IN) :: tau
    REAL(fvprc), INTENT(IN) :: cp, rg, ptop, rf_cutoff
    INTEGER, INTENT(IN) :: npx, npy, npz, ks
    REAL(fvprc), DIMENSION(npz), INTENT(IN) :: pm
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: conserve
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! D grid zonal wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
! D grid meridional wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
! cell center vertical wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! temp
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! 
    REAL(fvprc), INTENT(INOUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! 
    REAL(fvprc), INTENT(INOUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! delta-height (m); non-hydrostatic only
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    TYPE(FV_GRID_TYPE), INTENT(IN) :: gridstruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
! local:
    REAL(fvprc) :: u2f(bd%isd:bd%ied, bd%jsd:bd%jed, kmax)
    REAL(fvprc), PARAMETER :: sday=86400.
! scaling velocity  **2
    REAL(fvprc), PARAMETER :: u000=4900.
    REAL(fvprc) :: rcv
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    REAL(fvprc) :: rf(npz)
    INTRINSIC LOG
    INTRINSIC SIN
    INTRINSIC SQRT
    REAL(fvprc) :: arg1
    REAL(fvprc) :: result1
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    rcv = 1./(cp-rg)
    IF (.NOT.rf_initialized) THEN
!allocate( rf(npz) )
!if( is_master() ) write(6,*) 'Rayleigh friction E-folding time (days):'
      DO k=1,npz
        IF (pm(k) .LT. rf_cutoff) THEN
          arg1 = 0.5*pi*LOG(rf_cutoff/pm(k))/LOG(rf_cutoff/ptop)
          rf(k) = dt/(tau*sday)*SIN(arg1)**2
!if( is_master() ) write(6,*) k, 0.01*pm(k), dt/(rf(k)*sday)
          kmax = k
        ELSE
          GOTO 100
        END IF
      END DO
 100  rf_initialized = .true.
    END IF
!allocate( u2f(isd:ied,jsd:jed,kmax) )
    CALL C2L_ORD2(u, v, ua, va, gridstruct, npz, gridstruct%grid_type, &
&           bd)
    u2f = 0.
!$OMP parallel do default(none) shared(is,ie,js,je,kmax,u2f,hydrostatic,ua,va,w)
    DO k=1,kmax
      IF (hydrostatic) THEN
        DO j=js,je
          DO i=is,ie
            u2f(i, j, k) = ua(i, j, k)**2 + va(i, j, k)**2
          END DO
        END DO
      ELSE
        DO j=js,je
          DO i=is,ie
            u2f(i, j, k) = ua(i, j, k)**2 + va(i, j, k)**2 + w(i, j, k)&
&             **2
          END DO
        END DO
      END IF
    END DO
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
    CALL MPP_UPDATE_DOMAINS(u2f, domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!$OMP parallel do default(none) shared(is,ie,js,je,kmax,conserve,hydrostatic,pt,u2f,cp,rg, &
!$OMP                                  ptop,pm,rf,delz,rcv,u,v,w)
    DO k=1,kmax
      IF (conserve) THEN
        IF (hydrostatic) THEN
          DO j=js,je
            DO i=is,ie
              arg1 = u2f(i, j, k)/u000
              result1 = SQRT(arg1)
              pt(i, j, k) = pt(i, j, k) + 0.5*u2f(i, j, k)/(cp-rg*ptop/&
&               pm(k))*(1.-1./(1.+rf(k)*result1)**2)
            END DO
          END DO
        ELSE
          DO j=js,je
            DO i=is,ie
              delz(i, j, k) = delz(i, j, k)/pt(i, j, k)
              arg1 = u2f(i, j, k)/u000
              result1 = SQRT(arg1)
              pt(i, j, k) = pt(i, j, k) + 0.5*u2f(i, j, k)*rcv*(1.-1./(&
&               1.+rf(k)*result1)**2)
              delz(i, j, k) = delz(i, j, k)*pt(i, j, k)
            END DO
          END DO
        END IF
      END IF
      DO j=js-1,je+1
        DO i=is-1,ie+1
          arg1 = u2f(i, j, k)/u000
          result1 = SQRT(arg1)
          u2f(i, j, k) = rf(k)*result1
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          u(i, j, k) = u(i, j, k)/(1.+0.5*(u2f(i, j-1, k)+u2f(i, j, k)))
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          v(i, j, k) = v(i, j, k)/(1.+0.5*(u2f(i-1, j, k)+u2f(i, j, k)))
        END DO
      END DO
      IF (.NOT.hydrostatic) THEN
        DO j=js,je
          DO i=is,ie
            w(i, j, k) = w(i, j, k)/(1.+u2f(i, j, k))
          END DO
        END DO
      END IF
    END DO
  END SUBROUTINE RAYLEIGH_FRICTION
!  Differentiation of compute_aam in forward (tangent) mode (with options r8):
!   variations   of useful results: ua aam va m_fac ps
!   with respect to varying inputs: u v delp ua aam m_fac ps
  SUBROUTINE COMPUTE_AAM_TLM(npz, is, ie, js, je, isd, ied, jsd, jed, &
&   gridstruct, bd, ptop, ua, ua_tl, va, va_tl, u, u_tl, v, v_tl, delp, &
&   delp_tl, aam, aam_tl, ps, ps_tl, m_fac, m_fac_tl)
    IMPLICIT NONE
! Compute vertically (mass) integrated Atmospheric Angular Momentum
    INTEGER, INTENT(IN) :: npz
    INTEGER, INTENT(IN) :: is, ie, js, je
    INTEGER, INTENT(IN) :: isd, ied, jsd, jed
    REAL(fvprc), INTENT(IN) :: ptop
! D grid zonal wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: u(isd:ied, jsd:jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: u_tl(isd:ied, jsd:jed+1, npz)
! D grid meridional wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: v(isd:ied+1, jsd:jed, npz)
    REAL(fvprc), INTENT(INOUT) :: v_tl(isd:ied+1, jsd:jed, npz)
    REAL(fvprc), INTENT(INOUT) :: delp(isd:ied, jsd:jed, npz)
    REAL(fvprc), INTENT(INOUT) :: delp_tl(isd:ied, jsd:jed, npz)
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(INOUT) :: ua, &
&   va
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(INOUT) :: &
&   ua_tl, va_tl
    REAL(fvprc), INTENT(OUT) :: aam(is:ie, js:je)
    REAL(fvprc), INTENT(OUT) :: aam_tl(is:ie, js:je)
    REAL(fvprc), INTENT(OUT) :: m_fac(is:ie, js:je)
    REAL(fvprc), INTENT(OUT) :: m_fac_tl(is:ie, js:je)
    REAL(fvprc), INTENT(OUT) :: ps(isd:ied, jsd:jed)
    REAL(fvprc), INTENT(OUT) :: ps_tl(isd:ied, jsd:jed)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    TYPE(FV_GRID_TYPE), INTENT(IN) :: gridstruct
! local:
    REAL(fvprc), DIMENSION(is:ie) :: r1, r2, dm
    REAL(fvprc), DIMENSION(is:ie) :: dm_tl
    INTEGER :: i, j, k
    INTRINSIC COS
    va_tl = 0.0_FVPRC
    CALL C2L_ORD2_TLM(u, u_tl, v, v_tl, ua, ua_tl, va, va_tl, gridstruct&
&               , npz, gridstruct%grid_type, bd)
    dm_tl = 0.0_FVPRC
!$OMP parallel do default(none) shared(is,ie,js,je,npz,gridstruct,aam,m_fac,ps,ptop,delp,agrav,ua) &
!$OMP                          private(r1, r2, dm)
    DO j=js,je
      DO i=is,ie
        r1(i) = radius*COS(gridstruct%agrid(i, j, 2))
        r2(i) = r1(i)*r1(i)
        aam_tl(i, j) = 0.0_FVPRC
        aam(i, j) = 0.
        m_fac_tl(i, j) = 0.0_FVPRC
        m_fac(i, j) = 0.
        ps_tl(i, j) = 0.0_FVPRC
        ps(i, j) = ptop
      END DO
      DO k=1,npz
        DO i=is,ie
          dm_tl(i) = delp_tl(i, j, k)
          dm(i) = delp(i, j, k)
          ps_tl(i, j) = ps_tl(i, j) + dm_tl(i)
          ps(i, j) = ps(i, j) + dm(i)
          dm_tl(i) = agrav*dm_tl(i)
          dm(i) = dm(i)*agrav
          aam_tl(i, j) = aam_tl(i, j) + r1(i)*ua_tl(i, j, k)*dm(i) + (r2&
&           (i)*omega+r1(i)*ua(i, j, k))*dm_tl(i)
          aam(i, j) = aam(i, j) + (r2(i)*omega+r1(i)*ua(i, j, k))*dm(i)
          m_fac_tl(i, j) = m_fac_tl(i, j) + r2(i)*dm_tl(i)
          m_fac(i, j) = m_fac(i, j) + dm(i)*r2(i)
        END DO
      END DO
    END DO
  END SUBROUTINE COMPUTE_AAM_TLM
  SUBROUTINE COMPUTE_AAM(npz, is, ie, js, je, isd, ied, jsd, jed, &
&   gridstruct, bd, ptop, ua, va, u, v, delp, aam, ps, m_fac)
    IMPLICIT NONE
! Compute vertically (mass) integrated Atmospheric Angular Momentum
    INTEGER, INTENT(IN) :: npz
    INTEGER, INTENT(IN) :: is, ie, js, je
    INTEGER, INTENT(IN) :: isd, ied, jsd, jed
    REAL(fvprc), INTENT(IN) :: ptop
! D grid zonal wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: u(isd:ied, jsd:jed+1, npz)
! D grid meridional wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: v(isd:ied+1, jsd:jed, npz)
    REAL(fvprc), INTENT(INOUT) :: delp(isd:ied, jsd:jed, npz)
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(INOUT) :: ua, &
&   va
    REAL(fvprc), INTENT(OUT) :: aam(is:ie, js:je)
    REAL(fvprc), INTENT(OUT) :: m_fac(is:ie, js:je)
    REAL(fvprc), INTENT(OUT) :: ps(isd:ied, jsd:jed)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    TYPE(FV_GRID_TYPE), INTENT(IN) :: gridstruct
! local:
    REAL(fvprc), DIMENSION(is:ie) :: r1, r2, dm
    INTEGER :: i, j, k
    INTRINSIC COS
    CALL C2L_ORD2(u, v, ua, va, gridstruct, npz, gridstruct%grid_type, &
&           bd)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,gridstruct,aam,m_fac,ps,ptop,delp,agrav,ua) &
!$OMP                          private(r1, r2, dm)
    DO j=js,je
      DO i=is,ie
        r1(i) = radius*COS(gridstruct%agrid(i, j, 2))
        r2(i) = r1(i)*r1(i)
        aam(i, j) = 0.
        m_fac(i, j) = 0.
        ps(i, j) = ptop
      END DO
      DO k=1,npz
        DO i=is,ie
          dm(i) = delp(i, j, k)
          ps(i, j) = ps(i, j) + dm(i)
          dm(i) = dm(i)*agrav
          aam(i, j) = aam(i, j) + (r2(i)*omega+r1(i)*ua(i, j, k))*dm(i)
          m_fac(i, j) = m_fac(i, j) + dm(i)*r2(i)
        END DO
      END DO
    END DO
  END SUBROUTINE COMPUTE_AAM
!  Differentiation of geos_to_fv3 in forward (tangent) mode (with options r8):
!   variations   of useful results: peln pkz pe pk pt
!   with respect to varying inputs: delp pt
  SUBROUTINE GEOS_TO_FV3_TLM(bd, npz, kappa, ptop, delp, delp_tl, pe, &
&   pe_tl, pk, pk_tl, pkz, pkz_tl, peln, peln_tl, pt, pt_tl)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npz
    REAL(fvprc), INTENT(IN) :: kappa, ptop
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: pt_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: delp_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%&
&   je+1)
    REAL(fvprc), INTENT(INOUT) :: pe_tl(bd%is-1:bd%ie+1, npz+1, bd%js-1:&
&   bd%je+1)
    REAL(fvprc), INTENT(INOUT) :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL(fvprc), INTENT(INOUT) :: pk_tl(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL(fvprc), INTENT(INOUT) :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL(fvprc), INTENT(INOUT) :: peln_tl(bd%is:bd%ie, npz+1, bd%js:bd%&
&   je)
    REAL(fvprc), INTENT(INOUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
    REAL(fvprc), INTENT(INOUT) :: pkz_tl(bd%is:bd%ie, bd%js:bd%je, npz)
!Locals
    INTEGER :: i, j, k
    REAL(fvprc) :: akap
    INTEGER :: isc, iec, jsc, jec, km
    INTRINSIC LOG
    INTRINSIC EXP
    isc = bd%is
    iec = bd%ie
    jsc = bd%js
    jec = bd%je
    km = npz
    akap = kappa
    pe(:, :, :) = tiny_number
    pe(:, 1, :) = ptop
    pe_tl = 0.0_FVPRC
    DO k=2,km+1
      DO j=jsc,jec
        DO i=isc,iec
          pe_tl(i, k, j) = pe_tl(i, k-1, j) + delp_tl(i, j, k-1)
          pe(i, k, j) = pe(i, k-1, j) + delp(i, j, k-1)
        END DO
      END DO
    END DO
    peln_tl = 0.0_FVPRC
    DO k=1,km+1
      DO j=jsc,jec
        DO i=isc,iec
          peln_tl(i, k, j) = pe_tl(i, k, j)/pe(i, k, j)
          peln(i, k, j) = LOG(pe(i, k, j))
        END DO
      END DO
    END DO
    pk_tl = 0.0_FVPRC
    DO k=1,km+1
      DO j=jsc,jec
        DO i=isc,iec
          pk_tl(i, j, k) = akap*peln_tl(i, k, j)*EXP(akap*peln(i, k, j))
          pk(i, j, k) = EXP(akap*peln(i, k, j))
        END DO
      END DO
    END DO
    pkz_tl = 0.0_FVPRC
    DO k=1,km
      DO j=jsc,jec
        DO i=isc,iec
          pkz_tl(i, j, k) = ((pk_tl(i, j, k+1)-pk_tl(i, j, k))*akap*(&
&           peln(i, k+1, j)-peln(i, k, j))-(pk(i, j, k+1)-pk(i, j, k))*&
&           akap*(peln_tl(i, k+1, j)-peln_tl(i, k, j)))/(akap*(peln(i, k&
&           +1, j)-peln(i, k, j)))**2
          pkz(i, j, k) = (pk(i, j, k+1)-pk(i, j, k))/(akap*(peln(i, k+1&
&           , j)-peln(i, k, j)))
        END DO
      END DO
    END DO
    pt_tl(isc:iec, jsc:jec, :) = pt_tl(isc:iec, jsc:jec, :)*pkz(isc:iec&
&     , jsc:jec, :) + pt(isc:iec, jsc:jec, :)*pkz_tl(isc:iec, jsc:jec, :&
&     )
    pt(isc:iec, jsc:jec, :) = pt(isc:iec, jsc:jec, :)*pkz(isc:iec, jsc:&
&     jec, :)
  END SUBROUTINE GEOS_TO_FV3_TLM
  SUBROUTINE GEOS_TO_FV3(bd, npz, kappa, ptop, delp, pe, pk, pkz, peln, &
&   pt)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npz
    REAL(fvprc), INTENT(IN) :: kappa, ptop
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%&
&   je+1)
    REAL(fvprc), INTENT(INOUT) :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL(fvprc), INTENT(INOUT) :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL(fvprc), INTENT(INOUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
!Locals
    INTEGER :: i, j, k
    REAL(fvprc) :: akap
    INTEGER :: isc, iec, jsc, jec, km
    INTRINSIC LOG
    INTRINSIC EXP
    isc = bd%is
    iec = bd%ie
    jsc = bd%js
    jec = bd%je
    km = npz
    akap = kappa
    pe(:, :, :) = tiny_number
    pe(:, 1, :) = ptop
    DO k=2,km+1
      DO j=jsc,jec
        DO i=isc,iec
          pe(i, k, j) = pe(i, k-1, j) + delp(i, j, k-1)
        END DO
      END DO
    END DO
    DO k=1,km+1
      DO j=jsc,jec
        DO i=isc,iec
          peln(i, k, j) = LOG(pe(i, k, j))
        END DO
      END DO
    END DO
    DO k=1,km+1
      DO j=jsc,jec
        DO i=isc,iec
          pk(i, j, k) = EXP(akap*peln(i, k, j))
        END DO
      END DO
    END DO
    DO k=1,km
      DO j=jsc,jec
        DO i=isc,iec
          pkz(i, j, k) = (pk(i, j, k+1)-pk(i, j, k))/(akap*(peln(i, k+1&
&           , j)-peln(i, k, j)))
        END DO
      END DO
    END DO
    pt(isc:iec, jsc:jec, :) = pt(isc:iec, jsc:jec, :)*pkz(isc:iec, jsc:&
&     jec, :)
  END SUBROUTINE GEOS_TO_FV3
!  Differentiation of fv3_to_geos in forward (tangent) mode (with options r8):
!   variations   of useful results: pt
!   with respect to varying inputs: pkz pt
  SUBROUTINE FV3_TO_GEOS_TLM(bd, npz, pkz, pkz_tl, pt, pt_tl)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npz
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: pt_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
    REAL(fvprc), INTENT(INOUT) :: pkz_tl(bd%is:bd%ie, bd%js:bd%je, npz)
    pt_tl(bd%is:bd%ie, bd%js:bd%je, :) = (pt_tl(bd%is:bd%ie, bd%js:bd%je&
&     , :)*pkz(bd%is:bd%ie, bd%js:bd%je, :)-pt(bd%is:bd%ie, bd%js:bd%je&
&     , :)*pkz_tl(bd%is:bd%ie, bd%js:bd%je, :))/pkz(bd%is:bd%ie, bd%js:&
&     bd%je, :)**2
    pt(bd%is:bd%ie, bd%js:bd%je, :) = pt(bd%is:bd%ie, bd%js:bd%je, :)/&
&     pkz(bd%is:bd%ie, bd%js:bd%je, :)
  END SUBROUTINE FV3_TO_GEOS_TLM
  SUBROUTINE FV3_TO_GEOS(bd, npz, pkz, pt)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npz
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
    pt(bd%is:bd%ie, bd%js:bd%je, :) = pt(bd%is:bd%ie, bd%js:bd%je, :)/&
&     pkz(bd%is:bd%ie, bd%js:bd%je, :)
  END SUBROUTINE FV3_TO_GEOS
END MODULE FV_DYNAMICS_MOD_D
