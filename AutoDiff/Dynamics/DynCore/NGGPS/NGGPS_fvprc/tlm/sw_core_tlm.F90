!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
MODULE SW_CORE_MOD_D
  USE FV_MP_MOD_D, ONLY : ng
  USE TP_CORE_MOD_D, ONLY : fv_tp_2d, fv_tp_2d_tlm, fv_tp_2d, &
& fv_tp_2d_tlm, pert_ppm, pert_ppm_tlm, copy_corners, &
& copy_corners_tlm
  USE FV_MP_MOD_D, ONLY : fill_corners, fill_corners_tlm, xdir, ydir
  USE FV_ARRAYS_MOD_D, ONLY : fv_grid_type, fv_grid_bounds_type, &
& fv_flags_type
  USE FV_ARRAYS_MOD_D, ONLY : real4, real8, fvprc
  USE A2B_EDGE_MOD_D, ONLY : a2b_ord4, a2b_ord4_tlm, a2b_ord4, &
& a2b_ord4_tlm
  IMPLICIT NONE
  REAL(fvprc), PARAMETER :: r3=1./3.
  REAL(fvprc), PARAMETER :: t11=27./28., t12=-(13./28.), t13=3./7., t14=&
&   6./7., t15=3./28.
  REAL(fvprc), PARAMETER :: s11=11./14., s13=-(13./14.), s14=4./7., s15=&
&   3./14.
! for KE limiter
  REAL(fvprc), PARAMETER :: near_zero=1.e-9
  REAL(fvprc), PARAMETER :: big_number=1.e8
!----------------------
! PPM volume mean form:
!----------------------
! 0.58333333
  REAL(fvprc), PARAMETER :: p1=7./12.
  REAL(fvprc), PARAMETER :: p2=-(1./12.)
!----------------------------
! 4-pt Lagrange interpolation
!----------------------------
  REAL(fvprc), PARAMETER :: a1=0.5625
  REAL(fvprc), PARAMETER :: a2=-0.0625
!----------------------------------------------
! volume-conserving cubic with 2nd drv=0 at end point:
  REAL(fvprc), PARAMETER :: c1=-(2./14.)
  REAL(fvprc), PARAMETER :: c2=11./14.
  REAL(fvprc), PARAMETER :: c3=5./14.
! 3-pt off-center intp formular:
! real(FVPRC), parameter:: c1 = -0.125
! real(FVPRC), parameter:: c2 =  0.75
! real(FVPRC), parameter:: c3 =  0.375
!----------------------------------------------
! scheme 2.1: perturbation form
  REAL(fvprc), PARAMETER :: b1=1./30.
  REAL(fvprc), PARAMETER :: b2=-(13./60.)
  REAL(fvprc), PARAMETER :: b3=-(13./60.)
  REAL(fvprc), PARAMETER :: b4=0.45
  REAL(fvprc), PARAMETER :: b5=-0.05
!logical:: sw_corner, se_corner, ne_corner, nw_corner 
!---- version number -----
!  character(len=128) :: version = '$Id: sw_core.F90,v 1.2.2.1.2.1.30.1.6.1.50.3.6.1.2.1.4.1 2017/02/16 03:47:48 aoloso Exp $'
!  character(len=128) :: tagname = '$Name: Heracles-UNSTABLE_ncepdyn_Feb222017 $'
  PRIVATE 
  PUBLIC c_sw, d_sw, fill_4corners, del6_vt_flux, d2a2c_vect
  PUBLIC c_sw_tlm, d_sw_tlm, fill_4corners_tlm, del6_vt_flux_tlm, &
& d2a2c_vect_tlm

CONTAINS
!  Differentiation of c_sw in forward (tangent) mode (with options r8):
!   variations   of useful results: w delp ua uc ptc ut delpc va
!                vc vt divg_d wc pt
!   with respect to varying inputs: u v w delp ua uc ptc ut delpc
!                va vc vt divg_d wc pt
  SUBROUTINE C_SW_TLM(delpc, delpc_tl, delp, delp_tl, ptc, ptc_tl, pt, &
&   pt_tl, u, u_tl, v, v_tl, w, w_tl, uc, uc_tl, vc, vc_tl, ua, ua_tl, &
&   va, va_tl, wc, wc_tl, ut, ut_tl, vt, vt_tl, divg_d, divg_d_tl, nord&
&   , dt2, hydrostatic, dord4, bd, gridstruct, flagstruct)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u, vc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u_tl, vc_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v, uc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v_tl, uc_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delp, pt, ua, va, ut, vt, w
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delp_tl, pt_tl, ua_tl, va_tl, ut_tl, vt_tl, w_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(OUT) ::&
&   delpc, ptc, wc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(OUT) ::&
&   delpc_tl, ptc_tl, wc_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(OUT&
&   ) :: divg_d
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(OUT&
&   ) :: divg_d_tl
    INTEGER, INTENT(IN) :: nord
    REAL(fvprc), INTENT(IN) :: dt2
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: dord4
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
! Local:
    REAL(fvprc), DIMENSION(bd%is-1:bd%ie+1, bd%js-1:bd%je+1) :: vort, ke
    REAL(fvprc), DIMENSION(bd%is-1:bd%ie+1, bd%js-1:bd%je+1) :: vort_tl&
&   , ke_tl
    REAL(fvprc), DIMENSION(bd%is-1:bd%ie+2, bd%js-1:bd%je+1) :: fx, fx1&
&   , fx2
    REAL(fvprc), DIMENSION(bd%is-1:bd%ie+2, bd%js-1:bd%je+1) :: fx_tl, &
&   fx1_tl, fx2_tl
    REAL(fvprc), DIMENSION(bd%is-1:bd%ie+1, bd%js-1:bd%je+2) :: fy, fy1&
&   , fy2
    REAL(fvprc), DIMENSION(bd%is-1:bd%ie+1, bd%js-1:bd%je+2) :: fy_tl, &
&   fy1_tl, fy2_tl
    REAL(fvprc) :: dt4
    INTEGER :: i, j, is2, ie1
    INTEGER :: iep1, jep1
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTEGER :: npx, npy
    LOGICAL :: nested
!      real(FVPRC), pointer, dimension(:,:)   :: rarea, rarea_c
!      real(FVPRC), pointer, dimension(:,:,:) :: sin_sg, cos_sg
!      real(FVPRC), pointer, dimension(:,:)   :: cosa_u, cosa_v
!      real(FVPRC), pointer, dimension(:,:)   :: sina_u, sina_v
!      real(FVPRC), pointer, dimension(:,:) :: fC
!      real(FVPRC), pointer, dimension(:,:) :: rdxc, rdyc, dx, dy, dxc, dyc
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    npx = flagstruct%npx
    npy = flagstruct%npy
    nested = gridstruct%nested
!      rarea   => gridstruct%rarea
!      rarea_c => gridstruct%rarea_c
!      sin_sg  => gridstruct%sin_sg
!      cos_sg  => gridstruct%cos_sg
!      cosa_u  => gridstruct%cosa_u
!      cosa_v  => gridstruct%cosa_v
!      sina_u  => gridstruct%sina_u
!      sina_v  => gridstruct%sina_v
!      fC      => gridstruct%fC
!      rdxc    => gridstruct%rdxc
!      rdyc    => gridstruct%rdyc
!      dx      => gridstruct%dx
!      dy      => gridstruct%dy
!      dxc     => gridstruct%dxc
!      dyc     => gridstruct%dyc
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
    iep1 = ie + 1
    jep1 = je + 1
    CALL D2A2C_VECT_TLM(u, u_tl, v, v_tl, ua, ua_tl, va, va_tl, uc, &
&                 uc_tl, vc, vc_tl, ut, ut_tl, vt, vt_tl, dord4, &
&                 gridstruct, bd, npx, npy, nested, flagstruct%grid_type&
&                )
    IF (nord .GT. 0) THEN
      IF (nested) THEN
        CALL DIVERGENCE_CORNER_NEST_TLM(u, u_tl, v, v_tl, ua, ua_tl, va&
&                                 , va_tl, divg_d, divg_d_tl, gridstruct&
&                                 , flagstruct, bd)
      ELSE
        CALL DIVERGENCE_CORNER_TLM(u, u_tl, v, v_tl, ua, ua_tl, va, &
&                            va_tl, divg_d, divg_d_tl, gridstruct, &
&                            flagstruct, bd)
      END IF
    END IF
!!! TO DO: remove 'test_up'
!!!   check repro with siena
!!$AD II-LOOP
    DO j=js-1,jep1
      DO i=is-1,iep1+1
        IF (ut(i, j) .GT. 0.) THEN
          ut_tl(i, j) = dt2*gridstruct%dy(i, j)*gridstruct%sin_sg(i-1, j&
&           , 3)*ut_tl(i, j)
          ut(i, j) = dt2*ut(i, j)*gridstruct%dy(i, j)*gridstruct%sin_sg(&
&           i-1, j, 3)
        ELSE
          ut_tl(i, j) = dt2*gridstruct%dy(i, j)*gridstruct%sin_sg(i, j, &
&           1)*ut_tl(i, j)
          ut(i, j) = dt2*ut(i, j)*gridstruct%dy(i, j)*gridstruct%sin_sg(&
&           i, j, 1)
        END IF
      END DO
    END DO
!!$AD II-LOOP
    DO j=js-1,je+2
      DO i=is-1,iep1
        IF (vt(i, j) .GT. 0.) THEN
          vt_tl(i, j) = dt2*gridstruct%dx(i, j)*gridstruct%sin_sg(i, j-1&
&           , 4)*vt_tl(i, j)
          vt(i, j) = dt2*vt(i, j)*gridstruct%dx(i, j)*gridstruct%sin_sg(&
&           i, j-1, 4)
        ELSE
          vt_tl(i, j) = dt2*gridstruct%dx(i, j)*gridstruct%sin_sg(i, j, &
&           2)*vt_tl(i, j)
          vt(i, j) = dt2*vt(i, j)*gridstruct%dx(i, j)*gridstruct%sin_sg(&
&           i, j, 2)
        END IF
      END DO
    END DO
!----------------
! Transport delp:
!----------------
! Xdir:
    IF (flagstruct%grid_type .LT. 3 .AND. (.NOT.nested)) CALL &
&     FILL2_4CORNERS_TLM(delp, delp_tl, pt, pt_tl, 1, bd, npx, npy, &
&                  sw_corner, se_corner, ne_corner, nw_corner)
    IF (hydrostatic) THEN
      fx_tl = 0.0_FVPRC
      fx1_tl = 0.0_FVPRC
!#ifdef SW_DYNAMICS
!           do j=js-1,jep1
!              do i=is-1,ie+2
!                 if ( ut(i,j) > 0. ) then
!                      fx1(i,j) = delp(i-1,j)
!                 else
!                      fx1(i,j) = delp(i,j)
!                 endif
!                 fx1(i,j) =  ut(i,j)*fx1(i,j)
!              enddo
!           enddo
!#else
      DO j=js-1,jep1
        DO i=is-1,ie+2
          IF (ut(i, j) .GT. 0.) THEN
            fx1_tl(i, j) = delp_tl(i-1, j)
            fx1(i, j) = delp(i-1, j)
            fx_tl(i, j) = pt_tl(i-1, j)
            fx(i, j) = pt(i-1, j)
          ELSE
            fx1_tl(i, j) = delp_tl(i, j)
            fx1(i, j) = delp(i, j)
            fx_tl(i, j) = pt_tl(i, j)
            fx(i, j) = pt(i, j)
          END IF
          fx1_tl(i, j) = ut_tl(i, j)*fx1(i, j) + ut(i, j)*fx1_tl(i, j)
          fx1(i, j) = ut(i, j)*fx1(i, j)
          fx_tl(i, j) = fx1_tl(i, j)*fx(i, j) + fx1(i, j)*fx_tl(i, j)
          fx(i, j) = fx1(i, j)*fx(i, j)
        END DO
      END DO
      fx2_tl = 0.0_FVPRC
    ELSE
!#endif
      IF (flagstruct%grid_type .LT. 3) THEN
        CALL FILL_4CORNERS_TLM(w, w_tl, 1, bd, npx, npy, sw_corner, &
&                        se_corner, ne_corner, nw_corner)
        fx_tl = 0.0_FVPRC
        fx1_tl = 0.0_FVPRC
        fx2_tl = 0.0_FVPRC
      ELSE
        fx_tl = 0.0_FVPRC
        fx1_tl = 0.0_FVPRC
        fx2_tl = 0.0_FVPRC
      END IF
      DO j=js-1,je+1
        DO i=is-1,ie+2
          IF (ut(i, j) .GT. 0.) THEN
            fx1_tl(i, j) = delp_tl(i-1, j)
            fx1(i, j) = delp(i-1, j)
            fx_tl(i, j) = pt_tl(i-1, j)
            fx(i, j) = pt(i-1, j)
            fx2_tl(i, j) = w_tl(i-1, j)
            fx2(i, j) = w(i-1, j)
          ELSE
            fx1_tl(i, j) = delp_tl(i, j)
            fx1(i, j) = delp(i, j)
            fx_tl(i, j) = pt_tl(i, j)
            fx(i, j) = pt(i, j)
            fx2_tl(i, j) = w_tl(i, j)
            fx2(i, j) = w(i, j)
          END IF
          fx1_tl(i, j) = ut_tl(i, j)*fx1(i, j) + ut(i, j)*fx1_tl(i, j)
          fx1(i, j) = ut(i, j)*fx1(i, j)
          fx_tl(i, j) = fx1_tl(i, j)*fx(i, j) + fx1(i, j)*fx_tl(i, j)
          fx(i, j) = fx1(i, j)*fx(i, j)
          fx2_tl(i, j) = fx1_tl(i, j)*fx2(i, j) + fx1(i, j)*fx2_tl(i, j)
          fx2(i, j) = fx1(i, j)*fx2(i, j)
        END DO
      END DO
    END IF
! Ydir:
    IF (flagstruct%grid_type .LT. 3 .AND. (.NOT.nested)) CALL &
&     FILL2_4CORNERS_TLM(delp, delp_tl, pt, pt_tl, 2, bd, npx, npy, &
&                  sw_corner, se_corner, ne_corner, nw_corner)
    IF (hydrostatic) THEN
      fy1_tl = 0.0_FVPRC
      fy_tl = 0.0_FVPRC
      DO j=js-1,jep1+1
        DO i=is-1,iep1
          IF (vt(i, j) .GT. 0.) THEN
            fy1_tl(i, j) = delp_tl(i, j-1)
            fy1(i, j) = delp(i, j-1)
            fy_tl(i, j) = pt_tl(i, j-1)
            fy(i, j) = pt(i, j-1)
          ELSE
            fy1_tl(i, j) = delp_tl(i, j)
            fy1(i, j) = delp(i, j)
            fy_tl(i, j) = pt_tl(i, j)
            fy(i, j) = pt(i, j)
          END IF
          fy1_tl(i, j) = vt_tl(i, j)*fy1(i, j) + vt(i, j)*fy1_tl(i, j)
          fy1(i, j) = vt(i, j)*fy1(i, j)
          fy_tl(i, j) = fy1_tl(i, j)*fy(i, j) + fy1(i, j)*fy_tl(i, j)
          fy(i, j) = fy1(i, j)*fy(i, j)
        END DO
      END DO
      DO j=js-1,jep1
        DO i=is-1,iep1
          delpc_tl(i, j) = delp_tl(i, j) + gridstruct%rarea(i, j)*(&
&           fx1_tl(i, j)-fx1_tl(i+1, j)+fy1_tl(i, j)-fy1_tl(i, j+1))
          delpc(i, j) = delp(i, j) + (fx1(i, j)-fx1(i+1, j)+fy1(i, j)-&
&           fy1(i, j+1))*gridstruct%rarea(i, j)
!#ifdef SW_DYNAMICS
!                   ptc(i,j) = pt(i,j)
!#else
          ptc_tl(i, j) = ((pt_tl(i, j)*delp(i, j)+pt(i, j)*delp_tl(i, j)&
&           +gridstruct%rarea(i, j)*(fx_tl(i, j)-fx_tl(i+1, j)+fy_tl(i, &
&           j)-fy_tl(i, j+1)))*delpc(i, j)-(pt(i, j)*delp(i, j)+(fx(i, j&
&           )-fx(i+1, j)+fy(i, j)-fy(i, j+1))*gridstruct%rarea(i, j))*&
&           delpc_tl(i, j))/delpc(i, j)**2
          ptc(i, j) = (pt(i, j)*delp(i, j)+(fx(i, j)-fx(i+1, j)+fy(i, j)&
&           -fy(i, j+1))*gridstruct%rarea(i, j))/delpc(i, j)
        END DO
      END DO
    ELSE
!#endif
      IF (flagstruct%grid_type .LT. 3) THEN
        CALL FILL_4CORNERS_TLM(w, w_tl, 2, bd, npx, npy, sw_corner, &
&                        se_corner, ne_corner, nw_corner)
        fy1_tl = 0.0_FVPRC
        fy2_tl = 0.0_FVPRC
        fy_tl = 0.0_FVPRC
      ELSE
        fy1_tl = 0.0_FVPRC
        fy2_tl = 0.0_FVPRC
        fy_tl = 0.0_FVPRC
      END IF
      DO j=js-1,je+2
        DO i=is-1,ie+1
          IF (vt(i, j) .GT. 0.) THEN
            fy1_tl(i, j) = delp_tl(i, j-1)
            fy1(i, j) = delp(i, j-1)
            fy_tl(i, j) = pt_tl(i, j-1)
            fy(i, j) = pt(i, j-1)
            fy2_tl(i, j) = w_tl(i, j-1)
            fy2(i, j) = w(i, j-1)
          ELSE
            fy1_tl(i, j) = delp_tl(i, j)
            fy1(i, j) = delp(i, j)
            fy_tl(i, j) = pt_tl(i, j)
            fy(i, j) = pt(i, j)
            fy2_tl(i, j) = w_tl(i, j)
            fy2(i, j) = w(i, j)
          END IF
          fy1_tl(i, j) = vt_tl(i, j)*fy1(i, j) + vt(i, j)*fy1_tl(i, j)
          fy1(i, j) = vt(i, j)*fy1(i, j)
          fy_tl(i, j) = fy1_tl(i, j)*fy(i, j) + fy1(i, j)*fy_tl(i, j)
          fy(i, j) = fy1(i, j)*fy(i, j)
          fy2_tl(i, j) = fy1_tl(i, j)*fy2(i, j) + fy1(i, j)*fy2_tl(i, j)
          fy2(i, j) = fy1(i, j)*fy2(i, j)
        END DO
      END DO
      DO j=js-1,je+1
        DO i=is-1,ie+1
          delpc_tl(i, j) = delp_tl(i, j) + gridstruct%rarea(i, j)*(&
&           fx1_tl(i, j)-fx1_tl(i+1, j)+fy1_tl(i, j)-fy1_tl(i, j+1))
          delpc(i, j) = delp(i, j) + (fx1(i, j)-fx1(i+1, j)+fy1(i, j)-&
&           fy1(i, j+1))*gridstruct%rarea(i, j)
          ptc_tl(i, j) = ((pt_tl(i, j)*delp(i, j)+pt(i, j)*delp_tl(i, j)&
&           +gridstruct%rarea(i, j)*(fx_tl(i, j)-fx_tl(i+1, j)+fy_tl(i, &
&           j)-fy_tl(i, j+1)))*delpc(i, j)-(pt(i, j)*delp(i, j)+(fx(i, j&
&           )-fx(i+1, j)+fy(i, j)-fy(i, j+1))*gridstruct%rarea(i, j))*&
&           delpc_tl(i, j))/delpc(i, j)**2
          ptc(i, j) = (pt(i, j)*delp(i, j)+(fx(i, j)-fx(i+1, j)+fy(i, j)&
&           -fy(i, j+1))*gridstruct%rarea(i, j))/delpc(i, j)
          wc_tl(i, j) = ((w_tl(i, j)*delp(i, j)+w(i, j)*delp_tl(i, j)+&
&           gridstruct%rarea(i, j)*(fx2_tl(i, j)-fx2_tl(i+1, j)+fy2_tl(i&
&           , j)-fy2_tl(i, j+1)))*delpc(i, j)-(w(i, j)*delp(i, j)+(fx2(i&
&           , j)-fx2(i+1, j)+fy2(i, j)-fy2(i, j+1))*gridstruct%rarea(i, &
&           j))*delpc_tl(i, j))/delpc(i, j)**2
          wc(i, j) = (w(i, j)*delp(i, j)+(fx2(i, j)-fx2(i+1, j)+fy2(i, j&
&           )-fy2(i, j+1))*gridstruct%rarea(i, j))/delpc(i, j)
        END DO
      END DO
    END IF
!------------
! Compute KE:
!------------
!Since uc = u*, i.e. the covariant wind perpendicular to the face edge, if we want to compute kinetic energy we will need the tru
!e coordinate-parallel covariant wind, computed through u = uc*sina + v*cosa. 
!Use the alpha for the cell KE is being computed in.
!!! TO DO:
!!! Need separate versions for nesting/single-tile
!!!   and for cubed-sphere
    IF (nested .OR. flagstruct%grid_type .GE. 3) THEN
      ke_tl = 0.0_FVPRC
      DO j=js-1,jep1
        DO i=is-1,iep1
          IF (ua(i, j) .GT. 0.) THEN
            ke_tl(i, j) = uc_tl(i, j)
            ke(i, j) = uc(i, j)
          ELSE
            ke_tl(i, j) = uc_tl(i+1, j)
            ke(i, j) = uc(i+1, j)
          END IF
        END DO
      END DO
      vort_tl = 0.0_FVPRC
      DO j=js-1,jep1
        DO i=is-1,iep1
          IF (va(i, j) .GT. 0.) THEN
            vort_tl(i, j) = vc_tl(i, j)
            vort(i, j) = vc(i, j)
          ELSE
            vort_tl(i, j) = vc_tl(i, j+1)
            vort(i, j) = vc(i, j+1)
          END IF
        END DO
      END DO
    ELSE
      ke_tl = 0.0_FVPRC
      DO j=js-1,jep1
        DO i=is-1,iep1
          IF (ua(i, j) .GT. 0.) THEN
            IF (i .EQ. 1) THEN
              ke_tl(1, j) = gridstruct%sin_sg(1, j, 1)*uc_tl(1, j) + &
&               gridstruct%cos_sg(1, j, 1)*v_tl(1, j)
              ke(1, j) = uc(1, j)*gridstruct%sin_sg(1, j, 1) + v(1, j)*&
&               gridstruct%cos_sg(1, j, 1)
            ELSE IF (i .EQ. npx) THEN
              ke_tl(i, j) = gridstruct%sin_sg(npx, j, 1)*uc_tl(npx, j) +&
&               gridstruct%cos_sg(npx, j, 1)*v_tl(npx, j)
              ke(i, j) = uc(npx, j)*gridstruct%sin_sg(npx, j, 1) + v(npx&
&               , j)*gridstruct%cos_sg(npx, j, 1)
            ELSE
              ke_tl(i, j) = uc_tl(i, j)
              ke(i, j) = uc(i, j)
            END IF
          ELSE IF (i .EQ. 0) THEN
            ke_tl(0, j) = gridstruct%sin_sg(0, j, 3)*uc_tl(1, j) + &
&             gridstruct%cos_sg(0, j, 3)*v_tl(1, j)
            ke(0, j) = uc(1, j)*gridstruct%sin_sg(0, j, 3) + v(1, j)*&
&             gridstruct%cos_sg(0, j, 3)
          ELSE IF (i .EQ. npx - 1) THEN
            ke_tl(i, j) = gridstruct%sin_sg(npx-1, j, 3)*uc_tl(npx, j) +&
&             gridstruct%cos_sg(npx-1, j, 3)*v_tl(npx, j)
            ke(i, j) = uc(npx, j)*gridstruct%sin_sg(npx-1, j, 3) + v(npx&
&             , j)*gridstruct%cos_sg(npx-1, j, 3)
          ELSE
            ke_tl(i, j) = uc_tl(i+1, j)
            ke(i, j) = uc(i+1, j)
          END IF
        END DO
      END DO
      vort_tl = 0.0_FVPRC
      DO j=js-1,jep1
        DO i=is-1,iep1
          IF (va(i, j) .GT. 0.) THEN
            IF (j .EQ. 1) THEN
              vort_tl(i, 1) = gridstruct%sin_sg(i, 1, 2)*vc_tl(i, 1) + &
&               gridstruct%cos_sg(i, 1, 2)*u_tl(i, 1)
              vort(i, 1) = vc(i, 1)*gridstruct%sin_sg(i, 1, 2) + u(i, 1)&
&               *gridstruct%cos_sg(i, 1, 2)
            ELSE IF (j .EQ. npy) THEN
              vort_tl(i, j) = gridstruct%sin_sg(i, npy, 2)*vc_tl(i, npy)&
&               + gridstruct%cos_sg(i, npy, 2)*u_tl(i, npy)
              vort(i, j) = vc(i, npy)*gridstruct%sin_sg(i, npy, 2) + u(i&
&               , npy)*gridstruct%cos_sg(i, npy, 2)
            ELSE
              vort_tl(i, j) = vc_tl(i, j)
              vort(i, j) = vc(i, j)
            END IF
          ELSE IF (j .EQ. 0) THEN
            vort_tl(i, 0) = gridstruct%sin_sg(i, 0, 4)*vc_tl(i, 1) + &
&             gridstruct%cos_sg(i, 0, 4)*u_tl(i, 1)
            vort(i, 0) = vc(i, 1)*gridstruct%sin_sg(i, 0, 4) + u(i, 1)*&
&             gridstruct%cos_sg(i, 0, 4)
          ELSE IF (j .EQ. npy - 1) THEN
            vort_tl(i, j) = gridstruct%sin_sg(i, npy-1, 4)*vc_tl(i, npy)&
&             + gridstruct%cos_sg(i, npy-1, 4)*u_tl(i, npy)
            vort(i, j) = vc(i, npy)*gridstruct%sin_sg(i, npy-1, 4) + u(i&
&             , npy)*gridstruct%cos_sg(i, npy-1, 4)
          ELSE
            vort_tl(i, j) = vc_tl(i, j+1)
            vort(i, j) = vc(i, j+1)
          END IF
        END DO
      END DO
    END IF
    dt4 = 0.5*dt2
    DO j=js-1,jep1
      DO i=is-1,iep1
        ke_tl(i, j) = dt4*(ua_tl(i, j)*ke(i, j)+ua(i, j)*ke_tl(i, j)+&
&         va_tl(i, j)*vort(i, j)+va(i, j)*vort_tl(i, j))
        ke(i, j) = dt4*(ua(i, j)*ke(i, j)+va(i, j)*vort(i, j))
      END DO
    END DO
!------------------------------
! Compute circulation on C grid
!------------------------------
! To consider using true co-variant winds at face edges?
    DO j=js-1,je+1
      DO i=is,ie+1
        fx_tl(i, j) = gridstruct%dxc(i, j)*uc_tl(i, j)
        fx(i, j) = uc(i, j)*gridstruct%dxc(i, j)
      END DO
    END DO
    DO j=js,je+1
      DO i=is-1,ie+1
        fy_tl(i, j) = gridstruct%dyc(i, j)*vc_tl(i, j)
        fy(i, j) = vc(i, j)*gridstruct%dyc(i, j)
      END DO
    END DO
    DO j=js,je+1
      DO i=is,ie+1
        vort_tl(i, j) = fx_tl(i, j-1) - fx_tl(i, j) - fy_tl(i-1, j) + &
&         fy_tl(i, j)
        vort(i, j) = fx(i, j-1) - fx(i, j) - fy(i-1, j) + fy(i, j)
      END DO
    END DO
! Remove the extra term at the corners:
    IF (sw_corner) THEN
      vort_tl(1, 1) = vort_tl(1, 1) + fy_tl(0, 1)
      vort(1, 1) = vort(1, 1) + fy(0, 1)
    END IF
    IF (se_corner) THEN
      vort_tl(npx, 1) = vort_tl(npx, 1) - fy_tl(npx, 1)
      vort(npx, 1) = vort(npx, 1) - fy(npx, 1)
    END IF
    IF (ne_corner) THEN
      vort_tl(npx, npy) = vort_tl(npx, npy) - fy_tl(npx, npy)
      vort(npx, npy) = vort(npx, npy) - fy(npx, npy)
    END IF
    IF (nw_corner) THEN
      vort_tl(1, npy) = vort_tl(1, npy) + fy_tl(0, npy)
      vort(1, npy) = vort(1, npy) + fy(0, npy)
    END IF
!----------------------------
! Compute absolute vorticity
!----------------------------
    DO j=js,je+1
      DO i=is,ie+1
        vort_tl(i, j) = gridstruct%rarea_c(i, j)*vort_tl(i, j)
        vort(i, j) = gridstruct%fc(i, j) + gridstruct%rarea_c(i, j)*vort&
&         (i, j)
      END DO
    END DO
!----------------------------------
! Transport absolute vorticity:
!----------------------------------
!To go from v to contravariant v at the edges, we divide by sin_sg;
! but we then must multiply by sin_sg to get the proper flux.
! These cancel, leaving us with fy1 = dt2*v at the edges.
! (For the same reason we only divide by sin instead of sin**2 in the interior)
!! TO DO: separate versions for nesting/single-tile and cubed-sphere
    IF (nested .OR. flagstruct%grid_type .GE. 3) THEN
      DO j=js,je
        DO i=is,iep1
          fy1_tl(i, j) = dt2*(v_tl(i, j)-gridstruct%cosa_u(i, j)*uc_tl(i&
&           , j))/gridstruct%sina_u(i, j)
          fy1(i, j) = dt2*(v(i, j)-uc(i, j)*gridstruct%cosa_u(i, j))/&
&           gridstruct%sina_u(i, j)
          IF (fy1(i, j) .GT. 0.) THEN
            fy_tl(i, j) = vort_tl(i, j)
            fy(i, j) = vort(i, j)
          ELSE
            fy_tl(i, j) = vort_tl(i, j+1)
            fy(i, j) = vort(i, j+1)
          END IF
        END DO
      END DO
      DO j=js,jep1
        DO i=is,ie
          fx1_tl(i, j) = dt2*(u_tl(i, j)-gridstruct%cosa_v(i, j)*vc_tl(i&
&           , j))/gridstruct%sina_v(i, j)
          fx1(i, j) = dt2*(u(i, j)-vc(i, j)*gridstruct%cosa_v(i, j))/&
&           gridstruct%sina_v(i, j)
          IF (fx1(i, j) .GT. 0.) THEN
            fx_tl(i, j) = vort_tl(i, j)
            fx(i, j) = vort(i, j)
          ELSE
            fx_tl(i, j) = vort_tl(i+1, j)
            fx(i, j) = vort(i+1, j)
          END IF
        END DO
      END DO
    ELSE
      DO j=js,je
!DEC$ VECTOR ALWAYS
        DO i=is,iep1
          IF (i .EQ. 1 .OR. i .EQ. npx) THEN
            fy1_tl(i, j) = dt2*v_tl(i, j)
            fy1(i, j) = dt2*v(i, j)
          ELSE
            fy1_tl(i, j) = dt2*(v_tl(i, j)-gridstruct%cosa_u(i, j)*uc_tl&
&             (i, j))/gridstruct%sina_u(i, j)
            fy1(i, j) = dt2*(v(i, j)-uc(i, j)*gridstruct%cosa_u(i, j))/&
&             gridstruct%sina_u(i, j)
          END IF
          IF (fy1(i, j) .GT. 0.) THEN
            fy_tl(i, j) = vort_tl(i, j)
            fy(i, j) = vort(i, j)
          ELSE
            fy_tl(i, j) = vort_tl(i, j+1)
            fy(i, j) = vort(i, j+1)
          END IF
        END DO
      END DO
      DO j=js,jep1
        IF (j .EQ. 1 .OR. j .EQ. npy) THEN
!DEC$ VECTOR ALWAYS
          DO i=is,ie
            fx1_tl(i, j) = dt2*u_tl(i, j)
            fx1(i, j) = dt2*u(i, j)
            IF (fx1(i, j) .GT. 0.) THEN
              fx_tl(i, j) = vort_tl(i, j)
              fx(i, j) = vort(i, j)
            ELSE
              fx_tl(i, j) = vort_tl(i+1, j)
              fx(i, j) = vort(i+1, j)
            END IF
          END DO
        ELSE
!DEC$ VECTOR ALWAYS
          DO i=is,ie
            fx1_tl(i, j) = dt2*(u_tl(i, j)-gridstruct%cosa_v(i, j)*vc_tl&
&             (i, j))/gridstruct%sina_v(i, j)
            fx1(i, j) = dt2*(u(i, j)-vc(i, j)*gridstruct%cosa_v(i, j))/&
&             gridstruct%sina_v(i, j)
            IF (fx1(i, j) .GT. 0.) THEN
              fx_tl(i, j) = vort_tl(i, j)
              fx(i, j) = vort(i, j)
            ELSE
              fx_tl(i, j) = vort_tl(i+1, j)
              fx(i, j) = vort(i+1, j)
            END IF
          END DO
        END IF
      END DO
    END IF
! Update time-centered winds on the C-Grid
    DO j=js,je
      DO i=is,iep1
        uc_tl(i, j) = uc_tl(i, j) + fy1_tl(i, j)*fy(i, j) + fy1(i, j)*&
&         fy_tl(i, j) + gridstruct%rdxc(i, j)*(ke_tl(i-1, j)-ke_tl(i, j)&
&         )
        uc(i, j) = uc(i, j) + fy1(i, j)*fy(i, j) + gridstruct%rdxc(i, j)&
&         *(ke(i-1, j)-ke(i, j))
      END DO
    END DO
    DO j=js,jep1
      DO i=is,ie
        vc_tl(i, j) = vc_tl(i, j) - fx1_tl(i, j)*fx(i, j) - fx1(i, j)*&
&         fx_tl(i, j) + gridstruct%rdyc(i, j)*(ke_tl(i, j-1)-ke_tl(i, j)&
&         )
        vc(i, j) = vc(i, j) - fx1(i, j)*fx(i, j) + gridstruct%rdyc(i, j)&
&         *(ke(i, j-1)-ke(i, j))
      END DO
    END DO
  END SUBROUTINE C_SW_TLM
  SUBROUTINE C_SW(delpc, delp, ptc, pt, u, v, w, uc, vc, ua, va, wc, ut&
&   , vt, divg_d, nord, dt2, hydrostatic, dord4, bd, gridstruct, &
&   flagstruct)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u, vc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v, uc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delp, pt, ua, va, ut, vt, w
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(OUT) ::&
&   delpc, ptc, wc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(OUT&
&   ) :: divg_d
    INTEGER, INTENT(IN) :: nord
    REAL(fvprc), INTENT(IN) :: dt2
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: dord4
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
! Local:
    REAL(fvprc), DIMENSION(bd%is-1:bd%ie+1, bd%js-1:bd%je+1) :: vort, ke
    REAL(fvprc), DIMENSION(bd%is-1:bd%ie+2, bd%js-1:bd%je+1) :: fx, fx1&
&   , fx2
    REAL(fvprc), DIMENSION(bd%is-1:bd%ie+1, bd%js-1:bd%je+2) :: fy, fy1&
&   , fy2
    REAL(fvprc) :: dt4
    INTEGER :: i, j, is2, ie1
    INTEGER :: iep1, jep1
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTEGER :: npx, npy
    LOGICAL :: nested
!      real(FVPRC), pointer, dimension(:,:)   :: rarea, rarea_c
!      real(FVPRC), pointer, dimension(:,:,:) :: sin_sg, cos_sg
!      real(FVPRC), pointer, dimension(:,:)   :: cosa_u, cosa_v
!      real(FVPRC), pointer, dimension(:,:)   :: sina_u, sina_v
!      real(FVPRC), pointer, dimension(:,:) :: fC
!      real(FVPRC), pointer, dimension(:,:) :: rdxc, rdyc, dx, dy, dxc, dyc
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    npx = flagstruct%npx
    npy = flagstruct%npy
    nested = gridstruct%nested
!      rarea   => gridstruct%rarea
!      rarea_c => gridstruct%rarea_c
!      sin_sg  => gridstruct%sin_sg
!      cos_sg  => gridstruct%cos_sg
!      cosa_u  => gridstruct%cosa_u
!      cosa_v  => gridstruct%cosa_v
!      sina_u  => gridstruct%sina_u
!      sina_v  => gridstruct%sina_v
!      fC      => gridstruct%fC
!      rdxc    => gridstruct%rdxc
!      rdyc    => gridstruct%rdyc
!      dx      => gridstruct%dx
!      dy      => gridstruct%dy
!      dxc     => gridstruct%dxc
!      dyc     => gridstruct%dyc
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
    iep1 = ie + 1
    jep1 = je + 1
    CALL D2A2C_VECT(u, v, ua, va, uc, vc, ut, vt, dord4, gridstruct, bd&
&             , npx, npy, nested, flagstruct%grid_type)
    IF (nord .GT. 0) THEN
      IF (nested) THEN
        CALL DIVERGENCE_CORNER_NEST(u, v, ua, va, divg_d, gridstruct, &
&                             flagstruct, bd)
      ELSE
        CALL DIVERGENCE_CORNER(u, v, ua, va, divg_d, gridstruct, &
&                        flagstruct, bd)
      END IF
    END IF
!!! TO DO: remove 'test_up'
!!!   check repro with siena
!!$AD II-LOOP
    DO j=js-1,jep1
      DO i=is-1,iep1+1
        IF (ut(i, j) .GT. 0.) THEN
          ut(i, j) = dt2*ut(i, j)*gridstruct%dy(i, j)*gridstruct%sin_sg(&
&           i-1, j, 3)
        ELSE
          ut(i, j) = dt2*ut(i, j)*gridstruct%dy(i, j)*gridstruct%sin_sg(&
&           i, j, 1)
        END IF
      END DO
    END DO
!!$AD II-LOOP
    DO j=js-1,je+2
      DO i=is-1,iep1
        IF (vt(i, j) .GT. 0.) THEN
          vt(i, j) = dt2*vt(i, j)*gridstruct%dx(i, j)*gridstruct%sin_sg(&
&           i, j-1, 4)
        ELSE
          vt(i, j) = dt2*vt(i, j)*gridstruct%dx(i, j)*gridstruct%sin_sg(&
&           i, j, 2)
        END IF
      END DO
    END DO
!----------------
! Transport delp:
!----------------
! Xdir:
    IF (flagstruct%grid_type .LT. 3 .AND. (.NOT.nested)) CALL &
&     FILL2_4CORNERS(delp, pt, 1, bd, npx, npy, sw_corner, se_corner, &
&              ne_corner, nw_corner)
    IF (hydrostatic) THEN
!#ifdef SW_DYNAMICS
!           do j=js-1,jep1
!              do i=is-1,ie+2
!                 if ( ut(i,j) > 0. ) then
!                      fx1(i,j) = delp(i-1,j)
!                 else
!                      fx1(i,j) = delp(i,j)
!                 endif
!                 fx1(i,j) =  ut(i,j)*fx1(i,j)
!              enddo
!           enddo
!#else
      DO j=js-1,jep1
        DO i=is-1,ie+2
          IF (ut(i, j) .GT. 0.) THEN
            fx1(i, j) = delp(i-1, j)
            fx(i, j) = pt(i-1, j)
          ELSE
            fx1(i, j) = delp(i, j)
            fx(i, j) = pt(i, j)
          END IF
          fx1(i, j) = ut(i, j)*fx1(i, j)
          fx(i, j) = fx1(i, j)*fx(i, j)
        END DO
      END DO
    ELSE
!#endif
      IF (flagstruct%grid_type .LT. 3) CALL FILL_4CORNERS(w, 1, bd, npx&
&                                                   , npy, sw_corner, &
&                                                   se_corner, ne_corner&
&                                                   , nw_corner)
      DO j=js-1,je+1
        DO i=is-1,ie+2
          IF (ut(i, j) .GT. 0.) THEN
            fx1(i, j) = delp(i-1, j)
            fx(i, j) = pt(i-1, j)
            fx2(i, j) = w(i-1, j)
          ELSE
            fx1(i, j) = delp(i, j)
            fx(i, j) = pt(i, j)
            fx2(i, j) = w(i, j)
          END IF
          fx1(i, j) = ut(i, j)*fx1(i, j)
          fx(i, j) = fx1(i, j)*fx(i, j)
          fx2(i, j) = fx1(i, j)*fx2(i, j)
        END DO
      END DO
    END IF
! Ydir:
    IF (flagstruct%grid_type .LT. 3 .AND. (.NOT.nested)) CALL &
&     FILL2_4CORNERS(delp, pt, 2, bd, npx, npy, sw_corner, se_corner, &
&              ne_corner, nw_corner)
    IF (hydrostatic) THEN
      DO j=js-1,jep1+1
        DO i=is-1,iep1
          IF (vt(i, j) .GT. 0.) THEN
            fy1(i, j) = delp(i, j-1)
            fy(i, j) = pt(i, j-1)
          ELSE
            fy1(i, j) = delp(i, j)
            fy(i, j) = pt(i, j)
          END IF
          fy1(i, j) = vt(i, j)*fy1(i, j)
          fy(i, j) = fy1(i, j)*fy(i, j)
        END DO
      END DO
      DO j=js-1,jep1
        DO i=is-1,iep1
          delpc(i, j) = delp(i, j) + (fx1(i, j)-fx1(i+1, j)+fy1(i, j)-&
&           fy1(i, j+1))*gridstruct%rarea(i, j)
!#ifdef SW_DYNAMICS
!                   ptc(i,j) = pt(i,j)
!#else
          ptc(i, j) = (pt(i, j)*delp(i, j)+(fx(i, j)-fx(i+1, j)+fy(i, j)&
&           -fy(i, j+1))*gridstruct%rarea(i, j))/delpc(i, j)
        END DO
      END DO
    ELSE
!#endif
      IF (flagstruct%grid_type .LT. 3) CALL FILL_4CORNERS(w, 2, bd, npx&
&                                                   , npy, sw_corner, &
&                                                   se_corner, ne_corner&
&                                                   , nw_corner)
      DO j=js-1,je+2
        DO i=is-1,ie+1
          IF (vt(i, j) .GT. 0.) THEN
            fy1(i, j) = delp(i, j-1)
            fy(i, j) = pt(i, j-1)
            fy2(i, j) = w(i, j-1)
          ELSE
            fy1(i, j) = delp(i, j)
            fy(i, j) = pt(i, j)
            fy2(i, j) = w(i, j)
          END IF
          fy1(i, j) = vt(i, j)*fy1(i, j)
          fy(i, j) = fy1(i, j)*fy(i, j)
          fy2(i, j) = fy1(i, j)*fy2(i, j)
        END DO
      END DO
      DO j=js-1,je+1
        DO i=is-1,ie+1
          delpc(i, j) = delp(i, j) + (fx1(i, j)-fx1(i+1, j)+fy1(i, j)-&
&           fy1(i, j+1))*gridstruct%rarea(i, j)
          ptc(i, j) = (pt(i, j)*delp(i, j)+(fx(i, j)-fx(i+1, j)+fy(i, j)&
&           -fy(i, j+1))*gridstruct%rarea(i, j))/delpc(i, j)
          wc(i, j) = (w(i, j)*delp(i, j)+(fx2(i, j)-fx2(i+1, j)+fy2(i, j&
&           )-fy2(i, j+1))*gridstruct%rarea(i, j))/delpc(i, j)
        END DO
      END DO
    END IF
!------------
! Compute KE:
!------------
!Since uc = u*, i.e. the covariant wind perpendicular to the face edge, if we want to compute kinetic energy we will need the tru
!e coordinate-parallel covariant wind, computed through u = uc*sina + v*cosa. 
!Use the alpha for the cell KE is being computed in.
!!! TO DO:
!!! Need separate versions for nesting/single-tile
!!!   and for cubed-sphere
    IF (nested .OR. flagstruct%grid_type .GE. 3) THEN
      DO j=js-1,jep1
        DO i=is-1,iep1
          IF (ua(i, j) .GT. 0.) THEN
            ke(i, j) = uc(i, j)
          ELSE
            ke(i, j) = uc(i+1, j)
          END IF
        END DO
      END DO
      DO j=js-1,jep1
        DO i=is-1,iep1
          IF (va(i, j) .GT. 0.) THEN
            vort(i, j) = vc(i, j)
          ELSE
            vort(i, j) = vc(i, j+1)
          END IF
        END DO
      END DO
    ELSE
      DO j=js-1,jep1
        DO i=is-1,iep1
          IF (ua(i, j) .GT. 0.) THEN
            IF (i .EQ. 1) THEN
              ke(1, j) = uc(1, j)*gridstruct%sin_sg(1, j, 1) + v(1, j)*&
&               gridstruct%cos_sg(1, j, 1)
            ELSE IF (i .EQ. npx) THEN
              ke(i, j) = uc(npx, j)*gridstruct%sin_sg(npx, j, 1) + v(npx&
&               , j)*gridstruct%cos_sg(npx, j, 1)
            ELSE
              ke(i, j) = uc(i, j)
            END IF
          ELSE IF (i .EQ. 0) THEN
            ke(0, j) = uc(1, j)*gridstruct%sin_sg(0, j, 3) + v(1, j)*&
&             gridstruct%cos_sg(0, j, 3)
          ELSE IF (i .EQ. npx - 1) THEN
            ke(i, j) = uc(npx, j)*gridstruct%sin_sg(npx-1, j, 3) + v(npx&
&             , j)*gridstruct%cos_sg(npx-1, j, 3)
          ELSE
            ke(i, j) = uc(i+1, j)
          END IF
        END DO
      END DO
      DO j=js-1,jep1
        DO i=is-1,iep1
          IF (va(i, j) .GT. 0.) THEN
            IF (j .EQ. 1) THEN
              vort(i, 1) = vc(i, 1)*gridstruct%sin_sg(i, 1, 2) + u(i, 1)&
&               *gridstruct%cos_sg(i, 1, 2)
            ELSE IF (j .EQ. npy) THEN
              vort(i, j) = vc(i, npy)*gridstruct%sin_sg(i, npy, 2) + u(i&
&               , npy)*gridstruct%cos_sg(i, npy, 2)
            ELSE
              vort(i, j) = vc(i, j)
            END IF
          ELSE IF (j .EQ. 0) THEN
            vort(i, 0) = vc(i, 1)*gridstruct%sin_sg(i, 0, 4) + u(i, 1)*&
&             gridstruct%cos_sg(i, 0, 4)
          ELSE IF (j .EQ. npy - 1) THEN
            vort(i, j) = vc(i, npy)*gridstruct%sin_sg(i, npy-1, 4) + u(i&
&             , npy)*gridstruct%cos_sg(i, npy-1, 4)
          ELSE
            vort(i, j) = vc(i, j+1)
          END IF
        END DO
      END DO
    END IF
    dt4 = 0.5*dt2
    DO j=js-1,jep1
      DO i=is-1,iep1
        ke(i, j) = dt4*(ua(i, j)*ke(i, j)+va(i, j)*vort(i, j))
      END DO
    END DO
!------------------------------
! Compute circulation on C grid
!------------------------------
! To consider using true co-variant winds at face edges?
    DO j=js-1,je+1
      DO i=is,ie+1
        fx(i, j) = uc(i, j)*gridstruct%dxc(i, j)
      END DO
    END DO
    DO j=js,je+1
      DO i=is-1,ie+1
        fy(i, j) = vc(i, j)*gridstruct%dyc(i, j)
      END DO
    END DO
    DO j=js,je+1
      DO i=is,ie+1
        vort(i, j) = fx(i, j-1) - fx(i, j) - fy(i-1, j) + fy(i, j)
      END DO
    END DO
! Remove the extra term at the corners:
    IF (sw_corner) vort(1, 1) = vort(1, 1) + fy(0, 1)
    IF (se_corner) vort(npx, 1) = vort(npx, 1) - fy(npx, 1)
    IF (ne_corner) vort(npx, npy) = vort(npx, npy) - fy(npx, npy)
    IF (nw_corner) vort(1, npy) = vort(1, npy) + fy(0, npy)
!----------------------------
! Compute absolute vorticity
!----------------------------
    DO j=js,je+1
      DO i=is,ie+1
        vort(i, j) = gridstruct%fc(i, j) + gridstruct%rarea_c(i, j)*vort&
&         (i, j)
      END DO
    END DO
!----------------------------------
! Transport absolute vorticity:
!----------------------------------
!To go from v to contravariant v at the edges, we divide by sin_sg;
! but we then must multiply by sin_sg to get the proper flux.
! These cancel, leaving us with fy1 = dt2*v at the edges.
! (For the same reason we only divide by sin instead of sin**2 in the interior)
!! TO DO: separate versions for nesting/single-tile and cubed-sphere
    IF (nested .OR. flagstruct%grid_type .GE. 3) THEN
      DO j=js,je
        DO i=is,iep1
          fy1(i, j) = dt2*(v(i, j)-uc(i, j)*gridstruct%cosa_u(i, j))/&
&           gridstruct%sina_u(i, j)
          IF (fy1(i, j) .GT. 0.) THEN
            fy(i, j) = vort(i, j)
          ELSE
            fy(i, j) = vort(i, j+1)
          END IF
        END DO
      END DO
      DO j=js,jep1
        DO i=is,ie
          fx1(i, j) = dt2*(u(i, j)-vc(i, j)*gridstruct%cosa_v(i, j))/&
&           gridstruct%sina_v(i, j)
          IF (fx1(i, j) .GT. 0.) THEN
            fx(i, j) = vort(i, j)
          ELSE
            fx(i, j) = vort(i+1, j)
          END IF
        END DO
      END DO
    ELSE
      DO j=js,je
!DEC$ VECTOR ALWAYS
        DO i=is,iep1
          IF (i .EQ. 1 .OR. i .EQ. npx) THEN
            fy1(i, j) = dt2*v(i, j)
          ELSE
            fy1(i, j) = dt2*(v(i, j)-uc(i, j)*gridstruct%cosa_u(i, j))/&
&             gridstruct%sina_u(i, j)
          END IF
          IF (fy1(i, j) .GT. 0.) THEN
            fy(i, j) = vort(i, j)
          ELSE
            fy(i, j) = vort(i, j+1)
          END IF
        END DO
      END DO
      DO j=js,jep1
        IF (j .EQ. 1 .OR. j .EQ. npy) THEN
!DEC$ VECTOR ALWAYS
          DO i=is,ie
            fx1(i, j) = dt2*u(i, j)
            IF (fx1(i, j) .GT. 0.) THEN
              fx(i, j) = vort(i, j)
            ELSE
              fx(i, j) = vort(i+1, j)
            END IF
          END DO
        ELSE
!DEC$ VECTOR ALWAYS
          DO i=is,ie
            fx1(i, j) = dt2*(u(i, j)-vc(i, j)*gridstruct%cosa_v(i, j))/&
&             gridstruct%sina_v(i, j)
            IF (fx1(i, j) .GT. 0.) THEN
              fx(i, j) = vort(i, j)
            ELSE
              fx(i, j) = vort(i+1, j)
            END IF
          END DO
        END IF
      END DO
    END IF
! Update time-centered winds on the C-Grid
    DO j=js,je
      DO i=is,iep1
        uc(i, j) = uc(i, j) + fy1(i, j)*fy(i, j) + gridstruct%rdxc(i, j)&
&         *(ke(i-1, j)-ke(i, j))
      END DO
    END DO
    DO j=js,jep1
      DO i=is,ie
        vc(i, j) = vc(i, j) - fx1(i, j)*fx(i, j) + gridstruct%rdyc(i, j)&
&         *(ke(i, j-1)-ke(i, j))
      END DO
    END DO
  END SUBROUTINE C_SW
!  Differentiation of d_sw in forward (tangent) mode (with options r8):
!   variations   of useful results: yfx_adv q crx_adv u v w delp
!                xfx_adv uc ptc xflux cry_adv delpc vc yflux divg_d
!                heat_source pt cx cy
!   with respect to varying inputs: yfx_adv q crx_adv u v w delp
!                ua xfx_adv uc ptc xflux cry_adv delpc va vc yflux
!                divg_d z_rat heat_source pt cx cy
!     d_sw :: D-Grid Shallow Water Routine
  SUBROUTINE D_SW_TLM(delpc, delpc_tl, delpc_tj, delp, delp_tl, ptc, &
&   ptc_tl, pt, pt_tl, u, u_tl, v, v_tl, w, w_tl, uc, uc_tl, vc, vc_tl, &
&   ua, ua_tl, va, va_tl, divg_d, divg_d_tl, xflux, xflux_tl, yflux, &
&   yflux_tl, cx, cx_tl, cy, cy_tl, crx_adv, crx_adv_tl, cry_adv, &
&   cry_adv_tl, xfx_adv, xfx_adv_tl, yfx_adv, yfx_adv_tl, q_con, z_rat, &
&   z_rat_tl, heat_source, heat_source_tl, zvir, sphum, nq, q, q_tl, k, &
&   km, inline_q, dt, hord_tr, hord_mt, hord_vt, hord_tm, hord_dp, &
&   hord_tr_pert, hord_mt_pert, hord_vt_pert, hord_tm_pert, hord_dp_pert&
&   , nord, nord_v, nord_w, nord_t, dddmp, d2_bg, d4_bg, damp_v, damp_w&
&   , damp_t, d_con, split_damp, nord_pert, nord_v_pert, nord_w_pert, &
&   nord_t_pert, dddmp_pert, d2_bg_pert, d4_bg_pert, damp_v_pert, &
&   damp_w_pert, damp_t_pert, d_con_pert, hydrostatic, gridstruct, &
&   flagstruct, bd)
    IMPLICIT NONE
!#ifdef SW_DYNAMICS
!      endif ! test_case
!#endif
    INTEGER, INTENT(IN) :: hord_tr, hord_mt, hord_vt, hord_tm, hord_dp
    INTEGER, INTENT(IN) :: hord_tr_pert, hord_mt_pert, hord_vt_pert, &
&   hord_tm_pert, hord_dp_pert
! nord=1 divergence damping; (del-4) or 3 (del-8)
    INTEGER, INTENT(IN) :: nord
! vorticity damping
    INTEGER, INTENT(IN) :: nord_v
! vertical velocity
    INTEGER, INTENT(IN) :: nord_w
! pt
    INTEGER, INTENT(IN) :: nord_t
    LOGICAL, INTENT(IN) :: split_damp
    INTEGER, INTENT(IN) :: nord_pert, nord_v_pert, nord_w_pert, &
&   nord_t_pert
    INTEGER, INTENT(IN) :: sphum, nq, k, km
    REAL(fvprc), INTENT(IN) :: dt, dddmp, d2_bg, d4_bg, d_con
    REAL(fvprc), INTENT(IN) :: dddmp_pert, d2_bg_pert, d4_bg_pert, &
&   d_con_pert
    REAL(fvprc), INTENT(IN) :: zvir
    REAL(fvprc), INTENT(IN) :: damp_v, damp_w, damp_t
    REAL(fvprc), INTENT(IN) :: damp_v_pert, damp_w_pert, damp_t_pert
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! divergence
    REAL(fvprc), INTENT(INOUT) :: divg_d(bd%isd:bd%ied+1, bd%jsd:bd%jed+&
&   1)
    REAL(fvprc), INTENT(INOUT) :: divg_d_tl(bd%isd:bd%ied+1, bd%jsd:bd%&
&   jed+1)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   z_rat
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   z_rat_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delp, pt, ua, va, w
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delp_tl, pt_tl, ua_tl, va_tl, w_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%isd, bd%jsd:bd%jsd), INTENT(INOUT) &
&   :: q_con
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u, vc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u_tl, vc_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v, uc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v_tl, uc_tl
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, km, nq&
&   )
    REAL(fvprc), INTENT(INOUT) :: q_tl(bd%isd:bd%ied, bd%jsd:bd%jed, km&
&   , nq)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(OUT) ::&
&   delpc, ptc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(OUT) ::&
&   delpc_tl, ptc_tl
    REAL(fvprc), DIMENSION(bd%is:bd%ie, bd%js:bd%je), INTENT(OUT) :: &
&   heat_source
    REAL(fvprc), DIMENSION(bd%is:bd%ie, bd%js:bd%je), INTENT(OUT) :: &
&   heat_source_tl
! The flux capacitors:
    REAL(fvprc), INTENT(INOUT) :: xflux(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc), INTENT(INOUT) :: xflux_tl(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc), INTENT(INOUT) :: yflux(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc), INTENT(INOUT) :: yflux_tl(bd%is:bd%ie, bd%js:bd%je+1)
!------------------------
    REAL(fvprc), INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: cx_tl(bd%is:bd%ie+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1)
    REAL(fvprc), INTENT(INOUT) :: cy_tl(bd%isd:bd%ied, bd%js:bd%je+1)
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: inline_q
    REAL(fvprc), DIMENSION(bd%is:bd%ie+1, bd%jsd:bd%jed), INTENT(OUT) ::&
&   crx_adv, xfx_adv
    REAL(fvprc), DIMENSION(bd%is:bd%ie+1, bd%jsd:bd%jed), INTENT(OUT) ::&
&   crx_adv_tl, xfx_adv_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%js:bd%je+1), INTENT(OUT) ::&
&   cry_adv, yfx_adv
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%js:bd%je+1), INTENT(OUT) ::&
&   cry_adv_tl, yfx_adv_tl
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
! Local:
    REAL(fvprc) :: ut(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: ut_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: vt(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: vt_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1)
!---
    REAL(fvprc) :: fx2(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: fx2_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: fy2(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: fy2_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1)
!  work array
    REAL(fvprc) :: dw(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: dw_tl(bd%is:bd%ie, bd%js:bd%je)
!---
    REAL(fvprc), DIMENSION(bd%is:bd%ie+1, bd%js:bd%je+1) :: ub, vb
    REAL(fvprc), DIMENSION(bd%is:bd%ie+1, bd%js:bd%je+1) :: ub_tl, vb_tl
!  work array
    REAL(fvprc) :: wk(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk_tl(bd%isd:bd%ied, bd%jsd:bd%jed)
!  needs this for corner_comm
    REAL(fvprc) :: ke(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
    REAL(fvprc) :: ke_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
! Vorticity
    REAL(fvprc) :: vort(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: vort_tl(bd%isd:bd%ied, bd%jsd:bd%jed)
! 1-D X-direction Fluxes
    REAL(fvprc) :: fx(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: fx_tl(bd%is:bd%ie+1, bd%js:bd%je)
! 1-D Y-direction Fluxes
    REAL(fvprc) :: fy(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: fy_tl(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: ra_x(bd%is:bd%ie, bd%jsd:bd%jed)
    REAL(fvprc) :: ra_x_tl(bd%is:bd%ie, bd%jsd:bd%jed)
    REAL(fvprc) :: ra_y(bd%isd:bd%ied, bd%js:bd%je)
    REAL(fvprc) :: ra_y_tl(bd%isd:bd%ied, bd%js:bd%je)
    REAL(fvprc) :: gx(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: gx_tl(bd%is:bd%ie+1, bd%js:bd%je)
! work Y-dir flux array
    REAL(fvprc) :: gy(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: gy_tl(bd%is:bd%ie, bd%js:bd%je+1)
    LOGICAL :: fill_c
    REAL(fvprc) :: dt2, dt4, dt5, dt6
    REAL(fvprc) :: damp, damp2, damp4, dd8, u2, v2, du2, dv2, damp4_pert
    REAL(fvprc) :: u2_tl, v2_tl, du2_tl, dv2_tl
    REAL(fvprc) :: u_lon
    INTEGER :: i, j, is2, ie1, js2, je1, n, nt, n2, iq
!      real(FVPRC), pointer, dimension(:,:) :: area, area_c, rarea, rarea_c
!      real(FVPRC), pointer, dimension(:,:,:) :: sin_sg
!      real(FVPRC), pointer, dimension(:,:)   :: cosa_u, cosa_v, cosa_s
!      real(FVPRC), pointer, dimension(:,:)   :: sina_u, sina_v
!      real(FVPRC), pointer, dimension(:,:)   :: rsin_u, rsin_v, rsina
!      real(FVPRC), pointer, dimension(:,:)   :: f0, rsin2, divg_u, divg_v
!      real(FVPRC), pointer, dimension(:,:) ::  cosa, dx, dy, dxc, dyc, rdxa, rdya, rdx, rdy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTEGER :: npx, npy
    LOGICAL :: nested
    REAL(fvprc) :: da_min, da_min_c
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: delp_tj, &
&   pt_tj, w_tj
    REAL(fvprc) :: q_tj(bd%isd:bd%ied, bd%jsd:bd%jed, km, nq)
    REAL(fvprc) :: vort_tj(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), DIMENSION(bd%is:bd%ie+1, bd%js:bd%je+1) :: ub_tj, vb_tj
    REAL(fvprc) :: fx_tj(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: fy_tj(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: gx_tj(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: gy_tj(bd%is:bd%ie, bd%js:bd%je+1)
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(OUT) ::&
&   delpc_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ptc_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1) :: ke_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1) :: u_tj, &
&   vc_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed) :: v_tj, &
&   uc_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ua_tj, va_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1) :: &
&   divg_d_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: wk_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed) :: ut_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1) :: vt_tj
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    REAL(fvprc) :: pwx1
    INTEGER :: pwy1
!
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
    fx = 0.0
    fy = 0.0
    gx = 0.0
    gy = 0.0
    ub = 0.0
    vb = 0.0
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    npx = flagstruct%npx
    npy = flagstruct%npy
    nested = gridstruct%nested
    da_min = gridstruct%da_min
    da_min_c = gridstruct%da_min_c
! end grid_type choices
!      area      => gridstruct%area   
!      rarea     => gridstruct%rarea  
!      rarea_c   => gridstruct%rarea_c
!      sin_sg    => gridstruct%sin_sg 
!      cosa_u    => gridstruct%cosa_u 
!      cosa_v    => gridstruct%cosa_v 
!      cosa_s    => gridstruct%cosa_s 
!      sina_u    => gridstruct%sina_u 
!      sina_v    => gridstruct%sina_v 
!      rsin_u    => gridstruct%rsin_u 
!      rsin_v    => gridstruct%rsin_v 
!      rsina     => gridstruct%rsina  
!      f0        => gridstruct%f0     
!      rsin2     => gridstruct%rsin2  
!      divg_u    => gridstruct%divg_u 
!      divg_v    => gridstruct%divg_v 
!      cosa      => gridstruct%cosa   
!      dx        => gridstruct%dx     
!      dy        => gridstruct%dy     
!      dxc       => gridstruct%dxc    
!      dyc       => gridstruct%dyc    
!      rdxa      => gridstruct%rdxa   
!      rdya      => gridstruct%rdya   
!      rdx       => gridstruct%rdx    
!      rdy       => gridstruct%rdy    
!#ifdef SW_DYNAMICS 
!      if ( test_case == 1 ) then
!        do j=jsd,jed
!           do i=is,ie+1
!              xfx_adv(i,j) = dt * uc(i,j) / gridstruct%sina_u(i,j)
!              if (xfx_adv(i,j) > 0.) then
!                  crx_adv(i,j) = xfx_adv(i,j) * gridstruct%rdxa(i-1,j)
!              else
!                  crx_adv(i,j) = xfx_adv(i,j) * gridstruct%rdxa(i,j)
!              endif
!              xfx_adv(i,j) = gridstruct%dy(i,j)*xfx_adv(i,j)*gridstruct%sina_u(i,j)
!           enddo
!        enddo
!
!        do j=js,je+1
!           do i=isd,ied
!              yfx_adv(i,j) = dt * vc(i,j) / gridstruct%sina_v(i,j)
!              if (yfx_adv(i,j) > 0.) then
!                 cry_adv(i,j) = yfx_adv(i,j) * gridstruct%rdya(i,j-1)
!              else
!                 cry_adv(i,j) = yfx_adv(i,j) * gridstruct%rdya(i,j)
!              endif
!              yfx_adv(i,j) = gridstruct%dx(i,j)*yfx_adv(i,j)*gridstruct%sina_v(i,j)
!           enddo
!        enddo
!      else
!#endif
    IF (flagstruct%grid_type .LT. 3) THEN
!!! TO DO: separate versions for nesting and for cubed-sphere
      IF (nested) THEN
        ut_tl = 0.0_FVPRC
        DO j=jsd,jed
          DO i=is-1,ie+2
            ut_tl(i, j) = gridstruct%rsin_u(i, j)*(uc_tl(i, j)-0.25*&
&             gridstruct%cosa_u(i, j)*(vc_tl(i-1, j)+vc_tl(i, j)+vc_tl(i&
&             -1, j+1)+vc_tl(i, j+1)))
            ut(i, j) = (uc(i, j)-0.25*gridstruct%cosa_u(i, j)*(vc(i-1, j&
&             )+vc(i, j)+vc(i-1, j+1)+vc(i, j+1)))*gridstruct%rsin_u(i, &
&             j)
          END DO
        END DO
        vt_tl = 0.0_FVPRC
        DO j=js-1,je+2
          DO i=isd,ied
            vt_tl(i, j) = gridstruct%rsin_v(i, j)*(vc_tl(i, j)-0.25*&
&             gridstruct%cosa_v(i, j)*(uc_tl(i, j-1)+uc_tl(i+1, j-1)+&
&             uc_tl(i, j)+uc_tl(i+1, j)))
            vt(i, j) = (vc(i, j)-0.25*gridstruct%cosa_v(i, j)*(uc(i, j-1&
&             )+uc(i+1, j-1)+uc(i, j)+uc(i+1, j)))*gridstruct%rsin_v(i, &
&             j)
          END DO
        END DO
      ELSE
        ut_tl = 0.0_FVPRC
        DO j=jsd,jed
          IF (j .NE. 0 .AND. j .NE. 1 .AND. j .NE. npy - 1 .AND. j .NE. &
&             npy) THEN
            DO i=is-1,ie+2
              ut_tl(i, j) = gridstruct%rsin_u(i, j)*(uc_tl(i, j)-0.25*&
&               gridstruct%cosa_u(i, j)*(vc_tl(i-1, j)+vc_tl(i, j)+vc_tl&
&               (i-1, j+1)+vc_tl(i, j+1)))
              ut(i, j) = (uc(i, j)-0.25*gridstruct%cosa_u(i, j)*(vc(i-1&
&               , j)+vc(i, j)+vc(i-1, j+1)+vc(i, j+1)))*gridstruct%&
&               rsin_u(i, j)
            END DO
          END IF
        END DO
        vt_tl = 0.0_FVPRC
        DO j=js-1,je+2
          IF (j .NE. 1 .AND. j .NE. npy) THEN
            DO i=isd,ied
              vt_tl(i, j) = gridstruct%rsin_v(i, j)*(vc_tl(i, j)-0.25*&
&               gridstruct%cosa_v(i, j)*(uc_tl(i, j-1)+uc_tl(i+1, j-1)+&
&               uc_tl(i, j)+uc_tl(i+1, j)))
              vt(i, j) = (vc(i, j)-0.25*gridstruct%cosa_v(i, j)*(uc(i, j&
&               -1)+uc(i+1, j-1)+uc(i, j)+uc(i+1, j)))*gridstruct%rsin_v&
&               (i, j)
            END DO
          END IF
        END DO
      END IF
!.not. nested
      IF (.NOT.nested) THEN
! West face
! West edge:
        IF (is .EQ. 1) THEN
          DO j=jsd,jed
            IF (uc(1, j)*dt .GT. 0.) THEN
              ut_tl(1, j) = uc_tl(1, j)/gridstruct%sin_sg(0, j, 3)
              ut(1, j) = uc(1, j)/gridstruct%sin_sg(0, j, 3)
            ELSE
              ut_tl(1, j) = uc_tl(1, j)/gridstruct%sin_sg(1, j, 1)
              ut(1, j) = uc(1, j)/gridstruct%sin_sg(1, j, 1)
            END IF
          END DO
          IF (3 .LT. js) THEN
            max1 = js
          ELSE
            max1 = 3
          END IF
          IF (npy - 2 .GT. je + 1) THEN
            min1 = je + 1
          ELSE
            min1 = npy - 2
          END IF
          DO j=max1,min1
            vt_tl(0, j) = vc_tl(0, j) - 0.25*gridstruct%cosa_v(0, j)*(&
&             ut_tl(0, j-1)+ut_tl(1, j-1)+ut_tl(0, j)+ut_tl(1, j))
            vt(0, j) = vc(0, j) - 0.25*gridstruct%cosa_v(0, j)*(ut(0, j-&
&             1)+ut(1, j-1)+ut(0, j)+ut(1, j))
            vt_tl(1, j) = vc_tl(1, j) - 0.25*gridstruct%cosa_v(1, j)*(&
&             ut_tl(1, j-1)+ut_tl(2, j-1)+ut_tl(1, j)+ut_tl(2, j))
            vt(1, j) = vc(1, j) - 0.25*gridstruct%cosa_v(1, j)*(ut(1, j-&
&             1)+ut(2, j-1)+ut(1, j)+ut(2, j))
          END DO
        END IF
! East edge:
        IF (ie + 1 .EQ. npx) THEN
          DO j=jsd,jed
            IF (uc(npx, j)*dt .GT. 0.) THEN
              ut_tl(npx, j) = uc_tl(npx, j)/gridstruct%sin_sg(npx-1, j, &
&               3)
              ut(npx, j) = uc(npx, j)/gridstruct%sin_sg(npx-1, j, 3)
            ELSE
              ut_tl(npx, j) = uc_tl(npx, j)/gridstruct%sin_sg(npx, j, 1)
              ut(npx, j) = uc(npx, j)/gridstruct%sin_sg(npx, j, 1)
            END IF
          END DO
          IF (3 .LT. js) THEN
            max2 = js
          ELSE
            max2 = 3
          END IF
          IF (npy - 2 .GT. je + 1) THEN
            min2 = je + 1
          ELSE
            min2 = npy - 2
          END IF
          DO j=max2,min2
            vt_tl(npx-1, j) = vc_tl(npx-1, j) - 0.25*gridstruct%cosa_v(&
&             npx-1, j)*(ut_tl(npx-1, j-1)+ut_tl(npx, j-1)+ut_tl(npx-1, &
&             j)+ut_tl(npx, j))
            vt(npx-1, j) = vc(npx-1, j) - 0.25*gridstruct%cosa_v(npx-1, &
&             j)*(ut(npx-1, j-1)+ut(npx, j-1)+ut(npx-1, j)+ut(npx, j))
            vt_tl(npx, j) = vc_tl(npx, j) - 0.25*gridstruct%cosa_v(npx, &
&             j)*(ut_tl(npx, j-1)+ut_tl(npx+1, j-1)+ut_tl(npx, j)+ut_tl(&
&             npx+1, j))
            vt(npx, j) = vc(npx, j) - 0.25*gridstruct%cosa_v(npx, j)*(ut&
&             (npx, j-1)+ut(npx+1, j-1)+ut(npx, j)+ut(npx+1, j))
          END DO
        END IF
! South (Bottom) edge:
        IF (js .EQ. 1) THEN
          DO i=isd,ied
            IF (vc(i, 1)*dt .GT. 0.) THEN
              vt_tl(i, 1) = vc_tl(i, 1)/gridstruct%sin_sg(i, 0, 4)
              vt(i, 1) = vc(i, 1)/gridstruct%sin_sg(i, 0, 4)
            ELSE
              vt_tl(i, 1) = vc_tl(i, 1)/gridstruct%sin_sg(i, 1, 2)
              vt(i, 1) = vc(i, 1)/gridstruct%sin_sg(i, 1, 2)
            END IF
          END DO
          IF (3 .LT. is) THEN
            max3 = is
          ELSE
            max3 = 3
          END IF
          IF (npx - 2 .GT. ie + 1) THEN
            min3 = ie + 1
          ELSE
            min3 = npx - 2
          END IF
          DO i=max3,min3
            ut_tl(i, 0) = uc_tl(i, 0) - 0.25*gridstruct%cosa_u(i, 0)*(&
&             vt_tl(i-1, 0)+vt_tl(i, 0)+vt_tl(i-1, 1)+vt_tl(i, 1))
            ut(i, 0) = uc(i, 0) - 0.25*gridstruct%cosa_u(i, 0)*(vt(i-1, &
&             0)+vt(i, 0)+vt(i-1, 1)+vt(i, 1))
            ut_tl(i, 1) = uc_tl(i, 1) - 0.25*gridstruct%cosa_u(i, 1)*(&
&             vt_tl(i-1, 1)+vt_tl(i, 1)+vt_tl(i-1, 2)+vt_tl(i, 2))
            ut(i, 1) = uc(i, 1) - 0.25*gridstruct%cosa_u(i, 1)*(vt(i-1, &
&             1)+vt(i, 1)+vt(i-1, 2)+vt(i, 2))
          END DO
        END IF
! North edge:
        IF (je + 1 .EQ. npy) THEN
          DO i=isd,ied
            IF (vc(i, npy)*dt .GT. 0.) THEN
              vt_tl(i, npy) = vc_tl(i, npy)/gridstruct%sin_sg(i, npy-1, &
&               4)
              vt(i, npy) = vc(i, npy)/gridstruct%sin_sg(i, npy-1, 4)
            ELSE
              vt_tl(i, npy) = vc_tl(i, npy)/gridstruct%sin_sg(i, npy, 2)
              vt(i, npy) = vc(i, npy)/gridstruct%sin_sg(i, npy, 2)
            END IF
          END DO
          IF (3 .LT. is) THEN
            max4 = is
          ELSE
            max4 = 3
          END IF
          IF (npx - 2 .GT. ie + 1) THEN
            min4 = ie + 1
          ELSE
            min4 = npx - 2
          END IF
          DO i=max4,min4
            ut_tl(i, npy-1) = uc_tl(i, npy-1) - 0.25*gridstruct%cosa_u(i&
&             , npy-1)*(vt_tl(i-1, npy-1)+vt_tl(i, npy-1)+vt_tl(i-1, npy&
&             )+vt_tl(i, npy))
            ut(i, npy-1) = uc(i, npy-1) - 0.25*gridstruct%cosa_u(i, npy-&
&             1)*(vt(i-1, npy-1)+vt(i, npy-1)+vt(i-1, npy)+vt(i, npy))
            ut_tl(i, npy) = uc_tl(i, npy) - 0.25*gridstruct%cosa_u(i, &
&             npy)*(vt_tl(i-1, npy)+vt_tl(i, npy)+vt_tl(i-1, npy+1)+&
&             vt_tl(i, npy+1))
            ut(i, npy) = uc(i, npy) - 0.25*gridstruct%cosa_u(i, npy)*(vt&
&             (i-1, npy)+vt(i, npy)+vt(i-1, npy+1)+vt(i, npy+1))
          END DO
        END IF
! The following code solves a 2x2 system to get the interior parallel-to-edge uc,vc values 
! near the corners (ex: for the sw corner ut(2,1) and vt(1,2) are solved for simultaneously). 
! It then computes the halo uc, vc values so as to be consistent with the computations on 
! the facing panel. 
!The system solved is:
!  ut(2,1) = uc(2,1) - avg(vt)*gridstruct%cosa_u(2,1)
!  vt(1,2) = vc(1,2) - avg(ut)*gridstruct%cosa_v(1,2)
! in which avg(vt) includes vt(1,2) and avg(ut) includes ut(2,1)
        IF (sw_corner) THEN
          damp = 1./(1.-0.0625*gridstruct%cosa_u(2, 0)*gridstruct%cosa_v&
&           (1, 0))
          ut_tl(2, 0) = damp*(uc_tl(2, 0)-0.25*gridstruct%cosa_u(2, 0)*(&
&           vt_tl(1, 1)+vt_tl(2, 1)+vt_tl(2, 0)+vc_tl(1, 0)-0.25*&
&           gridstruct%cosa_v(1, 0)*(ut_tl(1, 0)+ut_tl(1, -1)+ut_tl(2, -&
&           1))))
          ut(2, 0) = (uc(2, 0)-0.25*gridstruct%cosa_u(2, 0)*(vt(1, 1)+vt&
&           (2, 1)+vt(2, 0)+vc(1, 0)-0.25*gridstruct%cosa_v(1, 0)*(ut(1&
&           , 0)+ut(1, -1)+ut(2, -1))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(0, 1)*gridstruct%cosa_v&
&           (0, 2))
          vt_tl(0, 2) = damp*(vc_tl(0, 2)-0.25*gridstruct%cosa_v(0, 2)*(&
&           ut_tl(1, 1)+ut_tl(1, 2)+ut_tl(0, 2)+uc_tl(0, 1)-0.25*&
&           gridstruct%cosa_u(0, 1)*(vt_tl(0, 1)+vt_tl(-1, 1)+vt_tl(-1, &
&           2))))
          vt(0, 2) = (vc(0, 2)-0.25*gridstruct%cosa_v(0, 2)*(ut(1, 1)+ut&
&           (1, 2)+ut(0, 2)+uc(0, 1)-0.25*gridstruct%cosa_u(0, 1)*(vt(0&
&           , 1)+vt(-1, 1)+vt(-1, 2))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(2, 1)*gridstruct%cosa_v&
&           (1, 2))
          ut_tl(2, 1) = damp*(uc_tl(2, 1)-0.25*gridstruct%cosa_u(2, 1)*(&
&           vt_tl(1, 1)+vt_tl(2, 1)+vt_tl(2, 2)+vc_tl(1, 2)-0.25*&
&           gridstruct%cosa_v(1, 2)*(ut_tl(1, 1)+ut_tl(1, 2)+ut_tl(2, 2)&
&           )))
          ut(2, 1) = (uc(2, 1)-0.25*gridstruct%cosa_u(2, 1)*(vt(1, 1)+vt&
&           (2, 1)+vt(2, 2)+vc(1, 2)-0.25*gridstruct%cosa_v(1, 2)*(ut(1&
&           , 1)+ut(1, 2)+ut(2, 2))))*damp
          vt_tl(1, 2) = damp*(vc_tl(1, 2)-0.25*gridstruct%cosa_v(1, 2)*(&
&           ut_tl(1, 1)+ut_tl(1, 2)+ut_tl(2, 2)+uc_tl(2, 1)-0.25*&
&           gridstruct%cosa_u(2, 1)*(vt_tl(1, 1)+vt_tl(2, 1)+vt_tl(2, 2)&
&           )))
          vt(1, 2) = (vc(1, 2)-0.25*gridstruct%cosa_v(1, 2)*(ut(1, 1)+ut&
&           (1, 2)+ut(2, 2)+uc(2, 1)-0.25*gridstruct%cosa_u(2, 1)*(vt(1&
&           , 1)+vt(2, 1)+vt(2, 2))))*damp
        END IF
        IF (se_corner) THEN
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx-1, 0)*gridstruct%&
&           cosa_v(npx-1, 0))
          ut_tl(npx-1, 0) = damp*(uc_tl(npx-1, 0)-0.25*gridstruct%cosa_u&
&           (npx-1, 0)*(vt_tl(npx-1, 1)+vt_tl(npx-2, 1)+vt_tl(npx-2, 0)+&
&           vc_tl(npx-1, 0)-0.25*gridstruct%cosa_v(npx-1, 0)*(ut_tl(npx&
&           , 0)+ut_tl(npx, -1)+ut_tl(npx-1, -1))))
          ut(npx-1, 0) = (uc(npx-1, 0)-0.25*gridstruct%cosa_u(npx-1, 0)*&
&           (vt(npx-1, 1)+vt(npx-2, 1)+vt(npx-2, 0)+vc(npx-1, 0)-0.25*&
&           gridstruct%cosa_v(npx-1, 0)*(ut(npx, 0)+ut(npx, -1)+ut(npx-1&
&           , -1))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx+1, 1)*gridstruct%&
&           cosa_v(npx, 2))
          vt_tl(npx, 2) = damp*(vc_tl(npx, 2)-0.25*gridstruct%cosa_v(npx&
&           , 2)*(ut_tl(npx, 1)+ut_tl(npx, 2)+ut_tl(npx+1, 2)+uc_tl(npx+&
&           1, 1)-0.25*gridstruct%cosa_u(npx+1, 1)*(vt_tl(npx, 1)+vt_tl(&
&           npx+1, 1)+vt_tl(npx+1, 2))))
          vt(npx, 2) = (vc(npx, 2)-0.25*gridstruct%cosa_v(npx, 2)*(ut(&
&           npx, 1)+ut(npx, 2)+ut(npx+1, 2)+uc(npx+1, 1)-0.25*gridstruct&
&           %cosa_u(npx+1, 1)*(vt(npx, 1)+vt(npx+1, 1)+vt(npx+1, 2))))*&
&           damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx-1, 1)*gridstruct%&
&           cosa_v(npx-1, 2))
          ut_tl(npx-1, 1) = damp*(uc_tl(npx-1, 1)-0.25*gridstruct%cosa_u&
&           (npx-1, 1)*(vt_tl(npx-1, 1)+vt_tl(npx-2, 1)+vt_tl(npx-2, 2)+&
&           vc_tl(npx-1, 2)-0.25*gridstruct%cosa_v(npx-1, 2)*(ut_tl(npx&
&           , 1)+ut_tl(npx, 2)+ut_tl(npx-1, 2))))
          ut(npx-1, 1) = (uc(npx-1, 1)-0.25*gridstruct%cosa_u(npx-1, 1)*&
&           (vt(npx-1, 1)+vt(npx-2, 1)+vt(npx-2, 2)+vc(npx-1, 2)-0.25*&
&           gridstruct%cosa_v(npx-1, 2)*(ut(npx, 1)+ut(npx, 2)+ut(npx-1&
&           , 2))))*damp
          vt_tl(npx-1, 2) = damp*(vc_tl(npx-1, 2)-0.25*gridstruct%cosa_v&
&           (npx-1, 2)*(ut_tl(npx, 1)+ut_tl(npx, 2)+ut_tl(npx-1, 2)+&
&           uc_tl(npx-1, 1)-0.25*gridstruct%cosa_u(npx-1, 1)*(vt_tl(npx-&
&           1, 1)+vt_tl(npx-2, 1)+vt_tl(npx-2, 2))))
          vt(npx-1, 2) = (vc(npx-1, 2)-0.25*gridstruct%cosa_v(npx-1, 2)*&
&           (ut(npx, 1)+ut(npx, 2)+ut(npx-1, 2)+uc(npx-1, 1)-0.25*&
&           gridstruct%cosa_u(npx-1, 1)*(vt(npx-1, 1)+vt(npx-2, 1)+vt(&
&           npx-2, 2))))*damp
        END IF
        IF (ne_corner) THEN
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx-1, npy)*gridstruct%&
&           cosa_v(npx-1, npy+1))
          ut_tl(npx-1, npy) = damp*(uc_tl(npx-1, npy)-0.25*gridstruct%&
&           cosa_u(npx-1, npy)*(vt_tl(npx-1, npy)+vt_tl(npx-2, npy)+&
&           vt_tl(npx-2, npy+1)+vc_tl(npx-1, npy+1)-0.25*gridstruct%&
&           cosa_v(npx-1, npy+1)*(ut_tl(npx, npy)+ut_tl(npx, npy+1)+&
&           ut_tl(npx-1, npy+1))))
          ut(npx-1, npy) = (uc(npx-1, npy)-0.25*gridstruct%cosa_u(npx-1&
&           , npy)*(vt(npx-1, npy)+vt(npx-2, npy)+vt(npx-2, npy+1)+vc(&
&           npx-1, npy+1)-0.25*gridstruct%cosa_v(npx-1, npy+1)*(ut(npx, &
&           npy)+ut(npx, npy+1)+ut(npx-1, npy+1))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx+1, npy-1)*&
&           gridstruct%cosa_v(npx, npy-1))
          vt_tl(npx, npy-1) = damp*(vc_tl(npx, npy-1)-0.25*gridstruct%&
&           cosa_v(npx, npy-1)*(ut_tl(npx, npy-1)+ut_tl(npx, npy-2)+&
&           ut_tl(npx+1, npy-2)+uc_tl(npx+1, npy-1)-0.25*gridstruct%&
&           cosa_u(npx+1, npy-1)*(vt_tl(npx, npy)+vt_tl(npx+1, npy)+&
&           vt_tl(npx+1, npy-1))))
          vt(npx, npy-1) = (vc(npx, npy-1)-0.25*gridstruct%cosa_v(npx, &
&           npy-1)*(ut(npx, npy-1)+ut(npx, npy-2)+ut(npx+1, npy-2)+uc(&
&           npx+1, npy-1)-0.25*gridstruct%cosa_u(npx+1, npy-1)*(vt(npx, &
&           npy)+vt(npx+1, npy)+vt(npx+1, npy-1))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx-1, npy-1)*&
&           gridstruct%cosa_v(npx-1, npy-1))
          ut_tl(npx-1, npy-1) = damp*(uc_tl(npx-1, npy-1)-0.25*&
&           gridstruct%cosa_u(npx-1, npy-1)*(vt_tl(npx-1, npy)+vt_tl(npx&
&           -2, npy)+vt_tl(npx-2, npy-1)+vc_tl(npx-1, npy-1)-0.25*&
&           gridstruct%cosa_v(npx-1, npy-1)*(ut_tl(npx, npy-1)+ut_tl(npx&
&           , npy-2)+ut_tl(npx-1, npy-2))))
          ut(npx-1, npy-1) = (uc(npx-1, npy-1)-0.25*gridstruct%cosa_u(&
&           npx-1, npy-1)*(vt(npx-1, npy)+vt(npx-2, npy)+vt(npx-2, npy-1&
&           )+vc(npx-1, npy-1)-0.25*gridstruct%cosa_v(npx-1, npy-1)*(ut(&
&           npx, npy-1)+ut(npx, npy-2)+ut(npx-1, npy-2))))*damp
          vt_tl(npx-1, npy-1) = damp*(vc_tl(npx-1, npy-1)-0.25*&
&           gridstruct%cosa_v(npx-1, npy-1)*(ut_tl(npx, npy-1)+ut_tl(npx&
&           , npy-2)+ut_tl(npx-1, npy-2)+uc_tl(npx-1, npy-1)-0.25*&
&           gridstruct%cosa_u(npx-1, npy-1)*(vt_tl(npx-1, npy)+vt_tl(npx&
&           -2, npy)+vt_tl(npx-2, npy-1))))
          vt(npx-1, npy-1) = (vc(npx-1, npy-1)-0.25*gridstruct%cosa_v(&
&           npx-1, npy-1)*(ut(npx, npy-1)+ut(npx, npy-2)+ut(npx-1, npy-2&
&           )+uc(npx-1, npy-1)-0.25*gridstruct%cosa_u(npx-1, npy-1)*(vt(&
&           npx-1, npy)+vt(npx-2, npy)+vt(npx-2, npy-1))))*damp
        END IF
        IF (nw_corner) THEN
          damp = 1./(1.-0.0625*gridstruct%cosa_u(2, npy)*gridstruct%&
&           cosa_v(1, npy+1))
          ut_tl(2, npy) = damp*(uc_tl(2, npy)-0.25*gridstruct%cosa_u(2, &
&           npy)*(vt_tl(1, npy)+vt_tl(2, npy)+vt_tl(2, npy+1)+vc_tl(1, &
&           npy+1)-0.25*gridstruct%cosa_v(1, npy+1)*(ut_tl(1, npy)+ut_tl&
&           (1, npy+1)+ut_tl(2, npy+1))))
          ut(2, npy) = (uc(2, npy)-0.25*gridstruct%cosa_u(2, npy)*(vt(1&
&           , npy)+vt(2, npy)+vt(2, npy+1)+vc(1, npy+1)-0.25*gridstruct%&
&           cosa_v(1, npy+1)*(ut(1, npy)+ut(1, npy+1)+ut(2, npy+1))))*&
&           damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(0, npy-1)*gridstruct%&
&           cosa_v(0, npy-1))
          vt_tl(0, npy-1) = damp*(vc_tl(0, npy-1)-0.25*gridstruct%cosa_v&
&           (0, npy-1)*(ut_tl(1, npy-1)+ut_tl(1, npy-2)+ut_tl(0, npy-2)+&
&           uc_tl(0, npy-1)-0.25*gridstruct%cosa_u(0, npy-1)*(vt_tl(0, &
&           npy)+vt_tl(-1, npy)+vt_tl(-1, npy-1))))
          vt(0, npy-1) = (vc(0, npy-1)-0.25*gridstruct%cosa_v(0, npy-1)*&
&           (ut(1, npy-1)+ut(1, npy-2)+ut(0, npy-2)+uc(0, npy-1)-0.25*&
&           gridstruct%cosa_u(0, npy-1)*(vt(0, npy)+vt(-1, npy)+vt(-1, &
&           npy-1))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(2, npy-1)*gridstruct%&
&           cosa_v(1, npy-1))
          ut_tl(2, npy-1) = damp*(uc_tl(2, npy-1)-0.25*gridstruct%cosa_u&
&           (2, npy-1)*(vt_tl(1, npy)+vt_tl(2, npy)+vt_tl(2, npy-1)+&
&           vc_tl(1, npy-1)-0.25*gridstruct%cosa_v(1, npy-1)*(ut_tl(1, &
&           npy-1)+ut_tl(1, npy-2)+ut_tl(2, npy-2))))
          ut(2, npy-1) = (uc(2, npy-1)-0.25*gridstruct%cosa_u(2, npy-1)*&
&           (vt(1, npy)+vt(2, npy)+vt(2, npy-1)+vc(1, npy-1)-0.25*&
&           gridstruct%cosa_v(1, npy-1)*(ut(1, npy-1)+ut(1, npy-2)+ut(2&
&           , npy-2))))*damp
          vt_tl(1, npy-1) = damp*(vc_tl(1, npy-1)-0.25*gridstruct%cosa_v&
&           (1, npy-1)*(ut_tl(1, npy-1)+ut_tl(1, npy-2)+ut_tl(2, npy-2)+&
&           uc_tl(2, npy-1)-0.25*gridstruct%cosa_u(2, npy-1)*(vt_tl(1, &
&           npy)+vt_tl(2, npy)+vt_tl(2, npy-1))))
          vt(1, npy-1) = (vc(1, npy-1)-0.25*gridstruct%cosa_v(1, npy-1)*&
&           (ut(1, npy-1)+ut(1, npy-2)+ut(2, npy-2)+uc(2, npy-1)-0.25*&
&           gridstruct%cosa_u(2, npy-1)*(vt(1, npy)+vt(2, npy)+vt(2, npy&
&           -1))))*damp
        END IF
      END IF
    ELSE
      ut_tl = 0.0_FVPRC
! flagstruct%grid_type >= 3
      DO j=jsd,jed
        DO i=is,ie+1
          ut_tl(i, j) = uc_tl(i, j)
          ut(i, j) = uc(i, j)
        END DO
      END DO
      vt_tl = 0.0_FVPRC
      DO j=js,je+1
        DO i=isd,ied
          vt_tl(i, j) = vc_tl(i, j)
          vt(i, j) = vc(i, j)
        END DO
      END DO
    END IF
    DO j=jsd,jed
      DO i=is,ie+1
        xfx_adv_tl(i, j) = dt*ut_tl(i, j)
        xfx_adv(i, j) = dt*ut(i, j)
      END DO
    END DO
    DO j=js,je+1
      DO i=isd,ied
        yfx_adv_tl(i, j) = dt*vt_tl(i, j)
        yfx_adv(i, j) = dt*vt(i, j)
      END DO
    END DO
! Explanation of the following code:
!    xfx_adv = dt*ut*dy   
!    crx_adv = dt*ut/dx
    DO j=jsd,jed
!DEC$ VECTOR ALWAYS
      DO i=is,ie+1
        IF (xfx_adv(i, j) .GT. 0.) THEN
          crx_adv_tl(i, j) = gridstruct%rdxa(i-1, j)*xfx_adv_tl(i, j)
          crx_adv(i, j) = xfx_adv(i, j)*gridstruct%rdxa(i-1, j)
          xfx_adv_tl(i, j) = gridstruct%dy(i, j)*gridstruct%sin_sg(i-1, &
&           j, 3)*xfx_adv_tl(i, j)
          xfx_adv(i, j) = gridstruct%dy(i, j)*xfx_adv(i, j)*gridstruct%&
&           sin_sg(i-1, j, 3)
        ELSE
          crx_adv_tl(i, j) = gridstruct%rdxa(i, j)*xfx_adv_tl(i, j)
          crx_adv(i, j) = xfx_adv(i, j)*gridstruct%rdxa(i, j)
          xfx_adv_tl(i, j) = gridstruct%dy(i, j)*gridstruct%sin_sg(i, j&
&           , 1)*xfx_adv_tl(i, j)
          xfx_adv(i, j) = gridstruct%dy(i, j)*xfx_adv(i, j)*gridstruct%&
&           sin_sg(i, j, 1)
        END IF
      END DO
    END DO
    DO j=js,je+1
!DEC$ VECTOR ALWAYS
      DO i=isd,ied
        IF (yfx_adv(i, j) .GT. 0.) THEN
          cry_adv_tl(i, j) = gridstruct%rdya(i, j-1)*yfx_adv_tl(i, j)
          cry_adv(i, j) = yfx_adv(i, j)*gridstruct%rdya(i, j-1)
          yfx_adv_tl(i, j) = gridstruct%dx(i, j)*gridstruct%sin_sg(i, j-&
&           1, 4)*yfx_adv_tl(i, j)
          yfx_adv(i, j) = gridstruct%dx(i, j)*yfx_adv(i, j)*gridstruct%&
&           sin_sg(i, j-1, 4)
        ELSE
          cry_adv_tl(i, j) = gridstruct%rdya(i, j)*yfx_adv_tl(i, j)
          cry_adv(i, j) = yfx_adv(i, j)*gridstruct%rdya(i, j)
          yfx_adv_tl(i, j) = gridstruct%dx(i, j)*gridstruct%sin_sg(i, j&
&           , 2)*yfx_adv_tl(i, j)
          yfx_adv(i, j) = gridstruct%dx(i, j)*yfx_adv(i, j)*gridstruct%&
&           sin_sg(i, j, 2)
        END IF
      END DO
    END DO
    ra_x_tl = 0.0_FVPRC
!#ifdef SW_DYNAMICS
!      endif
!#endif
    DO j=jsd,jed
      DO i=is,ie
        ra_x_tl(i, j) = xfx_adv_tl(i, j) - xfx_adv_tl(i+1, j)
        ra_x(i, j) = gridstruct%area(i, j) + xfx_adv(i, j) - xfx_adv(i+1&
&         , j)
      END DO
    END DO
    ra_y_tl = 0.0_FVPRC
    DO j=js,je
      DO i=isd,ied
        ra_y_tl(i, j) = yfx_adv_tl(i, j) - yfx_adv_tl(i, j+1)
        ra_y(i, j) = gridstruct%area(i, j) + yfx_adv(i, j) - yfx_adv(i, &
&         j+1)
      END DO
    END DO
    IF (hord_dp .EQ. hord_dp_pert .AND. (.NOT.split_damp)) THEN
      fy_tl = 0.0_FVPRC
      fx_tl = 0.0_FVPRC
      CALL FV_TP_2D_TLM(delp, delp_tl, crx_adv, crx_adv_tl, cry_adv, &
&                    cry_adv_tl, npx, npy, hord_dp, fx, fx_tl, fy, fy_tl&
&                    , xfx_adv, xfx_adv_tl, yfx_adv, yfx_adv_tl, &
&                    gridstruct, bd, ra_x, ra_x_tl, ra_y, ra_y_tl, nord=&
&                    nord_v, damp_c=damp_v)
    ELSE
      delp_tj = delp
      fx_tj = fx
      fy_tj = fy
      call fv_tp_2d(delp, crx_adv, cry_adv, npx, npy, hord_dp, fx, fy,  &
                    xfx_adv,yfx_adv, gridstruct, bd, ra_x, ra_y, nord=nord_v, damp_c=damp_v)
      fy_tl = 0.0_FVPRC
      fx_tl = 0.0_FVPRC
      CALL FV_TP_2D_TLM(delp, delp_tl, crx_adv, crx_adv_tl, cry_adv, &
&                 cry_adv_tl, npx, npy, hord_dp_pert, fx, fx_tl, fy, &
&                 fy_tl, xfx_adv, xfx_adv_tl, yfx_adv, yfx_adv_tl, &
&                 gridstruct, bd, ra_x, ra_x_tl, ra_y, ra_y_tl, nord=&
&                 nord_v_pert, damp_c=damp_v_pert)
    END IF
!#ifdef SW_DYNAMICS
!        do j=js,je
!           do i=is,ie
!              delp(i,j) = delp(i,j) +    &
!                         (fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*gridstruct%rarea(i,j)
!              ptc(i,j) = pt(i,j)
!           enddo
!        enddo
!#else
! <<< Save the mass fluxes to the "Flux Capacitor" for tracer transport >>>
    DO j=jsd,jed
      DO i=is,ie+1
        cx_tl(i, j) = cx_tl(i, j) + crx_adv_tl(i, j)
        cx(i, j) = cx(i, j) + crx_adv(i, j)
      END DO
    END DO
    DO j=js,je
      DO i=is,ie+1
        xflux_tl(i, j) = xflux_tl(i, j) + fx_tl(i, j)
        xflux(i, j) = xflux(i, j) + fx(i, j)
      END DO
    END DO
    DO j=js,je+1
      DO i=isd,ied
        cy_tl(i, j) = cy_tl(i, j) + cry_adv_tl(i, j)
        cy(i, j) = cy(i, j) + cry_adv(i, j)
      END DO
      DO i=is,ie
        yflux_tl(i, j) = yflux_tl(i, j) + fy_tl(i, j)
        yflux(i, j) = yflux(i, j) + fy(i, j)
      END DO
    END DO
    DO j=js,je
      DO i=is,ie
        heat_source_tl(i, j) = 0.0_FVPRC
        heat_source(i, j) = 0.
      END DO
    END DO
    IF (.NOT.hydrostatic) THEN
      IF (damp_w .GT. 1.e-5) THEN
        pwx1 = damp_w*da_min_c
        pwy1 = nord_w + 1
        damp4 = pwx1**pwy1
        fy2_tl = 0.0_FVPRC
        fx2_tl = 0.0_FVPRC
        wk_tl = 0.0_FVPRC
        CALL DEL6_VT_FLUX_TLM(nord_w, npx, npy, damp4, w, w_tl, wk, &
&                       wk_tl, fx2, fx2_tl, fy2, fy2_tl, gridstruct, bd)
        dw_tl = 0.0_FVPRC
        DO j=js,je
          DO i=is,ie
            dw_tl(i, j) = gridstruct%rarea(i, j)*(fx2_tl(i, j)-fx2_tl(i+&
&             1, j)+fy2_tl(i, j)-fy2_tl(i, j+1))
            dw(i, j) = (fx2(i, j)-fx2(i+1, j)+fy2(i, j)-fy2(i, j+1))*&
&             gridstruct%rarea(i, j)
! 0.5 * [ (w+dw)**2 - w**2 ] = w*dw + 0.5*dw*dw
!                   heat_source(i,j) = -d_con*dw(i,j)*(w(i,j)+0.5*dw(i,j))
            heat_source_tl(i, j) = -(dw_tl(i, j)*(w(i, j)+0.5*dw(i, j))+&
&             dw(i, j)*(w_tl(i, j)+0.5*dw_tl(i, j)))
            heat_source(i, j) = -(dw(i, j)*(w(i, j)+0.5*dw(i, j)))
          END DO
        END DO
      ELSE
        dw_tl = 0.0_FVPRC
        wk_tl = 0.0_FVPRC
      END IF
      IF (hord_vt .EQ. hord_vt_pert) THEN
        gy_tl = 0.0_FVPRC
        gx_tl = 0.0_FVPRC
        CALL FV_TP_2D_TLM(w, w_tl, crx_adv, crx_adv_tl, cry_adv, &
&                      cry_adv_tl, npx, npy, hord_vt, gx, gx_tl, gy, &
&                      gy_tl, xfx_adv, xfx_adv_tl, yfx_adv, yfx_adv_tl, &
&                      gridstruct, bd, ra_x, ra_x_tl, ra_y, ra_y_tl, mfx&
&                      =fx, mfx_tl=fx_tl, mfy=fy, mfy_tl=fy_tl)
      ELSE
        w_tj = w
        gx_tj = gx
        gy_tj = gy
        call fv_tp_2d(w, crx_adv,cry_adv, npx, npy, hord_vt, gx, gy, xfx_adv, yfx_adv, &
                      gridstruct, bd, ra_x, ra_y, mfx=fx, mfy=fy)
        gy_tl = 0.0_FVPRC
        gx_tl = 0.0_FVPRC
        CALL FV_TP_2D_TLM(w, w_tl, crx_adv, crx_adv_tl, cry_adv, &
&                   cry_adv_tl, npx, npy, hord_vt_pert, gx, gx_tl, gy, &
&                   gy_tl, xfx_adv, xfx_adv_tl, yfx_adv, yfx_adv_tl, &
&                   gridstruct, bd, ra_x, ra_x_tl, ra_y, ra_y_tl, mfx=fx&
&                   , mfx_tl=fx_tl, mfy=fy, mfy_tl=fy_tl)
      END IF
      DO j=js,je
        DO i=is,ie
          w_tl(i, j) = delp_tl(i, j)*w(i, j) + delp(i, j)*w_tl(i, j) + &
&           gridstruct%rarea(i, j)*(gx_tl(i, j)-gx_tl(i+1, j)+gy_tl(i, j&
&           )-gy_tl(i, j+1))
          w(i, j) = delp(i, j)*w(i, j) + (gx(i, j)-gx(i+1, j)+gy(i, j)-&
&           gy(i, j+1))*gridstruct%rarea(i, j)
        END DO
      END DO
    ELSE
      gx_tl = 0.0_FVPRC
      gy_tl = 0.0_FVPRC
      dw_tl = 0.0_FVPRC
      wk_tl = 0.0_FVPRC
    END IF
!#ifdef USE_COND
!           call fv_tp_2d(q_con, crx_adv,cry_adv, npx, npy, hord_dp, gx, gy,  &
!                xfx_adv,yfx_adv, gridstruct, bd, ra_x, ra_y, mfx=fx, mfy=fy, mass=delp, nord=nord_t, damp_c=damp_t)
!            do j=js,je
!               do i=is,ie
!                  q_con(i,j) = delp(i,j)*q_con(i,j) + (gx(i,j)-gx(i+1,j)+gy(i,j)-gy(i,j+1))*gridstruct%rarea(i,j)
!               enddo
!            enddo
!#endif
    IF (inline_q) THEN
      DO j=jsd,jed
        DO i=isd,ied
          pt_tl(i, j) = (pt_tl(i, j)*(1.+zvir*q(i, j, k, sphum))-pt(i, j&
&           )*zvir*q_tl(i, j, k, sphum))/(1.+zvir*q(i, j, k, sphum))**2
          pt(i, j) = pt(i, j)/(1.+zvir*q(i, j, k, sphum))
        END DO
      END DO
    END IF
    IF (hord_tm .EQ. hord_tm_pert .AND. (.NOT.split_damp)) THEN
      CALL FV_TP_2D_TLM(pt, pt_tl, crx_adv, crx_adv_tl, cry_adv, &
&                    cry_adv_tl, npx, npy, hord_tm, gx, gx_tl, gy, gy_tl&
&                    , xfx_adv, xfx_adv_tl, yfx_adv, yfx_adv_tl, &
&                    gridstruct, bd, ra_x, ra_x_tl, ra_y, ra_y_tl, mfx=&
&                    fx, mfx_tl=fx_tl, mfy=fy, mfy_tl=fy_tl, mass=delp, &
&                    mass_tl=delp_tl, nord=nord_t, damp_c=damp_t)
    ELSE
      pt_tj = pt
      gx_tj = gx
      gy_tj = gy
      call fv_tp_2d(pt, crx_adv,cry_adv, npx, npy, hord_tm, gx, gy,  &
                    xfx_adv,yfx_adv, gridstruct, bd, ra_x, ra_y,     &
                    mfx=fx, mfy=fy, mass=delp, nord=nord_t, damp_c=damp_t)
      CALL FV_TP_2D_TLM(pt, pt_tl, crx_adv, crx_adv_tl, cry_adv, &
&                 cry_adv_tl, npx, npy, hord_tm_pert, gx, gx_tl, gy, &
&                 gy_tl, xfx_adv, xfx_adv_tl, yfx_adv, yfx_adv_tl, &
&                 gridstruct, bd, ra_x, ra_x_tl, ra_y, ra_y_tl, mfx=fx, &
&                 mfx_tl=fx_tl, mfy=fy, mfy_tl=fy_tl, mass=delp, mass_tl&
&                 =delp_tl, nord=nord_t_pert, damp_c=damp_t_pert)
    END IF
    IF (inline_q) THEN
      DO j=js,je
        DO i=is,ie
          wk_tl(i, j) = delp_tl(i, j)
          wk(i, j) = delp(i, j)
          delp_tl(i, j) = wk_tl(i, j) + gridstruct%rarea(i, j)*(fx_tl(i&
&           , j)-fx_tl(i+1, j)+fy_tl(i, j)-fy_tl(i, j+1))
          delp(i, j) = wk(i, j) + (fx(i, j)-fx(i+1, j)+fy(i, j)-fy(i, j+&
&           1))*gridstruct%rarea(i, j)
          pt_tl(i, j) = ((pt_tl(i, j)*wk(i, j)+pt(i, j)*wk_tl(i, j)+&
&           gridstruct%rarea(i, j)*(gx_tl(i, j)-gx_tl(i+1, j)+gy_tl(i, j&
&           )-gy_tl(i, j+1)))*delp(i, j)-(pt(i, j)*wk(i, j)+(gx(i, j)-gx&
&           (i+1, j)+gy(i, j)-gy(i, j+1))*gridstruct%rarea(i, j))*&
&           delp_tl(i, j))/delp(i, j)**2
          pt(i, j) = (pt(i, j)*wk(i, j)+(gx(i, j)-gx(i+1, j)+gy(i, j)-gy&
&           (i, j+1))*gridstruct%rarea(i, j))/delp(i, j)
        END DO
      END DO
      DO iq=1,nq
        IF (hord_tr .EQ. hord_tr_pert) THEN
          CALL FV_TP_2D_TLM(q(isd:ied, jsd:jed, k, iq), q_tl(isd:ied&
&                        , jsd:jed, k, iq), crx_adv, crx_adv_tl, cry_adv&
&                        , cry_adv_tl, npx, npy, hord_tr, gx, gx_tl, gy&
&                        , gy_tl, xfx_adv, xfx_adv_tl, yfx_adv, &
&                        yfx_adv_tl, gridstruct, bd, ra_x, ra_x_tl, ra_y&
&                        , ra_y_tl, mfx=fx, mfx_tl=fx_tl, mfy=fy, mfy_tl&
&                        =fy_tl)
        ELSE
          q_tj(:, :, :, iq) = q(:, :, :, iq)
          gx_tj = gx
          gy_tj = gy
          call fv_tp_2d(q(isd:ied,jsd:ied,k,iq), crx_adv,cry_adv, npx, npy, hord_tr, gx, gy,  &
                        xfx_adv,yfx_adv, gridstruct, bd, ra_x, ra_y, mfx=fx, mfy=fy)
          CALL FV_TP_2D_TLM(q(isd:ied, jsd:ied, k, iq), q_tl(isd:ied, &
&                     jsd:ied, k, iq), crx_adv, crx_adv_tl, cry_adv, &
&                     cry_adv_tl, npx, npy, hord_tr_pert, gx, gx_tl, gy&
&                     , gy_tl, xfx_adv, xfx_adv_tl, yfx_adv, yfx_adv_tl&
&                     , gridstruct, bd, ra_x, ra_x_tl, ra_y, ra_y_tl, &
&                     mfx=fx, mfx_tl=fx_tl, mfy=fy, mfy_tl=fy_tl)
        END IF
        DO j=js,je
          DO i=is,ie
            q_tl(i, j, k, iq) = ((q_tl(i, j, k, iq)*wk(i, j)+q(i, j, k, &
&             iq)*wk_tl(i, j)+gridstruct%rarea(i, j)*(gx_tl(i, j)-gx_tl(&
&             i+1, j)+gy_tl(i, j)-gy_tl(i, j+1)))*delp(i, j)-(q(i, j, k&
&             , iq)*wk(i, j)+(gx(i, j)-gx(i+1, j)+gy(i, j)-gy(i, j+1))*&
&             gridstruct%rarea(i, j))*delp_tl(i, j))/delp(i, j)**2
            q(i, j, k, iq) = (q(i, j, k, iq)*wk(i, j)+(gx(i, j)-gx(i+1, &
&             j)+gy(i, j)-gy(i, j+1))*gridstruct%rarea(i, j))/delp(i, j)
          END DO
        END DO
      END DO
      DO j=js,je
        DO i=is,ie
          pt_tl(i, j) = pt_tl(i, j)*(1.+zvir*q(i, j, k, sphum)) + pt(i, &
&           j)*zvir*q_tl(i, j, k, sphum)
          pt(i, j) = pt(i, j)*(1.+zvir*q(i, j, k, sphum))
        END DO
      END DO
    ELSE
      DO j=js,je
        DO i=is,ie
          pt_tl(i, j) = pt_tl(i, j)*delp(i, j) + pt(i, j)*delp_tl(i, j) &
&           + gridstruct%rarea(i, j)*(gx_tl(i, j)-gx_tl(i+1, j)+gy_tl(i&
&           , j)-gy_tl(i, j+1))
          pt(i, j) = pt(i, j)*delp(i, j) + (gx(i, j)-gx(i+1, j)+gy(i, j)&
&           -gy(i, j+1))*gridstruct%rarea(i, j)
          delp_tl(i, j) = delp_tl(i, j) + gridstruct%rarea(i, j)*(fx_tl(&
&           i, j)-fx_tl(i+1, j)+fy_tl(i, j)-fy_tl(i, j+1))
          delp(i, j) = delp(i, j) + (fx(i, j)-fx(i+1, j)+fy(i, j)-fy(i, &
&           j+1))*gridstruct%rarea(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie
          pt_tl(i, j) = (pt_tl(i, j)*delp(i, j)-pt(i, j)*delp_tl(i, j))/&
&           delp(i, j)**2
          pt(i, j) = pt(i, j)/delp(i, j)
        END DO
      END DO
    END IF
!#endif
!#ifdef SW_DYNAMICS
!      if (test_case > 1) then
!#endif
!----------------------
! Kinetic Energy Fluxes
!----------------------
! Compute B grid contra-variant components for KE:
    dt5 = 0.5*dt
    dt4 = 0.25*dt
    IF (nested) THEN
      is2 = is
      ie1 = ie + 1
      js2 = js
      je1 = je + 1
    ELSE
      IF (2 .LT. is) THEN
        is2 = is
      ELSE
        is2 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        ie1 = ie + 1
      ELSE
        ie1 = npx - 1
      END IF
      IF (2 .LT. js) THEN
        js2 = js
      ELSE
        js2 = 2
      END IF
      IF (npy - 1 .GT. je + 1) THEN
        je1 = je + 1
      ELSE
        je1 = npy - 1
      END IF
    END IF
!!! TO DO: separate versions for nested and for cubed-sphere
    IF (flagstruct%grid_type .LT. 3) THEN
      IF (nested) THEN
        vb_tl = 0.0_FVPRC
        DO j=js2,je1
          DO i=is2,ie1
            vb_tl(i, j) = dt5*gridstruct%rsina(i, j)*(vc_tl(i-1, j)+&
&             vc_tl(i, j)-gridstruct%cosa(i, j)*(uc_tl(i, j-1)+uc_tl(i, &
&             j)))
            vb(i, j) = dt5*(vc(i-1, j)+vc(i, j)-(uc(i, j-1)+uc(i, j))*&
&             gridstruct%cosa(i, j))*gridstruct%rsina(i, j)
          END DO
        END DO
      ELSE
        IF (js .EQ. 1) THEN
          vb_tl = 0.0_FVPRC
          DO i=is,ie+1
! corner values are incorrect
            vb_tl(i, 1) = dt5*(vt_tl(i-1, 1)+vt_tl(i, 1))
            vb(i, 1) = dt5*(vt(i-1, 1)+vt(i, 1))
          END DO
        ELSE
          vb_tl = 0.0_FVPRC
        END IF
        DO j=js2,je1
          DO i=is2,ie1
            vb_tl(i, j) = dt5*gridstruct%rsina(i, j)*(vc_tl(i-1, j)+&
&             vc_tl(i, j)-gridstruct%cosa(i, j)*(uc_tl(i, j-1)+uc_tl(i, &
&             j)))
            vb(i, j) = dt5*(vc(i-1, j)+vc(i, j)-(uc(i, j-1)+uc(i, j))*&
&             gridstruct%cosa(i, j))*gridstruct%rsina(i, j)
          END DO
          IF (is .EQ. 1) THEN
! 2-pt extrapolation from both sides:
            vb_tl(1, j) = dt4*(3.*(vt_tl(0, j)+vt_tl(1, j))-vt_tl(-1, j)&
&             -vt_tl(2, j))
            vb(1, j) = dt4*(-vt(-1, j)+3.*(vt(0, j)+vt(1, j))-vt(2, j))
          END IF
          IF (ie + 1 .EQ. npx) THEN
! 2-pt extrapolation from both sides:
            vb_tl(npx, j) = dt4*(3.*(vt_tl(npx-1, j)+vt_tl(npx, j))-&
&             vt_tl(npx-2, j)-vt_tl(npx+1, j))
            vb(npx, j) = dt4*(-vt(npx-2, j)+3.*(vt(npx-1, j)+vt(npx, j))&
&             -vt(npx+1, j))
          END IF
        END DO
        IF (je + 1 .EQ. npy) THEN
          DO i=is,ie+1
! corner values are incorrect
            vb_tl(i, npy) = dt5*(vt_tl(i-1, npy)+vt_tl(i, npy))
            vb(i, npy) = dt5*(vt(i-1, npy)+vt(i, npy))
          END DO
        END IF
      END IF
    ELSE
      vb_tl = 0.0_FVPRC
      DO j=js,je+1
        DO i=is,ie+1
          vb_tl(i, j) = dt5*(vc_tl(i-1, j)+vc_tl(i, j))
          vb(i, j) = dt5*(vc(i-1, j)+vc(i, j))
        END DO
      END DO
    END IF
    IF (hord_mt .EQ. hord_mt_pert) THEN
      CALL YTP_V_TLM(vb, vb_tl, u, v, v_tl, ub, ub_tl, hord_mt, &
&                 gridstruct%cosa, gridstruct%dy, gridstruct%rdy, bd, &
&                 npx, npy, flagstruct%grid_type, nested)
      ke_tl = 0.0_FVPRC
    ELSE
      ub_tj = ub
      call ytp_v(vb, u, v, ub, hord_mt, gridstruct%cosa, gridstruct%dy, gridstruct%rdy, &
           bd, npx, npy, flagstruct%grid_type, nested)
      CALL YTP_V_TLM(vb, vb_tl, u, v, v_tl, ub, ub_tl, hord_mt_pert, &
&              gridstruct%cosa, gridstruct%dy, gridstruct%rdy, bd, npx, &
&              npy, flagstruct%grid_type, nested)
      ke_tl = 0.0_FVPRC
    END IF
    DO j=js,je+1
      DO i=is,ie+1
        ke_tl(i, j) = vb_tl(i, j)*ub(i, j) + vb(i, j)*ub_tl(i, j)
        ke(i, j) = vb(i, j)*ub(i, j)
      END DO
    END DO
    IF (flagstruct%grid_type .LT. 3) THEN
      IF (nested) THEN
        DO j=js,je+1
          DO i=is2,ie1
            ub_tl(i, j) = dt5*gridstruct%rsina(i, j)*(uc_tl(i, j-1)+&
&             uc_tl(i, j)-gridstruct%cosa(i, j)*(vc_tl(i-1, j)+vc_tl(i, &
&             j)))
            ub(i, j) = dt5*(uc(i, j-1)+uc(i, j)-(vc(i-1, j)+vc(i, j))*&
&             gridstruct%cosa(i, j))*gridstruct%rsina(i, j)
          END DO
        END DO
      ELSE
        IF (is .EQ. 1) THEN
          DO j=js,je+1
! corner values are incorrect
            ub_tl(1, j) = dt5*(ut_tl(1, j-1)+ut_tl(1, j))
            ub(1, j) = dt5*(ut(1, j-1)+ut(1, j))
          END DO
        END IF
        DO j=js,je+1
          IF (j .EQ. 1 .OR. j .EQ. npy) THEN
            DO i=is2,ie1
! 2-pt extrapolation from both sides:
              ub_tl(i, j) = dt4*(3.*(ut_tl(i, j-1)+ut_tl(i, j))-ut_tl(i&
&               , j-2)-ut_tl(i, j+1))
              ub(i, j) = dt4*(-ut(i, j-2)+3.*(ut(i, j-1)+ut(i, j))-ut(i&
&               , j+1))
            END DO
          ELSE
            DO i=is2,ie1
              ub_tl(i, j) = dt5*gridstruct%rsina(i, j)*(uc_tl(i, j-1)+&
&               uc_tl(i, j)-gridstruct%cosa(i, j)*(vc_tl(i-1, j)+vc_tl(i&
&               , j)))
              ub(i, j) = dt5*(uc(i, j-1)+uc(i, j)-(vc(i-1, j)+vc(i, j))*&
&               gridstruct%cosa(i, j))*gridstruct%rsina(i, j)
            END DO
          END IF
        END DO
        IF (ie + 1 .EQ. npx) THEN
          DO j=js,je+1
! corner values are incorrect
            ub_tl(npx, j) = dt5*(ut_tl(npx, j-1)+ut_tl(npx, j))
            ub(npx, j) = dt5*(ut(npx, j-1)+ut(npx, j))
          END DO
        END IF
      END IF
    ELSE
      DO j=js,je+1
        DO i=is,ie+1
          ub_tl(i, j) = dt5*(uc_tl(i, j-1)+uc_tl(i, j))
          ub(i, j) = dt5*(uc(i, j-1)+uc(i, j))
        END DO
      END DO
    END IF
    IF (hord_mt .EQ. hord_mt_pert) THEN
      CALL XTP_U_TLM(ub, ub_tl, u, u_tl, v, vb, vb_tl, hord_mt, &
&                 gridstruct%cosa, gridstruct%dx, gridstruct%rdx, bd, &
&                 npx, npy, flagstruct%grid_type, nested)
    ELSE
      vb_tj = vb
      call xtp_u(ub, u, v, vb, hord_mt, gridstruct%cosa, gridstruct%dx, gridstruct%rdx, &
           bd, npx, npy, flagstruct%grid_type, nested)
      CALL XTP_U_TLM(ub, ub_tl, u, u_tl, v, vb, vb_tl, hord_mt_pert, &
&              gridstruct%cosa, gridstruct%dx, gridstruct%rdx, bd, npx, &
&              npy, flagstruct%grid_type, nested)
    END IF
    DO j=js,je+1
      DO i=is,ie+1
        ke_tl(i, j) = 0.5*(ke_tl(i, j)+ub_tl(i, j)*vb(i, j)+ub(i, j)*&
&         vb_tl(i, j))
        ke(i, j) = 0.5*(ke(i, j)+ub(i, j)*vb(i, j))
      END DO
    END DO
!-----------------------------------------
! Fix KE at the 4 corners of the face:
!-----------------------------------------
    IF (.NOT.nested) THEN
      dt6 = dt/6.
      IF (sw_corner) THEN
        ke_tl(1, 1) = dt6*((ut_tl(1, 1)+ut_tl(1, 0))*u(1, 1)+(ut(1, 1)+&
&         ut(1, 0))*u_tl(1, 1)+(vt_tl(1, 1)+vt_tl(0, 1))*v(1, 1)+(vt(1, &
&         1)+vt(0, 1))*v_tl(1, 1)+(ut_tl(1, 1)+vt_tl(1, 1))*u(0, 1)+(ut(&
&         1, 1)+vt(1, 1))*u_tl(0, 1))
        ke(1, 1) = dt6*((ut(1, 1)+ut(1, 0))*u(1, 1)+(vt(1, 1)+vt(0, 1))*&
&         v(1, 1)+(ut(1, 1)+vt(1, 1))*u(0, 1))
      END IF
      IF (se_corner) THEN
        i = npx
        ke_tl(i, 1) = dt6*((ut_tl(i, 1)+ut_tl(i, 0))*u(i-1, 1)+(ut(i, 1)&
&         +ut(i, 0))*u_tl(i-1, 1)+(vt_tl(i, 1)+vt_tl(i-1, 1))*v(i, 1)+(&
&         vt(i, 1)+vt(i-1, 1))*v_tl(i, 1)+(ut_tl(i, 1)-vt_tl(i-1, 1))*u(&
&         i, 1)+(ut(i, 1)-vt(i-1, 1))*u_tl(i, 1))
        ke(i, 1) = dt6*((ut(i, 1)+ut(i, 0))*u(i-1, 1)+(vt(i, 1)+vt(i-1, &
&         1))*v(i, 1)+(ut(i, 1)-vt(i-1, 1))*u(i, 1))
      END IF
      IF (ne_corner) THEN
        i = npx
        j = npy
        ke_tl(i, j) = dt6*((ut_tl(i, j)+ut_tl(i, j-1))*u(i-1, j)+(ut(i, &
&         j)+ut(i, j-1))*u_tl(i-1, j)+(vt_tl(i, j)+vt_tl(i-1, j))*v(i, j&
&         -1)+(vt(i, j)+vt(i-1, j))*v_tl(i, j-1)+(ut_tl(i, j-1)+vt_tl(i-&
&         1, j))*u(i, j)+(ut(i, j-1)+vt(i-1, j))*u_tl(i, j))
        ke(i, j) = dt6*((ut(i, j)+ut(i, j-1))*u(i-1, j)+(vt(i, j)+vt(i-1&
&         , j))*v(i, j-1)+(ut(i, j-1)+vt(i-1, j))*u(i, j))
      END IF
      IF (nw_corner) THEN
        j = npy
        ke_tl(1, j) = dt6*((ut_tl(1, j)+ut_tl(1, j-1))*u(1, j)+(ut(1, j)&
&         +ut(1, j-1))*u_tl(1, j)+(vt_tl(1, j)+vt_tl(0, j))*v(1, j-1)+(&
&         vt(1, j)+vt(0, j))*v_tl(1, j-1)+(ut_tl(1, j-1)-vt_tl(1, j))*u(&
&         0, j)+(ut(1, j-1)-vt(1, j))*u_tl(0, j))
        ke(1, j) = dt6*((ut(1, j)+ut(1, j-1))*u(1, j)+(vt(1, j)+vt(0, j)&
&         )*v(1, j-1)+(ut(1, j-1)-vt(1, j))*u(0, j))
      END IF
    END IF
! Compute vorticity:
    DO j=jsd,jed+1
      DO i=isd,ied
        vt_tl(i, j) = gridstruct%dx(i, j)*u_tl(i, j)
        vt(i, j) = u(i, j)*gridstruct%dx(i, j)
      END DO
    END DO
    DO j=jsd,jed
      DO i=isd,ied+1
        ut_tl(i, j) = gridstruct%dy(i, j)*v_tl(i, j)
        ut(i, j) = v(i, j)*gridstruct%dy(i, j)
      END DO
    END DO
! wk is "volume-mean" relative vorticity
    DO j=jsd,jed
      DO i=isd,ied
        wk_tl(i, j) = gridstruct%rarea(i, j)*(vt_tl(i, j)-vt_tl(i, j+1)-&
&         ut_tl(i, j)+ut_tl(i+1, j))
        wk(i, j) = gridstruct%rarea(i, j)*(vt(i, j)-vt(i, j+1)-ut(i, j)+&
&         ut(i+1, j))
      END DO
    END DO
    IF (.NOT.hydrostatic) THEN
      IF (.NOT.flagstruct%do_f3d) THEN
!#ifdef ROT3
!            dt2 = 2.*dt
!            do j=js,je
!               do i=is,ie
!                  w(i,j) = w(i,j)/delp(i,j) + dt2*gridstruct%w00(i,j) *  &
!                         ( gridstruct%a11(i,j)*(u(i,j)+u(i,j+1)) +       &
!                           gridstruct%a12(i,j)*(v(i,j)+v(i+1,j)) )
!               enddo
!            enddo
!#endif
        DO j=js,je
          DO i=is,ie
            w_tl(i, j) = (w_tl(i, j)*delp(i, j)-w(i, j)*delp_tl(i, j))/&
&             delp(i, j)**2
            w(i, j) = w(i, j)/delp(i, j)
          END DO
        END DO
      END IF
      IF (damp_w .GT. 1.e-5) THEN
        DO j=js,je
          DO i=is,ie
            w_tl(i, j) = w_tl(i, j) + dw_tl(i, j)
            w(i, j) = w(i, j) + dw(i, j)
          END DO
        END DO
      END IF
    END IF
!#ifdef USE_COND
!     do j=js,je
!        do i=is,ie
!           q_con(i,j) = q_con(i,j)/delp(i,j)
!        enddo
!     enddo
!#endif
!-----------------------------
! Compute divergence damping
!-----------------------------
!  damp = dddmp * da_min_c
    IF (.NOT.split_damp) THEN
      CALL COMPUTE_DIV_DAMPING_TLM(nord, d2_bg, d4_bg, dddmp, dt, &
&                               vort, vort_tl, ptc, ptc_tl, delpc, &
&                               delpc_tl, ke, ke_tl, u, u_tl, v, v_tl, &
&                               uc, uc_tl, vc, vc_tl, ua, ua_tl, va, &
&                               va_tl, divg_d, divg_d_tl, wk, wk_tl, &
&                               gridstruct, flagstruct, bd)
    ELSE
      delpc_tj = 0.0
      ptc_tj = ptc
      vort_tj = 0.0
      delpc_tj = delpc
      ke_tj = ke
      u_tj = u
      uc_tj = uc
      v_tj = v
      vc_tj = vc
      ua_tj = ua
      va_tj = va
      divg_d_tj = divg_d
      wk_tj = wk
      call compute_div_damping( nord,d2_bg,d4_bg,dddmp,dt, &
                                vort,ptc,delpc,ke,u,v,uc,vc,ua,va,divg_d,wk, &
                                gridstruct, flagstruct, bd)
      CALL COMPUTE_DIV_DAMPING_TLM(nord_pert, d2_bg_pert, d4_bg_pert, &
&                            dddmp_pert, dt, vort, vort_tl, ptc, ptc_tl&
&                            , delpc, delpc_tl, ke, ke_tl, u, u_tl, v, &
&                            v_tl, uc, uc_tl, vc, vc_tl, ua, ua_tl, va, &
&                            va_tl, divg_d, divg_d_tl, wk, wk_tl, &
&                            gridstruct, flagstruct, bd)
    END IF
    IF (d_con .GT. 1.e-5) THEN
      DO j=js,je+1
        DO i=is,ie
          ub_tl(i, j) = vort_tl(i, j) - vort_tl(i+1, j)
          ub(i, j) = vort(i, j) - vort(i+1, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          vb_tl(i, j) = vort_tl(i, j) - vort_tl(i, j+1)
          vb(i, j) = vort(i, j) - vort(i, j+1)
        END DO
      END DO
    END IF
! Vorticity transport
    IF (hydrostatic) THEN
      DO j=jsd,jed
        DO i=isd,ied
          vort_tl(i, j) = wk_tl(i, j)
          vort(i, j) = wk(i, j) + gridstruct%f0(i, j)
        END DO
      END DO
    ELSE IF (flagstruct%do_f3d) THEN
      DO j=jsd,jed
        DO i=isd,ied
          vort_tl(i, j) = wk_tl(i, j) + gridstruct%f0(i, j)*z_rat_tl(i, &
&           j)
          vort(i, j) = wk(i, j) + gridstruct%f0(i, j)*z_rat(i, j)
        END DO
      END DO
    ELSE
      DO j=jsd,jed
        DO i=isd,ied
          vort_tl(i, j) = wk_tl(i, j)
          vort(i, j) = wk(i, j) + gridstruct%f0(i, j)
        END DO
      END DO
    END IF
    IF (hord_vt .EQ. hord_vt_pert) THEN
      CALL FV_TP_2D_TLM(vort, vort_tl, crx_adv, crx_adv_tl, cry_adv, &
&                    cry_adv_tl, npx, npy, hord_vt, fx, fx_tl, fy, fy_tl&
&                    , xfx_adv, xfx_adv_tl, yfx_adv, yfx_adv_tl, &
&                    gridstruct, bd, ra_x, ra_x_tl, ra_y, ra_y_tl)
    ELSE
      vort_tj = vort
      fx_tj = fx
      fy_tj = fy
      call fv_tp_2d(vort, crx_adv, cry_adv, npx, npy, hord_vt, fx, fy, &
                    xfx_adv,yfx_adv, gridstruct, bd, ra_x, ra_y)
      CALL FV_TP_2D_TLM(vort, vort_tl, crx_adv, crx_adv_tl, cry_adv, &
&                 cry_adv_tl, npx, npy, hord_vt_pert, fx, fx_tl, fy, &
&                 fy_tl, xfx_adv, xfx_adv_tl, yfx_adv, yfx_adv_tl, &
&                 gridstruct, bd, ra_x, ra_x_tl, ra_y, ra_y_tl)
    END IF
    DO j=js,je+1
      DO i=is,ie
        u_tl(i, j) = vt_tl(i, j) + ke_tl(i, j) - ke_tl(i+1, j) + fy_tl(i&
&         , j)
        u(i, j) = vt(i, j) + ke(i, j) - ke(i+1, j) + fy(i, j)
      END DO
    END DO
    DO j=js,je
      DO i=is,ie+1
        v_tl(i, j) = ut_tl(i, j) + ke_tl(i, j) - ke_tl(i, j+1) - fx_tl(i&
&         , j)
        v(i, j) = ut(i, j) + ke(i, j) - ke(i, j+1) - fx(i, j)
      END DO
    END DO
!--------------------------------------------------------
! damping applied to relative vorticity (wk):
    IF (damp_v .GT. 1.e-5) THEN
      pwx1 = damp_v*da_min_c
      pwy1 = nord_v + 1
      damp4 = pwx1**pwy1
      call del6_vt_flux(nord_v, npx, npy, damp4, wk, vort, ut, vt, gridstruct, bd)
      CALL DEL6_VT_FLUX_TLM(nord_v, npx, npy, damp4, wk, wk_tl, vort, &
&                     vort_tl, ut, ut_tl, vt, vt_tl, gridstruct, bd)
    END IF
    IF (damp_v_pert .GT. 1.e-5) THEN
      wk_tj = wk
      vort_tj = vort
      ut_tj = ut
      vt_tj = vt
      pwx1 = damp_v_pert*da_min_c
      pwy1 = nord_v_pert + 1
      damp4_pert = pwx1**pwy1
      CALL DEL6_VT_FLUX_TLM(nord_v_pert, npx, npy, damp4_pert, wk, wk_tl&
&                     , vort, vort_tl, ut, ut_tl, vt, vt_tl, gridstruct&
&                     , bd)
    END IF
    IF (d_con .GT. 1.e-5) THEN
      DO j=js,je+1
        DO i=is,ie
          ub_tl(i, j) = gridstruct%rdx(i, j)*(ub_tl(i, j)+vt_tl(i, j))
          ub(i, j) = (ub(i, j)+vt(i, j))*gridstruct%rdx(i, j)
          fy_tl(i, j) = gridstruct%rdx(i, j)*u_tl(i, j)
          fy(i, j) = u(i, j)*gridstruct%rdx(i, j)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          gy_tl(i, j) = fy_tl(i, j)*ub(i, j) + fy(i, j)*ub_tl(i, j)
          gy(i, j) = fy(i, j)*ub(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          vb_tl(i, j) = gridstruct%rdy(i, j)*(vb_tl(i, j)-ut_tl(i, j))
          vb(i, j) = (vb(i, j)-ut(i, j))*gridstruct%rdy(i, j)
          fx_tl(i, j) = gridstruct%rdy(i, j)*v_tl(i, j)
          fx(i, j) = v(i, j)*gridstruct%rdy(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          gx_tl(i, j) = fx_tl(i, j)*vb(i, j) + fx(i, j)*vb_tl(i, j)
          gx(i, j) = fx(i, j)*vb(i, j)
        END DO
      END DO
!----------------------------------
! Heating due to damping:
!----------------------------------
      damp = 0.25*d_con
      DO j=js,je
        DO i=is,ie
          u2_tl = fy_tl(i, j) + fy_tl(i, j+1)
          u2 = fy(i, j) + fy(i, j+1)
          du2_tl = ub_tl(i, j) + ub_tl(i, j+1)
          du2 = ub(i, j) + ub(i, j+1)
          v2_tl = fx_tl(i, j) + fx_tl(i+1, j)
          v2 = fx(i, j) + fx(i+1, j)
          dv2_tl = vb_tl(i, j) + vb_tl(i+1, j)
          dv2 = vb(i, j) + vb(i+1, j)
! Total energy conserving:
! Convert lost KE due to divergence damping to "heat"
          heat_source_tl(i, j) = delp_tl(i, j)*(heat_source(i, j)-damp*&
&           gridstruct%rsin2(i, j)*(ub(i, j)**2+ub(i, j+1)**2+vb(i, j)**&
&           2+vb(i+1, j)**2+2.*(gy(i, j)+gy(i, j+1)+gx(i, j)+gx(i+1, j))&
&           -gridstruct%cosa_s(i, j)*(u2*dv2+v2*du2+du2*dv2))) + delp(i&
&           , j)*(heat_source_tl(i, j)-damp*gridstruct%rsin2(i, j)*(2*ub&
&           (i, j)*ub_tl(i, j)+2*ub(i, j+1)*ub_tl(i, j+1)+2*vb(i, j)*&
&           vb_tl(i, j)+2*vb(i+1, j)*vb_tl(i+1, j)+2.*(gy_tl(i, j)+gy_tl&
&           (i, j+1)+gx_tl(i, j)+gx_tl(i+1, j))-gridstruct%cosa_s(i, j)*&
&           (u2_tl*dv2+u2*dv2_tl+v2_tl*du2+v2*du2_tl+du2_tl*dv2+du2*&
&           dv2_tl)))
          heat_source(i, j) = delp(i, j)*(heat_source(i, j)-damp*&
&           gridstruct%rsin2(i, j)*(ub(i, j)**2+ub(i, j+1)**2+vb(i, j)**&
&           2+vb(i+1, j)**2+2.*(gy(i, j)+gy(i, j+1)+gx(i, j)+gx(i+1, j))&
&           -gridstruct%cosa_s(i, j)*(u2*dv2+v2*du2+du2*dv2)))
        END DO
      END DO
    END IF
! Add diffusive fluxes to the momentum equation:
    IF (damp_v .GT. 1.e-5) THEN
      DO j=js,je+1
        DO i=is,ie
          u_tl(i, j) = u_tl(i, j) + vt_tl(i, j)
          u(i, j) = u(i, j) + vt(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          v_tl(i, j) = v_tl(i, j) - ut_tl(i, j)
          v(i, j) = v(i, j) - ut(i, j)
        END DO
      END DO
    END IF
    IF (damp_v_pert .GT. 1.e-5) THEN
      DO j=js,je+1
        DO i=is,ie
          u_tl(i, j) = u_tl(i, j) + vt_tl(i, j)
          u(i, j) = u(i, j) + vt(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          v_tl(i, j) = v_tl(i, j) - ut_tl(i, j)
          v(i, j) = v(i, j) - ut(i, j)
        END DO
      END DO
    END IF
  END SUBROUTINE D_SW_TLM
!     d_sw :: D-Grid Shallow Water Routine
  SUBROUTINE D_SW(delpc, delpc_tj, delp, ptc, pt, u, v, w, uc, vc, ua, &
&   va, divg_d, xflux, yflux, cx, cy, crx_adv, cry_adv, xfx_adv, yfx_adv&
&   , q_con, z_rat, heat_source, zvir, sphum, nq, q, k, km, inline_q, dt&
&   , hord_tr, hord_mt, hord_vt, hord_tm, hord_dp, hord_tr_pert, &
&   hord_mt_pert, hord_vt_pert, hord_tm_pert, hord_dp_pert, nord, nord_v&
&   , nord_w, nord_t, dddmp, d2_bg, d4_bg, damp_v, damp_w, damp_t, d_con&
&   , split_damp, nord_pert, nord_v_pert, nord_w_pert, nord_t_pert, &
&   dddmp_pert, d2_bg_pert, d4_bg_pert, damp_v_pert, damp_w_pert, &
&   damp_t_pert, d_con_pert, hydrostatic, gridstruct, flagstruct, bd)
    IMPLICIT NONE
!#ifdef SW_DYNAMICS
!      endif ! test_case
!#endif
    INTEGER, INTENT(IN) :: hord_tr, hord_mt, hord_vt, hord_tm, hord_dp
    INTEGER, INTENT(IN) :: hord_tr_pert, hord_mt_pert, hord_vt_pert, &
&   hord_tm_pert, hord_dp_pert
! nord=1 divergence damping; (del-4) or 3 (del-8)
    INTEGER, INTENT(IN) :: nord
! vorticity damping
    INTEGER, INTENT(IN) :: nord_v
! vertical velocity
    INTEGER, INTENT(IN) :: nord_w
! pt
    INTEGER, INTENT(IN) :: nord_t
    LOGICAL, INTENT(IN) :: split_damp
    INTEGER, INTENT(IN) :: nord_pert, nord_v_pert, nord_w_pert, &
&   nord_t_pert
    INTEGER, INTENT(IN) :: sphum, nq, k, km
    REAL(fvprc), INTENT(IN) :: dt, dddmp, d2_bg, d4_bg, d_con
    REAL(fvprc), INTENT(IN) :: dddmp_pert, d2_bg_pert, d4_bg_pert, &
&   d_con_pert
    REAL(fvprc), INTENT(IN) :: zvir
    REAL(fvprc), INTENT(IN) :: damp_v, damp_w, damp_t
    REAL(fvprc), INTENT(IN) :: damp_v_pert, damp_w_pert, damp_t_pert
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! divergence
    REAL(fvprc), INTENT(INOUT) :: divg_d(bd%isd:bd%ied+1, bd%jsd:bd%jed+&
&   1)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   z_rat
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delp, pt, ua, va, w
    REAL(fvprc), DIMENSION(bd%isd:bd%isd, bd%jsd:bd%jsd), INTENT(INOUT) &
&   :: q_con
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u, vc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v, uc
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, km, nq&
&   )
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(OUT) ::&
&   delpc, ptc
    REAL(fvprc), DIMENSION(bd%is:bd%ie, bd%js:bd%je), INTENT(OUT) :: &
&   heat_source
! The flux capacitors:
    REAL(fvprc), INTENT(INOUT) :: xflux(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc), INTENT(INOUT) :: yflux(bd%is:bd%ie, bd%js:bd%je+1)
!------------------------
    REAL(fvprc), INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1)
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: inline_q
    REAL(fvprc), DIMENSION(bd%is:bd%ie+1, bd%jsd:bd%jed), INTENT(OUT) ::&
&   crx_adv, xfx_adv
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%js:bd%je+1), INTENT(OUT) ::&
&   cry_adv, yfx_adv
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
! Local:
    REAL(fvprc) :: ut(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: vt(bd%isd:bd%ied, bd%jsd:bd%jed+1)
!---
    REAL(fvprc) :: fx2(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: fy2(bd%isd:bd%ied, bd%jsd:bd%jed+1)
!  work array
    REAL(fvprc) :: dw(bd%is:bd%ie, bd%js:bd%je)
!---
    REAL(fvprc), DIMENSION(bd%is:bd%ie+1, bd%js:bd%je+1) :: ub, vb
!  work array
    REAL(fvprc) :: wk(bd%isd:bd%ied, bd%jsd:bd%jed)
!  needs this for corner_comm
    REAL(fvprc) :: ke(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
! Vorticity
    REAL(fvprc) :: vort(bd%isd:bd%ied, bd%jsd:bd%jed)
! 1-D X-direction Fluxes
    REAL(fvprc) :: fx(bd%is:bd%ie+1, bd%js:bd%je)
! 1-D Y-direction Fluxes
    REAL(fvprc) :: fy(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: ra_x(bd%is:bd%ie, bd%jsd:bd%jed)
    REAL(fvprc) :: ra_y(bd%isd:bd%ied, bd%js:bd%je)
    REAL(fvprc) :: gx(bd%is:bd%ie+1, bd%js:bd%je)
! work Y-dir flux array
    REAL(fvprc) :: gy(bd%is:bd%ie, bd%js:bd%je+1)
    LOGICAL :: fill_c
    REAL(fvprc) :: dt2, dt4, dt5, dt6
    REAL(fvprc) :: damp, damp2, damp4, dd8, u2, v2, du2, dv2, damp4_pert
    REAL(fvprc) :: u_lon
    INTEGER :: i, j, is2, ie1, js2, je1, n, nt, n2, iq
!      real(FVPRC), pointer, dimension(:,:) :: area, area_c, rarea, rarea_c
!      real(FVPRC), pointer, dimension(:,:,:) :: sin_sg
!      real(FVPRC), pointer, dimension(:,:)   :: cosa_u, cosa_v, cosa_s
!      real(FVPRC), pointer, dimension(:,:)   :: sina_u, sina_v
!      real(FVPRC), pointer, dimension(:,:)   :: rsin_u, rsin_v, rsina
!      real(FVPRC), pointer, dimension(:,:)   :: f0, rsin2, divg_u, divg_v
!      real(FVPRC), pointer, dimension(:,:) ::  cosa, dx, dy, dxc, dyc, rdxa, rdya, rdx, rdy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTEGER :: npx, npy
    LOGICAL :: nested
    REAL(fvprc) :: da_min, da_min_c
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: delp_tj, &
&   pt_tj, w_tj
    REAL(fvprc) :: q_tj(bd%isd:bd%ied, bd%jsd:bd%jed, km, nq)
    REAL(fvprc) :: vort_tj(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), DIMENSION(bd%is:bd%ie+1, bd%js:bd%je+1) :: ub_tj, vb_tj
    REAL(fvprc) :: fx_tj(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: fy_tj(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: gx_tj(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: gy_tj(bd%is:bd%ie, bd%js:bd%je+1)
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(OUT) ::&
&   delpc_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ptc_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1) :: ke_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1) :: u_tj, &
&   vc_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed) :: v_tj, &
&   uc_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ua_tj, va_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1) :: &
&   divg_d_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: wk_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed) :: ut_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1) :: vt_tj
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    REAL(fvprc) :: pwx1
    INTEGER :: pwy1
!
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
    fx = 0.0
    fy = 0.0
    gx = 0.0
    gy = 0.0
    ub = 0.0
    vb = 0.0
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    npx = flagstruct%npx
    npy = flagstruct%npy
    nested = gridstruct%nested
    da_min = gridstruct%da_min
    da_min_c = gridstruct%da_min_c
! end grid_type choices
!      area      => gridstruct%area   
!      rarea     => gridstruct%rarea  
!      rarea_c   => gridstruct%rarea_c
!      sin_sg    => gridstruct%sin_sg 
!      cosa_u    => gridstruct%cosa_u 
!      cosa_v    => gridstruct%cosa_v 
!      cosa_s    => gridstruct%cosa_s 
!      sina_u    => gridstruct%sina_u 
!      sina_v    => gridstruct%sina_v 
!      rsin_u    => gridstruct%rsin_u 
!      rsin_v    => gridstruct%rsin_v 
!      rsina     => gridstruct%rsina  
!      f0        => gridstruct%f0     
!      rsin2     => gridstruct%rsin2  
!      divg_u    => gridstruct%divg_u 
!      divg_v    => gridstruct%divg_v 
!      cosa      => gridstruct%cosa   
!      dx        => gridstruct%dx     
!      dy        => gridstruct%dy     
!      dxc       => gridstruct%dxc    
!      dyc       => gridstruct%dyc    
!      rdxa      => gridstruct%rdxa   
!      rdya      => gridstruct%rdya   
!      rdx       => gridstruct%rdx    
!      rdy       => gridstruct%rdy    
!#ifdef SW_DYNAMICS 
!      if ( test_case == 1 ) then
!        do j=jsd,jed
!           do i=is,ie+1
!              xfx_adv(i,j) = dt * uc(i,j) / gridstruct%sina_u(i,j)
!              if (xfx_adv(i,j) > 0.) then
!                  crx_adv(i,j) = xfx_adv(i,j) * gridstruct%rdxa(i-1,j)
!              else
!                  crx_adv(i,j) = xfx_adv(i,j) * gridstruct%rdxa(i,j)
!              endif
!              xfx_adv(i,j) = gridstruct%dy(i,j)*xfx_adv(i,j)*gridstruct%sina_u(i,j)
!           enddo
!        enddo
!
!        do j=js,je+1
!           do i=isd,ied
!              yfx_adv(i,j) = dt * vc(i,j) / gridstruct%sina_v(i,j)
!              if (yfx_adv(i,j) > 0.) then
!                 cry_adv(i,j) = yfx_adv(i,j) * gridstruct%rdya(i,j-1)
!              else
!                 cry_adv(i,j) = yfx_adv(i,j) * gridstruct%rdya(i,j)
!              endif
!              yfx_adv(i,j) = gridstruct%dx(i,j)*yfx_adv(i,j)*gridstruct%sina_v(i,j)
!           enddo
!        enddo
!      else
!#endif
    IF (flagstruct%grid_type .LT. 3) THEN
!!! TO DO: separate versions for nesting and for cubed-sphere
      IF (nested) THEN
        DO j=jsd,jed
          DO i=is-1,ie+2
            ut(i, j) = (uc(i, j)-0.25*gridstruct%cosa_u(i, j)*(vc(i-1, j&
&             )+vc(i, j)+vc(i-1, j+1)+vc(i, j+1)))*gridstruct%rsin_u(i, &
&             j)
          END DO
        END DO
        DO j=js-1,je+2
          DO i=isd,ied
            vt(i, j) = (vc(i, j)-0.25*gridstruct%cosa_v(i, j)*(uc(i, j-1&
&             )+uc(i+1, j-1)+uc(i, j)+uc(i+1, j)))*gridstruct%rsin_v(i, &
&             j)
          END DO
        END DO
      ELSE
        DO j=jsd,jed
          IF (j .NE. 0 .AND. j .NE. 1 .AND. j .NE. npy - 1 .AND. j .NE. &
&             npy) THEN
            DO i=is-1,ie+2
              ut(i, j) = (uc(i, j)-0.25*gridstruct%cosa_u(i, j)*(vc(i-1&
&               , j)+vc(i, j)+vc(i-1, j+1)+vc(i, j+1)))*gridstruct%&
&               rsin_u(i, j)
            END DO
          END IF
        END DO
        DO j=js-1,je+2
          IF (j .NE. 1 .AND. j .NE. npy) THEN
            DO i=isd,ied
              vt(i, j) = (vc(i, j)-0.25*gridstruct%cosa_v(i, j)*(uc(i, j&
&               -1)+uc(i+1, j-1)+uc(i, j)+uc(i+1, j)))*gridstruct%rsin_v&
&               (i, j)
            END DO
          END IF
        END DO
      END IF
!.not. nested
      IF (.NOT.nested) THEN
! West face
! West edge:
        IF (is .EQ. 1) THEN
          DO j=jsd,jed
            IF (uc(1, j)*dt .GT. 0.) THEN
              ut(1, j) = uc(1, j)/gridstruct%sin_sg(0, j, 3)
            ELSE
              ut(1, j) = uc(1, j)/gridstruct%sin_sg(1, j, 1)
            END IF
          END DO
          IF (3 .LT. js) THEN
            max1 = js
          ELSE
            max1 = 3
          END IF
          IF (npy - 2 .GT. je + 1) THEN
            min1 = je + 1
          ELSE
            min1 = npy - 2
          END IF
          DO j=max1,min1
            vt(0, j) = vc(0, j) - 0.25*gridstruct%cosa_v(0, j)*(ut(0, j-&
&             1)+ut(1, j-1)+ut(0, j)+ut(1, j))
            vt(1, j) = vc(1, j) - 0.25*gridstruct%cosa_v(1, j)*(ut(1, j-&
&             1)+ut(2, j-1)+ut(1, j)+ut(2, j))
          END DO
        END IF
! East edge:
        IF (ie + 1 .EQ. npx) THEN
          DO j=jsd,jed
            IF (uc(npx, j)*dt .GT. 0.) THEN
              ut(npx, j) = uc(npx, j)/gridstruct%sin_sg(npx-1, j, 3)
            ELSE
              ut(npx, j) = uc(npx, j)/gridstruct%sin_sg(npx, j, 1)
            END IF
          END DO
          IF (3 .LT. js) THEN
            max2 = js
          ELSE
            max2 = 3
          END IF
          IF (npy - 2 .GT. je + 1) THEN
            min2 = je + 1
          ELSE
            min2 = npy - 2
          END IF
          DO j=max2,min2
            vt(npx-1, j) = vc(npx-1, j) - 0.25*gridstruct%cosa_v(npx-1, &
&             j)*(ut(npx-1, j-1)+ut(npx, j-1)+ut(npx-1, j)+ut(npx, j))
            vt(npx, j) = vc(npx, j) - 0.25*gridstruct%cosa_v(npx, j)*(ut&
&             (npx, j-1)+ut(npx+1, j-1)+ut(npx, j)+ut(npx+1, j))
          END DO
        END IF
! South (Bottom) edge:
        IF (js .EQ. 1) THEN
          DO i=isd,ied
            IF (vc(i, 1)*dt .GT. 0.) THEN
              vt(i, 1) = vc(i, 1)/gridstruct%sin_sg(i, 0, 4)
            ELSE
              vt(i, 1) = vc(i, 1)/gridstruct%sin_sg(i, 1, 2)
            END IF
          END DO
          IF (3 .LT. is) THEN
            max3 = is
          ELSE
            max3 = 3
          END IF
          IF (npx - 2 .GT. ie + 1) THEN
            min3 = ie + 1
          ELSE
            min3 = npx - 2
          END IF
          DO i=max3,min3
            ut(i, 0) = uc(i, 0) - 0.25*gridstruct%cosa_u(i, 0)*(vt(i-1, &
&             0)+vt(i, 0)+vt(i-1, 1)+vt(i, 1))
            ut(i, 1) = uc(i, 1) - 0.25*gridstruct%cosa_u(i, 1)*(vt(i-1, &
&             1)+vt(i, 1)+vt(i-1, 2)+vt(i, 2))
          END DO
        END IF
! North edge:
        IF (je + 1 .EQ. npy) THEN
          DO i=isd,ied
            IF (vc(i, npy)*dt .GT. 0.) THEN
              vt(i, npy) = vc(i, npy)/gridstruct%sin_sg(i, npy-1, 4)
            ELSE
              vt(i, npy) = vc(i, npy)/gridstruct%sin_sg(i, npy, 2)
            END IF
          END DO
          IF (3 .LT. is) THEN
            max4 = is
          ELSE
            max4 = 3
          END IF
          IF (npx - 2 .GT. ie + 1) THEN
            min4 = ie + 1
          ELSE
            min4 = npx - 2
          END IF
          DO i=max4,min4
            ut(i, npy-1) = uc(i, npy-1) - 0.25*gridstruct%cosa_u(i, npy-&
&             1)*(vt(i-1, npy-1)+vt(i, npy-1)+vt(i-1, npy)+vt(i, npy))
            ut(i, npy) = uc(i, npy) - 0.25*gridstruct%cosa_u(i, npy)*(vt&
&             (i-1, npy)+vt(i, npy)+vt(i-1, npy+1)+vt(i, npy+1))
          END DO
        END IF
! The following code solves a 2x2 system to get the interior parallel-to-edge uc,vc values 
! near the corners (ex: for the sw corner ut(2,1) and vt(1,2) are solved for simultaneously). 
! It then computes the halo uc, vc values so as to be consistent with the computations on 
! the facing panel. 
!The system solved is:
!  ut(2,1) = uc(2,1) - avg(vt)*gridstruct%cosa_u(2,1)
!  vt(1,2) = vc(1,2) - avg(ut)*gridstruct%cosa_v(1,2)
! in which avg(vt) includes vt(1,2) and avg(ut) includes ut(2,1)
        IF (sw_corner) THEN
          damp = 1./(1.-0.0625*gridstruct%cosa_u(2, 0)*gridstruct%cosa_v&
&           (1, 0))
          ut(2, 0) = (uc(2, 0)-0.25*gridstruct%cosa_u(2, 0)*(vt(1, 1)+vt&
&           (2, 1)+vt(2, 0)+vc(1, 0)-0.25*gridstruct%cosa_v(1, 0)*(ut(1&
&           , 0)+ut(1, -1)+ut(2, -1))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(0, 1)*gridstruct%cosa_v&
&           (0, 2))
          vt(0, 2) = (vc(0, 2)-0.25*gridstruct%cosa_v(0, 2)*(ut(1, 1)+ut&
&           (1, 2)+ut(0, 2)+uc(0, 1)-0.25*gridstruct%cosa_u(0, 1)*(vt(0&
&           , 1)+vt(-1, 1)+vt(-1, 2))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(2, 1)*gridstruct%cosa_v&
&           (1, 2))
          ut(2, 1) = (uc(2, 1)-0.25*gridstruct%cosa_u(2, 1)*(vt(1, 1)+vt&
&           (2, 1)+vt(2, 2)+vc(1, 2)-0.25*gridstruct%cosa_v(1, 2)*(ut(1&
&           , 1)+ut(1, 2)+ut(2, 2))))*damp
          vt(1, 2) = (vc(1, 2)-0.25*gridstruct%cosa_v(1, 2)*(ut(1, 1)+ut&
&           (1, 2)+ut(2, 2)+uc(2, 1)-0.25*gridstruct%cosa_u(2, 1)*(vt(1&
&           , 1)+vt(2, 1)+vt(2, 2))))*damp
        END IF
        IF (se_corner) THEN
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx-1, 0)*gridstruct%&
&           cosa_v(npx-1, 0))
          ut(npx-1, 0) = (uc(npx-1, 0)-0.25*gridstruct%cosa_u(npx-1, 0)*&
&           (vt(npx-1, 1)+vt(npx-2, 1)+vt(npx-2, 0)+vc(npx-1, 0)-0.25*&
&           gridstruct%cosa_v(npx-1, 0)*(ut(npx, 0)+ut(npx, -1)+ut(npx-1&
&           , -1))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx+1, 1)*gridstruct%&
&           cosa_v(npx, 2))
          vt(npx, 2) = (vc(npx, 2)-0.25*gridstruct%cosa_v(npx, 2)*(ut(&
&           npx, 1)+ut(npx, 2)+ut(npx+1, 2)+uc(npx+1, 1)-0.25*gridstruct&
&           %cosa_u(npx+1, 1)*(vt(npx, 1)+vt(npx+1, 1)+vt(npx+1, 2))))*&
&           damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx-1, 1)*gridstruct%&
&           cosa_v(npx-1, 2))
          ut(npx-1, 1) = (uc(npx-1, 1)-0.25*gridstruct%cosa_u(npx-1, 1)*&
&           (vt(npx-1, 1)+vt(npx-2, 1)+vt(npx-2, 2)+vc(npx-1, 2)-0.25*&
&           gridstruct%cosa_v(npx-1, 2)*(ut(npx, 1)+ut(npx, 2)+ut(npx-1&
&           , 2))))*damp
          vt(npx-1, 2) = (vc(npx-1, 2)-0.25*gridstruct%cosa_v(npx-1, 2)*&
&           (ut(npx, 1)+ut(npx, 2)+ut(npx-1, 2)+uc(npx-1, 1)-0.25*&
&           gridstruct%cosa_u(npx-1, 1)*(vt(npx-1, 1)+vt(npx-2, 1)+vt(&
&           npx-2, 2))))*damp
        END IF
        IF (ne_corner) THEN
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx-1, npy)*gridstruct%&
&           cosa_v(npx-1, npy+1))
          ut(npx-1, npy) = (uc(npx-1, npy)-0.25*gridstruct%cosa_u(npx-1&
&           , npy)*(vt(npx-1, npy)+vt(npx-2, npy)+vt(npx-2, npy+1)+vc(&
&           npx-1, npy+1)-0.25*gridstruct%cosa_v(npx-1, npy+1)*(ut(npx, &
&           npy)+ut(npx, npy+1)+ut(npx-1, npy+1))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx+1, npy-1)*&
&           gridstruct%cosa_v(npx, npy-1))
          vt(npx, npy-1) = (vc(npx, npy-1)-0.25*gridstruct%cosa_v(npx, &
&           npy-1)*(ut(npx, npy-1)+ut(npx, npy-2)+ut(npx+1, npy-2)+uc(&
&           npx+1, npy-1)-0.25*gridstruct%cosa_u(npx+1, npy-1)*(vt(npx, &
&           npy)+vt(npx+1, npy)+vt(npx+1, npy-1))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx-1, npy-1)*&
&           gridstruct%cosa_v(npx-1, npy-1))
          ut(npx-1, npy-1) = (uc(npx-1, npy-1)-0.25*gridstruct%cosa_u(&
&           npx-1, npy-1)*(vt(npx-1, npy)+vt(npx-2, npy)+vt(npx-2, npy-1&
&           )+vc(npx-1, npy-1)-0.25*gridstruct%cosa_v(npx-1, npy-1)*(ut(&
&           npx, npy-1)+ut(npx, npy-2)+ut(npx-1, npy-2))))*damp
          vt(npx-1, npy-1) = (vc(npx-1, npy-1)-0.25*gridstruct%cosa_v(&
&           npx-1, npy-1)*(ut(npx, npy-1)+ut(npx, npy-2)+ut(npx-1, npy-2&
&           )+uc(npx-1, npy-1)-0.25*gridstruct%cosa_u(npx-1, npy-1)*(vt(&
&           npx-1, npy)+vt(npx-2, npy)+vt(npx-2, npy-1))))*damp
        END IF
        IF (nw_corner) THEN
          damp = 1./(1.-0.0625*gridstruct%cosa_u(2, npy)*gridstruct%&
&           cosa_v(1, npy+1))
          ut(2, npy) = (uc(2, npy)-0.25*gridstruct%cosa_u(2, npy)*(vt(1&
&           , npy)+vt(2, npy)+vt(2, npy+1)+vc(1, npy+1)-0.25*gridstruct%&
&           cosa_v(1, npy+1)*(ut(1, npy)+ut(1, npy+1)+ut(2, npy+1))))*&
&           damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(0, npy-1)*gridstruct%&
&           cosa_v(0, npy-1))
          vt(0, npy-1) = (vc(0, npy-1)-0.25*gridstruct%cosa_v(0, npy-1)*&
&           (ut(1, npy-1)+ut(1, npy-2)+ut(0, npy-2)+uc(0, npy-1)-0.25*&
&           gridstruct%cosa_u(0, npy-1)*(vt(0, npy)+vt(-1, npy)+vt(-1, &
&           npy-1))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(2, npy-1)*gridstruct%&
&           cosa_v(1, npy-1))
          ut(2, npy-1) = (uc(2, npy-1)-0.25*gridstruct%cosa_u(2, npy-1)*&
&           (vt(1, npy)+vt(2, npy)+vt(2, npy-1)+vc(1, npy-1)-0.25*&
&           gridstruct%cosa_v(1, npy-1)*(ut(1, npy-1)+ut(1, npy-2)+ut(2&
&           , npy-2))))*damp
          vt(1, npy-1) = (vc(1, npy-1)-0.25*gridstruct%cosa_v(1, npy-1)*&
&           (ut(1, npy-1)+ut(1, npy-2)+ut(2, npy-2)+uc(2, npy-1)-0.25*&
&           gridstruct%cosa_u(2, npy-1)*(vt(1, npy)+vt(2, npy)+vt(2, npy&
&           -1))))*damp
        END IF
      END IF
    ELSE
! flagstruct%grid_type >= 3
      DO j=jsd,jed
        DO i=is,ie+1
          ut(i, j) = uc(i, j)
        END DO
      END DO
      DO j=js,je+1
        DO i=isd,ied
          vt(i, j) = vc(i, j)
        END DO
      END DO
    END IF
    DO j=jsd,jed
      DO i=is,ie+1
        xfx_adv(i, j) = dt*ut(i, j)
      END DO
    END DO
    DO j=js,je+1
      DO i=isd,ied
        yfx_adv(i, j) = dt*vt(i, j)
      END DO
    END DO
! Explanation of the following code:
!    xfx_adv = dt*ut*dy   
!    crx_adv = dt*ut/dx
    DO j=jsd,jed
!DEC$ VECTOR ALWAYS
      DO i=is,ie+1
        IF (xfx_adv(i, j) .GT. 0.) THEN
          crx_adv(i, j) = xfx_adv(i, j)*gridstruct%rdxa(i-1, j)
          xfx_adv(i, j) = gridstruct%dy(i, j)*xfx_adv(i, j)*gridstruct%&
&           sin_sg(i-1, j, 3)
        ELSE
          crx_adv(i, j) = xfx_adv(i, j)*gridstruct%rdxa(i, j)
          xfx_adv(i, j) = gridstruct%dy(i, j)*xfx_adv(i, j)*gridstruct%&
&           sin_sg(i, j, 1)
        END IF
      END DO
    END DO
    DO j=js,je+1
!DEC$ VECTOR ALWAYS
      DO i=isd,ied
        IF (yfx_adv(i, j) .GT. 0.) THEN
          cry_adv(i, j) = yfx_adv(i, j)*gridstruct%rdya(i, j-1)
          yfx_adv(i, j) = gridstruct%dx(i, j)*yfx_adv(i, j)*gridstruct%&
&           sin_sg(i, j-1, 4)
        ELSE
          cry_adv(i, j) = yfx_adv(i, j)*gridstruct%rdya(i, j)
          yfx_adv(i, j) = gridstruct%dx(i, j)*yfx_adv(i, j)*gridstruct%&
&           sin_sg(i, j, 2)
        END IF
      END DO
    END DO
!#ifdef SW_DYNAMICS
!      endif
!#endif
    DO j=jsd,jed
      DO i=is,ie
        ra_x(i, j) = gridstruct%area(i, j) + xfx_adv(i, j) - xfx_adv(i+1&
&         , j)
      END DO
    END DO
    DO j=js,je
      DO i=isd,ied
        ra_y(i, j) = gridstruct%area(i, j) + yfx_adv(i, j) - yfx_adv(i, &
&         j+1)
      END DO
    END DO
    IF (hord_dp .EQ. hord_dp_pert .AND. (.NOT.split_damp)) THEN
      CALL FV_TP_2D(delp, crx_adv, cry_adv, npx, npy, hord_dp, fx, fy&
&                , xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y, nord=&
&                nord_v, damp_c=damp_v)
    ELSE
      delp_tj = delp
      fx_tj = fx
      fy_tj = fy
      call fv_tp_2d(delp, crx_adv, cry_adv, npx, npy, hord_dp, fx, fy,  &
                    xfx_adv,yfx_adv, gridstruct, bd, ra_x, ra_y, nord=nord_v, damp_c=damp_v)
      CALL FV_TP_2D(delp, crx_adv, cry_adv, npx, npy, hord_dp_pert, fx, &
&             fy, xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y, nord=&
&             nord_v_pert, damp_c=damp_v_pert)
    END IF
!#ifdef SW_DYNAMICS
!        do j=js,je
!           do i=is,ie
!              delp(i,j) = delp(i,j) +    &
!                         (fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*gridstruct%rarea(i,j)
!              ptc(i,j) = pt(i,j)
!           enddo
!        enddo
!#else
! <<< Save the mass fluxes to the "Flux Capacitor" for tracer transport >>>
    DO j=jsd,jed
      DO i=is,ie+1
        cx(i, j) = cx(i, j) + crx_adv(i, j)
      END DO
    END DO
    DO j=js,je
      DO i=is,ie+1
        xflux(i, j) = xflux(i, j) + fx(i, j)
      END DO
    END DO
    DO j=js,je+1
      DO i=isd,ied
        cy(i, j) = cy(i, j) + cry_adv(i, j)
      END DO
      DO i=is,ie
        yflux(i, j) = yflux(i, j) + fy(i, j)
      END DO
    END DO
    DO j=js,je
      DO i=is,ie
        heat_source(i, j) = 0.
      END DO
    END DO
    IF (.NOT.hydrostatic) THEN
      IF (damp_w .GT. 1.e-5) THEN
        pwx1 = damp_w*da_min_c
        pwy1 = nord_w + 1
        damp4 = pwx1**pwy1
        CALL DEL6_VT_FLUX(nord_w, npx, npy, damp4, w, wk, fx2, fy2, &
&                   gridstruct, bd)
        DO j=js,je
          DO i=is,ie
            dw(i, j) = (fx2(i, j)-fx2(i+1, j)+fy2(i, j)-fy2(i, j+1))*&
&             gridstruct%rarea(i, j)
! 0.5 * [ (w+dw)**2 - w**2 ] = w*dw + 0.5*dw*dw
!                   heat_source(i,j) = -d_con*dw(i,j)*(w(i,j)+0.5*dw(i,j))
            heat_source(i, j) = -(dw(i, j)*(w(i, j)+0.5*dw(i, j)))
          END DO
        END DO
      END IF
      IF (hord_vt .EQ. hord_vt_pert) THEN
        CALL FV_TP_2D(w, crx_adv, cry_adv, npx, npy, hord_vt, gx, gy&
&                  , xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y, mfx=&
&                  fx, mfy=fy)
      ELSE
        w_tj = w
        gx_tj = gx
        gy_tj = gy
        call fv_tp_2d(w, crx_adv,cry_adv, npx, npy, hord_vt, gx, gy, xfx_adv, yfx_adv, &
                      gridstruct, bd, ra_x, ra_y, mfx=fx, mfy=fy)
        CALL FV_TP_2D(w, crx_adv, cry_adv, npx, npy, hord_vt_pert, gx, &
&               gy, xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y, mfx=fx&
&               , mfy=fy)
      END IF
      DO j=js,je
        DO i=is,ie
          w(i, j) = delp(i, j)*w(i, j) + (gx(i, j)-gx(i+1, j)+gy(i, j)-&
&           gy(i, j+1))*gridstruct%rarea(i, j)
        END DO
      END DO
    END IF
!#ifdef USE_COND
!           call fv_tp_2d(q_con, crx_adv,cry_adv, npx, npy, hord_dp, gx, gy,  &
!                xfx_adv,yfx_adv, gridstruct, bd, ra_x, ra_y, mfx=fx, mfy=fy, mass=delp, nord=nord_t, damp_c=damp_t)
!            do j=js,je
!               do i=is,ie
!                  q_con(i,j) = delp(i,j)*q_con(i,j) + (gx(i,j)-gx(i+1,j)+gy(i,j)-gy(i,j+1))*gridstruct%rarea(i,j)
!               enddo
!            enddo
!#endif
    IF (inline_q) THEN
      DO j=jsd,jed
        DO i=isd,ied
          pt(i, j) = pt(i, j)/(1.+zvir*q(i, j, k, sphum))
        END DO
      END DO
    END IF
    IF (hord_tm .EQ. hord_tm_pert .AND. (.NOT.split_damp)) THEN
      CALL FV_TP_2D(pt, crx_adv, cry_adv, npx, npy, hord_tm, gx, gy, &
&                xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y, fx, fy, &
&                delp, nord_t, damp_t)
    ELSE
      pt_tj = pt
      gx_tj = gx
      gy_tj = gy
      call fv_tp_2d(pt, crx_adv,cry_adv, npx, npy, hord_tm, gx, gy,  &
                    xfx_adv,yfx_adv, gridstruct, bd, ra_x, ra_y,     &
                    mfx=fx, mfy=fy, mass=delp, nord=nord_t, damp_c=damp_t)
      CALL FV_TP_2D(pt, crx_adv, cry_adv, npx, npy, hord_tm_pert, gx, gy&
&             , xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y, fx, fy, &
&             delp, nord_t_pert, damp_t_pert)
    END IF
    IF (inline_q) THEN
      DO j=js,je
        DO i=is,ie
          wk(i, j) = delp(i, j)
          delp(i, j) = wk(i, j) + (fx(i, j)-fx(i+1, j)+fy(i, j)-fy(i, j+&
&           1))*gridstruct%rarea(i, j)
          pt(i, j) = (pt(i, j)*wk(i, j)+(gx(i, j)-gx(i+1, j)+gy(i, j)-gy&
&           (i, j+1))*gridstruct%rarea(i, j))/delp(i, j)
        END DO
      END DO
      DO iq=1,nq
        IF (hord_tr .EQ. hord_tr_pert) THEN
          CALL FV_TP_2D(q(isd:ied, jsd:jed, k, iq), crx_adv, cry_adv&
&                    , npx, npy, hord_tr, gx, gy, xfx_adv, yfx_adv, &
&                    gridstruct, bd, ra_x, ra_y, mfx=fx, mfy=fy)
        ELSE
          q_tj(:, :, :, iq) = q(:, :, :, iq)
          gx_tj = gx
          gy_tj = gy
          call fv_tp_2d(q(isd:ied,jsd:ied,k,iq), crx_adv,cry_adv, npx, npy, hord_tr, gx, gy,  &
                        xfx_adv,yfx_adv, gridstruct, bd, ra_x, ra_y, mfx=fx, mfy=fy)
          CALL FV_TP_2D(q(isd:ied, jsd:ied, k, iq), crx_adv, cry_adv, &
&                 npx, npy, hord_tr_pert, gx, gy, xfx_adv, yfx_adv, &
&                 gridstruct, bd, ra_x, ra_y, mfx=fx, mfy=fy)
        END IF
        DO j=js,je
          DO i=is,ie
            q(i, j, k, iq) = (q(i, j, k, iq)*wk(i, j)+(gx(i, j)-gx(i+1, &
&             j)+gy(i, j)-gy(i, j+1))*gridstruct%rarea(i, j))/delp(i, j)
          END DO
        END DO
      END DO
      DO j=js,je
        DO i=is,ie
          pt(i, j) = pt(i, j)*(1.+zvir*q(i, j, k, sphum))
        END DO
      END DO
    ELSE
      DO j=js,je
        DO i=is,ie
          pt(i, j) = pt(i, j)*delp(i, j) + (gx(i, j)-gx(i+1, j)+gy(i, j)&
&           -gy(i, j+1))*gridstruct%rarea(i, j)
          delp(i, j) = delp(i, j) + (fx(i, j)-fx(i+1, j)+fy(i, j)-fy(i, &
&           j+1))*gridstruct%rarea(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie
          pt(i, j) = pt(i, j)/delp(i, j)
        END DO
      END DO
    END IF
!#endif
!#ifdef SW_DYNAMICS
!      if (test_case > 1) then
!#endif
!----------------------
! Kinetic Energy Fluxes
!----------------------
! Compute B grid contra-variant components for KE:
    dt5 = 0.5*dt
    dt4 = 0.25*dt
    IF (nested) THEN
      is2 = is
      ie1 = ie + 1
      js2 = js
      je1 = je + 1
    ELSE
      IF (2 .LT. is) THEN
        is2 = is
      ELSE
        is2 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        ie1 = ie + 1
      ELSE
        ie1 = npx - 1
      END IF
      IF (2 .LT. js) THEN
        js2 = js
      ELSE
        js2 = 2
      END IF
      IF (npy - 1 .GT. je + 1) THEN
        je1 = je + 1
      ELSE
        je1 = npy - 1
      END IF
    END IF
!!! TO DO: separate versions for nested and for cubed-sphere
    IF (flagstruct%grid_type .LT. 3) THEN
      IF (nested) THEN
        DO j=js2,je1
          DO i=is2,ie1
            vb(i, j) = dt5*(vc(i-1, j)+vc(i, j)-(uc(i, j-1)+uc(i, j))*&
&             gridstruct%cosa(i, j))*gridstruct%rsina(i, j)
          END DO
        END DO
      ELSE
        IF (js .EQ. 1) THEN
          DO i=is,ie+1
! corner values are incorrect
            vb(i, 1) = dt5*(vt(i-1, 1)+vt(i, 1))
          END DO
        END IF
        DO j=js2,je1
          DO i=is2,ie1
            vb(i, j) = dt5*(vc(i-1, j)+vc(i, j)-(uc(i, j-1)+uc(i, j))*&
&             gridstruct%cosa(i, j))*gridstruct%rsina(i, j)
          END DO
          IF (is .EQ. 1) vb(1, j) = dt4*(-vt(-1, j)+3.*(vt(0, j)+vt(1, j&
&             ))-vt(2, j))
! 2-pt extrapolation from both sides:
          IF (ie + 1 .EQ. npx) vb(npx, j) = dt4*(-vt(npx-2, j)+3.*(vt(&
&             npx-1, j)+vt(npx, j))-vt(npx+1, j))
! 2-pt extrapolation from both sides:
        END DO
        IF (je + 1 .EQ. npy) THEN
          DO i=is,ie+1
! corner values are incorrect
            vb(i, npy) = dt5*(vt(i-1, npy)+vt(i, npy))
          END DO
        END IF
      END IF
    ELSE
      DO j=js,je+1
        DO i=is,ie+1
          vb(i, j) = dt5*(vc(i-1, j)+vc(i, j))
        END DO
      END DO
    END IF
    IF (hord_mt .EQ. hord_mt_pert) THEN
      CALL YTP_V(vb, u, v, ub, hord_mt, gridstruct%cosa, gridstruct%&
&             dy, gridstruct%rdy, bd, npx, npy, flagstruct%grid_type, &
&             nested)
    ELSE
      ub_tj = ub
      call ytp_v(vb, u, v, ub, hord_mt, gridstruct%cosa, gridstruct%dy, gridstruct%rdy, &
           bd, npx, npy, flagstruct%grid_type, nested)
      CALL YTP_V(vb, u, v, ub, hord_mt_pert, gridstruct%cosa, gridstruct&
&          %dy, gridstruct%rdy, bd, npx, npy, flagstruct%grid_type, &
&          nested)
    END IF
    DO j=js,je+1
      DO i=is,ie+1
        ke(i, j) = vb(i, j)*ub(i, j)
      END DO
    END DO
    IF (flagstruct%grid_type .LT. 3) THEN
      IF (nested) THEN
        DO j=js,je+1
          DO i=is2,ie1
            ub(i, j) = dt5*(uc(i, j-1)+uc(i, j)-(vc(i-1, j)+vc(i, j))*&
&             gridstruct%cosa(i, j))*gridstruct%rsina(i, j)
          END DO
        END DO
      ELSE
        IF (is .EQ. 1) THEN
          DO j=js,je+1
! corner values are incorrect
            ub(1, j) = dt5*(ut(1, j-1)+ut(1, j))
          END DO
        END IF
        DO j=js,je+1
          IF (j .EQ. 1 .OR. j .EQ. npy) THEN
            DO i=is2,ie1
! 2-pt extrapolation from both sides:
              ub(i, j) = dt4*(-ut(i, j-2)+3.*(ut(i, j-1)+ut(i, j))-ut(i&
&               , j+1))
            END DO
          ELSE
            DO i=is2,ie1
              ub(i, j) = dt5*(uc(i, j-1)+uc(i, j)-(vc(i-1, j)+vc(i, j))*&
&               gridstruct%cosa(i, j))*gridstruct%rsina(i, j)
            END DO
          END IF
        END DO
        IF (ie + 1 .EQ. npx) THEN
          DO j=js,je+1
! corner values are incorrect
            ub(npx, j) = dt5*(ut(npx, j-1)+ut(npx, j))
          END DO
        END IF
      END IF
    ELSE
      DO j=js,je+1
        DO i=is,ie+1
          ub(i, j) = dt5*(uc(i, j-1)+uc(i, j))
        END DO
      END DO
    END IF
    IF (hord_mt .EQ. hord_mt_pert) THEN
      CALL XTP_U(ub, u, v, vb, hord_mt, gridstruct%cosa, gridstruct%&
&             dx, gridstruct%rdx, bd, npx, npy, flagstruct%grid_type, &
&             nested)
    ELSE
      vb_tj = vb
      call xtp_u(ub, u, v, vb, hord_mt, gridstruct%cosa, gridstruct%dx, gridstruct%rdx, &
           bd, npx, npy, flagstruct%grid_type, nested)
      CALL XTP_U(ub, u, v, vb, hord_mt_pert, gridstruct%cosa, gridstruct&
&          %dx, gridstruct%rdx, bd, npx, npy, flagstruct%grid_type, &
&          nested)
    END IF
    DO j=js,je+1
      DO i=is,ie+1
        ke(i, j) = 0.5*(ke(i, j)+ub(i, j)*vb(i, j))
      END DO
    END DO
!-----------------------------------------
! Fix KE at the 4 corners of the face:
!-----------------------------------------
    IF (.NOT.nested) THEN
      dt6 = dt/6.
      IF (sw_corner) ke(1, 1) = dt6*((ut(1, 1)+ut(1, 0))*u(1, 1)+(vt(1, &
&         1)+vt(0, 1))*v(1, 1)+(ut(1, 1)+vt(1, 1))*u(0, 1))
      IF (se_corner) THEN
        i = npx
        ke(i, 1) = dt6*((ut(i, 1)+ut(i, 0))*u(i-1, 1)+(vt(i, 1)+vt(i-1, &
&         1))*v(i, 1)+(ut(i, 1)-vt(i-1, 1))*u(i, 1))
      END IF
      IF (ne_corner) THEN
        i = npx
        j = npy
        ke(i, j) = dt6*((ut(i, j)+ut(i, j-1))*u(i-1, j)+(vt(i, j)+vt(i-1&
&         , j))*v(i, j-1)+(ut(i, j-1)+vt(i-1, j))*u(i, j))
      END IF
      IF (nw_corner) THEN
        j = npy
        ke(1, j) = dt6*((ut(1, j)+ut(1, j-1))*u(1, j)+(vt(1, j)+vt(0, j)&
&         )*v(1, j-1)+(ut(1, j-1)-vt(1, j))*u(0, j))
      END IF
    END IF
! Compute vorticity:
    DO j=jsd,jed+1
      DO i=isd,ied
        vt(i, j) = u(i, j)*gridstruct%dx(i, j)
      END DO
    END DO
    DO j=jsd,jed
      DO i=isd,ied+1
        ut(i, j) = v(i, j)*gridstruct%dy(i, j)
      END DO
    END DO
! wk is "volume-mean" relative vorticity
    DO j=jsd,jed
      DO i=isd,ied
        wk(i, j) = gridstruct%rarea(i, j)*(vt(i, j)-vt(i, j+1)-ut(i, j)+&
&         ut(i+1, j))
      END DO
    END DO
    IF (.NOT.hydrostatic) THEN
      IF (.NOT.flagstruct%do_f3d) THEN
!#ifdef ROT3
!            dt2 = 2.*dt
!            do j=js,je
!               do i=is,ie
!                  w(i,j) = w(i,j)/delp(i,j) + dt2*gridstruct%w00(i,j) *  &
!                         ( gridstruct%a11(i,j)*(u(i,j)+u(i,j+1)) +       &
!                           gridstruct%a12(i,j)*(v(i,j)+v(i+1,j)) )
!               enddo
!            enddo
!#endif
        DO j=js,je
          DO i=is,ie
            w(i, j) = w(i, j)/delp(i, j)
          END DO
        END DO
      END IF
      IF (damp_w .GT. 1.e-5) THEN
        DO j=js,je
          DO i=is,ie
            w(i, j) = w(i, j) + dw(i, j)
          END DO
        END DO
      END IF
    END IF
!#ifdef USE_COND
!     do j=js,je
!        do i=is,ie
!           q_con(i,j) = q_con(i,j)/delp(i,j)
!        enddo
!     enddo
!#endif
!-----------------------------
! Compute divergence damping
!-----------------------------
!  damp = dddmp * da_min_c
    IF (.NOT.split_damp) THEN
      CALL COMPUTE_DIV_DAMPING(nord, d2_bg, d4_bg, dddmp, dt, vort, &
&                           ptc, delpc, ke, u, v, uc, vc, ua, va, divg_d&
&                           , wk, gridstruct, flagstruct, bd)
    ELSE
      delpc_tj = 0.0
      ptc_tj = ptc
      vort_tj = 0.0
      delpc_tj = delpc
      ke_tj = ke
      u_tj = u
      uc_tj = uc
      v_tj = v
      vc_tj = vc
      ua_tj = ua
      va_tj = va
      divg_d_tj = divg_d
      wk_tj = wk
      call compute_div_damping( nord,d2_bg,d4_bg,dddmp,dt, &
                                vort,ptc,delpc,ke,u,v,uc,vc,ua,va,divg_d,wk, &
                                gridstruct, flagstruct, bd)
      CALL COMPUTE_DIV_DAMPING(nord_pert, d2_bg_pert, d4_bg_pert, &
&                        dddmp_pert, dt, vort, ptc, delpc, ke, u, v, uc&
&                        , vc, ua, va, divg_d, wk, gridstruct, &
&                        flagstruct, bd)
    END IF
    IF (d_con .GT. 1.e-5) THEN
      DO j=js,je+1
        DO i=is,ie
          ub(i, j) = vort(i, j) - vort(i+1, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          vb(i, j) = vort(i, j) - vort(i, j+1)
        END DO
      END DO
    END IF
! Vorticity transport
    IF (hydrostatic) THEN
      DO j=jsd,jed
        DO i=isd,ied
          vort(i, j) = wk(i, j) + gridstruct%f0(i, j)
        END DO
      END DO
    ELSE IF (flagstruct%do_f3d) THEN
      DO j=jsd,jed
        DO i=isd,ied
          vort(i, j) = wk(i, j) + gridstruct%f0(i, j)*z_rat(i, j)
        END DO
      END DO
    ELSE
      DO j=jsd,jed
        DO i=isd,ied
          vort(i, j) = wk(i, j) + gridstruct%f0(i, j)
        END DO
      END DO
    END IF
    IF (hord_vt .EQ. hord_vt_pert) THEN
      CALL FV_TP_2D(vort, crx_adv, cry_adv, npx, npy, hord_vt, fx, fy&
&                , xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y)
    ELSE
      vort_tj = vort
      fx_tj = fx
      fy_tj = fy
      call fv_tp_2d(vort, crx_adv, cry_adv, npx, npy, hord_vt, fx, fy, &
                    xfx_adv,yfx_adv, gridstruct, bd, ra_x, ra_y)
      CALL FV_TP_2D(vort, crx_adv, cry_adv, npx, npy, hord_vt_pert, fx, &
&             fy, xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y)
    END IF
    DO j=js,je+1
      DO i=is,ie
        u(i, j) = vt(i, j) + ke(i, j) - ke(i+1, j) + fy(i, j)
      END DO
    END DO
    DO j=js,je
      DO i=is,ie+1
        v(i, j) = ut(i, j) + ke(i, j) - ke(i, j+1) - fx(i, j)
      END DO
    END DO
!--------------------------------------------------------
! damping applied to relative vorticity (wk):
    IF (damp_v .GT. 1.e-5) THEN
      pwx1 = damp_v*da_min_c
      pwy1 = nord_v + 1
      damp4 = pwx1**pwy1
      call del6_vt_flux(nord_v, npx, npy, damp4, wk, vort, ut, vt, gridstruct, bd)
      CALL DEL6_VT_FLUX(nord_v, npx, npy, damp4, wk, vort, ut, vt, &
&                 gridstruct, bd)
    END IF
    IF (damp_v_pert .GT. 1.e-5) THEN
      wk_tj = wk
      vort_tj = vort
      ut_tj = ut
      vt_tj = vt
      pwx1 = damp_v_pert*da_min_c
      pwy1 = nord_v_pert + 1
      damp4_pert = pwx1**pwy1
      CALL DEL6_VT_FLUX(nord_v_pert, npx, npy, damp4_pert, wk, vort, ut&
&                 , vt, gridstruct, bd)
    END IF
    IF (d_con .GT. 1.e-5) THEN
      DO j=js,je+1
        DO i=is,ie
          ub(i, j) = (ub(i, j)+vt(i, j))*gridstruct%rdx(i, j)
          fy(i, j) = u(i, j)*gridstruct%rdx(i, j)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          gy(i, j) = fy(i, j)*ub(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          vb(i, j) = (vb(i, j)-ut(i, j))*gridstruct%rdy(i, j)
          fx(i, j) = v(i, j)*gridstruct%rdy(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          gx(i, j) = fx(i, j)*vb(i, j)
        END DO
      END DO
!----------------------------------
! Heating due to damping:
!----------------------------------
      damp = 0.25*d_con
      DO j=js,je
        DO i=is,ie
          u2 = fy(i, j) + fy(i, j+1)
          du2 = ub(i, j) + ub(i, j+1)
          v2 = fx(i, j) + fx(i+1, j)
          dv2 = vb(i, j) + vb(i+1, j)
! Total energy conserving:
! Convert lost KE due to divergence damping to "heat"
          heat_source(i, j) = delp(i, j)*(heat_source(i, j)-damp*&
&           gridstruct%rsin2(i, j)*(ub(i, j)**2+ub(i, j+1)**2+vb(i, j)**&
&           2+vb(i+1, j)**2+2.*(gy(i, j)+gy(i, j+1)+gx(i, j)+gx(i+1, j))&
&           -gridstruct%cosa_s(i, j)*(u2*dv2+v2*du2+du2*dv2)))
        END DO
      END DO
    END IF
! Add diffusive fluxes to the momentum equation:
    IF (damp_v .GT. 1.e-5) THEN
      DO j=js,je+1
        DO i=is,ie
          u(i, j) = u(i, j) + vt(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          v(i, j) = v(i, j) - ut(i, j)
        END DO
      END DO
    END IF
    IF (damp_v_pert .GT. 1.e-5) THEN
      DO j=js,je+1
        DO i=is,ie
          u(i, j) = u(i, j) + vt(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          v(i, j) = v(i, j) - ut(i, j)
        END DO
      END DO
    END IF
  END SUBROUTINE D_SW
  SUBROUTINE COMPUTE_DIV_DAMPING(nord, d2_bg, d4_bg, dddmp, dt, vort, &
&   ptc, delpc, ke, u, v, uc, vc, ua, va, divg_d, wk, gridstruct, &
&   flagstruct, bd)
    IMPLICIT NONE
!InOut Arguments
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
    INTEGER, INTENT(IN) :: nord
    REAL(fvprc), INTENT(IN) :: d2_bg, d4_bg, dddmp, dt
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: vort
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delpc, ptc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(&
&   INOUT) :: ke
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u, vc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v, uc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(&
&   INOUT) :: divg_d
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: wk
!Locals
    REAL(fvprc) :: damp, dd8, damp2, da_min, da_min_c
    INTEGER :: is, ie, js, je, npx, npy, is2, ie1
    LOGICAL :: nested, fill_c
    INTEGER :: i, j, n, n2, nt
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC SQRT
    REAL(fvprc) :: max1
    REAL(fvprc) :: abs0
    REAL(fvprc) :: abs1
    REAL(fvprc) :: max2
    REAL(fvprc) :: abs2
    REAL(fvprc) :: arg1
    REAL(fvprc) :: result1
    REAL(fvprc) :: pwr1
    REAL(fvprc) :: pwx1
    REAL(fvprc) :: y3
    REAL(fvprc) :: y2
    REAL(fvprc) :: y1
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
    da_min = gridstruct%da_min
    da_min_c = gridstruct%da_min_c
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    npx = flagstruct%npx
    npy = flagstruct%npy
    nested = gridstruct%nested
    IF (nested) THEN
      is2 = is
      ie1 = ie + 1
    ELSE
      IF (2 .LT. is) THEN
        is2 = is
      ELSE
        is2 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        ie1 = ie + 1
      ELSE
        ie1 = npx - 1
      END IF
    END IF
    IF (nord .EQ. 0) THEN
!         area ~ dxb*dyb*sin(alpha)
      IF (nested) THEN
        DO j=js,je+1
          DO i=is-1,ie+1
            ptc(i, j) = (u(i, j)-0.5*(va(i, j-1)+va(i, j))*gridstruct%&
&             cosa_v(i, j))*gridstruct%dyc(i, j)*gridstruct%sina_v(i, j)
          END DO
        END DO
        DO j=js-1,je+1
          DO i=is2,ie1
            vort(i, j) = (v(i, j)-0.5*(ua(i-1, j)+ua(i, j))*gridstruct%&
&             cosa_u(i, j))*gridstruct%dxc(i, j)*gridstruct%sina_u(i, j)
          END DO
        END DO
      ELSE
        DO j=js,je+1
          IF (j .EQ. 1 .OR. j .EQ. npy) THEN
            DO i=is-1,ie+1
              IF (vc(i, j) .GT. 0) THEN
                ptc(i, j) = u(i, j)*gridstruct%dyc(i, j)*gridstruct%&
&                 sin_sg(i, j-1, 4)
              ELSE
                ptc(i, j) = u(i, j)*gridstruct%dyc(i, j)*gridstruct%&
&                 sin_sg(i, j, 2)
              END IF
            END DO
          ELSE
            DO i=is-1,ie+1
              ptc(i, j) = (u(i, j)-0.5*(va(i, j-1)+va(i, j))*gridstruct%&
&               cosa_v(i, j))*gridstruct%dyc(i, j)*gridstruct%sina_v(i, &
&               j)
            END DO
          END IF
        END DO
        DO j=js-1,je+1
          DO i=is2,ie1
            vort(i, j) = (v(i, j)-0.5*(ua(i-1, j)+ua(i, j))*gridstruct%&
&             cosa_u(i, j))*gridstruct%dxc(i, j)*gridstruct%sina_u(i, j)
          END DO
          IF (is .EQ. 1) THEN
            IF (uc(1, j) .GT. 0) THEN
              vort(1, j) = v(1, j)*gridstruct%dxc(1, j)*gridstruct%&
&               sin_sg(0, j, 3)
            ELSE
              vort(1, j) = v(1, j)*gridstruct%dxc(1, j)*gridstruct%&
&               sin_sg(1, j, 1)
            END IF
          END IF
          IF (ie + 1 .EQ. npx) THEN
            IF (uc(npx, j) .GT. 0) THEN
              vort(npx, j) = v(npx, j)*gridstruct%dxc(npx, j)*gridstruct&
&               %sin_sg(npx-1, j, 3)
            ELSE
              vort(npx, j) = v(npx, j)*gridstruct%dxc(npx, j)*gridstruct&
&               %sin_sg(npx, j, 1)
            END IF
          END IF
        END DO
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          delpc(i, j) = vort(i, j-1) - vort(i, j) + ptc(i-1, j) - ptc(i&
&           , j)
        END DO
      END DO
! Remove the extra term at the corners:
      IF (sw_corner) delpc(1, 1) = delpc(1, 1) - vort(1, 0)
      IF (se_corner) delpc(npx, 1) = delpc(npx, 1) - vort(npx, 0)
      IF (ne_corner) delpc(npx, npy) = delpc(npx, npy) + vort(npx, npy)
      IF (nw_corner) delpc(1, npy) = delpc(1, npy) + vort(1, npy)
      DO j=js,je+1
        DO i=is,ie+1
          delpc(i, j) = gridstruct%rarea_c(i, j)*delpc(i, j)
          IF (delpc(i, j)*dt .GE. 0.) THEN
            abs2 = delpc(i, j)*dt
          ELSE
            abs2 = -(delpc(i, j)*dt)
          END IF
          y3 = dddmp*abs2
          IF (0.20 .GT. y3) THEN
            y1 = y3
          ELSE
            y1 = 0.20
          END IF
          IF (d2_bg .LT. y1) THEN
            max1 = y1
          ELSE
            max1 = d2_bg
          END IF
          damp = da_min_c*max1
          vort(i, j) = damp*delpc(i, j)
          ke(i, j) = ke(i, j) + vort(i, j)
        END DO
      END DO
    ELSE
!--------------------------
! Higher order divg damping
!--------------------------
      DO j=js,je+1
        DO i=is,ie+1
! Save divergence for external mode filter
          delpc(i, j) = divg_d(i, j)
        END DO
      END DO
! N > 1
      n2 = nord + 1
      DO n=1,nord
        nt = nord - n
        fill_c = nt .NE. 0 .AND. flagstruct%grid_type .LT. 3 .AND. (((&
&         sw_corner .OR. se_corner) .OR. ne_corner) .OR. nw_corner) &
&         .AND. (.NOT.nested)
        IF (fill_c) CALL FILL_CORNERS(divg_d, npx, npy, fill=xdir, bgrid&
&                               =.true.)
        DO j=js-nt,je+1+nt
          DO i=is-1-nt,ie+1+nt
            vc(i, j) = (divg_d(i+1, j)-divg_d(i, j))*gridstruct%divg_u(i&
&             , j)
          END DO
        END DO
        IF (fill_c) CALL FILL_CORNERS(divg_d, npx, npy, fill=ydir, bgrid&
&                               =.true.)
        DO j=js-1-nt,je+1+nt
          DO i=is-nt,ie+1+nt
            uc(i, j) = (divg_d(i, j+1)-divg_d(i, j))*gridstruct%divg_v(i&
&             , j)
          END DO
        END DO
        IF (fill_c) CALL FILL_CORNERS(vc, uc, npx, npy, dgrid=.true., &
&                               vector=.true.)
        DO j=js-nt,je+1+nt
          DO i=is-nt,ie+1+nt
            divg_d(i, j) = uc(i, j-1) - uc(i, j) + vc(i-1, j) - vc(i, j)
          END DO
        END DO
! Remove the extra term at the corners:
        IF (sw_corner) divg_d(1, 1) = divg_d(1, 1) - uc(1, 0)
        IF (se_corner) divg_d(npx, 1) = divg_d(npx, 1) - uc(npx, 0)
        IF (ne_corner) divg_d(npx, npy) = divg_d(npx, npy) + uc(npx, npy&
&           )
        IF (nw_corner) divg_d(1, npy) = divg_d(1, npy) + uc(1, npy)
        IF (.NOT.gridstruct%stretched_grid) THEN
          DO j=js-nt,je+1+nt
            DO i=is-nt,ie+1+nt
              divg_d(i, j) = divg_d(i, j)*gridstruct%rarea_c(i, j)
            END DO
          END DO
        END IF
      END DO
! n-loop
      IF (dddmp .LT. 1.e-5) THEN
        vort(:, :) = 0.
      ELSE IF (flagstruct%grid_type .LT. 3) THEN
! Interpolate relative vort to cell corners
        CALL A2B_ORD4(wk, vort, gridstruct, npx, npy, is, ie, js, je, ng&
&               , .false.)
        DO j=js,je+1
          DO i=is,ie+1
            IF (dt .GE. 0.) THEN
              abs0 = dt
            ELSE
              abs0 = -dt
            END IF
! The following is an approxi form of Smagorinsky diffusion
            arg1 = delpc(i, j)**2 + vort(i, j)**2
            result1 = SQRT(arg1)
            vort(i, j) = abs0*result1
          END DO
        END DO
      ELSE
        IF (dt .GE. 0.) THEN
          abs1 = dt
        ELSE
          abs1 = -dt
        END IF
! Correct form: works only for doubly preiodic domain
        CALL SMAG_CORNER(abs1, u, v, ua, va, vort, bd, npx, npy, &
&                  gridstruct, ng)
      END IF
      IF (gridstruct%stretched_grid) THEN
! Stretched grid with variable damping ~ area
        pwr1 = d4_bg**n2
        dd8 = da_min*pwr1
      ELSE
        pwx1 = da_min_c*d4_bg
        dd8 = pwx1**n2
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          IF (0.20 .GT. dddmp*vort(i, j)) THEN
            y2 = dddmp*vort(i, j)
          ELSE
            y2 = 0.20
          END IF
          IF (d2_bg .LT. y2) THEN
            max2 = y2
          ELSE
            max2 = d2_bg
          END IF
! del-2
          damp2 = da_min_c*max2
          vort(i, j) = damp2*delpc(i, j) + dd8*divg_d(i, j)
          ke(i, j) = ke(i, j) + vort(i, j)
        END DO
      END DO
    END IF
  END SUBROUTINE COMPUTE_DIV_DAMPING
!  Differentiation of compute_div_damping in forward (tangent) mode (with options r8):
!   variations   of useful results: ke uc ptc delpc vc vort divg_d
!                wk
!   with respect to varying inputs: u v ke ua uc ptc delpc va vc
!                divg_d wk
  SUBROUTINE COMPUTE_DIV_DAMPING_TLM(nord, d2_bg, d4_bg, dddmp, dt, &
&   vort, vort_tl, ptc, ptc_tl, delpc, delpc_tl, ke, ke_tl, u, u_tl, v, &
&   v_tl, uc, uc_tl, vc, vc_tl, ua, ua_tl, va, va_tl, divg_d, divg_d_tl&
&   , wk, wk_tl, gridstruct, flagstruct, bd)
    IMPLICIT NONE
!InOut Arguments
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
    INTEGER, INTENT(IN) :: nord
    REAL(fvprc), INTENT(IN) :: d2_bg, d4_bg, dddmp, dt
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: vort
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: vort_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delpc, ptc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delpc_tl, ptc_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(&
&   INOUT) :: ke
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(&
&   INOUT) :: ke_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u, vc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u_tl, vc_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v, uc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v_tl, uc_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: ua_tl, va_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(&
&   INOUT) :: divg_d
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(&
&   INOUT) :: divg_d_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: wk
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: wk_tl
!Locals
    REAL(fvprc) :: damp, dd8, damp2, da_min, da_min_c
    REAL(fvprc) :: damp_tl, damp2_tl
    INTEGER :: is, ie, js, je, npx, npy, is2, ie1
    LOGICAL :: nested, fill_c
    INTEGER :: i, j, n, n2, nt
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC SQRT
    REAL(fvprc) :: max1
    REAL(fvprc) :: max1_tl
    REAL(fvprc) :: abs0
    REAL(fvprc) :: abs1
    REAL(fvprc) :: max2
    REAL(fvprc) :: max2_tl
    REAL(fvprc) :: abs2
    REAL(fvprc) :: abs2_tl
    REAL(fvprc) :: arg1
    REAL(fvprc) :: arg1_tl
    REAL(fvprc) :: result1
    REAL(fvprc) :: result1_tl
    REAL(fvprc) :: pwr1
    REAL(fvprc) :: pwx1
    REAL(fvprc) :: y3_tl
    REAL(fvprc) :: y1_tl
    REAL(fvprc) :: y2_tl
    REAL(fvprc) :: y3
    REAL(fvprc) :: y2
    REAL(fvprc) :: y1
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
    da_min = gridstruct%da_min
    da_min_c = gridstruct%da_min_c
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    npx = flagstruct%npx
    npy = flagstruct%npy
    nested = gridstruct%nested
    IF (nested) THEN
      is2 = is
      ie1 = ie + 1
    ELSE
      IF (2 .LT. is) THEN
        is2 = is
      ELSE
        is2 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        ie1 = ie + 1
      ELSE
        ie1 = npx - 1
      END IF
    END IF
    IF (nord .EQ. 0) THEN
!         area ~ dxb*dyb*sin(alpha)
      IF (nested) THEN
        DO j=js,je+1
          DO i=is-1,ie+1
            ptc_tl(i, j) = gridstruct%dyc(i, j)*gridstruct%sina_v(i, j)*&
&             (u_tl(i, j)-0.5*gridstruct%cosa_v(i, j)*(va_tl(i, j-1)+&
&             va_tl(i, j)))
            ptc(i, j) = (u(i, j)-0.5*(va(i, j-1)+va(i, j))*gridstruct%&
&             cosa_v(i, j))*gridstruct%dyc(i, j)*gridstruct%sina_v(i, j)
          END DO
        END DO
        vort_tl = 0.0_FVPRC
        DO j=js-1,je+1
          DO i=is2,ie1
            vort_tl(i, j) = gridstruct%dxc(i, j)*gridstruct%sina_u(i, j)&
&             *(v_tl(i, j)-0.5*gridstruct%cosa_u(i, j)*(ua_tl(i-1, j)+&
&             ua_tl(i, j)))
            vort(i, j) = (v(i, j)-0.5*(ua(i-1, j)+ua(i, j))*gridstruct%&
&             cosa_u(i, j))*gridstruct%dxc(i, j)*gridstruct%sina_u(i, j)
          END DO
        END DO
      ELSE
        DO j=js,je+1
          IF (j .EQ. 1 .OR. j .EQ. npy) THEN
            DO i=is-1,ie+1
              IF (vc(i, j) .GT. 0) THEN
                ptc_tl(i, j) = gridstruct%dyc(i, j)*gridstruct%sin_sg(i&
&                 , j-1, 4)*u_tl(i, j)
                ptc(i, j) = u(i, j)*gridstruct%dyc(i, j)*gridstruct%&
&                 sin_sg(i, j-1, 4)
              ELSE
                ptc_tl(i, j) = gridstruct%dyc(i, j)*gridstruct%sin_sg(i&
&                 , j, 2)*u_tl(i, j)
                ptc(i, j) = u(i, j)*gridstruct%dyc(i, j)*gridstruct%&
&                 sin_sg(i, j, 2)
              END IF
            END DO
          ELSE
            DO i=is-1,ie+1
              ptc_tl(i, j) = gridstruct%dyc(i, j)*gridstruct%sina_v(i, j&
&               )*(u_tl(i, j)-0.5*gridstruct%cosa_v(i, j)*(va_tl(i, j-1)&
&               +va_tl(i, j)))
              ptc(i, j) = (u(i, j)-0.5*(va(i, j-1)+va(i, j))*gridstruct%&
&               cosa_v(i, j))*gridstruct%dyc(i, j)*gridstruct%sina_v(i, &
&               j)
            END DO
          END IF
        END DO
        vort_tl = 0.0_FVPRC
        DO j=js-1,je+1
          DO i=is2,ie1
            vort_tl(i, j) = gridstruct%dxc(i, j)*gridstruct%sina_u(i, j)&
&             *(v_tl(i, j)-0.5*gridstruct%cosa_u(i, j)*(ua_tl(i-1, j)+&
&             ua_tl(i, j)))
            vort(i, j) = (v(i, j)-0.5*(ua(i-1, j)+ua(i, j))*gridstruct%&
&             cosa_u(i, j))*gridstruct%dxc(i, j)*gridstruct%sina_u(i, j)
          END DO
          IF (is .EQ. 1) THEN
            IF (uc(1, j) .GT. 0) THEN
              vort_tl(1, j) = gridstruct%dxc(1, j)*gridstruct%sin_sg(0, &
&               j, 3)*v_tl(1, j)
              vort(1, j) = v(1, j)*gridstruct%dxc(1, j)*gridstruct%&
&               sin_sg(0, j, 3)
            ELSE
              vort_tl(1, j) = gridstruct%dxc(1, j)*gridstruct%sin_sg(1, &
&               j, 1)*v_tl(1, j)
              vort(1, j) = v(1, j)*gridstruct%dxc(1, j)*gridstruct%&
&               sin_sg(1, j, 1)
            END IF
          END IF
          IF (ie + 1 .EQ. npx) THEN
            IF (uc(npx, j) .GT. 0) THEN
              vort_tl(npx, j) = gridstruct%dxc(npx, j)*gridstruct%sin_sg&
&               (npx-1, j, 3)*v_tl(npx, j)
              vort(npx, j) = v(npx, j)*gridstruct%dxc(npx, j)*gridstruct&
&               %sin_sg(npx-1, j, 3)
            ELSE
              vort_tl(npx, j) = gridstruct%dxc(npx, j)*gridstruct%sin_sg&
&               (npx, j, 1)*v_tl(npx, j)
              vort(npx, j) = v(npx, j)*gridstruct%dxc(npx, j)*gridstruct&
&               %sin_sg(npx, j, 1)
            END IF
          END IF
        END DO
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          delpc_tl(i, j) = vort_tl(i, j-1) - vort_tl(i, j) + ptc_tl(i-1&
&           , j) - ptc_tl(i, j)
          delpc(i, j) = vort(i, j-1) - vort(i, j) + ptc(i-1, j) - ptc(i&
&           , j)
        END DO
      END DO
! Remove the extra term at the corners:
      IF (sw_corner) THEN
        delpc_tl(1, 1) = delpc_tl(1, 1) - vort_tl(1, 0)
        delpc(1, 1) = delpc(1, 1) - vort(1, 0)
      END IF
      IF (se_corner) THEN
        delpc_tl(npx, 1) = delpc_tl(npx, 1) - vort_tl(npx, 0)
        delpc(npx, 1) = delpc(npx, 1) - vort(npx, 0)
      END IF
      IF (ne_corner) THEN
        delpc_tl(npx, npy) = delpc_tl(npx, npy) + vort_tl(npx, npy)
        delpc(npx, npy) = delpc(npx, npy) + vort(npx, npy)
      END IF
      IF (nw_corner) THEN
        delpc_tl(1, npy) = delpc_tl(1, npy) + vort_tl(1, npy)
        delpc(1, npy) = delpc(1, npy) + vort(1, npy)
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          delpc_tl(i, j) = gridstruct%rarea_c(i, j)*delpc_tl(i, j)
          delpc(i, j) = gridstruct%rarea_c(i, j)*delpc(i, j)
          IF (delpc(i, j)*dt .GE. 0.) THEN
            abs2_tl = dt*delpc_tl(i, j)
            abs2 = delpc(i, j)*dt
          ELSE
            abs2_tl = -(dt*delpc_tl(i, j))
            abs2 = -(delpc(i, j)*dt)
          END IF
          y3_tl = dddmp*abs2_tl
          y3 = dddmp*abs2
          IF (0.20 .GT. y3) THEN
            y1_tl = y3_tl
            y1 = y3
          ELSE
            y1 = 0.20
            y1_tl = 0.0_FVPRC
          END IF
          IF (d2_bg .LT. y1) THEN
            max1_tl = y1_tl
            max1 = y1
          ELSE
            max1 = d2_bg
            max1_tl = 0.0_FVPRC
          END IF
          damp_tl = da_min_c*max1_tl
          damp = da_min_c*max1
          vort_tl(i, j) = damp_tl*delpc(i, j) + damp*delpc_tl(i, j)
          vort(i, j) = damp*delpc(i, j)
          ke_tl(i, j) = ke_tl(i, j) + vort_tl(i, j)
          ke(i, j) = ke(i, j) + vort(i, j)
        END DO
      END DO
    ELSE
!--------------------------
! Higher order divg damping
!--------------------------
      DO j=js,je+1
        DO i=is,ie+1
! Save divergence for external mode filter
          delpc_tl(i, j) = divg_d_tl(i, j)
          delpc(i, j) = divg_d(i, j)
        END DO
      END DO
! N > 1
      n2 = nord + 1
      DO n=1,nord
        nt = nord - n
        fill_c = nt .NE. 0 .AND. flagstruct%grid_type .LT. 3 .AND. (((&
&         sw_corner .OR. se_corner) .OR. ne_corner) .OR. nw_corner) &
&         .AND. (.NOT.nested)
        IF (fill_c) CALL FILL_CORNERS_TLM(divg_d, divg_d_tl, npx, npy, &
&                                   fill=xdir, bgrid=.true.)
        DO j=js-nt,je+1+nt
          DO i=is-1-nt,ie+1+nt
            vc_tl(i, j) = gridstruct%divg_u(i, j)*(divg_d_tl(i+1, j)-&
&             divg_d_tl(i, j))
            vc(i, j) = (divg_d(i+1, j)-divg_d(i, j))*gridstruct%divg_u(i&
&             , j)
          END DO
        END DO
        IF (fill_c) CALL FILL_CORNERS_TLM(divg_d, divg_d_tl, npx, npy, &
&                                   fill=ydir, bgrid=.true.)
        DO j=js-1-nt,je+1+nt
          DO i=is-nt,ie+1+nt
            uc_tl(i, j) = gridstruct%divg_v(i, j)*(divg_d_tl(i, j+1)-&
&             divg_d_tl(i, j))
            uc(i, j) = (divg_d(i, j+1)-divg_d(i, j))*gridstruct%divg_v(i&
&             , j)
          END DO
        END DO
        IF (fill_c) CALL FILL_CORNERS_TLM(vc, vc_tl, uc, uc_tl, npx, npy&
&                                   , dgrid=.true., vector=.true.)
        DO j=js-nt,je+1+nt
          DO i=is-nt,ie+1+nt
            divg_d_tl(i, j) = uc_tl(i, j-1) - uc_tl(i, j) + vc_tl(i-1, j&
&             ) - vc_tl(i, j)
            divg_d(i, j) = uc(i, j-1) - uc(i, j) + vc(i-1, j) - vc(i, j)
          END DO
        END DO
! Remove the extra term at the corners:
        IF (sw_corner) THEN
          divg_d_tl(1, 1) = divg_d_tl(1, 1) - uc_tl(1, 0)
          divg_d(1, 1) = divg_d(1, 1) - uc(1, 0)
        END IF
        IF (se_corner) THEN
          divg_d_tl(npx, 1) = divg_d_tl(npx, 1) - uc_tl(npx, 0)
          divg_d(npx, 1) = divg_d(npx, 1) - uc(npx, 0)
        END IF
        IF (ne_corner) THEN
          divg_d_tl(npx, npy) = divg_d_tl(npx, npy) + uc_tl(npx, npy)
          divg_d(npx, npy) = divg_d(npx, npy) + uc(npx, npy)
        END IF
        IF (nw_corner) THEN
          divg_d_tl(1, npy) = divg_d_tl(1, npy) + uc_tl(1, npy)
          divg_d(1, npy) = divg_d(1, npy) + uc(1, npy)
        END IF
        IF (.NOT.gridstruct%stretched_grid) THEN
          DO j=js-nt,je+1+nt
            DO i=is-nt,ie+1+nt
              divg_d_tl(i, j) = gridstruct%rarea_c(i, j)*divg_d_tl(i, j)
              divg_d(i, j) = divg_d(i, j)*gridstruct%rarea_c(i, j)
            END DO
          END DO
        END IF
      END DO
! n-loop
      IF (dddmp .LT. 1.e-5) THEN
        vort(:, :) = 0.
        vort_tl = 0.0_FVPRC
      ELSE IF (flagstruct%grid_type .LT. 3) THEN
! Interpolate relative vort to cell corners
        vort_tl = 0.0_FVPRC
        CALL A2B_ORD4_TLM(wk, wk_tl, vort, vort_tl, gridstruct, npx, &
&                      npy, is, ie, js, je, ng, .false.)
        DO j=js,je+1
          DO i=is,ie+1
            IF (dt .GE. 0.) THEN
              abs0 = dt
            ELSE
              abs0 = -dt
            END IF
! The following is an approxi form of Smagorinsky diffusion
            arg1_tl = 2*delpc(i, j)*delpc_tl(i, j) + 2*vort(i, j)*&
&             vort_tl(i, j)
            arg1 = delpc(i, j)**2 + vort(i, j)**2
            IF (arg1 .EQ. 0.0_FVPRC) THEN
              result1_tl = 0.0_FVPRC
            ELSE
              result1_tl = arg1_tl/(2.0*SQRT(arg1))
            END IF
            result1 = SQRT(arg1)
            vort_tl(i, j) = abs0*result1_tl
            vort(i, j) = abs0*result1
          END DO
        END DO
      ELSE
        IF (dt .GE. 0.) THEN
          abs1 = dt
        ELSE
          abs1 = -dt
        END IF
! Correct form: works only for doubly preiodic domain
        CALL SMAG_CORNER_TLM(abs1, u, u_tl, v, v_tl, ua, va, vort, &
&                         vort_tl, bd, npx, npy, gridstruct, ng)
      END IF
      IF (gridstruct%stretched_grid) THEN
! Stretched grid with variable damping ~ area
        pwr1 = d4_bg**n2
        dd8 = da_min*pwr1
      ELSE
        pwx1 = da_min_c*d4_bg
        dd8 = pwx1**n2
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          IF (0.20 .GT. dddmp*vort(i, j)) THEN
            y2_tl = dddmp*vort_tl(i, j)
            y2 = dddmp*vort(i, j)
          ELSE
            y2 = 0.20
            y2_tl = 0.0_FVPRC
          END IF
          IF (d2_bg .LT. y2) THEN
            max2_tl = y2_tl
            max2 = y2
          ELSE
            max2 = d2_bg
            max2_tl = 0.0_FVPRC
          END IF
! del-2
          damp2_tl = da_min_c*max2_tl
          damp2 = da_min_c*max2
          vort_tl(i, j) = damp2_tl*delpc(i, j) + damp2*delpc_tl(i, j) + &
&           dd8*divg_d_tl(i, j)
          vort(i, j) = damp2*delpc(i, j) + dd8*divg_d(i, j)
          ke_tl(i, j) = ke_tl(i, j) + vort_tl(i, j)
          ke(i, j) = ke(i, j) + vort(i, j)
        END DO
      END DO
    END IF
  END SUBROUTINE COMPUTE_DIV_DAMPING_TLM
!  Differentiation of del6_vt_flux in forward (tangent) mode (with options r8):
!   variations   of useful results: fy2 d2 fx2
!   with respect to varying inputs: q fy2 d2 fx2
  SUBROUTINE DEL6_VT_FLUX_TLM(nord, npx, npy, damp, q, q_tl, d2, d2_tl, &
&   fx2, fx2_tl, fy2, fy2_tl, gridstruct, bd)
    IMPLICIT NONE
! Del-nord damping for the relative vorticity
! nord must be <= 2
!------------------
! nord = 0:   del-2
! nord = 1:   del-4
! nord = 2:   del-6
!------------------
    INTEGER, INTENT(IN) :: nord, npx, npy
    REAL(fvprc), INTENT(IN) :: damp
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! rel. vorticity ghosted on input
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: q_tl(bd%isd:bd%ied, bd%jsd:bd%jed)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
! Work arrays:
    REAL(fvprc), INTENT(OUT) :: d2(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(OUT) :: d2_tl(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(OUT) :: fx2(bd%isd:bd%ied+1, bd%jsd:bd%jed), fy2&
&   (bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(OUT) :: fx2_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed), &
&   fy2_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    INTEGER :: i, j, nt, n, i1, i2, j1, j2
    LOGICAL :: nested
!  real(FVPRC), pointer, dimension(:,:) :: rarea
!  real(FVPRC), pointer, dimension(:,:,:) :: sin_sg
!  real(FVPRC), pointer, dimension(:,:)   :: sina_u, sina_v
!  real(FVPRC), pointer, dimension(:,:) ::  rdxc, rdyc, dx,dy
    INTEGER :: is, ie, js, je
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
!   rarea    => gridstruct%rarea 
!   sin_sg   => gridstruct%sin_sg
!   sina_u   => gridstruct%sina_u
!   sina_v   => gridstruct%sina_v
!   rdxc     => gridstruct%rdxc  
!   rdyc     => gridstruct%rdyc  
!   dx       => gridstruct%dx    
!   dy       => gridstruct%dy    
    nested = gridstruct%nested
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    i1 = is - 1 - nord
    i2 = ie + 1 + nord
    j1 = js - 1 - nord
    j2 = je + 1 + nord
    DO j=j1,j2
      DO i=i1,i2
        d2_tl(i, j) = damp*q_tl(i, j)
        d2(i, j) = damp*q(i, j)
      END DO
    END DO
    IF (nord .GT. 0) CALL COPY_CORNERS_TLM(d2, d2_tl, npx, npy, 1, &
&                                    nested, bd, sw_corner, se_corner, &
&                                    nw_corner, ne_corner)
    DO j=js-nord,je+nord
      DO i=is-nord,ie+nord+1
!        fx2(i,j) = gridstruct%dy(i,j)*gridstruct%sina_u(i,j)*(d2(i-1,j)-d2(i,j))*gridstruct%rdxc(i,j)
        fx2_tl(i, j) = 0.5*(gridstruct%sin_sg(i-1, j, 3)+gridstruct%&
&         sin_sg(i, j, 1))*gridstruct%dy(i, j)*gridstruct%rdxc(i, j)*(&
&         d2_tl(i-1, j)-d2_tl(i, j))
        fx2(i, j) = 0.5*(gridstruct%sin_sg(i-1, j, 3)+gridstruct%sin_sg(&
&         i, j, 1))*gridstruct%dy(i, j)*(d2(i-1, j)-d2(i, j))*gridstruct&
&         %rdxc(i, j)
      END DO
    END DO
    IF (nord .GT. 0) CALL COPY_CORNERS_TLM(d2, d2_tl, npx, npy, 2, &
&                                    nested, bd, sw_corner, se_corner, &
&                                    nw_corner, ne_corner)
    DO j=js-nord,je+nord+1
      DO i=is-nord,ie+nord
!        fy2(i,j) = gridstruct%dx(i,j)*gridstruct%sina_v(i,j)*(d2(i,j-1)-d2(i,j))*gridstruct%rdyc(i,j)
        fy2_tl(i, j) = 0.5*(gridstruct%sin_sg(i, j-1, 4)+gridstruct%&
&         sin_sg(i, j, 2))*gridstruct%dx(i, j)*gridstruct%rdyc(i, j)*(&
&         d2_tl(i, j-1)-d2_tl(i, j))
        fy2(i, j) = 0.5*(gridstruct%sin_sg(i, j-1, 4)+gridstruct%sin_sg(&
&         i, j, 2))*gridstruct%dx(i, j)*(d2(i, j-1)-d2(i, j))*gridstruct&
&         %rdyc(i, j)
      END DO
    END DO
    IF (nord .GT. 0) THEN
      DO n=1,nord
        nt = nord - n
        DO j=js-nt-1,je+nt+1
          DO i=is-nt-1,ie+nt+1
            d2_tl(i, j) = gridstruct%rarea(i, j)*(fx2_tl(i, j)-fx2_tl(i+&
&             1, j)+fy2_tl(i, j)-fy2_tl(i, j+1))
            d2(i, j) = (fx2(i, j)-fx2(i+1, j)+fy2(i, j)-fy2(i, j+1))*&
&             gridstruct%rarea(i, j)
          END DO
        END DO
        CALL COPY_CORNERS_TLM(d2, d2_tl, npx, npy, 1, nested, bd, &
&                       sw_corner, se_corner, nw_corner, ne_corner)
        DO j=js-nt,je+nt
          DO i=is-nt,ie+nt+1
!           fx2(i,j) = gridstruct%dy(i,j)*gridstruct%sina_u(i,j)*(d2(i,j)-d2(i-1,j))*gridstruct%rdxc(i,j)
            fx2_tl(i, j) = 0.5*(gridstruct%sin_sg(i-1, j, 3)+gridstruct%&
&             sin_sg(i, j, 1))*gridstruct%dy(i, j)*gridstruct%rdxc(i, j)&
&             *(d2_tl(i, j)-d2_tl(i-1, j))
            fx2(i, j) = 0.5*(gridstruct%sin_sg(i-1, j, 3)+gridstruct%&
&             sin_sg(i, j, 1))*gridstruct%dy(i, j)*(d2(i, j)-d2(i-1, j))&
&             *gridstruct%rdxc(i, j)
          END DO
        END DO
        CALL COPY_CORNERS_TLM(d2, d2_tl, npx, npy, 2, nested, bd, &
&                       sw_corner, se_corner, nw_corner, ne_corner)
        DO j=js-nt,je+nt+1
          DO i=is-nt,ie+nt
!           fy2(i,j) = gridstruct%dx(i,j)*gridstruct%sina_v(i,j)*(d2(i,j)-d2(i,j-1))*gridstruct%rdyc(i,j)
            fy2_tl(i, j) = 0.5*(gridstruct%sin_sg(i, j-1, 4)+gridstruct%&
&             sin_sg(i, j, 2))*gridstruct%dx(i, j)*gridstruct%rdyc(i, j)&
&             *(d2_tl(i, j)-d2_tl(i, j-1))
            fy2(i, j) = 0.5*(gridstruct%sin_sg(i, j-1, 4)+gridstruct%&
&             sin_sg(i, j, 2))*gridstruct%dx(i, j)*(d2(i, j)-d2(i, j-1))&
&             *gridstruct%rdyc(i, j)
          END DO
        END DO
      END DO
    END IF
  END SUBROUTINE DEL6_VT_FLUX_TLM
  SUBROUTINE DEL6_VT_FLUX(nord, npx, npy, damp, q, d2, fx2, fy2, &
&   gridstruct, bd)
    IMPLICIT NONE
! Del-nord damping for the relative vorticity
! nord must be <= 2
!------------------
! nord = 0:   del-2
! nord = 1:   del-4
! nord = 2:   del-6
!------------------
    INTEGER, INTENT(IN) :: nord, npx, npy
    REAL(fvprc), INTENT(IN) :: damp
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! rel. vorticity ghosted on input
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
! Work arrays:
    REAL(fvprc), INTENT(OUT) :: d2(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(OUT) :: fx2(bd%isd:bd%ied+1, bd%jsd:bd%jed), fy2&
&   (bd%isd:bd%ied, bd%jsd:bd%jed+1)
    INTEGER :: i, j, nt, n, i1, i2, j1, j2
    LOGICAL :: nested
!  real(FVPRC), pointer, dimension(:,:) :: rarea
!  real(FVPRC), pointer, dimension(:,:,:) :: sin_sg
!  real(FVPRC), pointer, dimension(:,:)   :: sina_u, sina_v
!  real(FVPRC), pointer, dimension(:,:) ::  rdxc, rdyc, dx,dy
    INTEGER :: is, ie, js, je
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
!   rarea    => gridstruct%rarea 
!   sin_sg   => gridstruct%sin_sg
!   sina_u   => gridstruct%sina_u
!   sina_v   => gridstruct%sina_v
!   rdxc     => gridstruct%rdxc  
!   rdyc     => gridstruct%rdyc  
!   dx       => gridstruct%dx    
!   dy       => gridstruct%dy    
    nested = gridstruct%nested
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    i1 = is - 1 - nord
    i2 = ie + 1 + nord
    j1 = js - 1 - nord
    j2 = je + 1 + nord
    DO j=j1,j2
      DO i=i1,i2
        d2(i, j) = damp*q(i, j)
      END DO
    END DO
    IF (nord .GT. 0) CALL COPY_CORNERS(d2, npx, npy, 1, nested, bd, &
&                                sw_corner, se_corner, nw_corner, &
&                                ne_corner)
    DO j=js-nord,je+nord
      DO i=is-nord,ie+nord+1
!        fx2(i,j) = gridstruct%dy(i,j)*gridstruct%sina_u(i,j)*(d2(i-1,j)-d2(i,j))*gridstruct%rdxc(i,j)
        fx2(i, j) = 0.5*(gridstruct%sin_sg(i-1, j, 3)+gridstruct%sin_sg(&
&         i, j, 1))*gridstruct%dy(i, j)*(d2(i-1, j)-d2(i, j))*gridstruct&
&         %rdxc(i, j)
      END DO
    END DO
    IF (nord .GT. 0) CALL COPY_CORNERS(d2, npx, npy, 2, nested, bd, &
&                                sw_corner, se_corner, nw_corner, &
&                                ne_corner)
    DO j=js-nord,je+nord+1
      DO i=is-nord,ie+nord
!        fy2(i,j) = gridstruct%dx(i,j)*gridstruct%sina_v(i,j)*(d2(i,j-1)-d2(i,j))*gridstruct%rdyc(i,j)
        fy2(i, j) = 0.5*(gridstruct%sin_sg(i, j-1, 4)+gridstruct%sin_sg(&
&         i, j, 2))*gridstruct%dx(i, j)*(d2(i, j-1)-d2(i, j))*gridstruct&
&         %rdyc(i, j)
      END DO
    END DO
    IF (nord .GT. 0) THEN
      DO n=1,nord
        nt = nord - n
        DO j=js-nt-1,je+nt+1
          DO i=is-nt-1,ie+nt+1
            d2(i, j) = (fx2(i, j)-fx2(i+1, j)+fy2(i, j)-fy2(i, j+1))*&
&             gridstruct%rarea(i, j)
          END DO
        END DO
        CALL COPY_CORNERS(d2, npx, npy, 1, nested, bd, sw_corner, &
&                   se_corner, nw_corner, ne_corner)
        DO j=js-nt,je+nt
          DO i=is-nt,ie+nt+1
!           fx2(i,j) = gridstruct%dy(i,j)*gridstruct%sina_u(i,j)*(d2(i,j)-d2(i-1,j))*gridstruct%rdxc(i,j)
            fx2(i, j) = 0.5*(gridstruct%sin_sg(i-1, j, 3)+gridstruct%&
&             sin_sg(i, j, 1))*gridstruct%dy(i, j)*(d2(i, j)-d2(i-1, j))&
&             *gridstruct%rdxc(i, j)
          END DO
        END DO
        CALL COPY_CORNERS(d2, npx, npy, 2, nested, bd, sw_corner, &
&                   se_corner, nw_corner, ne_corner)
        DO j=js-nt,je+nt+1
          DO i=is-nt,ie+nt
!           fy2(i,j) = gridstruct%dx(i,j)*gridstruct%sina_v(i,j)*(d2(i,j)-d2(i,j-1))*gridstruct%rdyc(i,j)
            fy2(i, j) = 0.5*(gridstruct%sin_sg(i, j-1, 4)+gridstruct%&
&             sin_sg(i, j, 2))*gridstruct%dx(i, j)*(d2(i, j)-d2(i, j-1))&
&             *gridstruct%rdyc(i, j)
          END DO
        END DO
      END DO
    END IF
  END SUBROUTINE DEL6_VT_FLUX
!  Differentiation of divergence_corner in forward (tangent) mode (with options r8):
!   variations   of useful results: divg_d
!   with respect to varying inputs: u v ua va divg_d
  SUBROUTINE DIVERGENCE_CORNER_TLM(u, u_tl, v, v_tl, ua, ua_tl, va, &
&   va_tl, divg_d, divg_d_tl, gridstruct, flagstruct, bd)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(IN) &
&   :: u
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(IN) &
&   :: u_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(IN) &
&   :: v
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(IN) &
&   :: v_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   ua_tl, va_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(OUT&
&   ) :: divg_d
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(OUT&
&   ) :: divg_d_tl
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
! local
    REAL(fvprc) :: uf(bd%is-2:bd%ie+2, bd%js-1:bd%je+2)
    REAL(fvprc) :: uf_tl(bd%is-2:bd%ie+2, bd%js-1:bd%je+2)
    REAL(fvprc) :: vf(bd%is-1:bd%ie+2, bd%js-2:bd%je+2)
    REAL(fvprc) :: vf_tl(bd%is-1:bd%ie+2, bd%js-2:bd%je+2)
    INTEGER :: i, j
    INTEGER :: is2, ie1
!  real(FVPRC), pointer, dimension(:,:) :: rarea_c
!  real(FVPRC), pointer, dimension(:,:,:) :: sin_sg, cos_sg
!  real(FVPRC), pointer, dimension(:,:)   :: cosa_u, cosa_v
!  real(FVPRC), pointer, dimension(:,:)   :: sina_u, sina_v
!  real(FVPRC), pointer, dimension(:,:) ::  dxc,dyc
    INTEGER :: is, ie, js, je
    INTEGER :: npx, npy
    LOGICAL :: nested
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    INTRINSIC MAX
    INTRINSIC MIN
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    npx = flagstruct%npx
    npy = flagstruct%npy
    nested = gridstruct%nested
!      rarea_c    => gridstruct%rarea_c
!      sin_sg     => gridstruct%sin_sg 
!      cos_sg     => gridstruct%cos_sg 
!      cosa_u     => gridstruct%cosa_u 
!      cosa_v     => gridstruct%cosa_v 
!      sina_u     => gridstruct%sina_u 
!      sina_v     => gridstruct%sina_v 
!      dxc        => gridstruct%dxc    
!      dyc        => gridstruct%dyc    
    IF (nested) THEN
      is2 = is
      ie1 = ie + 1
    ELSE
      IF (2 .LT. is) THEN
        is2 = is
      ELSE
        is2 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        ie1 = ie + 1
      ELSE
        ie1 = npx - 1
      END IF
    END IF
    IF (flagstruct%grid_type .EQ. 4) THEN
      uf_tl = 0.0_FVPRC
      DO j=js-1,je+2
        DO i=is-2,ie+2
          uf_tl(i, j) = gridstruct%dyc(i, j)*u_tl(i, j)
          uf(i, j) = u(i, j)*gridstruct%dyc(i, j)
        END DO
      END DO
      vf_tl = 0.0_FVPRC
      DO j=js-2,je+2
        DO i=is-1,ie+2
          vf_tl(i, j) = gridstruct%dxc(i, j)*v_tl(i, j)
          vf(i, j) = v(i, j)*gridstruct%dxc(i, j)
        END DO
      END DO
      DO j=js-1,je+2
        DO i=is-1,ie+2
          divg_d_tl(i, j) = gridstruct%rarea_c(i, j)*(vf_tl(i, j-1)-&
&           vf_tl(i, j)+uf_tl(i-1, j)-uf_tl(i, j))
          divg_d(i, j) = gridstruct%rarea_c(i, j)*(vf(i, j-1)-vf(i, j)+&
&           uf(i-1, j)-uf(i, j))
        END DO
      END DO
    ELSE
      uf_tl = 0.0_FVPRC
!#ifdef USE_UPWIND
!    do j=js,je+1
!!!! TO DO: separate versions for nested and for cubed-sphere
!       if ( (j==1 .or. j==npy)  .and. .not. nested ) then
!            do i=is-1,ie+1
!               if ( va(i,j) + va(i,j-1) > 0. ) then 
!                   uf(i,j) = u(i,j)*gridstruct%dyc(i,j) * gridstruct%sin_sg(i,j-1,4)
!               else
!                   uf(i,j) = u(i,j)*gridstruct%dyc(i,j) * gridstruct%sin_sg(i,j,2)
!               end if
!            enddo
!       else
!            do i=is-1,ie+1
!               uf(i,j) = (u(i,j)-0.5*(va(i,j-1)+va(i,j))*gridstruct%cosa_v(i,j))   &
!                        *gridstruct%dyc(i,j)*gridstruct%sina_v(i,j)
!            enddo
!       endif
!    enddo
!
!    do j=js-1,je+1
!       do i=is2,ie1
!          vf(i,j) = (v(i,j) - 0.5*(ua(i-1,j)+ua(i,j))*gridstruct%cosa_u(i,j))  &
!                    *gridstruct%dxc(i,j)*gridstruct%sina_u(i,j)
!       enddo
!       if (  is == 1 .and. .not. nested) then
!          if (ua(1,j) + ua(0,j) > 0.) then
!             vf(1,j) = v(1,j)*gridstruct%dxc(1,j)*gridstruct%sin_sg(0,j,3)
!          else
!             vf(1,j) = v(1,j)*gridstruct%dxc(1,j)*gridstruct%sin_sg(1,j,1)
!          end if
!       end if
!       if ( (ie+1)==npx .and. .not. nested ) then
!          if (ua(npx-1,j) + ua(npx,j) > 0.) then
!             vf(npx,j) = v(npx,j)*gridstruct%dxc(npx,j)*gridstruct%sin_sg(npx-1,j,3)
!          else
!             vf(npx,j) = v(npx,j)*gridstruct%dxc(npx,j)*gridstruct%sin_sg(npx,j,1)
!          end if
!       end if
!    enddo
!#else
!     9---4---8
!     |       |
!     1   5   3
!     |       |
!     6---2---7
      DO j=js,je+1
        IF (j .EQ. 1 .OR. j .EQ. npy) THEN
          DO i=is-1,ie+1
            uf_tl(i, j) = gridstruct%dyc(i, j)*0.5*(gridstruct%sin_sg(i&
&             , j-1, 4)+gridstruct%sin_sg(i, j, 2))*u_tl(i, j)
            uf(i, j) = u(i, j)*gridstruct%dyc(i, j)*0.5*(gridstruct%&
&             sin_sg(i, j-1, 4)+gridstruct%sin_sg(i, j, 2))
          END DO
        ELSE
          DO i=is-1,ie+1
            uf_tl(i, j) = gridstruct%dyc(i, j)*0.5*(gridstruct%sin_sg(i&
&             , j-1, 4)+gridstruct%sin_sg(i, j, 2))*(u_tl(i, j)-0.25*(&
&             gridstruct%cos_sg(i, j-1, 4)+gridstruct%cos_sg(i, j, 2))*(&
&             va_tl(i, j-1)+va_tl(i, j)))
            uf(i, j) = (u(i, j)-0.25*(va(i, j-1)+va(i, j))*(gridstruct%&
&             cos_sg(i, j-1, 4)+gridstruct%cos_sg(i, j, 2)))*gridstruct%&
&             dyc(i, j)*0.5*(gridstruct%sin_sg(i, j-1, 4)+gridstruct%&
&             sin_sg(i, j, 2))
          END DO
        END IF
      END DO
      vf_tl = 0.0_FVPRC
      DO j=js-1,je+1
        DO i=is2,ie1
          vf_tl(i, j) = gridstruct%dxc(i, j)*0.5*(gridstruct%sin_sg(i-1&
&           , j, 3)+gridstruct%sin_sg(i, j, 1))*(v_tl(i, j)-0.25*(&
&           gridstruct%cos_sg(i-1, j, 3)+gridstruct%cos_sg(i, j, 1))*(&
&           ua_tl(i-1, j)+ua_tl(i, j)))
          vf(i, j) = (v(i, j)-0.25*(ua(i-1, j)+ua(i, j))*(gridstruct%&
&           cos_sg(i-1, j, 3)+gridstruct%cos_sg(i, j, 1)))*gridstruct%&
&           dxc(i, j)*0.5*(gridstruct%sin_sg(i-1, j, 3)+gridstruct%&
&           sin_sg(i, j, 1))
        END DO
        IF (is .EQ. 1) THEN
          vf_tl(1, j) = gridstruct%dxc(1, j)*0.5*(gridstruct%sin_sg(0, j&
&           , 3)+gridstruct%sin_sg(1, j, 1))*v_tl(1, j)
          vf(1, j) = v(1, j)*gridstruct%dxc(1, j)*0.5*(gridstruct%sin_sg&
&           (0, j, 3)+gridstruct%sin_sg(1, j, 1))
        END IF
        IF (ie + 1 .EQ. npx) THEN
          vf_tl(npx, j) = gridstruct%dxc(npx, j)*0.5*(gridstruct%sin_sg(&
&           npx-1, j, 3)+gridstruct%sin_sg(npx, j, 1))*v_tl(npx, j)
          vf(npx, j) = v(npx, j)*gridstruct%dxc(npx, j)*0.5*(gridstruct%&
&           sin_sg(npx-1, j, 3)+gridstruct%sin_sg(npx, j, 1))
        END IF
      END DO
!#endif
      DO j=js,je+1
        DO i=is,ie+1
          divg_d_tl(i, j) = vf_tl(i, j-1) - vf_tl(i, j) + uf_tl(i-1, j) &
&           - uf_tl(i, j)
          divg_d(i, j) = vf(i, j-1) - vf(i, j) + uf(i-1, j) - uf(i, j)
        END DO
      END DO
! Remove the extra term at the corners:
      IF (sw_corner) THEN
        divg_d_tl(1, 1) = divg_d_tl(1, 1) - vf_tl(1, 0)
        divg_d(1, 1) = divg_d(1, 1) - vf(1, 0)
      END IF
      IF (se_corner) THEN
        divg_d_tl(npx, 1) = divg_d_tl(npx, 1) - vf_tl(npx, 0)
        divg_d(npx, 1) = divg_d(npx, 1) - vf(npx, 0)
      END IF
      IF (ne_corner) THEN
        divg_d_tl(npx, npy) = divg_d_tl(npx, npy) + vf_tl(npx, npy)
        divg_d(npx, npy) = divg_d(npx, npy) + vf(npx, npy)
      END IF
      IF (nw_corner) THEN
        divg_d_tl(1, npy) = divg_d_tl(1, npy) + vf_tl(1, npy)
        divg_d(1, npy) = divg_d(1, npy) + vf(1, npy)
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          divg_d_tl(i, j) = gridstruct%rarea_c(i, j)*divg_d_tl(i, j)
          divg_d(i, j) = gridstruct%rarea_c(i, j)*divg_d(i, j)
        END DO
      END DO
    END IF
  END SUBROUTINE DIVERGENCE_CORNER_TLM
  SUBROUTINE DIVERGENCE_CORNER(u, v, ua, va, divg_d, gridstruct, &
&   flagstruct, bd)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(IN) &
&   :: u
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(IN) &
&   :: v
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(OUT&
&   ) :: divg_d
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
! local
    REAL(fvprc) :: uf(bd%is-2:bd%ie+2, bd%js-1:bd%je+2)
    REAL(fvprc) :: vf(bd%is-1:bd%ie+2, bd%js-2:bd%je+2)
    INTEGER :: i, j
    INTEGER :: is2, ie1
!  real(FVPRC), pointer, dimension(:,:) :: rarea_c
!  real(FVPRC), pointer, dimension(:,:,:) :: sin_sg, cos_sg
!  real(FVPRC), pointer, dimension(:,:)   :: cosa_u, cosa_v
!  real(FVPRC), pointer, dimension(:,:)   :: sina_u, sina_v
!  real(FVPRC), pointer, dimension(:,:) ::  dxc,dyc
    INTEGER :: is, ie, js, je
    INTEGER :: npx, npy
    LOGICAL :: nested
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    INTRINSIC MAX
    INTRINSIC MIN
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    npx = flagstruct%npx
    npy = flagstruct%npy
    nested = gridstruct%nested
!      rarea_c    => gridstruct%rarea_c
!      sin_sg     => gridstruct%sin_sg 
!      cos_sg     => gridstruct%cos_sg 
!      cosa_u     => gridstruct%cosa_u 
!      cosa_v     => gridstruct%cosa_v 
!      sina_u     => gridstruct%sina_u 
!      sina_v     => gridstruct%sina_v 
!      dxc        => gridstruct%dxc    
!      dyc        => gridstruct%dyc    
    IF (nested) THEN
      is2 = is
      ie1 = ie + 1
    ELSE
      IF (2 .LT. is) THEN
        is2 = is
      ELSE
        is2 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        ie1 = ie + 1
      ELSE
        ie1 = npx - 1
      END IF
    END IF
    IF (flagstruct%grid_type .EQ. 4) THEN
      DO j=js-1,je+2
        DO i=is-2,ie+2
          uf(i, j) = u(i, j)*gridstruct%dyc(i, j)
        END DO
      END DO
      DO j=js-2,je+2
        DO i=is-1,ie+2
          vf(i, j) = v(i, j)*gridstruct%dxc(i, j)
        END DO
      END DO
      DO j=js-1,je+2
        DO i=is-1,ie+2
          divg_d(i, j) = gridstruct%rarea_c(i, j)*(vf(i, j-1)-vf(i, j)+&
&           uf(i-1, j)-uf(i, j))
        END DO
      END DO
    ELSE
!#ifdef USE_UPWIND
!    do j=js,je+1
!!!! TO DO: separate versions for nested and for cubed-sphere
!       if ( (j==1 .or. j==npy)  .and. .not. nested ) then
!            do i=is-1,ie+1
!               if ( va(i,j) + va(i,j-1) > 0. ) then 
!                   uf(i,j) = u(i,j)*gridstruct%dyc(i,j) * gridstruct%sin_sg(i,j-1,4)
!               else
!                   uf(i,j) = u(i,j)*gridstruct%dyc(i,j) * gridstruct%sin_sg(i,j,2)
!               end if
!            enddo
!       else
!            do i=is-1,ie+1
!               uf(i,j) = (u(i,j)-0.5*(va(i,j-1)+va(i,j))*gridstruct%cosa_v(i,j))   &
!                        *gridstruct%dyc(i,j)*gridstruct%sina_v(i,j)
!            enddo
!       endif
!    enddo
!
!    do j=js-1,je+1
!       do i=is2,ie1
!          vf(i,j) = (v(i,j) - 0.5*(ua(i-1,j)+ua(i,j))*gridstruct%cosa_u(i,j))  &
!                    *gridstruct%dxc(i,j)*gridstruct%sina_u(i,j)
!       enddo
!       if (  is == 1 .and. .not. nested) then
!          if (ua(1,j) + ua(0,j) > 0.) then
!             vf(1,j) = v(1,j)*gridstruct%dxc(1,j)*gridstruct%sin_sg(0,j,3)
!          else
!             vf(1,j) = v(1,j)*gridstruct%dxc(1,j)*gridstruct%sin_sg(1,j,1)
!          end if
!       end if
!       if ( (ie+1)==npx .and. .not. nested ) then
!          if (ua(npx-1,j) + ua(npx,j) > 0.) then
!             vf(npx,j) = v(npx,j)*gridstruct%dxc(npx,j)*gridstruct%sin_sg(npx-1,j,3)
!          else
!             vf(npx,j) = v(npx,j)*gridstruct%dxc(npx,j)*gridstruct%sin_sg(npx,j,1)
!          end if
!       end if
!    enddo
!#else
!     9---4---8
!     |       |
!     1   5   3
!     |       |
!     6---2---7
      DO j=js,je+1
        IF (j .EQ. 1 .OR. j .EQ. npy) THEN
          DO i=is-1,ie+1
            uf(i, j) = u(i, j)*gridstruct%dyc(i, j)*0.5*(gridstruct%&
&             sin_sg(i, j-1, 4)+gridstruct%sin_sg(i, j, 2))
          END DO
        ELSE
          DO i=is-1,ie+1
            uf(i, j) = (u(i, j)-0.25*(va(i, j-1)+va(i, j))*(gridstruct%&
&             cos_sg(i, j-1, 4)+gridstruct%cos_sg(i, j, 2)))*gridstruct%&
&             dyc(i, j)*0.5*(gridstruct%sin_sg(i, j-1, 4)+gridstruct%&
&             sin_sg(i, j, 2))
          END DO
        END IF
      END DO
      DO j=js-1,je+1
        DO i=is2,ie1
          vf(i, j) = (v(i, j)-0.25*(ua(i-1, j)+ua(i, j))*(gridstruct%&
&           cos_sg(i-1, j, 3)+gridstruct%cos_sg(i, j, 1)))*gridstruct%&
&           dxc(i, j)*0.5*(gridstruct%sin_sg(i-1, j, 3)+gridstruct%&
&           sin_sg(i, j, 1))
        END DO
        IF (is .EQ. 1) vf(1, j) = v(1, j)*gridstruct%dxc(1, j)*0.5*(&
&           gridstruct%sin_sg(0, j, 3)+gridstruct%sin_sg(1, j, 1))
        IF (ie + 1 .EQ. npx) vf(npx, j) = v(npx, j)*gridstruct%dxc(npx, &
&           j)*0.5*(gridstruct%sin_sg(npx-1, j, 3)+gridstruct%sin_sg(npx&
&           , j, 1))
      END DO
!#endif
      DO j=js,je+1
        DO i=is,ie+1
          divg_d(i, j) = vf(i, j-1) - vf(i, j) + uf(i-1, j) - uf(i, j)
        END DO
      END DO
! Remove the extra term at the corners:
      IF (sw_corner) divg_d(1, 1) = divg_d(1, 1) - vf(1, 0)
      IF (se_corner) divg_d(npx, 1) = divg_d(npx, 1) - vf(npx, 0)
      IF (ne_corner) divg_d(npx, npy) = divg_d(npx, npy) + vf(npx, npy)
      IF (nw_corner) divg_d(1, npy) = divg_d(1, npy) + vf(1, npy)
      DO j=js,je+1
        DO i=is,ie+1
          divg_d(i, j) = gridstruct%rarea_c(i, j)*divg_d(i, j)
        END DO
      END DO
    END IF
  END SUBROUTINE DIVERGENCE_CORNER
!  Differentiation of divergence_corner_nest in forward (tangent) mode (with options r8):
!   variations   of useful results: divg_d
!   with respect to varying inputs: u v ua va
  SUBROUTINE DIVERGENCE_CORNER_NEST_TLM(u, u_tl, v, v_tl, ua, ua_tl, va&
&   , va_tl, divg_d, divg_d_tl, gridstruct, flagstruct, bd)
    IMPLICIT NONE
!!$       !Edges
!!$
!!$       !West, East
!!$       do j=jsd+1,jed
!!$          divg_d(isd  ,j) = (vf(isd,j-1) - vf(isd,j) + uf(isd,j) - uf(isd+1,j))*gridstruct%rarea_c(isd,j)
!!$          divg_d(ied+1,j) = (vf(ied+1,j-1) - vf(ied+1,j) + uf(ied-1,j) - uf(ied,j))*gridstruct%rarea_c(ied,j)
!!$       end do
!!$
!!$       !North, South
!!$       do i=isd+1,ied
!!$          divg_d(i,jsd  ) = (vf(i,jsd) - vf(i,jsd+1) + uf(i-1,jsd) - uf(i,jsd))*gridstruct%rarea_c(i,jsd)
!!$          divg_d(i,jed+1) = (vf(i,jed-1) - vf(i,jed) + uf(i-1,jed+1) - uf(i,jed+1))*gridstruct%rarea_c(i,jed)
!!$       end do
!!$
!!$       !Corners (just use next corner value)
!!$       divg_d(isd,jsd)   = divg_d(isd+1,jsd+1)
!!$       divg_d(isd,jed+1) = divg_d(isd+1,jed)
!!$       divg_d(ied+1,jsd)   = divg_d(ied,jsd+1)
!!$       divg_d(ied+1,jed+1) = divg_d(ied,jed)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(IN) &
&   :: u
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(IN) &
&   :: u_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(IN) &
&   :: v
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(IN) &
&   :: v_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   ua_tl, va_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(OUT&
&   ) :: divg_d
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(OUT&
&   ) :: divg_d_tl
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
! local
    REAL(fvprc) :: uf(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: uf_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: vf(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: vf_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    INTEGER :: i, j
!  real(FVPRC), pointer, dimension(:,:) :: rarea_c
!  real(FVPRC), pointer, dimension(:,:,:) :: sin_sg, cos_sg
!  real(FVPRC), pointer, dimension(:,:)   :: cosa_u, cosa_v
!  real(FVPRC), pointer, dimension(:,:)   :: sina_u, sina_v
!  real(FVPRC), pointer, dimension(:,:) ::  dxc,dyc
    INTEGER :: isd, ied, jsd, jed
    INTEGER :: npx, npy
    LOGICAL :: nested
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    npx = flagstruct%npx
    npy = flagstruct%npy
    nested = gridstruct%nested
!      rarea_c    => gridstruct%rarea_c
!      sin_sg     => gridstruct%sin_sg 
!      cos_sg     => gridstruct%cos_sg 
!      cosa_u     => gridstruct%cosa_u 
!      cosa_v     => gridstruct%cosa_v 
!      sina_u     => gridstruct%sina_u 
!      sina_v     => gridstruct%sina_v 
!      dxc        => gridstruct%dxc    
!      dyc        => gridstruct%dyc    
    divg_d = 1.e25
    IF (flagstruct%grid_type .EQ. 4) THEN
      uf_tl = 0.0_FVPRC
      DO j=jsd,jed
        DO i=isd,ied
          uf_tl(i, j) = gridstruct%dyc(i, j)*u_tl(i, j)
          uf(i, j) = u(i, j)*gridstruct%dyc(i, j)
        END DO
      END DO
      vf_tl = 0.0_FVPRC
      DO j=jsd,jed
        DO i=isd,ied
          vf_tl(i, j) = gridstruct%dxc(i, j)*v_tl(i, j)
          vf(i, j) = v(i, j)*gridstruct%dxc(i, j)
        END DO
      END DO
      divg_d_tl = 0.0_FVPRC
      DO j=jsd+1,jed
        DO i=isd+1,ied
          divg_d_tl(i, j) = gridstruct%rarea_c(i, j)*(vf_tl(i, j-1)-&
&           vf_tl(i, j)+uf_tl(i-1, j)-uf_tl(i, j))
          divg_d(i, j) = gridstruct%rarea_c(i, j)*(vf(i, j-1)-vf(i, j)+&
&           uf(i-1, j)-uf(i, j))
        END DO
      END DO
    ELSE
      uf_tl = 0.0_FVPRC
      DO j=jsd+1,jed
        DO i=isd,ied
          uf_tl(i, j) = gridstruct%dyc(i, j)*0.5*(gridstruct%sin_sg(i, j&
&           -1, 4)+gridstruct%sin_sg(i, j, 2))*(u_tl(i, j)-0.25*(&
&           gridstruct%cos_sg(i, j-1, 4)+gridstruct%cos_sg(i, j, 2))*(&
&           va_tl(i, j-1)+va_tl(i, j)))
          uf(i, j) = (u(i, j)-0.25*(va(i, j-1)+va(i, j))*(gridstruct%&
&           cos_sg(i, j-1, 4)+gridstruct%cos_sg(i, j, 2)))*gridstruct%&
&           dyc(i, j)*0.5*(gridstruct%sin_sg(i, j-1, 4)+gridstruct%&
&           sin_sg(i, j, 2))
        END DO
      END DO
      vf_tl = 0.0_FVPRC
      DO j=jsd,jed
        DO i=isd+1,ied
          vf_tl(i, j) = gridstruct%dxc(i, j)*0.5*(gridstruct%sin_sg(i-1&
&           , j, 3)+gridstruct%sin_sg(i, j, 1))*(v_tl(i, j)-0.25*(&
&           gridstruct%cos_sg(i-1, j, 3)+gridstruct%cos_sg(i, j, 1))*(&
&           ua_tl(i-1, j)+ua_tl(i, j)))
          vf(i, j) = (v(i, j)-0.25*(ua(i-1, j)+ua(i, j))*(gridstruct%&
&           cos_sg(i-1, j, 3)+gridstruct%cos_sg(i, j, 1)))*gridstruct%&
&           dxc(i, j)*0.5*(gridstruct%sin_sg(i-1, j, 3)+gridstruct%&
&           sin_sg(i, j, 1))
        END DO
      END DO
      divg_d_tl = 0.0_FVPRC
      DO j=jsd+1,jed
        DO i=isd+1,ied
          divg_d_tl(i, j) = gridstruct%rarea_c(i, j)*(vf_tl(i, j-1)-&
&           vf_tl(i, j)+uf_tl(i-1, j)-uf_tl(i, j))
          divg_d(i, j) = (vf(i, j-1)-vf(i, j)+uf(i-1, j)-uf(i, j))*&
&           gridstruct%rarea_c(i, j)
        END DO
      END DO
    END IF
  END SUBROUTINE DIVERGENCE_CORNER_NEST_TLM
  SUBROUTINE DIVERGENCE_CORNER_NEST(u, v, ua, va, divg_d, gridstruct, &
&   flagstruct, bd)
    IMPLICIT NONE
!!$       !Edges
!!$
!!$       !West, East
!!$       do j=jsd+1,jed
!!$          divg_d(isd  ,j) = (vf(isd,j-1) - vf(isd,j) + uf(isd,j) - uf(isd+1,j))*gridstruct%rarea_c(isd,j)
!!$          divg_d(ied+1,j) = (vf(ied+1,j-1) - vf(ied+1,j) + uf(ied-1,j) - uf(ied,j))*gridstruct%rarea_c(ied,j)
!!$       end do
!!$
!!$       !North, South
!!$       do i=isd+1,ied
!!$          divg_d(i,jsd  ) = (vf(i,jsd) - vf(i,jsd+1) + uf(i-1,jsd) - uf(i,jsd))*gridstruct%rarea_c(i,jsd)
!!$          divg_d(i,jed+1) = (vf(i,jed-1) - vf(i,jed) + uf(i-1,jed+1) - uf(i,jed+1))*gridstruct%rarea_c(i,jed)
!!$       end do
!!$
!!$       !Corners (just use next corner value)
!!$       divg_d(isd,jsd)   = divg_d(isd+1,jsd+1)
!!$       divg_d(isd,jed+1) = divg_d(isd+1,jed)
!!$       divg_d(ied+1,jsd)   = divg_d(ied,jsd+1)
!!$       divg_d(ied+1,jed+1) = divg_d(ied,jed)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(IN) &
&   :: u
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(IN) &
&   :: v
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(OUT&
&   ) :: divg_d
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
! local
    REAL(fvprc) :: uf(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: vf(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    INTEGER :: i, j
!  real(FVPRC), pointer, dimension(:,:) :: rarea_c
!  real(FVPRC), pointer, dimension(:,:,:) :: sin_sg, cos_sg
!  real(FVPRC), pointer, dimension(:,:)   :: cosa_u, cosa_v
!  real(FVPRC), pointer, dimension(:,:)   :: sina_u, sina_v
!  real(FVPRC), pointer, dimension(:,:) ::  dxc,dyc
    INTEGER :: isd, ied, jsd, jed
    INTEGER :: npx, npy
    LOGICAL :: nested
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    npx = flagstruct%npx
    npy = flagstruct%npy
    nested = gridstruct%nested
!      rarea_c    => gridstruct%rarea_c
!      sin_sg     => gridstruct%sin_sg 
!      cos_sg     => gridstruct%cos_sg 
!      cosa_u     => gridstruct%cosa_u 
!      cosa_v     => gridstruct%cosa_v 
!      sina_u     => gridstruct%sina_u 
!      sina_v     => gridstruct%sina_v 
!      dxc        => gridstruct%dxc    
!      dyc        => gridstruct%dyc    
    divg_d = 1.e25
    IF (flagstruct%grid_type .EQ. 4) THEN
      DO j=jsd,jed
        DO i=isd,ied
          uf(i, j) = u(i, j)*gridstruct%dyc(i, j)
        END DO
      END DO
      DO j=jsd,jed
        DO i=isd,ied
          vf(i, j) = v(i, j)*gridstruct%dxc(i, j)
        END DO
      END DO
      DO j=jsd+1,jed
        DO i=isd+1,ied
          divg_d(i, j) = gridstruct%rarea_c(i, j)*(vf(i, j-1)-vf(i, j)+&
&           uf(i-1, j)-uf(i, j))
        END DO
      END DO
    ELSE
      DO j=jsd+1,jed
        DO i=isd,ied
          uf(i, j) = (u(i, j)-0.25*(va(i, j-1)+va(i, j))*(gridstruct%&
&           cos_sg(i, j-1, 4)+gridstruct%cos_sg(i, j, 2)))*gridstruct%&
&           dyc(i, j)*0.5*(gridstruct%sin_sg(i, j-1, 4)+gridstruct%&
&           sin_sg(i, j, 2))
        END DO
      END DO
      DO j=jsd,jed
        DO i=isd+1,ied
          vf(i, j) = (v(i, j)-0.25*(ua(i-1, j)+ua(i, j))*(gridstruct%&
&           cos_sg(i-1, j, 3)+gridstruct%cos_sg(i, j, 1)))*gridstruct%&
&           dxc(i, j)*0.5*(gridstruct%sin_sg(i-1, j, 3)+gridstruct%&
&           sin_sg(i, j, 1))
        END DO
      END DO
      DO j=jsd+1,jed
        DO i=isd+1,ied
          divg_d(i, j) = (vf(i, j-1)-vf(i, j)+uf(i-1, j)-uf(i, j))*&
&           gridstruct%rarea_c(i, j)
        END DO
      END DO
    END IF
  END SUBROUTINE DIVERGENCE_CORNER_NEST
  SUBROUTINE SMAG_CORNER(dt, u, v, ua, va, smag_c, bd, npx, npy, &
&   gridstruct, ng)
    IMPLICIT NONE
! Compute the Tension_Shear strain at cell corners for Smagorinsky diffusion
!!!  work only if (grid_type==4)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: dt
    INTEGER, INTENT(IN) :: npx, npy, ng
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(IN) &
&   :: u
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(IN) &
&   :: v
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(OUT) ::&
&   smag_c
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
! local
    REAL(fvprc) :: ut(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: vt(bd%isd:bd%ied, bd%jsd:bd%jed+1)
!  work array
    REAL(fvprc) :: wk(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: sh(bd%isd:bd%ied, bd%jsd:bd%jed)
    INTEGER :: i, j
    INTEGER :: is2, ie1
! real(FVPRC), pointer, dimension(:,:) :: dxc, dyc, dx, dy, rarea, rarea_c
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC SQRT
    REAL(fvprc) :: arg1
    REAL(fvprc) :: result1
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    IF (2 .LT. is) THEN
      is2 = is
    ELSE
      is2 = 2
    END IF
    IF (npx - 1 .GT. ie + 1) THEN
      ie1 = ie + 1
    ELSE
      ie1 = npx - 1
    END IF
! Smag = sqrt [ T**2 + S**2 ]:  unit = 1/s
! where T = du/dx - dv/dy;   S = du/dy + dv/dx
! Compute tension strain at corners:
    DO j=js,je+1
      DO i=is-1,ie+1
        ut(i, j) = u(i, j)*gridstruct%dyc(i, j)
      END DO
    END DO
    DO j=js-1,je+1
      DO i=is,ie+1
        vt(i, j) = v(i, j)*gridstruct%dxc(i, j)
      END DO
    END DO
    DO j=js,je+1
      DO i=is,ie+1
        smag_c(i, j) = gridstruct%rarea_c(i, j)*(vt(i, j-1)-vt(i, j)-ut(&
&         i-1, j)+ut(i, j))
      END DO
    END DO
! Fix the corners?? if grid_type /= 4
! Compute shear strain:
    DO j=jsd,jed+1
      DO i=isd,ied
        vt(i, j) = u(i, j)*gridstruct%dx(i, j)
      END DO
    END DO
    DO j=jsd,jed
      DO i=isd,ied+1
        ut(i, j) = v(i, j)*gridstruct%dy(i, j)
      END DO
    END DO
    DO j=jsd,jed
      DO i=isd,ied
        wk(i, j) = gridstruct%rarea(i, j)*(vt(i, j)-vt(i, j+1)+ut(i, j)-&
&         ut(i+1, j))
      END DO
    END DO
    CALL A2B_ORD4(wk, sh, gridstruct, npx, npy, is, ie, js, je, ng, &
&           .false.)
    DO j=js,je+1
      DO i=is,ie+1
        arg1 = sh(i, j)**2 + smag_c(i, j)**2
        result1 = SQRT(arg1)
        smag_c(i, j) = dt*result1
      END DO
    END DO
  END SUBROUTINE SMAG_CORNER
!  Differentiation of smag_corner in forward (tangent) mode (with options r8):
!   variations   of useful results: smag_c
!   with respect to varying inputs: u v
  SUBROUTINE SMAG_CORNER_TLM(dt, u, u_tl, v, v_tl, ua, va, smag_c, &
&   smag_c_tl, bd, npx, npy, gridstruct, ng)
    IMPLICIT NONE
! Compute the Tension_Shear strain at cell corners for Smagorinsky diffusion
!!!  work only if (grid_type==4)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: dt
    INTEGER, INTENT(IN) :: npx, npy, ng
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(IN) &
&   :: u
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(IN) &
&   :: u_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(IN) &
&   :: v
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(IN) &
&   :: v_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(OUT) ::&
&   smag_c
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(OUT) ::&
&   smag_c_tl
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
! local
    REAL(fvprc) :: ut(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: ut_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: vt(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: vt_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1)
!  work array
    REAL(fvprc) :: wk(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk_tl(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: sh(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: sh_tl(bd%isd:bd%ied, bd%jsd:bd%jed)
    INTEGER :: i, j
    INTEGER :: is2, ie1
! real(FVPRC), pointer, dimension(:,:) :: dxc, dyc, dx, dy, rarea, rarea_c
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC SQRT
    REAL(fvprc) :: arg1
    REAL(fvprc) :: arg1_tl
    REAL(fvprc) :: result1
    REAL(fvprc) :: result1_tl
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    IF (2 .LT. is) THEN
      is2 = is
    ELSE
      is2 = 2
    END IF
    IF (npx - 1 .GT. ie + 1) THEN
      ie1 = ie + 1
    ELSE
      ie1 = npx - 1
    END IF
    ut_tl = 0.0_FVPRC
! Smag = sqrt [ T**2 + S**2 ]:  unit = 1/s
! where T = du/dx - dv/dy;   S = du/dy + dv/dx
! Compute tension strain at corners:
    DO j=js,je+1
      DO i=is-1,ie+1
        ut_tl(i, j) = gridstruct%dyc(i, j)*u_tl(i, j)
        ut(i, j) = u(i, j)*gridstruct%dyc(i, j)
      END DO
    END DO
    vt_tl = 0.0_FVPRC
    DO j=js-1,je+1
      DO i=is,ie+1
        vt_tl(i, j) = gridstruct%dxc(i, j)*v_tl(i, j)
        vt(i, j) = v(i, j)*gridstruct%dxc(i, j)
      END DO
    END DO
    smag_c_tl = 0.0_FVPRC
    DO j=js,je+1
      DO i=is,ie+1
        smag_c_tl(i, j) = gridstruct%rarea_c(i, j)*(vt_tl(i, j-1)-vt_tl(&
&         i, j)-ut_tl(i-1, j)+ut_tl(i, j))
        smag_c(i, j) = gridstruct%rarea_c(i, j)*(vt(i, j-1)-vt(i, j)-ut(&
&         i-1, j)+ut(i, j))
      END DO
    END DO
! Fix the corners?? if grid_type /= 4
! Compute shear strain:
    DO j=jsd,jed+1
      DO i=isd,ied
        vt_tl(i, j) = gridstruct%dx(i, j)*u_tl(i, j)
        vt(i, j) = u(i, j)*gridstruct%dx(i, j)
      END DO
    END DO
    DO j=jsd,jed
      DO i=isd,ied+1
        ut_tl(i, j) = gridstruct%dy(i, j)*v_tl(i, j)
        ut(i, j) = v(i, j)*gridstruct%dy(i, j)
      END DO
    END DO
    wk_tl = 0.0_FVPRC
    DO j=jsd,jed
      DO i=isd,ied
        wk_tl(i, j) = gridstruct%rarea(i, j)*(vt_tl(i, j)-vt_tl(i, j+1)+&
&         ut_tl(i, j)-ut_tl(i+1, j))
        wk(i, j) = gridstruct%rarea(i, j)*(vt(i, j)-vt(i, j+1)+ut(i, j)-&
&         ut(i+1, j))
      END DO
    END DO
    sh_tl = 0.0_FVPRC
    CALL A2B_ORD4_TLM(wk, wk_tl, sh, sh_tl, gridstruct, npx, npy, is&
&                  , ie, js, je, ng, .false.)
    DO j=js,je+1
      DO i=is,ie+1
        arg1_tl = 2*sh(i, j)*sh_tl(i, j) + 2*smag_c(i, j)*smag_c_tl(i, j&
&         )
        arg1 = sh(i, j)**2 + smag_c(i, j)**2
        IF (arg1 .EQ. 0.0_FVPRC) THEN
          result1_tl = 0.0_FVPRC
        ELSE
          result1_tl = arg1_tl/(2.0*SQRT(arg1))
        END IF
        result1 = SQRT(arg1)
        smag_c_tl(i, j) = dt*result1_tl
        smag_c(i, j) = dt*result1
      END DO
    END DO
  END SUBROUTINE SMAG_CORNER_TLM
  SUBROUTINE XTP_U(c, u, v, flux, iord, cosa, dx, rdx, bd, npx, npy, &
&   grid_type, nested)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(IN) :: c(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(OUT) :: flux(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(IN) :: dx(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: rdx(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: cosa(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
    INTEGER, INTENT(IN) :: iord, npx, npy, grid_type
    LOGICAL, INTENT(IN) :: nested
! Local
    LOGICAL :: extm(bd%is-2:bd%ie+2)
    REAL(fvprc) :: al(bd%is-1:bd%ie+2), dm(bd%is-2:bd%ie+2)
    REAL(fvprc) :: bl(bd%is-1:bd%ie+1)
    REAL(fvprc) :: br(bd%is-1:bd%ie+1)
    REAL(fvprc) :: dq(bd%is-3:bd%ie+2)
    REAL(fvprc) :: dl, dr, xt, pmp, lac, cfl
    REAL(fvprc) :: pmp_1, lac_1, pmp_2, lac_2
    REAL(fvprc) :: x0, x1, x0l, x0r
    INTEGER :: i, j
    INTEGER :: is3, ie3
    INTEGER :: is, ie, js, je
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC SIGN
    REAL(fvprc) :: min1
    REAL(fvprc) :: min2
    REAL(fvprc) :: min3
    REAL(fvprc) :: min4
    REAL(fvprc) :: min5
    REAL(fvprc) :: min6
    INTEGER :: max1
    REAL(fvprc) :: min7
    REAL(fvprc) :: min8
    REAL(fvprc) :: min9
    REAL(fvprc) :: min10
    REAL(fvprc) :: min11
    REAL(fvprc) :: min12
    REAL(fvprc) :: min13
    REAL(fvprc) :: abs0
    REAL(fvprc) :: abs1
    REAL(fvprc) :: abs2
    REAL(fvprc) :: max2
    REAL(fvprc) :: min14
    REAL(fvprc) :: max3
    REAL(fvprc) :: min15
    REAL(fvprc) :: max4
    REAL(fvprc) :: min16
    REAL(fvprc) :: max5
    REAL(fvprc) :: min17
    REAL(fvprc) :: max6
    REAL(fvprc) :: min18
    REAL(fvprc) :: max7
    REAL(fvprc) :: min19
    INTEGER :: min20
    REAL(fvprc) :: max8
    REAL(fvprc) :: min21
    REAL(fvprc) :: abs3
    REAL(fvprc) :: abs4
    REAL(fvprc) :: x19
    REAL(fvprc) :: x18
    REAL(fvprc) :: x17
    REAL(fvprc) :: x16
    REAL(fvprc) :: x15
    REAL(fvprc) :: x14
    REAL(fvprc) :: x13
    REAL(fvprc) :: x12
    REAL(fvprc) :: x11
    REAL(fvprc) :: x10
    REAL(fvprc) :: y25
    REAL(fvprc) :: y24
    REAL(fvprc) :: y23
    REAL(fvprc) :: y22
    REAL(fvprc) :: y21
    REAL(fvprc) :: y20
    REAL(fvprc) :: x9
    REAL(fvprc) :: x8
    REAL(fvprc) :: x7
    REAL(fvprc) :: x6
    REAL(fvprc) :: x5
    REAL(fvprc) :: x4
    REAL(fvprc) :: x3
    REAL(fvprc) :: x2
    REAL(fvprc) :: y19
    REAL(fvprc) :: y18
    REAL(fvprc) :: y17
    REAL(fvprc) :: y16
    REAL(fvprc) :: y15
    REAL(fvprc) :: y14
    REAL(fvprc) :: y13
    REAL(fvprc) :: y12
    REAL(fvprc) :: y11
    REAL(fvprc) :: y10
    REAL(fvprc) :: z7
    REAL(fvprc) :: z6
    REAL(fvprc) :: z5
    REAL(fvprc) :: z4
    REAL(fvprc) :: z3
    REAL(fvprc) :: z2
    REAL(fvprc) :: z1
    REAL(fvprc) :: x20
    REAL(fvprc) :: y9
    REAL(fvprc) :: y8
    REAL(fvprc) :: y7
    REAL(fvprc) :: y6
    REAL(fvprc) :: y5
    REAL(fvprc) :: y4
    REAL(fvprc) :: y3
    REAL(fvprc) :: y2
    REAL(fvprc) :: y1
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    IF (nested .OR. grid_type .GT. 3) THEN
      is3 = is - 1
      ie3 = ie + 1
    ELSE
      IF (3 .LT. is - 1) THEN
        is3 = is - 1
      ELSE
        is3 = 3
      END IF
      IF (npx - 3 .GT. ie + 1) THEN
        ie3 = ie + 1
      ELSE
        ie3 = npx - 3
      END IF
    END IF
    SELECT CASE  (iord) 
    CASE (1) 
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            flux(i, j) = u(i-1, j)
          ELSE
            flux(i, j) = u(i, j)
          END IF
        END DO
      END DO
    CASE (333) 
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            flux(i, j) = (2.0*u(i, j)+5.0*u(i-1, j)-u(i-2, j))/6.0 - 0.5&
&             *c(i, j)*rdx(i-1, j)*(u(i, j)-u(i-1, j)) + c(i, j)*rdx(i-1&
&             , j)*c(i, j)*rdx(i-1, j)/6.0*(u(i, j)-2.0*u(i-1, j)+u(i-2&
&             , j))
          ELSE
            flux(i, j) = (2.0*u(i-1, j)+5.0*u(i, j)-u(i+1, j))/6.0 - 0.5&
&             *c(i, j)*rdx(i, j)*(u(i, j)-u(i-1, j)) + c(i, j)*rdx(i, j)&
&             *c(i, j)*rdx(i, j)/6.0*(u(i+1, j)-2.0*u(i, j)+u(i-1, j))
          END IF
        END DO
      END DO
    CASE (2) 
      DO j=js,je+1
        DO i=is-2,ie+2
          xt = 0.25*(u(i+1, j)-u(i-1, j))
          IF (xt .GE. 0.) THEN
            x2 = xt
          ELSE
            x2 = -xt
          END IF
          IF (u(i-1, j) .LT. u(i, j)) THEN
            IF (u(i, j) .LT. u(i+1, j)) THEN
              max2 = u(i+1, j)
            ELSE
              max2 = u(i, j)
            END IF
          ELSE IF (u(i-1, j) .LT. u(i+1, j)) THEN
            max2 = u(i+1, j)
          ELSE
            max2 = u(i-1, j)
          END IF
          y1 = max2 - u(i, j)
          IF (u(i-1, j) .GT. u(i, j)) THEN
            IF (u(i, j) .GT. u(i+1, j)) THEN
              min14 = u(i+1, j)
            ELSE
              min14 = u(i, j)
            END IF
          ELSE IF (u(i-1, j) .GT. u(i+1, j)) THEN
            min14 = u(i+1, j)
          ELSE
            min14 = u(i-1, j)
          END IF
          z1 = u(i, j) - min14
          IF (x2 .GT. y1) THEN
            IF (y1 .GT. z1) THEN
              min1 = z1
            ELSE
              min1 = y1
            END IF
          ELSE IF (x2 .GT. z1) THEN
            min1 = z1
          ELSE
            min1 = x2
          END IF
          dm(i) = SIGN(min1, xt)
        END DO
! Fix slopes near edges:
!!! TO DO: separate versions for nested and for cubed-sphere
        IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
          IF (is .EQ. 1) THEN
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
              dm(0) = 0.
              dm(1) = 0.
            ELSE
              x0l = 0.5*((2.*dx(0, j)+dx(-1, j))*u(0, j)-dx(0, j)*u(-1, &
&               j))/(dx(0, j)+dx(-1, j))
              x0r = 0.5*((2.*dx(1, j)+dx(2, j))*u(1, j)-dx(1, j)*u(2, j)&
&               )/(dx(1, j)+dx(2, j))
              x0 = x0l + x0r
              x1 = s15*u(0, j) + s11*u(-1, j) + s14*dm(-1)
!          dm(0) = u(0,j) - x1
              dm(0) = 0.5*(x0-x1)
              IF (dm(0) .GE. 0.) THEN
                x3 = dm(0)
              ELSE
                x3 = -dm(0)
              END IF
              IF (u(0, j) .LT. x0) THEN
                IF (x0 .LT. x1) THEN
                  max3 = x1
                ELSE
                  max3 = x0
                END IF
              ELSE IF (u(0, j) .LT. x1) THEN
                max3 = x1
              ELSE
                max3 = u(0, j)
              END IF
              y2 = max3 - u(0, j)
              IF (u(0, j) .GT. x0) THEN
                IF (x0 .GT. x1) THEN
                  min15 = x1
                ELSE
                  min15 = x0
                END IF
              ELSE IF (u(0, j) .GT. x1) THEN
                min15 = x1
              ELSE
                min15 = u(0, j)
              END IF
              z2 = u(0, j) - min15
              IF (x3 .GT. y2) THEN
                IF (y2 .GT. z2) THEN
                  min2 = z2
                ELSE
                  min2 = y2
                END IF
              ELSE IF (x3 .GT. z2) THEN
                min2 = z2
              ELSE
                min2 = x3
              END IF
              dm(0) = SIGN(min2, dm(0))
              x1 = s15*u(1, j) + s11*u(2, j) - s14*dm(2)
!          dm(1) = x1 - u(1,j)
              dm(1) = 0.5*(x1-x0)
              IF (dm(1) .GE. 0.) THEN
                x4 = dm(1)
              ELSE
                x4 = -dm(1)
              END IF
              IF (u(1, j) .LT. x0) THEN
                IF (x0 .LT. x1) THEN
                  max4 = x1
                ELSE
                  max4 = x0
                END IF
              ELSE IF (u(1, j) .LT. x1) THEN
                max4 = x1
              ELSE
                max4 = u(1, j)
              END IF
              y3 = max4 - u(1, j)
              IF (u(1, j) .GT. x0) THEN
                IF (x0 .GT. x1) THEN
                  min16 = x1
                ELSE
                  min16 = x0
                END IF
              ELSE IF (u(1, j) .GT. x1) THEN
                min16 = x1
              ELSE
                min16 = u(1, j)
              END IF
              z3 = u(1, j) - min16
              IF (x4 .GT. y3) THEN
                IF (y3 .GT. z3) THEN
                  min3 = z3
                ELSE
                  min3 = y3
                END IF
              ELSE IF (x4 .GT. z3) THEN
                min3 = z3
              ELSE
                min3 = x4
              END IF
              dm(1) = SIGN(min3, dm(1))
            END IF
          END IF
          IF (ie + 1 .EQ. npx) THEN
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
              dm(npx-1) = 0.
              dm(npx) = 0.
            ELSE
              x0l = 0.5*((2.*dx(npx-1, j)+dx(npx-2, j))*u(npx-1, j)-dx(&
&               npx-1, j)*u(npx-2, j))/(dx(npx-1, j)+dx(npx-2, j))
              x0r = 0.5*((2.*dx(npx, j)+dx(npx+1, j))*u(npx, j)-dx(npx, &
&               j)*u(npx+1, j))/(dx(npx, j)+dx(npx+1, j))
              x0 = x0l + x0r
              x1 = s15*u(npx-1, j) + s11*u(npx-2, j) + s14*dm(npx-2)
!          dm(npx-1) = u(npx-1,j) - x1
              dm(npx-1) = 0.5*(x0-x1)
              IF (dm(npx-1) .GE. 0.) THEN
                x5 = dm(npx-1)
              ELSE
                x5 = -dm(npx-1)
              END IF
              IF (u(npx-1, j) .LT. x0) THEN
                IF (x0 .LT. x1) THEN
                  max5 = x1
                ELSE
                  max5 = x0
                END IF
              ELSE IF (u(npx-1, j) .LT. x1) THEN
                max5 = x1
              ELSE
                max5 = u(npx-1, j)
              END IF
              y4 = max5 - u(npx-1, j)
              IF (u(npx-1, j) .GT. x0) THEN
                IF (x0 .GT. x1) THEN
                  min17 = x1
                ELSE
                  min17 = x0
                END IF
              ELSE IF (u(npx-1, j) .GT. x1) THEN
                min17 = x1
              ELSE
                min17 = u(npx-1, j)
              END IF
              z4 = u(npx-1, j) - min17
              IF (x5 .GT. y4) THEN
                IF (y4 .GT. z4) THEN
                  min4 = z4
                ELSE
                  min4 = y4
                END IF
              ELSE IF (x5 .GT. z4) THEN
                min4 = z4
              ELSE
                min4 = x5
              END IF
              dm(npx-1) = SIGN(min4, dm(npx-1))
              x1 = s15*u(npx, j) + s11*u(npx+1, j) - s14*dm(npx+1)
!          dm(npx) = x1 - u(npx,j)
              dm(npx) = 0.5*(x1-x0)
              IF (dm(npx) .GE. 0.) THEN
                x6 = dm(npx)
              ELSE
                x6 = -dm(npx)
              END IF
              IF (u(npx, j) .LT. x0) THEN
                IF (x0 .LT. x1) THEN
                  max6 = x1
                ELSE
                  max6 = x0
                END IF
              ELSE IF (u(npx, j) .LT. x1) THEN
                max6 = x1
              ELSE
                max6 = u(npx, j)
              END IF
              y5 = max6 - u(npx, j)
              IF (u(npx, j) .GT. x0) THEN
                IF (x0 .GT. x1) THEN
                  min18 = x1
                ELSE
                  min18 = x0
                END IF
              ELSE IF (u(npx, j) .GT. x1) THEN
                min18 = x1
              ELSE
                min18 = u(npx, j)
              END IF
              z5 = u(npx, j) - min18
              IF (x6 .GT. y5) THEN
                IF (y5 .GT. z5) THEN
                  min5 = z5
                ELSE
                  min5 = y5
                END IF
              ELSE IF (x6 .GT. z5) THEN
                min5 = z5
              ELSE
                min5 = x6
              END IF
              dm(npx) = SIGN(min5, dm(npx))
            END IF
          END IF
        END IF
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            flux(i, j) = u(i-1, j) + (1.-c(i, j)*rdx(i-1, j))*dm(i-1)
          ELSE
            flux(i, j) = u(i, j) - (1.+c(i, j)*rdx(i, j))*dm(i)
          END IF
        END DO
      END DO
    CASE (4) 
      DO j=js,je+1
        DO i=is-2,ie+2
          xt = 0.25*(u(i+1, j)-u(i-1, j))
          IF (xt .GE. 0.) THEN
            x7 = xt
          ELSE
            x7 = -xt
          END IF
          IF (u(i-1, j) .LT. u(i, j)) THEN
            IF (u(i, j) .LT. u(i+1, j)) THEN
              max7 = u(i+1, j)
            ELSE
              max7 = u(i, j)
            END IF
          ELSE IF (u(i-1, j) .LT. u(i+1, j)) THEN
            max7 = u(i+1, j)
          ELSE
            max7 = u(i-1, j)
          END IF
          y6 = max7 - u(i, j)
          IF (u(i-1, j) .GT. u(i, j)) THEN
            IF (u(i, j) .GT. u(i+1, j)) THEN
              min19 = u(i+1, j)
            ELSE
              min19 = u(i, j)
            END IF
          ELSE IF (u(i-1, j) .GT. u(i+1, j)) THEN
            min19 = u(i+1, j)
          ELSE
            min19 = u(i-1, j)
          END IF
          z6 = u(i, j) - min19
          IF (x7 .GT. y6) THEN
            IF (y6 .GT. z6) THEN
              min6 = z6
            ELSE
              min6 = y6
            END IF
          ELSE IF (x7 .GT. z6) THEN
            min6 = z6
          ELSE
            min6 = x7
          END IF
          dm(i) = SIGN(min6, xt)
        END DO
        IF (3 .LT. is - 1) THEN
          max1 = is - 1
        ELSE
          max1 = 3
        END IF
        IF (npx - 2 .GT. ie + 2) THEN
          min20 = ie + 2
        ELSE
          min20 = npx - 2
        END IF
        DO i=max1,min20
          al(i) = 0.5*(u(i-1, j)+u(i, j)) + r3*(dm(i-1)-dm(i))
        END DO
! Fix slopes near edges:
        IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
          IF (is .EQ. 1) THEN
            x0l = 0.5*((2.*dx(0, j)+dx(-1, j))*u(0, j)-dx(0, j)*u(-1, j)&
&             )/(dx(0, j)+dx(-1, j))
            x0r = 0.5*((2.*dx(1, j)+dx(2, j))*u(1, j)-dx(1, j)*u(2, j))/&
&             (dx(1, j)+dx(2, j))
            x0 = x0l + x0r
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
              dm(0) = 0.
              dm(1) = 0.
              al(0) = 0.5*(u(-1, j)+u(0, j)) + r3*dm(-1)
              al(1) = x0
              al(2) = 0.5*(u(1, j)+u(2, j)) - r3*dm(2)
            ELSE
              x1 = s15*u(1, j) + s11*u(2, j) - s14*dm(2)
              dm(1) = 0.5*(x1-x0)
!          dm(1) = sign(min(abs(dm(1)), max(u(1,j), x0, x1) - u(1,j),   &
!                              u(1,j) - min(u(1,j), x0, x1)), dm(1))
              x1 = s15*u(0, j) + s11*u(-1, j) + s14*dm(-1)
              dm(0) = 0.5*(x0-x1)
!          dm(0) = sign(min(abs(dm(0)), max(u(0,j), x0, x1) - u(0,j),   &
!                              u(0,j) - min(u(0,j), x0, x1)), dm(0))
              al(0) = 0.5*(u(-1, j)+u(0, j)) + r3*(dm(-1)-dm(0))
              al(1) = x0
              al(2) = 0.5*(u(1, j)+u(2, j)) + r3*(dm(1)-dm(2))
            END IF
          END IF
          IF (ie + 1 .EQ. npx) THEN
            x0l = 0.5*((2.*dx(npx-1, j)+dx(npx-2, j))*u(npx-1, j)-dx(npx&
&             -1, j)*u(npx-2, j))/(dx(npx-1, j)+dx(npx-2, j))
            x0r = 0.5*((2.*dx(npx, j)+dx(npx+1, j))*u(npx, j)-dx(npx, j)&
&             *u(npx+1, j))/(dx(npx, j)+dx(npx+1, j))
            x0 = x0l + x0r
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
              dm(npx-1) = 0.
              dm(npx) = 0.
              al(npx-1) = 0.5*(u(npx-2, j)+u(npx-1, j)) + r3*dm(npx-2)
              al(npx) = x0
              al(npx+1) = 0.5*(u(npx, j)+u(npx+1, j)) - r3*dm(npx+1)
            ELSE
              x1 = s15*u(npx-1, j) + s11*u(npx-2, j) + s14*dm(npx-2)
              dm(npx-1) = 0.5*(x0-x1)
!          dm(npx-1) = sign(min(abs(dm(npx-1)), max(u(npx-1,j), x0, x1) - u(npx-1,j),  &
!                                  u(npx-1,j) - min(u(npx-1,j), x0, x1)), dm(npx-1))
              x1 = s15*u(npx, j) + s11*u(npx+1, j) - s14*dm(npx+1)
              dm(npx) = 0.5*(x1-x0)
!          dm(npx) = sign(min(abs(dm(npx)), max(u(npx,j), x0, x1) - u(npx,j),   &
!                                u(npx,j) - min(u(npx,j), x0, x1)), dm(npx))
              al(npx-1) = 0.5*(u(npx-2, j)+u(npx-1, j)) + r3*(dm(npx-2)-&
&               dm(npx-1))
              al(npx) = x0
              al(npx+1) = 0.5*(u(npx, j)+u(npx+1, j)) + r3*(dm(npx)-dm(&
&               npx+1))
            END IF
          END IF
        END IF
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            xt = 2.*dm(i-1)
            IF (xt .GE. 0.) THEN
              x8 = xt
            ELSE
              x8 = -xt
            END IF
            IF (al(i-1) - u(i-1, j) .GE. 0.) THEN
              y7 = al(i-1) - u(i-1, j)
            ELSE
              y7 = -(al(i-1)-u(i-1, j))
            END IF
            IF (x8 .GT. y7) THEN
              min7 = y7
            ELSE
              min7 = x8
            END IF
            dl = SIGN(min7, xt)
            IF (xt .GE. 0.) THEN
              x9 = xt
            ELSE
              x9 = -xt
            END IF
            IF (al(i) - u(i-1, j) .GE. 0.) THEN
              y8 = al(i) - u(i-1, j)
            ELSE
              y8 = -(al(i)-u(i-1, j))
            END IF
            IF (x9 .GT. y8) THEN
              min8 = y8
            ELSE
              min8 = x9
            END IF
            dr = SIGN(min8, xt)
            cfl = c(i, j)*rdx(i-1, j)
            flux(i, j) = u(i-1, j) + (1.-cfl)*(dr+cfl*(dl-dr))
          ELSE
            xt = 2.*dm(i)
            IF (xt .GE. 0.) THEN
              x10 = xt
            ELSE
              x10 = -xt
            END IF
            IF (al(i) - u(i, j) .GE. 0.) THEN
              y9 = al(i) - u(i, j)
            ELSE
              y9 = -(al(i)-u(i, j))
            END IF
            IF (x10 .GT. y9) THEN
              min9 = y9
            ELSE
              min9 = x10
            END IF
            dl = SIGN(min9, xt)
            IF (xt .GE. 0.) THEN
              x11 = xt
            ELSE
              x11 = -xt
            END IF
            IF (al(i+1) - u(i, j) .GE. 0.) THEN
              y10 = al(i+1) - u(i, j)
            ELSE
              y10 = -(al(i+1)-u(i, j))
            END IF
            IF (x11 .GT. y10) THEN
              min10 = y10
            ELSE
              min10 = x11
            END IF
            dr = SIGN(min10, xt)
            cfl = c(i, j)*rdx(i, j)
            flux(i, j) = u(i, j) - (1.+cfl)*(dl+cfl*(dl-dr))
          END IF
        END DO
      END DO
    CASE (6) 
      DO j=js,je+1
!            is3 = max(3,is-1) ; ie3 = min(npx-3,ie+1)
        DO i=is3,ie3+1
          al(i) = p1*(u(i-1, j)+u(i, j)) + p2*(u(i-2, j)+u(i+1, j))
        END DO
        DO i=is3,ie3
          bl(i) = al(i) - u(i, j)
          br(i) = al(i+1) - u(i, j)
        END DO
        IF (.NOT.nested .AND. grid_type .LT. 3) THEN
          IF (is .EQ. 1) THEN
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
! out
              bl(0) = 0.
! edge
              br(0) = 0.
! edge
              bl(1) = 0.
! in
              br(1) = 0.
              bl(2) = c3*u(1, j) + c2*u(2, j) + c1*u(3, j) - u(2, j)
            ELSE
              bl(0) = c1*u(-2, j) + c2*u(-1, j) + c3*u(0, j) - u(0, j)
              xt = 0.5*(((2.*dx(0, j)+dx(-1, j))*u(0, j)-dx(0, j)*u(-1, &
&               j))/(dx(0, j)+dx(-1, j))+((2.*dx(1, j)+dx(2, j))*u(1, j)&
&               -dx(1, j)*u(2, j))/(dx(1, j)+dx(2, j)))
              br(0) = xt - u(0, j)
              bl(1) = xt - u(1, j)
              xt = c3*u(1, j) + c2*u(2, j) + c1*u(3, j)
              br(1) = xt - u(1, j)
              bl(2) = xt - u(2, j)
            END IF
            br(2) = al(3) - u(2, j)
          END IF
          IF (ie + 1 .EQ. npx) THEN
            bl(npx-2) = al(npx-2) - u(npx-2, j)
            xt = c1*u(npx-3, j) + c2*u(npx-2, j) + c3*u(npx-1, j)
            br(npx-2) = xt - u(npx-2, j)
            bl(npx-1) = xt - u(npx-1, j)
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
! in
              bl(npx-1) = 0.
! edge
              br(npx-1) = 0.
! edge
              bl(npx) = 0.
! out
              br(npx) = 0.
            ELSE
              xt = 0.5*(((2.*dx(npx-1, j)+dx(npx-2, j))*u(npx-1, j)-dx(&
&               npx-1, j)*u(npx-2, j))/(dx(npx-1, j)+dx(npx-2, j))+((2.*&
&               dx(npx, j)+dx(npx+1, j))*u(npx, j)-dx(npx, j)*u(npx+1, j&
&               ))/(dx(npx, j)+dx(npx+1, j)))
              br(npx-1) = xt - u(npx-1, j)
              bl(npx) = xt - u(npx, j)
              br(npx) = c3*u(npx, j) + c2*u(npx+1, j) + c1*u(npx+2, j) -&
&               u(npx, j)
            END IF
          END IF
        END IF
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            cfl = c(i, j)*rdx(i-1, j)
            flux(i, j) = u(i-1, j) + (1.-cfl)*(br(i-1)-cfl*(bl(i-1)+br(i&
&             -1)))
          ELSE
            cfl = c(i, j)*rdx(i, j)
            flux(i, j) = u(i, j) + (1.+cfl)*(bl(i)+cfl*(bl(i)+br(i)))
          END IF
        END DO
      END DO
    CASE DEFAULT
! iord = 8, 9, 10
      DO j=js,je+1
        DO i=is-2,ie+2
          xt = 0.25*(u(i+1, j)-u(i-1, j))
          IF (xt .GE. 0.) THEN
            x12 = xt
          ELSE
            x12 = -xt
          END IF
          IF (u(i-1, j) .LT. u(i, j)) THEN
            IF (u(i, j) .LT. u(i+1, j)) THEN
              max8 = u(i+1, j)
            ELSE
              max8 = u(i, j)
            END IF
          ELSE IF (u(i-1, j) .LT. u(i+1, j)) THEN
            max8 = u(i+1, j)
          ELSE
            max8 = u(i-1, j)
          END IF
          y11 = max8 - u(i, j)
          IF (u(i-1, j) .GT. u(i, j)) THEN
            IF (u(i, j) .GT. u(i+1, j)) THEN
              min21 = u(i+1, j)
            ELSE
              min21 = u(i, j)
            END IF
          ELSE IF (u(i-1, j) .GT. u(i+1, j)) THEN
            min21 = u(i+1, j)
          ELSE
            min21 = u(i-1, j)
          END IF
          z7 = u(i, j) - min21
          IF (x12 .GT. y11) THEN
            IF (y11 .GT. z7) THEN
              min11 = z7
            ELSE
              min11 = y11
            END IF
          ELSE IF (x12 .GT. z7) THEN
            min11 = z7
          ELSE
            min11 = x12
          END IF
          dm(i) = SIGN(min11, xt)
        END DO
        DO i=is-3,ie+2
          dq(i) = u(i+1, j) - u(i, j)
        END DO
        IF (grid_type .LT. 3) THEN
          DO i=is3,ie3+1
            al(i) = 0.5*(u(i-1, j)+u(i, j)) + r3*(dm(i-1)-dm(i))
          END DO
! Perturbation form:
          IF (iord .EQ. 8) THEN
            DO i=is3,ie3
              xt = 2.*dm(i)
              IF (xt .GE. 0.) THEN
                x13 = xt
              ELSE
                x13 = -xt
              END IF
              IF (al(i) - u(i, j) .GE. 0.) THEN
                y12 = al(i) - u(i, j)
              ELSE
                y12 = -(al(i)-u(i, j))
              END IF
              IF (x13 .GT. y12) THEN
                min12 = y12
              ELSE
                min12 = x13
              END IF
              bl(i) = -SIGN(min12, xt)
              IF (xt .GE. 0.) THEN
                x14 = xt
              ELSE
                x14 = -xt
              END IF
              IF (al(i+1) - u(i, j) .GE. 0.) THEN
                y13 = al(i+1) - u(i, j)
              ELSE
                y13 = -(al(i+1)-u(i, j))
              END IF
              IF (x14 .GT. y13) THEN
                min13 = y13
              ELSE
                min13 = x14
              END IF
              br(i) = SIGN(min13, xt)
            END DO
          ELSE IF (iord .EQ. 9) THEN
            DO i=is3,ie3
              pmp_1 = -(2.*dq(i))
              lac_1 = pmp_1 + 1.5*dq(i+1)
              IF (0. .LT. pmp_1) THEN
                IF (pmp_1 .LT. lac_1) THEN
                  x15 = lac_1
                ELSE
                  x15 = pmp_1
                END IF
              ELSE IF (0. .LT. lac_1) THEN
                x15 = lac_1
              ELSE
                x15 = 0.
              END IF
              IF (0. .GT. pmp_1) THEN
                IF (pmp_1 .GT. lac_1) THEN
                  y20 = lac_1
                ELSE
                  y20 = pmp_1
                END IF
              ELSE IF (0. .GT. lac_1) THEN
                y20 = lac_1
              ELSE
                y20 = 0.
              END IF
              IF (al(i) - u(i, j) .LT. y20) THEN
                y14 = y20
              ELSE
                y14 = al(i) - u(i, j)
              END IF
              IF (x15 .GT. y14) THEN
                bl(i) = y14
              ELSE
                bl(i) = x15
              END IF
              pmp_2 = 2.*dq(i-1)
              lac_2 = pmp_2 - 1.5*dq(i-2)
              IF (0. .LT. pmp_2) THEN
                IF (pmp_2 .LT. lac_2) THEN
                  x16 = lac_2
                ELSE
                  x16 = pmp_2
                END IF
              ELSE IF (0. .LT. lac_2) THEN
                x16 = lac_2
              ELSE
                x16 = 0.
              END IF
              IF (0. .GT. pmp_2) THEN
                IF (pmp_2 .GT. lac_2) THEN
                  y21 = lac_2
                ELSE
                  y21 = pmp_2
                END IF
              ELSE IF (0. .GT. lac_2) THEN
                y21 = lac_2
              ELSE
                y21 = 0.
              END IF
              IF (al(i+1) - u(i, j) .LT. y21) THEN
                y15 = y21
              ELSE
                y15 = al(i+1) - u(i, j)
              END IF
              IF (x16 .GT. y15) THEN
                br(i) = y15
              ELSE
                br(i) = x16
              END IF
            END DO
          ELSE IF (iord .EQ. 10) THEN
            DO i=is3,ie3
              bl(i) = al(i) - u(i, j)
              br(i) = al(i+1) - u(i, j)
              IF (dm(i) .GE. 0.) THEN
                abs0 = dm(i)
              ELSE
                abs0 = -dm(i)
              END IF
!             if ( abs(dm(i-1))+abs(dm(i))+abs(dm(i+1)) < near_zero ) then
              IF (abs0 .LT. near_zero) THEN
                IF (dm(i-1) .GE. 0.) THEN
                  abs1 = dm(i-1)
                ELSE
                  abs1 = -dm(i-1)
                END IF
                IF (dm(i+1) .GE. 0.) THEN
                  abs3 = dm(i+1)
                ELSE
                  abs3 = -dm(i+1)
                END IF
                IF (abs1 + abs3 .LT. near_zero) THEN
! 2-delta-x structure detected within 3 cells
                  bl(i) = 0.
                  br(i) = 0.
                END IF
              ELSE
                IF (3.*(bl(i)+br(i)) .GE. 0.) THEN
                  abs2 = 3.*(bl(i)+br(i))
                ELSE
                  abs2 = -(3.*(bl(i)+br(i)))
                END IF
                IF (bl(i) - br(i) .GE. 0.) THEN
                  abs4 = bl(i) - br(i)
                ELSE
                  abs4 = -(bl(i)-br(i))
                END IF
                IF (abs2 .GT. abs4) THEN
                  pmp_1 = -(2.*dq(i))
                  lac_1 = pmp_1 + 1.5*dq(i+1)
                  IF (0. .LT. pmp_1) THEN
                    IF (pmp_1 .LT. lac_1) THEN
                      x17 = lac_1
                    ELSE
                      x17 = pmp_1
                    END IF
                  ELSE IF (0. .LT. lac_1) THEN
                    x17 = lac_1
                  ELSE
                    x17 = 0.
                  END IF
                  IF (0. .GT. pmp_1) THEN
                    IF (pmp_1 .GT. lac_1) THEN
                      y22 = lac_1
                    ELSE
                      y22 = pmp_1
                    END IF
                  ELSE IF (0. .GT. lac_1) THEN
                    y22 = lac_1
                  ELSE
                    y22 = 0.
                  END IF
                  IF (bl(i) .LT. y22) THEN
                    y16 = y22
                  ELSE
                    y16 = bl(i)
                  END IF
                  IF (x17 .GT. y16) THEN
                    bl(i) = y16
                  ELSE
                    bl(i) = x17
                  END IF
                  pmp_2 = 2.*dq(i-1)
                  lac_2 = pmp_2 - 1.5*dq(i-2)
                  IF (0. .LT. pmp_2) THEN
                    IF (pmp_2 .LT. lac_2) THEN
                      x18 = lac_2
                    ELSE
                      x18 = pmp_2
                    END IF
                  ELSE IF (0. .LT. lac_2) THEN
                    x18 = lac_2
                  ELSE
                    x18 = 0.
                  END IF
                  IF (0. .GT. pmp_2) THEN
                    IF (pmp_2 .GT. lac_2) THEN
                      y23 = lac_2
                    ELSE
                      y23 = pmp_2
                    END IF
                  ELSE IF (0. .GT. lac_2) THEN
                    y23 = lac_2
                  ELSE
                    y23 = 0.
                  END IF
                  IF (br(i) .LT. y23) THEN
                    y17 = y23
                  ELSE
                    y17 = br(i)
                  END IF
                  IF (x18 .GT. y17) THEN
                    br(i) = y17
                  ELSE
                    br(i) = x18
                  END IF
                END IF
              END IF
            END DO
          ELSE
! un-limited:
            DO i=is3,ie3
              bl(i) = al(i) - u(i, j)
              br(i) = al(i+1) - u(i, j)
            END DO
          END IF
!--------------
! fix the edges
!--------------
!!! TO DO: separate versions for nested and for cubed-sphere
          IF (is .EQ. 1 .AND. (.NOT.nested)) THEN
            br(2) = al(3) - u(2, j)
            xt = s15*u(1, j) + s11*u(2, j) - s14*dm(2)
            bl(2) = xt - u(2, j)
            br(1) = xt - u(1, j)
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
! out
              bl(0) = 0.
! edge
              br(0) = 0.
! edge
              bl(1) = 0.
! in
              br(1) = 0.
            ELSE
              bl(0) = s14*dm(-1) - s11*dq(-1)
!---------------------------------------------------------------
!#ifdef ONE_SIDE
!                 xt = t14*u(0,j) + t12*u(-1,j) + t15*u(-2,j)
!                 br(0) = 2.*xt - u(0,j)
!                 xt = t14*u(1,j) + t12*u(2,j) + t15*u(3,j)
!                 bl(1) = 2.*xt - u(1,j)
!#else
              x0l = 0.5*((2.*dx(0, j)+dx(-1, j))*u(0, j)-dx(0, j)*u(-1, &
&               j))/(dx(0, j)+dx(-1, j))
              x0r = 0.5*((2.*dx(1, j)+dx(2, j))*u(1, j)-dx(1, j)*u(2, j)&
&               )/(dx(1, j)+dx(2, j))
              xt = x0l + x0r
              br(0) = xt - u(0, j)
              bl(1) = xt - u(1, j)
!#endif
!---------------------------------------------------------------
            END IF
            CALL PERT_PPM(1, u(2, j), bl(2), br(2), -1)
          END IF
          IF (ie + 1 .EQ. npx .AND. (.NOT.nested)) THEN
            bl(npx-2) = al(npx-2) - u(npx-2, j)
            xt = s15*u(npx-1, j) + s11*u(npx-2, j) + s14*dm(npx-2)
            br(npx-2) = xt - u(npx-2, j)
            bl(npx-1) = xt - u(npx-1, j)
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
! in
              bl(npx-1) = 0.
! edge
              br(npx-1) = 0.
! edge
              bl(npx) = 0.
! out
              br(npx) = 0.
            ELSE
              br(npx) = s11*dq(npx) - s14*dm(npx+1)
!#ifdef ONE_SIDE
!                 xt = t14*u(npx-1,j) + t12*u(npx-2,j) + t15*u(npx-3,j)
!                 br(npx-1) = 2.*xt - u(npx-1,j)
!                 xt = t14*u(npx,j) + t12*u(npx+1,j) + t15*u(npx+2,j)
!                 bl(npx  ) = 2.*xt - u(npx  ,j)
!#else
              x0l = 0.5*((2.*dx(npx-1, j)+dx(npx-2, j))*u(npx-1, j)-dx(&
&               npx-1, j)*u(npx-2, j))/(dx(npx-1, j)+dx(npx-2, j))
              x0r = 0.5*((2.*dx(npx, j)+dx(npx+1, j))*u(npx, j)-dx(npx, &
&               j)*u(npx+1, j))/(dx(npx, j)+dx(npx+1, j))
              xt = x0l + x0r
              br(npx-1) = xt - u(npx-1, j)
              bl(npx) = xt - u(npx, j)
!#endif
            END IF
            CALL PERT_PPM(1, u(npx-2, j), bl(npx-2), br(npx-2), -1)
          END IF
        ELSE
          DO i=is-1,ie+2
            al(i) = 0.5*(u(i-1, j)+u(i, j)) + r3*(dm(i-1)-dm(i))
          END DO
          DO i=is-1,ie+1
            pmp = -(2.*dq(i))
            lac = pmp + 1.5*dq(i+1)
            IF (0. .LT. pmp) THEN
              IF (pmp .LT. lac) THEN
                x19 = lac
              ELSE
                x19 = pmp
              END IF
            ELSE IF (0. .LT. lac) THEN
              x19 = lac
            ELSE
              x19 = 0.
            END IF
            IF (0. .GT. pmp) THEN
              IF (pmp .GT. lac) THEN
                y24 = lac
              ELSE
                y24 = pmp
              END IF
            ELSE IF (0. .GT. lac) THEN
              y24 = lac
            ELSE
              y24 = 0.
            END IF
            IF (al(i) - u(i, j) .LT. y24) THEN
              y18 = y24
            ELSE
              y18 = al(i) - u(i, j)
            END IF
            IF (x19 .GT. y18) THEN
              bl(i) = y18
            ELSE
              bl(i) = x19
            END IF
            pmp = 2.*dq(i-1)
            lac = pmp - 1.5*dq(i-2)
            IF (0. .LT. pmp) THEN
              IF (pmp .LT. lac) THEN
                x20 = lac
              ELSE
                x20 = pmp
              END IF
            ELSE IF (0. .LT. lac) THEN
              x20 = lac
            ELSE
              x20 = 0.
            END IF
            IF (0. .GT. pmp) THEN
              IF (pmp .GT. lac) THEN
                y25 = lac
              ELSE
                y25 = pmp
              END IF
            ELSE IF (0. .GT. lac) THEN
              y25 = lac
            ELSE
              y25 = 0.
            END IF
            IF (al(i+1) - u(i, j) .LT. y25) THEN
              y19 = y25
            ELSE
              y19 = al(i+1) - u(i, j)
            END IF
            IF (x20 .GT. y19) THEN
              br(i) = y19
            ELSE
              br(i) = x20
            END IF
          END DO
        END IF
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            cfl = c(i, j)*rdx(i-1, j)
            flux(i, j) = u(i-1, j) + (1.-cfl)*(br(i-1)-cfl*(bl(i-1)+br(i&
&             -1)))
          ELSE
            cfl = c(i, j)*rdx(i, j)
            flux(i, j) = u(i, j) + (1.+cfl)*(bl(i)+cfl*(bl(i)+br(i)))
          END IF
        END DO
      END DO
    END SELECT
  END SUBROUTINE XTP_U
!  Differentiation of xtp_u in forward (tangent) mode (with options r8):
!   variations   of useful results: flux
!   with respect to varying inputs: flux u c
  SUBROUTINE XTP_U_TLM(c, c_tl, u, u_tl, v, flux, flux_tl, iord, cosa&
&   , dx, rdx, bd, npx, npy, grid_type, nested)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: u_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(IN) :: c(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(IN) :: c_tl(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(OUT) :: flux(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(OUT) :: flux_tl(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(IN) :: dx(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: rdx(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: cosa(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
    INTEGER, INTENT(IN) :: iord, npx, npy, grid_type
    LOGICAL, INTENT(IN) :: nested
! Local
    LOGICAL :: extm(bd%is-2:bd%ie+2)
    REAL(fvprc) :: al(bd%is-1:bd%ie+2), dm(bd%is-2:bd%ie+2)
    REAL(fvprc) :: al_tl(bd%is-1:bd%ie+2)
    REAL(fvprc) :: bl(bd%is-1:bd%ie+1)
    REAL(fvprc) :: bl_tl(bd%is-1:bd%ie+1)
    REAL(fvprc) :: br(bd%is-1:bd%ie+1)
    REAL(fvprc) :: br_tl(bd%is-1:bd%ie+1)
    REAL(fvprc) :: dq(bd%is-3:bd%ie+2)
    REAL(fvprc) :: dl, dr, xt, pmp, lac, cfl
    REAL(fvprc) :: xt_tl, cfl_tl
    REAL(fvprc) :: pmp_1, lac_1, pmp_2, lac_2
    REAL(fvprc) :: x0, x1, x0l, x0r
    INTEGER :: i, j
    INTEGER :: is3, ie3
    INTEGER :: is, ie, js, je
    INTRINSIC MAX
    INTRINSIC MIN
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    IF (nested .OR. grid_type .GT. 3) THEN
      is3 = is - 1
      ie3 = ie + 1
    ELSE
      IF (3 .LT. is - 1) THEN
        is3 = is - 1
      ELSE
        is3 = 3
      END IF
      IF (npx - 3 .GT. ie + 1) THEN
        ie3 = ie + 1
      ELSE
        ie3 = npx - 3
      END IF
    END IF
    SELECT CASE  (iord) 
    CASE (1) 
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            flux_tl(i, j) = u_tl(i-1, j)
            flux(i, j) = u(i-1, j)
          ELSE
            flux_tl(i, j) = u_tl(i, j)
            flux(i, j) = u(i, j)
          END IF
        END DO
      END DO
    CASE (333) 
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            flux_tl(i, j) = (2.0*u_tl(i, j)+5.0*u_tl(i-1, j)-u_tl(i-2, j&
&             ))/6.0 - 0.5*rdx(i-1, j)*(c_tl(i, j)*(u(i, j)-u(i-1, j))+c&
&             (i, j)*(u_tl(i, j)-u_tl(i-1, j))) + rdx(i-1, j)**2*(c_tl(i&
&             , j)*c(i, j)+c(i, j)*c_tl(i, j))*(u(i, j)-2.0*u(i-1, j)+u(&
&             i-2, j))/6.0 + c(i, j)**2*rdx(i-1, j)**2*(u_tl(i, j)-2.0*&
&             u_tl(i-1, j)+u_tl(i-2, j))/6.0
            flux(i, j) = (2.0*u(i, j)+5.0*u(i-1, j)-u(i-2, j))/6.0 - 0.5&
&             *c(i, j)*rdx(i-1, j)*(u(i, j)-u(i-1, j)) + c(i, j)*rdx(i-1&
&             , j)*c(i, j)*rdx(i-1, j)/6.0*(u(i, j)-2.0*u(i-1, j)+u(i-2&
&             , j))
          ELSE
            flux_tl(i, j) = (2.0*u_tl(i-1, j)+5.0*u_tl(i, j)-u_tl(i+1, j&
&             ))/6.0 - 0.5*rdx(i, j)*(c_tl(i, j)*(u(i, j)-u(i-1, j))+c(i&
&             , j)*(u_tl(i, j)-u_tl(i-1, j))) + rdx(i, j)**2*(c_tl(i, j)&
&             *c(i, j)+c(i, j)*c_tl(i, j))*(u(i+1, j)-2.0*u(i, j)+u(i-1&
&             , j))/6.0 + c(i, j)**2*rdx(i, j)**2*(u_tl(i+1, j)-2.0*u_tl&
&             (i, j)+u_tl(i-1, j))/6.0
            flux(i, j) = (2.0*u(i-1, j)+5.0*u(i, j)-u(i+1, j))/6.0 - 0.5&
&             *c(i, j)*rdx(i, j)*(u(i, j)-u(i-1, j)) + c(i, j)*rdx(i, j)&
&             *c(i, j)*rdx(i, j)/6.0*(u(i+1, j)-2.0*u(i, j)+u(i-1, j))
          END IF
        END DO
      END DO
    CASE (6) 
      al_tl = 0.0_FVPRC
      bl_tl = 0.0_FVPRC
      br_tl = 0.0_FVPRC
      DO j=js,je+1
!            is3 = max(3,is-1) ; ie3 = min(npx-3,ie+1)
        DO i=is3,ie3+1
          al_tl(i) = p1*(u_tl(i-1, j)+u_tl(i, j)) + p2*(u_tl(i-2, j)+&
&           u_tl(i+1, j))
          al(i) = p1*(u(i-1, j)+u(i, j)) + p2*(u(i-2, j)+u(i+1, j))
        END DO
        DO i=is3,ie3
          bl_tl(i) = al_tl(i) - u_tl(i, j)
          bl(i) = al(i) - u(i, j)
          br_tl(i) = al_tl(i+1) - u_tl(i, j)
          br(i) = al(i+1) - u(i, j)
        END DO
        IF (.NOT.nested .AND. grid_type .LT. 3) THEN
          IF (is .EQ. 1) THEN
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
! out
              bl_tl(0) = 0.0_FVPRC
              bl(0) = 0.
! edge
              br_tl(0) = 0.0_FVPRC
              br(0) = 0.
! edge
              bl_tl(1) = 0.0_FVPRC
              bl(1) = 0.
! in
              br_tl(1) = 0.0_FVPRC
              br(1) = 0.
              bl_tl(2) = c3*u_tl(1, j) + c2*u_tl(2, j) + c1*u_tl(3, j) -&
&               u_tl(2, j)
              bl(2) = c3*u(1, j) + c2*u(2, j) + c1*u(3, j) - u(2, j)
            ELSE
              bl_tl(0) = c1*u_tl(-2, j) + c2*u_tl(-1, j) + c3*u_tl(0, j)&
&               - u_tl(0, j)
              bl(0) = c1*u(-2, j) + c2*u(-1, j) + c3*u(0, j) - u(0, j)
              xt_tl = 0.5*(((2.*dx(0, j)+dx(-1, j))*u_tl(0, j)-dx(0, j)*&
&               u_tl(-1, j))/(dx(0, j)+dx(-1, j))+((2.*dx(1, j)+dx(2, j)&
&               )*u_tl(1, j)-dx(1, j)*u_tl(2, j))/(dx(1, j)+dx(2, j)))
              xt = 0.5*(((2.*dx(0, j)+dx(-1, j))*u(0, j)-dx(0, j)*u(-1, &
&               j))/(dx(0, j)+dx(-1, j))+((2.*dx(1, j)+dx(2, j))*u(1, j)&
&               -dx(1, j)*u(2, j))/(dx(1, j)+dx(2, j)))
              br_tl(0) = xt_tl - u_tl(0, j)
              br(0) = xt - u(0, j)
              bl_tl(1) = xt_tl - u_tl(1, j)
              bl(1) = xt - u(1, j)
              xt_tl = c3*u_tl(1, j) + c2*u_tl(2, j) + c1*u_tl(3, j)
              xt = c3*u(1, j) + c2*u(2, j) + c1*u(3, j)
              br_tl(1) = xt_tl - u_tl(1, j)
              br(1) = xt - u(1, j)
              bl_tl(2) = xt_tl - u_tl(2, j)
              bl(2) = xt - u(2, j)
            END IF
            br_tl(2) = al_tl(3) - u_tl(2, j)
            br(2) = al(3) - u(2, j)
          END IF
          IF (ie + 1 .EQ. npx) THEN
            bl_tl(npx-2) = al_tl(npx-2) - u_tl(npx-2, j)
            bl(npx-2) = al(npx-2) - u(npx-2, j)
            xt_tl = c1*u_tl(npx-3, j) + c2*u_tl(npx-2, j) + c3*u_tl(npx-&
&             1, j)
            xt = c1*u(npx-3, j) + c2*u(npx-2, j) + c3*u(npx-1, j)
            br_tl(npx-2) = xt_tl - u_tl(npx-2, j)
            br(npx-2) = xt - u(npx-2, j)
            bl_tl(npx-1) = xt_tl - u_tl(npx-1, j)
            bl(npx-1) = xt - u(npx-1, j)
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
! in
              bl_tl(npx-1) = 0.0_FVPRC
              bl(npx-1) = 0.
! edge
              br_tl(npx-1) = 0.0_FVPRC
              br(npx-1) = 0.
! edge
              bl_tl(npx) = 0.0_FVPRC
              bl(npx) = 0.
! out
              br_tl(npx) = 0.0_FVPRC
              br(npx) = 0.
            ELSE
              xt_tl = 0.5*(((2.*dx(npx-1, j)+dx(npx-2, j))*u_tl(npx-1, j&
&               )-dx(npx-1, j)*u_tl(npx-2, j))/(dx(npx-1, j)+dx(npx-2, j&
&               ))+((2.*dx(npx, j)+dx(npx+1, j))*u_tl(npx, j)-dx(npx, j)&
&               *u_tl(npx+1, j))/(dx(npx, j)+dx(npx+1, j)))
              xt = 0.5*(((2.*dx(npx-1, j)+dx(npx-2, j))*u(npx-1, j)-dx(&
&               npx-1, j)*u(npx-2, j))/(dx(npx-1, j)+dx(npx-2, j))+((2.*&
&               dx(npx, j)+dx(npx+1, j))*u(npx, j)-dx(npx, j)*u(npx+1, j&
&               ))/(dx(npx, j)+dx(npx+1, j)))
              br_tl(npx-1) = xt_tl - u_tl(npx-1, j)
              br(npx-1) = xt - u(npx-1, j)
              bl_tl(npx) = xt_tl - u_tl(npx, j)
              bl(npx) = xt - u(npx, j)
              br_tl(npx) = c3*u_tl(npx, j) + c2*u_tl(npx+1, j) + c1*u_tl&
&               (npx+2, j) - u_tl(npx, j)
              br(npx) = c3*u(npx, j) + c2*u(npx+1, j) + c1*u(npx+2, j) -&
&               u(npx, j)
            END IF
          END IF
        END IF
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            cfl_tl = rdx(i-1, j)*c_tl(i, j)
            cfl = c(i, j)*rdx(i-1, j)
            flux_tl(i, j) = u_tl(i-1, j) + (1.-cfl)*(br_tl(i-1)-cfl_tl*(&
&             bl(i-1)+br(i-1))-cfl*(bl_tl(i-1)+br_tl(i-1))) - cfl_tl*(br&
&             (i-1)-cfl*(bl(i-1)+br(i-1)))
            flux(i, j) = u(i-1, j) + (1.-cfl)*(br(i-1)-cfl*(bl(i-1)+br(i&
&             -1)))
          ELSE
            cfl_tl = rdx(i, j)*c_tl(i, j)
            cfl = c(i, j)*rdx(i, j)
            flux_tl(i, j) = u_tl(i, j) + cfl_tl*(bl(i)+cfl*(bl(i)+br(i))&
&             ) + (1.+cfl)*(bl_tl(i)+cfl_tl*(bl(i)+br(i))+cfl*(bl_tl(i)+&
&             br_tl(i)))
            flux(i, j) = u(i, j) + (1.+cfl)*(bl(i)+cfl*(bl(i)+br(i)))
          END IF
        END DO
      END DO
    END SELECT
  END SUBROUTINE XTP_U_TLM
!  Differentiation of ytp_v in forward (tangent) mode (with options r8):
!   variations   of useful results: flux
!   with respect to varying inputs: v c
  SUBROUTINE YTP_V_TLM(c, c_tl, u, v, v_tl, flux, flux_tl, jord, cosa&
&   , dy, rdy, bd, npx, npy, grid_type, nested)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: jord
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(IN) :: v_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed)
!  Courant   N (like FLUX)
    REAL(fvprc), INTENT(IN) :: c(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(IN) :: c_tl(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(OUT) :: flux(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(OUT) :: flux_tl(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(IN) :: dy(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(IN) :: rdy(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(IN) :: cosa(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
    INTEGER, INTENT(IN) :: npx, npy, grid_type
    LOGICAL, INTENT(IN) :: nested
! Local:
    LOGICAL :: extm(bd%is:bd%ie+1, bd%js-2:bd%je+2)
    REAL(fvprc) :: dm(bd%is:bd%ie+1, bd%js-2:bd%je+2)
    REAL(fvprc) :: al(bd%is:bd%ie+1, bd%js-1:bd%je+2)
    REAL(fvprc) :: al_tl(bd%is:bd%ie+1, bd%js-1:bd%je+2)
    REAL(fvprc) :: bl(bd%is:bd%ie+1, bd%js-1:bd%je+1)
    REAL(fvprc) :: bl_tl(bd%is:bd%ie+1, bd%js-1:bd%je+1)
    REAL(fvprc) :: br(bd%is:bd%ie+1, bd%js-1:bd%je+1)
    REAL(fvprc) :: br_tl(bd%is:bd%ie+1, bd%js-1:bd%je+1)
    REAL(fvprc) :: dq(bd%is:bd%ie+1, bd%js-3:bd%je+2)
    REAL(fvprc) :: xt, dl, dr, pmp, lac, cfl
    REAL(fvprc) :: xt_tl, cfl_tl
    REAL(fvprc) :: pmp_1, lac_1, pmp_2, lac_2
    REAL(fvprc) :: x0, x1, x0r, x0l
    INTEGER :: i, j, js3, je3
    INTEGER :: is, ie, js, je
    INTRINSIC MAX
    INTRINSIC MIN
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    IF (nested .OR. grid_type .GT. 3) THEN
      js3 = js - 1
      je3 = je + 1
    ELSE
      IF (3 .LT. js - 1) THEN
        js3 = js - 1
      ELSE
        js3 = 3
      END IF
      IF (npy - 3 .GT. je + 1) THEN
        je3 = je + 1
      ELSE
        je3 = npy - 3
      END IF
    END IF
    SELECT CASE  (jord) 
    CASE (1) 
      flux_tl = 0.0_FVPRC
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            flux_tl(i, j) = v_tl(i, j-1)
            flux(i, j) = v(i, j-1)
          ELSE
            flux_tl(i, j) = v_tl(i, j)
            flux(i, j) = v(i, j)
          END IF
        END DO
      END DO
    CASE (333) 
      flux_tl = 0.0_FVPRC
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            flux_tl(i, j) = (2.0*v_tl(i, j)+5.0*v_tl(i, j-1)-v_tl(i, j-2&
&             ))/6.0 - 0.5*rdy(i, j-1)*(c_tl(i, j)*(v(i, j)-v(i, j-1))+c&
&             (i, j)*(v_tl(i, j)-v_tl(i, j-1))) + rdy(i, j-1)**2*(c_tl(i&
&             , j)*c(i, j)+c(i, j)*c_tl(i, j))*(v(i, j)-2.0*v(i, j-1)+v(&
&             i, j-2))/6.0 + c(i, j)**2*rdy(i, j-1)**2*(v_tl(i, j)-2.0*&
&             v_tl(i, j-1)+v_tl(i, j-2))/6.0
            flux(i, j) = (2.0*v(i, j)+5.0*v(i, j-1)-v(i, j-2))/6.0 - 0.5&
&             *c(i, j)*rdy(i, j-1)*(v(i, j)-v(i, j-1)) + c(i, j)*rdy(i, &
&             j-1)*c(i, j)*rdy(i, j-1)/6.0*(v(i, j)-2.0*v(i, j-1)+v(i, j&
&             -2))
          ELSE
            flux_tl(i, j) = (2.0*v_tl(i, j-1)+5.0*v_tl(i, j)-v_tl(i, j+1&
&             ))/6.0 - 0.5*rdy(i, j)*(c_tl(i, j)*(v(i, j)-v(i, j-1))+c(i&
&             , j)*(v_tl(i, j)-v_tl(i, j-1))) + rdy(i, j)**2*(c_tl(i, j)&
&             *c(i, j)+c(i, j)*c_tl(i, j))*(v(i, j+1)-2.0*v(i, j)+v(i, j&
&             -1))/6.0 + c(i, j)**2*rdy(i, j)**2*(v_tl(i, j+1)-2.0*v_tl(&
&             i, j)+v_tl(i, j-1))/6.0
            flux(i, j) = (2.0*v(i, j-1)+5.0*v(i, j)-v(i, j+1))/6.0 - 0.5&
&             *c(i, j)*rdy(i, j)*(v(i, j)-v(i, j-1)) + c(i, j)*rdy(i, j)&
&             *c(i, j)*rdy(i, j)/6.0*(v(i, j+1)-2.0*v(i, j)+v(i, j-1))
          END IF
        END DO
      END DO
    CASE (6) 
      al_tl = 0.0_FVPRC
      DO j=js3,je3+1
        DO i=is,ie+1
          al_tl(i, j) = p1*(v_tl(i, j-1)+v_tl(i, j)) + p2*(v_tl(i, j-2)+&
&           v_tl(i, j+1))
          al(i, j) = p1*(v(i, j-1)+v(i, j)) + p2*(v(i, j-2)+v(i, j+1))
        END DO
      END DO
      bl_tl = 0.0_FVPRC
      br_tl = 0.0_FVPRC
      DO j=js3,je3
        DO i=is,ie+1
          bl_tl(i, j) = al_tl(i, j) - v_tl(i, j)
          bl(i, j) = al(i, j) - v(i, j)
          br_tl(i, j) = al_tl(i, j+1) - v_tl(i, j)
          br(i, j) = al(i, j+1) - v(i, j)
        END DO
      END DO
      IF (.NOT.nested .AND. grid_type .LT. 3) THEN
        IF (js .EQ. 1) THEN
          DO i=is,ie+1
            bl_tl(i, 0) = c1*v_tl(i, -2) + c2*v_tl(i, -1) + c3*v_tl(i, 0&
&             ) - v_tl(i, 0)
            bl(i, 0) = c1*v(i, -2) + c2*v(i, -1) + c3*v(i, 0) - v(i, 0)
            xt_tl = 0.5*(((2.*dy(i, 0)+dy(i, -1))*v_tl(i, 0)-dy(i, 0)*&
&             v_tl(i, -1))/(dy(i, 0)+dy(i, -1))+((2.*dy(i, 1)+dy(i, 2))*&
&             v_tl(i, 1)-dy(i, 1)*v_tl(i, 2))/(dy(i, 1)+dy(i, 2)))
            xt = 0.5*(((2.*dy(i, 0)+dy(i, -1))*v(i, 0)-dy(i, 0)*v(i, -1)&
&             )/(dy(i, 0)+dy(i, -1))+((2.*dy(i, 1)+dy(i, 2))*v(i, 1)-dy(&
&             i, 1)*v(i, 2))/(dy(i, 1)+dy(i, 2)))
            br_tl(i, 0) = xt_tl - v_tl(i, 0)
            br(i, 0) = xt - v(i, 0)
            bl_tl(i, 1) = xt_tl - v_tl(i, 1)
            bl(i, 1) = xt - v(i, 1)
            xt_tl = c3*v_tl(i, 1) + c2*v_tl(i, 2) + c1*v_tl(i, 3)
            xt = c3*v(i, 1) + c2*v(i, 2) + c1*v(i, 3)
            br_tl(i, 1) = xt_tl - v_tl(i, 1)
            br(i, 1) = xt - v(i, 1)
            bl_tl(i, 2) = xt_tl - v_tl(i, 2)
            bl(i, 2) = xt - v(i, 2)
            br_tl(i, 2) = al_tl(i, 3) - v_tl(i, 2)
            br(i, 2) = al(i, 3) - v(i, 2)
          END DO
          IF (is .EQ. 1) THEN
! out
            bl_tl(1, 0) = 0.0_FVPRC
            bl(1, 0) = 0.
! edge
            br_tl(1, 0) = 0.0_FVPRC
            br(1, 0) = 0.
! edge
            bl_tl(1, 1) = 0.0_FVPRC
            bl(1, 1) = 0.
! in
            br_tl(1, 1) = 0.0_FVPRC
            br(1, 1) = 0.
          END IF
          IF (ie + 1 .EQ. npx) THEN
! out
            bl_tl(npx, 0) = 0.0_FVPRC
            bl(npx, 0) = 0.
! edge
            br_tl(npx, 0) = 0.0_FVPRC
            br(npx, 0) = 0.
! edge
            bl_tl(npx, 1) = 0.0_FVPRC
            bl(npx, 1) = 0.
! in
            br_tl(npx, 1) = 0.0_FVPRC
            br(npx, 1) = 0.
          END IF
        END IF
        IF (je + 1 .EQ. npy) THEN
          DO i=is,ie+1
            bl_tl(i, npy-2) = al_tl(i, npy-2) - v_tl(i, npy-2)
            bl(i, npy-2) = al(i, npy-2) - v(i, npy-2)
            xt_tl = c1*v_tl(i, npy-3) + c2*v_tl(i, npy-2) + c3*v_tl(i, &
&             npy-1)
            xt = c1*v(i, npy-3) + c2*v(i, npy-2) + c3*v(i, npy-1)
            br_tl(i, npy-2) = xt_tl - v_tl(i, npy-2)
            br(i, npy-2) = xt - v(i, npy-2)
            bl_tl(i, npy-1) = xt_tl - v_tl(i, npy-1)
            bl(i, npy-1) = xt - v(i, npy-1)
            xt_tl = 0.5*(((2.*dy(i, npy-1)+dy(i, npy-2))*v_tl(i, npy-1)-&
&             dy(i, npy-1)*v_tl(i, npy-2))/(dy(i, npy-1)+dy(i, npy-2))+(&
&             (2.*dy(i, npy)+dy(i, npy+1))*v_tl(i, npy)-dy(i, npy)*v_tl(&
&             i, npy+1))/(dy(i, npy)+dy(i, npy+1)))
            xt = 0.5*(((2.*dy(i, npy-1)+dy(i, npy-2))*v(i, npy-1)-dy(i, &
&             npy-1)*v(i, npy-2))/(dy(i, npy-1)+dy(i, npy-2))+((2.*dy(i&
&             , npy)+dy(i, npy+1))*v(i, npy)-dy(i, npy)*v(i, npy+1))/(dy&
&             (i, npy)+dy(i, npy+1)))
            br_tl(i, npy-1) = xt_tl - v_tl(i, npy-1)
            br(i, npy-1) = xt - v(i, npy-1)
            bl_tl(i, npy) = xt_tl - v_tl(i, npy)
            bl(i, npy) = xt - v(i, npy)
            br_tl(i, npy) = c3*v_tl(i, npy) + c2*v_tl(i, npy+1) + c1*&
&             v_tl(i, npy+2) - v_tl(i, npy)
            br(i, npy) = c3*v(i, npy) + c2*v(i, npy+1) + c1*v(i, npy+2) &
&             - v(i, npy)
          END DO
          IF (is .EQ. 1) THEN
! in
            bl_tl(1, npy-1) = 0.0_FVPRC
            bl(1, npy-1) = 0.
! edge
            br_tl(1, npy-1) = 0.0_FVPRC
            br(1, npy-1) = 0.
! edge
            bl_tl(1, npy) = 0.0_FVPRC
            bl(1, npy) = 0.
! out
            br_tl(1, npy) = 0.0_FVPRC
            br(1, npy) = 0.
          END IF
          IF (ie + 1 .EQ. npx) THEN
! in
            bl_tl(npx, npy-1) = 0.0_FVPRC
            bl(npx, npy-1) = 0.
! edge
            br_tl(npx, npy-1) = 0.0_FVPRC
            br(npx, npy-1) = 0.
! edge
            bl_tl(npx, npy) = 0.0_FVPRC
            bl(npx, npy) = 0.
! out
            br_tl(npx, npy) = 0.0_FVPRC
            br(npx, npy) = 0.
            flux_tl = 0.0_FVPRC
          ELSE
            flux_tl = 0.0_FVPRC
          END IF
        ELSE
          flux_tl = 0.0_FVPRC
        END IF
      ELSE
        flux_tl = 0.0_FVPRC
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            cfl_tl = rdy(i, j-1)*c_tl(i, j)
            cfl = c(i, j)*rdy(i, j-1)
            flux_tl(i, j) = v_tl(i, j-1) + (1.-cfl)*(br_tl(i, j-1)-&
&             cfl_tl*(bl(i, j-1)+br(i, j-1))-cfl*(bl_tl(i, j-1)+br_tl(i&
&             , j-1))) - cfl_tl*(br(i, j-1)-cfl*(bl(i, j-1)+br(i, j-1)))
            flux(i, j) = v(i, j-1) + (1.-cfl)*(br(i, j-1)-cfl*(bl(i, j-1&
&             )+br(i, j-1)))
          ELSE
            cfl_tl = rdy(i, j)*c_tl(i, j)
            cfl = c(i, j)*rdy(i, j)
            flux_tl(i, j) = v_tl(i, j) + cfl_tl*(bl(i, j)+cfl*(bl(i, j)+&
&             br(i, j))) + (1.+cfl)*(bl_tl(i, j)+cfl_tl*(bl(i, j)+br(i, &
&             j))+cfl*(bl_tl(i, j)+br_tl(i, j)))
            flux(i, j) = v(i, j) + (1.+cfl)*(bl(i, j)+cfl*(bl(i, j)+br(i&
&             , j)))
          END IF
        END DO
      END DO
    CASE DEFAULT
      flux_tl = 0.0_FVPRC
    END SELECT
  END SUBROUTINE YTP_V_TLM
  SUBROUTINE YTP_V(c, u, v, flux, jord, cosa, dy, rdy, bd, npx, npy, &
&   grid_type, nested)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: jord
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed)
!  Courant   N (like FLUX)
    REAL(fvprc), INTENT(IN) :: c(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(OUT) :: flux(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(IN) :: dy(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(IN) :: rdy(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(IN) :: cosa(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
    INTEGER, INTENT(IN) :: npx, npy, grid_type
    LOGICAL, INTENT(IN) :: nested
! Local:
    LOGICAL :: extm(bd%is:bd%ie+1, bd%js-2:bd%je+2)
    REAL(fvprc) :: dm(bd%is:bd%ie+1, bd%js-2:bd%je+2)
    REAL(fvprc) :: al(bd%is:bd%ie+1, bd%js-1:bd%je+2)
    REAL(fvprc) :: bl(bd%is:bd%ie+1, bd%js-1:bd%je+1)
    REAL(fvprc) :: br(bd%is:bd%ie+1, bd%js-1:bd%je+1)
    REAL(fvprc) :: dq(bd%is:bd%ie+1, bd%js-3:bd%je+2)
    REAL(fvprc) :: xt, dl, dr, pmp, lac, cfl
    REAL(fvprc) :: pmp_1, lac_1, pmp_2, lac_2
    REAL(fvprc) :: x0, x1, x0r, x0l
    INTEGER :: i, j, js3, je3
    INTEGER :: is, ie, js, je
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC SIGN
    REAL(fvprc) :: min1
    REAL(fvprc) :: min2
    REAL(fvprc) :: min3
    REAL(fvprc) :: min4
    REAL(fvprc) :: min5
    REAL(fvprc) :: min6
    REAL(fvprc) :: min7
    REAL(fvprc) :: min8
    REAL(fvprc) :: min9
    REAL(fvprc) :: min10
    REAL(fvprc) :: min11
    REAL(fvprc) :: min12
    REAL(fvprc) :: min13
    REAL(fvprc) :: abs0
    REAL(fvprc) :: abs1
    REAL(fvprc) :: abs2
    REAL(fvprc) :: max1
    REAL(fvprc) :: min14
    REAL(fvprc) :: max2
    REAL(fvprc) :: min15
    REAL(fvprc) :: max3
    REAL(fvprc) :: min16
    REAL(fvprc) :: max4
    REAL(fvprc) :: min17
    REAL(fvprc) :: max5
    REAL(fvprc) :: min18
    REAL(fvprc) :: max6
    REAL(fvprc) :: min19
    REAL(fvprc) :: max7
    REAL(fvprc) :: min20
    REAL(fvprc) :: abs3
    REAL(fvprc) :: abs4
    REAL(fvprc) :: x19
    REAL(fvprc) :: x18
    REAL(fvprc) :: x17
    REAL(fvprc) :: x16
    REAL(fvprc) :: x15
    REAL(fvprc) :: x14
    REAL(fvprc) :: x13
    REAL(fvprc) :: x12
    REAL(fvprc) :: x11
    REAL(fvprc) :: x10
    REAL(fvprc) :: y25
    REAL(fvprc) :: y24
    REAL(fvprc) :: y23
    REAL(fvprc) :: y22
    REAL(fvprc) :: y21
    REAL(fvprc) :: y20
    REAL(fvprc) :: x9
    REAL(fvprc) :: x8
    REAL(fvprc) :: x7
    REAL(fvprc) :: x6
    REAL(fvprc) :: x5
    REAL(fvprc) :: x4
    REAL(fvprc) :: x3
    REAL(fvprc) :: x2
    REAL(fvprc) :: y19
    REAL(fvprc) :: y18
    REAL(fvprc) :: y17
    REAL(fvprc) :: y16
    REAL(fvprc) :: y15
    REAL(fvprc) :: y14
    REAL(fvprc) :: y13
    REAL(fvprc) :: y12
    REAL(fvprc) :: y11
    REAL(fvprc) :: y10
    REAL(fvprc) :: z7
    REAL(fvprc) :: z6
    REAL(fvprc) :: z5
    REAL(fvprc) :: z4
    REAL(fvprc) :: z3
    REAL(fvprc) :: z2
    REAL(fvprc) :: z1
    REAL(fvprc) :: x20
    REAL(fvprc) :: y9
    REAL(fvprc) :: y8
    REAL(fvprc) :: y7
    REAL(fvprc) :: y6
    REAL(fvprc) :: y5
    REAL(fvprc) :: y4
    REAL(fvprc) :: y3
    REAL(fvprc) :: y2
    REAL(fvprc) :: y1
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    IF (nested .OR. grid_type .GT. 3) THEN
      js3 = js - 1
      je3 = je + 1
    ELSE
      IF (3 .LT. js - 1) THEN
        js3 = js - 1
      ELSE
        js3 = 3
      END IF
      IF (npy - 3 .GT. je + 1) THEN
        je3 = je + 1
      ELSE
        je3 = npy - 3
      END IF
    END IF
    SELECT CASE  (jord) 
    CASE (1) 
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            flux(i, j) = v(i, j-1)
          ELSE
            flux(i, j) = v(i, j)
          END IF
        END DO
      END DO
    CASE (333) 
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            flux(i, j) = (2.0*v(i, j)+5.0*v(i, j-1)-v(i, j-2))/6.0 - 0.5&
&             *c(i, j)*rdy(i, j-1)*(v(i, j)-v(i, j-1)) + c(i, j)*rdy(i, &
&             j-1)*c(i, j)*rdy(i, j-1)/6.0*(v(i, j)-2.0*v(i, j-1)+v(i, j&
&             -2))
          ELSE
            flux(i, j) = (2.0*v(i, j-1)+5.0*v(i, j)-v(i, j+1))/6.0 - 0.5&
&             *c(i, j)*rdy(i, j)*(v(i, j)-v(i, j-1)) + c(i, j)*rdy(i, j)&
&             *c(i, j)*rdy(i, j)/6.0*(v(i, j+1)-2.0*v(i, j)+v(i, j-1))
          END IF
        END DO
      END DO
    CASE (2) 
      DO j=js-2,je+2
        DO i=is,ie+1
          xt = 0.25*(v(i, j+1)-v(i, j-1))
          IF (xt .GE. 0.) THEN
            x2 = xt
          ELSE
            x2 = -xt
          END IF
          IF (v(i, j-1) .LT. v(i, j)) THEN
            IF (v(i, j) .LT. v(i, j+1)) THEN
              max1 = v(i, j+1)
            ELSE
              max1 = v(i, j)
            END IF
          ELSE IF (v(i, j-1) .LT. v(i, j+1)) THEN
            max1 = v(i, j+1)
          ELSE
            max1 = v(i, j-1)
          END IF
          y1 = max1 - v(i, j)
          IF (v(i, j-1) .GT. v(i, j)) THEN
            IF (v(i, j) .GT. v(i, j+1)) THEN
              min14 = v(i, j+1)
            ELSE
              min14 = v(i, j)
            END IF
          ELSE IF (v(i, j-1) .GT. v(i, j+1)) THEN
            min14 = v(i, j+1)
          ELSE
            min14 = v(i, j-1)
          END IF
          z1 = v(i, j) - min14
          IF (x2 .GT. y1) THEN
            IF (y1 .GT. z1) THEN
              min1 = z1
            ELSE
              min1 = y1
            END IF
          ELSE IF (x2 .GT. z1) THEN
            min1 = z1
          ELSE
            min1 = x2
          END IF
          dm(i, j) = SIGN(min1, xt)
        END DO
      END DO
      IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
        IF (js .EQ. 1) THEN
          DO i=is,ie+1
            x0l = 0.5*((2.*dy(i, 0)+dy(i, -1))*v(i, 0)-dy(i, 0)*v(i, -1)&
&             )/(dy(i, 0)+dy(i, -1))
            x0r = 0.5*((2.*dy(i, 1)+dy(i, 2))*v(i, 1)-dy(i, 1)*v(i, 2))/&
&             (dy(i, 1)+dy(i, 2))
            x0 = x0l + x0r
            x1 = s15*v(i, 1) + s11*v(i, 2) - s14*dm(i, 2)
!           dm(i,1) = x1 - v(i,1)
            dm(i, 1) = 0.5*(x1-x0)
            IF (dm(i, 1) .GE. 0.) THEN
              x3 = dm(i, 1)
            ELSE
              x3 = -dm(i, 1)
            END IF
            IF (v(i, 1) .LT. x0) THEN
              IF (x0 .LT. x1) THEN
                max2 = x1
              ELSE
                max2 = x0
              END IF
            ELSE IF (v(i, 1) .LT. x1) THEN
              max2 = x1
            ELSE
              max2 = v(i, 1)
            END IF
            y2 = max2 - v(i, 1)
            IF (v(i, 1) .GT. x0) THEN
              IF (x0 .GT. x1) THEN
                min15 = x1
              ELSE
                min15 = x0
              END IF
            ELSE IF (v(i, 1) .GT. x1) THEN
              min15 = x1
            ELSE
              min15 = v(i, 1)
            END IF
            z2 = v(i, 1) - min15
            IF (x3 .GT. y2) THEN
              IF (y2 .GT. z2) THEN
                min2 = z2
              ELSE
                min2 = y2
              END IF
            ELSE IF (x3 .GT. z2) THEN
              min2 = z2
            ELSE
              min2 = x3
            END IF
            dm(i, 1) = SIGN(min2, dm(i, 1))
            x1 = s15*v(i, 0) + s11*v(i, -1) + s14*dm(i, -1)
!           dm(i,0) = v(i,0) - x1
            dm(i, 0) = 0.5*(x0-x1)
            IF (dm(i, 0) .GE. 0.) THEN
              x4 = dm(i, 0)
            ELSE
              x4 = -dm(i, 0)
            END IF
            IF (v(i, 0) .LT. x0) THEN
              IF (x0 .LT. x1) THEN
                max3 = x1
              ELSE
                max3 = x0
              END IF
            ELSE IF (v(i, 0) .LT. x1) THEN
              max3 = x1
            ELSE
              max3 = v(i, 0)
            END IF
            y3 = max3 - v(i, 0)
            IF (v(i, 0) .GT. x0) THEN
              IF (x0 .GT. x1) THEN
                min16 = x1
              ELSE
                min16 = x0
              END IF
            ELSE IF (v(i, 0) .GT. x1) THEN
              min16 = x1
            ELSE
              min16 = v(i, 0)
            END IF
            z3 = v(i, 0) - min16
            IF (x4 .GT. y3) THEN
              IF (y3 .GT. z3) THEN
                min3 = z3
              ELSE
                min3 = y3
              END IF
            ELSE IF (x4 .GT. z3) THEN
              min3 = z3
            ELSE
              min3 = x4
            END IF
            dm(i, 0) = SIGN(min3, dm(i, 0))
          END DO
          IF (is .EQ. 1) THEN
            dm(1, 0) = 0.
            dm(1, 1) = 0.
          END IF
          IF (ie + 1 .EQ. npx) THEN
            dm(npx, 0) = 0.
            dm(npx, 1) = 0.
          END IF
        END IF
        IF (je + 1 .EQ. npy) THEN
          DO i=is,ie+1
            x0l = 0.5*((2.*dy(i, npy-1)+dy(i, npy-2))*v(i, npy-1)-dy(i, &
&             npy-1)*v(i, npy-2))/(dy(i, npy-1)+dy(i, npy-2))
            x0r = 0.5*((2.*dy(i, npy)+dy(i, npy+1))*v(i, npy)-dy(i, npy)&
&             *v(i, npy+1))/(dy(i, npy)+dy(i, npy+1))
            x0 = x0l + x0r
            x1 = s15*v(i, npy-1) + s11*v(i, npy-2) + s14*dm(i, npy-2)
!           dm(i,npy-1) = v(i,npy-1) - x1
            dm(i, npy-1) = 0.5*(x0-x1)
            IF (dm(i, npy-1) .GE. 0.) THEN
              x5 = dm(i, npy-1)
            ELSE
              x5 = -dm(i, npy-1)
            END IF
            IF (v(i, npy-1) .LT. x0) THEN
              IF (x0 .LT. x1) THEN
                max4 = x1
              ELSE
                max4 = x0
              END IF
            ELSE IF (v(i, npy-1) .LT. x1) THEN
              max4 = x1
            ELSE
              max4 = v(i, npy-1)
            END IF
            y4 = max4 - v(i, npy-1)
            IF (v(i, npy-1) .GT. x0) THEN
              IF (x0 .GT. x1) THEN
                min17 = x1
              ELSE
                min17 = x0
              END IF
            ELSE IF (v(i, npy-1) .GT. x1) THEN
              min17 = x1
            ELSE
              min17 = v(i, npy-1)
            END IF
            z4 = v(i, npy-1) - min17
            IF (x5 .GT. y4) THEN
              IF (y4 .GT. z4) THEN
                min4 = z4
              ELSE
                min4 = y4
              END IF
            ELSE IF (x5 .GT. z4) THEN
              min4 = z4
            ELSE
              min4 = x5
            END IF
            dm(i, npy-1) = SIGN(min4, dm(i, npy-1))
            x1 = s15*v(i, npy) + s11*v(i, npy+1) - s14*dm(i, npy+1)
!           dm(i,npy) = x1 - v(i,npy)
            dm(i, npy) = 0.5*(x1-x0)
            IF (dm(i, npy) .GE. 0.) THEN
              x6 = dm(i, npy)
            ELSE
              x6 = -dm(i, npy)
            END IF
            IF (v(i, npy) .LT. x0) THEN
              IF (x0 .LT. x1) THEN
                max5 = x1
              ELSE
                max5 = x0
              END IF
            ELSE IF (v(i, npy) .LT. x1) THEN
              max5 = x1
            ELSE
              max5 = v(i, npy)
            END IF
            y5 = max5 - v(i, npy)
            IF (v(i, npy) .GT. x0) THEN
              IF (x0 .GT. x1) THEN
                min18 = x1
              ELSE
                min18 = x0
              END IF
            ELSE IF (v(i, npy) .GT. x1) THEN
              min18 = x1
            ELSE
              min18 = v(i, npy)
            END IF
            z5 = v(i, npy) - min18
            IF (x6 .GT. y5) THEN
              IF (y5 .GT. z5) THEN
                min5 = z5
              ELSE
                min5 = y5
              END IF
            ELSE IF (x6 .GT. z5) THEN
              min5 = z5
            ELSE
              min5 = x6
            END IF
            dm(i, npy) = SIGN(min5, dm(i, npy))
          END DO
          IF (is .EQ. 1) THEN
            dm(1, npy-1) = 0.
            dm(1, npy) = 0.
          END IF
          IF (ie + 1 .EQ. npx) THEN
            dm(npx, npy-1) = 0.
            dm(npx, npy) = 0.
          END IF
        END IF
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            flux(i, j) = v(i, j-1) + (1.-c(i, j)*rdy(i, j-1))*dm(i, j-1)
          ELSE
            flux(i, j) = v(i, j) - (1.+c(i, j)*rdy(i, j))*dm(i, j)
          END IF
        END DO
      END DO
    CASE (4) 
      DO j=js-2,je+2
        DO i=is,ie+1
          xt = 0.25*(v(i, j+1)-v(i, j-1))
          IF (xt .GE. 0.) THEN
            x7 = xt
          ELSE
            x7 = -xt
          END IF
          IF (v(i, j-1) .LT. v(i, j)) THEN
            IF (v(i, j) .LT. v(i, j+1)) THEN
              max6 = v(i, j+1)
            ELSE
              max6 = v(i, j)
            END IF
          ELSE IF (v(i, j-1) .LT. v(i, j+1)) THEN
            max6 = v(i, j+1)
          ELSE
            max6 = v(i, j-1)
          END IF
          y6 = max6 - v(i, j)
          IF (v(i, j-1) .GT. v(i, j)) THEN
            IF (v(i, j) .GT. v(i, j+1)) THEN
              min19 = v(i, j+1)
            ELSE
              min19 = v(i, j)
            END IF
          ELSE IF (v(i, j-1) .GT. v(i, j+1)) THEN
            min19 = v(i, j+1)
          ELSE
            min19 = v(i, j-1)
          END IF
          z6 = v(i, j) - min19
          IF (x7 .GT. y6) THEN
            IF (y6 .GT. z6) THEN
              min6 = z6
            ELSE
              min6 = y6
            END IF
          ELSE IF (x7 .GT. z6) THEN
            min6 = z6
          ELSE
            min6 = x7
          END IF
          dm(i, j) = SIGN(min6, xt)
        END DO
      END DO
      DO j=js-1,je+2
        DO i=is,ie+1
          al(i, j) = 0.5*(v(i, j-1)+v(i, j)) + r3*(dm(i, j-1)-dm(i, j))
        END DO
      END DO
      IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
        IF (js .EQ. 1) THEN
          DO i=is,ie+1
            x0l = 0.5*((2.*dy(i, 0)+dy(i, -1))*v(i, 0)-dy(i, 0)*v(i, -1)&
&             )/(dy(i, 0)+dy(i, -1))
            x0r = 0.5*((2.*dy(i, 1)+dy(i, 2))*v(i, 1)-dy(i, 1)*v(i, 2))/&
&             (dy(i, 1)+dy(i, 2))
            x0 = x0l + x0r
            x1 = s15*v(i, 1) + s11*v(i, 2) - s14*dm(i, 2)
            dm(i, 1) = 0.5*(x1-x0)
!           dm(i,1) = sign(min(abs(dm(i,1)), max(v(i,1), x0, x1) - v(i,1),   &
!                                   v(i,1) - min(v(i,1), x0, x1)), dm(i,1))
            x1 = s15*v(i, 0) + s11*v(i, -1) + s14*dm(i, -1)
            dm(i, 0) = 0.5*(x0-x1)
!           dm(i,0) = sign(min(abs(dm(i,0)), max(v(i,0), x0, x1) - v(i,0),   &
!                                   v(i,0) - min(v(i,0), x0, x1)), dm(i,0))
            al(i, 0) = 0.5*(v(i, -1)+v(i, 0)) + r3*(dm(i, -1)-dm(i, 0))
            al(i, 1) = x0
            al(i, 2) = 0.5*(v(i, 1)+v(i, 2)) + r3*(dm(i, 1)-dm(i, 2))
          END DO
          IF (is .EQ. 1) THEN
            dm(1, 0) = 0.
            dm(1, 1) = 0.
            i = 1
            al(i, 0) = 0.5*(v(i, -1)+v(i, 0)) + r3*(dm(i, -1)-dm(i, 0))
            al(i, 2) = 0.5*(v(i, 1)+v(i, 2)) + r3*(dm(i, 1)-dm(i, 2))
          END IF
          IF (ie + 1 .EQ. npx) THEN
            dm(npx, 0) = 0.
            dm(npx, 1) = 0.
            i = npx
            al(i, 0) = 0.5*(v(i, -1)+v(i, 0)) + r3*dm(i, -1)
            al(i, 2) = 0.5*(v(i, 1)+v(i, 2)) - r3*dm(i, 2)
          END IF
        END IF
        IF (je + 1 .EQ. npy) THEN
          DO i=is,ie+1
            x0l = 0.5*((2.*dy(i, npy-1)+dy(i, npy-2))*v(i, npy-1)-dy(i, &
&             npy-1)*v(i, npy-2))/(dy(i, npy-1)+dy(i, npy-2))
            x0r = 0.5*((2.*dy(i, npy)+dy(i, npy+1))*v(i, npy)-dy(i, npy)&
&             *v(i, npy+1))/(dy(i, npy)+dy(i, npy+1))
            x0 = x0l + x0r
            x1 = s15*v(i, npy-1) + s11*v(i, npy-2) + s14*dm(i, npy-2)
            dm(i, npy-1) = 0.5*(x0-x1)
!           dm(i,npy-1) = sign(min(abs(dm(i,npy-1)), max(v(i,npy-1), x0, x1) - v(i,npy-1),  &
!                                       v(i,npy-1) - min(v(i,npy-1), x0, x1)), dm(i,npy-1))
            x1 = s15*v(i, npy) + s11*v(i, npy+1) - s14*dm(i, npy+1)
            dm(i, npy) = 0.5*(x1-x0)
!           dm(i,npy) = sign(min(abs(dm(i,npy)), max(v(i,npy), x0, x1) - v(i,npy),   &
!                                     v(i,npy) - min(v(i,npy), x0, x1)), dm(i,npy))
            al(i, npy-1) = 0.5*(v(i, npy-2)+v(i, npy-1)) + r3*(dm(i, npy&
&             -2)-dm(i, npy-1))
            al(i, npy) = x0
            al(i, npy+1) = 0.5*(v(i, npy)+v(i, npy+1)) + r3*(dm(i, npy)-&
&             dm(i, npy+1))
          END DO
          IF (is .EQ. 1) THEN
            dm(1, npy-1) = 0.
            dm(1, npy) = 0.
            i = 1
            al(i, npy-1) = 0.5*(v(i, npy-2)+v(i, npy-1)) + r3*dm(i, npy-&
&             2)
            al(i, npy+1) = 0.5*(v(i, npy)+v(i, npy+1)) - r3*dm(i, npy+1)
          END IF
          IF (ie + 1 .EQ. npx) THEN
            dm(npx, npy-1) = 0.
            dm(npx, npy) = 0.
            i = npx
            al(i, npy-1) = 0.5*(v(i, npy-2)+v(i, npy-1)) + r3*dm(i, npy-&
&             2)
            al(i, npy+1) = 0.5*(v(i, npy)+v(i, npy+1)) - r3*dm(i, npy+1)
          END IF
        END IF
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            xt = 2.*dm(i, j-1)
            IF (xt .GE. 0.) THEN
              x8 = xt
            ELSE
              x8 = -xt
            END IF
            IF (al(i, j-1) - v(i, j-1) .GE. 0.) THEN
              y7 = al(i, j-1) - v(i, j-1)
            ELSE
              y7 = -(al(i, j-1)-v(i, j-1))
            END IF
            IF (x8 .GT. y7) THEN
              min7 = y7
            ELSE
              min7 = x8
            END IF
            dl = SIGN(min7, xt)
            IF (xt .GE. 0.) THEN
              x9 = xt
            ELSE
              x9 = -xt
            END IF
            IF (al(i, j) - v(i, j-1) .GE. 0.) THEN
              y8 = al(i, j) - v(i, j-1)
            ELSE
              y8 = -(al(i, j)-v(i, j-1))
            END IF
            IF (x9 .GT. y8) THEN
              min8 = y8
            ELSE
              min8 = x9
            END IF
            dr = SIGN(min8, xt)
            cfl = c(i, j)*rdy(i, j-1)
            flux(i, j) = v(i, j-1) + (1.-cfl)*(dr+cfl*(dl-dr))
          ELSE
            xt = 2.*dm(i, j)
            IF (xt .GE. 0.) THEN
              x10 = xt
            ELSE
              x10 = -xt
            END IF
            IF (al(i, j) - v(i, j) .GE. 0.) THEN
              y9 = al(i, j) - v(i, j)
            ELSE
              y9 = -(al(i, j)-v(i, j))
            END IF
            IF (x10 .GT. y9) THEN
              min9 = y9
            ELSE
              min9 = x10
            END IF
            dl = SIGN(min9, xt)
            IF (xt .GE. 0.) THEN
              x11 = xt
            ELSE
              x11 = -xt
            END IF
            IF (al(i, j+1) - v(i, j) .GE. 0.) THEN
              y10 = al(i, j+1) - v(i, j)
            ELSE
              y10 = -(al(i, j+1)-v(i, j))
            END IF
            IF (x11 .GT. y10) THEN
              min10 = y10
            ELSE
              min10 = x11
            END IF
            dr = SIGN(min10, xt)
            cfl = c(i, j)*rdy(i, j)
            flux(i, j) = v(i, j) - (1.+cfl)*(dl+cfl*(dl-dr))
          END IF
        END DO
      END DO
    CASE (6) 
      DO j=js3,je3+1
        DO i=is,ie+1
          al(i, j) = p1*(v(i, j-1)+v(i, j)) + p2*(v(i, j-2)+v(i, j+1))
        END DO
      END DO
      DO j=js3,je3
        DO i=is,ie+1
          bl(i, j) = al(i, j) - v(i, j)
          br(i, j) = al(i, j+1) - v(i, j)
        END DO
      END DO
      IF (.NOT.nested .AND. grid_type .LT. 3) THEN
        IF (js .EQ. 1) THEN
          DO i=is,ie+1
            bl(i, 0) = c1*v(i, -2) + c2*v(i, -1) + c3*v(i, 0) - v(i, 0)
            xt = 0.5*(((2.*dy(i, 0)+dy(i, -1))*v(i, 0)-dy(i, 0)*v(i, -1)&
&             )/(dy(i, 0)+dy(i, -1))+((2.*dy(i, 1)+dy(i, 2))*v(i, 1)-dy(&
&             i, 1)*v(i, 2))/(dy(i, 1)+dy(i, 2)))
            br(i, 0) = xt - v(i, 0)
            bl(i, 1) = xt - v(i, 1)
            xt = c3*v(i, 1) + c2*v(i, 2) + c1*v(i, 3)
            br(i, 1) = xt - v(i, 1)
            bl(i, 2) = xt - v(i, 2)
            br(i, 2) = al(i, 3) - v(i, 2)
          END DO
          IF (is .EQ. 1) THEN
! out
            bl(1, 0) = 0.
! edge
            br(1, 0) = 0.
! edge
            bl(1, 1) = 0.
! in
            br(1, 1) = 0.
          END IF
          IF (ie + 1 .EQ. npx) THEN
! out
            bl(npx, 0) = 0.
! edge
            br(npx, 0) = 0.
! edge
            bl(npx, 1) = 0.
! in
            br(npx, 1) = 0.
          END IF
        END IF
        IF (je + 1 .EQ. npy) THEN
          DO i=is,ie+1
            bl(i, npy-2) = al(i, npy-2) - v(i, npy-2)
            xt = c1*v(i, npy-3) + c2*v(i, npy-2) + c3*v(i, npy-1)
            br(i, npy-2) = xt - v(i, npy-2)
            bl(i, npy-1) = xt - v(i, npy-1)
            xt = 0.5*(((2.*dy(i, npy-1)+dy(i, npy-2))*v(i, npy-1)-dy(i, &
&             npy-1)*v(i, npy-2))/(dy(i, npy-1)+dy(i, npy-2))+((2.*dy(i&
&             , npy)+dy(i, npy+1))*v(i, npy)-dy(i, npy)*v(i, npy+1))/(dy&
&             (i, npy)+dy(i, npy+1)))
            br(i, npy-1) = xt - v(i, npy-1)
            bl(i, npy) = xt - v(i, npy)
            br(i, npy) = c3*v(i, npy) + c2*v(i, npy+1) + c1*v(i, npy+2) &
&             - v(i, npy)
          END DO
          IF (is .EQ. 1) THEN
! in
            bl(1, npy-1) = 0.
! edge
            br(1, npy-1) = 0.
! edge
            bl(1, npy) = 0.
! out
            br(1, npy) = 0.
          END IF
          IF (ie + 1 .EQ. npx) THEN
! in
            bl(npx, npy-1) = 0.
! edge
            br(npx, npy-1) = 0.
! edge
            bl(npx, npy) = 0.
! out
            br(npx, npy) = 0.
          END IF
        END IF
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            cfl = c(i, j)*rdy(i, j-1)
            flux(i, j) = v(i, j-1) + (1.-cfl)*(br(i, j-1)-cfl*(bl(i, j-1&
&             )+br(i, j-1)))
          ELSE
            cfl = c(i, j)*rdy(i, j)
            flux(i, j) = v(i, j) + (1.+cfl)*(bl(i, j)+cfl*(bl(i, j)+br(i&
&             , j)))
          END IF
        END DO
      END DO
    CASE DEFAULT
! jord= 8, 9, 10
      DO j=js-2,je+2
        DO i=is,ie+1
          xt = 0.25*(v(i, j+1)-v(i, j-1))
          IF (xt .GE. 0.) THEN
            x12 = xt
          ELSE
            x12 = -xt
          END IF
          IF (v(i, j-1) .LT. v(i, j)) THEN
            IF (v(i, j) .LT. v(i, j+1)) THEN
              max7 = v(i, j+1)
            ELSE
              max7 = v(i, j)
            END IF
          ELSE IF (v(i, j-1) .LT. v(i, j+1)) THEN
            max7 = v(i, j+1)
          ELSE
            max7 = v(i, j-1)
          END IF
          y11 = max7 - v(i, j)
          IF (v(i, j-1) .GT. v(i, j)) THEN
            IF (v(i, j) .GT. v(i, j+1)) THEN
              min20 = v(i, j+1)
            ELSE
              min20 = v(i, j)
            END IF
          ELSE IF (v(i, j-1) .GT. v(i, j+1)) THEN
            min20 = v(i, j+1)
          ELSE
            min20 = v(i, j-1)
          END IF
          z7 = v(i, j) - min20
          IF (x12 .GT. y11) THEN
            IF (y11 .GT. z7) THEN
              min11 = z7
            ELSE
              min11 = y11
            END IF
          ELSE IF (x12 .GT. z7) THEN
            min11 = z7
          ELSE
            min11 = x12
          END IF
          dm(i, j) = SIGN(min11, xt)
        END DO
      END DO
      DO j=js-3,je+2
        DO i=is,ie+1
          dq(i, j) = v(i, j+1) - v(i, j)
        END DO
      END DO
      IF (grid_type .LT. 3) THEN
        DO j=js3,je3+1
          DO i=is,ie+1
            al(i, j) = 0.5*(v(i, j-1)+v(i, j)) + r3*(dm(i, j-1)-dm(i, j)&
&             )
          END DO
        END DO
        IF (jord .EQ. 8) THEN
          DO j=js3,je3
            DO i=is,ie+1
              xt = 2.*dm(i, j)
              IF (xt .GE. 0.) THEN
                x13 = xt
              ELSE
                x13 = -xt
              END IF
              IF (al(i, j) - v(i, j) .GE. 0.) THEN
                y12 = al(i, j) - v(i, j)
              ELSE
                y12 = -(al(i, j)-v(i, j))
              END IF
              IF (x13 .GT. y12) THEN
                min12 = y12
              ELSE
                min12 = x13
              END IF
              bl(i, j) = -SIGN(min12, xt)
              IF (xt .GE. 0.) THEN
                x14 = xt
              ELSE
                x14 = -xt
              END IF
              IF (al(i, j+1) - v(i, j) .GE. 0.) THEN
                y13 = al(i, j+1) - v(i, j)
              ELSE
                y13 = -(al(i, j+1)-v(i, j))
              END IF
              IF (x14 .GT. y13) THEN
                min13 = y13
              ELSE
                min13 = x14
              END IF
              br(i, j) = SIGN(min13, xt)
            END DO
          END DO
        ELSE IF (jord .EQ. 9) THEN
          DO j=js3,je3
            DO i=is,ie+1
              pmp_1 = -(2.*dq(i, j))
              lac_1 = pmp_1 + 1.5*dq(i, j+1)
              IF (0. .LT. pmp_1) THEN
                IF (pmp_1 .LT. lac_1) THEN
                  x15 = lac_1
                ELSE
                  x15 = pmp_1
                END IF
              ELSE IF (0. .LT. lac_1) THEN
                x15 = lac_1
              ELSE
                x15 = 0.
              END IF
              IF (0. .GT. pmp_1) THEN
                IF (pmp_1 .GT. lac_1) THEN
                  y20 = lac_1
                ELSE
                  y20 = pmp_1
                END IF
              ELSE IF (0. .GT. lac_1) THEN
                y20 = lac_1
              ELSE
                y20 = 0.
              END IF
              IF (al(i, j) - v(i, j) .LT. y20) THEN
                y14 = y20
              ELSE
                y14 = al(i, j) - v(i, j)
              END IF
              IF (x15 .GT. y14) THEN
                bl(i, j) = y14
              ELSE
                bl(i, j) = x15
              END IF
              pmp_2 = 2.*dq(i, j-1)
              lac_2 = pmp_2 - 1.5*dq(i, j-2)
              IF (0. .LT. pmp_2) THEN
                IF (pmp_2 .LT. lac_2) THEN
                  x16 = lac_2
                ELSE
                  x16 = pmp_2
                END IF
              ELSE IF (0. .LT. lac_2) THEN
                x16 = lac_2
              ELSE
                x16 = 0.
              END IF
              IF (0. .GT. pmp_2) THEN
                IF (pmp_2 .GT. lac_2) THEN
                  y21 = lac_2
                ELSE
                  y21 = pmp_2
                END IF
              ELSE IF (0. .GT. lac_2) THEN
                y21 = lac_2
              ELSE
                y21 = 0.
              END IF
              IF (al(i, j+1) - v(i, j) .LT. y21) THEN
                y15 = y21
              ELSE
                y15 = al(i, j+1) - v(i, j)
              END IF
              IF (x16 .GT. y15) THEN
                br(i, j) = y15
              ELSE
                br(i, j) = x16
              END IF
            END DO
          END DO
        ELSE IF (jord .EQ. 10) THEN
          DO j=js3,je3
            DO i=is,ie+1
              bl(i, j) = al(i, j) - v(i, j)
              br(i, j) = al(i, j+1) - v(i, j)
              IF (dm(i, j) .GE. 0.) THEN
                abs0 = dm(i, j)
              ELSE
                abs0 = -dm(i, j)
              END IF
!           if ( abs(dm(i,j-1))+abs(dm(i,j))+abs(dm(i,j+1)) < near_zero ) then
              IF (abs0 .LT. near_zero) THEN
                IF (dm(i, j-1) .GE. 0.) THEN
                  abs1 = dm(i, j-1)
                ELSE
                  abs1 = -dm(i, j-1)
                END IF
                IF (dm(i, j+1) .GE. 0.) THEN
                  abs3 = dm(i, j+1)
                ELSE
                  abs3 = -dm(i, j+1)
                END IF
                IF (abs1 + abs3 .LT. near_zero) THEN
                  bl(i, j) = 0.
                  br(i, j) = 0.
                END IF
              ELSE
                IF (3.*(bl(i, j)+br(i, j)) .GE. 0.) THEN
                  abs2 = 3.*(bl(i, j)+br(i, j))
                ELSE
                  abs2 = -(3.*(bl(i, j)+br(i, j)))
                END IF
                IF (bl(i, j) - br(i, j) .GE. 0.) THEN
                  abs4 = bl(i, j) - br(i, j)
                ELSE
                  abs4 = -(bl(i, j)-br(i, j))
                END IF
                IF (abs2 .GT. abs4) THEN
                  pmp_1 = -(2.*dq(i, j))
                  lac_1 = pmp_1 + 1.5*dq(i, j+1)
                  IF (0. .LT. pmp_1) THEN
                    IF (pmp_1 .LT. lac_1) THEN
                      x17 = lac_1
                    ELSE
                      x17 = pmp_1
                    END IF
                  ELSE IF (0. .LT. lac_1) THEN
                    x17 = lac_1
                  ELSE
                    x17 = 0.
                  END IF
                  IF (0. .GT. pmp_1) THEN
                    IF (pmp_1 .GT. lac_1) THEN
                      y22 = lac_1
                    ELSE
                      y22 = pmp_1
                    END IF
                  ELSE IF (0. .GT. lac_1) THEN
                    y22 = lac_1
                  ELSE
                    y22 = 0.
                  END IF
                  IF (bl(i, j) .LT. y22) THEN
                    y16 = y22
                  ELSE
                    y16 = bl(i, j)
                  END IF
                  IF (x17 .GT. y16) THEN
                    bl(i, j) = y16
                  ELSE
                    bl(i, j) = x17
                  END IF
                  pmp_2 = 2.*dq(i, j-1)
                  lac_2 = pmp_2 - 1.5*dq(i, j-2)
                  IF (0. .LT. pmp_2) THEN
                    IF (pmp_2 .LT. lac_2) THEN
                      x18 = lac_2
                    ELSE
                      x18 = pmp_2
                    END IF
                  ELSE IF (0. .LT. lac_2) THEN
                    x18 = lac_2
                  ELSE
                    x18 = 0.
                  END IF
                  IF (0. .GT. pmp_2) THEN
                    IF (pmp_2 .GT. lac_2) THEN
                      y23 = lac_2
                    ELSE
                      y23 = pmp_2
                    END IF
                  ELSE IF (0. .GT. lac_2) THEN
                    y23 = lac_2
                  ELSE
                    y23 = 0.
                  END IF
                  IF (br(i, j) .LT. y23) THEN
                    y17 = y23
                  ELSE
                    y17 = br(i, j)
                  END IF
                  IF (x18 .GT. y17) THEN
                    br(i, j) = y17
                  ELSE
                    br(i, j) = x18
                  END IF
                END IF
              END IF
            END DO
          END DO
        ELSE
! Unlimited:
          DO j=js3,je3
            DO i=is,ie+1
              bl(i, j) = al(i, j) - v(i, j)
              br(i, j) = al(i, j+1) - v(i, j)
            END DO
          END DO
        END IF
!--------------
! fix the edges
!--------------
        IF (js .EQ. 1 .AND. (.NOT.nested)) THEN
          DO i=is,ie+1
            br(i, 2) = al(i, 3) - v(i, 2)
            xt = s15*v(i, 1) + s11*v(i, 2) - s14*dm(i, 2)
            br(i, 1) = xt - v(i, 1)
            bl(i, 2) = xt - v(i, 2)
            bl(i, 0) = s14*dm(i, -1) - s11*dq(i, -1)
!#ifdef ONE_SIDE
!            xt =  t14*v(i,1) +  t12*v(i,2) + t15*v(i,3)
!            bl(i,1) = 2.*xt - v(i,1)
!            xt =  t14*v(i,0) +  t12*v(i,-1) + t15*v(i,-2)
!            br(i,0) = 2.*xt - v(i,0)
!#else
            x0l = 0.5*((2.*dy(i, 0)+dy(i, -1))*v(i, 0)-dy(i, 0)*v(i, -1)&
&             )/(dy(i, 0)+dy(i, -1))
            x0r = 0.5*((2.*dy(i, 1)+dy(i, 2))*v(i, 1)-dy(i, 1)*v(i, 2))/&
&             (dy(i, 1)+dy(i, 2))
            xt = x0l + x0r
            bl(i, 1) = xt - v(i, 1)
            br(i, 0) = xt - v(i, 0)
          END DO
!#endif
          IF (is .EQ. 1) THEN
! out
            bl(1, 0) = 0.
! edge
            br(1, 0) = 0.
! edge
            bl(1, 1) = 0.
! in
            br(1, 1) = 0.
          END IF
          IF (ie + 1 .EQ. npx) THEN
! out
            bl(npx, 0) = 0.
! edge
            br(npx, 0) = 0.
! edge
            bl(npx, 1) = 0.
! in
            br(npx, 1) = 0.
          END IF
          j = 2
          CALL PERT_PPM(ie - is + 2, v(is, j), bl(is, j), br(is, j), -1)
        END IF
        IF (je + 1 .EQ. npy .AND. (.NOT.nested)) THEN
          DO i=is,ie+1
            bl(i, npy-2) = al(i, npy-2) - v(i, npy-2)
            xt = s15*v(i, npy-1) + s11*v(i, npy-2) + s14*dm(i, npy-2)
            br(i, npy-2) = xt - v(i, npy-2)
            bl(i, npy-1) = xt - v(i, npy-1)
            br(i, npy) = s11*dq(i, npy) - s14*dm(i, npy+1)
!#ifdef ONE_SIDE
!            xt = t14*v(i,npy-1) + t12*v(i,npy-2) + t15*v(i,npy-3)
!            br(i,npy-1) = 2.*xt - v(i,npy-1)
!            xt = t14*v(i,npy) + t12*v(i,npy+1) + t15*v(i,npy+2)
!            bl(i,npy  ) = 2.*xt - v(i,npy)
!#else
            x0l = 0.5*((2.*dy(i, npy-1)+dy(i, npy-2))*v(i, npy-1)-dy(i, &
&             npy-1)*v(i, npy-2))/(dy(i, npy-1)+dy(i, npy-2))
            x0r = 0.5*((2.*dy(i, npy)+dy(i, npy+1))*v(i, npy)-dy(i, npy)&
&             *v(i, npy+1))/(dy(i, npy)+dy(i, npy+1))
            xt = x0l + x0r
            br(i, npy-1) = xt - v(i, npy-1)
            bl(i, npy) = xt - v(i, npy)
          END DO
!#endif
          IF (is .EQ. 1) THEN
! in
            bl(1, npy-1) = 0.
! edge
            br(1, npy-1) = 0.
! edge
            bl(1, npy) = 0.
! out
            br(1, npy) = 0.
          END IF
          IF (ie + 1 .EQ. npx) THEN
! in
            bl(npx, npy-1) = 0.
! edge
            br(npx, npy-1) = 0.
! edge
            bl(npx, npy) = 0.
! out
            br(npx, npy) = 0.
          END IF
          j = npy - 2
          CALL PERT_PPM(ie - is + 2, v(is, j), bl(is, j), br(is, j), -1)
        END IF
      ELSE
        DO j=js-1,je+2
          DO i=is,ie+1
            al(i, j) = 0.5*(v(i, j-1)+v(i, j)) + r3*(dm(i, j-1)-dm(i, j)&
&             )
          END DO
        END DO
        DO j=js-1,je+1
          DO i=is,ie+1
            pmp = 2.*dq(i, j-1)
            lac = pmp - 1.5*dq(i, j-2)
            IF (0. .LT. pmp) THEN
              IF (pmp .LT. lac) THEN
                x19 = lac
              ELSE
                x19 = pmp
              END IF
            ELSE IF (0. .LT. lac) THEN
              x19 = lac
            ELSE
              x19 = 0.
            END IF
            IF (0. .GT. pmp) THEN
              IF (pmp .GT. lac) THEN
                y24 = lac
              ELSE
                y24 = pmp
              END IF
            ELSE IF (0. .GT. lac) THEN
              y24 = lac
            ELSE
              y24 = 0.
            END IF
            IF (al(i, j+1) - v(i, j) .LT. y24) THEN
              y18 = y24
            ELSE
              y18 = al(i, j+1) - v(i, j)
            END IF
            IF (x19 .GT. y18) THEN
              br(i, j) = y18
            ELSE
              br(i, j) = x19
            END IF
            pmp = -(2.*dq(i, j))
            lac = pmp + 1.5*dq(i, j+1)
            IF (0. .LT. pmp) THEN
              IF (pmp .LT. lac) THEN
                x20 = lac
              ELSE
                x20 = pmp
              END IF
            ELSE IF (0. .LT. lac) THEN
              x20 = lac
            ELSE
              x20 = 0.
            END IF
            IF (0. .GT. pmp) THEN
              IF (pmp .GT. lac) THEN
                y25 = lac
              ELSE
                y25 = pmp
              END IF
            ELSE IF (0. .GT. lac) THEN
              y25 = lac
            ELSE
              y25 = 0.
            END IF
            IF (al(i, j) - v(i, j) .LT. y25) THEN
              y19 = y25
            ELSE
              y19 = al(i, j) - v(i, j)
            END IF
            IF (x20 .GT. y19) THEN
              bl(i, j) = y19
            ELSE
              bl(i, j) = x20
            END IF
          END DO
        END DO
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            cfl = c(i, j)*rdy(i, j-1)
            flux(i, j) = v(i, j-1) + (1.-cfl)*(br(i, j-1)-cfl*(bl(i, j-1&
&             )+br(i, j-1)))
          ELSE
            cfl = c(i, j)*rdy(i, j)
            flux(i, j) = v(i, j) + (1.+cfl)*(bl(i, j)+cfl*(bl(i, j)+br(i&
&             , j)))
          END IF
        END DO
      END DO
    END SELECT
  END SUBROUTINE YTP_V
!  Differentiation of d2a2c_vect in forward (tangent) mode (with options r8):
!   variations   of useful results: ua uc ut va vc vt
!   with respect to varying inputs: u v ua uc ut va vc vt
!There is a limit to how far this routine can fill uc and vc in the
! halo, and so either mpp_update_domains or some sort of boundary
!  routine (extrapolation, outflow, interpolation from a nested grid)
!   is needed after c_sw is completed if these variables are needed
!    in the halo
  SUBROUTINE D2A2C_VECT_TLM(u, u_tl, v, v_tl, ua, ua_tl, va, va_tl, uc, &
&   uc_tl, vc, vc_tl, ut, ut_tl, vt, vt_tl, dord4, gridstruct, bd, npx, &
&   npy, nested, grid_type)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    LOGICAL, INTENT(IN) :: dord4
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: u_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(IN) :: v_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(OUT) &
&   :: uc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(OUT) &
&   :: uc_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(OUT) &
&   :: vc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(OUT) &
&   :: vc_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(OUT) ::&
&   ua, va, ut, vt
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(OUT) ::&
&   ua_tl, va_tl, ut_tl, vt_tl
    INTEGER, INTENT(IN) :: npx, npy, grid_type
    LOGICAL, INTENT(IN) :: nested
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
! Local 
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: utmp, vtmp
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: utmp_tl, &
&   vtmp_tl
    INTEGER :: npt, i, j, ifirst, ilast, id
!  real(FVPRC), pointer, dimension(:,:,:) :: sin_sg
!  real(FVPRC), pointer, dimension(:,:)   :: cosa_u, cosa_v, cosa_s
!  real(FVPRC), pointer, dimension(:,:)   :: rsin_u, rsin_v, rsin2
!  real(FVPRC), pointer, dimension(:,:)   ::  dxa,dya
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: max5
    INTEGER :: max6
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    INTEGER :: min5
    INTEGER :: min6
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
!      sin_sg    => gridstruct%sin_sg  
!      cosa_u    => gridstruct%cosa_u  
!      cosa_v    => gridstruct%cosa_v  
!      cosa_s    => gridstruct%cosa_s  
!      rsin_u    => gridstruct%rsin_u  
!      rsin_v    => gridstruct%rsin_v  
!      rsin2     => gridstruct%rsin2   
!      dxa       => gridstruct%dxa     
!      dya       => gridstruct%dya     
    IF (dord4) THEN
      id = 1
    ELSE
      id = 0
    END IF
    IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
      npt = 4
    ELSE
      npt = -2
    END IF
! Initialize the non-existing corner regions
    utmp = big_number
    vtmp = big_number
    IF (nested) THEN
      utmp_tl = 0.0_FVPRC
      DO j=jsd+1,jed-1
        DO i=isd,ied
          utmp_tl(i, j) = a2*(u_tl(i, j-1)+u_tl(i, j+2)) + a1*(u_tl(i, j&
&           )+u_tl(i, j+1))
          utmp(i, j) = a2*(u(i, j-1)+u(i, j+2)) + a1*(u(i, j)+u(i, j+1))
        END DO
      END DO
      DO i=isd,ied
        j = jsd
        utmp_tl(i, j) = 0.5*(u_tl(i, j)+u_tl(i, j+1))
        utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
        j = jed
        utmp_tl(i, j) = 0.5*(u_tl(i, j)+u_tl(i, j+1))
        utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
      END DO
      vtmp_tl = 0.0_FVPRC
      DO j=jsd,jed
        DO i=isd+1,ied-1
          vtmp_tl(i, j) = a2*(v_tl(i-1, j)+v_tl(i+2, j)) + a1*(v_tl(i, j&
&           )+v_tl(i+1, j))
          vtmp(i, j) = a2*(v(i-1, j)+v(i+2, j)) + a1*(v(i, j)+v(i+1, j))
        END DO
        i = isd
        vtmp_tl(i, j) = 0.5*(v_tl(i, j)+v_tl(i+1, j))
        vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
        i = ied
        vtmp_tl(i, j) = 0.5*(v_tl(i, j)+v_tl(i+1, j))
        vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
      END DO
      DO j=jsd,jed
        DO i=isd,ied
          ua_tl(i, j) = gridstruct%rsin2(i, j)*(utmp_tl(i, j)-gridstruct&
&           %cosa_s(i, j)*vtmp_tl(i, j))
          ua(i, j) = (utmp(i, j)-vtmp(i, j)*gridstruct%cosa_s(i, j))*&
&           gridstruct%rsin2(i, j)
          va_tl(i, j) = gridstruct%rsin2(i, j)*(vtmp_tl(i, j)-gridstruct&
&           %cosa_s(i, j)*utmp_tl(i, j))
          va(i, j) = (vtmp(i, j)-utmp(i, j)*gridstruct%cosa_s(i, j))*&
&           gridstruct%rsin2(i, j)
        END DO
      END DO
    ELSE
      IF (npt .LT. js - 1) THEN
        max1 = js - 1
      ELSE
        max1 = npt
      END IF
      IF (npy - npt .GT. je + 1) THEN
        min1 = je + 1
        utmp_tl = 0.0_FVPRC
      ELSE
        min1 = npy - npt
        utmp_tl = 0.0_FVPRC
      END IF
!----------
! Interior:
!----------
      DO j=max1,min1
        IF (npt .LT. isd) THEN
          max2 = isd
        ELSE
          max2 = npt
        END IF
        IF (npx - npt .GT. ied) THEN
          min2 = ied
        ELSE
          min2 = npx - npt
        END IF
        DO i=max2,min2
          utmp_tl(i, j) = a2*(u_tl(i, j-1)+u_tl(i, j+2)) + a1*(u_tl(i, j&
&           )+u_tl(i, j+1))
          utmp(i, j) = a2*(u(i, j-1)+u(i, j+2)) + a1*(u(i, j)+u(i, j+1))
        END DO
      END DO
      IF (npt .LT. jsd) THEN
        max3 = jsd
      ELSE
        max3 = npt
      END IF
      IF (npy - npt .GT. jed) THEN
        min3 = jed
        vtmp_tl = 0.0_FVPRC
      ELSE
        min3 = npy - npt
        vtmp_tl = 0.0_FVPRC
      END IF
      DO j=max3,min3
        IF (npt .LT. is - 1) THEN
          max4 = is - 1
        ELSE
          max4 = npt
        END IF
        IF (npx - npt .GT. ie + 1) THEN
          min4 = ie + 1
        ELSE
          min4 = npx - npt
        END IF
        DO i=max4,min4
          vtmp_tl(i, j) = a2*(v_tl(i-1, j)+v_tl(i+2, j)) + a1*(v_tl(i, j&
&           )+v_tl(i+1, j))
          vtmp(i, j) = a2*(v(i-1, j)+v(i+2, j)) + a1*(v(i, j)+v(i+1, j))
        END DO
      END DO
!#ifdef EDGE_TEST
!                                                     call timing_on('COMM_TOTAL')
!  call mpp_update_domains(utmp, vtmp, domain)
!                                                     call timing_off('COMM_TOTAL')
!#else
!----------
! edges:
!----------
      IF (grid_type .LT. 3) THEN
        IF (js .EQ. 1 .OR. jsd .LT. npt) THEN
          DO j=jsd,npt-1
            DO i=isd,ied
              utmp_tl(i, j) = 0.5*(u_tl(i, j)+u_tl(i, j+1))
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp_tl(i, j) = 0.5*(v_tl(i, j)+v_tl(i+1, j))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
        END IF
        IF (je + 1 .EQ. npy .OR. jed .GE. npy - npt) THEN
          DO j=npy-npt+1,jed
            DO i=isd,ied
              utmp_tl(i, j) = 0.5*(u_tl(i, j)+u_tl(i, j+1))
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp_tl(i, j) = 0.5*(v_tl(i, j)+v_tl(i+1, j))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
        END IF
        IF (is .EQ. 1 .OR. isd .LT. npt) THEN
          IF (npt .LT. jsd) THEN
            max5 = jsd
          ELSE
            max5 = npt
          END IF
          IF (npy - npt .GT. jed) THEN
            min5 = jed
          ELSE
            min5 = npy - npt
          END IF
          DO j=max5,min5
            DO i=isd,npt-1
              utmp_tl(i, j) = 0.5*(u_tl(i, j)+u_tl(i, j+1))
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp_tl(i, j) = 0.5*(v_tl(i, j)+v_tl(i+1, j))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
        END IF
        IF (ie + 1 .EQ. npx .OR. ied .GE. npx - npt) THEN
          IF (npt .LT. jsd) THEN
            max6 = jsd
          ELSE
            max6 = npt
          END IF
          IF (npy - npt .GT. jed) THEN
            min6 = jed
          ELSE
            min6 = npy - npt
          END IF
          DO j=max6,min6
            DO i=npx-npt+1,ied
              utmp_tl(i, j) = 0.5*(u_tl(i, j)+u_tl(i, j+1))
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp_tl(i, j) = 0.5*(v_tl(i, j)+v_tl(i+1, j))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
        END IF
      END IF
!#endif
      DO j=js-1-id,je+1+id
        DO i=is-1-id,ie+1+id
          ua_tl(i, j) = gridstruct%rsin2(i, j)*(utmp_tl(i, j)-gridstruct&
&           %cosa_s(i, j)*vtmp_tl(i, j))
          ua(i, j) = (utmp(i, j)-vtmp(i, j)*gridstruct%cosa_s(i, j))*&
&           gridstruct%rsin2(i, j)
          va_tl(i, j) = gridstruct%rsin2(i, j)*(vtmp_tl(i, j)-gridstruct&
&           %cosa_s(i, j)*utmp_tl(i, j))
          va(i, j) = (vtmp(i, j)-utmp(i, j)*gridstruct%cosa_s(i, j))*&
&           gridstruct%rsin2(i, j)
        END DO
      END DO
    END IF
! A -> C
!--------------
! Fix the edges
!--------------
! Xdir:
    IF (sw_corner) THEN
      DO i=-2,0
        utmp_tl(i, 0) = -vtmp_tl(0, 1-i)
        utmp(i, 0) = -vtmp(0, 1-i)
      END DO
    END IF
    IF (se_corner) THEN
      DO i=0,2
        utmp_tl(npx+i, 0) = vtmp_tl(npx, i+1)
        utmp(npx+i, 0) = vtmp(npx, i+1)
      END DO
    END IF
    IF (ne_corner) THEN
      DO i=0,2
        utmp_tl(npx+i, npy) = -vtmp_tl(npx, je-i)
        utmp(npx+i, npy) = -vtmp(npx, je-i)
      END DO
    END IF
    IF (nw_corner) THEN
      DO i=-2,0
        utmp_tl(i, npy) = vtmp_tl(0, je+i)
        utmp(i, npy) = vtmp(0, je+i)
      END DO
    END IF
    IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
      IF (3 .LT. is - 1) THEN
        ifirst = is - 1
      ELSE
        ifirst = 3
      END IF
      IF (npx - 2 .GT. ie + 2) THEN
        ilast = ie + 2
      ELSE
        ilast = npx - 2
      END IF
    ELSE
      ifirst = is - 1
      ilast = ie + 2
    END IF
!---------------------------------------------
! 4th order interpolation for interior points:
!---------------------------------------------
    DO j=js-1,je+1
      DO i=ifirst,ilast
        uc_tl(i, j) = a1*(utmp_tl(i-1, j)+utmp_tl(i, j)) + a2*(utmp_tl(i&
&         -2, j)+utmp_tl(i+1, j))
        uc(i, j) = a1*(utmp(i-1, j)+utmp(i, j)) + a2*(utmp(i-2, j)+utmp(&
&         i+1, j))
      END DO
    END DO
    DO j=js-1,je+1
      DO i=ifirst,ilast
        ut_tl(i, j) = gridstruct%rsin_u(i, j)*(uc_tl(i, j)-gridstruct%&
&         cosa_u(i, j)*v_tl(i, j))
        ut(i, j) = (uc(i, j)-v(i, j)*gridstruct%cosa_u(i, j))*gridstruct&
&         %rsin_u(i, j)
      END DO
    END DO
    IF (grid_type .LT. 3) THEN
!#ifndef TEST_NEW
! Xdir:
      IF (sw_corner) THEN
        ua_tl(-1, 0) = -va_tl(0, 2)
        ua(-1, 0) = -va(0, 2)
        ua_tl(0, 0) = -va_tl(0, 1)
        ua(0, 0) = -va(0, 1)
      END IF
      IF (se_corner) THEN
        ua_tl(npx, 0) = va_tl(npx, 1)
        ua(npx, 0) = va(npx, 1)
        ua_tl(npx+1, 0) = va_tl(npx, 2)
        ua(npx+1, 0) = va(npx, 2)
      END IF
      IF (ne_corner) THEN
        ua_tl(npx, npy) = -va_tl(npx, npy-1)
        ua(npx, npy) = -va(npx, npy-1)
        ua_tl(npx+1, npy) = -va_tl(npx, npy-2)
        ua(npx+1, npy) = -va(npx, npy-2)
      END IF
      IF (nw_corner) THEN
        ua_tl(-1, npy) = va_tl(0, npy-2)
        ua(-1, npy) = va(0, npy-2)
        ua_tl(0, npy) = va_tl(0, npy-1)
        ua(0, npy) = va(0, npy-1)
      END IF
!#endif
      IF (is .EQ. 1 .AND. (.NOT.nested)) THEN
        DO j=js-1,je+1
          uc_tl(0, j) = c1*utmp_tl(-2, j) + c2*utmp_tl(-1, j) + c3*&
&           utmp_tl(0, j)
          uc(0, j) = c1*utmp(-2, j) + c2*utmp(-1, j) + c3*utmp(0, j)
!#ifndef TEST_NEW
!ut(1,j) = 0.25*(-ua(-1,j) + 3.*(ua(0,j)+ua(1,j)) - ua(2,j))
!           uc(1,j) = 0.25*(-utmp(-1,j) + 3.*(utmp(0,j)+utmp(1,j)) - utmp(2,j))
          ut_tl(1, j) = EDGE_INTERPOLATE4_TLM(ua(-1:2, j), ua_tl(-1:2, j&
&           ), gridstruct%dxa(-1:2, j), ut(1, j))
!Want to use the UPSTREAM value
!#ifdef UPSTREAM_FIXED
!           if (ut(1,j) > 0.) then
!#else
          IF (ut(1, j) .LT. 0.) THEN
!#endif
            uc_tl(1, j) = gridstruct%sin_sg(0, j, 3)*ut_tl(1, j)
            uc(1, j) = ut(1, j)*gridstruct%sin_sg(0, j, 3)
          ELSE
            uc_tl(1, j) = gridstruct%sin_sg(1, j, 1)*ut_tl(1, j)
            uc(1, j) = ut(1, j)*gridstruct%sin_sg(1, j, 1)
          END IF
!#else
!! 3-pt extrapolation: grid symmetry assumed --------------------------------
!           uc(1,j) = ( t14*(utmp( 0,j)+utmp(1,j))    &
!                     + t12*(utmp(-1,j)+utmp(2,j))    &
!                     + t15*(utmp(-2,j)+utmp(3,j)) )*gridstruct%rsin_u(1,j)
!           ut(1,j) =  uc(1,j) * gridstruct%rsin_u(1,j)
!! 3-pt extrapolation: grid symmetry assumed --------------------------------
!#endif
          uc_tl(2, j) = c1*utmp_tl(3, j) + c2*utmp_tl(2, j) + c3*utmp_tl&
&           (1, j)
          uc(2, j) = c1*utmp(3, j) + c2*utmp(2, j) + c3*utmp(1, j)
          ut_tl(0, j) = gridstruct%rsin_u(0, j)*(uc_tl(0, j)-gridstruct%&
&           cosa_u(0, j)*v_tl(0, j))
          ut(0, j) = (uc(0, j)-v(0, j)*gridstruct%cosa_u(0, j))*&
&           gridstruct%rsin_u(0, j)
          ut_tl(2, j) = gridstruct%rsin_u(2, j)*(uc_tl(2, j)-gridstruct%&
&           cosa_u(2, j)*v_tl(2, j))
          ut(2, j) = (uc(2, j)-v(2, j)*gridstruct%cosa_u(2, j))*&
&           gridstruct%rsin_u(2, j)
        END DO
      END IF
      IF (ie + 1 .EQ. npx .AND. (.NOT.nested)) THEN
        DO j=js-1,je+1
          uc_tl(npx-1, j) = c1*utmp_tl(npx-3, j) + c2*utmp_tl(npx-2, j) &
&           + c3*utmp_tl(npx-1, j)
          uc(npx-1, j) = c1*utmp(npx-3, j) + c2*utmp(npx-2, j) + c3*utmp&
&           (npx-1, j)
!#ifndef TEST_NEW
          i = npx
          ut_tl(i, j) = 0.25*(3.*(ua_tl(i-1, j)+ua_tl(i, j))-ua_tl(i-2, &
&           j)-ua_tl(i+1, j))
          ut(i, j) = 0.25*(-ua(i-2, j)+3.*(ua(i-1, j)+ua(i, j))-ua(i+1, &
&           j))
          ut_tl(i, j) = EDGE_INTERPOLATE4_TLM(ua(i-2:i+1, j), ua_tl(i-2:&
&           i+1, j), gridstruct%dxa(i-2:i+1, j), ut(i, j))
!#ifdef UPSTREAM_FIXED
!        if (ut(i,j) > 0.) then
!#else
          IF (ut(i, j) .LT. 0.) THEN
!#endif
            uc_tl(i, j) = gridstruct%sin_sg(i-1, j, 3)*ut_tl(i, j)
            uc(i, j) = ut(i, j)*gridstruct%sin_sg(i-1, j, 3)
          ELSE
            uc_tl(i, j) = gridstruct%sin_sg(i, j, 1)*ut_tl(i, j)
            uc(i, j) = ut(i, j)*gridstruct%sin_sg(i, j, 1)
          END IF
!#else
!! 3-pt extrapolation --------------------------------------------------------
!           uc(npx,j) = (t14*(utmp(npx-1,j)+utmp(npx,j))+      &
!                        t12*(utmp(npx-2,j)+utmp(npx+1,j))     &
!                      + t15*(utmp(npx-3,j)+utmp(npx+2,j)))*gridstruct%rsin_u(npx,j)
!           ut(npx,  j) =  uc(npx,j) * gridstruct%rsin_u(npx,j)
!! 3-pt extrapolation --------------------------------------------------------
!#endif
          uc_tl(npx+1, j) = c3*utmp_tl(npx, j) + c2*utmp_tl(npx+1, j) + &
&           c1*utmp_tl(npx+2, j)
          uc(npx+1, j) = c3*utmp(npx, j) + c2*utmp(npx+1, j) + c1*utmp(&
&           npx+2, j)
          ut_tl(npx-1, j) = gridstruct%rsin_u(npx-1, j)*(uc_tl(npx-1, j)&
&           -gridstruct%cosa_u(npx-1, j)*v_tl(npx-1, j))
          ut(npx-1, j) = (uc(npx-1, j)-v(npx-1, j)*gridstruct%cosa_u(npx&
&           -1, j))*gridstruct%rsin_u(npx-1, j)
          ut_tl(npx+1, j) = gridstruct%rsin_u(npx+1, j)*(uc_tl(npx+1, j)&
&           -gridstruct%cosa_u(npx+1, j)*v_tl(npx+1, j))
          ut(npx+1, j) = (uc(npx+1, j)-v(npx+1, j)*gridstruct%cosa_u(npx&
&           +1, j))*gridstruct%rsin_u(npx+1, j)
        END DO
      END IF
    END IF
!------
! Ydir:
!------
    IF (sw_corner) THEN
      DO j=-2,0
        vtmp_tl(0, j) = -utmp_tl(1-j, 0)
        vtmp(0, j) = -utmp(1-j, 0)
      END DO
    END IF
    IF (nw_corner) THEN
      DO j=0,2
        vtmp_tl(0, npy+j) = utmp_tl(j+1, npy)
        vtmp(0, npy+j) = utmp(j+1, npy)
      END DO
    END IF
    IF (se_corner) THEN
      DO j=-2,0
        vtmp_tl(npx, j) = utmp_tl(ie+j, 0)
        vtmp(npx, j) = utmp(ie+j, 0)
      END DO
    END IF
    IF (ne_corner) THEN
      DO j=0,2
        vtmp_tl(npx, npy+j) = -utmp_tl(ie-j, npy)
        vtmp(npx, npy+j) = -utmp(ie-j, npy)
      END DO
    END IF
!#ifndef TEST_NEW
    IF (sw_corner) THEN
      va_tl(0, -1) = -ua_tl(2, 0)
      va(0, -1) = -ua(2, 0)
      va_tl(0, 0) = -ua_tl(1, 0)
      va(0, 0) = -ua(1, 0)
    END IF
    IF (se_corner) THEN
      va_tl(npx, 0) = ua_tl(npx-1, 0)
      va(npx, 0) = ua(npx-1, 0)
      va_tl(npx, -1) = ua_tl(npx-2, 0)
      va(npx, -1) = ua(npx-2, 0)
    END IF
    IF (ne_corner) THEN
      va_tl(npx, npy) = -ua_tl(npx-1, npy)
      va(npx, npy) = -ua(npx-1, npy)
      va_tl(npx, npy+1) = -ua_tl(npx-2, npy)
      va(npx, npy+1) = -ua(npx-2, npy)
    END IF
    IF (nw_corner) THEN
      va_tl(0, npy) = ua_tl(1, npy)
      va(0, npy) = ua(1, npy)
      va_tl(0, npy+1) = ua_tl(2, npy)
      va(0, npy+1) = ua(2, npy)
    END IF
!#endif
    IF (grid_type .LT. 3) THEN
      DO j=js-1,je+2
        IF (j .EQ. 1 .AND. (.NOT.nested)) THEN
          DO i=is-1,ie+1
!#ifndef TEST_NEW
!vt(i,j) = 0.25*(-va(i,j-2) + 3.*(va(i,j-1)+va(i,j)) - va(i,j+1))
!           vc(i,j) = 0.25*(-vtmp(i,j-2) + 3.*(vtmp(i,j-1)+vtmp(i,j)) - vtmp(i,j+1))
            vt_tl(i, j) = EDGE_INTERPOLATE4_TLM(va(i, -1:2), va_tl(i, -1&
&             :2), gridstruct%dya(i, -1:2), vt(i, j))
!#ifdef UPSTREAM_FIXED
!           if (vt(i,j) > 0.) then
!#else
            IF (vt(i, j) .LT. 0.) THEN
!#endif
              vc_tl(i, j) = gridstruct%sin_sg(i, j-1, 4)*vt_tl(i, j)
              vc(i, j) = vt(i, j)*gridstruct%sin_sg(i, j-1, 4)
            ELSE
              vc_tl(i, j) = gridstruct%sin_sg(i, j, 2)*vt_tl(i, j)
              vc(i, j) = vt(i, j)*gridstruct%sin_sg(i, j, 2)
            END IF
          END DO
        ELSE IF (j .EQ. 0 .OR. (j .EQ. npy - 1 .AND. (.NOT.nested))) &
&       THEN
!#else
!! 3-pt extrapolation -----------------------------------------
!           vc(i,1) = (t14*(vtmp(i, 0)+vtmp(i,1))    &
!                    + t12*(vtmp(i,-1)+vtmp(i,2))    &
!                    + t15*(vtmp(i,-2)+vtmp(i,3)))*gridstruct%rsin_v(i,1)
!           vt(i,1) = vc(i,1) * gridstruct%rsin_v(i,1)
!! 3-pt extrapolation -----------------------------------------
!#endif
          DO i=is-1,ie+1
            vc_tl(i, j) = c1*vtmp_tl(i, j-2) + c2*vtmp_tl(i, j-1) + c3*&
&             vtmp_tl(i, j)
            vc(i, j) = c1*vtmp(i, j-2) + c2*vtmp(i, j-1) + c3*vtmp(i, j)
            vt_tl(i, j) = gridstruct%rsin_v(i, j)*(vc_tl(i, j)-&
&             gridstruct%cosa_v(i, j)*u_tl(i, j))
            vt(i, j) = (vc(i, j)-u(i, j)*gridstruct%cosa_v(i, j))*&
&             gridstruct%rsin_v(i, j)
          END DO
        ELSE IF (j .EQ. 2 .OR. (j .EQ. npy + 1 .AND. (.NOT.nested))) &
&       THEN
          DO i=is-1,ie+1
            vc_tl(i, j) = c1*vtmp_tl(i, j+1) + c2*vtmp_tl(i, j) + c3*&
&             vtmp_tl(i, j-1)
            vc(i, j) = c1*vtmp(i, j+1) + c2*vtmp(i, j) + c3*vtmp(i, j-1)
            vt_tl(i, j) = gridstruct%rsin_v(i, j)*(vc_tl(i, j)-&
&             gridstruct%cosa_v(i, j)*u_tl(i, j))
            vt(i, j) = (vc(i, j)-u(i, j)*gridstruct%cosa_v(i, j))*&
&             gridstruct%rsin_v(i, j)
          END DO
        ELSE IF (j .EQ. npy .AND. (.NOT.nested)) THEN
          DO i=is-1,ie+1
!#ifndef TEST_NEW
            vt_tl(i, j) = 0.25*(3.*(va_tl(i, j-1)+va_tl(i, j))-va_tl(i, &
&             j-2)-va_tl(i, j+1))
            vt(i, j) = 0.25*(-va(i, j-2)+3.*(va(i, j-1)+va(i, j))-va(i, &
&             j+1))
!           vc(i,j) = 0.25*(-vtmp(i,j-2) + 3.*(vtmp(i,j-1)+vtmp(i,j)) - vtmp(i,j+1))
            vt_tl(i, j) = EDGE_INTERPOLATE4_TLM(va(i, j-2:j+1), va_tl(i&
&             , j-2:j+1), gridstruct%dya(i, j-2:j+1), vt(i, j))
!#ifdef UPSTREAM_FIXED
!           if (vt(i,j) > 0.) then
!#else
            IF (vt(i, j) .LT. 0.) THEN
!#endif
              vc_tl(i, j) = gridstruct%sin_sg(i, j-1, 4)*vt_tl(i, j)
              vc(i, j) = vt(i, j)*gridstruct%sin_sg(i, j-1, 4)
            ELSE
              vc_tl(i, j) = gridstruct%sin_sg(i, j, 2)*vt_tl(i, j)
              vc(i, j) = vt(i, j)*gridstruct%sin_sg(i, j, 2)
            END IF
          END DO
        ELSE
!#else
!! 3-pt extrapolation --------------------------------------------------------
!           vc(i,npy) = (t14*(vtmp(i,npy-1)+vtmp(i,npy))    &
!                      + t12*(vtmp(i,npy-2)+vtmp(i,npy+1))  &
!                      + t15*(vtmp(i,npy-3)+vtmp(i,npy+2)))*gridstruct%rsin_v(i,npy)
!           vt(i,npy) = vc(i,npy) * gridstruct%rsin_v(i,npy)
!! 3-pt extrapolation -----------------------------------------
!#endif
! 4th order interpolation for interior points:
          DO i=is-1,ie+1
            vc_tl(i, j) = a2*(vtmp_tl(i, j-2)+vtmp_tl(i, j+1)) + a1*(&
&             vtmp_tl(i, j-1)+vtmp_tl(i, j))
            vc(i, j) = a2*(vtmp(i, j-2)+vtmp(i, j+1)) + a1*(vtmp(i, j-1)&
&             +vtmp(i, j))
            vt_tl(i, j) = gridstruct%rsin_v(i, j)*(vc_tl(i, j)-&
&             gridstruct%cosa_v(i, j)*u_tl(i, j))
            vt(i, j) = (vc(i, j)-u(i, j)*gridstruct%cosa_v(i, j))*&
&             gridstruct%rsin_v(i, j)
          END DO
        END IF
      END DO
    ELSE
! 4th order interpolation:
      DO j=js-1,je+2
        DO i=is-1,ie+1
          vc_tl(i, j) = a2*(vtmp_tl(i, j-2)+vtmp_tl(i, j+1)) + a1*(&
&           vtmp_tl(i, j-1)+vtmp_tl(i, j))
          vc(i, j) = a2*(vtmp(i, j-2)+vtmp(i, j+1)) + a1*(vtmp(i, j-1)+&
&           vtmp(i, j))
        END DO
      END DO
      DO j=js-1,je+2
        DO i=is-1,ie+1
          vt_tl(i, j) = vc_tl(i, j)
          vt(i, j) = vc(i, j)
        END DO
      END DO
    END IF
  END SUBROUTINE D2A2C_VECT_TLM
!There is a limit to how far this routine can fill uc and vc in the
! halo, and so either mpp_update_domains or some sort of boundary
!  routine (extrapolation, outflow, interpolation from a nested grid)
!   is needed after c_sw is completed if these variables are needed
!    in the halo
  SUBROUTINE D2A2C_VECT(u, v, ua, va, uc, vc, ut, vt, dord4, gridstruct&
&   , bd, npx, npy, nested, grid_type)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    LOGICAL, INTENT(IN) :: dord4
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(OUT) &
&   :: uc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(OUT) &
&   :: vc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(OUT) ::&
&   ua, va, ut, vt
    INTEGER, INTENT(IN) :: npx, npy, grid_type
    LOGICAL, INTENT(IN) :: nested
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
! Local 
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: utmp, vtmp
    INTEGER :: npt, i, j, ifirst, ilast, id
!  real(FVPRC), pointer, dimension(:,:,:) :: sin_sg
!  real(FVPRC), pointer, dimension(:,:)   :: cosa_u, cosa_v, cosa_s
!  real(FVPRC), pointer, dimension(:,:)   :: rsin_u, rsin_v, rsin2
!  real(FVPRC), pointer, dimension(:,:)   ::  dxa,dya
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: max5
    INTEGER :: max6
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    INTEGER :: min5
    INTEGER :: min6
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
!      sin_sg    => gridstruct%sin_sg  
!      cosa_u    => gridstruct%cosa_u  
!      cosa_v    => gridstruct%cosa_v  
!      cosa_s    => gridstruct%cosa_s  
!      rsin_u    => gridstruct%rsin_u  
!      rsin_v    => gridstruct%rsin_v  
!      rsin2     => gridstruct%rsin2   
!      dxa       => gridstruct%dxa     
!      dya       => gridstruct%dya     
    IF (dord4) THEN
      id = 1
    ELSE
      id = 0
    END IF
    IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
      npt = 4
    ELSE
      npt = -2
    END IF
! Initialize the non-existing corner regions
    utmp = big_number
    vtmp = big_number
    IF (nested) THEN
      DO j=jsd+1,jed-1
        DO i=isd,ied
          utmp(i, j) = a2*(u(i, j-1)+u(i, j+2)) + a1*(u(i, j)+u(i, j+1))
        END DO
      END DO
      DO i=isd,ied
        j = jsd
        utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
        j = jed
        utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
      END DO
      DO j=jsd,jed
        DO i=isd+1,ied-1
          vtmp(i, j) = a2*(v(i-1, j)+v(i+2, j)) + a1*(v(i, j)+v(i+1, j))
        END DO
        i = isd
        vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
        i = ied
        vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
      END DO
      DO j=jsd,jed
        DO i=isd,ied
          ua(i, j) = (utmp(i, j)-vtmp(i, j)*gridstruct%cosa_s(i, j))*&
&           gridstruct%rsin2(i, j)
          va(i, j) = (vtmp(i, j)-utmp(i, j)*gridstruct%cosa_s(i, j))*&
&           gridstruct%rsin2(i, j)
        END DO
      END DO
    ELSE
      IF (npt .LT. js - 1) THEN
        max1 = js - 1
      ELSE
        max1 = npt
      END IF
      IF (npy - npt .GT. je + 1) THEN
        min1 = je + 1
      ELSE
        min1 = npy - npt
      END IF
!----------
! Interior:
!----------
      DO j=max1,min1
        IF (npt .LT. isd) THEN
          max2 = isd
        ELSE
          max2 = npt
        END IF
        IF (npx - npt .GT. ied) THEN
          min2 = ied
        ELSE
          min2 = npx - npt
        END IF
        DO i=max2,min2
          utmp(i, j) = a2*(u(i, j-1)+u(i, j+2)) + a1*(u(i, j)+u(i, j+1))
        END DO
      END DO
      IF (npt .LT. jsd) THEN
        max3 = jsd
      ELSE
        max3 = npt
      END IF
      IF (npy - npt .GT. jed) THEN
        min3 = jed
      ELSE
        min3 = npy - npt
      END IF
      DO j=max3,min3
        IF (npt .LT. is - 1) THEN
          max4 = is - 1
        ELSE
          max4 = npt
        END IF
        IF (npx - npt .GT. ie + 1) THEN
          min4 = ie + 1
        ELSE
          min4 = npx - npt
        END IF
        DO i=max4,min4
          vtmp(i, j) = a2*(v(i-1, j)+v(i+2, j)) + a1*(v(i, j)+v(i+1, j))
        END DO
      END DO
!#ifdef EDGE_TEST
!                                                     call timing_on('COMM_TOTAL')
!  call mpp_update_domains(utmp, vtmp, domain)
!                                                     call timing_off('COMM_TOTAL')
!#else
!----------
! edges:
!----------
      IF (grid_type .LT. 3) THEN
        IF (js .EQ. 1 .OR. jsd .LT. npt) THEN
          DO j=jsd,npt-1
            DO i=isd,ied
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
        END IF
        IF (je + 1 .EQ. npy .OR. jed .GE. npy - npt) THEN
          DO j=npy-npt+1,jed
            DO i=isd,ied
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
        END IF
        IF (is .EQ. 1 .OR. isd .LT. npt) THEN
          IF (npt .LT. jsd) THEN
            max5 = jsd
          ELSE
            max5 = npt
          END IF
          IF (npy - npt .GT. jed) THEN
            min5 = jed
          ELSE
            min5 = npy - npt
          END IF
          DO j=max5,min5
            DO i=isd,npt-1
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
        END IF
        IF (ie + 1 .EQ. npx .OR. ied .GE. npx - npt) THEN
          IF (npt .LT. jsd) THEN
            max6 = jsd
          ELSE
            max6 = npt
          END IF
          IF (npy - npt .GT. jed) THEN
            min6 = jed
          ELSE
            min6 = npy - npt
          END IF
          DO j=max6,min6
            DO i=npx-npt+1,ied
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
        END IF
      END IF
!#endif
      DO j=js-1-id,je+1+id
        DO i=is-1-id,ie+1+id
          ua(i, j) = (utmp(i, j)-vtmp(i, j)*gridstruct%cosa_s(i, j))*&
&           gridstruct%rsin2(i, j)
          va(i, j) = (vtmp(i, j)-utmp(i, j)*gridstruct%cosa_s(i, j))*&
&           gridstruct%rsin2(i, j)
        END DO
      END DO
    END IF
! A -> C
!--------------
! Fix the edges
!--------------
! Xdir:
    IF (sw_corner) THEN
      DO i=-2,0
        utmp(i, 0) = -vtmp(0, 1-i)
      END DO
    END IF
    IF (se_corner) THEN
      DO i=0,2
        utmp(npx+i, 0) = vtmp(npx, i+1)
      END DO
    END IF
    IF (ne_corner) THEN
      DO i=0,2
        utmp(npx+i, npy) = -vtmp(npx, je-i)
      END DO
    END IF
    IF (nw_corner) THEN
      DO i=-2,0
        utmp(i, npy) = vtmp(0, je+i)
      END DO
    END IF
    IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
      IF (3 .LT. is - 1) THEN
        ifirst = is - 1
      ELSE
        ifirst = 3
      END IF
      IF (npx - 2 .GT. ie + 2) THEN
        ilast = ie + 2
      ELSE
        ilast = npx - 2
      END IF
    ELSE
      ifirst = is - 1
      ilast = ie + 2
    END IF
!---------------------------------------------
! 4th order interpolation for interior points:
!---------------------------------------------
    DO j=js-1,je+1
      DO i=ifirst,ilast
        uc(i, j) = a1*(utmp(i-1, j)+utmp(i, j)) + a2*(utmp(i-2, j)+utmp(&
&         i+1, j))
      END DO
    END DO
    DO j=js-1,je+1
      DO i=ifirst,ilast
        ut(i, j) = (uc(i, j)-v(i, j)*gridstruct%cosa_u(i, j))*gridstruct&
&         %rsin_u(i, j)
      END DO
    END DO
    IF (grid_type .LT. 3) THEN
!#ifndef TEST_NEW
! Xdir:
      IF (sw_corner) THEN
        ua(-1, 0) = -va(0, 2)
        ua(0, 0) = -va(0, 1)
      END IF
      IF (se_corner) THEN
        ua(npx, 0) = va(npx, 1)
        ua(npx+1, 0) = va(npx, 2)
      END IF
      IF (ne_corner) THEN
        ua(npx, npy) = -va(npx, npy-1)
        ua(npx+1, npy) = -va(npx, npy-2)
      END IF
      IF (nw_corner) THEN
        ua(-1, npy) = va(0, npy-2)
        ua(0, npy) = va(0, npy-1)
      END IF
!#endif
      IF (is .EQ. 1 .AND. (.NOT.nested)) THEN
        DO j=js-1,je+1
          uc(0, j) = c1*utmp(-2, j) + c2*utmp(-1, j) + c3*utmp(0, j)
!#ifndef TEST_NEW
!ut(1,j) = 0.25*(-ua(-1,j) + 3.*(ua(0,j)+ua(1,j)) - ua(2,j))
!           uc(1,j) = 0.25*(-utmp(-1,j) + 3.*(utmp(0,j)+utmp(1,j)) - utmp(2,j))
          ut(1, j) = EDGE_INTERPOLATE4(ua(-1:2, j), gridstruct%dxa(-1:2&
&           , j))
!Want to use the UPSTREAM value
!#ifdef UPSTREAM_FIXED
!           if (ut(1,j) > 0.) then
!#else
          IF (ut(1, j) .LT. 0.) THEN
!#endif
            uc(1, j) = ut(1, j)*gridstruct%sin_sg(0, j, 3)
          ELSE
            uc(1, j) = ut(1, j)*gridstruct%sin_sg(1, j, 1)
          END IF
!#else
!! 3-pt extrapolation: grid symmetry assumed --------------------------------
!           uc(1,j) = ( t14*(utmp( 0,j)+utmp(1,j))    &
!                     + t12*(utmp(-1,j)+utmp(2,j))    &
!                     + t15*(utmp(-2,j)+utmp(3,j)) )*gridstruct%rsin_u(1,j)
!           ut(1,j) =  uc(1,j) * gridstruct%rsin_u(1,j)
!! 3-pt extrapolation: grid symmetry assumed --------------------------------
!#endif
          uc(2, j) = c1*utmp(3, j) + c2*utmp(2, j) + c3*utmp(1, j)
          ut(0, j) = (uc(0, j)-v(0, j)*gridstruct%cosa_u(0, j))*&
&           gridstruct%rsin_u(0, j)
          ut(2, j) = (uc(2, j)-v(2, j)*gridstruct%cosa_u(2, j))*&
&           gridstruct%rsin_u(2, j)
        END DO
      END IF
      IF (ie + 1 .EQ. npx .AND. (.NOT.nested)) THEN
        DO j=js-1,je+1
          uc(npx-1, j) = c1*utmp(npx-3, j) + c2*utmp(npx-2, j) + c3*utmp&
&           (npx-1, j)
!#ifndef TEST_NEW
          i = npx
          ut(i, j) = 0.25*(-ua(i-2, j)+3.*(ua(i-1, j)+ua(i, j))-ua(i+1, &
&           j))
          ut(i, j) = EDGE_INTERPOLATE4(ua(i-2:i+1, j), gridstruct%dxa(i-&
&           2:i+1, j))
!#ifdef UPSTREAM_FIXED
!        if (ut(i,j) > 0.) then
!#else
          IF (ut(i, j) .LT. 0.) THEN
!#endif
            uc(i, j) = ut(i, j)*gridstruct%sin_sg(i-1, j, 3)
          ELSE
            uc(i, j) = ut(i, j)*gridstruct%sin_sg(i, j, 1)
          END IF
!#else
!! 3-pt extrapolation --------------------------------------------------------
!           uc(npx,j) = (t14*(utmp(npx-1,j)+utmp(npx,j))+      &
!                        t12*(utmp(npx-2,j)+utmp(npx+1,j))     &
!                      + t15*(utmp(npx-3,j)+utmp(npx+2,j)))*gridstruct%rsin_u(npx,j)
!           ut(npx,  j) =  uc(npx,j) * gridstruct%rsin_u(npx,j)
!! 3-pt extrapolation --------------------------------------------------------
!#endif
          uc(npx+1, j) = c3*utmp(npx, j) + c2*utmp(npx+1, j) + c1*utmp(&
&           npx+2, j)
          ut(npx-1, j) = (uc(npx-1, j)-v(npx-1, j)*gridstruct%cosa_u(npx&
&           -1, j))*gridstruct%rsin_u(npx-1, j)
          ut(npx+1, j) = (uc(npx+1, j)-v(npx+1, j)*gridstruct%cosa_u(npx&
&           +1, j))*gridstruct%rsin_u(npx+1, j)
        END DO
      END IF
    END IF
!------
! Ydir:
!------
    IF (sw_corner) THEN
      DO j=-2,0
        vtmp(0, j) = -utmp(1-j, 0)
      END DO
    END IF
    IF (nw_corner) THEN
      DO j=0,2
        vtmp(0, npy+j) = utmp(j+1, npy)
      END DO
    END IF
    IF (se_corner) THEN
      DO j=-2,0
        vtmp(npx, j) = utmp(ie+j, 0)
      END DO
    END IF
    IF (ne_corner) THEN
      DO j=0,2
        vtmp(npx, npy+j) = -utmp(ie-j, npy)
      END DO
    END IF
!#ifndef TEST_NEW
    IF (sw_corner) THEN
      va(0, -1) = -ua(2, 0)
      va(0, 0) = -ua(1, 0)
    END IF
    IF (se_corner) THEN
      va(npx, 0) = ua(npx-1, 0)
      va(npx, -1) = ua(npx-2, 0)
    END IF
    IF (ne_corner) THEN
      va(npx, npy) = -ua(npx-1, npy)
      va(npx, npy+1) = -ua(npx-2, npy)
    END IF
    IF (nw_corner) THEN
      va(0, npy) = ua(1, npy)
      va(0, npy+1) = ua(2, npy)
    END IF
!#endif
    IF (grid_type .LT. 3) THEN
      DO j=js-1,je+2
        IF (j .EQ. 1 .AND. (.NOT.nested)) THEN
          DO i=is-1,ie+1
!#ifndef TEST_NEW
!vt(i,j) = 0.25*(-va(i,j-2) + 3.*(va(i,j-1)+va(i,j)) - va(i,j+1))
!           vc(i,j) = 0.25*(-vtmp(i,j-2) + 3.*(vtmp(i,j-1)+vtmp(i,j)) - vtmp(i,j+1))
            vt(i, j) = EDGE_INTERPOLATE4(va(i, -1:2), gridstruct%dya(i, &
&             -1:2))
!#ifdef UPSTREAM_FIXED
!           if (vt(i,j) > 0.) then
!#else
            IF (vt(i, j) .LT. 0.) THEN
!#endif
              vc(i, j) = vt(i, j)*gridstruct%sin_sg(i, j-1, 4)
            ELSE
              vc(i, j) = vt(i, j)*gridstruct%sin_sg(i, j, 2)
            END IF
          END DO
        ELSE IF (j .EQ. 0 .OR. (j .EQ. npy - 1 .AND. (.NOT.nested))) &
&       THEN
!#else
!! 3-pt extrapolation -----------------------------------------
!           vc(i,1) = (t14*(vtmp(i, 0)+vtmp(i,1))    &
!                    + t12*(vtmp(i,-1)+vtmp(i,2))    &
!                    + t15*(vtmp(i,-2)+vtmp(i,3)))*gridstruct%rsin_v(i,1)
!           vt(i,1) = vc(i,1) * gridstruct%rsin_v(i,1)
!! 3-pt extrapolation -----------------------------------------
!#endif
          DO i=is-1,ie+1
            vc(i, j) = c1*vtmp(i, j-2) + c2*vtmp(i, j-1) + c3*vtmp(i, j)
            vt(i, j) = (vc(i, j)-u(i, j)*gridstruct%cosa_v(i, j))*&
&             gridstruct%rsin_v(i, j)
          END DO
        ELSE IF (j .EQ. 2 .OR. (j .EQ. npy + 1 .AND. (.NOT.nested))) &
&       THEN
          DO i=is-1,ie+1
            vc(i, j) = c1*vtmp(i, j+1) + c2*vtmp(i, j) + c3*vtmp(i, j-1)
            vt(i, j) = (vc(i, j)-u(i, j)*gridstruct%cosa_v(i, j))*&
&             gridstruct%rsin_v(i, j)
          END DO
        ELSE IF (j .EQ. npy .AND. (.NOT.nested)) THEN
          DO i=is-1,ie+1
!#ifndef TEST_NEW
            vt(i, j) = 0.25*(-va(i, j-2)+3.*(va(i, j-1)+va(i, j))-va(i, &
&             j+1))
!           vc(i,j) = 0.25*(-vtmp(i,j-2) + 3.*(vtmp(i,j-1)+vtmp(i,j)) - vtmp(i,j+1))
            vt(i, j) = EDGE_INTERPOLATE4(va(i, j-2:j+1), gridstruct%dya(&
&             i, j-2:j+1))
!#ifdef UPSTREAM_FIXED
!           if (vt(i,j) > 0.) then
!#else
            IF (vt(i, j) .LT. 0.) THEN
!#endif
              vc(i, j) = vt(i, j)*gridstruct%sin_sg(i, j-1, 4)
            ELSE
              vc(i, j) = vt(i, j)*gridstruct%sin_sg(i, j, 2)
            END IF
          END DO
        ELSE
!#else
!! 3-pt extrapolation --------------------------------------------------------
!           vc(i,npy) = (t14*(vtmp(i,npy-1)+vtmp(i,npy))    &
!                      + t12*(vtmp(i,npy-2)+vtmp(i,npy+1))  &
!                      + t15*(vtmp(i,npy-3)+vtmp(i,npy+2)))*gridstruct%rsin_v(i,npy)
!           vt(i,npy) = vc(i,npy) * gridstruct%rsin_v(i,npy)
!! 3-pt extrapolation -----------------------------------------
!#endif
! 4th order interpolation for interior points:
          DO i=is-1,ie+1
            vc(i, j) = a2*(vtmp(i, j-2)+vtmp(i, j+1)) + a1*(vtmp(i, j-1)&
&             +vtmp(i, j))
            vt(i, j) = (vc(i, j)-u(i, j)*gridstruct%cosa_v(i, j))*&
&             gridstruct%rsin_v(i, j)
          END DO
        END IF
      END DO
    ELSE
! 4th order interpolation:
      DO j=js-1,je+2
        DO i=is-1,ie+1
          vc(i, j) = a2*(vtmp(i, j-2)+vtmp(i, j+1)) + a1*(vtmp(i, j-1)+&
&           vtmp(i, j))
        END DO
      END DO
      DO j=js-1,je+2
        DO i=is-1,ie+1
          vt(i, j) = vc(i, j)
        END DO
      END DO
    END IF
  END SUBROUTINE D2A2C_VECT
!  Differentiation of edge_interpolate4 in forward (tangent) mode (with options r8):
!   variations   of useful results: edge_interpolate4
!   with respect to varying inputs: ua
  REAL(fvprc) FUNCTION EDGE_INTERPOLATE4_TLM(ua, ua_tl, dxa, &
&   edge_interpolate4)
    IMPLICIT NONE
!This is the original edge-interpolation code, which makes
! a relatively small increase in the error in unstretched case 2.
!   edge_interpolate4 = 0.25*( 3*(ua(2)+ua(3)) - (ua(1)+ua(4))  )
    REAL(fvprc), INTENT(IN) :: ua(4)
    REAL(fvprc), INTENT(IN) :: ua_tl(4)
    REAL(fvprc), INTENT(IN) :: dxa(4)
    REAL(fvprc) :: u0l, u0r
    REAL(fvprc) :: u0l_tl, u0r_tl
    REAL(fvprc) :: edge_interpolate4
    u0l_tl = 0.5*((2.*dxa(2)+dxa(1))*ua_tl(2)-dxa(2)*ua_tl(1))/(dxa(1)+&
&     dxa(2))
    u0l = 0.5*((2.*dxa(2)+dxa(1))*ua(2)-dxa(2)*ua(1))/(dxa(1)+dxa(2))
    u0r_tl = 0.5*((2.*dxa(3)+dxa(4))*ua_tl(3)-dxa(3)*ua_tl(4))/(dxa(3)+&
&     dxa(4))
    u0r = 0.5*((2.*dxa(3)+dxa(4))*ua(3)-dxa(3)*ua(4))/(dxa(3)+dxa(4))
    edge_interpolate4_tlm = u0l_tl + u0r_tl
    edge_interpolate4 = u0l + u0r
  END FUNCTION EDGE_INTERPOLATE4_TLM
  REAL(fvprc) FUNCTION EDGE_INTERPOLATE4(ua, dxa)
    IMPLICIT NONE
!This is the original edge-interpolation code, which makes
! a relatively small increase in the error in unstretched case 2.
!   edge_interpolate4 = 0.25*( 3*(ua(2)+ua(3)) - (ua(1)+ua(4))  )
    REAL(fvprc), INTENT(IN) :: ua(4)
    REAL(fvprc), INTENT(IN) :: dxa(4)
    REAL(fvprc) :: u0l, u0r
    u0l = 0.5*((2.*dxa(2)+dxa(1))*ua(2)-dxa(2)*ua(1))/(dxa(1)+dxa(2))
    u0r = 0.5*((2.*dxa(3)+dxa(4))*ua(3)-dxa(3)*ua(4))/(dxa(3)+dxa(4))
    edge_interpolate4 = u0l + u0r
  END FUNCTION EDGE_INTERPOLATE4
!Subroutines d2a2c and d2a2c_vect_v? have been deleted. Look at older code versions if you are interested.
  SUBROUTINE FILL3_4CORNERS(q1, q2, q3, dir, bd, npx, npy, sw_corner, &
&   se_corner, ne_corner, nw_corner)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! This routine fill the 4 corners of the scalar fileds only as needed by c_core
! 1: x-dir; 2: y-dir
    INTEGER, INTENT(IN) :: dir
    REAL(fvprc), INTENT(INOUT) :: q1(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: q2(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: q3(bd%isd:bd%ied, bd%jsd:bd%jed)
    LOGICAL, INTENT(IN) :: sw_corner, se_corner, ne_corner, nw_corner
    INTEGER, INTENT(IN) :: npx, npy
    INTEGER :: i, j
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    SELECT CASE  (dir) 
    CASE (1) 
      IF (sw_corner) THEN
        q1(-1, 0) = q1(0, 2)
        q1(0, 0) = q1(0, 1)
        q1(0, -1) = q1(-1, 1)
        q2(-1, 0) = q2(0, 2)
        q2(0, 0) = q2(0, 1)
        q2(0, -1) = q2(-1, 1)
        q3(-1, 0) = q3(0, 2)
        q3(0, 0) = q3(0, 1)
        q3(0, -1) = q3(-1, 1)
      END IF
      IF (se_corner) THEN
        q1(npx+1, 0) = q1(npx, 2)
        q1(npx, 0) = q1(npx, 1)
        q1(npx, -1) = q1(npx+1, 1)
        q2(npx+1, 0) = q2(npx, 2)
        q2(npx, 0) = q2(npx, 1)
        q2(npx, -1) = q2(npx+1, 1)
        q3(npx+1, 0) = q3(npx, 2)
        q3(npx, 0) = q3(npx, 1)
        q3(npx, -1) = q3(npx+1, 1)
      END IF
      IF (ne_corner) THEN
        q1(npx, npy) = q1(npx, npy-1)
        q1(npx+1, npy) = q1(npx, npy-2)
        q1(npx, npy+1) = q1(npx+1, npy-1)
        q2(npx, npy) = q2(npx, npy-1)
        q2(npx+1, npy) = q2(npx, npy-2)
        q2(npx, npy+1) = q2(npx+1, npy-1)
        q3(npx, npy) = q3(npx, npy-1)
        q3(npx+1, npy) = q3(npx, npy-2)
        q3(npx, npy+1) = q3(npx+1, npy-1)
      END IF
      IF (nw_corner) THEN
        q1(0, npy) = q1(0, npy-1)
        q1(-1, npy) = q1(0, npy-2)
        q1(0, npy+1) = q1(-1, npy-1)
        q2(0, npy) = q2(0, npy-1)
        q2(-1, npy) = q2(0, npy-2)
        q2(0, npy+1) = q2(-1, npy-1)
        q3(0, npy) = q3(0, npy-1)
        q3(-1, npy) = q3(0, npy-2)
        q3(0, npy+1) = q3(-1, npy-1)
      END IF
    CASE (2) 
      IF (sw_corner) THEN
        q1(0, 0) = q1(1, 0)
        q1(0, -1) = q1(2, 0)
        q1(-1, 0) = q1(1, -1)
        q2(0, 0) = q2(1, 0)
        q2(0, -1) = q2(2, 0)
        q2(-1, 0) = q2(1, -1)
        q3(0, 0) = q3(1, 0)
        q3(0, -1) = q3(2, 0)
        q3(-1, 0) = q3(1, -1)
      END IF
      IF (se_corner) THEN
        q1(npx, 0) = q1(npx-1, 0)
        q1(npx, -1) = q1(npx-2, 0)
        q1(npx+1, 0) = q1(npx-1, -1)
        q2(npx, 0) = q2(npx-1, 0)
        q2(npx, -1) = q2(npx-2, 0)
        q2(npx+1, 0) = q2(npx-1, -1)
        q3(npx, 0) = q3(npx-1, 0)
        q3(npx, -1) = q3(npx-2, 0)
        q3(npx+1, 0) = q3(npx-1, -1)
      END IF
      IF (ne_corner) THEN
        q1(npx, npy) = q1(npx-1, npy)
        q1(npx, npy+1) = q1(npx-2, npy)
        q1(npx+1, npy) = q1(npx-1, npy+1)
        q2(npx, npy) = q2(npx-1, npy)
        q2(npx, npy+1) = q2(npx-2, npy)
        q2(npx+1, npy) = q2(npx-1, npy+1)
        q3(npx, npy) = q3(npx-1, npy)
        q3(npx, npy+1) = q3(npx-2, npy)
        q3(npx+1, npy) = q3(npx-1, npy+1)
      END IF
      IF (nw_corner) THEN
        q1(0, npy) = q1(1, npy)
        q1(0, npy+1) = q1(2, npy)
        q1(-1, npy) = q1(1, npy+1)
        q2(0, npy) = q2(1, npy)
        q2(0, npy+1) = q2(2, npy)
        q2(-1, npy) = q2(1, npy+1)
        q3(0, npy) = q3(1, npy)
        q3(0, npy+1) = q3(2, npy)
        q3(-1, npy) = q3(1, npy+1)
      END IF
    END SELECT
  END SUBROUTINE FILL3_4CORNERS
!  Differentiation of fill2_4corners in forward (tangent) mode (with options r8):
!   variations   of useful results: q1 q2
!   with respect to varying inputs: q1 q2
  SUBROUTINE FILL2_4CORNERS_TLM(q1, q1_tl, q2, q2_tl, dir, bd, npx, npy&
&   , sw_corner, se_corner, ne_corner, nw_corner)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! This routine fill the 4 corners of the scalar fileds only as needed by c_core
! 1: x-dir; 2: y-dir
    INTEGER, INTENT(IN) :: dir
    REAL(fvprc), INTENT(INOUT) :: q1(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: q1_tl(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: q2(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: q2_tl(bd%isd:bd%ied, bd%jsd:bd%jed)
    LOGICAL, INTENT(IN) :: sw_corner, se_corner, ne_corner, nw_corner
    INTEGER, INTENT(IN) :: npx, npy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    SELECT CASE  (dir) 
    CASE (1) 
      IF (sw_corner) THEN
        q1_tl(-1, 0) = q1_tl(0, 2)
        q1(-1, 0) = q1(0, 2)
        q1_tl(0, 0) = q1_tl(0, 1)
        q1(0, 0) = q1(0, 1)
        q2_tl(-1, 0) = q2_tl(0, 2)
        q2(-1, 0) = q2(0, 2)
        q2_tl(0, 0) = q2_tl(0, 1)
        q2(0, 0) = q2(0, 1)
      END IF
      IF (se_corner) THEN
        q1_tl(npx+1, 0) = q1_tl(npx, 2)
        q1(npx+1, 0) = q1(npx, 2)
        q1_tl(npx, 0) = q1_tl(npx, 1)
        q1(npx, 0) = q1(npx, 1)
        q2_tl(npx+1, 0) = q2_tl(npx, 2)
        q2(npx+1, 0) = q2(npx, 2)
        q2_tl(npx, 0) = q2_tl(npx, 1)
        q2(npx, 0) = q2(npx, 1)
      END IF
      IF (nw_corner) THEN
        q1_tl(0, npy) = q1_tl(0, npy-1)
        q1(0, npy) = q1(0, npy-1)
        q1_tl(-1, npy) = q1_tl(0, npy-2)
        q1(-1, npy) = q1(0, npy-2)
        q2_tl(0, npy) = q2_tl(0, npy-1)
        q2(0, npy) = q2(0, npy-1)
        q2_tl(-1, npy) = q2_tl(0, npy-2)
        q2(-1, npy) = q2(0, npy-2)
      END IF
      IF (ne_corner) THEN
        q1_tl(npx, npy) = q1_tl(npx, npy-1)
        q1(npx, npy) = q1(npx, npy-1)
        q1_tl(npx+1, npy) = q1_tl(npx, npy-2)
        q1(npx+1, npy) = q1(npx, npy-2)
        q2_tl(npx, npy) = q2_tl(npx, npy-1)
        q2(npx, npy) = q2(npx, npy-1)
        q2_tl(npx+1, npy) = q2_tl(npx, npy-2)
        q2(npx+1, npy) = q2(npx, npy-2)
      END IF
    CASE (2) 
      IF (sw_corner) THEN
        q1_tl(0, 0) = q1_tl(1, 0)
        q1(0, 0) = q1(1, 0)
        q1_tl(0, -1) = q1_tl(2, 0)
        q1(0, -1) = q1(2, 0)
        q2_tl(0, 0) = q2_tl(1, 0)
        q2(0, 0) = q2(1, 0)
        q2_tl(0, -1) = q2_tl(2, 0)
        q2(0, -1) = q2(2, 0)
      END IF
      IF (se_corner) THEN
        q1_tl(npx, 0) = q1_tl(npx-1, 0)
        q1(npx, 0) = q1(npx-1, 0)
        q1_tl(npx, -1) = q1_tl(npx-2, 0)
        q1(npx, -1) = q1(npx-2, 0)
        q2_tl(npx, 0) = q2_tl(npx-1, 0)
        q2(npx, 0) = q2(npx-1, 0)
        q2_tl(npx, -1) = q2_tl(npx-2, 0)
        q2(npx, -1) = q2(npx-2, 0)
      END IF
      IF (nw_corner) THEN
        q1_tl(0, npy) = q1_tl(1, npy)
        q1(0, npy) = q1(1, npy)
        q1_tl(0, npy+1) = q1_tl(2, npy)
        q1(0, npy+1) = q1(2, npy)
        q2_tl(0, npy) = q2_tl(1, npy)
        q2(0, npy) = q2(1, npy)
        q2_tl(0, npy+1) = q2_tl(2, npy)
        q2(0, npy+1) = q2(2, npy)
      END IF
      IF (ne_corner) THEN
        q1_tl(npx, npy) = q1_tl(npx-1, npy)
        q1(npx, npy) = q1(npx-1, npy)
        q1_tl(npx, npy+1) = q1_tl(npx-2, npy)
        q1(npx, npy+1) = q1(npx-2, npy)
        q2_tl(npx, npy) = q2_tl(npx-1, npy)
        q2(npx, npy) = q2(npx-1, npy)
        q2_tl(npx, npy+1) = q2_tl(npx-2, npy)
        q2(npx, npy+1) = q2(npx-2, npy)
      END IF
    END SELECT
  END SUBROUTINE FILL2_4CORNERS_TLM
  SUBROUTINE FILL2_4CORNERS(q1, q2, dir, bd, npx, npy, sw_corner, &
&   se_corner, ne_corner, nw_corner)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! This routine fill the 4 corners of the scalar fileds only as needed by c_core
! 1: x-dir; 2: y-dir
    INTEGER, INTENT(IN) :: dir
    REAL(fvprc), INTENT(INOUT) :: q1(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: q2(bd%isd:bd%ied, bd%jsd:bd%jed)
    LOGICAL, INTENT(IN) :: sw_corner, se_corner, ne_corner, nw_corner
    INTEGER, INTENT(IN) :: npx, npy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    SELECT CASE  (dir) 
    CASE (1) 
      IF (sw_corner) THEN
        q1(-1, 0) = q1(0, 2)
        q1(0, 0) = q1(0, 1)
        q2(-1, 0) = q2(0, 2)
        q2(0, 0) = q2(0, 1)
      END IF
      IF (se_corner) THEN
        q1(npx+1, 0) = q1(npx, 2)
        q1(npx, 0) = q1(npx, 1)
        q2(npx+1, 0) = q2(npx, 2)
        q2(npx, 0) = q2(npx, 1)
      END IF
      IF (nw_corner) THEN
        q1(0, npy) = q1(0, npy-1)
        q1(-1, npy) = q1(0, npy-2)
        q2(0, npy) = q2(0, npy-1)
        q2(-1, npy) = q2(0, npy-2)
      END IF
      IF (ne_corner) THEN
        q1(npx, npy) = q1(npx, npy-1)
        q1(npx+1, npy) = q1(npx, npy-2)
        q2(npx, npy) = q2(npx, npy-1)
        q2(npx+1, npy) = q2(npx, npy-2)
      END IF
    CASE (2) 
      IF (sw_corner) THEN
        q1(0, 0) = q1(1, 0)
        q1(0, -1) = q1(2, 0)
        q2(0, 0) = q2(1, 0)
        q2(0, -1) = q2(2, 0)
      END IF
      IF (se_corner) THEN
        q1(npx, 0) = q1(npx-1, 0)
        q1(npx, -1) = q1(npx-2, 0)
        q2(npx, 0) = q2(npx-1, 0)
        q2(npx, -1) = q2(npx-2, 0)
      END IF
      IF (nw_corner) THEN
        q1(0, npy) = q1(1, npy)
        q1(0, npy+1) = q1(2, npy)
        q2(0, npy) = q2(1, npy)
        q2(0, npy+1) = q2(2, npy)
      END IF
      IF (ne_corner) THEN
        q1(npx, npy) = q1(npx-1, npy)
        q1(npx, npy+1) = q1(npx-2, npy)
        q2(npx, npy) = q2(npx-1, npy)
        q2(npx, npy+1) = q2(npx-2, npy)
      END IF
    END SELECT
  END SUBROUTINE FILL2_4CORNERS
!  Differentiation of fill_4corners in forward (tangent) mode (with options r8):
!   variations   of useful results: q
!   with respect to varying inputs: q
  SUBROUTINE FILL_4CORNERS_TLM(q, q_tl, dir, bd, npx, npy, sw_corner, &
&   se_corner, ne_corner, nw_corner)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! This routine fill the 4 corners of the scalar fileds only as needed by c_core
! 1: x-dir; 2: y-dir
    INTEGER, INTENT(IN) :: dir
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: q_tl(bd%isd:bd%ied, bd%jsd:bd%jed)
    LOGICAL, INTENT(IN) :: sw_corner, se_corner, ne_corner, nw_corner
    INTEGER, INTENT(IN) :: npx, npy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    SELECT CASE  (dir) 
    CASE (1) 
      IF (sw_corner) THEN
        q_tl(-1, 0) = q_tl(0, 2)
        q(-1, 0) = q(0, 2)
        q_tl(0, 0) = q_tl(0, 1)
        q(0, 0) = q(0, 1)
      END IF
      IF (se_corner) THEN
        q_tl(npx+1, 0) = q_tl(npx, 2)
        q(npx+1, 0) = q(npx, 2)
        q_tl(npx, 0) = q_tl(npx, 1)
        q(npx, 0) = q(npx, 1)
      END IF
      IF (nw_corner) THEN
        q_tl(0, npy) = q_tl(0, npy-1)
        q(0, npy) = q(0, npy-1)
        q_tl(-1, npy) = q_tl(0, npy-2)
        q(-1, npy) = q(0, npy-2)
      END IF
      IF (ne_corner) THEN
        q_tl(npx, npy) = q_tl(npx, npy-1)
        q(npx, npy) = q(npx, npy-1)
        q_tl(npx+1, npy) = q_tl(npx, npy-2)
        q(npx+1, npy) = q(npx, npy-2)
      END IF
    CASE (2) 
      IF (sw_corner) THEN
        q_tl(0, 0) = q_tl(1, 0)
        q(0, 0) = q(1, 0)
        q_tl(0, -1) = q_tl(2, 0)
        q(0, -1) = q(2, 0)
      END IF
      IF (se_corner) THEN
        q_tl(npx, 0) = q_tl(npx-1, 0)
        q(npx, 0) = q(npx-1, 0)
        q_tl(npx, -1) = q_tl(npx-2, 0)
        q(npx, -1) = q(npx-2, 0)
      END IF
      IF (nw_corner) THEN
        q_tl(0, npy) = q_tl(1, npy)
        q(0, npy) = q(1, npy)
        q_tl(0, npy+1) = q_tl(2, npy)
        q(0, npy+1) = q(2, npy)
      END IF
      IF (ne_corner) THEN
        q_tl(npx, npy) = q_tl(npx-1, npy)
        q(npx, npy) = q(npx-1, npy)
        q_tl(npx, npy+1) = q_tl(npx-2, npy)
        q(npx, npy+1) = q(npx-2, npy)
      END IF
    END SELECT
  END SUBROUTINE FILL_4CORNERS_TLM
  SUBROUTINE FILL_4CORNERS(q, dir, bd, npx, npy, sw_corner, se_corner, &
&   ne_corner, nw_corner)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! This routine fill the 4 corners of the scalar fileds only as needed by c_core
! 1: x-dir; 2: y-dir
    INTEGER, INTENT(IN) :: dir
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed)
    LOGICAL, INTENT(IN) :: sw_corner, se_corner, ne_corner, nw_corner
    INTEGER, INTENT(IN) :: npx, npy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    SELECT CASE  (dir) 
    CASE (1) 
      IF (sw_corner) THEN
        q(-1, 0) = q(0, 2)
        q(0, 0) = q(0, 1)
      END IF
      IF (se_corner) THEN
        q(npx+1, 0) = q(npx, 2)
        q(npx, 0) = q(npx, 1)
      END IF
      IF (nw_corner) THEN
        q(0, npy) = q(0, npy-1)
        q(-1, npy) = q(0, npy-2)
      END IF
      IF (ne_corner) THEN
        q(npx, npy) = q(npx, npy-1)
        q(npx+1, npy) = q(npx, npy-2)
      END IF
    CASE (2) 
      IF (sw_corner) THEN
        q(0, 0) = q(1, 0)
        q(0, -1) = q(2, 0)
      END IF
      IF (se_corner) THEN
        q(npx, 0) = q(npx-1, 0)
        q(npx, -1) = q(npx-2, 0)
      END IF
      IF (nw_corner) THEN
        q(0, npy) = q(1, npy)
        q(0, npy+1) = q(2, npy)
      END IF
      IF (ne_corner) THEN
        q(npx, npy) = q(npx-1, npy)
        q(npx, npy+1) = q(npx-2, npy)
      END IF
    END SELECT
  END SUBROUTINE FILL_4CORNERS
END MODULE SW_CORE_MOD_D
