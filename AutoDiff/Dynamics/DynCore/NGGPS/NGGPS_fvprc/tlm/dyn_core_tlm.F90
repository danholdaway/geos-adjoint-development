!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
MODULE DYN_CORE_MOD_D
  USE FV_ARRAYS_MOD_D, ONLY : real4, real8, fvprc, fv_timing_onoff
  USE CONSTANTS_MOD, ONLY : rdgas, radius
  USE MPP_MOD_D, ONLY : mpp_pe
  USE MPP_DOMAINS_MOD_D, ONLY : cgrid_ne, dgrid_ne, mpp_get_boundary, &
& mpp_get_boundary_tlm, mpp_update_domains, mpp_update_domains_tlm, &
& domain2d
  USE MPP_PARAMETER_MOD, ONLY : corner
  USE FV_MP_MOD_D, ONLY : is_master
  USE FV_MP_MOD_D, ONLY : start_group_halo_update, &
& start_group_halo_update_tlm, complete_group_halo_update
  USE FV_MP_MOD_D, ONLY : group_halo_update_type
  USE SW_CORE_MOD_D, ONLY : c_sw, c_sw_tlm, d_sw, d_sw_tlm
  USE A2B_EDGE_MOD_D, ONLY : a2b_ord2, a2b_ord2_tlm, a2b_ord4, &
& a2b_ord4_tlm
  USE NH_CORE_MOD_D, ONLY : riem_solver3, riem_solver3_tlm, &
& riem_solver_c, riem_solver_c_tlm, update_dz_c, update_dz_c_tlm, &
& update_dz_d, update_dz_d_tlm, geopk_halo_nh
  USE TP_CORE_MOD_D, ONLY : copy_corners, copy_corners_tlm
  USE FV_TIMING_MOD, ONLY : timing_on, timing_off
!  use fv_diagnostics_mod, only: prt_maxmin, fv_time, prt_mxm
!#ifdef ROT3
!  use fv_update_phys_mod, only: update_dwinds_phys
!#endif
!#if defined (ADA_NUDGE)
!  use fv_ada_nudge_mod,   only: breed_slp_inline_ada
!#else
!  use fv_nwp_nudge_mod,   only: breed_slp_inline
!#endif
!  use diag_manager_mod,   only: send_data
  USE FV_ARRAYS_MOD_D, ONLY : fv_grid_type, fv_flags_type, fv_nest_type,&
& fv_diag_type, fv_grid_bounds_type
  USE FV_ARRAYS_MOD_D, ONLY : r_grid
  IMPLICIT NONE
  PRIVATE 
  PUBLIC dyn_core, del2_cubed
  PUBLIC dyn_core_tlm, del2_cubed_tlm
  INTEGER :: is, ie, js, je
  INTEGER :: isd, ied, jsd, jed
  REAL(fvprc) :: ptk, peln1, rgrav
  REAL(fvprc) :: d3_damp
!  real(FVPRC), allocatable, dimension(:,:,:) ::  ut, vt, crx, cry, xfx, yfx, divgd, &
!                                          zh, du, dv, pkc, delpc, pk3, ptc, gz
  REAL(kind=r_grid), PARAMETER :: cnst_0p20=0.20d0

CONTAINS
!  Differentiation of dyn_core in forward (tangent) mode (with options r8):
!   variations   of useful results: pk3 xfx ws peln q gz du u dv
!                v w delp ua uc ptc mfx delz mfy omga ut divgd
!                pkc delpc va vc yfx pkz pe vt pk zh pt cx cy crx
!                cry
!   with respect to varying inputs: pk3 xfx ws peln q gz du u dv
!                v w delp ua uc ptc mfx delz mfy omga ut divgd
!                pkc delpc va vc yfx pkz pe vt pk zh pt cx cy crx
!                cry
!---- version number -----
!  character(len=128) :: version = '$Id: dyn_core.F90,v 1.2.2.1.2.1.30.1.4.1.22.5.48.6.2.2.2.1.4.1 2017/02/16 03:47:47 aoloso Exp
! $'
!  character(len=128) :: tagname = '$Name: Heracles-UNSTABLE_ncepdyn_Feb222017 $'
!-----------------------------------------------------------------------
!     dyn_core :: FV Lagrangian dynamics driver
!-----------------------------------------------------------------------
  SUBROUTINE DYN_CORE_TLM(npx, npy, npz, ng, sphum, nq, bdt, n_split, &
&   zvir, cp, akap, cappa, grav, hydrostatic, u, u_tl, v, v_tl, w, w_tl&
&   , delz, delz_tl, pt, pt_tl, q, q_tl, delp, delp_tl, pe, pe_tl, pk, &
&   pk_tl, phis, ws, ws_tl, omga, omga_tl, ptop, pfull, ua, ua_tl, va, &
&   va_tl, uc, uc_tl, vc, vc_tl, mfx, mfx_tl, mfy, mfy_tl, cx, cx_tl, cy&
&   , cy_tl, pkz, pkz_tl, peln, peln_tl, q_con, ak, bk, ks, gridstruct, &
&   flagstruct, neststruct, idiag, bd, domain, init_step, i_pack, &
&   end_step, gz, gz_tl, pkc, pkc_tl, ptc, ptc_tl, crx, crx_tl, xfx, &
&   xfx_tl, cry, cry_tl, yfx, yfx_tl, divgd, divgd_tl, delpc, delpc_tl, &
&   ut, ut_tl, vt, vt_tl, zh, zh_tl, pk3, pk3_tl, du, du_tl, dv, dv_tl, &
&   time_total)
    IMPLICIT NONE
!if (fv_timing_onoff) call timing_off('  UPDATE_DZ')
!    if ( flagstruct%fv_debug ) then
!         if ( .not. flagstruct%hydrostatic )    &
!         call prt_mxm('delz updated',  delz, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!    endif
!deallocate( heat_source )    
!if (allocated(heat_source)) deallocate( heat_source ) !If ncon == 0 but d_con > 1.e-5, this would not be deallocated in earlier 
!versions of the code
!deallocate(    gz )
!deallocate(   ptc )
!deallocate(   crx )
!deallocate(   xfx )
!deallocate(   cry )
!deallocate(   yfx )
!deallocate( divgd )
!deallocate(   pkc )
!deallocate( delpc )
!if( allocated(ut))   deallocate( ut )
!if( allocated(vt))   deallocate( vt )
!if ( allocated (du) ) deallocate( du )
!if ( allocated (dv) ) deallocate( dv )
!if ( .not. hydrostatic ) then
!     deallocate( zh )
!     deallocate( pk3 )
!endif
!if( allocated(pem) )   deallocate ( pem )
!if ( flagstruct%fv_debug ) then
!   if(is_master()) write(*,*) 'End of dyn_core'
!endif
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
    INTEGER, INTENT(IN) :: ng, nq, sphum
    INTEGER, INTENT(IN) :: n_split
    REAL(fvprc), INTENT(IN) :: bdt
    REAL(fvprc), INTENT(IN) :: zvir, cp, akap, grav
    REAL(fvprc), INTENT(IN) :: ptop
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: init_step, end_step
    REAL(fvprc), INTENT(IN) :: pfull(npz)
    REAL(fvprc), DIMENSION(npz+1), INTENT(IN) :: ak, bk
    INTEGER, INTENT(IN) :: ks
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: i_pack(*)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! D grid zonal wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz), INTENT(&
&   INOUT) :: u
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz), INTENT(&
&   INOUT) :: u_tl
! D grid meridional wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: v
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: v_tl
! vertical vel. (m/s)
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: w_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! delta-height (m)
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: delz_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
! moist kappa
    REAL(fvprc), INTENT(INOUT) :: cappa(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
! temperature (K)
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: pt_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
! pressure thickness (pascal)
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: delp_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
! 
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, &
&   nq)
    REAL(fvprc), INTENT(INOUT) :: q_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   , nq)
! total time (seconds) since start
    REAL(fvprc), INTENT(IN), OPTIONAL :: time_total
!-----------------------------------------------------------------------
! Auxilliary pressure arrays:    
! The 5 vars below can be re-computed from delp and ptop.
!-----------------------------------------------------------------------
! dyn_aux:
! Surface geopotential (g*Z_surf)
    REAL(fvprc), INTENT(INOUT) :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
! edge pressure (pascal)
    REAL(fvprc), INTENT(INOUT) :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%&
&   je+1)
    REAL(fvprc), INTENT(INOUT) :: pe_tl(bd%is-1:bd%ie+1, npz+1, bd%js-1:&
&   bd%je+1)
! ln(pe)
    REAL(fvprc), INTENT(INOUT) :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL(fvprc), INTENT(INOUT) :: peln_tl(bd%is:bd%ie, npz+1, bd%js:bd%&
&   je)
! pe**kappa
    REAL(fvprc), INTENT(INOUT) :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL(fvprc), INTENT(INOUT) :: pk_tl(bd%is:bd%ie, bd%js:bd%je, npz+1)
!-----------------------------------------------------------------------
! Others:
    REAL(fvprc), PARAMETER :: near0=1.e-8
    REAL(fvprc), PARAMETER :: huge_r=1.e20
! [m**2/sec] for T ~ 260 K
    REAL(fvprc), PARAMETER :: air_viscosity=1.e-5
!-----------------------------------------------------------------------
! w at surface
    REAL(fvprc), INTENT(OUT) :: ws(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc), INTENT(OUT) :: ws_tl(bd%is:bd%ie, bd%js:bd%je)
! Vertical pressure velocity (pa/s)
    REAL(fvprc), INTENT(INOUT) :: omga(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: omga_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
! (uc, vc) are mostly used as the C grid winds
    REAL(fvprc), INTENT(INOUT) :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: uc_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: vc_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: ua_tl, va_tl
    REAL(fvprc), INTENT(INOUT) :: q_con(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
! The Flux capacitors: accumulated Mass flux arrays
    REAL(fvprc), INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL(fvprc), INTENT(INOUT) :: mfx_tl(bd%is:bd%ie+1, bd%js:bd%je, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
    REAL(fvprc), INTENT(INOUT) :: mfy_tl(bd%is:bd%ie, bd%js:bd%je+1, npz&
&   )
! Accumulated Courant number arrays
    REAL(fvprc), INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: cx_tl(bd%is:bd%ie+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc), INTENT(INOUT) :: cy_tl(bd%isd:bd%ied, bd%js:bd%je+1, &
&   npz)
    REAL(fvprc), DIMENSION(bd%is:bd%ie, bd%js:bd%je, npz), INTENT(INOUT)&
&   :: pkz
    REAL(fvprc), DIMENSION(bd%is:bd%ie, bd%js:bd%je, npz), INTENT(INOUT)&
&   :: pkz_tl
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
    TYPE(FV_NEST_TYPE), INTENT(INOUT) :: neststruct
    TYPE(FV_DIAG_TYPE), INTENT(IN) :: idiag
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    REAL(fvprc) :: pem(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1), &
&   heat_source(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: pem_tl(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1), &
&   heat_source_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! Auto 1D & 2D arrays:
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ws3, z_rat
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ws3_tl, &
&   z_rat_tl
    REAL(fvprc) :: dp_ref(npz)
! surface height (m)
    REAL(fvprc) :: zs(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: p1d(bd%is:bd%ie)
    REAL(fvprc) :: om2d(bd%is:bd%ie, npz)
    REAL(fvprc) :: om2d_tl(bd%is:bd%ie, npz)
    REAL(fvprc) :: wbuffer(npy+2, npz)
    REAL(fvprc) :: ebuffer(npy+2, npz)
    REAL(fvprc) :: ebuffer_tl(npy+2, npz)
    REAL(fvprc) :: nbuffer(npx+2, npz)
    REAL(fvprc) :: nbuffer_tl(npx+2, npz)
    REAL(fvprc) :: sbuffer(npx+2, npz)
! ----   For external mode:
    REAL(fvprc) :: divg2(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: divg2_tl(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: wk(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk_tl(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: fz(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: heat_s(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: heat_s_tl(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: damp_vt(npz+1)
    REAL(fvprc) :: damp_vt_pert(npz+1)
    INTEGER :: nord_v(npz+1)
    INTEGER :: nord_v_pert(npz+1)
!-------------------------------------
    INTEGER :: hord_m, hord_v, hord_t, hord_p
    INTEGER :: hord_m_pert, hord_v_pert, hord_t_pert, hord_p_pert
    INTEGER :: nord_k, nord_w, nord_t
    INTEGER :: nord_k_pert, nord_w_pert, nord_t_pert
    INTEGER :: ms
!---------------------------------------
    INTEGER :: i, j, k, it, iq, n_con
    INTEGER :: iep1, jep1
    REAL(fvprc) :: beta, beta_d, damp_k, damp_w, damp_t, d_con_k
    REAL(fvprc) :: damp_k_pert, damp_w_pert, damp_t_pert, d_con_k_pert
    REAL(fvprc) :: dt, dt2, rdt
    REAL(fvprc) :: d2_divg, d3_divg
    REAL(fvprc) :: d2_divg_pert
    REAL(fvprc) :: k1k, kapag, tmcp, cpm
    REAL(fvprc) :: tmcp_tl
    LOGICAL :: last_step, remap_step
    LOGICAL :: used
    REAL(fvprc) :: split_timestep_bc, split
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: gz_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: pkc(bd%isd:bd%ied, bd%jsd:bd%jed, npz+&
&   1)
    REAL(fvprc), INTENT(INOUT) :: pkc_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: ptc(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: ptc_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: crx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: crx_tl(bd%is:bd%ie+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: xfx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: xfx_tl(bd%is:bd%ie+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: cry(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc), INTENT(INOUT) :: cry_tl(bd%isd:bd%ied, bd%js:bd%je+1, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: yfx(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc), INTENT(INOUT) :: yfx_tl(bd%isd:bd%ied, bd%js:bd%je+1, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: divgd(bd%isd:bd%ied+1, bd%jsd:bd%jed+1&
&   , npz)
    REAL(fvprc), INTENT(INOUT) :: divgd_tl(bd%isd:bd%ied+1, bd%jsd:bd%&
&   jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: delpc(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: delpc_tl(bd%isd:bd%ied, bd%jsd:bd%jed&
&   , npz)
    REAL(fvprc), INTENT(INOUT) :: ut(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: ut_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: vt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: vt_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: zh(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: zh_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: pk3(bd%isd:bd%ied, bd%jsd:bd%jed, npz+&
&   1)
    REAL(fvprc), INTENT(INOUT) :: pk3_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: du(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: du_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: dv(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: dv_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc) :: vt_tj(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    INTRINSIC LOG
    INTRINSIC REAL
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC TANH
    INTRINSIC EXP
    REAL(fvprc) :: arg1
    REAL(fvprc) :: arg1_tl
    REAL(fvprc) :: arg2
    REAL(fvprc) :: arg2_tl
    REAL(fvprc) :: y2
    REAL(fvprc) :: y1
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    damp_vt = 0
    damp_vt_pert = 0
    peln1 = LOG(ptop)
    ptk = ptop**akap
    dt = bdt/REAL(n_split)
    dt2 = 0.5*dt
    rdt = 1.0/dt
    IF (1 .LT. flagstruct%m_split/2) THEN
      ms = flagstruct%m_split/2
    ELSE
      ms = 1
    END IF
    beta = flagstruct%beta
    split = REAL(n_split*flagstruct%k_split)
! Indexes:
    iep1 = ie + 1
    jep1 = je + 1
    IF (.NOT.hydrostatic) THEN
      rgrav = 1.0/grav
! rg/Cv=0.4
      k1k = akap/(1.-akap)
      kapag = -(akap/grav)
!$OMP parallel do default(none) shared(npz,dp_ref,ak,bk)
      DO k=1,npz
        dp_ref(k) = ak(k+1) - ak(k) + (bk(k+1)-bk(k))*1.e5
      END DO
!$OMP parallel do default(none) shared(isd,ied,jsd,jed,zs,phis,rgrav)
      DO j=jsd,jed
        DO i=isd,ied
          zs(i, j) = phis(i, j)*rgrav
        END DO
      END DO
    END IF
! end init_step
    IF (init_step) THEN
! Start of the big dynamic time stepping
!allocate(    gz(isd:ied, jsd:jed ,npz+1) )
      CALL INIT_IJK_MEM_TLM(isd, ied, jsd, jed, npz + 1, gz, gz_tl, &
&                     huge_r)
!allocate(   pkc(isd:ied, jsd:jed ,npz+1) )
!allocate(   ptc(isd:ied, jsd:jed ,npz ) )
!allocate( crx(is :ie+1, jsd:jed,  npz) )
!allocate( xfx(is :ie+1, jsd:jed,  npz) )
!allocate( cry(isd:ied,  js :je+1, npz) )
!allocate( yfx(isd:ied,  js :je+1, npz) )
!allocate( divgd(isd:ied+1,jsd:jed+1,npz) )
!allocate( delpc(isd:ied, jsd:jed  ,npz  ) )
!                    call init_ijk_mem(isd,ied, jsd,jed, npz, delpc, 0._FVPRC)
!allocate( ut(isd:ied, jsd:jed, npz) )
!                    call init_ijk_mem(isd,ied, jsd,jed, npz, ut, 0._FVPRC)
!allocate( vt(isd:ied, jsd:jed, npz) )
!                    call init_ijk_mem(isd,ied, jsd,jed, npz, vt, 0._FVPRC)
      IF (.NOT.hydrostatic) CALL INIT_IJK_MEM_TLM(isd, ied, jsd, jed, &
&                                           npz + 1, pk3, pk3_tl, huge_r&
&                                          )
!allocate( zh(isd:ied, jsd:jed, npz+1) )
!              call init_ijk_mem(isd,ied, jsd,jed, npz+1, zh, huge_r )
!allocate ( pk3(isd:ied,jsd:jed,npz+1) )
      IF (beta .GT. near0) THEN
!allocate( du(isd:ied,  jsd:jed+1,npz) )
        CALL INIT_IJK_MEM_TLM(isd, ied, jsd, jed + 1, npz, du, du_tl, &
&                       0._FVPRC)
!allocate( dv(isd:ied+1,jsd:jed,  npz) )
        CALL INIT_IJK_MEM_TLM(isd, ied + 1, jsd, jed, npz, dv, dv_tl, &
&                       0._FVPRC)
      END IF
    END IF
! Empty the "flux capacitors"
    CALL INIT_IJK_MEM_TLM(is, ie + 1, js, je, npz, mfx, mfx_tl, 0._FVPRC&
&                  )
    CALL INIT_IJK_MEM_TLM(is, ie, js, je + 1, npz, mfy, mfy_tl, 0._FVPRC&
&                  )
    CALL INIT_IJK_MEM_TLM(is, ie + 1, jsd, jed, npz, cx, cx_tl, 0._FVPRC&
&                  )
    CALL INIT_IJK_MEM_TLM(isd, ied, js, je + 1, npz, cy, cy_tl, 0._FVPRC&
&                  )
    IF (flagstruct%d_con .GT. 1.0e-5) THEN
!allocate( heat_source(isd:ied, jsd:jed, npz) )
      heat_source = 0.0
      CALL INIT_IJK_MEM(isd, ied, jsd, jed, npz, heat_source, 0._FVPRC)
    END IF
    IF (flagstruct%convert_ke .OR. flagstruct%vtdm4 .GT. 1.e-3) THEN
      n_con = npz
    ELSE IF (flagstruct%d2_bg_k1 .LT. 1.e-3) THEN
      n_con = 0
    ELSE IF (flagstruct%d2_bg_k2 .LT. 1.e-3) THEN
      n_con = 1
    ELSE
      n_con = 2
    END IF
    IF (gridstruct%nested) THEN
      split_timestep_bc = REAL(n_split*flagstruct%k_split + neststruct%&
&       nest_timestep)
      om2d_tl = 0.0_FVPRC
      pem_tl = 0.0_FVPRC
      ws3_tl = 0.0_FVPRC
      z_rat_tl = 0.0_FVPRC
      heat_source_tl = 0.0_FVPRC
      heat_s_tl = 0.0_FVPRC
      wk_tl = 0.0_FVPRC
      divg2_tl = 0.0_FVPRC
    ELSE
      om2d_tl = 0.0_FVPRC
      pem_tl = 0.0_FVPRC
      ws3_tl = 0.0_FVPRC
      z_rat_tl = 0.0_FVPRC
      heat_source_tl = 0.0_FVPRC
      heat_s_tl = 0.0_FVPRC
      wk_tl = 0.0_FVPRC
      divg2_tl = 0.0_FVPRC
    END IF
!-----------------------------------------------------
    DO it=1,n_split
!-----------------------------------------------------
!#ifdef ROT3
!     call start_group_halo_update(i_pack(8), i_pack(8+12), u, v, domain, gridtype=DGRID_NE)
!#endif
      IF (flagstruct%breed_vortex_inline .OR. it .EQ. n_split) THEN
        remap_step = .true.
      ELSE
        remap_step = .false.
      END IF
!     if ( flagstruct%fv_debug ) then
!          if(is_master()) write(*,*) 'n_split loop, it=', it
!          if ( .not. flagstruct%hydrostatic )    &
!          call prt_mxm('delz',  delz, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!     endif
      IF (nq .GT. 0) THEN
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
!if (fv_timing_onoff) call timing_on('COMM_TRACER')
        IF (flagstruct%inline_q) THEN
          CALL START_GROUP_HALO_UPDATE_TLM(i_pack(10), i_pack(10+12), q&
&                                    , q_tl, domain)
        ELSE IF (it .EQ. n_split) THEN
          CALL START_GROUP_HALO_UPDATE_TLM(i_pack(10), i_pack(10+12), q&
&                                    , q_tl, domain)
        END IF
      END IF
!if (fv_timing_onoff) call timing_off('COMM_TRACER')
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
      IF (.NOT.hydrostatic) THEN
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
        CALL START_GROUP_HALO_UPDATE_TLM(i_pack(7), i_pack(7+12), w, &
&                                  w_tl, domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
        IF (it .EQ. 1) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,gz,zs,delz)
          DO j=js,je
            DO i=is,ie
              gz_tl(i, j, npz+1) = 0.0_FVPRC
              gz(i, j, npz+1) = zs(i, j)
            END DO
            DO k=npz,1,-1
              DO i=is,ie
                gz_tl(i, j, k) = gz_tl(i, j, k+1) - delz_tl(i, j, k)
                gz(i, j, k) = gz(i, j, k+1) - delz(i, j, k)
              END DO
            END DO
          END DO
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
          CALL START_GROUP_HALO_UPDATE_TLM(i_pack(5), i_pack(5+12), gz, &
&                                    gz_tl, domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
        END IF
      END IF
!#ifdef SW_DYNAMICS
!     if (test_case>1) then
!     if (test_case==9) call case9_forcing1(phis, time_total)
!#endif
      IF (it .EQ. 1) THEN
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
        CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(1), i_pack(1+12), domain)
        CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(2), i_pack(2+12), domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
        beta_d = 0.
      ELSE
        beta_d = beta
      END IF
      IF (it .EQ. n_split .AND. end_step) THEN
        IF (flagstruct%use_old_omega) THEN
!allocate ( pem(is-1:ie+1,npz+1,js-1:je+1) )
          pem = 0.0
          pem_tl = 0.0_FVPRC
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pem,delp,ptop)
          DO j=js-1,je+1
            DO i=is-1,ie+1
              pem_tl(i, 1, j) = 0.0_FVPRC
              pem(i, 1, j) = ptop
            END DO
            DO k=1,npz
              DO i=is-1,ie+1
                pem_tl(i, k+1, j) = pem_tl(i, k, j) + delp_tl(i, j, k)
                pem(i, k+1, j) = pem(i, k, j) + delp(i, j, k)
              END DO
            END DO
          END DO
        END IF
        last_step = .true.
      ELSE
        last_step = .false.
      END IF
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
      CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(8), i_pack(8+12), domain)
      IF (.NOT.hydrostatic) CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(7), &
&                                                     i_pack(7+12), &
&                                                     domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!if (fv_timing_onoff) call timing_on('  c_sw')
!$OMP parallel do default(none) shared(npz,isd,jsd,delpc,delp,ptc,pt,u,v,w,uc,vc,ua,va, &
!$OMP                                  omga,ut,vt,divgd,flagstruct,dt2,hydrostatic,bd,  &
!$OMP                                  gridstruct)
      DO k=1,npz
        CALL C_SW_TLM(delpc(isd:ied, jsd:jed, k), delpc_tl(isd:ied, jsd:&
&               jed, k), delp(isd:ied, jsd:jed, k), delp_tl(isd:ied, jsd&
&               :jed, k), ptc(isd:ied, jsd:jed, k), ptc_tl(isd:ied, jsd:&
&               jed, k), pt(isd:ied, jsd:jed, k), pt_tl(isd:ied, jsd:jed&
&               , k), u(isd:ied, jsd:jed+1, k), u_tl(isd:ied, jsd:jed+1&
&               , k), v(isd:ied+1, jsd:jed, k), v_tl(isd:ied+1, jsd:jed&
&               , k), w(isd:ied, jsd:jed, k), w_tl(isd:ied, jsd:jed, k)&
&               , uc(isd:ied+1, jsd:jed, k), uc_tl(isd:ied+1, jsd:jed, k&
&               ), vc(isd:ied, jsd:jed+1, k), vc_tl(isd:ied, jsd:jed+1, &
&               k), ua(isd:ied, jsd:jed, k), ua_tl(isd:ied, jsd:jed, k)&
&               , va(isd:ied, jsd:jed, k), va_tl(isd:ied, jsd:jed, k), &
&               omga(isd:ied, jsd:jed, k), omga_tl(isd:ied, jsd:jed, k)&
&               , ut(isd:ied, jsd:jed, k), ut_tl(isd:ied, jsd:jed, k), &
&               vt(isd:ied, jsd:jed, k), vt_tl(isd:ied, jsd:jed, k), &
&               divgd(isd:ied+1, jsd:jed+1, k), divgd_tl(isd:ied+1, jsd:&
&               jed+1, k), flagstruct%nord, dt2, hydrostatic, .true., bd&
&               , gridstruct, flagstruct)
      END DO
!if (fv_timing_onoff) call timing_off('  c_sw')
      IF (flagstruct%nord .GT. 0) CALL START_GROUP_HALO_UPDATE_TLM(&
&                                                            i_pack(3), &
&                                                            i_pack(3+12&
&                                                            ), divgd, &
&                                                            divgd_tl, &
&                                                            domain, &
&                                                            position=&
&                                                            corner)
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
! end hydro check
      IF (hydrostatic) THEN
        CALL GEOPK_TLM(ptop, pe, pe_tl, peln, peln_tl, delpc, delpc_tl, &
&                pkc, pkc_tl, gz, gz_tl, phis, ptc, ptc_tl, q_con, pkz, &
&                pkz_tl, npz, akap, .true., gridstruct%nested, .false., &
&                npx, npy, flagstruct%a2b_ord, bd)
      ELSE
        IF (it .EQ. 1) THEN
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
          CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(5), i_pack(5+12), &
&                                   domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!$OMP parallel do default(none) shared(isd,ied,jsd,jed,npz,zh,gz)
          DO k=1,npz+1
            DO j=jsd,jed
              DO i=isd,ied
! Save edge heights for update_dz_d
                zh_tl(i, j, k) = gz_tl(i, j, k)
                zh(i, j, k) = gz(i, j, k)
              END DO
            END DO
          END DO
        ELSE
!$OMP parallel do default(none) shared(isd,ied,jsd,jed,npz,zh,gz)
          DO k=1,npz+1
            DO j=jsd,jed
              DO i=isd,ied
                gz_tl(i, j, k) = zh_tl(i, j, k)
                gz(i, j, k) = zh(i, j, k)
              END DO
            END DO
          END DO
        END IF
!if (fv_timing_onoff) call timing_on('  UPDATE_DZ_C')
        CALL UPDATE_DZ_C_TLM(is, ie, js, je, npz, ng, dt2, dp_ref, zs, &
&                      gridstruct%area, ut, ut_tl, vt, vt_tl, gz, gz_tl&
&                      , ws3, ws3_tl, npx, npy, gridstruct%sw_corner, &
&                      gridstruct%se_corner, gridstruct%ne_corner, &
&                      gridstruct%nw_corner, bd, gridstruct%grid_type)
!if (fv_timing_onoff) call timing_off('  UPDATE_DZ_C')
!if (fv_timing_onoff) call timing_on('  Riem_Solver')
        CALL RIEM_SOLVER_C_TLM(ms, dt2, is, ie, js, je, npz, ng, akap, &
&                        cappa, cp, ptop, phis, omga, omga_tl, ptc, &
&                        ptc_tl, q_con, delpc, delpc_tl, gz, gz_tl, pkc&
&                        , pkc_tl, ws3, ws3_tl, flagstruct%p_fac, &
&                        flagstruct%a_imp, flagstruct%scale_z)
!if (fv_timing_onoff) call timing_off('  Riem_Solver')
!#ifndef SW_DYNAMICS
!           if (gridstruct%nested) then
!                 call nested_grid_BC_apply_intT(delpc, &
!                      0, 0, npx, npy, npz, bd, split_timestep_BC+0.5, split, &
!                      var_east_t0=neststruct%delp_BC%east_t0, &
!                      var_west_t0=neststruct%delp_BC%west_t0, &
!                      var_north_t0=neststruct%delp_BC%north_t0, &
!                      var_south_t0=neststruct%delp_BC%south_t0, &
!                      var_east_t1=neststruct%delp_BC%east_t1, &
!                      var_west_t1=neststruct%delp_BC%west_t1, &
!                      var_north_t1=neststruct%delp_BC%north_t1, &
!                      var_south_t1=neststruct%delp_BC%south_t1, &
!                      bctype=neststruct%nestbctype, &
!                      nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!                 call nested_grid_BC_apply_intT(ptc, &
!                      0, 0, npx, npy, npz, bd, split_timestep_BC+0.5, split, &
!                      var_east_t0=neststruct%pt_BC%east_t0, &
!                      var_west_t0=neststruct%pt_BC%west_t0, &
!                      var_north_t0=neststruct%pt_BC%north_t0, &
!                      var_south_t0=neststruct%pt_BC%south_t0, &
!                      var_east_t1=neststruct%pt_BC%east_t1, &
!                      var_west_t1=neststruct%pt_BC%west_t1, &
!                      var_north_t1=neststruct%pt_BC%north_t1, &
!                      var_south_t1=neststruct%pt_BC%south_t1, &
!                      bctype=neststruct%nestbctype, &
!                      nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!                 call nested_grid_BC_apply_intT(delz, &
!                      0, 0, npx, npy, npz, bd, split_timestep_BC+0.5, split, &
!                      var_east_t0=neststruct%delz_BC%east_t0, &
!                      var_west_t0=neststruct%delz_BC%west_t0, &
!                      var_north_t0=neststruct%delz_BC%north_t0, &
!                      var_south_t0=neststruct%delz_BC%south_t0, &
!                      var_east_t1=neststruct%delz_BC%east_t1, &
!                      var_west_t1=neststruct%delz_BC%west_t1, &
!                      var_north_t1=neststruct%delz_BC%north_t1, &
!                      var_south_t1=neststruct%delz_BC%south_t1, &
!                      bctype=neststruct%nestbctype, &
!                      nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!!!$         do k=1,npz
!!!$            call extrapolation_BC( delz(:,:,k), 0, 0, npx, npy, bd)
!!!$            call extrapolation_BC(delpc(:,:,k), 0, 0, npx, npy, bd)
!!!$            call extrapolation_BC(  ptc(:,:,k), 0, 0, npx, npy, bd)
!!!$         end do
!
!
!              !Compute gz/pkc
!              !NOTE: nominally only need to compute quantities one out in the halo for p_grad_c
!              !(instead of entire halo)
!              call geopk_halo_nh(ptop, grav, akap, cp, delpc, delz, ptc, phis, pkc, gz, pk3, &
!                   npx, npy, npz, gridstruct%nested, .false., .false., .false., bd)
!
!           endif
!#endif
      END IF
      CALL P_GRAD_C_TLM(dt2, npz, delpc, delpc_tl, pkc, pkc_tl, gz, &
&                 gz_tl, uc, uc_tl, vc, vc_tl, bd, gridstruct%rdxc, &
&                 gridstruct%rdyc, hydrostatic)
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
      CALL START_GROUP_HALO_UPDATE_TLM(i_pack(9), i_pack(9+12), uc, &
&                                uc_tl, vc, vc_tl, domain, gridtype=&
&                                cgrid_ne)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!#ifdef SW_DYNAMICS
!      if (test_case==9) call case9_forcing2(phis)
!      endif !test_case>1
!#endif
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
      IF (flagstruct%inline_q .AND. nq .GT. 0) CALL &
&       COMPLETE_GROUP_HALO_UPDATE(i_pack(10), i_pack(10+12), domain)
      IF (flagstruct%nord .GT. 0) CALL COMPLETE_GROUP_HALO_UPDATE(i_pack&
&                                                           (3), i_pack(&
&                                                           3+12), &
&                                                           domain)
      CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(9), i_pack(9+12), domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!      if (gridstruct%nested) then
!         !On a nested grid we have to do SOMETHING with uc and vc in
!         ! the boundary halo, particularly at the corners of the
!         ! domain and of each processor element. We must either
!         ! apply an interpolated BC, or extrapolate into the
!         ! boundary halo
!         ! NOTE: 
!         !The update_domains calls for uc and vc need to go BEFORE the BCs to ensure cross-restart
!         !bitwise-consistent solutions when doing the spatial extrapolation; should not make a
!         !difference for interpolated BCs from the coarse grid.
!
!
!!!$         do k=1,npz
!!!$            call extrapolation_BC(uc(:,:,k), 1, 0, npx, npy, bd)
!!!$            call extrapolation_BC(vc(:,:,k), 0, 1, npx, npy, bd)
!!!$         end do
!!!$
!
!
!         !vc
!            call nested_grid_BC_apply_intT(vc, &
!                 0, 1, npx, npy, npz, bd, split_timestep_bc+0.5, split, & 
!                 var_east_t0=neststruct%vc_BC%east_t0, &
!                 var_west_t0=neststruct%vc_BC%west_t0, &
!                 var_north_t0=neststruct%vc_BC%north_t0, &
!                 var_south_t0=neststruct%vc_BC%south_t0, &
!                 var_east_t1=neststruct%vc_BC%east_t1, &
!                 var_west_t1=neststruct%vc_BC%west_t1, &
!                 var_north_t1=neststruct%vc_BC%north_t1, &
!                 var_south_t1=neststruct%vc_BC%south_t1, &
!                 bctype=neststruct%nestbctype, &
!                 nsponge=neststruct%nsponge, s_weight=neststruct%s_weight  )
!
!            !uc
!            call nested_grid_BC_apply_intT(uc, &
!                 1, 0, npx, npy, npz, bd, split_timestep_bc+0.5, split, &
!                 var_east_t0=neststruct%uc_BC%east_t0, &
!                 var_west_t0=neststruct%uc_BC%west_t0, &
!                 var_north_t0=neststruct%uc_BC%north_t0, &
!                 var_south_t0=neststruct%uc_BC%south_t0, &
!                 var_east_t1=neststruct%uc_BC%east_t1, &
!                 var_west_t1=neststruct%uc_BC%west_t1, &
!                 var_north_t1=neststruct%uc_BC%north_t1, &
!                 var_south_t1=neststruct%uc_BC%south_t1, &
!                 bctype=neststruct%nestbctype, &
!                 nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!      end if
!    if ( flagstruct%inline_q ) then
!         if (gridstruct%nested) then
!            do iq=1,nq
!                  call nested_grid_BC_apply_intT(q(isd:ied,jsd:jed,:,iq), &
!                       0, 0, npx, npy, npz, bd, split_timestep_BC+1, split, &
!                       var_east_t0=neststruct%q_BC(iq)%east_t0, &
!                       var_west_t0=neststruct%q_BC(iq)%west_t0, &
!                       var_north_t0=neststruct%q_BC(iq)%north_t0, &
!                       var_south_t0=neststruct%q_BC(iq)%south_t0, &
!                       var_east_t1=neststruct%q_BC(iq)%east_t1, &
!                       var_west_t1=neststruct%q_BC(iq)%west_t1, &
!                       var_north_t1=neststruct%q_BC(iq)%north_t1, &
!                       var_south_t1=neststruct%q_BC(iq)%south_t1, &
!                       bctype=neststruct%nestbctype, &
!                       nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!            end do
!         end if
!      endif
!if (fv_timing_onoff) call timing_on('  d_sw')
!$OMP parallel do default(none) shared(npz,flagstruct,nord_v,pfull,damp_vt,hydrostatic,last_step, &
!$OMP                                  is,ie,js,je,isd,ied,jsd,jed,omga,delp,gridstruct,npx,npy,  &
!$OMP                                  ng,zh,vt,ptc,pt,u,v,w,uc,vc,ua,va,divgd,mfx,mfy,cx,cy,     &
!$OMP                                  crx,cry,xfx,yfx,q_con,zvir,sphum,nq,q,dt,bd,rdt,iep1,jep1, &
!$OMP                                  heat_source)                                               &
!$OMP                          private(nord_k, nord_w, nord_t, damp_k, damp_w, damp_t, d2_divg,   &
!$OMP                                  hord_m, hord_v, hord_t, hord_p, wk, heat_s, d_con_k, z_rat)
      DO k=1,npz
        hord_m = flagstruct%hord_mt
        hord_t = flagstruct%hord_tm
        hord_v = flagstruct%hord_vt
        hord_p = flagstruct%hord_dp
        hord_m_pert = flagstruct%hord_mt_pert
        hord_t_pert = flagstruct%hord_tm_pert
        hord_v_pert = flagstruct%hord_vt_pert
        hord_p_pert = flagstruct%hord_dp_pert
        nord_k = flagstruct%nord
        nord_k_pert = flagstruct%nord_pert
        IF (2 .GT. flagstruct%nord) THEN
          nord_v(k) = flagstruct%nord
        ELSE
          nord_v(k) = 2
        END IF
        IF (2 .GT. flagstruct%nord_pert) THEN
          nord_v_pert(k) = flagstruct%nord_pert
        ELSE
          nord_v_pert(k) = 2
        END IF
        damp_k = flagstruct%dddmp
        damp_k_pert = flagstruct%dddmp_pert
        arg1 = pfull(k)/pfull(npz)
        arg2 = 0.1*LOG(arg1)
        y1 = flagstruct%d2_bg*(1.-3.*TANH(arg2))
        IF (0.20 .GT. y1) THEN
          d2_divg = y1
        ELSE
          d2_divg = 0.20
        END IF
        arg1 = pfull(k)/pfull(npz)
        arg2 = 0.1*LOG(arg1)
        y2 = flagstruct%d2_bg_pert*(1.-3.*TANH(arg2))
        IF (0.20 .GT. y2) THEN
          d2_divg_pert = y2
        ELSE
          d2_divg_pert = 0.20
        END IF
        d_con_k = flagstruct%d_con
        d_con_k_pert = flagstruct%d_con_pert
        IF (flagstruct%do_vort_damp) THEN
! for delp, delz, and vorticity
          damp_vt(k) = flagstruct%vtdm4
        ELSE
          damp_vt(k) = 0.
        END IF
        IF (flagstruct%do_vort_damp_pert) THEN
! for delp, delz, and vorticity
          damp_vt_pert(k) = flagstruct%vtdm4_pert
        ELSE
          damp_vt_pert(k) = 0.
        END IF
        nord_w = nord_v(k)
        nord_w_pert = nord_v_pert(k)
        nord_t = nord_v(k)
        nord_t_pert = nord_v_pert(k)
        damp_w = damp_vt(k)
        damp_w_pert = damp_vt_pert(k)
        damp_t = damp_vt(k)
        damp_t_pert = damp_vt_pert(k)
        IF (npz .EQ. 1 .OR. flagstruct%n_sponge .LT. 0) THEN
          d2_divg = flagstruct%d2_bg
          d2_divg_pert = flagstruct%d2_bg_pert
        ELSE IF (flagstruct%n_sponge .EQ. 0) THEN
! New Del-2 Sponge layer: formulation
! Sponge layers with del-2 damping on divergence, vorticity, w, z, and air mass (delp).
! (no damping of potential temperature in sponge layers)
          IF (k .EQ. 1) THEN
            damp_k = 0.
            damp_k_pert = 0.
            nord_k = 0
            nord_k_pert = 0
            IF (flagstruct%d2_bg .LT. flagstruct%d2_bg_k1) THEN
              d2_divg = flagstruct%d2_bg_k1
            ELSE
              d2_divg = flagstruct%d2_bg
            END IF
            IF (flagstruct%d2_bg_pert .LT. flagstruct%d2_bg_k1) THEN
              d2_divg_pert = flagstruct%d2_bg_k1
            ELSE
              d2_divg_pert = flagstruct%d2_bg_pert
            END IF
! for delp, delz, and vorticity, sponger layers
            nord_v(k) = 0
! for delp, delz, and vorticity, sponger layers
            nord_v_pert(k) = 0
!#ifndef HIWPP
            damp_vt(k) = d2_divg
            damp_vt_pert(k) = d2_divg_pert
!#endif
            nord_w = 0
            nord_w_pert = 0
            damp_w = d2_divg
            damp_w_pert = d2_divg_pert
          ELSE IF (k .EQ. 2) THEN
            damp_k = 0.
            damp_k_pert = 0.
            nord_k = 0
            nord_k_pert = 0
            IF (flagstruct%d2_bg .LT. flagstruct%d2_bg_k2) THEN
              d2_divg = flagstruct%d2_bg_k2
            ELSE
              d2_divg = flagstruct%d2_bg
            END IF
            IF (flagstruct%d2_bg_pert .LT. flagstruct%d2_bg_k2) THEN
              d2_divg_pert = flagstruct%d2_bg_k2
            ELSE
              d2_divg_pert = flagstruct%d2_bg_pert
            END IF
            nord_v(k) = 0
            nord_v_pert(k) = 0
!#ifndef HIWPP
            damp_vt(k) = d2_divg
            damp_vt_pert(k) = d2_divg_pert
!#endif
            nord_w = 0
            nord_w_pert = 0
            damp_w = d2_divg
            damp_w_pert = d2_divg_pert
          ELSE IF (k .EQ. 3 .AND. flagstruct%d2_bg_k2 .GT. 0.05) THEN
            damp_k = 0.
            damp_k_pert = 0.
            nord_k = 0
            nord_k_pert = 0
            IF (flagstruct%d2_bg .LT. 0.2*flagstruct%d2_bg_k2) THEN
              d2_divg = 0.2*flagstruct%d2_bg_k2
            ELSE
              d2_divg = flagstruct%d2_bg
            END IF
            IF (flagstruct%d2_bg_pert .LT. 0.2*flagstruct%d2_bg_k2) THEN
              d2_divg_pert = 0.2*flagstruct%d2_bg_k2
            ELSE
              d2_divg_pert = flagstruct%d2_bg_pert
            END IF
            nord_v(k) = 0
            nord_v_pert(k) = 0
!#ifndef HIWPP
            damp_vt(k) = d2_divg
            damp_vt_pert(k) = d2_divg_pert
!#endif
            nord_w = 0
            nord_w_pert = 0
            damp_w = d2_divg
            damp_w_pert = d2_divg_pert
          END IF
          IF (damp_vt(k) .LT. 0.01 .AND. nord_k .GT. 0) d_con_k = 0.
          IF (damp_vt_pert(k) .LT. 0.01 .AND. nord_k_pert .GT. 0) &
&           d_con_k_pert = 0.
        ELSE IF (k .LE. flagstruct%n_sponge .AND. npz .GT. 16) THEN
! Apply first order scheme for damping the sponge layer
          hord_m = 1
          hord_m_pert = 1
          hord_v = 1
          hord_v_pert = 1
          hord_t = 1
          hord_t_pert = 1
          hord_p = 1
          hord_p_pert = 1
          nord_k = 0
          nord_k_pert = 0
          damp_k = flagstruct%damp_k_k1
          damp_k_pert = flagstruct%damp_k_k1
          IF (0.20 .GT. flagstruct%d2_bg_k1*flagstruct%d2_bg) THEN
            d2_divg = flagstruct%d2_bg_k1*flagstruct%d2_bg
          ELSE
            d2_divg = 0.20
          END IF
          IF (0.20 .GT. flagstruct%d2_bg_k1*flagstruct%d2_bg_pert) THEN
            d2_divg_pert = flagstruct%d2_bg_k1*flagstruct%d2_bg_pert
          ELSE
            d2_divg_pert = 0.20
          END IF
          IF (flagstruct%d2_divg_max_k1 .LT. d2_divg) THEN
            d2_divg = d2_divg
          ELSE
            d2_divg = flagstruct%d2_divg_max_k1
          END IF
          IF (flagstruct%d2_divg_max_k1 .LT. d2_divg_pert) THEN
            d2_divg_pert = d2_divg_pert
          ELSE
            d2_divg_pert = flagstruct%d2_divg_max_k1
          END IF
        ELSE IF (k .EQ. flagstruct%n_sponge + 1 .AND. npz .GT. 24) THEN
          hord_v = 2
          hord_v_pert = 1
          hord_t = 2
          hord_t_pert = 1
          hord_p = 2
          hord_p_pert = 1
          IF (0 .LT. flagstruct%nord - 1) THEN
            nord_k = flagstruct%nord - 1
          ELSE
            nord_k = 0
          END IF
          IF (0 .LT. flagstruct%nord_pert - 1) THEN
            nord_k_pert = flagstruct%nord_pert - 1
          ELSE
            nord_k_pert = 0
          END IF
          IF (0.20 .GT. flagstruct%d2_bg_k2*flagstruct%d2_bg) THEN
            d2_divg = flagstruct%d2_bg_k2*flagstruct%d2_bg
          ELSE
            d2_divg = 0.20
          END IF
          IF (0.20 .GT. flagstruct%d2_bg_k2*flagstruct%d2_bg_pert) THEN
            d2_divg_pert = flagstruct%d2_bg_k2*flagstruct%d2_bg_pert
          ELSE
            d2_divg_pert = 0.20
          END IF
          IF (flagstruct%d2_divg_max_k2 .LT. d2_divg) THEN
            d2_divg = d2_divg
          ELSE
            d2_divg = flagstruct%d2_divg_max_k2
          END IF
          IF (flagstruct%d2_divg_max_k2 .LT. d2_divg_pert) THEN
            d2_divg_pert = d2_divg_pert
          ELSE
            d2_divg_pert = flagstruct%d2_divg_max_k2
          END IF
          IF (flagstruct%nord .GT. 1) THEN
            damp_k = 0.
          ELSE
            damp_k = flagstruct%damp_k_k2
          END IF
          IF (flagstruct%nord_pert .GT. 1) THEN
            damp_k_pert = 0.
          ELSE
            damp_k_pert = flagstruct%damp_k_k2
          END IF
        END IF
        IF (damp_k .LT. flagstruct%dddmp) THEN
          damp_k = flagstruct%dddmp
        ELSE
          damp_k = damp_k
        END IF
        IF (damp_k_pert .LT. flagstruct%dddmp_pert) THEN
          damp_k_pert = flagstruct%dddmp_pert
        ELSE
          damp_k_pert = damp_k_pert
        END IF
        IF (hydrostatic .AND. (.NOT.flagstruct%use_old_omega) .AND. &
&           last_step) THEN
! Average horizontal "convergence" to cell center
          DO j=js,je
            DO i=is,ie
              omga_tl(i, j, k) = delp_tl(i, j, k)
              omga(i, j, k) = delp(i, j, k)
            END DO
          END DO
        END IF
!--- external mode divergence damping ---
        IF (flagstruct%d_ext .GT. 0.) CALL A2B_ORD2_TLM(delp(isd, jsd, k&
&                                                 ), delp_tl(isd, jsd, k&
&                                                 ), wk, wk_tl, &
&                                                 gridstruct, npx, npy, &
&                                                 is, ie, js, je, ng, &
&                                                 .false.)
        IF (.NOT.hydrostatic .AND. flagstruct%do_f3d) THEN
! Correction factor for 3D Coriolis force
          DO j=jsd,jed
            DO i=isd,ied
              z_rat_tl(i, j) = (zh_tl(i, j, k)+zh_tl(i, j, k+1))/radius
              z_rat(i, j) = 1. + (zh(i, j, k)+zh(i, j, k+1))/radius
            END DO
          END DO
        END IF
        CALL D_SW_TLM(vt(isd:ied, jsd:jed, k), vt_tl(isd:ied, jsd:jed, k&
&               ), vt_tj(isd:ied, jsd:jed, k), delp(isd:ied, jsd:jed, k)&
&               , delp_tl(isd:ied, jsd:jed, k), ptc(isd:ied, jsd:jed, k)&
&               , ptc_tl(isd:ied, jsd:jed, k), pt(isd:ied, jsd:jed, k), &
&               pt_tl(isd:ied, jsd:jed, k), u(isd:ied, jsd:jed+1, k), &
&               u_tl(isd:ied, jsd:jed+1, k), v(isd:ied+1, jsd:jed, k), &
&               v_tl(isd:ied+1, jsd:jed, k), w(isd:ied, jsd:jed, k), &
&               w_tl(isd:ied, jsd:jed, k), uc(isd:ied+1, jsd:jed, k), &
&               uc_tl(isd:ied+1, jsd:jed, k), vc(isd:ied, jsd:jed+1, k)&
&               , vc_tl(isd:ied, jsd:jed+1, k), ua(isd:ied, jsd:jed, k)&
&               , ua_tl(isd:ied, jsd:jed, k), va(isd:ied, jsd:jed, k), &
&               va_tl(isd:ied, jsd:jed, k), divgd(isd:ied+1, jsd:jed+1, &
&               k), divgd_tl(isd:ied+1, jsd:jed+1, k), mfx(is:ie+1, js:&
&               je, k), mfx_tl(is:ie+1, js:je, k), mfy(is:ie, js:je+1, k&
&               ), mfy_tl(is:ie, js:je+1, k), cx(is:ie+1, jsd:jed, k), &
&               cx_tl(is:ie+1, jsd:jed, k), cy(isd:ied, js:je+1, k), &
&               cy_tl(isd:ied, js:je+1, k), crx(is:ie+1, jsd:jed, k), &
&               crx_tl(is:ie+1, jsd:jed, k), cry(isd:ied, js:je+1, k), &
&               cry_tl(isd:ied, js:je+1, k), xfx(is:ie+1, jsd:jed, k), &
&               xfx_tl(is:ie+1, jsd:jed, k), yfx(isd:ied, js:je+1, k), &
&               yfx_tl(isd:ied, js:je+1, k), q_con(isd:isd, jsd:jsd, 1)&
&               , z_rat(isd:ied, jsd:jed), z_rat_tl(isd:ied, jsd:jed), &
&               heat_s, heat_s_tl, zvir, sphum, nq, q, q_tl, k, npz, &
&               flagstruct%inline_q, dt, flagstruct%hord_tr, hord_m, &
&               hord_v, hord_t, hord_p, flagstruct%hord_tr_pert, &
&               hord_m_pert, hord_v_pert, hord_t_pert, hord_p_pert, &
&               nord_k, nord_v(k), nord_w, nord_t, damp_k, d2_divg, &
&               flagstruct%d4_bg, damp_vt(k), damp_w, damp_t, d_con_k, &
&               flagstruct%split_damp, nord_k_pert, nord_v_pert(k), &
&               nord_w_pert, nord_t_pert, damp_k_pert, d2_divg_pert, &
&               flagstruct%d4_bg_pert, damp_vt_pert(k), damp_w_pert, &
&               damp_t_pert, d_con_k_pert, hydrostatic, gridstruct, &
&               flagstruct, bd)
        IF (hydrostatic .AND. (.NOT.flagstruct%use_old_omega) .AND. &
&           last_step) THEN
! Average horizontal "convergence" to cell center
          DO j=js,je
            DO i=is,ie
              omga_tl(i, j, k) = gridstruct%rarea(i, j)*rdt*(omga_tl(i, &
&               j, k)*(xfx(i, j, k)-xfx(i+1, j, k)+yfx(i, j, k)-yfx(i, j&
&               +1, k))+omga(i, j, k)*(xfx_tl(i, j, k)-xfx_tl(i+1, j, k)&
&               +yfx_tl(i, j, k)-yfx_tl(i, j+1, k)))
              omga(i, j, k) = omga(i, j, k)*(xfx(i, j, k)-xfx(i+1, j, k)&
&               +yfx(i, j, k)-yfx(i, j+1, k))*gridstruct%rarea(i, j)*rdt
            END DO
          END DO
        END IF
        IF (flagstruct%d_ext .GT. 0.) THEN
          DO j=js,jep1
            DO i=is,iep1
! delp at cell corners
              ptc_tl(i, j, k) = wk_tl(i, j)
              ptc(i, j, k) = wk(i, j)
            END DO
          END DO
        END IF
        IF (d_con_k .GT. 1.0e-5) THEN
! Average horizontal "convergence" to cell center
          DO j=js,je
            DO i=is,ie
              heat_source_tl(i, j, k) = heat_source_tl(i, j, k) + &
&               heat_s_tl(i, j)
              heat_source(i, j, k) = heat_source(i, j, k) + heat_s(i, j)
            END DO
          END DO
        END IF
      END DO
! end openMP k-loop
!if (fv_timing_onoff) call timing_off('  d_sw')
      IF (flagstruct%fill_dp) CALL MIX_DP_TLM(hydrostatic, w, w_tl, delp&
&                                       , delp_tl, pt, pt_tl, npz, ak, &
&                                       bk, .false., flagstruct%fv_debug&
&                                       , bd)
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
      CALL START_GROUP_HALO_UPDATE_TLM(i_pack(1), i_pack(1+12), delp, &
&                                delp_tl, domain)
      CALL START_GROUP_HALO_UPDATE_TLM(i_pack(2), i_pack(2+12), pt, &
&                                pt_tl, domain)
!#ifdef USE_COND
!    call start_group_halo_update(i_pack(11), i_pack(11+12), q_con, domain)
!#endif
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
      IF (flagstruct%d_ext .GT. 0.) THEN
        d2_divg = flagstruct%d_ext*gridstruct%da_min_c
!$OMP parallel do default(none) shared(is,iep1,js,jep1,npz,wk,ptc,divg2,vt,d2_divg)
!!$AD II-LOOP
        DO j=js,jep1
          DO i=is,iep1
            wk_tl(i, j) = ptc_tl(i, j, 1)
            wk(i, j) = ptc(i, j, 1)
            divg2_tl(i, j) = wk_tl(i, j)*vt(i, j, 1) + wk(i, j)*vt_tl(i&
&             , j, 1)
            divg2(i, j) = wk(i, j)*vt(i, j, 1)
          END DO
          DO k=2,npz
            DO i=is,iep1
              wk_tl(i, j) = wk_tl(i, j) + ptc_tl(i, j, k)
              wk(i, j) = wk(i, j) + ptc(i, j, k)
              divg2_tl(i, j) = divg2_tl(i, j) + ptc_tl(i, j, k)*vt(i, j&
&               , k) + ptc(i, j, k)*vt_tl(i, j, k)
              divg2(i, j) = divg2(i, j) + ptc(i, j, k)*vt(i, j, k)
            END DO
          END DO
          DO i=is,iep1
            divg2_tl(i, j) = (d2_divg*divg2_tl(i, j)*wk(i, j)-d2_divg*&
&             divg2(i, j)*wk_tl(i, j))/wk(i, j)**2
            divg2(i, j) = d2_divg*divg2(i, j)/wk(i, j)
          END DO
        END DO
      ELSE
        divg2(:, :) = 0.
        divg2_tl = 0.0_FVPRC
      END IF
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
      CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(1), i_pack(1+12), domain)
      CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(2), i_pack(2+12), domain)
! end hydro check
!#ifdef USE_COND
!     call complete_group_halo_update(i_pack(11), i_pack(11+12), domain)
!#endif
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!    if ( flagstruct%fv_debug ) then
!         if ( .not. flagstruct%hydrostatic )    &
!         call prt_mxm('delz',  delz, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!    endif
      IF (hydrostatic) THEN
        CALL GEOPK_TLM(ptop, pe, pe_tl, peln, peln_tl, delp, delp_tl, &
&                pkc, pkc_tl, gz, gz_tl, phis, pt, pt_tl, q_con, pkz, &
&                pkz_tl, npz, akap, .false., gridstruct%nested, .true., &
&                npx, npy, flagstruct%a2b_ord, bd)
!Want to move this block into the hydro/nonhydro branch above and merge the two if structures
!          if (gridstruct%nested) then
!
!             call nested_grid_BC_apply_intT(delp, &
!                  0, 0, npx, npy, npz, bd, split_timestep_BC+1, split, &
!                  var_east_t0=neststruct%delp_BC%east_t0, &
!                  var_west_t0=neststruct%delp_BC%west_t0, &
!                  var_north_t0=neststruct%delp_BC%north_t0, &
!                  var_south_t0=neststruct%delp_BC%south_t0, &
!                  var_east_t1=neststruct%delp_BC%east_t1, &
!                  var_west_t1=neststruct%delp_BC%west_t1, &
!                  var_north_t1=neststruct%delp_BC%north_t1, &
!                  var_south_t1=neststruct%delp_BC%south_t1, &
!                  bctype=neststruct%nestbctype, &
!                  nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!!#ifndef SW_DYNAMICS
!
!             call nested_grid_BC_apply_intT(pt, &
!                  0, 0, npx, npy, npz, bd, split_timestep_BC+1, split, &
!                  var_east_t0=neststruct%pt_BC%east_t0, &
!                  var_west_t0=neststruct%pt_BC%west_t0, &
!                  var_north_t0=neststruct%pt_BC%north_t0, &
!                  var_south_t0=neststruct%pt_BC%south_t0, &
!                  var_east_t1=neststruct%pt_BC%east_t1, &
!                  var_west_t1=neststruct%pt_BC%west_t1, &
!                  var_north_t1=neststruct%pt_BC%north_t1, &
!                  var_south_t1=neststruct%pt_BC%south_t1, &
!                  bctype=neststruct%nestbctype, &
!                  nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!!#endif
!          end if
      ELSE
!if (fv_timing_onoff) call timing_on('  UPDATE_DZ')
        CALL UPDATE_DZ_D_TLM(nord_v, damp_vt, flagstruct%hord_tm, &
&                      flagstruct%hord_tm_pert, is, ie, js, je, npz, ng&
&                      , npx, npy, gridstruct%area, gridstruct%rarea, &
&                      dp_ref, zs, zh, zh_tl, crx, crx_tl, cry, cry_tl, &
&                      xfx, xfx_tl, yfx, yfx_tl, ws, ws_tl, rdt, &
&                      gridstruct, bd)
!           call prt_maxmin('WS', ws, is, ie, js, je, 0, 1, 1._FVPRC, master)
!            used=send_data(idiag%id_ws, ws, fv_time)
!Want to move this block into the hydro/nonhydro branch above and merge the two if structures
!        if (gridstruct%nested) then
!
!           call nested_grid_BC_apply_intT(delp, &
!                0, 0, npx, npy, npz, bd, split_timestep_BC+1, split, &
!                var_east_t0=neststruct%delp_BC%east_t0, &
!                var_west_t0=neststruct%delp_BC%west_t0, &
!                var_north_t0=neststruct%delp_BC%north_t0, &
!                var_south_t0=neststruct%delp_BC%south_t0, &
!                var_east_t1=neststruct%delp_BC%east_t1, &
!                var_west_t1=neststruct%delp_BC%west_t1, &
!                var_north_t1=neststruct%delp_BC%north_t1, &
!                var_south_t1=neststruct%delp_BC%south_t1, &
!                bctype=neststruct%nestbctype, &
!                nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!!#ifndef SW_DYNAMICS
!
!           call nested_grid_BC_apply_intT(pt, &
!                0, 0, npx, npy, npz, bd, split_timestep_BC+1, split, &
!                var_east_t0=neststruct%pt_BC%east_t0, &
!                var_west_t0=neststruct%pt_BC%west_t0, &
!                var_north_t0=neststruct%pt_BC%north_t0, &
!                var_south_t0=neststruct%pt_BC%south_t0, &
!                var_east_t1=neststruct%pt_BC%east_t1, &
!                var_west_t1=neststruct%pt_BC%west_t1, &
!                var_north_t1=neststruct%pt_BC%north_t1, &
!                var_south_t1=neststruct%pt_BC%south_t1, &
!                bctype=neststruct%nestbctype, &
!                nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!!#endif
!
!        end if
!if (fv_timing_onoff) call timing_on('  Riem_Solver')
        CALL RIEM_SOLVER3_TLM(flagstruct%m_split, dt, is, ie, js, je, &
&                       npz, ng, isd, ied, jsd, jed, akap, cappa, cp, &
&                       ptop, zs, q_con, w, w_tl, delz, delz_tl, pt, &
&                       pt_tl, delp, delp_tl, zh, zh_tl, pe, pe_tl, pkc&
&                       , pkc_tl, pk3, pk3_tl, pk, pk_tl, peln, peln_tl&
&                       , ws, ws_tl, flagstruct%scale_z, flagstruct%&
&                       p_fac, flagstruct%a_imp, flagstruct%use_logp, &
&                       remap_step, beta .LT. -0.1)
!if (fv_timing_onoff) call timing_off('  Riem_Solver')
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
        CALL START_GROUP_HALO_UPDATE_TLM(i_pack(4), i_pack(4+12), zh, &
&                                  zh_tl, domain)
        IF (gridstruct%square_domain) THEN
          CALL START_GROUP_HALO_UPDATE_TLM(i_pack(6), i_pack(6+12), pkc&
&                                    , pkc_tl, domain, whalo=2, ehalo=2&
&                                    , shalo=2, nhalo=2)
        ELSE
          CALL START_GROUP_HALO_UPDATE_TLM(i_pack(6), i_pack(6+12), pkc&
&                                    , pkc_tl, domain)
        END IF
        IF (remap_step) CALL PE_HALO_TLM(is, ie, js, je, isd, ied, jsd, &
&                                  jed, npz, ptop, pe, pe_tl, delp, &
&                                  delp_tl)
        IF (flagstruct%use_logp) THEN
          CALL PLN_HALO_TLM(is, ie, js, je, isd, ied, jsd, jed, npz, &
&                     ptop, pk3, pk3_tl, delp, delp_tl)
        ELSE
          CALL PK3_HALO_TLM(is, ie, js, je, isd, ied, jsd, jed, npz, &
&                     ptop, akap, pk3, pk3_tl, delp, delp_tl)
        END IF
        CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(4), i_pack(4+12), domain)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,gz,zh,grav)
        DO k=1,npz+1
          DO j=js-2,je+2
            DO i=is-2,ie+2
              gz_tl(i, j, k) = grav*zh_tl(i, j, k)
              gz(i, j, k) = zh(i, j, k)*grav
            END DO
          END DO
        END DO
        CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(6), i_pack(6+12), domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
      END IF
!#ifdef SW_DYNAMICS
!      if (test_case > 1) then
!#else
      IF (remap_step .AND. hydrostatic) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pk,pkc)
        DO k=1,npz+1
          DO j=js,je
            DO i=is,ie
              pk_tl(i, j, k) = pkc_tl(i, j, k)
              pk(i, j, k) = pkc(i, j, k)
            END DO
          END DO
        END DO
      END IF
!#endif
!----------------------------
! Compute pressure gradient:
!----------------------------
!if (fv_timing_onoff) call timing_on('  PG_D')
      IF (hydrostatic) THEN
        IF (beta .GT. 0.) THEN
          CALL GRAD1_P_UPDATE_TLM(divg2, divg2_tl, u, u_tl, v, v_tl, du&
&                           , du_tl, dv, dv_tl, pkc, pkc_tl, gz, gz_tl, &
&                           dt, ng, gridstruct, bd, npx, npy, npz, ptop&
&                           , beta_d, flagstruct%a2b_ord)
        ELSE
          CALL ONE_GRAD_P_TLM(u, u_tl, v, v_tl, pkc, pkc_tl, gz, gz_tl, &
&                       divg2, divg2_tl, delp, delp_tl, dt, ng, &
&                       gridstruct, bd, npx, npy, npz, ptop, hydrostatic&
&                       , flagstruct%a2b_ord, flagstruct%d_ext)
        END IF
      ELSE IF (beta .GT. 0.) THEN
!#ifndef SW_DYNAMICS
!       if (gridstruct%nested) then
!           call nested_grid_BC_apply_intT(delz, &
!                    0, 0, npx, npy, npz, bd, split_timestep_BC+1., split, &
!                    var_east_t0=neststruct%delz_BC%east_t0, &
!                    var_west_t0=neststruct%delz_BC%west_t0, &
!                    var_north_t0=neststruct%delz_BC%north_t0, &
!                    var_south_t0=neststruct%delz_BC%south_t0, &
!                    var_east_t1=neststruct%delz_BC%east_t1, &
!                    var_west_t1=neststruct%delz_BC%west_t1, &
!                    var_north_t1=neststruct%delz_BC%north_t1, &
!                    var_south_t1=neststruct%delz_BC%south_t1, &
!                    bctype=neststruct%nestbctype, &
!                    nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!            !Compute gz/pkc/pk3; note that now pkc should be nonhydro pert'n pressure
!            call geopk_halo_nh(ptop, grav, akap, cp, delp, delz, pt, phis, pkc, &
!                               gz, pk3, npx, npy, npz, gridstruct%nested, .true., .true., .true., bd)
!
!       endif
!#endif
        CALL SPLIT_P_GRAD_TLM(u, u_tl, v, v_tl, du, du_tl, dv, dv_tl, &
&                       pkc, pkc_tl, gz, gz_tl, delp, delp_tl, pk3, &
&                       pk3_tl, beta_d, dt, ng, gridstruct, bd, npx, npy&
&                       , npz, flagstruct%use_logp)
      ELSE IF (beta .LT. -0.1) THEN
        CALL ONE_GRAD_P_TLM(u, u_tl, v, v_tl, pkc, pkc_tl, gz, gz_tl, &
&                     divg2, divg2_tl, delp, delp_tl, dt, ng, gridstruct&
&                     , bd, npx, npy, npz, ptop, hydrostatic, flagstruct&
&                     %a2b_ord, flagstruct%d_ext)
      ELSE
        CALL NH_P_GRAD_TLM(u, u_tl, v, v_tl, pkc, pkc_tl, gz, gz_tl, &
&                    delp, delp_tl, pk3, pk3_tl, dt, ng, gridstruct, bd&
&                    , npx, npy, npz, flagstruct%use_logp)
      END IF
!#ifdef ROT3
!       if ( flagstruct%do_f3d ) then
!!$OMP parallel do default(none) shared(is,ie,js,je,npz,ua,gridstruct,w,va,isd,ied,jsd,jed)
!           do k=1,npz
!              do j=js,je
!                 do i=is,ie
!                    ua(i,j,k) = -gridstruct%w00(i,j)*w(i,j,k)
!                 enddo
!              enddo
!              do j=jsd,jed
!                 do i=isd,ied
!                    va(i,j,k) = 0.
!                 enddo
!              enddo
!           enddo
!           call mpp_update_domains(ua, domain, complete=.true.)
!           call update_dwinds_phys(is, ie, js, je, isd, ied, jsd, jed, dt, ua, va, u, v, gridstruct, npx, npy, npz, domain)
!       endif
!#endif
!if (fv_timing_onoff) call timing_off('  PG_D')
!-------------------------------------------------------------------------------------------------------
      IF (flagstruct%breed_vortex_inline) THEN
        IF (.NOT.hydrostatic) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pkz,cappa,kapag,delp,delz,pt,k1k)
          DO k=1,npz
            DO j=js,je
              DO i=is,ie
! Note: pt at this stage is cp*Theta_m
!#ifdef MOIST_CAPPA
!                    pkz(i,j,k) = exp(cappa(i,j,k)/(1.-cappa(i,j,k))*log(kapag*delp(i,j,k)/delz(i,j,k)*pt(i,j,k)) )
!#else
                arg1_tl = (kapag*delp_tl(i, j, k)*delz(i, j, k)-kapag*&
&                 delp(i, j, k)*delz_tl(i, j, k))*pt(i, j, k)/delz(i, j&
&                 , k)**2 + kapag*delp(i, j, k)*pt_tl(i, j, k)/delz(i, j&
&                 , k)
                arg1 = kapag*delp(i, j, k)/delz(i, j, k)*pt(i, j, k)
                arg2_tl = k1k*arg1_tl/arg1
                arg2 = k1k*LOG(arg1)
                pkz_tl(i, j, k) = arg2_tl*EXP(arg2)
                pkz(i, j, k) = EXP(arg2)
              END DO
            END DO
          END DO
        END IF
      END IF
!#endif
!#if defined (ADA_NUDGE)
!         call breed_slp_inline_ada( it, dt, npz, ak, bk, phis, pe, pk, peln, pkz,     &
!                                delp, u, v, pt, q, flagstruct%nwat, zvir, gridstruct, ks, domain, bd )
!#else
!call breed_slp_inline( it, dt, npz, ak, bk, phis, pe, pk, peln, pkz, delp, u, v, pt, q,    &
!                       flagstruct%nwat, zvir, gridstruct, ks, domain, bd, hydrostatic )
!#endif
!-------------------------------------------------------------------------------------------------------
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
      IF (it .EQ. n_split .AND. gridstruct%grid_type .LT. 4 .AND. (.NOT.&
&         gridstruct%nested)) THEN
! Prevent accumulation of rounding errors at overlapped domain edges:
        CALL MPP_GET_BOUNDARY_TLM(u, u_tl, v, v_tl, domain, wbuffery=&
&                           wbuffer, ebuffery=ebuffer, ebuffery_tl=&
&                           ebuffer_tl, sbufferx=sbuffer, nbufferx=&
&                           nbuffer, nbufferx_tl=nbuffer_tl, gridtype=&
&                           dgrid_ne)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,u,nbuffer,v,ebuffer)
        DO k=1,npz
          DO i=is,ie
            u_tl(i, je+1, k) = nbuffer_tl(i-is+1, k)
            u(i, je+1, k) = nbuffer(i-is+1, k)
          END DO
          DO j=js,je
            v_tl(ie+1, j, k) = ebuffer_tl(j-js+1, k)
            v(ie+1, j, k) = ebuffer(j-js+1, k)
          END DO
        END DO
      END IF
!#ifndef ROT3
      IF (it .NE. n_split) CALL START_GROUP_HALO_UPDATE_TLM(i_pack(8), &
&                                                     i_pack(8+12), u, &
&                                                     u_tl, v, v_tl, &
&                                                     domain, gridtype=&
&                                                     dgrid_ne)
!#endif
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!#ifdef SW_DYNAMICS
!    endif
!#endif
      IF (gridstruct%nested) neststruct%nest_timestep = neststruct%&
&         nest_timestep + 1
!#ifdef SW_DYNAMICS
!#else
      IF (hydrostatic .AND. last_step) THEN
        IF (flagstruct%use_old_omega) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,omga,pe,pem,rdt)
          DO k=1,npz
            DO j=js,je
              DO i=is,ie
                omga_tl(i, j, k) = rdt*(pe_tl(i, k+1, j)-pem_tl(i, k+1, &
&                 j))
                omga(i, j, k) = (pe(i, k+1, j)-pem(i, k+1, j))*rdt
              END DO
            END DO
          END DO
!------------------------------
! Compute the "advective term"
!------------------------------
          CALL ADV_PE_TLM(ua, ua_tl, va, va_tl, pem, pem_tl, omga, &
&                   omga_tl, gridstruct, bd, npx, npy, npz, ng)
        ELSE
!$OMP parallel do default(none) shared(is,ie,js,je,npz,omga) private(om2d)
!!$AD II-LOOP
          DO j=js,je
            DO k=1,npz
              DO i=is,ie
                om2d_tl(i, k) = omga_tl(i, j, k)
                om2d(i, k) = omga(i, j, k)
              END DO
            END DO
            DO k=2,npz
              DO i=is,ie
                om2d_tl(i, k) = om2d_tl(i, k-1) + omga_tl(i, j, k)
                om2d(i, k) = om2d(i, k-1) + omga(i, j, k)
              END DO
            END DO
            DO k=2,npz
              DO i=is,ie
                omga_tl(i, j, k) = om2d_tl(i, k)
                omga(i, j, k) = om2d(i, k)
              END DO
            END DO
          END DO
        END IF
        IF (idiag%id_ws .GT. 0 .AND. hydrostatic) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,ws,delz,delp,omga)
          DO j=js,je
            DO i=is,ie
              ws_tl(i, j) = (delz_tl(i, j, npz)*delp(i, j, npz)-delz(i, &
&               j, npz)*delp_tl(i, j, npz))*omga(i, j, npz)/delp(i, j, &
&               npz)**2 + delz(i, j, npz)*omga_tl(i, j, npz)/delp(i, j, &
&               npz)
              ws(i, j) = delz(i, j, npz)/delp(i, j, npz)*omga(i, j, npz)
            END DO
          END DO
        END IF
      END IF
    END DO
!          used=send_data(idiag%id_ws, ws, fv_time)
!#endif
!    if (gridstruct%nested) then
!!#ifdef SW_DYNAMICS
!!#else
!
!
!
!         if (.not. hydrostatic) then
!               call nested_grid_BC_apply_intT(w, &
!                    0, 0, npx, npy, npz, bd, split_timestep_BC, split, &
!                    var_east_t0=neststruct%w_BC%east_t0, &
!                    var_west_t0=neststruct%w_BC%west_t0, &
!                    var_north_t0=neststruct%w_BC%north_t0, &
!                    var_south_t0=neststruct%w_BC%south_t0, &
!                    var_east_t1=neststruct%w_BC%east_t1, &
!                    var_west_t1=neststruct%w_BC%west_t1, &
!                    var_north_t1=neststruct%w_BC%north_t1, &
!                    var_south_t1=neststruct%w_BC%south_t1, &
!                    bctype=neststruct%nestbctype, &
!                    nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!         end if
!!#endif
!         
!         
!            call nested_grid_BC_apply_intT(u, &
!                 0, 1, npx, npy, npz, bd, split_timestep_BC, split, &
!                 var_east_t0=neststruct%u_BC%east_t0, &
!                 var_west_t0=neststruct%u_BC%west_t0, &
!                 var_north_t0=neststruct%u_BC%north_t0, &
!                 var_south_t0=neststruct%u_BC%south_t0, &
!                 var_east_t1=neststruct%u_BC%east_t1, &
!                 var_west_t1=neststruct%u_BC%west_t1, &
!                 var_north_t1=neststruct%u_BC%north_t1, &
!                 var_south_t1=neststruct%u_BC%south_t1, &
!                 bctype=neststruct%nestbctype, &
!                 nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!         !v
!            call nested_grid_BC_apply_intT(v, &
!                 1, 0, npx, npy, npz, bd, split_timestep_BC, split, &
!                 var_east_t0=neststruct%v_BC%east_t0, &
!                 var_west_t0=neststruct%v_BC%west_t0, &
!                 var_north_t0=neststruct%v_BC%north_t0, &
!                 var_south_t0=neststruct%v_BC%south_t0, &
!                 var_east_t1=neststruct%v_BC%east_t1, &
!                 var_west_t1=neststruct%v_BC%west_t1, &
!                 var_north_t1=neststruct%v_BC%north_t1, &
!                 var_south_t1=neststruct%v_BC%south_t1, &
!                 bctype=neststruct%nestbctype, &
!                 nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!      end if
!-----------------------------------------------------
! time split loop
!-----------------------------------------------------
!  if ( flagstruct%fv_debug ) then
!       if(is_master()) write(*,*) 'End of n_split loop'
!  endif
    IF (n_con .NE. 0 .AND. flagstruct%d_con .GT. 1.e-5) THEN
      CALL DEL2_CUBED_TLM(heat_source, heat_source_tl, cnst_0p20*&
&                   gridstruct%da_min, gridstruct, domain, npx, npy, npz&
&                   , 3, bd)
! Note: pt here is cp*(Virtual_Temperature/pkz)
      IF (hydrostatic) THEN
!
! del(Cp*T) = - del(KE)
!
!$OMP parallel do default(none) shared(is,ie,js,je,n_con,pt,heat_source,delp,pkz)
        DO j=js,je
          DO k=1,n_con
            DO i=is,ie
              pt_tl(i, j, k) = pt_tl(i, j, k) + (heat_source_tl(i, j, k)&
&               *delp(i, j, k)*pkz(i, j, k)-heat_source(i, j, k)*(&
&               delp_tl(i, j, k)*pkz(i, j, k)+delp(i, j, k)*pkz_tl(i, j&
&               , k)))/(delp(i, j, k)*pkz(i, j, k))**2
              pt(i, j, k) = pt(i, j, k) + heat_source(i, j, k)/(delp(i, &
&               j, k)*pkz(i, j, k))
            END DO
          END DO
        END DO
      ELSE
!$OMP parallel do default(none) shared(is,ie,js,je,n_con,pkz,cappa,kapag,delp,delz,pt, &
!$OMP                                  heat_source,k1k) &
!$OMP                          private(cpm, tmcp)
        DO j=js,je
! n_con is usually less than 3; not good as outer openMP loop
          DO k=1,n_con
            DO i=is,ie
!#ifdef MOIST_CAPPA
!                pkz(i,j,k) = exp(cappa(i,j,k)/(1.-cappa(i,j,k))*log(kapag*delp(i,j,k)/delz(i,j,k)*pt(i,j,k)) )
!#else
              arg1_tl = (kapag*delp_tl(i, j, k)*delz(i, j, k)-kapag*delp&
&               (i, j, k)*delz_tl(i, j, k))*pt(i, j, k)/delz(i, j, k)**2&
&               + kapag*delp(i, j, k)*pt_tl(i, j, k)/delz(i, j, k)
              arg1 = kapag*delp(i, j, k)/delz(i, j, k)*pt(i, j, k)
              arg2_tl = k1k*arg1_tl/arg1
              arg2 = k1k*LOG(arg1)
              pkz_tl(i, j, k) = arg2_tl*EXP(arg2)
              pkz(i, j, k) = EXP(arg2)
!#endif
! tmcp = termperature_v * cp
              tmcp_tl = pt_tl(i, j, k)*pkz(i, j, k) + pt(i, j, k)*pkz_tl&
&               (i, j, k)
              tmcp = pt(i, j, k)*pkz(i, j, k)
              delz_tl(i, j, k) = (delz_tl(i, j, k)*tmcp-delz(i, j, k)*&
&               tmcp_tl)/tmcp**2
              delz(i, j, k) = delz(i, j, k)/tmcp
              tmcp_tl = tmcp_tl + (heat_source_tl(i, j, k)*delp(i, j, k)&
&               -heat_source(i, j, k)*delp_tl(i, j, k))/delp(i, j, k)**2
              tmcp = tmcp + heat_source(i, j, k)/delp(i, j, k)
              pt_tl(i, j, k) = (tmcp_tl*pkz(i, j, k)-tmcp*pkz_tl(i, j, k&
&               ))/pkz(i, j, k)**2
              pt(i, j, k) = tmcp/pkz(i, j, k)
              delz_tl(i, j, k) = delz_tl(i, j, k)*tmcp + delz(i, j, k)*&
&               tmcp_tl
              delz(i, j, k) = delz(i, j, k)*tmcp
            END DO
          END DO
        END DO
      END IF
    END IF
  END SUBROUTINE DYN_CORE_TLM
!---- version number -----
!  character(len=128) :: version = '$Id: dyn_core.F90,v 1.2.2.1.2.1.30.1.4.1.22.5.48.6.2.2.2.1.4.1 2017/02/16 03:47:47 aoloso Exp
! $'
!  character(len=128) :: tagname = '$Name: Heracles-UNSTABLE_ncepdyn_Feb222017 $'
!-----------------------------------------------------------------------
!     dyn_core :: FV Lagrangian dynamics driver
!-----------------------------------------------------------------------
  SUBROUTINE DYN_CORE(npx, npy, npz, ng, sphum, nq, bdt, n_split, zvir, &
&   cp, akap, cappa, grav, hydrostatic, u, v, w, delz, pt, q, delp, pe, &
&   pk, phis, ws, omga, ptop, pfull, ua, va, uc, vc, mfx, mfy, cx, cy, &
&   pkz, peln, q_con, ak, bk, ks, gridstruct, flagstruct, neststruct, &
&   idiag, bd, domain, init_step, i_pack, end_step, gz, pkc, ptc, crx, &
&   xfx, cry, yfx, divgd, delpc, ut, vt, zh, pk3, du, dv, time_total)
    IMPLICIT NONE
!if (fv_timing_onoff) call timing_off('  UPDATE_DZ')
!    if ( flagstruct%fv_debug ) then
!         if ( .not. flagstruct%hydrostatic )    &
!         call prt_mxm('delz updated',  delz, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!    endif
!deallocate( heat_source )    
!if (allocated(heat_source)) deallocate( heat_source ) !If ncon == 0 but d_con > 1.e-5, this would not be deallocated in earlier 
!versions of the code
!deallocate(    gz )
!deallocate(   ptc )
!deallocate(   crx )
!deallocate(   xfx )
!deallocate(   cry )
!deallocate(   yfx )
!deallocate( divgd )
!deallocate(   pkc )
!deallocate( delpc )
!if( allocated(ut))   deallocate( ut )
!if( allocated(vt))   deallocate( vt )
!if ( allocated (du) ) deallocate( du )
!if ( allocated (dv) ) deallocate( dv )
!if ( .not. hydrostatic ) then
!     deallocate( zh )
!     deallocate( pk3 )
!endif
!if( allocated(pem) )   deallocate ( pem )
!if ( flagstruct%fv_debug ) then
!   if(is_master()) write(*,*) 'End of dyn_core'
!endif
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
    INTEGER, INTENT(IN) :: ng, nq, sphum
    INTEGER, INTENT(IN) :: n_split
    REAL(fvprc), INTENT(IN) :: bdt
    REAL(fvprc), INTENT(IN) :: zvir, cp, akap, grav
    REAL(fvprc), INTENT(IN) :: ptop
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: init_step, end_step
    REAL(fvprc), INTENT(IN) :: pfull(npz)
    REAL(fvprc), DIMENSION(npz+1), INTENT(IN) :: ak, bk
    INTEGER, INTENT(IN) :: ks
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: i_pack(*)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! D grid zonal wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz), INTENT(&
&   INOUT) :: u
! D grid meridional wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: v
! vertical vel. (m/s)
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! delta-height (m)
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! moist kappa
    REAL(fvprc), INTENT(INOUT) :: cappa(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
! temperature (K)
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! pressure thickness (pascal)
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! 
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, &
&   nq)
! total time (seconds) since start
    REAL(fvprc), INTENT(IN), OPTIONAL :: time_total
!-----------------------------------------------------------------------
! Auxilliary pressure arrays:    
! The 5 vars below can be re-computed from delp and ptop.
!-----------------------------------------------------------------------
! dyn_aux:
! Surface geopotential (g*Z_surf)
    REAL(fvprc), INTENT(INOUT) :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
! edge pressure (pascal)
    REAL(fvprc), INTENT(INOUT) :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%&
&   je+1)
! ln(pe)
    REAL(fvprc), INTENT(INOUT) :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
! pe**kappa
    REAL(fvprc), INTENT(INOUT) :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
!-----------------------------------------------------------------------
! Others:
    REAL(fvprc), PARAMETER :: near0=1.e-8
    REAL(fvprc), PARAMETER :: huge_r=1.e20
! [m**2/sec] for T ~ 260 K
    REAL(fvprc), PARAMETER :: air_viscosity=1.e-5
!-----------------------------------------------------------------------
! w at surface
    REAL(fvprc), INTENT(OUT) :: ws(bd%is:bd%ie, bd%js:bd%je)
! Vertical pressure velocity (pa/s)
    REAL(fvprc), INTENT(INOUT) :: omga(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! (uc, vc) are mostly used as the C grid winds
    REAL(fvprc), INTENT(INOUT) :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: ua, va
    REAL(fvprc), INTENT(INOUT) :: q_con(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
! The Flux capacitors: accumulated Mass flux arrays
    REAL(fvprc), INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL(fvprc), INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
! Accumulated Courant number arrays
    REAL(fvprc), INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc), DIMENSION(bd%is:bd%ie, bd%js:bd%je, npz), INTENT(INOUT)&
&   :: pkz
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
    TYPE(FV_NEST_TYPE), INTENT(INOUT) :: neststruct
    TYPE(FV_DIAG_TYPE), INTENT(IN) :: idiag
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    REAL(fvprc) :: pem(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1), &
&   heat_source(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! Auto 1D & 2D arrays:
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ws3, z_rat
    REAL(fvprc) :: dp_ref(npz)
! surface height (m)
    REAL(fvprc) :: zs(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: p1d(bd%is:bd%ie)
    REAL(fvprc) :: om2d(bd%is:bd%ie, npz)
    REAL(fvprc) :: wbuffer(npy+2, npz)
    REAL(fvprc) :: ebuffer(npy+2, npz)
    REAL(fvprc) :: nbuffer(npx+2, npz)
    REAL(fvprc) :: sbuffer(npx+2, npz)
! ----   For external mode:
    REAL(fvprc) :: divg2(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: wk(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: fz(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: heat_s(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: damp_vt(npz+1)
    REAL(fvprc) :: damp_vt_pert(npz+1)
    INTEGER :: nord_v(npz+1)
    INTEGER :: nord_v_pert(npz+1)
!-------------------------------------
    INTEGER :: hord_m, hord_v, hord_t, hord_p
    INTEGER :: hord_m_pert, hord_v_pert, hord_t_pert, hord_p_pert
    INTEGER :: nord_k, nord_w, nord_t
    INTEGER :: nord_k_pert, nord_w_pert, nord_t_pert
    INTEGER :: ms
!---------------------------------------
    INTEGER :: i, j, k, it, iq, n_con
    INTEGER :: iep1, jep1
    REAL(fvprc) :: beta, beta_d, damp_k, damp_w, damp_t, d_con_k
    REAL(fvprc) :: damp_k_pert, damp_w_pert, damp_t_pert, d_con_k_pert
    REAL(fvprc) :: dt, dt2, rdt
    REAL(fvprc) :: d2_divg, d3_divg
    REAL(fvprc) :: d2_divg_pert
    REAL(fvprc) :: k1k, kapag, tmcp, cpm
    LOGICAL :: last_step, remap_step
    LOGICAL :: used
    REAL(fvprc) :: split_timestep_bc, split
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: pkc(bd%isd:bd%ied, bd%jsd:bd%jed, npz+&
&   1)
    REAL(fvprc), INTENT(INOUT) :: ptc(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: crx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: xfx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: cry(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc), INTENT(INOUT) :: yfx(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc), INTENT(INOUT) :: divgd(bd%isd:bd%ied+1, bd%jsd:bd%jed+1&
&   , npz)
    REAL(fvprc), INTENT(INOUT) :: delpc(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: ut(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: vt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: zh(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: pk3(bd%isd:bd%ied, bd%jsd:bd%jed, npz+&
&   1)
    REAL(fvprc), INTENT(INOUT) :: du(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: dv(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc) :: vt_tj(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    INTRINSIC LOG
    INTRINSIC REAL
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC TANH
    INTRINSIC EXP
    REAL(fvprc) :: arg1
    REAL(fvprc) :: arg2
    REAL(fvprc) :: y2
    REAL(fvprc) :: y1
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    damp_vt = 0
    damp_vt_pert = 0
    peln1 = LOG(ptop)
    ptk = ptop**akap
    dt = bdt/REAL(n_split)
    dt2 = 0.5*dt
    rdt = 1.0/dt
    IF (1 .LT. flagstruct%m_split/2) THEN
      ms = flagstruct%m_split/2
    ELSE
      ms = 1
    END IF
    beta = flagstruct%beta
    split = REAL(n_split*flagstruct%k_split)
! Indexes:
    iep1 = ie + 1
    jep1 = je + 1
    IF (.NOT.hydrostatic) THEN
      rgrav = 1.0/grav
! rg/Cv=0.4
      k1k = akap/(1.-akap)
      kapag = -(akap/grav)
!$OMP parallel do default(none) shared(npz,dp_ref,ak,bk)
      DO k=1,npz
        dp_ref(k) = ak(k+1) - ak(k) + (bk(k+1)-bk(k))*1.e5
      END DO
!$OMP parallel do default(none) shared(isd,ied,jsd,jed,zs,phis,rgrav)
      DO j=jsd,jed
        DO i=isd,ied
          zs(i, j) = phis(i, j)*rgrav
        END DO
      END DO
    END IF
! end init_step
    IF (init_step) THEN
! Start of the big dynamic time stepping
!allocate(    gz(isd:ied, jsd:jed ,npz+1) )
      CALL INIT_IJK_MEM(isd, ied, jsd, jed, npz + 1, gz, huge_r)
!allocate(   pkc(isd:ied, jsd:jed ,npz+1) )
!allocate(   ptc(isd:ied, jsd:jed ,npz ) )
!allocate( crx(is :ie+1, jsd:jed,  npz) )
!allocate( xfx(is :ie+1, jsd:jed,  npz) )
!allocate( cry(isd:ied,  js :je+1, npz) )
!allocate( yfx(isd:ied,  js :je+1, npz) )
!allocate( divgd(isd:ied+1,jsd:jed+1,npz) )
!allocate( delpc(isd:ied, jsd:jed  ,npz  ) )
!                    call init_ijk_mem(isd,ied, jsd,jed, npz, delpc, 0._FVPRC)
!allocate( ut(isd:ied, jsd:jed, npz) )
!                    call init_ijk_mem(isd,ied, jsd,jed, npz, ut, 0._FVPRC)
!allocate( vt(isd:ied, jsd:jed, npz) )
!                    call init_ijk_mem(isd,ied, jsd,jed, npz, vt, 0._FVPRC)
      IF (.NOT.hydrostatic) CALL INIT_IJK_MEM(isd, ied, jsd, jed, npz + &
&                                       1, pk3, huge_r)
!allocate( zh(isd:ied, jsd:jed, npz+1) )
!              call init_ijk_mem(isd,ied, jsd,jed, npz+1, zh, huge_r )
!allocate ( pk3(isd:ied,jsd:jed,npz+1) )
      IF (beta .GT. near0) THEN
!allocate( du(isd:ied,  jsd:jed+1,npz) )
        CALL INIT_IJK_MEM(isd, ied, jsd, jed + 1, npz, du, 0._FVPRC)
!allocate( dv(isd:ied+1,jsd:jed,  npz) )
        CALL INIT_IJK_MEM(isd, ied + 1, jsd, jed, npz, dv, 0._FVPRC)
      END IF
    END IF
! Empty the "flux capacitors"
    CALL INIT_IJK_MEM(is, ie + 1, js, je, npz, mfx, 0._FVPRC)
    CALL INIT_IJK_MEM(is, ie, js, je + 1, npz, mfy, 0._FVPRC)
    CALL INIT_IJK_MEM(is, ie + 1, jsd, jed, npz, cx, 0._FVPRC)
    CALL INIT_IJK_MEM(isd, ied, js, je + 1, npz, cy, 0._FVPRC)
    IF (flagstruct%d_con .GT. 1.0e-5) THEN
!allocate( heat_source(isd:ied, jsd:jed, npz) )
      heat_source = 0.0
      CALL INIT_IJK_MEM(isd, ied, jsd, jed, npz, heat_source, 0._FVPRC)
    END IF
    IF (flagstruct%convert_ke .OR. flagstruct%vtdm4 .GT. 1.e-3) THEN
      n_con = npz
    ELSE IF (flagstruct%d2_bg_k1 .LT. 1.e-3) THEN
      n_con = 0
    ELSE IF (flagstruct%d2_bg_k2 .LT. 1.e-3) THEN
      n_con = 1
    ELSE
      n_con = 2
    END IF
    IF (gridstruct%nested) split_timestep_bc = REAL(n_split*flagstruct%&
&       k_split + neststruct%nest_timestep)
!-----------------------------------------------------
    DO it=1,n_split
!-----------------------------------------------------
!#ifdef ROT3
!     call start_group_halo_update(i_pack(8), i_pack(8+12), u, v, domain, gridtype=DGRID_NE)
!#endif
      IF (flagstruct%breed_vortex_inline .OR. it .EQ. n_split) THEN
        remap_step = .true.
      ELSE
        remap_step = .false.
      END IF
!     if ( flagstruct%fv_debug ) then
!          if(is_master()) write(*,*) 'n_split loop, it=', it
!          if ( .not. flagstruct%hydrostatic )    &
!          call prt_mxm('delz',  delz, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!     endif
      IF (nq .GT. 0) THEN
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
!if (fv_timing_onoff) call timing_on('COMM_TRACER')
        IF (flagstruct%inline_q) THEN
          CALL START_GROUP_HALO_UPDATE(i_pack(10), i_pack(10+12), q, &
&                                domain)
        ELSE IF (it .EQ. n_split) THEN
          CALL START_GROUP_HALO_UPDATE(i_pack(10), i_pack(10+12), q, &
&                                domain)
        END IF
      END IF
!if (fv_timing_onoff) call timing_off('COMM_TRACER')
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
      IF (.NOT.hydrostatic) THEN
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
        CALL START_GROUP_HALO_UPDATE(i_pack(7), i_pack(7+12), w, domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
        IF (it .EQ. 1) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,gz,zs,delz)
          DO j=js,je
            DO i=is,ie
              gz(i, j, npz+1) = zs(i, j)
            END DO
            DO k=npz,1,-1
              DO i=is,ie
                gz(i, j, k) = gz(i, j, k+1) - delz(i, j, k)
              END DO
            END DO
          END DO
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
          CALL START_GROUP_HALO_UPDATE(i_pack(5), i_pack(5+12), gz, &
&                                domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
        END IF
      END IF
!#ifdef SW_DYNAMICS
!     if (test_case>1) then
!     if (test_case==9) call case9_forcing1(phis, time_total)
!#endif
      IF (it .EQ. 1) THEN
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
        CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(1), i_pack(1+12), domain)
        CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(2), i_pack(2+12), domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
        beta_d = 0.
      ELSE
        beta_d = beta
      END IF
      IF (it .EQ. n_split .AND. end_step) THEN
        IF (flagstruct%use_old_omega) THEN
!allocate ( pem(is-1:ie+1,npz+1,js-1:je+1) )
          pem = 0.0
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pem,delp,ptop)
          DO j=js-1,je+1
            DO i=is-1,ie+1
              pem(i, 1, j) = ptop
            END DO
            DO k=1,npz
              DO i=is-1,ie+1
                pem(i, k+1, j) = pem(i, k, j) + delp(i, j, k)
              END DO
            END DO
          END DO
        END IF
        last_step = .true.
      ELSE
        last_step = .false.
      END IF
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
      CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(8), i_pack(8+12), domain)
      IF (.NOT.hydrostatic) CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(7), &
&                                                     i_pack(7+12), &
&                                                     domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!if (fv_timing_onoff) call timing_on('  c_sw')
!$OMP parallel do default(none) shared(npz,isd,jsd,delpc,delp,ptc,pt,u,v,w,uc,vc,ua,va, &
!$OMP                                  omga,ut,vt,divgd,flagstruct,dt2,hydrostatic,bd,  &
!$OMP                                  gridstruct)
      DO k=1,npz
        CALL C_SW(delpc(isd:ied, jsd:jed, k), delp(isd:ied, jsd:jed, k)&
&           , ptc(isd:ied, jsd:jed, k), pt(isd:ied, jsd:jed, k), u(isd:&
&           ied, jsd:jed+1, k), v(isd:ied+1, jsd:jed, k), w(isd:ied, jsd&
&           :jed, k), uc(isd:ied+1, jsd:jed, k), vc(isd:ied, jsd:jed+1, &
&           k), ua(isd:ied, jsd:jed, k), va(isd:ied, jsd:jed, k), omga(&
&           isd:ied, jsd:jed, k), ut(isd:ied, jsd:jed, k), vt(isd:ied, &
&           jsd:jed, k), divgd(isd:ied+1, jsd:jed+1, k), flagstruct%nord&
&           , dt2, hydrostatic, .true., bd, gridstruct, flagstruct)
      END DO
!if (fv_timing_onoff) call timing_off('  c_sw')
      IF (flagstruct%nord .GT. 0) CALL START_GROUP_HALO_UPDATE(i_pack(3)&
&                                                        , i_pack(3+12)&
&                                                        , divgd, domain&
&                                                        , position=&
&                                                        corner)
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
! end hydro check
      IF (hydrostatic) THEN
        CALL GEOPK(ptop, pe, peln, delpc, pkc, gz, phis, ptc, q_con, pkz&
&            , npz, akap, .true., gridstruct%nested, .false., npx, npy, &
&            flagstruct%a2b_ord, bd)
      ELSE
        IF (it .EQ. 1) THEN
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
          CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(5), i_pack(5+12), &
&                                   domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!$OMP parallel do default(none) shared(isd,ied,jsd,jed,npz,zh,gz)
          DO k=1,npz+1
            DO j=jsd,jed
              DO i=isd,ied
! Save edge heights for update_dz_d
                zh(i, j, k) = gz(i, j, k)
              END DO
            END DO
          END DO
        ELSE
!$OMP parallel do default(none) shared(isd,ied,jsd,jed,npz,zh,gz)
          DO k=1,npz+1
            DO j=jsd,jed
              DO i=isd,ied
                gz(i, j, k) = zh(i, j, k)
              END DO
            END DO
          END DO
        END IF
!if (fv_timing_onoff) call timing_on('  UPDATE_DZ_C')
        CALL UPDATE_DZ_C(is, ie, js, je, npz, ng, dt2, dp_ref, zs, &
&                  gridstruct%area, ut, vt, gz, ws3, npx, npy, &
&                  gridstruct%sw_corner, gridstruct%se_corner, &
&                  gridstruct%ne_corner, gridstruct%nw_corner, bd, &
&                  gridstruct%grid_type)
!if (fv_timing_onoff) call timing_off('  UPDATE_DZ_C')
!if (fv_timing_onoff) call timing_on('  Riem_Solver')
        CALL RIEM_SOLVER_C(ms, dt2, is, ie, js, je, npz, ng, akap, cappa&
&                    , cp, ptop, phis, omga, ptc, q_con, delpc, gz, pkc&
&                    , ws3, flagstruct%p_fac, flagstruct%a_imp, &
&                    flagstruct%scale_z)
!if (fv_timing_onoff) call timing_off('  Riem_Solver')
!#ifndef SW_DYNAMICS
!           if (gridstruct%nested) then
!                 call nested_grid_BC_apply_intT(delpc, &
!                      0, 0, npx, npy, npz, bd, split_timestep_BC+0.5, split, &
!                      var_east_t0=neststruct%delp_BC%east_t0, &
!                      var_west_t0=neststruct%delp_BC%west_t0, &
!                      var_north_t0=neststruct%delp_BC%north_t0, &
!                      var_south_t0=neststruct%delp_BC%south_t0, &
!                      var_east_t1=neststruct%delp_BC%east_t1, &
!                      var_west_t1=neststruct%delp_BC%west_t1, &
!                      var_north_t1=neststruct%delp_BC%north_t1, &
!                      var_south_t1=neststruct%delp_BC%south_t1, &
!                      bctype=neststruct%nestbctype, &
!                      nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!                 call nested_grid_BC_apply_intT(ptc, &
!                      0, 0, npx, npy, npz, bd, split_timestep_BC+0.5, split, &
!                      var_east_t0=neststruct%pt_BC%east_t0, &
!                      var_west_t0=neststruct%pt_BC%west_t0, &
!                      var_north_t0=neststruct%pt_BC%north_t0, &
!                      var_south_t0=neststruct%pt_BC%south_t0, &
!                      var_east_t1=neststruct%pt_BC%east_t1, &
!                      var_west_t1=neststruct%pt_BC%west_t1, &
!                      var_north_t1=neststruct%pt_BC%north_t1, &
!                      var_south_t1=neststruct%pt_BC%south_t1, &
!                      bctype=neststruct%nestbctype, &
!                      nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!                 call nested_grid_BC_apply_intT(delz, &
!                      0, 0, npx, npy, npz, bd, split_timestep_BC+0.5, split, &
!                      var_east_t0=neststruct%delz_BC%east_t0, &
!                      var_west_t0=neststruct%delz_BC%west_t0, &
!                      var_north_t0=neststruct%delz_BC%north_t0, &
!                      var_south_t0=neststruct%delz_BC%south_t0, &
!                      var_east_t1=neststruct%delz_BC%east_t1, &
!                      var_west_t1=neststruct%delz_BC%west_t1, &
!                      var_north_t1=neststruct%delz_BC%north_t1, &
!                      var_south_t1=neststruct%delz_BC%south_t1, &
!                      bctype=neststruct%nestbctype, &
!                      nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!!!$         do k=1,npz
!!!$            call extrapolation_BC( delz(:,:,k), 0, 0, npx, npy, bd)
!!!$            call extrapolation_BC(delpc(:,:,k), 0, 0, npx, npy, bd)
!!!$            call extrapolation_BC(  ptc(:,:,k), 0, 0, npx, npy, bd)
!!!$         end do
!
!
!              !Compute gz/pkc
!              !NOTE: nominally only need to compute quantities one out in the halo for p_grad_c
!              !(instead of entire halo)
!              call geopk_halo_nh(ptop, grav, akap, cp, delpc, delz, ptc, phis, pkc, gz, pk3, &
!                   npx, npy, npz, gridstruct%nested, .false., .false., .false., bd)
!
!           endif
!#endif
      END IF
      CALL P_GRAD_C(dt2, npz, delpc, pkc, gz, uc, vc, bd, gridstruct%&
&             rdxc, gridstruct%rdyc, hydrostatic)
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
      CALL START_GROUP_HALO_UPDATE(i_pack(9), i_pack(9+12), uc, vc, &
&                            domain, gridtype=cgrid_ne)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!#ifdef SW_DYNAMICS
!      if (test_case==9) call case9_forcing2(phis)
!      endif !test_case>1
!#endif
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
      IF (flagstruct%inline_q .AND. nq .GT. 0) CALL &
&       COMPLETE_GROUP_HALO_UPDATE(i_pack(10), i_pack(10+12), domain)
      IF (flagstruct%nord .GT. 0) CALL COMPLETE_GROUP_HALO_UPDATE(i_pack&
&                                                           (3), i_pack(&
&                                                           3+12), &
&                                                           domain)
      CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(9), i_pack(9+12), domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!      if (gridstruct%nested) then
!         !On a nested grid we have to do SOMETHING with uc and vc in
!         ! the boundary halo, particularly at the corners of the
!         ! domain and of each processor element. We must either
!         ! apply an interpolated BC, or extrapolate into the
!         ! boundary halo
!         ! NOTE: 
!         !The update_domains calls for uc and vc need to go BEFORE the BCs to ensure cross-restart
!         !bitwise-consistent solutions when doing the spatial extrapolation; should not make a
!         !difference for interpolated BCs from the coarse grid.
!
!
!!!$         do k=1,npz
!!!$            call extrapolation_BC(uc(:,:,k), 1, 0, npx, npy, bd)
!!!$            call extrapolation_BC(vc(:,:,k), 0, 1, npx, npy, bd)
!!!$         end do
!!!$
!
!
!         !vc
!            call nested_grid_BC_apply_intT(vc, &
!                 0, 1, npx, npy, npz, bd, split_timestep_bc+0.5, split, & 
!                 var_east_t0=neststruct%vc_BC%east_t0, &
!                 var_west_t0=neststruct%vc_BC%west_t0, &
!                 var_north_t0=neststruct%vc_BC%north_t0, &
!                 var_south_t0=neststruct%vc_BC%south_t0, &
!                 var_east_t1=neststruct%vc_BC%east_t1, &
!                 var_west_t1=neststruct%vc_BC%west_t1, &
!                 var_north_t1=neststruct%vc_BC%north_t1, &
!                 var_south_t1=neststruct%vc_BC%south_t1, &
!                 bctype=neststruct%nestbctype, &
!                 nsponge=neststruct%nsponge, s_weight=neststruct%s_weight  )
!
!            !uc
!            call nested_grid_BC_apply_intT(uc, &
!                 1, 0, npx, npy, npz, bd, split_timestep_bc+0.5, split, &
!                 var_east_t0=neststruct%uc_BC%east_t0, &
!                 var_west_t0=neststruct%uc_BC%west_t0, &
!                 var_north_t0=neststruct%uc_BC%north_t0, &
!                 var_south_t0=neststruct%uc_BC%south_t0, &
!                 var_east_t1=neststruct%uc_BC%east_t1, &
!                 var_west_t1=neststruct%uc_BC%west_t1, &
!                 var_north_t1=neststruct%uc_BC%north_t1, &
!                 var_south_t1=neststruct%uc_BC%south_t1, &
!                 bctype=neststruct%nestbctype, &
!                 nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!      end if
!    if ( flagstruct%inline_q ) then
!         if (gridstruct%nested) then
!            do iq=1,nq
!                  call nested_grid_BC_apply_intT(q(isd:ied,jsd:jed,:,iq), &
!                       0, 0, npx, npy, npz, bd, split_timestep_BC+1, split, &
!                       var_east_t0=neststruct%q_BC(iq)%east_t0, &
!                       var_west_t0=neststruct%q_BC(iq)%west_t0, &
!                       var_north_t0=neststruct%q_BC(iq)%north_t0, &
!                       var_south_t0=neststruct%q_BC(iq)%south_t0, &
!                       var_east_t1=neststruct%q_BC(iq)%east_t1, &
!                       var_west_t1=neststruct%q_BC(iq)%west_t1, &
!                       var_north_t1=neststruct%q_BC(iq)%north_t1, &
!                       var_south_t1=neststruct%q_BC(iq)%south_t1, &
!                       bctype=neststruct%nestbctype, &
!                       nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!            end do
!         end if
!      endif
!if (fv_timing_onoff) call timing_on('  d_sw')
!$OMP parallel do default(none) shared(npz,flagstruct,nord_v,pfull,damp_vt,hydrostatic,last_step, &
!$OMP                                  is,ie,js,je,isd,ied,jsd,jed,omga,delp,gridstruct,npx,npy,  &
!$OMP                                  ng,zh,vt,ptc,pt,u,v,w,uc,vc,ua,va,divgd,mfx,mfy,cx,cy,     &
!$OMP                                  crx,cry,xfx,yfx,q_con,zvir,sphum,nq,q,dt,bd,rdt,iep1,jep1, &
!$OMP                                  heat_source)                                               &
!$OMP                          private(nord_k, nord_w, nord_t, damp_k, damp_w, damp_t, d2_divg,   &
!$OMP                                  hord_m, hord_v, hord_t, hord_p, wk, heat_s, d_con_k, z_rat)
      DO k=1,npz
        hord_m = flagstruct%hord_mt
        hord_t = flagstruct%hord_tm
        hord_v = flagstruct%hord_vt
        hord_p = flagstruct%hord_dp
        hord_m_pert = flagstruct%hord_mt_pert
        hord_t_pert = flagstruct%hord_tm_pert
        hord_v_pert = flagstruct%hord_vt_pert
        hord_p_pert = flagstruct%hord_dp_pert
        nord_k = flagstruct%nord
        nord_k_pert = flagstruct%nord_pert
        IF (2 .GT. flagstruct%nord) THEN
          nord_v(k) = flagstruct%nord
        ELSE
          nord_v(k) = 2
        END IF
        IF (2 .GT. flagstruct%nord_pert) THEN
          nord_v_pert(k) = flagstruct%nord_pert
        ELSE
          nord_v_pert(k) = 2
        END IF
        damp_k = flagstruct%dddmp
        damp_k_pert = flagstruct%dddmp_pert
        arg1 = pfull(k)/pfull(npz)
        arg2 = 0.1*LOG(arg1)
        y1 = flagstruct%d2_bg*(1.-3.*TANH(arg2))
        IF (0.20 .GT. y1) THEN
          d2_divg = y1
        ELSE
          d2_divg = 0.20
        END IF
        arg1 = pfull(k)/pfull(npz)
        arg2 = 0.1*LOG(arg1)
        y2 = flagstruct%d2_bg_pert*(1.-3.*TANH(arg2))
        IF (0.20 .GT. y2) THEN
          d2_divg_pert = y2
        ELSE
          d2_divg_pert = 0.20
        END IF
        d_con_k = flagstruct%d_con
        d_con_k_pert = flagstruct%d_con_pert
        IF (flagstruct%do_vort_damp) THEN
! for delp, delz, and vorticity
          damp_vt(k) = flagstruct%vtdm4
        ELSE
          damp_vt(k) = 0.
        END IF
        IF (flagstruct%do_vort_damp_pert) THEN
! for delp, delz, and vorticity
          damp_vt_pert(k) = flagstruct%vtdm4_pert
        ELSE
          damp_vt_pert(k) = 0.
        END IF
        nord_w = nord_v(k)
        nord_w_pert = nord_v_pert(k)
        nord_t = nord_v(k)
        nord_t_pert = nord_v_pert(k)
        damp_w = damp_vt(k)
        damp_w_pert = damp_vt_pert(k)
        damp_t = damp_vt(k)
        damp_t_pert = damp_vt_pert(k)
        IF (npz .EQ. 1 .OR. flagstruct%n_sponge .LT. 0) THEN
          d2_divg = flagstruct%d2_bg
          d2_divg_pert = flagstruct%d2_bg_pert
        ELSE IF (flagstruct%n_sponge .EQ. 0) THEN
! New Del-2 Sponge layer: formulation
! Sponge layers with del-2 damping on divergence, vorticity, w, z, and air mass (delp).
! (no damping of potential temperature in sponge layers)
          IF (k .EQ. 1) THEN
            damp_k = 0.
            damp_k_pert = 0.
            nord_k = 0
            nord_k_pert = 0
            IF (flagstruct%d2_bg .LT. flagstruct%d2_bg_k1) THEN
              d2_divg = flagstruct%d2_bg_k1
            ELSE
              d2_divg = flagstruct%d2_bg
            END IF
            IF (flagstruct%d2_bg_pert .LT. flagstruct%d2_bg_k1) THEN
              d2_divg_pert = flagstruct%d2_bg_k1
            ELSE
              d2_divg_pert = flagstruct%d2_bg_pert
            END IF
! for delp, delz, and vorticity, sponger layers
            nord_v(k) = 0
! for delp, delz, and vorticity, sponger layers
            nord_v_pert(k) = 0
!#ifndef HIWPP
            damp_vt(k) = d2_divg
            damp_vt_pert(k) = d2_divg_pert
!#endif
            nord_w = 0
            nord_w_pert = 0
            damp_w = d2_divg
            damp_w_pert = d2_divg_pert
          ELSE IF (k .EQ. 2) THEN
            damp_k = 0.
            damp_k_pert = 0.
            nord_k = 0
            nord_k_pert = 0
            IF (flagstruct%d2_bg .LT. flagstruct%d2_bg_k2) THEN
              d2_divg = flagstruct%d2_bg_k2
            ELSE
              d2_divg = flagstruct%d2_bg
            END IF
            IF (flagstruct%d2_bg_pert .LT. flagstruct%d2_bg_k2) THEN
              d2_divg_pert = flagstruct%d2_bg_k2
            ELSE
              d2_divg_pert = flagstruct%d2_bg_pert
            END IF
            nord_v(k) = 0
            nord_v_pert(k) = 0
!#ifndef HIWPP
            damp_vt(k) = d2_divg
            damp_vt_pert(k) = d2_divg_pert
!#endif
            nord_w = 0
            nord_w_pert = 0
            damp_w = d2_divg
            damp_w_pert = d2_divg_pert
          ELSE IF (k .EQ. 3 .AND. flagstruct%d2_bg_k2 .GT. 0.05) THEN
            damp_k = 0.
            damp_k_pert = 0.
            nord_k = 0
            nord_k_pert = 0
            IF (flagstruct%d2_bg .LT. 0.2*flagstruct%d2_bg_k2) THEN
              d2_divg = 0.2*flagstruct%d2_bg_k2
            ELSE
              d2_divg = flagstruct%d2_bg
            END IF
            IF (flagstruct%d2_bg_pert .LT. 0.2*flagstruct%d2_bg_k2) THEN
              d2_divg_pert = 0.2*flagstruct%d2_bg_k2
            ELSE
              d2_divg_pert = flagstruct%d2_bg_pert
            END IF
            nord_v(k) = 0
            nord_v_pert(k) = 0
!#ifndef HIWPP
            damp_vt(k) = d2_divg
            damp_vt_pert(k) = d2_divg_pert
!#endif
            nord_w = 0
            nord_w_pert = 0
            damp_w = d2_divg
            damp_w_pert = d2_divg_pert
          END IF
          IF (damp_vt(k) .LT. 0.01 .AND. nord_k .GT. 0) d_con_k = 0.
          IF (damp_vt_pert(k) .LT. 0.01 .AND. nord_k_pert .GT. 0) &
&           d_con_k_pert = 0.
        ELSE IF (k .LE. flagstruct%n_sponge .AND. npz .GT. 16) THEN
! Apply first order scheme for damping the sponge layer
          hord_m = 1
          hord_m_pert = 1
          hord_v = 1
          hord_v_pert = 1
          hord_t = 1
          hord_t_pert = 1
          hord_p = 1
          hord_p_pert = 1
          nord_k = 0
          nord_k_pert = 0
          damp_k = flagstruct%damp_k_k1
          damp_k_pert = flagstruct%damp_k_k1
          IF (0.20 .GT. flagstruct%d2_bg_k1*flagstruct%d2_bg) THEN
            d2_divg = flagstruct%d2_bg_k1*flagstruct%d2_bg
          ELSE
            d2_divg = 0.20
          END IF
          IF (0.20 .GT. flagstruct%d2_bg_k1*flagstruct%d2_bg_pert) THEN
            d2_divg_pert = flagstruct%d2_bg_k1*flagstruct%d2_bg_pert
          ELSE
            d2_divg_pert = 0.20
          END IF
          IF (flagstruct%d2_divg_max_k1 .LT. d2_divg) THEN
            d2_divg = d2_divg
          ELSE
            d2_divg = flagstruct%d2_divg_max_k1
          END IF
          IF (flagstruct%d2_divg_max_k1 .LT. d2_divg_pert) THEN
            d2_divg_pert = d2_divg_pert
          ELSE
            d2_divg_pert = flagstruct%d2_divg_max_k1
          END IF
        ELSE IF (k .EQ. flagstruct%n_sponge + 1 .AND. npz .GT. 24) THEN
          hord_v = 2
          hord_v_pert = 1
          hord_t = 2
          hord_t_pert = 1
          hord_p = 2
          hord_p_pert = 1
          IF (0 .LT. flagstruct%nord - 1) THEN
            nord_k = flagstruct%nord - 1
          ELSE
            nord_k = 0
          END IF
          IF (0 .LT. flagstruct%nord_pert - 1) THEN
            nord_k_pert = flagstruct%nord_pert - 1
          ELSE
            nord_k_pert = 0
          END IF
          IF (0.20 .GT. flagstruct%d2_bg_k2*flagstruct%d2_bg) THEN
            d2_divg = flagstruct%d2_bg_k2*flagstruct%d2_bg
          ELSE
            d2_divg = 0.20
          END IF
          IF (0.20 .GT. flagstruct%d2_bg_k2*flagstruct%d2_bg_pert) THEN
            d2_divg_pert = flagstruct%d2_bg_k2*flagstruct%d2_bg_pert
          ELSE
            d2_divg_pert = 0.20
          END IF
          IF (flagstruct%d2_divg_max_k2 .LT. d2_divg) THEN
            d2_divg = d2_divg
          ELSE
            d2_divg = flagstruct%d2_divg_max_k2
          END IF
          IF (flagstruct%d2_divg_max_k2 .LT. d2_divg_pert) THEN
            d2_divg_pert = d2_divg_pert
          ELSE
            d2_divg_pert = flagstruct%d2_divg_max_k2
          END IF
          IF (flagstruct%nord .GT. 1) THEN
            damp_k = 0.
          ELSE
            damp_k = flagstruct%damp_k_k2
          END IF
          IF (flagstruct%nord_pert .GT. 1) THEN
            damp_k_pert = 0.
          ELSE
            damp_k_pert = flagstruct%damp_k_k2
          END IF
        END IF
        IF (damp_k .LT. flagstruct%dddmp) THEN
          damp_k = flagstruct%dddmp
        ELSE
          damp_k = damp_k
        END IF
        IF (damp_k_pert .LT. flagstruct%dddmp_pert) THEN
          damp_k_pert = flagstruct%dddmp_pert
        ELSE
          damp_k_pert = damp_k_pert
        END IF
        IF (hydrostatic .AND. (.NOT.flagstruct%use_old_omega) .AND. &
&           last_step) THEN
! Average horizontal "convergence" to cell center
          DO j=js,je
            DO i=is,ie
              omga(i, j, k) = delp(i, j, k)
            END DO
          END DO
        END IF
!--- external mode divergence damping ---
        IF (flagstruct%d_ext .GT. 0.) CALL A2B_ORD2(delp(isd, jsd, k), &
&                                             wk, gridstruct, npx, npy, &
&                                             is, ie, js, je, ng, &
&                                             .false.)
        IF (.NOT.hydrostatic .AND. flagstruct%do_f3d) THEN
! Correction factor for 3D Coriolis force
          DO j=jsd,jed
            DO i=isd,ied
              z_rat(i, j) = 1. + (zh(i, j, k)+zh(i, j, k+1))/radius
            END DO
          END DO
        END IF
        CALL D_SW(vt(isd:ied, jsd:jed, k), vt_tj(isd:ied, jsd:jed, k), &
&           delp(isd:ied, jsd:jed, k), ptc(isd:ied, jsd:jed, k), pt(isd:&
&           ied, jsd:jed, k), u(isd:ied, jsd:jed+1, k), v(isd:ied+1, jsd&
&           :jed, k), w(isd:ied, jsd:jed, k), uc(isd:ied+1, jsd:jed, k)&
&           , vc(isd:ied, jsd:jed+1, k), ua(isd:ied, jsd:jed, k), va(isd&
&           :ied, jsd:jed, k), divgd(isd:ied+1, jsd:jed+1, k), mfx(is:ie&
&           +1, js:je, k), mfy(is:ie, js:je+1, k), cx(is:ie+1, jsd:jed, &
&           k), cy(isd:ied, js:je+1, k), crx(is:ie+1, jsd:jed, k), cry(&
&           isd:ied, js:je+1, k), xfx(is:ie+1, jsd:jed, k), yfx(isd:ied&
&           , js:je+1, k), q_con(isd:isd, jsd:jsd, 1), z_rat(isd:ied, &
&           jsd:jed), heat_s, zvir, sphum, nq, q, k, npz, flagstruct%&
&           inline_q, dt, flagstruct%hord_tr, hord_m, hord_v, hord_t, &
&           hord_p, flagstruct%hord_tr_pert, hord_m_pert, hord_v_pert, &
&           hord_t_pert, hord_p_pert, nord_k, nord_v(k), nord_w, nord_t&
&           , damp_k, d2_divg, flagstruct%d4_bg, damp_vt(k), damp_w, &
&           damp_t, d_con_k, flagstruct%split_damp, nord_k_pert, &
&           nord_v_pert(k), nord_w_pert, nord_t_pert, damp_k_pert, &
&           d2_divg_pert, flagstruct%d4_bg_pert, damp_vt_pert(k), &
&           damp_w_pert, damp_t_pert, d_con_k_pert, hydrostatic, &
&           gridstruct, flagstruct, bd)
        IF (hydrostatic .AND. (.NOT.flagstruct%use_old_omega) .AND. &
&           last_step) THEN
! Average horizontal "convergence" to cell center
          DO j=js,je
            DO i=is,ie
              omga(i, j, k) = omga(i, j, k)*(xfx(i, j, k)-xfx(i+1, j, k)&
&               +yfx(i, j, k)-yfx(i, j+1, k))*gridstruct%rarea(i, j)*rdt
            END DO
          END DO
        END IF
        IF (flagstruct%d_ext .GT. 0.) THEN
          DO j=js,jep1
            DO i=is,iep1
! delp at cell corners
              ptc(i, j, k) = wk(i, j)
            END DO
          END DO
        END IF
        IF (d_con_k .GT. 1.0e-5) THEN
! Average horizontal "convergence" to cell center
          DO j=js,je
            DO i=is,ie
              heat_source(i, j, k) = heat_source(i, j, k) + heat_s(i, j)
            END DO
          END DO
        END IF
      END DO
! end openMP k-loop
!if (fv_timing_onoff) call timing_off('  d_sw')
      IF (flagstruct%fill_dp) CALL MIX_DP(hydrostatic, w, delp, pt, npz&
&                                   , ak, bk, .false., flagstruct%&
&                                   fv_debug, bd)
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
      CALL START_GROUP_HALO_UPDATE(i_pack(1), i_pack(1+12), delp, domain&
&                           )
      CALL START_GROUP_HALO_UPDATE(i_pack(2), i_pack(2+12), pt, domain)
!#ifdef USE_COND
!    call start_group_halo_update(i_pack(11), i_pack(11+12), q_con, domain)
!#endif
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
      IF (flagstruct%d_ext .GT. 0.) THEN
        d2_divg = flagstruct%d_ext*gridstruct%da_min_c
!$OMP parallel do default(none) shared(is,iep1,js,jep1,npz,wk,ptc,divg2,vt,d2_divg)
!!$AD II-LOOP
        DO j=js,jep1
          DO i=is,iep1
            wk(i, j) = ptc(i, j, 1)
            divg2(i, j) = wk(i, j)*vt(i, j, 1)
          END DO
          DO k=2,npz
            DO i=is,iep1
              wk(i, j) = wk(i, j) + ptc(i, j, k)
              divg2(i, j) = divg2(i, j) + ptc(i, j, k)*vt(i, j, k)
            END DO
          END DO
          DO i=is,iep1
            divg2(i, j) = d2_divg*divg2(i, j)/wk(i, j)
          END DO
        END DO
      ELSE
        divg2(:, :) = 0.
      END IF
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
      CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(1), i_pack(1+12), domain)
      CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(2), i_pack(2+12), domain)
! end hydro check
!#ifdef USE_COND
!     call complete_group_halo_update(i_pack(11), i_pack(11+12), domain)
!#endif
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!    if ( flagstruct%fv_debug ) then
!         if ( .not. flagstruct%hydrostatic )    &
!         call prt_mxm('delz',  delz, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!    endif
      IF (hydrostatic) THEN
        CALL GEOPK(ptop, pe, peln, delp, pkc, gz, phis, pt, q_con, pkz, &
&            npz, akap, .false., gridstruct%nested, .true., npx, npy, &
&            flagstruct%a2b_ord, bd)
!Want to move this block into the hydro/nonhydro branch above and merge the two if structures
!          if (gridstruct%nested) then
!
!             call nested_grid_BC_apply_intT(delp, &
!                  0, 0, npx, npy, npz, bd, split_timestep_BC+1, split, &
!                  var_east_t0=neststruct%delp_BC%east_t0, &
!                  var_west_t0=neststruct%delp_BC%west_t0, &
!                  var_north_t0=neststruct%delp_BC%north_t0, &
!                  var_south_t0=neststruct%delp_BC%south_t0, &
!                  var_east_t1=neststruct%delp_BC%east_t1, &
!                  var_west_t1=neststruct%delp_BC%west_t1, &
!                  var_north_t1=neststruct%delp_BC%north_t1, &
!                  var_south_t1=neststruct%delp_BC%south_t1, &
!                  bctype=neststruct%nestbctype, &
!                  nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!!#ifndef SW_DYNAMICS
!
!             call nested_grid_BC_apply_intT(pt, &
!                  0, 0, npx, npy, npz, bd, split_timestep_BC+1, split, &
!                  var_east_t0=neststruct%pt_BC%east_t0, &
!                  var_west_t0=neststruct%pt_BC%west_t0, &
!                  var_north_t0=neststruct%pt_BC%north_t0, &
!                  var_south_t0=neststruct%pt_BC%south_t0, &
!                  var_east_t1=neststruct%pt_BC%east_t1, &
!                  var_west_t1=neststruct%pt_BC%west_t1, &
!                  var_north_t1=neststruct%pt_BC%north_t1, &
!                  var_south_t1=neststruct%pt_BC%south_t1, &
!                  bctype=neststruct%nestbctype, &
!                  nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!!#endif
!          end if
      ELSE
!if (fv_timing_onoff) call timing_on('  UPDATE_DZ')
        CALL UPDATE_DZ_D(nord_v, damp_vt, flagstruct%hord_tm, flagstruct&
&                  %hord_tm_pert, is, ie, js, je, npz, ng, npx, npy, &
&                  gridstruct%area, gridstruct%rarea, dp_ref, zs, zh, &
&                  crx, cry, xfx, yfx, ws, rdt, gridstruct, bd)
!           call prt_maxmin('WS', ws, is, ie, js, je, 0, 1, 1._FVPRC, master)
!            used=send_data(idiag%id_ws, ws, fv_time)
!Want to move this block into the hydro/nonhydro branch above and merge the two if structures
!        if (gridstruct%nested) then
!
!           call nested_grid_BC_apply_intT(delp, &
!                0, 0, npx, npy, npz, bd, split_timestep_BC+1, split, &
!                var_east_t0=neststruct%delp_BC%east_t0, &
!                var_west_t0=neststruct%delp_BC%west_t0, &
!                var_north_t0=neststruct%delp_BC%north_t0, &
!                var_south_t0=neststruct%delp_BC%south_t0, &
!                var_east_t1=neststruct%delp_BC%east_t1, &
!                var_west_t1=neststruct%delp_BC%west_t1, &
!                var_north_t1=neststruct%delp_BC%north_t1, &
!                var_south_t1=neststruct%delp_BC%south_t1, &
!                bctype=neststruct%nestbctype, &
!                nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!!#ifndef SW_DYNAMICS
!
!           call nested_grid_BC_apply_intT(pt, &
!                0, 0, npx, npy, npz, bd, split_timestep_BC+1, split, &
!                var_east_t0=neststruct%pt_BC%east_t0, &
!                var_west_t0=neststruct%pt_BC%west_t0, &
!                var_north_t0=neststruct%pt_BC%north_t0, &
!                var_south_t0=neststruct%pt_BC%south_t0, &
!                var_east_t1=neststruct%pt_BC%east_t1, &
!                var_west_t1=neststruct%pt_BC%west_t1, &
!                var_north_t1=neststruct%pt_BC%north_t1, &
!                var_south_t1=neststruct%pt_BC%south_t1, &
!                bctype=neststruct%nestbctype, &
!                nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!!#endif
!
!        end if
!if (fv_timing_onoff) call timing_on('  Riem_Solver')
        CALL RIEM_SOLVER3(flagstruct%m_split, dt, is, ie, js, je, npz, &
&                   ng, isd, ied, jsd, jed, akap, cappa, cp, ptop, zs, &
&                   q_con, w, delz, pt, delp, zh, pe, pkc, pk3, pk, peln&
&                   , ws, flagstruct%scale_z, flagstruct%p_fac, &
&                   flagstruct%a_imp, flagstruct%use_logp, remap_step, &
&                   beta .LT. -0.1)
!if (fv_timing_onoff) call timing_off('  Riem_Solver')
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
        CALL START_GROUP_HALO_UPDATE(i_pack(4), i_pack(4+12), zh, domain&
&                             )
        IF (gridstruct%square_domain) THEN
          CALL START_GROUP_HALO_UPDATE(i_pack(6), i_pack(6+12), pkc, &
&                                domain, whalo=2, ehalo=2, shalo=2, &
&                                nhalo=2)
        ELSE
          CALL START_GROUP_HALO_UPDATE(i_pack(6), i_pack(6+12), pkc, &
&                                domain)
        END IF
        IF (remap_step) CALL PE_HALO(is, ie, js, je, isd, ied, jsd, jed&
&                              , npz, ptop, pe, delp)
        IF (flagstruct%use_logp) THEN
          CALL PLN_HALO(is, ie, js, je, isd, ied, jsd, jed, npz, ptop, &
&                 pk3, delp)
        ELSE
          CALL PK3_HALO(is, ie, js, je, isd, ied, jsd, jed, npz, ptop, &
&                 akap, pk3, delp)
        END IF
        CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(4), i_pack(4+12), domain)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,gz,zh,grav)
        DO k=1,npz+1
          DO j=js-2,je+2
            DO i=is-2,ie+2
              gz(i, j, k) = zh(i, j, k)*grav
            END DO
          END DO
        END DO
        CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(6), i_pack(6+12), domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
      END IF
!#ifdef SW_DYNAMICS
!      if (test_case > 1) then
!#else
      IF (remap_step .AND. hydrostatic) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pk,pkc)
        DO k=1,npz+1
          DO j=js,je
            DO i=is,ie
              pk(i, j, k) = pkc(i, j, k)
            END DO
          END DO
        END DO
      END IF
!#endif
!----------------------------
! Compute pressure gradient:
!----------------------------
!if (fv_timing_onoff) call timing_on('  PG_D')
      IF (hydrostatic) THEN
        IF (beta .GT. 0.) THEN
          CALL GRAD1_P_UPDATE(divg2, u, v, du, dv, pkc, gz, dt, ng, &
&                       gridstruct, bd, npx, npy, npz, ptop, beta_d, &
&                       flagstruct%a2b_ord)
        ELSE
          CALL ONE_GRAD_P(u, v, pkc, gz, divg2, delp, dt, ng, gridstruct&
&                   , bd, npx, npy, npz, ptop, hydrostatic, flagstruct%&
&                   a2b_ord, flagstruct%d_ext)
        END IF
      ELSE IF (beta .GT. 0.) THEN
!#ifndef SW_DYNAMICS
!       if (gridstruct%nested) then
!           call nested_grid_BC_apply_intT(delz, &
!                    0, 0, npx, npy, npz, bd, split_timestep_BC+1., split, &
!                    var_east_t0=neststruct%delz_BC%east_t0, &
!                    var_west_t0=neststruct%delz_BC%west_t0, &
!                    var_north_t0=neststruct%delz_BC%north_t0, &
!                    var_south_t0=neststruct%delz_BC%south_t0, &
!                    var_east_t1=neststruct%delz_BC%east_t1, &
!                    var_west_t1=neststruct%delz_BC%west_t1, &
!                    var_north_t1=neststruct%delz_BC%north_t1, &
!                    var_south_t1=neststruct%delz_BC%south_t1, &
!                    bctype=neststruct%nestbctype, &
!                    nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!            !Compute gz/pkc/pk3; note that now pkc should be nonhydro pert'n pressure
!            call geopk_halo_nh(ptop, grav, akap, cp, delp, delz, pt, phis, pkc, &
!                               gz, pk3, npx, npy, npz, gridstruct%nested, .true., .true., .true., bd)
!
!       endif
!#endif
        CALL SPLIT_P_GRAD(u, v, du, dv, pkc, gz, delp, pk3, beta_d, dt, &
&                   ng, gridstruct, bd, npx, npy, npz, flagstruct%&
&                   use_logp)
      ELSE IF (beta .LT. -0.1) THEN
        CALL ONE_GRAD_P(u, v, pkc, gz, divg2, delp, dt, ng, gridstruct, &
&                 bd, npx, npy, npz, ptop, hydrostatic, flagstruct%&
&                 a2b_ord, flagstruct%d_ext)
      ELSE
        CALL NH_P_GRAD(u, v, pkc, gz, delp, pk3, dt, ng, gridstruct, bd&
&                , npx, npy, npz, flagstruct%use_logp)
      END IF
!#ifdef ROT3
!       if ( flagstruct%do_f3d ) then
!!$OMP parallel do default(none) shared(is,ie,js,je,npz,ua,gridstruct,w,va,isd,ied,jsd,jed)
!           do k=1,npz
!              do j=js,je
!                 do i=is,ie
!                    ua(i,j,k) = -gridstruct%w00(i,j)*w(i,j,k)
!                 enddo
!              enddo
!              do j=jsd,jed
!                 do i=isd,ied
!                    va(i,j,k) = 0.
!                 enddo
!              enddo
!           enddo
!           call mpp_update_domains(ua, domain, complete=.true.)
!           call update_dwinds_phys(is, ie, js, je, isd, ied, jsd, jed, dt, ua, va, u, v, gridstruct, npx, npy, npz, domain)
!       endif
!#endif
!if (fv_timing_onoff) call timing_off('  PG_D')
!-------------------------------------------------------------------------------------------------------
      IF (flagstruct%breed_vortex_inline) THEN
        IF (.NOT.hydrostatic) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pkz,cappa,kapag,delp,delz,pt,k1k)
          DO k=1,npz
            DO j=js,je
              DO i=is,ie
! Note: pt at this stage is cp*Theta_m
!#ifdef MOIST_CAPPA
!                    pkz(i,j,k) = exp(cappa(i,j,k)/(1.-cappa(i,j,k))*log(kapag*delp(i,j,k)/delz(i,j,k)*pt(i,j,k)) )
!#else
                arg1 = kapag*delp(i, j, k)/delz(i, j, k)*pt(i, j, k)
                arg2 = k1k*LOG(arg1)
                pkz(i, j, k) = EXP(arg2)
              END DO
            END DO
          END DO
        END IF
      END IF
!#endif
!#if defined (ADA_NUDGE)
!         call breed_slp_inline_ada( it, dt, npz, ak, bk, phis, pe, pk, peln, pkz,     &
!                                delp, u, v, pt, q, flagstruct%nwat, zvir, gridstruct, ks, domain, bd )
!#else
!call breed_slp_inline( it, dt, npz, ak, bk, phis, pe, pk, peln, pkz, delp, u, v, pt, q,    &
!                       flagstruct%nwat, zvir, gridstruct, ks, domain, bd, hydrostatic )
!#endif
!-------------------------------------------------------------------------------------------------------
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
      IF (it .EQ. n_split .AND. gridstruct%grid_type .LT. 4 .AND. (.NOT.&
&         gridstruct%nested)) THEN
! Prevent accumulation of rounding errors at overlapped domain edges:
        CALL MPP_GET_BOUNDARY(u, v, domain, wbuffery=wbuffer, ebuffery=&
&                       ebuffer, sbufferx=sbuffer, nbufferx=nbuffer, &
&                       gridtype=dgrid_ne)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,u,nbuffer,v,ebuffer)
        DO k=1,npz
          DO i=is,ie
            u(i, je+1, k) = nbuffer(i-is+1, k)
          END DO
          DO j=js,je
            v(ie+1, j, k) = ebuffer(j-js+1, k)
          END DO
        END DO
      END IF
!#ifndef ROT3
      IF (it .NE. n_split) CALL START_GROUP_HALO_UPDATE(i_pack(8), &
&                                                 i_pack(8+12), u, v, &
&                                                 domain, gridtype=&
&                                                 dgrid_ne)
!#endif
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!#ifdef SW_DYNAMICS
!    endif
!#endif
      IF (gridstruct%nested) neststruct%nest_timestep = neststruct%&
&         nest_timestep + 1
!#ifdef SW_DYNAMICS
!#else
      IF (hydrostatic .AND. last_step) THEN
        IF (flagstruct%use_old_omega) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,omga,pe,pem,rdt)
          DO k=1,npz
            DO j=js,je
              DO i=is,ie
                omga(i, j, k) = (pe(i, k+1, j)-pem(i, k+1, j))*rdt
              END DO
            END DO
          END DO
!------------------------------
! Compute the "advective term"
!------------------------------
          CALL ADV_PE(ua, va, pem, omga, gridstruct, bd, npx, npy, npz, &
&               ng)
        ELSE
!$OMP parallel do default(none) shared(is,ie,js,je,npz,omga) private(om2d)
!!$AD II-LOOP
          DO j=js,je
            DO k=1,npz
              DO i=is,ie
                om2d(i, k) = omga(i, j, k)
              END DO
            END DO
            DO k=2,npz
              DO i=is,ie
                om2d(i, k) = om2d(i, k-1) + omga(i, j, k)
              END DO
            END DO
            DO k=2,npz
              DO i=is,ie
                omga(i, j, k) = om2d(i, k)
              END DO
            END DO
          END DO
        END IF
        IF (idiag%id_ws .GT. 0 .AND. hydrostatic) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,ws,delz,delp,omga)
          DO j=js,je
            DO i=is,ie
              ws(i, j) = delz(i, j, npz)/delp(i, j, npz)*omga(i, j, npz)
            END DO
          END DO
        END IF
      END IF
    END DO
!          used=send_data(idiag%id_ws, ws, fv_time)
!#endif
!    if (gridstruct%nested) then
!!#ifdef SW_DYNAMICS
!!#else
!
!
!
!         if (.not. hydrostatic) then
!               call nested_grid_BC_apply_intT(w, &
!                    0, 0, npx, npy, npz, bd, split_timestep_BC, split, &
!                    var_east_t0=neststruct%w_BC%east_t0, &
!                    var_west_t0=neststruct%w_BC%west_t0, &
!                    var_north_t0=neststruct%w_BC%north_t0, &
!                    var_south_t0=neststruct%w_BC%south_t0, &
!                    var_east_t1=neststruct%w_BC%east_t1, &
!                    var_west_t1=neststruct%w_BC%west_t1, &
!                    var_north_t1=neststruct%w_BC%north_t1, &
!                    var_south_t1=neststruct%w_BC%south_t1, &
!                    bctype=neststruct%nestbctype, &
!                    nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!         end if
!!#endif
!         
!         
!            call nested_grid_BC_apply_intT(u, &
!                 0, 1, npx, npy, npz, bd, split_timestep_BC, split, &
!                 var_east_t0=neststruct%u_BC%east_t0, &
!                 var_west_t0=neststruct%u_BC%west_t0, &
!                 var_north_t0=neststruct%u_BC%north_t0, &
!                 var_south_t0=neststruct%u_BC%south_t0, &
!                 var_east_t1=neststruct%u_BC%east_t1, &
!                 var_west_t1=neststruct%u_BC%west_t1, &
!                 var_north_t1=neststruct%u_BC%north_t1, &
!                 var_south_t1=neststruct%u_BC%south_t1, &
!                 bctype=neststruct%nestbctype, &
!                 nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!         !v
!            call nested_grid_BC_apply_intT(v, &
!                 1, 0, npx, npy, npz, bd, split_timestep_BC, split, &
!                 var_east_t0=neststruct%v_BC%east_t0, &
!                 var_west_t0=neststruct%v_BC%west_t0, &
!                 var_north_t0=neststruct%v_BC%north_t0, &
!                 var_south_t0=neststruct%v_BC%south_t0, &
!                 var_east_t1=neststruct%v_BC%east_t1, &
!                 var_west_t1=neststruct%v_BC%west_t1, &
!                 var_north_t1=neststruct%v_BC%north_t1, &
!                 var_south_t1=neststruct%v_BC%south_t1, &
!                 bctype=neststruct%nestbctype, &
!                 nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!      end if
!-----------------------------------------------------
! time split loop
!-----------------------------------------------------
!  if ( flagstruct%fv_debug ) then
!       if(is_master()) write(*,*) 'End of n_split loop'
!  endif
    IF (n_con .NE. 0 .AND. flagstruct%d_con .GT. 1.e-5) THEN
      CALL DEL2_CUBED(heat_source, cnst_0p20*gridstruct%da_min, &
&               gridstruct, domain, npx, npy, npz, 3, bd)
! Note: pt here is cp*(Virtual_Temperature/pkz)
      IF (hydrostatic) THEN
!
! del(Cp*T) = - del(KE)
!
!$OMP parallel do default(none) shared(is,ie,js,je,n_con,pt,heat_source,delp,pkz)
        DO j=js,je
          DO k=1,n_con
            DO i=is,ie
              pt(i, j, k) = pt(i, j, k) + heat_source(i, j, k)/(delp(i, &
&               j, k)*pkz(i, j, k))
            END DO
          END DO
        END DO
      ELSE
!$OMP parallel do default(none) shared(is,ie,js,je,n_con,pkz,cappa,kapag,delp,delz,pt, &
!$OMP                                  heat_source,k1k) &
!$OMP                          private(cpm, tmcp)
        DO j=js,je
! n_con is usually less than 3; not good as outer openMP loop
          DO k=1,n_con
            DO i=is,ie
!#ifdef MOIST_CAPPA
!                pkz(i,j,k) = exp(cappa(i,j,k)/(1.-cappa(i,j,k))*log(kapag*delp(i,j,k)/delz(i,j,k)*pt(i,j,k)) )
!#else
              arg1 = kapag*delp(i, j, k)/delz(i, j, k)*pt(i, j, k)
              arg2 = k1k*LOG(arg1)
              pkz(i, j, k) = EXP(arg2)
!#endif
! tmcp = termperature_v * cp
              tmcp = pt(i, j, k)*pkz(i, j, k)
              delz(i, j, k) = delz(i, j, k)/tmcp
              tmcp = tmcp + heat_source(i, j, k)/delp(i, j, k)
              pt(i, j, k) = tmcp/pkz(i, j, k)
              delz(i, j, k) = delz(i, j, k)*tmcp
            END DO
          END DO
        END DO
      END IF
    END IF
  END SUBROUTINE DYN_CORE
!  Differentiation of pk3_halo in forward (tangent) mode (with options r8):
!   variations   of useful results: pk3
!   with respect to varying inputs: pk3 delp
  SUBROUTINE PK3_HALO_TLM(is, ie, js, je, isd, ied, jsd, jed, npz, ptop&
&   , akap, pk3, pk3_tl, delp, delp_tl)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, npz
    REAL(fvprc), INTENT(IN) :: ptop, akap
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(IN) :: delp
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(IN) :: delp_tl
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz+1), INTENT(INOUT) :: &
&   pk3
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz+1), INTENT(INOUT) :: &
&   pk3_tl
! Local:
    REAL(fvprc) :: pei(isd:ied)
    REAL(fvprc) :: pei_tl(isd:ied)
    REAL(fvprc) :: pej(jsd:jed)
    REAL(fvprc) :: pej_tl(jsd:jed)
    INTEGER :: i, j, k
    INTRINSIC LOG
    INTRINSIC EXP
    REAL(fvprc) :: arg1
    REAL(fvprc) :: arg1_tl
    pei_tl = 0.0_FVPRC
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,npz,ptop,delp,pk3,akap) &
!$OMP                          private(pei)
    DO j=js,je
      pei_tl(is-2) = 0.0_FVPRC
      pei(is-2) = ptop
      pei_tl(is-1) = 0.0_FVPRC
      pei(is-1) = ptop
      DO k=1,npz
        pei_tl(is-2) = pei_tl(is-2) + delp_tl(is-2, j, k)
        pei(is-2) = pei(is-2) + delp(is-2, j, k)
        pei_tl(is-1) = pei_tl(is-1) + delp_tl(is-1, j, k)
        pei(is-1) = pei(is-1) + delp(is-1, j, k)
        arg1_tl = akap*pei_tl(is-2)/pei(is-2)
        arg1 = akap*LOG(pei(is-2))
        pk3_tl(is-2, j, k+1) = arg1_tl*EXP(arg1)
        pk3(is-2, j, k+1) = EXP(arg1)
        arg1_tl = akap*pei_tl(is-1)/pei(is-1)
        arg1 = akap*LOG(pei(is-1))
        pk3_tl(is-1, j, k+1) = arg1_tl*EXP(arg1)
        pk3(is-1, j, k+1) = EXP(arg1)
      END DO
      pei_tl(ie+1) = 0.0_FVPRC
      pei(ie+1) = ptop
      pei_tl(ie+2) = 0.0_FVPRC
      pei(ie+2) = ptop
      DO k=1,npz
        pei_tl(ie+1) = pei_tl(ie+1) + delp_tl(ie+1, j, k)
        pei(ie+1) = pei(ie+1) + delp(ie+1, j, k)
        pei_tl(ie+2) = pei_tl(ie+2) + delp_tl(ie+2, j, k)
        pei(ie+2) = pei(ie+2) + delp(ie+2, j, k)
        arg1_tl = akap*pei_tl(ie+1)/pei(ie+1)
        arg1 = akap*LOG(pei(ie+1))
        pk3_tl(ie+1, j, k+1) = arg1_tl*EXP(arg1)
        pk3(ie+1, j, k+1) = EXP(arg1)
        arg1_tl = akap*pei_tl(ie+2)/pei(ie+2)
        arg1 = akap*LOG(pei(ie+2))
        pk3_tl(ie+2, j, k+1) = arg1_tl*EXP(arg1)
        pk3(ie+2, j, k+1) = EXP(arg1)
      END DO
    END DO
    pej_tl = 0.0_FVPRC
!$OMP parallel do default(none) shared(is,ie,js,je,npz,ptop,delp,pk3,akap) &
!$OMP                          private(pej)
    DO i=is-2,ie+2
      pej_tl(js-2) = 0.0_FVPRC
      pej(js-2) = ptop
      pej_tl(js-1) = 0.0_FVPRC
      pej(js-1) = ptop
      DO k=1,npz
        pej_tl(js-2) = pej_tl(js-2) + delp_tl(i, js-2, k)
        pej(js-2) = pej(js-2) + delp(i, js-2, k)
        pej_tl(js-1) = pej_tl(js-1) + delp_tl(i, js-1, k)
        pej(js-1) = pej(js-1) + delp(i, js-1, k)
        arg1_tl = akap*pej_tl(js-2)/pej(js-2)
        arg1 = akap*LOG(pej(js-2))
        pk3_tl(i, js-2, k+1) = arg1_tl*EXP(arg1)
        pk3(i, js-2, k+1) = EXP(arg1)
        arg1_tl = akap*pej_tl(js-1)/pej(js-1)
        arg1 = akap*LOG(pej(js-1))
        pk3_tl(i, js-1, k+1) = arg1_tl*EXP(arg1)
        pk3(i, js-1, k+1) = EXP(arg1)
      END DO
      pej_tl(je+1) = 0.0_FVPRC
      pej(je+1) = ptop
      pej_tl(je+2) = 0.0_FVPRC
      pej(je+2) = ptop
      DO k=1,npz
        pej_tl(je+1) = pej_tl(je+1) + delp_tl(i, je+1, k)
        pej(je+1) = pej(je+1) + delp(i, je+1, k)
        pej_tl(je+2) = pej_tl(je+2) + delp_tl(i, je+2, k)
        pej(je+2) = pej(je+2) + delp(i, je+2, k)
        arg1_tl = akap*pej_tl(je+1)/pej(je+1)
        arg1 = akap*LOG(pej(je+1))
        pk3_tl(i, je+1, k+1) = arg1_tl*EXP(arg1)
        pk3(i, je+1, k+1) = EXP(arg1)
        arg1_tl = akap*pej_tl(je+2)/pej(je+2)
        arg1 = akap*LOG(pej(je+2))
        pk3_tl(i, je+2, k+1) = arg1_tl*EXP(arg1)
        pk3(i, je+2, k+1) = EXP(arg1)
      END DO
    END DO
  END SUBROUTINE PK3_HALO_TLM
  SUBROUTINE PK3_HALO(is, ie, js, je, isd, ied, jsd, jed, npz, ptop, &
&   akap, pk3, delp)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, npz
    REAL(fvprc), INTENT(IN) :: ptop, akap
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(IN) :: delp
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz+1), INTENT(INOUT) :: &
&   pk3
! Local:
    REAL(fvprc) :: pei(isd:ied)
    REAL(fvprc) :: pej(jsd:jed)
    INTEGER :: i, j, k
    INTRINSIC LOG
    INTRINSIC EXP
    REAL(fvprc) :: arg1
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,npz,ptop,delp,pk3,akap) &
!$OMP                          private(pei)
    DO j=js,je
      pei(is-2) = ptop
      pei(is-1) = ptop
      DO k=1,npz
        pei(is-2) = pei(is-2) + delp(is-2, j, k)
        pei(is-1) = pei(is-1) + delp(is-1, j, k)
        arg1 = akap*LOG(pei(is-2))
        pk3(is-2, j, k+1) = EXP(arg1)
        arg1 = akap*LOG(pei(is-1))
        pk3(is-1, j, k+1) = EXP(arg1)
      END DO
      pei(ie+1) = ptop
      pei(ie+2) = ptop
      DO k=1,npz
        pei(ie+1) = pei(ie+1) + delp(ie+1, j, k)
        pei(ie+2) = pei(ie+2) + delp(ie+2, j, k)
        arg1 = akap*LOG(pei(ie+1))
        pk3(ie+1, j, k+1) = EXP(arg1)
        arg1 = akap*LOG(pei(ie+2))
        pk3(ie+2, j, k+1) = EXP(arg1)
      END DO
    END DO
!$OMP parallel do default(none) shared(is,ie,js,je,npz,ptop,delp,pk3,akap) &
!$OMP                          private(pej)
    DO i=is-2,ie+2
      pej(js-2) = ptop
      pej(js-1) = ptop
      DO k=1,npz
        pej(js-2) = pej(js-2) + delp(i, js-2, k)
        pej(js-1) = pej(js-1) + delp(i, js-1, k)
        arg1 = akap*LOG(pej(js-2))
        pk3(i, js-2, k+1) = EXP(arg1)
        arg1 = akap*LOG(pej(js-1))
        pk3(i, js-1, k+1) = EXP(arg1)
      END DO
      pej(je+1) = ptop
      pej(je+2) = ptop
      DO k=1,npz
        pej(je+1) = pej(je+1) + delp(i, je+1, k)
        pej(je+2) = pej(je+2) + delp(i, je+2, k)
        arg1 = akap*LOG(pej(je+1))
        pk3(i, je+1, k+1) = EXP(arg1)
        arg1 = akap*LOG(pej(je+2))
        pk3(i, je+2, k+1) = EXP(arg1)
      END DO
    END DO
  END SUBROUTINE PK3_HALO
!  Differentiation of pln_halo in forward (tangent) mode (with options r8):
!   variations   of useful results: pk3
!   with respect to varying inputs: pk3 delp
  SUBROUTINE PLN_HALO_TLM(is, ie, js, je, isd, ied, jsd, jed, npz, ptop&
&   , pk3, pk3_tl, delp, delp_tl)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, npz
    REAL(fvprc), INTENT(IN) :: ptop
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(IN) :: delp
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(IN) :: delp_tl
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz+1), INTENT(INOUT) :: &
&   pk3
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz+1), INTENT(INOUT) :: &
&   pk3_tl
! Local:
    REAL(fvprc) :: pet
    REAL(fvprc) :: pet_tl
    INTEGER :: i, j, k
    INTRINSIC LOG
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,npz,ptop,delp,pk3) &
!$OMP                          private(pet)
!!$AD II-LOOP
    DO j=js,je
      DO i=is-2,is-1
        pet = ptop
        pet_tl = 0.0_FVPRC
        DO k=1,npz
          pet_tl = pet_tl + delp_tl(i, j, k)
          pet = pet + delp(i, j, k)
          pk3_tl(i, j, k+1) = pet_tl/pet
          pk3(i, j, k+1) = LOG(pet)
        END DO
      END DO
      DO i=ie+1,ie+2
        pet = ptop
        pet_tl = 0.0_FVPRC
        DO k=1,npz
          pet_tl = pet_tl + delp_tl(i, j, k)
          pet = pet + delp(i, j, k)
          pk3_tl(i, j, k+1) = pet_tl/pet
          pk3(i, j, k+1) = LOG(pet)
        END DO
      END DO
    END DO
!$OMP parallel do default(none) shared(is,ie,js,je,npz,ptop,delp,pk3) &
!$OMP                          private(pet)
!!$AD II-LOOP
    DO i=is-2,ie+2
      DO j=js-2,js-1
        pet = ptop
        pet_tl = 0.0_FVPRC
        DO k=1,npz
          pet_tl = pet_tl + delp_tl(i, j, k)
          pet = pet + delp(i, j, k)
          pk3_tl(i, j, k+1) = pet_tl/pet
          pk3(i, j, k+1) = LOG(pet)
        END DO
      END DO
      DO j=je+1,je+2
        pet = ptop
        pet_tl = 0.0_FVPRC
        DO k=1,npz
          pet_tl = pet_tl + delp_tl(i, j, k)
          pet = pet + delp(i, j, k)
          pk3_tl(i, j, k+1) = pet_tl/pet
          pk3(i, j, k+1) = LOG(pet)
        END DO
      END DO
    END DO
  END SUBROUTINE PLN_HALO_TLM
  SUBROUTINE PLN_HALO(is, ie, js, je, isd, ied, jsd, jed, npz, ptop, pk3&
&   , delp)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, npz
    REAL(fvprc), INTENT(IN) :: ptop
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(IN) :: delp
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz+1), INTENT(INOUT) :: &
&   pk3
! Local:
    REAL(fvprc) :: pet
    INTEGER :: i, j, k
    INTRINSIC LOG
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,npz,ptop,delp,pk3) &
!$OMP                          private(pet)
!!$AD II-LOOP
    DO j=js,je
      DO i=is-2,is-1
        pet = ptop
        DO k=1,npz
          pet = pet + delp(i, j, k)
          pk3(i, j, k+1) = LOG(pet)
        END DO
      END DO
      DO i=ie+1,ie+2
        pet = ptop
        DO k=1,npz
          pet = pet + delp(i, j, k)
          pk3(i, j, k+1) = LOG(pet)
        END DO
      END DO
    END DO
!$OMP parallel do default(none) shared(is,ie,js,je,npz,ptop,delp,pk3) &
!$OMP                          private(pet)
!!$AD II-LOOP
    DO i=is-2,ie+2
      DO j=js-2,js-1
        pet = ptop
        DO k=1,npz
          pet = pet + delp(i, j, k)
          pk3(i, j, k+1) = LOG(pet)
        END DO
      END DO
      DO j=je+1,je+2
        pet = ptop
        DO k=1,npz
          pet = pet + delp(i, j, k)
          pk3(i, j, k+1) = LOG(pet)
        END DO
      END DO
    END DO
  END SUBROUTINE PLN_HALO
!  Differentiation of pe_halo in forward (tangent) mode (with options r8):
!   variations   of useful results: pe
!   with respect to varying inputs: delp pe
  SUBROUTINE PE_HALO_TLM(is, ie, js, je, isd, ied, jsd, jed, npz, ptop, &
&   pe, pe_tl, delp, delp_tl)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, npz
    REAL(fvprc), INTENT(IN) :: ptop
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(IN) :: delp
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(IN) :: delp_tl
    REAL(fvprc), DIMENSION(is-1:ie+1, npz+1, js-1:je+1), INTENT(INOUT) &
&   :: pe
    REAL(fvprc), DIMENSION(is-1:ie+1, npz+1, js-1:je+1), INTENT(INOUT) &
&   :: pe_tl
! Local:
    INTEGER :: i, j, k
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pe,delp,ptop)
!!$AD II-LOOP
    DO j=js,je
      pe_tl(is-1, 1, j) = 0.0_FVPRC
      pe(is-1, 1, j) = ptop
      pe_tl(ie+1, 1, j) = 0.0_FVPRC
      pe(ie+1, 1, j) = ptop
      DO k=1,npz
        pe_tl(is-1, k+1, j) = pe_tl(is-1, k, j) + delp_tl(is-1, j, k)
        pe(is-1, k+1, j) = pe(is-1, k, j) + delp(is-1, j, k)
        pe_tl(ie+1, k+1, j) = pe_tl(ie+1, k, j) + delp_tl(ie+1, j, k)
        pe(ie+1, k+1, j) = pe(ie+1, k, j) + delp(ie+1, j, k)
      END DO
    END DO
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pe,delp,ptop)
!!$AD II-LOOP
    DO i=is-1,ie+1
      pe_tl(i, 1, js-1) = 0.0_FVPRC
      pe(i, 1, js-1) = ptop
      pe_tl(i, 1, je+1) = 0.0_FVPRC
      pe(i, 1, je+1) = ptop
      DO k=1,npz
        pe_tl(i, k+1, js-1) = pe_tl(i, k, js-1) + delp_tl(i, js-1, k)
        pe(i, k+1, js-1) = pe(i, k, js-1) + delp(i, js-1, k)
        pe_tl(i, k+1, je+1) = pe_tl(i, k, je+1) + delp_tl(i, je+1, k)
        pe(i, k+1, je+1) = pe(i, k, je+1) + delp(i, je+1, k)
      END DO
    END DO
  END SUBROUTINE PE_HALO_TLM
  SUBROUTINE PE_HALO(is, ie, js, je, isd, ied, jsd, jed, npz, ptop, pe, &
&   delp)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, npz
    REAL(fvprc), INTENT(IN) :: ptop
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(IN) :: delp
    REAL(fvprc), DIMENSION(is-1:ie+1, npz+1, js-1:je+1), INTENT(INOUT) &
&   :: pe
! Local:
    INTEGER :: i, j, k
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pe,delp,ptop)
!!$AD II-LOOP
    DO j=js,je
      pe(is-1, 1, j) = ptop
      pe(ie+1, 1, j) = ptop
      DO k=1,npz
        pe(is-1, k+1, j) = pe(is-1, k, j) + delp(is-1, j, k)
        pe(ie+1, k+1, j) = pe(ie+1, k, j) + delp(ie+1, j, k)
      END DO
    END DO
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pe,delp,ptop)
!!$AD II-LOOP
    DO i=is-1,ie+1
      pe(i, 1, js-1) = ptop
      pe(i, 1, je+1) = ptop
      DO k=1,npz
        pe(i, k+1, js-1) = pe(i, k, js-1) + delp(i, js-1, k)
        pe(i, k+1, je+1) = pe(i, k, je+1) + delp(i, je+1, k)
      END DO
    END DO
  END SUBROUTINE PE_HALO
!  Differentiation of adv_pe in forward (tangent) mode (with options r8):
!   variations   of useful results: om
!   with respect to varying inputs: ua om va pem
  SUBROUTINE ADV_PE_TLM(ua, ua_tl, va, va_tl, pem, pem_tl, om, om_tl, &
&   gridstruct, bd, npx, npy, npz, ng)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, npz, ng
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! Contra-variant wind components:
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(IN&
&   ) :: ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(IN&
&   ) :: ua_tl, va_tl
! Pressure at edges:
    REAL(fvprc), INTENT(IN) :: pem(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je&
&   +1)
    REAL(fvprc), INTENT(IN) :: pem_tl(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd&
&   %je+1)
    REAL(fvprc), INTENT(INOUT) :: om(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: om_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
! Local:
    REAL(fvprc), DIMENSION(bd%is:bd%ie, bd%js:bd%je) :: up, vp
    REAL(fvprc), DIMENSION(bd%is:bd%ie, bd%js:bd%je) :: up_tl, vp_tl
    REAL(fvprc) :: v3(3, bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: v3_tl(3, bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: pin(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: pin_tl(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: pb(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: pb_tl(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: grad(3, bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: grad_tl(3, bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: pdx(3, bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: pdx_tl(3, bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: pdy(3, bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: pdy_tl(3, bd%is:bd%ie+1, bd%js:bd%je)
    INTEGER :: i, j, k, n
    v3_tl = 0.0_FVPRC
    grad_tl = 0.0_FVPRC
    up_tl = 0.0_FVPRC
    pdx_tl = 0.0_FVPRC
    pdy_tl = 0.0_FVPRC
    pb_tl = 0.0_FVPRC
    vp_tl = 0.0_FVPRC
    pin_tl = 0.0_FVPRC
!$OMP parallel do default(none) shared(is,ie,js,je,npz,ua,va,gridstruct,pem,npx,npy,ng,om) &
!$OMP                          private(n, pdx, pdy, pin, pb, up, vp, grad, v3)
    DO k=1,npz
      IF (k .EQ. npz) THEN
        DO j=js,je
          DO i=is,ie
            up_tl(i, j) = ua_tl(i, j, npz)
            up(i, j) = ua(i, j, npz)
            vp_tl(i, j) = va_tl(i, j, npz)
            vp(i, j) = va(i, j, npz)
          END DO
        END DO
      ELSE
        DO j=js,je
          DO i=is,ie
            up_tl(i, j) = 0.5*(ua_tl(i, j, k)+ua_tl(i, j, k+1))
            up(i, j) = 0.5*(ua(i, j, k)+ua(i, j, k+1))
            vp_tl(i, j) = 0.5*(va_tl(i, j, k)+va_tl(i, j, k+1))
            vp(i, j) = 0.5*(va(i, j, k)+va(i, j, k+1))
          END DO
        END DO
      END IF
! Compute Vect wind:
      DO j=js,je
        DO i=is,ie
          DO n=1,3
            v3_tl(n, i, j) = gridstruct%ec1(n, i, j)*up_tl(i, j) + &
&             gridstruct%ec2(n, i, j)*vp_tl(i, j)
            v3(n, i, j) = up(i, j)*gridstruct%ec1(n, i, j) + vp(i, j)*&
&             gridstruct%ec2(n, i, j)
          END DO
        END DO
      END DO
      DO j=js-1,je+1
        DO i=is-1,ie+1
          pin_tl(i, j) = pem_tl(i, k+1, j)
          pin(i, j) = pem(i, k+1, j)
        END DO
      END DO
! Compute pe at 4 cell corners:
      CALL A2B_ORD2_TLM(pin, pin_tl, pb, pb_tl, gridstruct, npx, npy, is&
&                 , ie, js, je, ng)
      DO j=js,je+1
        DO i=is,ie
          DO n=1,3
            pdx_tl(n, i, j) = gridstruct%dx(i, j)*gridstruct%en1(n, i, j&
&             )*(pb_tl(i, j)+pb_tl(i+1, j))
            pdx(n, i, j) = (pb(i, j)+pb(i+1, j))*gridstruct%dx(i, j)*&
&             gridstruct%en1(n, i, j)
          END DO
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          DO n=1,3
            pdy_tl(n, i, j) = gridstruct%dy(i, j)*gridstruct%en2(n, i, j&
&             )*(pb_tl(i, j)+pb_tl(i, j+1))
            pdy(n, i, j) = (pb(i, j)+pb(i, j+1))*gridstruct%dy(i, j)*&
&             gridstruct%en2(n, i, j)
          END DO
        END DO
      END DO
! Compute grad (pe) by Green's theorem
      DO j=js,je
        DO i=is,ie
          DO n=1,3
            grad_tl(n, i, j) = pdx_tl(n, i, j+1) - pdx_tl(n, i, j) - &
&             pdy_tl(n, i, j) + pdy_tl(n, i+1, j)
            grad(n, i, j) = pdx(n, i, j+1) - pdx(n, i, j) - pdy(n, i, j)&
&             + pdy(n, i+1, j)
          END DO
        END DO
      END DO
! Compute inner product: V3 * grad (pe)
      DO j=js,je
        DO i=is,ie
          om_tl(i, j, k) = om_tl(i, j, k) + 0.5*gridstruct%rarea(i, j)*(&
&           v3_tl(1, i, j)*grad(1, i, j)+v3(1, i, j)*grad_tl(1, i, j)+&
&           v3_tl(2, i, j)*grad(2, i, j)+v3(2, i, j)*grad_tl(2, i, j)+&
&           v3_tl(3, i, j)*grad(3, i, j)+v3(3, i, j)*grad_tl(3, i, j))
          om(i, j, k) = om(i, j, k) + 0.5*gridstruct%rarea(i, j)*(v3(1, &
&           i, j)*grad(1, i, j)+v3(2, i, j)*grad(2, i, j)+v3(3, i, j)*&
&           grad(3, i, j))
        END DO
      END DO
    END DO
  END SUBROUTINE ADV_PE_TLM
  SUBROUTINE ADV_PE(ua, va, pem, om, gridstruct, bd, npx, npy, npz, ng)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, npz, ng
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! Contra-variant wind components:
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(IN&
&   ) :: ua, va
! Pressure at edges:
    REAL(fvprc), INTENT(IN) :: pem(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je&
&   +1)
    REAL(fvprc), INTENT(INOUT) :: om(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
! Local:
    REAL(fvprc), DIMENSION(bd%is:bd%ie, bd%js:bd%je) :: up, vp
    REAL(fvprc) :: v3(3, bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: pin(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: pb(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: grad(3, bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: pdx(3, bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: pdy(3, bd%is:bd%ie+1, bd%js:bd%je)
    INTEGER :: i, j, k, n
!$OMP parallel do default(none) shared(is,ie,js,je,npz,ua,va,gridstruct,pem,npx,npy,ng,om) &
!$OMP                          private(n, pdx, pdy, pin, pb, up, vp, grad, v3)
    DO k=1,npz
      IF (k .EQ. npz) THEN
        DO j=js,je
          DO i=is,ie
            up(i, j) = ua(i, j, npz)
            vp(i, j) = va(i, j, npz)
          END DO
        END DO
      ELSE
        DO j=js,je
          DO i=is,ie
            up(i, j) = 0.5*(ua(i, j, k)+ua(i, j, k+1))
            vp(i, j) = 0.5*(va(i, j, k)+va(i, j, k+1))
          END DO
        END DO
      END IF
! Compute Vect wind:
      DO j=js,je
        DO i=is,ie
          DO n=1,3
            v3(n, i, j) = up(i, j)*gridstruct%ec1(n, i, j) + vp(i, j)*&
&             gridstruct%ec2(n, i, j)
          END DO
        END DO
      END DO
      DO j=js-1,je+1
        DO i=is-1,ie+1
          pin(i, j) = pem(i, k+1, j)
        END DO
      END DO
! Compute pe at 4 cell corners:
      CALL A2B_ORD2(pin, pb, gridstruct, npx, npy, is, ie, js, je, ng)
      DO j=js,je+1
        DO i=is,ie
          DO n=1,3
            pdx(n, i, j) = (pb(i, j)+pb(i+1, j))*gridstruct%dx(i, j)*&
&             gridstruct%en1(n, i, j)
          END DO
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          DO n=1,3
            pdy(n, i, j) = (pb(i, j)+pb(i, j+1))*gridstruct%dy(i, j)*&
&             gridstruct%en2(n, i, j)
          END DO
        END DO
      END DO
! Compute grad (pe) by Green's theorem
      DO j=js,je
        DO i=is,ie
          DO n=1,3
            grad(n, i, j) = pdx(n, i, j+1) - pdx(n, i, j) - pdy(n, i, j)&
&             + pdy(n, i+1, j)
          END DO
        END DO
      END DO
! Compute inner product: V3 * grad (pe)
      DO j=js,je
        DO i=is,ie
          om(i, j, k) = om(i, j, k) + 0.5*gridstruct%rarea(i, j)*(v3(1, &
&           i, j)*grad(1, i, j)+v3(2, i, j)*grad(2, i, j)+v3(3, i, j)*&
&           grad(3, i, j))
        END DO
      END DO
    END DO
  END SUBROUTINE ADV_PE
!  Differentiation of p_grad_c in forward (tangent) mode (with options r8):
!   variations   of useful results: uc vc
!   with respect to varying inputs: gz uc pkc delpc vc
  SUBROUTINE P_GRAD_C_TLM(dt2, npz, delpc, delpc_tl, pkc, pkc_tl, gz, &
&   gz_tl, uc, uc_tl, vc, vc_tl, bd, rdxc, rdyc, hydrostatic)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npz
    REAL(fvprc), INTENT(IN) :: dt2
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:, bd%jsd:, :), INTENT(IN) :: delpc
    REAL(fvprc), DIMENSION(bd%isd:, bd%jsd:, :), INTENT(IN) :: delpc_tl
! pkc is pe**cappa     if hydrostatic
! pkc is full pressure if non-hydrostatic
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1), INTENT(&
&   IN) :: pkc, gz
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1), INTENT(&
&   IN) :: pkc_tl, gz_tl
    REAL(fvprc), INTENT(INOUT) :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: uc_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: vc_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), INTENT(IN) :: rdxc(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: rdyc(bd%isd:bd%ied, bd%jsd:bd%jed)
    LOGICAL, INTENT(IN) :: hydrostatic
! Local:
    REAL(fvprc) :: wk(bd%is-1:bd%ie+1, bd%js-1:bd%je+1)
    REAL(fvprc) :: wk_tl(bd%is-1:bd%ie+1, bd%js-1:bd%je+1)
    INTEGER :: i, j, k
    wk_tl = 0.0_FVPRC
!$OMP parallel do default(none) shared(is,ie,js,je,npz,hydrostatic,pkc,delpc,uc,dt2,rdxc,gz,vc,rdyc) &
!$OMP                          private(wk)
    DO k=1,npz
      IF (hydrostatic) THEN
        DO j=js-1,je+1
          DO i=is-1,ie+1
            wk_tl(i, j) = pkc_tl(i, j, k+1) - pkc_tl(i, j, k)
            wk(i, j) = pkc(i, j, k+1) - pkc(i, j, k)
          END DO
        END DO
      ELSE
        DO j=js-1,je+1
          DO i=is-1,ie+1
            wk_tl(i, j) = delpc_tl(i, j, k)
            wk(i, j) = delpc(i, j, k)
          END DO
        END DO
      END IF
      DO j=js,je
        DO i=is,ie+1
          uc_tl(i, j, k) = uc_tl(i, j, k) + dt2*rdxc(i, j)*((gz_tl(i-1, &
&           j, k+1)-gz_tl(i, j, k))*(pkc(i, j, k+1)-pkc(i-1, j, k))+(gz(&
&           i-1, j, k+1)-gz(i, j, k))*(pkc_tl(i, j, k+1)-pkc_tl(i-1, j, &
&           k))+(gz_tl(i-1, j, k)-gz_tl(i, j, k+1))*(pkc(i-1, j, k+1)-&
&           pkc(i, j, k))+(gz(i-1, j, k)-gz(i, j, k+1))*(pkc_tl(i-1, j, &
&           k+1)-pkc_tl(i, j, k)))/(wk(i-1, j)+wk(i, j)) - dt2*rdxc(i, j&
&           )*(wk_tl(i-1, j)+wk_tl(i, j))*((gz(i-1, j, k+1)-gz(i, j, k))&
&           *(pkc(i, j, k+1)-pkc(i-1, j, k))+(gz(i-1, j, k)-gz(i, j, k+1&
&           ))*(pkc(i-1, j, k+1)-pkc(i, j, k)))/(wk(i-1, j)+wk(i, j))**2
          uc(i, j, k) = uc(i, j, k) + dt2*rdxc(i, j)/(wk(i-1, j)+wk(i, j&
&           ))*((gz(i-1, j, k+1)-gz(i, j, k))*(pkc(i, j, k+1)-pkc(i-1, j&
&           , k))+(gz(i-1, j, k)-gz(i, j, k+1))*(pkc(i-1, j, k+1)-pkc(i&
&           , j, k)))
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          vc_tl(i, j, k) = vc_tl(i, j, k) + dt2*rdyc(i, j)*((gz_tl(i, j-&
&           1, k+1)-gz_tl(i, j, k))*(pkc(i, j, k+1)-pkc(i, j-1, k))+(gz(&
&           i, j-1, k+1)-gz(i, j, k))*(pkc_tl(i, j, k+1)-pkc_tl(i, j-1, &
&           k))+(gz_tl(i, j-1, k)-gz_tl(i, j, k+1))*(pkc(i, j-1, k+1)-&
&           pkc(i, j, k))+(gz(i, j-1, k)-gz(i, j, k+1))*(pkc_tl(i, j-1, &
&           k+1)-pkc_tl(i, j, k)))/(wk(i, j-1)+wk(i, j)) - dt2*rdyc(i, j&
&           )*(wk_tl(i, j-1)+wk_tl(i, j))*((gz(i, j-1, k+1)-gz(i, j, k))&
&           *(pkc(i, j, k+1)-pkc(i, j-1, k))+(gz(i, j-1, k)-gz(i, j, k+1&
&           ))*(pkc(i, j-1, k+1)-pkc(i, j, k)))/(wk(i, j-1)+wk(i, j))**2
          vc(i, j, k) = vc(i, j, k) + dt2*rdyc(i, j)/(wk(i, j-1)+wk(i, j&
&           ))*((gz(i, j-1, k+1)-gz(i, j, k))*(pkc(i, j, k+1)-pkc(i, j-1&
&           , k))+(gz(i, j-1, k)-gz(i, j, k+1))*(pkc(i, j-1, k+1)-pkc(i&
&           , j, k)))
        END DO
      END DO
    END DO
  END SUBROUTINE P_GRAD_C_TLM
  SUBROUTINE P_GRAD_C(dt2, npz, delpc, pkc, gz, uc, vc, bd, rdxc, rdyc, &
&   hydrostatic)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npz
    REAL(fvprc), INTENT(IN) :: dt2
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:, bd%jsd:, :), INTENT(IN) :: delpc
! pkc is pe**cappa     if hydrostatic
! pkc is full pressure if non-hydrostatic
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1), INTENT(&
&   IN) :: pkc, gz
    REAL(fvprc), INTENT(INOUT) :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(IN) :: rdxc(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: rdyc(bd%isd:bd%ied, bd%jsd:bd%jed)
    LOGICAL, INTENT(IN) :: hydrostatic
! Local:
    REAL(fvprc) :: wk(bd%is-1:bd%ie+1, bd%js-1:bd%je+1)
    INTEGER :: i, j, k
!$OMP parallel do default(none) shared(is,ie,js,je,npz,hydrostatic,pkc,delpc,uc,dt2,rdxc,gz,vc,rdyc) &
!$OMP                          private(wk)
    DO k=1,npz
      IF (hydrostatic) THEN
        DO j=js-1,je+1
          DO i=is-1,ie+1
            wk(i, j) = pkc(i, j, k+1) - pkc(i, j, k)
          END DO
        END DO
      ELSE
        DO j=js-1,je+1
          DO i=is-1,ie+1
            wk(i, j) = delpc(i, j, k)
          END DO
        END DO
      END IF
      DO j=js,je
        DO i=is,ie+1
          uc(i, j, k) = uc(i, j, k) + dt2*rdxc(i, j)/(wk(i-1, j)+wk(i, j&
&           ))*((gz(i-1, j, k+1)-gz(i, j, k))*(pkc(i, j, k+1)-pkc(i-1, j&
&           , k))+(gz(i-1, j, k)-gz(i, j, k+1))*(pkc(i-1, j, k+1)-pkc(i&
&           , j, k)))
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          vc(i, j, k) = vc(i, j, k) + dt2*rdyc(i, j)/(wk(i, j-1)+wk(i, j&
&           ))*((gz(i, j-1, k+1)-gz(i, j, k))*(pkc(i, j, k+1)-pkc(i, j-1&
&           , k))+(gz(i, j-1, k)-gz(i, j, k+1))*(pkc(i, j-1, k+1)-pkc(i&
&           , j, k)))
        END DO
      END DO
    END DO
  END SUBROUTINE P_GRAD_C
!  Differentiation of nh_p_grad in forward (tangent) mode (with options r8):
!   variations   of useful results: gz u v delp pk pp
!   with respect to varying inputs: gz u v delp pk pp
  SUBROUTINE NH_P_GRAD_TLM(u, u_tl, v, v_tl, pp, pp_tl, gz, gz_tl, delp&
&   , delp_tl, pk, pk_tl, dt, ng, gridstruct, bd, npx, npy, npz, &
&   use_logp)
    IMPLICIT NONE
! end k-loop
    INTEGER, INTENT(IN) :: ng, npx, npy, npz
    REAL(fvprc), INTENT(IN) :: dt
    LOGICAL, INTENT(IN) :: use_logp
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: delp_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
! perturbation pressure
    REAL(fvprc), INTENT(INOUT) :: pp(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: pp_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
! p**kappa
    REAL(fvprc), INTENT(INOUT) :: pk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: pk_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
! g * h
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: gz_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: u_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: v_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
! Local:
    REAL(fvprc) :: wk1(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk1_tl(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: wk_tl(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: du1, dv1, top_value
    REAL(fvprc) :: du1_tl, dv1_tl
    INTEGER :: i, j, k
    IF (use_logp) THEN
      top_value = peln1
    ELSE
      top_value = ptk
    END IF
!Remember that not all compilers set pp to zero by default
!$OMP parallel do default(none) shared(is,ie,js,je,pp,pk,top_value)
    DO j=js,je+1
      DO i=is,ie+1
        pp_tl(i, j, 1) = 0.0_FVPRC
        pp(i, j, 1) = 0.
        pk_tl(i, j, 1) = 0.0_FVPRC
        pk(i, j, 1) = top_value
      END DO
    END DO
    wk1_tl = 0.0_FVPRC
!$OMP parallel do default(none) shared(isd,jsd,npz,pp,gridstruct,npx,npy,is,ie,js,je,ng,pk,gz) &
!$OMP                          private(wk1)
    DO k=1,npz+1
      IF (k .NE. 1) THEN
        CALL A2B_ORD4_TLM(pp(isd:ied, jsd:jed, k), pp_tl(isd:ied, jsd&
&                      :jed, k), wk1, wk1_tl, gridstruct, npx, npy, is, &
&                      ie, js, je, ng, .true.)
        CALL A2B_ORD4_TLM(pk(isd:ied, jsd:jed, k), pk_tl(isd:ied, jsd&
&                      :jed, k), wk1, wk1_tl, gridstruct, npx, npy, is, &
&                      ie, js, je, ng, .true.)
      END IF
      CALL A2B_ORD4_TLM(gz(isd:ied, jsd:jed, k), gz_tl(isd:ied, jsd:&
&                    jed, k), wk1, wk1_tl, gridstruct, npx, npy, is, ie&
&                    , js, je, ng, .true.)
    END DO
    wk_tl = 0.0_FVPRC
!$OMP parallel do default(none) shared(is,ie,js,je,npz,delp,gridstruct,npx,npy,ng,isd,jsd, &
!$OMP                                  pk,dt,gz,u,pp,v) &
!$OMP                          private(wk1, wk, du1, dv1)
    DO k=1,npz
      CALL A2B_ORD4_TLM(delp(isd:ied, jsd:jed, k), delp_tl(isd:ied, &
&                    jsd:jed, k), wk1, wk1_tl, gridstruct, npx, npy, is&
&                    , ie, js, je, ng)
      DO j=js,je+1
        DO i=is,ie+1
          wk_tl(i, j) = pk_tl(i, j, k+1) - pk_tl(i, j, k)
          wk(i, j) = pk(i, j, k+1) - pk(i, j, k)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
! hydrostatic contributions from past time-step already added in the "beta" part
! Current gradient from "hydrostatic" components:
          du1_tl = dt*((gz_tl(i, j, k+1)-gz_tl(i+1, j, k))*(pk(i+1, j, k&
&           +1)-pk(i, j, k))+(gz(i, j, k+1)-gz(i+1, j, k))*(pk_tl(i+1, j&
&           , k+1)-pk_tl(i, j, k))+(gz_tl(i, j, k)-gz_tl(i+1, j, k+1))*(&
&           pk(i, j, k+1)-pk(i+1, j, k))+(gz(i, j, k)-gz(i+1, j, k+1))*(&
&           pk_tl(i, j, k+1)-pk_tl(i+1, j, k)))/(wk(i, j)+wk(i+1, j)) - &
&           dt*(wk_tl(i, j)+wk_tl(i+1, j))*((gz(i, j, k+1)-gz(i+1, j, k)&
&           )*(pk(i+1, j, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i+1, j, k+1)&
&           )*(pk(i, j, k+1)-pk(i+1, j, k)))/(wk(i, j)+wk(i+1, j))**2
          du1 = dt/(wk(i, j)+wk(i+1, j))*((gz(i, j, k+1)-gz(i+1, j, k))*&
&           (pk(i+1, j, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i+1, j, k+1))*&
&           (pk(i, j, k+1)-pk(i+1, j, k)))
! Non-hydrostatic contribution
          u_tl(i, j, k) = gridstruct%rdx(i, j)*(u_tl(i, j, k)+du1_tl+dt*&
&           ((gz_tl(i, j, k+1)-gz_tl(i+1, j, k))*(pp(i+1, j, k+1)-pp(i, &
&           j, k))+(gz(i, j, k+1)-gz(i+1, j, k))*(pp_tl(i+1, j, k+1)-&
&           pp_tl(i, j, k))+(gz_tl(i, j, k)-gz_tl(i+1, j, k+1))*(pp(i, j&
&           , k+1)-pp(i+1, j, k))+(gz(i, j, k)-gz(i+1, j, k+1))*(pp_tl(i&
&           , j, k+1)-pp_tl(i+1, j, k)))/(wk1(i, j)+wk1(i+1, j))-dt*(&
&           wk1_tl(i, j)+wk1_tl(i+1, j))*((gz(i, j, k+1)-gz(i+1, j, k))*&
&           (pp(i+1, j, k+1)-pp(i, j, k))+(gz(i, j, k)-gz(i+1, j, k+1))*&
&           (pp(i, j, k+1)-pp(i+1, j, k)))/(wk1(i, j)+wk1(i+1, j))**2)
          u(i, j, k) = (u(i, j, k)+du1+dt/(wk1(i, j)+wk1(i+1, j))*((gz(i&
&           , j, k+1)-gz(i+1, j, k))*(pp(i+1, j, k+1)-pp(i, j, k))+(gz(i&
&           , j, k)-gz(i+1, j, k+1))*(pp(i, j, k+1)-pp(i+1, j, k))))*&
&           gridstruct%rdx(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
! Current gradient from "hydrostatic" components:
          dv1_tl = dt*((gz_tl(i, j, k+1)-gz_tl(i, j+1, k))*(pk(i, j+1, k&
&           +1)-pk(i, j, k))+(gz(i, j, k+1)-gz(i, j+1, k))*(pk_tl(i, j+1&
&           , k+1)-pk_tl(i, j, k))+(gz_tl(i, j, k)-gz_tl(i, j+1, k+1))*(&
&           pk(i, j, k+1)-pk(i, j+1, k))+(gz(i, j, k)-gz(i, j+1, k+1))*(&
&           pk_tl(i, j, k+1)-pk_tl(i, j+1, k)))/(wk(i, j)+wk(i, j+1)) - &
&           dt*(wk_tl(i, j)+wk_tl(i, j+1))*((gz(i, j, k+1)-gz(i, j+1, k)&
&           )*(pk(i, j+1, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i, j+1, k+1)&
&           )*(pk(i, j, k+1)-pk(i, j+1, k)))/(wk(i, j)+wk(i, j+1))**2
          dv1 = dt/(wk(i, j)+wk(i, j+1))*((gz(i, j, k+1)-gz(i, j+1, k))*&
&           (pk(i, j+1, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i, j+1, k+1))*&
&           (pk(i, j, k+1)-pk(i, j+1, k)))
! Non-hydrostatic contribution
          v_tl(i, j, k) = gridstruct%rdy(i, j)*(v_tl(i, j, k)+dv1_tl+dt*&
&           ((gz_tl(i, j, k+1)-gz_tl(i, j+1, k))*(pp(i, j+1, k+1)-pp(i, &
&           j, k))+(gz(i, j, k+1)-gz(i, j+1, k))*(pp_tl(i, j+1, k+1)-&
&           pp_tl(i, j, k))+(gz_tl(i, j, k)-gz_tl(i, j+1, k+1))*(pp(i, j&
&           , k+1)-pp(i, j+1, k))+(gz(i, j, k)-gz(i, j+1, k+1))*(pp_tl(i&
&           , j, k+1)-pp_tl(i, j+1, k)))/(wk1(i, j)+wk1(i, j+1))-dt*(&
&           wk1_tl(i, j)+wk1_tl(i, j+1))*((gz(i, j, k+1)-gz(i, j+1, k))*&
&           (pp(i, j+1, k+1)-pp(i, j, k))+(gz(i, j, k)-gz(i, j+1, k+1))*&
&           (pp(i, j, k+1)-pp(i, j+1, k)))/(wk1(i, j)+wk1(i, j+1))**2)
          v(i, j, k) = (v(i, j, k)+dv1+dt/(wk1(i, j)+wk1(i, j+1))*((gz(i&
&           , j, k+1)-gz(i, j+1, k))*(pp(i, j+1, k+1)-pp(i, j, k))+(gz(i&
&           , j, k)-gz(i, j+1, k+1))*(pp(i, j, k+1)-pp(i, j+1, k))))*&
&           gridstruct%rdy(i, j)
        END DO
      END DO
    END DO
  END SUBROUTINE NH_P_GRAD_TLM
  SUBROUTINE NH_P_GRAD(u, v, pp, gz, delp, pk, dt, ng, gridstruct, bd, &
&   npx, npy, npz, use_logp)
    IMPLICIT NONE
! end k-loop
    INTEGER, INTENT(IN) :: ng, npx, npy, npz
    REAL(fvprc), INTENT(IN) :: dt
    LOGICAL, INTENT(IN) :: use_logp
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! perturbation pressure
    REAL(fvprc), INTENT(INOUT) :: pp(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
! p**kappa
    REAL(fvprc), INTENT(INOUT) :: pk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
! g * h
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
! Local:
    REAL(fvprc) :: wk1(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: du1, dv1, top_value
    INTEGER :: i, j, k
    IF (use_logp) THEN
      top_value = peln1
    ELSE
      top_value = ptk
    END IF
!Remember that not all compilers set pp to zero by default
!$OMP parallel do default(none) shared(is,ie,js,je,pp,pk,top_value)
    DO j=js,je+1
      DO i=is,ie+1
        pp(i, j, 1) = 0.
        pk(i, j, 1) = top_value
      END DO
    END DO
!$OMP parallel do default(none) shared(isd,jsd,npz,pp,gridstruct,npx,npy,is,ie,js,je,ng,pk,gz) &
!$OMP                          private(wk1)
    DO k=1,npz+1
      IF (k .NE. 1) THEN
        CALL A2B_ORD4(pp(isd:ied, jsd:jed, k), wk1, gridstruct, npx, &
&                  npy, is, ie, js, je, ng, .true.)
        CALL A2B_ORD4(pk(isd:ied, jsd:jed, k), wk1, gridstruct, npx, &
&                  npy, is, ie, js, je, ng, .true.)
      END IF
      CALL A2B_ORD4(gz(isd:ied, jsd:jed, k), wk1, gridstruct, npx, &
&                npy, is, ie, js, je, ng, .true.)
    END DO
!$OMP parallel do default(none) shared(is,ie,js,je,npz,delp,gridstruct,npx,npy,ng,isd,jsd, &
!$OMP                                  pk,dt,gz,u,pp,v) &
!$OMP                          private(wk1, wk, du1, dv1)
    DO k=1,npz
      CALL A2B_ORD4(delp(isd:ied, jsd:jed, k), wk1, gridstruct, npx, &
&                npy, is, ie, js, je, ng)
      DO j=js,je+1
        DO i=is,ie+1
          wk(i, j) = pk(i, j, k+1) - pk(i, j, k)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
! hydrostatic contributions from past time-step already added in the "beta" part
! Current gradient from "hydrostatic" components:
          du1 = dt/(wk(i, j)+wk(i+1, j))*((gz(i, j, k+1)-gz(i+1, j, k))*&
&           (pk(i+1, j, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i+1, j, k+1))*&
&           (pk(i, j, k+1)-pk(i+1, j, k)))
! Non-hydrostatic contribution
          u(i, j, k) = (u(i, j, k)+du1+dt/(wk1(i, j)+wk1(i+1, j))*((gz(i&
&           , j, k+1)-gz(i+1, j, k))*(pp(i+1, j, k+1)-pp(i, j, k))+(gz(i&
&           , j, k)-gz(i+1, j, k+1))*(pp(i, j, k+1)-pp(i+1, j, k))))*&
&           gridstruct%rdx(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
! Current gradient from "hydrostatic" components:
          dv1 = dt/(wk(i, j)+wk(i, j+1))*((gz(i, j, k+1)-gz(i, j+1, k))*&
&           (pk(i, j+1, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i, j+1, k+1))*&
&           (pk(i, j, k+1)-pk(i, j+1, k)))
! Non-hydrostatic contribution
          v(i, j, k) = (v(i, j, k)+dv1+dt/(wk1(i, j)+wk1(i, j+1))*((gz(i&
&           , j, k+1)-gz(i, j+1, k))*(pp(i, j+1, k+1)-pp(i, j, k))+(gz(i&
&           , j, k)-gz(i, j+1, k+1))*(pp(i, j, k+1)-pp(i, j+1, k))))*&
&           gridstruct%rdy(i, j)
        END DO
      END DO
    END DO
  END SUBROUTINE NH_P_GRAD
!  Differentiation of split_p_grad in forward (tangent) mode (with options r8):
!   variations   of useful results: gz du u dv v delp pk pp
!   with respect to varying inputs: gz du u dv v delp pk pp
  SUBROUTINE SPLIT_P_GRAD_TLM(u, u_tl, v, v_tl, du, du_tl, dv, dv_tl, pp&
&   , pp_tl, gz, gz_tl, delp, delp_tl, pk, pk_tl, beta, dt, ng, &
&   gridstruct, bd, npx, npy, npz, use_logp)
    IMPLICIT NONE
! end k-loop
    INTEGER, INTENT(IN) :: ng, npx, npy, npz
    REAL(fvprc), INTENT(IN) :: beta, dt
    LOGICAL, INTENT(IN) :: use_logp
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: delp_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
! perturbation pressure
    REAL(fvprc), INTENT(INOUT) :: pp(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: pp_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
! p**kappa
    REAL(fvprc), INTENT(INOUT) :: pk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: pk_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
! g * h
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: gz_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: du(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: du_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: dv(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: dv_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: u_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: v_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
! Local:
    REAL(fvprc) :: wk1(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk1_tl(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: wk_tl(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: alpha, top_value
    INTEGER :: i, j, k
    IF (use_logp) THEN
      top_value = peln1
    ELSE
      top_value = ptk
    END IF
    alpha = 1. - beta
!$OMP parallel do default(none) shared(is,ie,js,je,pp,pk,top_value)
    DO j=js,je+1
      DO i=is,ie+1
        pp_tl(i, j, 1) = 0.0_FVPRC
        pp(i, j, 1) = 0.
        pk_tl(i, j, 1) = 0.0_FVPRC
        pk(i, j, 1) = top_value
      END DO
    END DO
    wk1_tl = 0.0_FVPRC
!$OMP parallel do default(none) shared(isd,jsd,npz,pp,gridstruct,npx,npy,is,ie,js,je,ng,pk,gz) &
!$OMP                          private(wk1)
    DO k=1,npz+1
      IF (k .NE. 1) THEN
        CALL A2B_ORD4_TLM(pp(isd:ied, jsd:jed, k), pp_tl(isd:ied, jsd&
&                      :jed, k), wk1, wk1_tl, gridstruct, npx, npy, is, &
&                      ie, js, je, ng, .true.)
        CALL A2B_ORD4_TLM(pk(isd:ied, jsd:jed, k), pk_tl(isd:ied, jsd&
&                      :jed, k), wk1, wk1_tl, gridstruct, npx, npy, is, &
&                      ie, js, je, ng, .true.)
      END IF
      CALL A2B_ORD4_TLM(gz(isd:ied, jsd:jed, k), gz_tl(isd:ied, jsd:&
&                    jed, k), wk1, wk1_tl, gridstruct, npx, npy, is, ie&
&                    , js, je, ng, .true.)
    END DO
    wk_tl = 0.0_FVPRC
!$OMP parallel do default(none) shared(is,ie,js,je,isd,jsd,npz,delp,gridstruct,npx,npy,ng, &
!$OMP                                  pk,u,beta,du,dt,gz,alpha,pp,v,dv) &
!$OMP                          private(wk1, wk)
    DO k=1,npz
      CALL A2B_ORD4_TLM(delp(isd:ied, jsd:jed, k), delp_tl(isd:ied, &
&                    jsd:jed, k), wk1, wk1_tl, gridstruct, npx, npy, is&
&                    , ie, js, je, ng)
      DO j=js,je+1
        DO i=is,ie+1
          wk_tl(i, j) = pk_tl(i, j, k+1) - pk_tl(i, j, k)
          wk(i, j) = pk(i, j, k+1) - pk(i, j, k)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          u_tl(i, j, k) = u_tl(i, j, k) + beta*du_tl(i, j, k)
          u(i, j, k) = u(i, j, k) + beta*du(i, j, k)
! hydrostatic contributions from past time-step already added in the "beta" part
! Current gradient from "hydrostatic" components:
!---------------------------------------------------------------------------------
          du_tl(i, j, k) = dt*((gz_tl(i, j, k+1)-gz_tl(i+1, j, k))*(pk(i&
&           +1, j, k+1)-pk(i, j, k))+(gz(i, j, k+1)-gz(i+1, j, k))*(&
&           pk_tl(i+1, j, k+1)-pk_tl(i, j, k))+(gz_tl(i, j, k)-gz_tl(i+1&
&           , j, k+1))*(pk(i, j, k+1)-pk(i+1, j, k))+(gz(i, j, k)-gz(i+1&
&           , j, k+1))*(pk_tl(i, j, k+1)-pk_tl(i+1, j, k)))/(wk(i, j)+wk&
&           (i+1, j)) - dt*(wk_tl(i, j)+wk_tl(i+1, j))*((gz(i, j, k+1)-&
&           gz(i+1, j, k))*(pk(i+1, j, k+1)-pk(i, j, k))+(gz(i, j, k)-gz&
&           (i+1, j, k+1))*(pk(i, j, k+1)-pk(i+1, j, k)))/(wk(i, j)+wk(i&
&           +1, j))**2
          du(i, j, k) = dt/(wk(i, j)+wk(i+1, j))*((gz(i, j, k+1)-gz(i+1&
&           , j, k))*(pk(i+1, j, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i+1, &
&           j, k+1))*(pk(i, j, k+1)-pk(i+1, j, k)))
!---------------------------------------------------------------------------------
! Non-hydrostatic contribution
          u_tl(i, j, k) = gridstruct%rdx(i, j)*(u_tl(i, j, k)+alpha*&
&           du_tl(i, j, k)+dt*((gz_tl(i, j, k+1)-gz_tl(i+1, j, k))*(pp(i&
&           +1, j, k+1)-pp(i, j, k))+(gz(i, j, k+1)-gz(i+1, j, k))*(&
&           pp_tl(i+1, j, k+1)-pp_tl(i, j, k))+(gz_tl(i, j, k)-gz_tl(i+1&
&           , j, k+1))*(pp(i, j, k+1)-pp(i+1, j, k))+(gz(i, j, k)-gz(i+1&
&           , j, k+1))*(pp_tl(i, j, k+1)-pp_tl(i+1, j, k)))/(wk1(i, j)+&
&           wk1(i+1, j))-dt*(wk1_tl(i, j)+wk1_tl(i+1, j))*((gz(i, j, k+1&
&           )-gz(i+1, j, k))*(pp(i+1, j, k+1)-pp(i, j, k))+(gz(i, j, k)-&
&           gz(i+1, j, k+1))*(pp(i, j, k+1)-pp(i+1, j, k)))/(wk1(i, j)+&
&           wk1(i+1, j))**2)
          u(i, j, k) = (u(i, j, k)+alpha*du(i, j, k)+dt/(wk1(i, j)+wk1(i&
&           +1, j))*((gz(i, j, k+1)-gz(i+1, j, k))*(pp(i+1, j, k+1)-pp(i&
&           , j, k))+(gz(i, j, k)-gz(i+1, j, k+1))*(pp(i, j, k+1)-pp(i+1&
&           , j, k))))*gridstruct%rdx(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          v_tl(i, j, k) = v_tl(i, j, k) + beta*dv_tl(i, j, k)
          v(i, j, k) = v(i, j, k) + beta*dv(i, j, k)
! Current gradient from "hydrostatic" components:
!---------------------------------------------------------------------------------
          dv_tl(i, j, k) = dt*((gz_tl(i, j, k+1)-gz_tl(i, j+1, k))*(pk(i&
&           , j+1, k+1)-pk(i, j, k))+(gz(i, j, k+1)-gz(i, j+1, k))*(&
&           pk_tl(i, j+1, k+1)-pk_tl(i, j, k))+(gz_tl(i, j, k)-gz_tl(i, &
&           j+1, k+1))*(pk(i, j, k+1)-pk(i, j+1, k))+(gz(i, j, k)-gz(i, &
&           j+1, k+1))*(pk_tl(i, j, k+1)-pk_tl(i, j+1, k)))/(wk(i, j)+wk&
&           (i, j+1)) - dt*(wk_tl(i, j)+wk_tl(i, j+1))*((gz(i, j, k+1)-&
&           gz(i, j+1, k))*(pk(i, j+1, k+1)-pk(i, j, k))+(gz(i, j, k)-gz&
&           (i, j+1, k+1))*(pk(i, j, k+1)-pk(i, j+1, k)))/(wk(i, j)+wk(i&
&           , j+1))**2
          dv(i, j, k) = dt/(wk(i, j)+wk(i, j+1))*((gz(i, j, k+1)-gz(i, j&
&           +1, k))*(pk(i, j+1, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i, j+1&
&           , k+1))*(pk(i, j, k+1)-pk(i, j+1, k)))
!---------------------------------------------------------------------------------
! Non-hydrostatic contribution
          v_tl(i, j, k) = gridstruct%rdy(i, j)*(v_tl(i, j, k)+alpha*&
&           dv_tl(i, j, k)+dt*((gz_tl(i, j, k+1)-gz_tl(i, j+1, k))*(pp(i&
&           , j+1, k+1)-pp(i, j, k))+(gz(i, j, k+1)-gz(i, j+1, k))*(&
&           pp_tl(i, j+1, k+1)-pp_tl(i, j, k))+(gz_tl(i, j, k)-gz_tl(i, &
&           j+1, k+1))*(pp(i, j, k+1)-pp(i, j+1, k))+(gz(i, j, k)-gz(i, &
&           j+1, k+1))*(pp_tl(i, j, k+1)-pp_tl(i, j+1, k)))/(wk1(i, j)+&
&           wk1(i, j+1))-dt*(wk1_tl(i, j)+wk1_tl(i, j+1))*((gz(i, j, k+1&
&           )-gz(i, j+1, k))*(pp(i, j+1, k+1)-pp(i, j, k))+(gz(i, j, k)-&
&           gz(i, j+1, k+1))*(pp(i, j, k+1)-pp(i, j+1, k)))/(wk1(i, j)+&
&           wk1(i, j+1))**2)
          v(i, j, k) = (v(i, j, k)+alpha*dv(i, j, k)+dt/(wk1(i, j)+wk1(i&
&           , j+1))*((gz(i, j, k+1)-gz(i, j+1, k))*(pp(i, j+1, k+1)-pp(i&
&           , j, k))+(gz(i, j, k)-gz(i, j+1, k+1))*(pp(i, j, k+1)-pp(i, &
&           j+1, k))))*gridstruct%rdy(i, j)
        END DO
      END DO
    END DO
  END SUBROUTINE SPLIT_P_GRAD_TLM
  SUBROUTINE SPLIT_P_GRAD(u, v, du, dv, pp, gz, delp, pk, beta, dt, ng, &
&   gridstruct, bd, npx, npy, npz, use_logp)
    IMPLICIT NONE
! end k-loop
    INTEGER, INTENT(IN) :: ng, npx, npy, npz
    REAL(fvprc), INTENT(IN) :: beta, dt
    LOGICAL, INTENT(IN) :: use_logp
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! perturbation pressure
    REAL(fvprc), INTENT(INOUT) :: pp(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
! p**kappa
    REAL(fvprc), INTENT(INOUT) :: pk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
! g * h
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: du(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: dv(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
! Local:
    REAL(fvprc) :: wk1(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: alpha, top_value
    INTEGER :: i, j, k
    IF (use_logp) THEN
      top_value = peln1
    ELSE
      top_value = ptk
    END IF
    alpha = 1. - beta
!$OMP parallel do default(none) shared(is,ie,js,je,pp,pk,top_value)
    DO j=js,je+1
      DO i=is,ie+1
        pp(i, j, 1) = 0.
        pk(i, j, 1) = top_value
      END DO
    END DO
!$OMP parallel do default(none) shared(isd,jsd,npz,pp,gridstruct,npx,npy,is,ie,js,je,ng,pk,gz) &
!$OMP                          private(wk1)
    DO k=1,npz+1
      IF (k .NE. 1) THEN
        CALL A2B_ORD4(pp(isd:ied, jsd:jed, k), wk1, gridstruct, npx, &
&                  npy, is, ie, js, je, ng, .true.)
        CALL A2B_ORD4(pk(isd:ied, jsd:jed, k), wk1, gridstruct, npx, &
&                  npy, is, ie, js, je, ng, .true.)
      END IF
      CALL A2B_ORD4(gz(isd:ied, jsd:jed, k), wk1, gridstruct, npx, &
&                npy, is, ie, js, je, ng, .true.)
    END DO
!$OMP parallel do default(none) shared(is,ie,js,je,isd,jsd,npz,delp,gridstruct,npx,npy,ng, &
!$OMP                                  pk,u,beta,du,dt,gz,alpha,pp,v,dv) &
!$OMP                          private(wk1, wk)
    DO k=1,npz
      CALL A2B_ORD4(delp(isd:ied, jsd:jed, k), wk1, gridstruct, npx, &
&                npy, is, ie, js, je, ng)
      DO j=js,je+1
        DO i=is,ie+1
          wk(i, j) = pk(i, j, k+1) - pk(i, j, k)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          u(i, j, k) = u(i, j, k) + beta*du(i, j, k)
! hydrostatic contributions from past time-step already added in the "beta" part
! Current gradient from "hydrostatic" components:
!---------------------------------------------------------------------------------
          du(i, j, k) = dt/(wk(i, j)+wk(i+1, j))*((gz(i, j, k+1)-gz(i+1&
&           , j, k))*(pk(i+1, j, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i+1, &
&           j, k+1))*(pk(i, j, k+1)-pk(i+1, j, k)))
!---------------------------------------------------------------------------------
! Non-hydrostatic contribution
          u(i, j, k) = (u(i, j, k)+alpha*du(i, j, k)+dt/(wk1(i, j)+wk1(i&
&           +1, j))*((gz(i, j, k+1)-gz(i+1, j, k))*(pp(i+1, j, k+1)-pp(i&
&           , j, k))+(gz(i, j, k)-gz(i+1, j, k+1))*(pp(i, j, k+1)-pp(i+1&
&           , j, k))))*gridstruct%rdx(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          v(i, j, k) = v(i, j, k) + beta*dv(i, j, k)
! Current gradient from "hydrostatic" components:
!---------------------------------------------------------------------------------
          dv(i, j, k) = dt/(wk(i, j)+wk(i, j+1))*((gz(i, j, k+1)-gz(i, j&
&           +1, k))*(pk(i, j+1, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i, j+1&
&           , k+1))*(pk(i, j, k+1)-pk(i, j+1, k)))
!---------------------------------------------------------------------------------
! Non-hydrostatic contribution
          v(i, j, k) = (v(i, j, k)+alpha*dv(i, j, k)+dt/(wk1(i, j)+wk1(i&
&           , j+1))*((gz(i, j, k+1)-gz(i, j+1, k))*(pp(i, j+1, k+1)-pp(i&
&           , j, k))+(gz(i, j, k)-gz(i, j+1, k+1))*(pp(i, j, k+1)-pp(i, &
&           j+1, k))))*gridstruct%rdy(i, j)
        END DO
      END DO
    END DO
  END SUBROUTINE SPLIT_P_GRAD
!  Differentiation of one_grad_p in forward (tangent) mode (with options r8):
!   variations   of useful results: gz u v delp pk
!   with respect to varying inputs: gz u v delp pk divg2
  SUBROUTINE ONE_GRAD_P_TLM(u, u_tl, v, v_tl, pk, pk_tl, gz, gz_tl, &
&   divg2, divg2_tl, delp, delp_tl, dt, ng, gridstruct, bd, npx, npy, &
&   npz, ptop, hydrostatic, a2b_ord, d_ext)
    IMPLICIT NONE
! end k-loop
    INTEGER, INTENT(IN) :: ng, npx, npy, npz, a2b_ord
    REAL(fvprc), INTENT(IN) :: dt, ptop, d_ext
    LOGICAL, INTENT(IN) :: hydrostatic
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: divg2(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(IN) :: divg2_tl(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(INOUT) :: pk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: pk_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: gz_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: delp_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: u_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: v_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
! Local:
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: wk
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: wk_tl
    REAL(fvprc) :: wk1(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: wk1_tl(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: wk2(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: wk2_tl(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: top_value
    INTEGER :: i, j, k
    IF (hydrostatic) THEN
! pk is pe**kappa if hydrostatic
      top_value = ptk
    ELSE
! pk is full pressure if non-hydrostatic
      top_value = ptop
    END IF
!$OMP parallel do default(none) shared(is,ie,js,je,pk,top_value)
    DO j=js,je+1
      DO i=is,ie+1
        pk_tl(i, j, 1) = 0.0_FVPRC
        pk(i, j, 1) = top_value
      END DO
    END DO
    wk_tl = 0.0_FVPRC
!$OMP parallel do default(none) shared(npz,isd,jsd,pk,gridstruct,npx,npy,is,ie,js,je,ng,a2b_ord) &
!$OMP                          private(wk)
    DO k=2,npz+1
      IF (a2b_ord .EQ. 4) THEN
        CALL A2B_ORD4_TLM(pk(isd:ied, jsd:jed, k), pk_tl(isd:ied, jsd&
&                      :jed, k), wk, wk_tl, gridstruct, npx, npy, is, ie&
&                      , js, je, ng, .true.)
      ELSE
        CALL A2B_ORD2_TLM(pk(isd:ied, jsd:jed, k), pk_tl(isd:ied, jsd:&
&                   jed, k), wk, wk_tl, gridstruct, npx, npy, is, ie, js&
&                   , je, ng, .true.)
      END IF
    END DO
!$OMP parallel do default(none) shared(npz,isd,jsd,gz,gridstruct,npx,npy,is,ie,js,je,ng,a2b_ord) &
!$OMP                          private(wk)
    DO k=1,npz+1
      IF (a2b_ord .EQ. 4) THEN
        CALL A2B_ORD4_TLM(gz(isd:ied, jsd:jed, k), gz_tl(isd:ied, jsd&
&                      :jed, k), wk, wk_tl, gridstruct, npx, npy, is, ie&
&                      , js, je, ng, .true.)
      ELSE
        CALL A2B_ORD2_TLM(gz(isd:ied, jsd:jed, k), gz_tl(isd:ied, jsd:&
&                   jed, k), wk, wk_tl, gridstruct, npx, npy, is, ie, js&
&                   , je, ng, .true.)
      END IF
    END DO
    IF (d_ext .GT. 0.) THEN
      wk2_tl = 0.0_FVPRC
!$OMP parallel do default(none) shared(is,ie,js,je,wk2,divg2)
      DO j=js,je+1
        DO i=is,ie
          wk2_tl(i, j) = divg2_tl(i, j) - divg2_tl(i+1, j)
          wk2(i, j) = divg2(i, j) - divg2(i+1, j)
        END DO
      END DO
      wk1_tl = 0.0_FVPRC
!$OMP parallel do default(none) shared(is,ie,js,je,wk1,divg2)
      DO j=js,je
        DO i=is,ie+1
          wk1_tl(i, j) = divg2_tl(i, j) - divg2_tl(i, j+1)
          wk1(i, j) = divg2(i, j) - divg2(i, j+1)
        END DO
      END DO
    ELSE
!$OMP parallel do default(none) shared(is,ie,js,je,wk1,wk2)
      DO j=js,je+1
        DO i=is,ie
          wk2(i, j) = 0.
        END DO
        DO i=is,ie+1
          wk1(i, j) = 0.
        END DO
      END DO
      wk1_tl = 0.0_FVPRC
      wk2_tl = 0.0_FVPRC
    END IF
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pk,delp,hydrostatic,a2b_ord,gridstruct, &
!$OMP                                  npx,npy,isd,jsd,ng,u,v,wk2,dt,gz,wk1) &
!$OMP                          private(wk)
    DO k=1,npz
      IF (hydrostatic) THEN
        DO j=js,je+1
          DO i=is,ie+1
            wk_tl(i, j) = pk_tl(i, j, k+1) - pk_tl(i, j, k)
            wk(i, j) = pk(i, j, k+1) - pk(i, j, k)
          END DO
        END DO
      ELSE IF (a2b_ord .EQ. 4) THEN
        CALL A2B_ORD4_TLM(delp(isd:ied, jsd:jed, k), delp_tl(isd:ied&
&                      , jsd:jed, k), wk, wk_tl, gridstruct, npx, npy, &
&                      is, ie, js, je, ng)
      ELSE
        CALL A2B_ORD2_TLM(delp(isd:ied, jsd:jed, k), delp_tl(isd:ied, &
&                   jsd:jed, k), wk, wk_tl, gridstruct, npx, npy, is, ie&
&                   , js, je, ng)
      END IF
      DO j=js,je+1
        DO i=is,ie
          u_tl(i, j, k) = gridstruct%rdx(i, j)*(wk2_tl(i, j)+u_tl(i, j, &
&           k)+dt*((gz_tl(i, j, k+1)-gz_tl(i+1, j, k))*(pk(i+1, j, k+1)-&
&           pk(i, j, k))+(gz(i, j, k+1)-gz(i+1, j, k))*(pk_tl(i+1, j, k+&
&           1)-pk_tl(i, j, k))+(gz_tl(i, j, k)-gz_tl(i+1, j, k+1))*(pk(i&
&           , j, k+1)-pk(i+1, j, k))+(gz(i, j, k)-gz(i+1, j, k+1))*(&
&           pk_tl(i, j, k+1)-pk_tl(i+1, j, k)))/(wk(i, j)+wk(i+1, j))-dt&
&           *(wk_tl(i, j)+wk_tl(i+1, j))*((gz(i, j, k+1)-gz(i+1, j, k))*&
&           (pk(i+1, j, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i+1, j, k+1))*&
&           (pk(i, j, k+1)-pk(i+1, j, k)))/(wk(i, j)+wk(i+1, j))**2)
          u(i, j, k) = gridstruct%rdx(i, j)*(wk2(i, j)+u(i, j, k)+dt/(wk&
&           (i, j)+wk(i+1, j))*((gz(i, j, k+1)-gz(i+1, j, k))*(pk(i+1, j&
&           , k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i+1, j, k+1))*(pk(i, j, &
&           k+1)-pk(i+1, j, k))))
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          v_tl(i, j, k) = gridstruct%rdy(i, j)*(wk1_tl(i, j)+v_tl(i, j, &
&           k)+dt*((gz_tl(i, j, k+1)-gz_tl(i, j+1, k))*(pk(i, j+1, k+1)-&
&           pk(i, j, k))+(gz(i, j, k+1)-gz(i, j+1, k))*(pk_tl(i, j+1, k+&
&           1)-pk_tl(i, j, k))+(gz_tl(i, j, k)-gz_tl(i, j+1, k+1))*(pk(i&
&           , j, k+1)-pk(i, j+1, k))+(gz(i, j, k)-gz(i, j+1, k+1))*(&
&           pk_tl(i, j, k+1)-pk_tl(i, j+1, k)))/(wk(i, j)+wk(i, j+1))-dt&
&           *(wk_tl(i, j)+wk_tl(i, j+1))*((gz(i, j, k+1)-gz(i, j+1, k))*&
&           (pk(i, j+1, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i, j+1, k+1))*&
&           (pk(i, j, k+1)-pk(i, j+1, k)))/(wk(i, j)+wk(i, j+1))**2)
          v(i, j, k) = gridstruct%rdy(i, j)*(wk1(i, j)+v(i, j, k)+dt/(wk&
&           (i, j)+wk(i, j+1))*((gz(i, j, k+1)-gz(i, j+1, k))*(pk(i, j+1&
&           , k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i, j+1, k+1))*(pk(i, j, &
&           k+1)-pk(i, j+1, k))))
        END DO
      END DO
    END DO
  END SUBROUTINE ONE_GRAD_P_TLM
  SUBROUTINE ONE_GRAD_P(u, v, pk, gz, divg2, delp, dt, ng, gridstruct, &
&   bd, npx, npy, npz, ptop, hydrostatic, a2b_ord, d_ext)
    IMPLICIT NONE
! end k-loop
    INTEGER, INTENT(IN) :: ng, npx, npy, npz, a2b_ord
    REAL(fvprc), INTENT(IN) :: dt, ptop, d_ext
    LOGICAL, INTENT(IN) :: hydrostatic
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: divg2(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(INOUT) :: pk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
! Local:
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: wk
    REAL(fvprc) :: wk1(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: wk2(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: top_value
    INTEGER :: i, j, k
    IF (hydrostatic) THEN
! pk is pe**kappa if hydrostatic
      top_value = ptk
    ELSE
! pk is full pressure if non-hydrostatic
      top_value = ptop
    END IF
!$OMP parallel do default(none) shared(is,ie,js,je,pk,top_value)
    DO j=js,je+1
      DO i=is,ie+1
        pk(i, j, 1) = top_value
      END DO
    END DO
!$OMP parallel do default(none) shared(npz,isd,jsd,pk,gridstruct,npx,npy,is,ie,js,je,ng,a2b_ord) &
!$OMP                          private(wk)
    DO k=2,npz+1
      IF (a2b_ord .EQ. 4) THEN
        CALL A2B_ORD4(pk(isd:ied, jsd:jed, k), wk, gridstruct, npx, &
&                  npy, is, ie, js, je, ng, .true.)
      ELSE
        CALL A2B_ORD2(pk(isd:ied, jsd:jed, k), wk, gridstruct, npx, npy&
&               , is, ie, js, je, ng, .true.)
      END IF
    END DO
!$OMP parallel do default(none) shared(npz,isd,jsd,gz,gridstruct,npx,npy,is,ie,js,je,ng,a2b_ord) &
!$OMP                          private(wk)
    DO k=1,npz+1
      IF (a2b_ord .EQ. 4) THEN
        CALL A2B_ORD4(gz(isd:ied, jsd:jed, k), wk, gridstruct, npx, &
&                  npy, is, ie, js, je, ng, .true.)
      ELSE
        CALL A2B_ORD2(gz(isd:ied, jsd:jed, k), wk, gridstruct, npx, npy&
&               , is, ie, js, je, ng, .true.)
      END IF
    END DO
    IF (d_ext .GT. 0.) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,wk2,divg2)
      DO j=js,je+1
        DO i=is,ie
          wk2(i, j) = divg2(i, j) - divg2(i+1, j)
        END DO
      END DO
!$OMP parallel do default(none) shared(is,ie,js,je,wk1,divg2)
      DO j=js,je
        DO i=is,ie+1
          wk1(i, j) = divg2(i, j) - divg2(i, j+1)
        END DO
      END DO
    ELSE
!$OMP parallel do default(none) shared(is,ie,js,je,wk1,wk2)
      DO j=js,je+1
        DO i=is,ie
          wk2(i, j) = 0.
        END DO
        DO i=is,ie+1
          wk1(i, j) = 0.
        END DO
      END DO
    END IF
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pk,delp,hydrostatic,a2b_ord,gridstruct, &
!$OMP                                  npx,npy,isd,jsd,ng,u,v,wk2,dt,gz,wk1) &
!$OMP                          private(wk)
    DO k=1,npz
      IF (hydrostatic) THEN
        DO j=js,je+1
          DO i=is,ie+1
            wk(i, j) = pk(i, j, k+1) - pk(i, j, k)
          END DO
        END DO
      ELSE IF (a2b_ord .EQ. 4) THEN
        CALL A2B_ORD4(delp(isd:ied, jsd:jed, k), wk, gridstruct, npx&
&                  , npy, is, ie, js, je, ng)
      ELSE
        CALL A2B_ORD2(delp(isd:ied, jsd:jed, k), wk, gridstruct, npx, &
&               npy, is, ie, js, je, ng)
      END IF
      DO j=js,je+1
        DO i=is,ie
          u(i, j, k) = gridstruct%rdx(i, j)*(wk2(i, j)+u(i, j, k)+dt/(wk&
&           (i, j)+wk(i+1, j))*((gz(i, j, k+1)-gz(i+1, j, k))*(pk(i+1, j&
&           , k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i+1, j, k+1))*(pk(i, j, &
&           k+1)-pk(i+1, j, k))))
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          v(i, j, k) = gridstruct%rdy(i, j)*(wk1(i, j)+v(i, j, k)+dt/(wk&
&           (i, j)+wk(i, j+1))*((gz(i, j, k+1)-gz(i, j+1, k))*(pk(i, j+1&
&           , k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i, j+1, k+1))*(pk(i, j, &
&           k+1)-pk(i, j+1, k))))
        END DO
      END DO
    END DO
  END SUBROUTINE ONE_GRAD_P
!  Differentiation of grad1_p_update in forward (tangent) mode (with options r8):
!   variations   of useful results: gz du u dv v pk
!   with respect to varying inputs: gz du u dv v pk divg2
  SUBROUTINE GRAD1_P_UPDATE_TLM(divg2, divg2_tl, u, u_tl, v, v_tl, du, &
&   du_tl, dv, dv_tl, pk, pk_tl, gz, gz_tl, dt, ng, gridstruct, bd, npx&
&   , npy, npz, ptop, beta, a2b_ord)
    IMPLICIT NONE
! end k-loop
    INTEGER, INTENT(IN) :: ng, npx, npy, npz, a2b_ord
    REAL(fvprc), INTENT(IN) :: dt, ptop, beta
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: divg2(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(IN) :: divg2_tl(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(INOUT) :: pk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: pk_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: gz_tl(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: u_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: v_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    REAL(fvprc), INTENT(INOUT) :: du(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: du_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: dv(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: dv_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
! Local:
    REAL(fvprc) :: wk(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk_tl(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: top_value, alpha
    INTEGER :: i, j, k
    alpha = 1. - beta
! pk is pe**kappa if hydrostatic
    top_value = ptk
!$OMP parallel do default(none) shared(is,ie,js,je,pk,top_value)
    DO j=js,je+1
      DO i=is,ie+1
        pk_tl(i, j, 1) = 0.0_FVPRC
        pk(i, j, 1) = top_value
      END DO
    END DO
    wk_tl = 0.0_FVPRC
!$OMP parallel do default(none) shared(npz,isd,jsd,pk,gridstruct,npx,npy,is,ie,js,je,ng,a2b_ord) &
!$OMP                          private(wk)
    DO k=2,npz+1
      IF (a2b_ord .EQ. 4) THEN
        CALL A2B_ORD4_TLM(pk(isd:ied, jsd:jed, k), pk_tl(isd:ied, jsd&
&                      :jed, k), wk, wk_tl, gridstruct, npx, npy, is, ie&
&                      , js, je, ng, .true.)
      ELSE
        CALL A2B_ORD2_TLM(pk(isd:ied, jsd:jed, k), pk_tl(isd:ied, jsd:&
&                   jed, k), wk, wk_tl, gridstruct, npx, npy, is, ie, js&
&                   , je, ng, .true.)
      END IF
    END DO
!$OMP parallel do default(none) shared(npz,isd,jsd,gz,gridstruct,npx,npy,is,ie,js,je,ng,a2b_ord) &
!$OMP                          private(wk)
    DO k=1,npz+1
      IF (a2b_ord .EQ. 4) THEN
        CALL A2B_ORD4_TLM(gz(isd:ied, jsd:jed, k), gz_tl(isd:ied, jsd&
&                      :jed, k), wk, wk_tl, gridstruct, npx, npy, is, ie&
&                      , js, je, ng, .true.)
      ELSE
        CALL A2B_ORD2_TLM(gz(isd:ied, jsd:jed, k), gz_tl(isd:ied, jsd:&
&                   jed, k), wk, wk_tl, gridstruct, npx, npy, is, ie, js&
&                   , je, ng, .true.)
      END IF
    END DO
!$OMP parallel do default(none) shared(npz,is,ie,js,je,pk,u,beta,gz,divg2,alpha, &
!$OMP                                  gridstruct,v,dt,du,dv) &          
!$OMP                          private(wk)
    DO k=1,npz
      DO j=js,je+1
        DO i=is,ie+1
          wk_tl(i, j) = pk_tl(i, j, k+1) - pk_tl(i, j, k)
          wk(i, j) = pk(i, j, k+1) - pk(i, j, k)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          u_tl(i, j, k) = u_tl(i, j, k) + beta*du_tl(i, j, k)
          u(i, j, k) = u(i, j, k) + beta*du(i, j, k)
          du_tl(i, j, k) = dt*((gz_tl(i, j, k+1)-gz_tl(i+1, j, k))*(pk(i&
&           +1, j, k+1)-pk(i, j, k))+(gz(i, j, k+1)-gz(i+1, j, k))*(&
&           pk_tl(i+1, j, k+1)-pk_tl(i, j, k))+(gz_tl(i, j, k)-gz_tl(i+1&
&           , j, k+1))*(pk(i, j, k+1)-pk(i+1, j, k))+(gz(i, j, k)-gz(i+1&
&           , j, k+1))*(pk_tl(i, j, k+1)-pk_tl(i+1, j, k)))/(wk(i, j)+wk&
&           (i+1, j)) - dt*(wk_tl(i, j)+wk_tl(i+1, j))*((gz(i, j, k+1)-&
&           gz(i+1, j, k))*(pk(i+1, j, k+1)-pk(i, j, k))+(gz(i, j, k)-gz&
&           (i+1, j, k+1))*(pk(i, j, k+1)-pk(i+1, j, k)))/(wk(i, j)+wk(i&
&           +1, j))**2
          du(i, j, k) = dt/(wk(i, j)+wk(i+1, j))*((gz(i, j, k+1)-gz(i+1&
&           , j, k))*(pk(i+1, j, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i+1, &
&           j, k+1))*(pk(i, j, k+1)-pk(i+1, j, k)))
          u_tl(i, j, k) = gridstruct%rdx(i, j)*(u_tl(i, j, k)+divg2_tl(i&
&           , j)-divg2_tl(i+1, j)+alpha*du_tl(i, j, k))
          u(i, j, k) = (u(i, j, k)+divg2(i, j)-divg2(i+1, j)+alpha*du(i&
&           , j, k))*gridstruct%rdx(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          v_tl(i, j, k) = v_tl(i, j, k) + beta*dv_tl(i, j, k)
          v(i, j, k) = v(i, j, k) + beta*dv(i, j, k)
          dv_tl(i, j, k) = dt*((gz_tl(i, j, k+1)-gz_tl(i, j+1, k))*(pk(i&
&           , j+1, k+1)-pk(i, j, k))+(gz(i, j, k+1)-gz(i, j+1, k))*(&
&           pk_tl(i, j+1, k+1)-pk_tl(i, j, k))+(gz_tl(i, j, k)-gz_tl(i, &
&           j+1, k+1))*(pk(i, j, k+1)-pk(i, j+1, k))+(gz(i, j, k)-gz(i, &
&           j+1, k+1))*(pk_tl(i, j, k+1)-pk_tl(i, j+1, k)))/(wk(i, j)+wk&
&           (i, j+1)) - dt*(wk_tl(i, j)+wk_tl(i, j+1))*((gz(i, j, k+1)-&
&           gz(i, j+1, k))*(pk(i, j+1, k+1)-pk(i, j, k))+(gz(i, j, k)-gz&
&           (i, j+1, k+1))*(pk(i, j, k+1)-pk(i, j+1, k)))/(wk(i, j)+wk(i&
&           , j+1))**2
          dv(i, j, k) = dt/(wk(i, j)+wk(i, j+1))*((gz(i, j, k+1)-gz(i, j&
&           +1, k))*(pk(i, j+1, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i, j+1&
&           , k+1))*(pk(i, j, k+1)-pk(i, j+1, k)))
          v_tl(i, j, k) = gridstruct%rdy(i, j)*(v_tl(i, j, k)+divg2_tl(i&
&           , j)-divg2_tl(i, j+1)+alpha*dv_tl(i, j, k))
          v(i, j, k) = (v(i, j, k)+divg2(i, j)-divg2(i, j+1)+alpha*dv(i&
&           , j, k))*gridstruct%rdy(i, j)
        END DO
      END DO
    END DO
  END SUBROUTINE GRAD1_P_UPDATE_TLM
  SUBROUTINE GRAD1_P_UPDATE(divg2, u, v, du, dv, pk, gz, dt, ng, &
&   gridstruct, bd, npx, npy, npz, ptop, beta, a2b_ord)
    IMPLICIT NONE
! end k-loop
    INTEGER, INTENT(IN) :: ng, npx, npy, npz, a2b_ord
    REAL(fvprc), INTENT(IN) :: dt, ptop, beta
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: divg2(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(INOUT) :: pk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    REAL(fvprc), INTENT(INOUT) :: du(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: dv(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
! Local:
    REAL(fvprc) :: wk(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: top_value, alpha
    INTEGER :: i, j, k
    alpha = 1. - beta
! pk is pe**kappa if hydrostatic
    top_value = ptk
!$OMP parallel do default(none) shared(is,ie,js,je,pk,top_value)
    DO j=js,je+1
      DO i=is,ie+1
        pk(i, j, 1) = top_value
      END DO
    END DO
!$OMP parallel do default(none) shared(npz,isd,jsd,pk,gridstruct,npx,npy,is,ie,js,je,ng,a2b_ord) &
!$OMP                          private(wk)
    DO k=2,npz+1
      IF (a2b_ord .EQ. 4) THEN
        CALL A2B_ORD4(pk(isd:ied, jsd:jed, k), wk, gridstruct, npx, &
&                  npy, is, ie, js, je, ng, .true.)
      ELSE
        CALL A2B_ORD2(pk(isd:ied, jsd:jed, k), wk, gridstruct, npx, npy&
&               , is, ie, js, je, ng, .true.)
      END IF
    END DO
!$OMP parallel do default(none) shared(npz,isd,jsd,gz,gridstruct,npx,npy,is,ie,js,je,ng,a2b_ord) &
!$OMP                          private(wk)
    DO k=1,npz+1
      IF (a2b_ord .EQ. 4) THEN
        CALL A2B_ORD4(gz(isd:ied, jsd:jed, k), wk, gridstruct, npx, &
&                  npy, is, ie, js, je, ng, .true.)
      ELSE
        CALL A2B_ORD2(gz(isd:ied, jsd:jed, k), wk, gridstruct, npx, npy&
&               , is, ie, js, je, ng, .true.)
      END IF
    END DO
!$OMP parallel do default(none) shared(npz,is,ie,js,je,pk,u,beta,gz,divg2,alpha, &
!$OMP                                  gridstruct,v,dt,du,dv) &          
!$OMP                          private(wk)
    DO k=1,npz
      DO j=js,je+1
        DO i=is,ie+1
          wk(i, j) = pk(i, j, k+1) - pk(i, j, k)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          u(i, j, k) = u(i, j, k) + beta*du(i, j, k)
          du(i, j, k) = dt/(wk(i, j)+wk(i+1, j))*((gz(i, j, k+1)-gz(i+1&
&           , j, k))*(pk(i+1, j, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i+1, &
&           j, k+1))*(pk(i, j, k+1)-pk(i+1, j, k)))
          u(i, j, k) = (u(i, j, k)+divg2(i, j)-divg2(i+1, j)+alpha*du(i&
&           , j, k))*gridstruct%rdx(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          v(i, j, k) = v(i, j, k) + beta*dv(i, j, k)
          dv(i, j, k) = dt/(wk(i, j)+wk(i, j+1))*((gz(i, j, k+1)-gz(i, j&
&           +1, k))*(pk(i, j+1, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i, j+1&
&           , k+1))*(pk(i, j, k+1)-pk(i, j+1, k)))
          v(i, j, k) = (v(i, j, k)+divg2(i, j)-divg2(i, j+1)+alpha*dv(i&
&           , j, k))*gridstruct%rdy(i, j)
        END DO
      END DO
    END DO
  END SUBROUTINE GRAD1_P_UPDATE
!  Differentiation of mix_dp in forward (tangent) mode (with options r8):
!   variations   of useful results: w delp pt
!   with respect to varying inputs: w delp pt
  SUBROUTINE MIX_DP_TLM(hydrostatic, w, w_tl, delp, delp_tl, pt, pt_tl, &
&   km, ak, bk, cg, fv_debug, bd)
    IMPLICIT NONE
!if ( fv_debug .and. ip/=0 ) write(*,*) 'Warning: Mix_dp', mpp_pe, j, ip 
!     if ( ip/=0 ) write(*,*) 'Warning: Mix_dp', mpp_pe, j, ip 
    INTEGER, INTENT(IN) :: km
    REAL(fvprc), INTENT(IN) :: ak(km+1), bk(km+1)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, km), INTENT(&
&   INOUT) :: pt, delp
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, km), INTENT(&
&   INOUT) :: pt_tl, delp_tl
    REAL(fvprc), DIMENSION(bd%isd:, bd%jsd:, :), INTENT(INOUT) :: w
    REAL(fvprc), DIMENSION(bd%isd:, bd%jsd:, :), INTENT(INOUT) :: w_tl
    LOGICAL, INTENT(IN) :: hydrostatic, cg, fv_debug
! Local:
    REAL(fvprc) :: dp, dpmin
    REAL(fvprc) :: dp_tl
    INTEGER :: i, j, k, ip
    INTEGER :: ifirst, ilast
    INTEGER :: jfirst, jlast
    IF (cg) THEN
      ifirst = is - 1
      ilast = ie + 1
      jfirst = js - 1
      jlast = je + 1
    ELSE
      ifirst = is
      ilast = ie
      jfirst = js
      jlast = je
    END IF
!$OMP parallel do default(none) shared(jfirst,jlast,km,ifirst,ilast,delp,ak,bk,pt, &
!$OMP                                  hydrostatic,w,fv_debug) &
!$OMP                          private(ip, dpmin, dp)
    DO j=jfirst,jlast
      ip = 0
      DO k=1,km-1
        dpmin = 0.01*(ak(k+1)-ak(k)+(bk(k+1)-bk(k))*1.e5)
        DO i=ifirst,ilast
          IF (delp(i, j, k) .LT. dpmin) THEN
! Remap from below and mix pt
            dp_tl = -delp_tl(i, j, k)
            dp = dpmin - delp(i, j, k)
            pt_tl(i, j, k) = (pt_tl(i, j, k)*delp(i, j, k)+pt(i, j, k)*&
&             delp_tl(i, j, k)+pt_tl(i, j, k+1)*dp+pt(i, j, k+1)*dp_tl)/&
&             dpmin
            pt(i, j, k) = (pt(i, j, k)*delp(i, j, k)+pt(i, j, k+1)*dp)/&
&             dpmin
            IF (.NOT.hydrostatic) THEN
              w_tl(i, j, k) = (w_tl(i, j, k)*delp(i, j, k)+w(i, j, k)*&
&               delp_tl(i, j, k)+w_tl(i, j, k+1)*dp+w(i, j, k+1)*dp_tl)/&
&               dpmin
              w(i, j, k) = (w(i, j, k)*delp(i, j, k)+w(i, j, k+1)*dp)/&
&               dpmin
            END IF
            delp_tl(i, j, k) = 0.0_FVPRC
            delp(i, j, k) = dpmin
            delp_tl(i, j, k+1) = delp_tl(i, j, k+1) - dp_tl
            delp(i, j, k+1) = delp(i, j, k+1) - dp
            ip = ip + 1
          END IF
        END DO
      END DO
! Bottom (k=km):
      dpmin = 0.01*(ak(km+1)-ak(km)+(bk(km+1)-bk(km))*1.e5)
      DO i=ifirst,ilast
        IF (delp(i, j, km) .LT. dpmin) THEN
! Remap from above and mix pt
          dp_tl = -delp_tl(i, j, km)
          dp = dpmin - delp(i, j, km)
          pt_tl(i, j, km) = (pt_tl(i, j, km)*delp(i, j, km)+pt(i, j, km)&
&           *delp_tl(i, j, km)+pt_tl(i, j, km-1)*dp+pt(i, j, km-1)*dp_tl&
&           )/dpmin
          pt(i, j, km) = (pt(i, j, km)*delp(i, j, km)+pt(i, j, km-1)*dp)&
&           /dpmin
          IF (.NOT.hydrostatic) THEN
            w_tl(i, j, km) = (w_tl(i, j, km)*delp(i, j, km)+w(i, j, km)*&
&             delp_tl(i, j, km)+w_tl(i, j, km-1)*dp+w(i, j, km-1)*dp_tl)&
&             /dpmin
            w(i, j, km) = (w(i, j, km)*delp(i, j, km)+w(i, j, km-1)*dp)/&
&             dpmin
          END IF
          delp_tl(i, j, km) = 0.0_FVPRC
          delp(i, j, km) = dpmin
          delp_tl(i, j, km-1) = delp_tl(i, j, km-1) - dp_tl
          delp(i, j, km-1) = delp(i, j, km-1) - dp
          ip = ip + 1
        END IF
      END DO
    END DO
  END SUBROUTINE MIX_DP_TLM
  SUBROUTINE MIX_DP(hydrostatic, w, delp, pt, km, ak, bk, cg, fv_debug, &
&   bd)
    IMPLICIT NONE
!if ( fv_debug .and. ip/=0 ) write(*,*) 'Warning: Mix_dp', mpp_pe, j, ip 
!     if ( ip/=0 ) write(*,*) 'Warning: Mix_dp', mpp_pe, j, ip 
    INTEGER, INTENT(IN) :: km
    REAL(fvprc), INTENT(IN) :: ak(km+1), bk(km+1)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, km), INTENT(&
&   INOUT) :: pt, delp
    REAL(fvprc), DIMENSION(bd%isd:, bd%jsd:, :), INTENT(INOUT) :: w
    LOGICAL, INTENT(IN) :: hydrostatic, cg, fv_debug
! Local:
    REAL(fvprc) :: dp, dpmin
    INTEGER :: i, j, k, ip
    INTEGER :: ifirst, ilast
    INTEGER :: jfirst, jlast
    IF (cg) THEN
      ifirst = is - 1
      ilast = ie + 1
      jfirst = js - 1
      jlast = je + 1
    ELSE
      ifirst = is
      ilast = ie
      jfirst = js
      jlast = je
    END IF
!$OMP parallel do default(none) shared(jfirst,jlast,km,ifirst,ilast,delp,ak,bk,pt, &
!$OMP                                  hydrostatic,w,fv_debug) &
!$OMP                          private(ip, dpmin, dp)
    DO j=jfirst,jlast
      ip = 0
      DO k=1,km-1
        dpmin = 0.01*(ak(k+1)-ak(k)+(bk(k+1)-bk(k))*1.e5)
        DO i=ifirst,ilast
          IF (delp(i, j, k) .LT. dpmin) THEN
! Remap from below and mix pt
            dp = dpmin - delp(i, j, k)
            pt(i, j, k) = (pt(i, j, k)*delp(i, j, k)+pt(i, j, k+1)*dp)/&
&             dpmin
            IF (.NOT.hydrostatic) w(i, j, k) = (w(i, j, k)*delp(i, j, k)&
&               +w(i, j, k+1)*dp)/dpmin
            delp(i, j, k) = dpmin
            delp(i, j, k+1) = delp(i, j, k+1) - dp
            ip = ip + 1
          END IF
        END DO
      END DO
! Bottom (k=km):
      dpmin = 0.01*(ak(km+1)-ak(km)+(bk(km+1)-bk(km))*1.e5)
      DO i=ifirst,ilast
        IF (delp(i, j, km) .LT. dpmin) THEN
! Remap from above and mix pt
          dp = dpmin - delp(i, j, km)
          pt(i, j, km) = (pt(i, j, km)*delp(i, j, km)+pt(i, j, km-1)*dp)&
&           /dpmin
          IF (.NOT.hydrostatic) w(i, j, km) = (w(i, j, km)*delp(i, j, km&
&             )+w(i, j, km-1)*dp)/dpmin
          delp(i, j, km) = dpmin
          delp(i, j, km-1) = delp(i, j, km-1) - dp
          ip = ip + 1
        END IF
      END DO
    END DO
  END SUBROUTINE MIX_DP
!  Differentiation of geopk in forward (tangent) mode (with options r8):
!   variations   of useful results: peln gz pkz pe pk
!   with respect to varying inputs: peln gz delp pkz pe pk pt
  SUBROUTINE GEOPK_TLM(ptop, pe, pe_tl, peln, peln_tl, delp, delp_tl, pk&
&   , pk_tl, gz, gz_tl, hs, pt, pt_tl, q_con, pkz, pkz_tl, km, akap, cg&
&   , nested, computehalo, npx, npy, a2b_ord, bd)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: km, npx, npy, a2b_ord
    REAL(fvprc), INTENT(IN) :: akap, ptop
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: hs(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, km), INTENT(IN)&
&   :: pt, delp
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, km), INTENT(IN)&
&   :: pt_tl, delp_tl
    REAL(fvprc), DIMENSION(bd%isd:bd%isd, bd%jsd:bd%jsd, 1), INTENT(IN) &
&   :: q_con
    LOGICAL, INTENT(IN) :: cg, nested, computehalo
! !OUTPUT PARAMETERS
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, km+1), INTENT(&
&   OUT) :: gz, pk
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, km+1), INTENT(&
&   OUT) :: gz_tl, pk_tl
    REAL(fvprc), INTENT(OUT) :: pe(bd%is-1:bd%ie+1, km+1, bd%js-1:bd%je+&
&   1)
    REAL(fvprc), INTENT(OUT) :: pe_tl(bd%is-1:bd%ie+1, km+1, bd%js-1:bd%&
&   je+1)
! ln(pe)
    REAL(fvprc), INTENT(OUT) :: peln(bd%is:bd%ie, km+1, bd%js:bd%je)
    REAL(fvprc), INTENT(OUT) :: peln_tl(bd%is:bd%ie, km+1, bd%js:bd%je)
    REAL(fvprc), INTENT(OUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, km)
    REAL(fvprc), INTENT(OUT) :: pkz_tl(bd%is:bd%ie, bd%js:bd%je, km)
! !DESCRIPTION:
!    Calculates geopotential and pressure to the kappa.
! Local:
    REAL(fvprc) :: peg(bd%isd:bd%ied, km+1)
    REAL(fvprc) :: pkg(bd%isd:bd%ied, km+1)
    REAL(fvprc) :: p1d(bd%isd:bd%ied)
    REAL(fvprc) :: p1d_tl(bd%isd:bd%ied)
    REAL(fvprc) :: logp(bd%isd:bd%ied)
    REAL(fvprc) :: logp_tl(bd%isd:bd%ied)
    INTEGER :: i, j, k
    INTEGER :: ifirst, ilast
    INTEGER :: jfirst, jlast
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC LOG
    INTRINSIC EXP
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: min1
    INTEGER :: min2
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    IF ((.NOT.cg .AND. a2b_ord .EQ. 4) .OR. (nested .AND. (.NOT.cg))) &
&   THEN
! D-Grid
      ifirst = is - 2
      ilast = ie + 2
      jfirst = js - 2
      jlast = je + 2
    ELSE
      ifirst = is - 1
      ilast = ie + 1
      jfirst = js - 1
      jlast = je + 1
    END IF
    IF (nested .AND. computehalo) THEN
      IF (is .EQ. 1) ifirst = isd
      IF (ie .EQ. npx - 1) ilast = ied
      IF (js .EQ. 1) jfirst = jsd
      IF (je .EQ. npy - 1) THEN
        jlast = jed
        logp_tl = 0.0_FVPRC
        p1d_tl = 0.0_FVPRC
      ELSE
        logp_tl = 0.0_FVPRC
        p1d_tl = 0.0_FVPRC
      END IF
    ELSE
      logp_tl = 0.0_FVPRC
      p1d_tl = 0.0_FVPRC
    END IF
!$OMP parallel do default(none) shared(jfirst,jlast,ifirst,ilast,pk,km,gz,hs,ptop,ptk, &
!$OMP                                  js,je,is,ie,peln,peln1,pe,delp,akap,pt,CG,pkz) &
!$OMP                          private(peg, pkg, p1d, logp)
    DO j=jfirst,jlast
      DO i=ifirst,ilast
        p1d_tl(i) = 0.0_FVPRC
        p1d(i) = ptop
        pk_tl(i, j, 1) = 0.0_FVPRC
        pk(i, j, 1) = ptk
        gz_tl(i, j, km+1) = 0.0_FVPRC
        gz(i, j, km+1) = hs(i, j)
      END DO
!#ifdef USE_COND
!         peg(i,1) = ptop
!         pkg(i,1) = ptk
!#endif
!#ifndef SW_DYNAMICS
      IF (j .GE. js .AND. j .LE. je) THEN
        DO i=is,ie
          peln_tl(i, 1, j) = 0.0_FVPRC
          peln(i, 1, j) = peln1
        END DO
      END IF
!#endif
      IF (j .GT. js - 2 .AND. j .LT. je + 2) THEN
        IF (ifirst .LT. is - 1) THEN
          max1 = is - 1
        ELSE
          max1 = ifirst
        END IF
        IF (ilast .GT. ie + 1) THEN
          min1 = ie + 1
        ELSE
          min1 = ilast
        END IF
        DO i=max1,min1
          pe_tl(i, 1, j) = 0.0_FVPRC
          pe(i, 1, j) = ptop
        END DO
      END IF
! Top down
      DO k=2,km+1
        DO i=ifirst,ilast
          p1d_tl(i) = p1d_tl(i) + delp_tl(i, j, k-1)
          p1d(i) = p1d(i) + delp(i, j, k-1)
          logp_tl(i) = p1d_tl(i)/p1d(i)
          logp(i) = LOG(p1d(i))
          pk_tl(i, j, k) = akap*logp_tl(i)*EXP(akap*logp(i))
          pk(i, j, k) = EXP(akap*logp(i))
        END DO
!#ifdef USE_COND
!            peg(i,k) = peg(i,k-1) + delp(i,j,k-1)*(1.-q_con(i,j,k-1))
!            pkg(i,k) = exp( akap*log(peg(i,k)) )
!#endif
        IF (j .GT. js - 2 .AND. j .LT. je + 2) THEN
          IF (ifirst .LT. is - 1) THEN
            max2 = is - 1
          ELSE
            max2 = ifirst
          END IF
          IF (ilast .GT. ie + 1) THEN
            min2 = ie + 1
          ELSE
            min2 = ilast
          END IF
          DO i=max2,min2
            pe_tl(i, k, j) = p1d_tl(i)
            pe(i, k, j) = p1d(i)
          END DO
          IF (j .GE. js .AND. j .LE. je) THEN
            DO i=is,ie
              peln_tl(i, k, j) = logp_tl(i)
              peln(i, k, j) = logp(i)
            END DO
          END IF
        END IF
      END DO
! Bottom up
      DO k=km,1,-1
        DO i=ifirst,ilast
!#ifdef USE_COND
!            gz(i,j,k) = gz(i,j,k+1) + pt(i,j,k)*(pkg(i,k+1)-pkg(i,k))
!#else
          gz_tl(i, j, k) = gz_tl(i, j, k+1) + pt_tl(i, j, k)*(pk(i, j, k&
&           +1)-pk(i, j, k)) + pt(i, j, k)*(pk_tl(i, j, k+1)-pk_tl(i, j&
&           , k))
          gz(i, j, k) = gz(i, j, k+1) + pt(i, j, k)*(pk(i, j, k+1)-pk(i&
&           , j, k))
        END DO
      END DO
!#endif
      IF (.NOT.cg .AND. j .GE. js .AND. j .LE. je) THEN
        DO k=1,km
          DO i=is,ie
            pkz_tl(i, j, k) = ((pk_tl(i, j, k+1)-pk_tl(i, j, k))*akap*(&
&             peln(i, k+1, j)-peln(i, k, j))-(pk(i, j, k+1)-pk(i, j, k))&
&             *akap*(peln_tl(i, k+1, j)-peln_tl(i, k, j)))/(akap*(peln(i&
&             , k+1, j)-peln(i, k, j)))**2
            pkz(i, j, k) = (pk(i, j, k+1)-pk(i, j, k))/(akap*(peln(i, k+&
&             1, j)-peln(i, k, j)))
          END DO
        END DO
      END IF
    END DO
  END SUBROUTINE GEOPK_TLM
  SUBROUTINE GEOPK(ptop, pe, peln, delp, pk, gz, hs, pt, q_con, pkz, km&
&   , akap, cg, nested, computehalo, npx, npy, a2b_ord, bd)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: km, npx, npy, a2b_ord
    REAL(fvprc), INTENT(IN) :: akap, ptop
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: hs(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, km), INTENT(IN)&
&   :: pt, delp
    REAL(fvprc), DIMENSION(bd%isd:bd%isd, bd%jsd:bd%jsd, 1), INTENT(IN) &
&   :: q_con
    LOGICAL, INTENT(IN) :: cg, nested, computehalo
! !OUTPUT PARAMETERS
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, km+1), INTENT(&
&   OUT) :: gz, pk
    REAL(fvprc), INTENT(OUT) :: pe(bd%is-1:bd%ie+1, km+1, bd%js-1:bd%je+&
&   1)
! ln(pe)
    REAL(fvprc), INTENT(OUT) :: peln(bd%is:bd%ie, km+1, bd%js:bd%je)
    REAL(fvprc), INTENT(OUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, km)
! !DESCRIPTION:
!    Calculates geopotential and pressure to the kappa.
! Local:
    REAL(fvprc) :: peg(bd%isd:bd%ied, km+1)
    REAL(fvprc) :: pkg(bd%isd:bd%ied, km+1)
    REAL(fvprc) :: p1d(bd%isd:bd%ied)
    REAL(fvprc) :: logp(bd%isd:bd%ied)
    INTEGER :: i, j, k
    INTEGER :: ifirst, ilast
    INTEGER :: jfirst, jlast
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC LOG
    INTRINSIC EXP
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: min1
    INTEGER :: min2
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    IF ((.NOT.cg .AND. a2b_ord .EQ. 4) .OR. (nested .AND. (.NOT.cg))) &
&   THEN
! D-Grid
      ifirst = is - 2
      ilast = ie + 2
      jfirst = js - 2
      jlast = je + 2
    ELSE
      ifirst = is - 1
      ilast = ie + 1
      jfirst = js - 1
      jlast = je + 1
    END IF
    IF (nested .AND. computehalo) THEN
      IF (is .EQ. 1) ifirst = isd
      IF (ie .EQ. npx - 1) ilast = ied
      IF (js .EQ. 1) jfirst = jsd
      IF (je .EQ. npy - 1) jlast = jed
    END IF
!$OMP parallel do default(none) shared(jfirst,jlast,ifirst,ilast,pk,km,gz,hs,ptop,ptk, &
!$OMP                                  js,je,is,ie,peln,peln1,pe,delp,akap,pt,CG,pkz) &
!$OMP                          private(peg, pkg, p1d, logp)
    DO j=jfirst,jlast
      DO i=ifirst,ilast
        p1d(i) = ptop
        pk(i, j, 1) = ptk
        gz(i, j, km+1) = hs(i, j)
      END DO
!#ifdef USE_COND
!         peg(i,1) = ptop
!         pkg(i,1) = ptk
!#endif
!#ifndef SW_DYNAMICS
      IF (j .GE. js .AND. j .LE. je) THEN
        DO i=is,ie
          peln(i, 1, j) = peln1
        END DO
      END IF
!#endif
      IF (j .GT. js - 2 .AND. j .LT. je + 2) THEN
        IF (ifirst .LT. is - 1) THEN
          max1 = is - 1
        ELSE
          max1 = ifirst
        END IF
        IF (ilast .GT. ie + 1) THEN
          min1 = ie + 1
        ELSE
          min1 = ilast
        END IF
        DO i=max1,min1
          pe(i, 1, j) = ptop
        END DO
      END IF
! Top down
      DO k=2,km+1
        DO i=ifirst,ilast
          p1d(i) = p1d(i) + delp(i, j, k-1)
          logp(i) = LOG(p1d(i))
          pk(i, j, k) = EXP(akap*logp(i))
        END DO
!#ifdef USE_COND
!            peg(i,k) = peg(i,k-1) + delp(i,j,k-1)*(1.-q_con(i,j,k-1))
!            pkg(i,k) = exp( akap*log(peg(i,k)) )
!#endif
        IF (j .GT. js - 2 .AND. j .LT. je + 2) THEN
          IF (ifirst .LT. is - 1) THEN
            max2 = is - 1
          ELSE
            max2 = ifirst
          END IF
          IF (ilast .GT. ie + 1) THEN
            min2 = ie + 1
          ELSE
            min2 = ilast
          END IF
          DO i=max2,min2
            pe(i, k, j) = p1d(i)
          END DO
          IF (j .GE. js .AND. j .LE. je) THEN
            DO i=is,ie
              peln(i, k, j) = logp(i)
            END DO
          END IF
        END IF
      END DO
! Bottom up
      DO k=km,1,-1
        DO i=ifirst,ilast
!#ifdef USE_COND
!            gz(i,j,k) = gz(i,j,k+1) + pt(i,j,k)*(pkg(i,k+1)-pkg(i,k))
!#else
          gz(i, j, k) = gz(i, j, k+1) + pt(i, j, k)*(pk(i, j, k+1)-pk(i&
&           , j, k))
        END DO
      END DO
!#endif
      IF (.NOT.cg .AND. j .GE. js .AND. j .LE. je) THEN
        DO k=1,km
          DO i=is,ie
            pkz(i, j, k) = (pk(i, j, k+1)-pk(i, j, k))/(akap*(peln(i, k+&
&             1, j)-peln(i, k, j)))
          END DO
        END DO
      END IF
    END DO
  END SUBROUTINE GEOPK
!  Differentiation of del2_cubed in forward (tangent) mode (with options r8):
!   variations   of useful results: q
!   with respect to varying inputs: q
  SUBROUTINE DEL2_CUBED_TLM(q, q_tl, cd, gridstruct, domain, npx, npy, &
&   km, nmax, bd)
    IMPLICIT NONE
!---------------------------------------------------------------
! This routine is for filtering the omega field for the physics
!---------------------------------------------------------------
    INTEGER, INTENT(IN) :: npx, npy, km, nmax
! cd = K * da_min;   0 < K < 0.25
    REAL(kind=r_grid), INTENT(IN) :: cd
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(INOUT) :: q_tl(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    REAL(fvprc), PARAMETER :: r3=1./3.
    REAL(fvprc) :: fx(bd%isd:bd%ied+1, bd%jsd:bd%jed), fy(bd%isd:bd%ied&
&   , bd%jsd:bd%jed+1)
    REAL(fvprc) :: fx_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed), fy_tl(bd%isd:&
&   bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: q2(bd%isd:bd%ied, bd%jsd:bd%jed)
    INTEGER :: i, j, k, n, nt, ntimes
    LOGICAL, SAVE :: do_nullify=.false.
    INTRINSIC MIN
!Local routine pointers
!      real(FVPRC), pointer, dimension(:,:) :: rarea
!      real(FVPRC), pointer, dimension(:,:) :: sina_u, sina_v
!      real(FVPRC), pointer, dimension(:,:) :: rdxc, rdyc, dy
!      logical, pointer :: sw_corner, se_corner, ne_corner, nw_corner
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    IF (3 .GT. nmax) THEN
      ntimes = nmax
    ELSE
      ntimes = 3
    END IF
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
    CALL MPP_UPDATE_DOMAINS_TLM(q, q_tl, domain, complete=.true.)
    fx_tl = 0.0_FVPRC
    fy_tl = 0.0_FVPRC
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
    DO n=1,ntimes
      nt = ntimes - n
!$OMP parallel do default(none) shared(km,sw_corner,q,se_corner,is,ie,js,je,npx,npy, &
!$OMP                                  nw_corner,ne_corner,nt,isd,jsd,gridstruct,bd, &
!$OMP                                  dy,sina_u,rdxc,sina_v,rdyc,cd,rarea         ) &
!$OMP                          private(fx, fy)
      DO k=1,km
        IF (gridstruct%sw_corner) THEN
          q_tl(1, 1, k) = r3*(q_tl(1, 1, k)+q_tl(0, 1, k)+q_tl(1, 0, k))
          q(1, 1, k) = (q(1, 1, k)+q(0, 1, k)+q(1, 0, k))*r3
          q_tl(0, 1, k) = q_tl(1, 1, k)
          q(0, 1, k) = q(1, 1, k)
          q_tl(1, 0, k) = q_tl(1, 1, k)
          q(1, 0, k) = q(1, 1, k)
        END IF
        IF (gridstruct%se_corner) THEN
          q_tl(ie, 1, k) = r3*(q_tl(ie, 1, k)+q_tl(npx, 1, k)+q_tl(ie, 0&
&           , k))
          q(ie, 1, k) = (q(ie, 1, k)+q(npx, 1, k)+q(ie, 0, k))*r3
          q_tl(npx, 1, k) = q_tl(ie, 1, k)
          q(npx, 1, k) = q(ie, 1, k)
          q_tl(ie, 0, k) = q_tl(ie, 1, k)
          q(ie, 0, k) = q(ie, 1, k)
        END IF
        IF (gridstruct%ne_corner) THEN
          q_tl(ie, je, k) = r3*(q_tl(ie, je, k)+q_tl(npx, je, k)+q_tl(ie&
&           , npy, k))
          q(ie, je, k) = (q(ie, je, k)+q(npx, je, k)+q(ie, npy, k))*r3
          q_tl(npx, je, k) = q_tl(ie, je, k)
          q(npx, je, k) = q(ie, je, k)
          q_tl(ie, npy, k) = q_tl(ie, je, k)
          q(ie, npy, k) = q(ie, je, k)
        END IF
        IF (gridstruct%nw_corner) THEN
          q_tl(1, je, k) = r3*(q_tl(1, je, k)+q_tl(0, je, k)+q_tl(1, npy&
&           , k))
          q(1, je, k) = (q(1, je, k)+q(0, je, k)+q(1, npy, k))*r3
          q_tl(0, je, k) = q_tl(1, je, k)
          q(0, je, k) = q(1, je, k)
          q_tl(1, npy, k) = q_tl(1, je, k)
          q(1, npy, k) = q(1, je, k)
        END IF
        IF (nt .GT. 0) CALL COPY_CORNERS_TLM(q(isd:ied, jsd:jed, k), &
&                                      q_tl(isd:ied, jsd:jed, k), npx, &
&                                      npy, 1, gridstruct%nested, bd, &
&                                      gridstruct%sw_corner, gridstruct%&
&                                      se_corner, gridstruct%nw_corner, &
&                                      gridstruct%ne_corner)
        DO j=js-nt,je+nt
          DO i=is-nt,ie+1+nt
            fx_tl(i, j) = gridstruct%dy(i, j)*gridstruct%sina_u(i, j)*&
&             gridstruct%rdxc(i, j)*(q_tl(i-1, j, k)-q_tl(i, j, k))
            fx(i, j) = gridstruct%dy(i, j)*gridstruct%sina_u(i, j)*(q(i-&
&             1, j, k)-q(i, j, k))*gridstruct%rdxc(i, j)
          END DO
        END DO
        IF (nt .GT. 0) CALL COPY_CORNERS_TLM(q(isd:ied, jsd:jed, k), &
&                                      q_tl(isd:ied, jsd:jed, k), npx, &
&                                      npy, 2, gridstruct%nested, bd, &
&                                      gridstruct%sw_corner, gridstruct%&
&                                      se_corner, gridstruct%nw_corner, &
&                                      gridstruct%ne_corner)
        DO j=js-nt,je+1+nt
          DO i=is-nt,ie+nt
            fy_tl(i, j) = gridstruct%dx(i, j)*gridstruct%sina_v(i, j)*&
&             gridstruct%rdyc(i, j)*(q_tl(i, j-1, k)-q_tl(i, j, k))
            fy(i, j) = gridstruct%dx(i, j)*gridstruct%sina_v(i, j)*(q(i&
&             , j-1, k)-q(i, j, k))*gridstruct%rdyc(i, j)
          END DO
        END DO
        DO j=js-nt,je+nt
          DO i=is-nt,ie+nt
            q_tl(i, j, k) = q_tl(i, j, k) + cd*gridstruct%rarea(i, j)*(&
&             fx_tl(i, j)-fx_tl(i+1, j)+fy_tl(i, j)-fy_tl(i, j+1))
            q(i, j, k) = q(i, j, k) + cd*gridstruct%rarea(i, j)*(fx(i, j&
&             )-fx(i+1, j)+fy(i, j)-fy(i, j+1))
          END DO
        END DO
      END DO
    END DO
  END SUBROUTINE DEL2_CUBED_TLM
  SUBROUTINE DEL2_CUBED(q, cd, gridstruct, domain, npx, npy, km, nmax, &
&   bd)
    IMPLICIT NONE
!---------------------------------------------------------------
! This routine is for filtering the omega field for the physics
!---------------------------------------------------------------
    INTEGER, INTENT(IN) :: npx, npy, km, nmax
! cd = K * da_min;   0 < K < 0.25
    REAL(kind=r_grid), INTENT(IN) :: cd
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    REAL(fvprc), PARAMETER :: r3=1./3.
    REAL(fvprc) :: fx(bd%isd:bd%ied+1, bd%jsd:bd%jed), fy(bd%isd:bd%ied&
&   , bd%jsd:bd%jed+1)
    REAL(fvprc) :: q2(bd%isd:bd%ied, bd%jsd:bd%jed)
    INTEGER :: i, j, k, n, nt, ntimes
    LOGICAL, SAVE :: do_nullify=.false.
    INTRINSIC MIN
!Local routine pointers
!      real(FVPRC), pointer, dimension(:,:) :: rarea
!      real(FVPRC), pointer, dimension(:,:) :: sina_u, sina_v
!      real(FVPRC), pointer, dimension(:,:) :: rdxc, rdyc, dy
!      logical, pointer :: sw_corner, se_corner, ne_corner, nw_corner
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    IF (3 .GT. nmax) THEN
      ntimes = nmax
    ELSE
      ntimes = 3
    END IF
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
    CALL MPP_UPDATE_DOMAINS(q, domain, complete=.true.)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
    DO n=1,ntimes
      nt = ntimes - n
!$OMP parallel do default(none) shared(km,sw_corner,q,se_corner,is,ie,js,je,npx,npy, &
!$OMP                                  nw_corner,ne_corner,nt,isd,jsd,gridstruct,bd, &
!$OMP                                  dy,sina_u,rdxc,sina_v,rdyc,cd,rarea         ) &
!$OMP                          private(fx, fy)
      DO k=1,km
        IF (gridstruct%sw_corner) THEN
          q(1, 1, k) = (q(1, 1, k)+q(0, 1, k)+q(1, 0, k))*r3
          q(0, 1, k) = q(1, 1, k)
          q(1, 0, k) = q(1, 1, k)
        END IF
        IF (gridstruct%se_corner) THEN
          q(ie, 1, k) = (q(ie, 1, k)+q(npx, 1, k)+q(ie, 0, k))*r3
          q(npx, 1, k) = q(ie, 1, k)
          q(ie, 0, k) = q(ie, 1, k)
        END IF
        IF (gridstruct%ne_corner) THEN
          q(ie, je, k) = (q(ie, je, k)+q(npx, je, k)+q(ie, npy, k))*r3
          q(npx, je, k) = q(ie, je, k)
          q(ie, npy, k) = q(ie, je, k)
        END IF
        IF (gridstruct%nw_corner) THEN
          q(1, je, k) = (q(1, je, k)+q(0, je, k)+q(1, npy, k))*r3
          q(0, je, k) = q(1, je, k)
          q(1, npy, k) = q(1, je, k)
        END IF
        IF (nt .GT. 0) CALL COPY_CORNERS(q(isd:ied, jsd:jed, k), npx, &
&                                  npy, 1, gridstruct%nested, bd, &
&                                  gridstruct%sw_corner, gridstruct%&
&                                  se_corner, gridstruct%nw_corner, &
&                                  gridstruct%ne_corner)
        DO j=js-nt,je+nt
          DO i=is-nt,ie+1+nt
            fx(i, j) = gridstruct%dy(i, j)*gridstruct%sina_u(i, j)*(q(i-&
&             1, j, k)-q(i, j, k))*gridstruct%rdxc(i, j)
          END DO
        END DO
        IF (nt .GT. 0) CALL COPY_CORNERS(q(isd:ied, jsd:jed, k), npx, &
&                                  npy, 2, gridstruct%nested, bd, &
&                                  gridstruct%sw_corner, gridstruct%&
&                                  se_corner, gridstruct%nw_corner, &
&                                  gridstruct%ne_corner)
        DO j=js-nt,je+1+nt
          DO i=is-nt,ie+nt
            fy(i, j) = gridstruct%dx(i, j)*gridstruct%sina_v(i, j)*(q(i&
&             , j-1, k)-q(i, j, k))*gridstruct%rdyc(i, j)
          END DO
        END DO
        DO j=js-nt,je+nt
          DO i=is-nt,ie+nt
            q(i, j, k) = q(i, j, k) + cd*gridstruct%rarea(i, j)*(fx(i, j&
&             )-fx(i+1, j)+fy(i, j)-fy(i, j+1))
          END DO
        END DO
      END DO
    END DO
  END SUBROUTINE DEL2_CUBED
!  Differentiation of init_ijk_mem in forward (tangent) mode (with options r8):
!   variations   of useful results: array
!   with respect to varying inputs: array
  SUBROUTINE INIT_IJK_MEM_TLM(i1, i2, j1, j2, km, array, array_tl, var)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: i1, i2, j1, j2, km
    REAL(fvprc), INTENT(INOUT) :: array(i1:i2, j1:j2, km)
    REAL(fvprc), INTENT(INOUT) :: array_tl(i1:i2, j1:j2, km)
    REAL(fvprc), INTENT(IN) :: var
    INTEGER :: i, j, k
!$OMP parallel do default(none) shared(i1,i2,j1,j2,km,array,var)
    DO k=1,km
      DO j=j1,j2
        DO i=i1,i2
          array_tl(i, j, k) = 0.0_FVPRC
          array(i, j, k) = var
        END DO
      END DO
    END DO
  END SUBROUTINE INIT_IJK_MEM_TLM
  SUBROUTINE INIT_IJK_MEM(i1, i2, j1, j2, km, array, var)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: i1, i2, j1, j2, km
    REAL(fvprc), INTENT(INOUT) :: array(i1:i2, j1:j2, km)
    REAL(fvprc), INTENT(IN) :: var
    INTEGER :: i, j, k
!$OMP parallel do default(none) shared(i1,i2,j1,j2,km,array,var)
    DO k=1,km
      DO j=j1,j2
        DO i=i1,i2
          array(i, j, k) = var
        END DO
      END DO
    END DO
  END SUBROUTINE INIT_IJK_MEM
END MODULE DYN_CORE_MOD_D
