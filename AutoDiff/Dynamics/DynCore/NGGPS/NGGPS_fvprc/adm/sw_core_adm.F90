!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
MODULE SW_CORE_MOD_B
  USE FV_MP_MOD_B, ONLY : ng
  USE TP_CORE_MOD_B, ONLY : fv_tp_2d, fv_tp_2d_adm, fv_tp_2d, &
& fv_tp_2d_adm, pert_ppm, pert_ppm_adm, copy_corners, &
& copy_corners_adm
  USE FV_MP_MOD_B, ONLY : fill_corners, fill_corners_adm, xdir, ydir
  USE FV_ARRAYS_MOD_B, ONLY : fv_grid_type, fv_grid_bounds_type, &
& fv_flags_type
  USE FV_ARRAYS_MOD_B, ONLY : real4, real8, 8
  USE A2B_EDGE_MOD_B, ONLY : a2b_ord4, a2b_ord4_adm, a2b_ord4, &
& a2b_ord4_adm
  IMPLICIT NONE
  REAL(fvprc), PARAMETER :: r3=1./3.
  REAL(fvprc), PARAMETER :: t11=27./28., t12=-(13./28.), t13=3./7., t14=&
&   6./7., t15=3./28.
  REAL(fvprc), PARAMETER :: s11=11./14., s13=-(13./14.), s14=4./7., s15=&
&   3./14.
! for KE limiter
  REAL(fvprc), PARAMETER :: near_zero=1.e-9
  REAL(fvprc), PARAMETER :: big_number=1.e8
!----------------------
! PPM volume mean form:
!----------------------
! 0.58333333
  REAL(fvprc), PARAMETER :: p1=7./12.
  REAL(fvprc), PARAMETER :: p2=-(1./12.)
!----------------------------
! 4-pt Lagrange interpolation
!----------------------------
  REAL(fvprc), PARAMETER :: a1=0.5625
  REAL(fvprc), PARAMETER :: a2=-0.0625
!----------------------------------------------
! volume-conserving cubic with 2nd drv=0 at end point:
  REAL(fvprc), PARAMETER :: c1=-(2./14.)
  REAL(fvprc), PARAMETER :: c2=11./14.
  REAL(fvprc), PARAMETER :: c3=5./14.
! 3-pt off-center intp formular:
! real(FVPRC), parameter:: c1 = -0.125
! real(FVPRC), parameter:: c2 =  0.75
! real(FVPRC), parameter:: c3 =  0.375
!----------------------------------------------
! scheme 2.1: perturbation form
  REAL(fvprc), PARAMETER :: b1=1./30.
  REAL(fvprc), PARAMETER :: b2=-(13./60.)
  REAL(fvprc), PARAMETER :: b3=-(13./60.)
  REAL(fvprc), PARAMETER :: b4=0.45
  REAL(fvprc), PARAMETER :: b5=-0.05
!logical:: sw_corner, se_corner, ne_corner, nw_corner 
!---- version number -----
!  character(len=128) :: version = '$Id: sw_core.F90,v 1.2.2.1.2.1.30.1.6.1.50.3.6.1.2.1.4.1 2017/02/16 03:47:48 aoloso Exp $'
!  character(len=128) :: tagname = '$Name: Heracles-UNSTABLE_ncepdyn_Feb222017 $'
  PRIVATE 
  PUBLIC c_sw, d_sw, fill_4corners, del6_vt_flux, d2a2c_vect
  PUBLIC c_sw_fwd, c_sw_bwd, d_sw_fwd, d_sw_bwd, fill_4corners_fwd, &
& fill_4corners_bwd, del6_vt_flux_adm, d2a2c_vect_fwd, d2a2c_vect_bwd
  EXTERNAL D_SW_ADM
  EXTERNAL C_SW_ADM
  EXTERNAL FILL_4CORNERS_ADM

CONTAINS
!  Differentiation of c_sw in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod.a2b
!_ord4_fb a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo d
!yn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.g
!rad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.rayleig
!h_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to_lat
!lon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energy fv
!_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mod.m
!ap1_q2_fb fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv_tra
!cer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver_c n
!h_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core_mod
!.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_corn
!er_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.co
!mpute_div_damping_fb sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mod.co
!py_corners_fb tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_mod.f
!yppm_fb tp_core_mod.deln_flux)):
!   gradient     of useful results: u v w delp ua uc ptc ut delpc
!                va vc vt divg_d wc pt
!   with respect to varying inputs: u v w delp ua uc ptc ut delpc
!                va vc vt divg_d wc pt
  SUBROUTINE C_SW_FWD(delpc, delp, ptc, pt, u, v, w, uc, vc, ua, va, wc&
&   , ut, vt, divg_d, nord, dt2, hydrostatic, dord4, bd, gridstruct, &
&   flagstruct)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u, vc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v, uc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delp, pt, ua, va, ut, vt, w
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: delpc, ptc, &
&   wc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1) :: divg_d
    INTEGER, INTENT(IN) :: nord
    REAL(fvprc), INTENT(IN) :: dt2
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: dord4
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
! Local:
    REAL(fvprc), DIMENSION(bd%is-1:bd%ie+1, bd%js-1:bd%je+1) :: vort, ke
    REAL(fvprc), DIMENSION(bd%is-1:bd%ie+2, bd%js-1:bd%je+1) :: fx, fx1&
&   , fx2
    REAL(fvprc), DIMENSION(bd%is-1:bd%ie+1, bd%js-1:bd%je+2) :: fy, fy1&
&   , fy2
    REAL(fvprc) :: dt4
    INTEGER :: i, j, is2, ie1
    INTEGER :: iep1, jep1
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTEGER :: npx, npy
    LOGICAL :: nested
!      real(FVPRC), pointer, dimension(:,:)   :: rarea, rarea_c
!      real(FVPRC), pointer, dimension(:,:,:) :: sin_sg, cos_sg
!      real(FVPRC), pointer, dimension(:,:)   :: cosa_u, cosa_v
!      real(FVPRC), pointer, dimension(:,:)   :: sina_u, sina_v
!      real(FVPRC), pointer, dimension(:,:) :: fC
!      real(FVPRC), pointer, dimension(:,:) :: rdxc, rdyc, dx, dy, dxc, dyc
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    npx = flagstruct%npx
    npy = flagstruct%npy
    nested = gridstruct%nested
!      rarea   => gridstruct%rarea
!      rarea_c => gridstruct%rarea_c
!      sin_sg  => gridstruct%sin_sg
!      cos_sg  => gridstruct%cos_sg
!      cosa_u  => gridstruct%cosa_u
!      cosa_v  => gridstruct%cosa_v
!      sina_u  => gridstruct%sina_u
!      sina_v  => gridstruct%sina_v
!      fC      => gridstruct%fC
!      rdxc    => gridstruct%rdxc
!      rdyc    => gridstruct%rdyc
!      dx      => gridstruct%dx
!      dy      => gridstruct%dy
!      dxc     => gridstruct%dxc
!      dyc     => gridstruct%dyc
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
    iep1 = ie + 1
    jep1 = je + 1
    CALL D2A2C_VECT_FWD(u, v, ua, va, uc, vc, ut, vt, dord4, gridstruct&
&                 , bd, npx, npy, nested, flagstruct%grid_type)
    IF (nord .GT. 0) THEN
      IF (nested) THEN
        CALL DIVERGENCE_CORNER_NEST_FWD(u, v, ua, va, divg_d, gridstruct&
&                                 , flagstruct, bd)
        CALL PUSHCONTROL2B_FV(2)
      ELSE
        CALL DIVERGENCE_CORNER_FWD(u, v, ua, va, divg_d, gridstruct, &
&                            flagstruct, bd)
        CALL PUSHCONTROL2B_FV(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B_FV(0)
    END IF
!!! TO DO: remove 'test_up'
!!!   check repro with siena
    DO j=js-1,jep1
      DO i=is-1,iep1+1
        IF (ut(i, j) .GT. 0.) THEN
          CALL PUSHREALARRAY(ut(i, j))
          ut(i, j) = dt2*ut(i, j)*gridstruct%dy(i, j)*gridstruct%sin_sg(&
&           i-1, j, 3)
          CALL PUSHCONTROL1B_FV(1)
        ELSE
          CALL PUSHREALARRAY(ut(i, j))
          ut(i, j) = dt2*ut(i, j)*gridstruct%dy(i, j)*gridstruct%sin_sg(&
&           i, j, 1)
          CALL PUSHCONTROL1B_FV(0)
        END IF
      END DO
    END DO
    DO j=js-1,je+2
      DO i=is-1,iep1
        IF (vt(i, j) .GT. 0.) THEN
          CALL PUSHREALARRAY(vt(i, j))
          vt(i, j) = dt2*vt(i, j)*gridstruct%dx(i, j)*gridstruct%sin_sg(&
&           i, j-1, 4)
          CALL PUSHCONTROL1B_FV(1)
        ELSE
          CALL PUSHREALARRAY(vt(i, j))
          vt(i, j) = dt2*vt(i, j)*gridstruct%dx(i, j)*gridstruct%sin_sg(&
&           i, j, 2)
          CALL PUSHCONTROL1B_FV(0)
        END IF
      END DO
    END DO
!----------------
! Transport delp:
!----------------
! Xdir:
    IF (flagstruct%grid_type .LT. 3 .AND. (.NOT.nested)) THEN
      CALL FILL2_4CORNERS_FWD(delp, pt, 1, bd, npx, npy, sw_corner, &
&                       se_corner, ne_corner, nw_corner)
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
    IF (hydrostatic) THEN
!#ifdef SW_DYNAMICS
!           do j=js-1,jep1
!              do i=is-1,ie+2
!                 if ( ut(i,j) > 0. ) then
!                      fx1(i,j) = delp(i-1,j)
!                 else
!                      fx1(i,j) = delp(i,j)
!                 endif
!                 fx1(i,j) =  ut(i,j)*fx1(i,j)
!              enddo
!           enddo
!#else
      DO j=js-1,jep1
        DO i=is-1,ie+2
          IF (ut(i, j) .GT. 0.) THEN
            fx1(i, j) = delp(i-1, j)
            fx(i, j) = pt(i-1, j)
            CALL PUSHCONTROL1B_FV(0)
          ELSE
            fx1(i, j) = delp(i, j)
            fx(i, j) = pt(i, j)
            CALL PUSHCONTROL1B_FV(1)
          END IF
          CALL PUSHREALARRAY(fx1(i, j))
          fx1(i, j) = ut(i, j)*fx1(i, j)
          CALL PUSHREALARRAY(fx(i, j))
          fx(i, j) = fx1(i, j)*fx(i, j)
        END DO
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
!#endif
      IF (flagstruct%grid_type .LT. 3) THEN
        CALL FILL_4CORNERS_FWD(w, 1, bd, npx, npy, sw_corner, se_corner&
&                        , ne_corner, nw_corner)
        CALL PUSHCONTROL1B_FV(1)
      ELSE
        CALL PUSHCONTROL1B_FV(0)
      END IF
      DO j=js-1,je+1
        DO i=is-1,ie+2
          IF (ut(i, j) .GT. 0.) THEN
            fx1(i, j) = delp(i-1, j)
            fx(i, j) = pt(i-1, j)
            fx2(i, j) = w(i-1, j)
            CALL PUSHCONTROL1B_FV(0)
          ELSE
            fx1(i, j) = delp(i, j)
            fx(i, j) = pt(i, j)
            fx2(i, j) = w(i, j)
            CALL PUSHCONTROL1B_FV(1)
          END IF
          CALL PUSHREALARRAY(fx1(i, j))
          fx1(i, j) = ut(i, j)*fx1(i, j)
          CALL PUSHREALARRAY(fx(i, j))
          fx(i, j) = fx1(i, j)*fx(i, j)
          CALL PUSHREALARRAY(fx2(i, j))
          fx2(i, j) = fx1(i, j)*fx2(i, j)
        END DO
      END DO
      CALL PUSHCONTROL1B_FV(1)
    END IF
! Ydir:
    IF (flagstruct%grid_type .LT. 3 .AND. (.NOT.nested)) THEN
      CALL FILL2_4CORNERS_FWD(delp, pt, 2, bd, npx, npy, sw_corner, &
&                       se_corner, ne_corner, nw_corner)
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
    IF (hydrostatic) THEN
      DO j=js-1,jep1+1
        DO i=is-1,iep1
          IF (vt(i, j) .GT. 0.) THEN
            fy1(i, j) = delp(i, j-1)
            fy(i, j) = pt(i, j-1)
            CALL PUSHCONTROL1B_FV(0)
          ELSE
            fy1(i, j) = delp(i, j)
            fy(i, j) = pt(i, j)
            CALL PUSHCONTROL1B_FV(1)
          END IF
          CALL PUSHREALARRAY(fy1(i, j))
          fy1(i, j) = vt(i, j)*fy1(i, j)
          CALL PUSHREALARRAY(fy(i, j))
          fy(i, j) = fy1(i, j)*fy(i, j)
        END DO
      END DO
      CALL PUSHREALARRAY(delpc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+&
&                   1)/8)
      CALL PUSHREALARRAY(ptc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                   /8)
      CALL PUSHINTEGER(is)
      CALL PUSHREALARRAY(fx, 8*(bd%ie-bd%is+4)*(bd%je-bd%js+3)/8)
      CALL PUSHREALARRAY(fy, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+4)/8)
      DO j=js-1,jep1
        DO i=is-1,iep1
          delpc(i, j) = delp(i, j) + (fx1(i, j)-fx1(i+1, j)+fy1(i, j)-&
&           fy1(i, j+1))*gridstruct%rarea(i, j)
!#ifdef SW_DYNAMICS
!                   ptc(i,j) = pt(i,j)
!#else
          ptc(i, j) = (pt(i, j)*delp(i, j)+(fx(i, j)-fx(i+1, j)+fy(i, j)&
&           -fy(i, j+1))*gridstruct%rarea(i, j))/delpc(i, j)
        END DO
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
!#endif
      IF (flagstruct%grid_type .LT. 3) THEN
        CALL FILL_4CORNERS_FWD(w, 2, bd, npx, npy, sw_corner, se_corner&
&                        , ne_corner, nw_corner)
        CALL PUSHCONTROL1B_FV(1)
      ELSE
        CALL PUSHCONTROL1B_FV(0)
      END IF
      DO j=js-1,je+2
        DO i=is-1,ie+1
          IF (vt(i, j) .GT. 0.) THEN
            fy1(i, j) = delp(i, j-1)
            fy(i, j) = pt(i, j-1)
            fy2(i, j) = w(i, j-1)
            CALL PUSHCONTROL1B_FV(0)
          ELSE
            fy1(i, j) = delp(i, j)
            fy(i, j) = pt(i, j)
            fy2(i, j) = w(i, j)
            CALL PUSHCONTROL1B_FV(1)
          END IF
          CALL PUSHREALARRAY(fy1(i, j))
          fy1(i, j) = vt(i, j)*fy1(i, j)
          CALL PUSHREALARRAY(fy(i, j))
          fy(i, j) = fy1(i, j)*fy(i, j)
          CALL PUSHREALARRAY(fy2(i, j))
          fy2(i, j) = fy1(i, j)*fy2(i, j)
        END DO
      END DO
      DO j=js-1,je+1
        DO i=is-1,ie+1
          CALL PUSHREALARRAY(delpc(i, j))
          delpc(i, j) = delp(i, j) + (fx1(i, j)-fx1(i+1, j)+fy1(i, j)-&
&           fy1(i, j+1))*gridstruct%rarea(i, j)
          CALL PUSHREALARRAY(ptc(i, j))
          ptc(i, j) = (pt(i, j)*delp(i, j)+(fx(i, j)-fx(i+1, j)+fy(i, j)&
&           -fy(i, j+1))*gridstruct%rarea(i, j))/delpc(i, j)
          CALL PUSHREALARRAY(wc(i, j))
          wc(i, j) = (w(i, j)*delp(i, j)+(fx2(i, j)-fx2(i+1, j)+fy2(i, j&
&           )-fy2(i, j+1))*gridstruct%rarea(i, j))/delpc(i, j)
        END DO
      END DO
      CALL PUSHCONTROL1B_FV(1)
    END IF
!------------
! Compute KE:
!------------
!Since uc = u*, i.e. the covariant wind perpendicular to the face edge, if we want to compute kinetic energy we will need the tru
!e coordinate-parallel covariant wind, computed through u = uc*sina + v*cosa. 
!Use the alpha for the cell KE is being computed in.
!!! TO DO:
!!! Need separate versions for nesting/single-tile
!!!   and for cubed-sphere
    IF (nested .OR. flagstruct%grid_type .GE. 3) THEN
      DO j=js-1,jep1
        DO i=is-1,iep1
          IF (ua(i, j) .GT. 0.) THEN
            ke(i, j) = uc(i, j)
            CALL PUSHCONTROL1B_FV(1)
          ELSE
            ke(i, j) = uc(i+1, j)
            CALL PUSHCONTROL1B_FV(0)
          END IF
        END DO
      END DO
      DO j=js-1,jep1
        DO i=is-1,iep1
          IF (va(i, j) .GT. 0.) THEN
            vort(i, j) = vc(i, j)
            CALL PUSHCONTROL1B_FV(1)
          ELSE
            vort(i, j) = vc(i, j+1)
            CALL PUSHCONTROL1B_FV(0)
          END IF
        END DO
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      DO j=js-1,jep1
        DO i=is-1,iep1
          IF (ua(i, j) .GT. 0.) THEN
            IF (i .EQ. 1) THEN
              ke(1, j) = uc(1, j)*gridstruct%sin_sg(1, j, 1) + v(1, j)*&
&               gridstruct%cos_sg(1, j, 1)
              CALL PUSHCONTROL3B_FV(5)
            ELSE IF (i .EQ. npx) THEN
              ke(i, j) = uc(npx, j)*gridstruct%sin_sg(npx, j, 1) + v(npx&
&               , j)*gridstruct%cos_sg(npx, j, 1)
              CALL PUSHCONTROL3B_FV(4)
            ELSE
              ke(i, j) = uc(i, j)
              CALL PUSHCONTROL3B_FV(3)
            END IF
          ELSE IF (i .EQ. 0) THEN
            ke(0, j) = uc(1, j)*gridstruct%sin_sg(0, j, 3) + v(1, j)*&
&             gridstruct%cos_sg(0, j, 3)
            CALL PUSHCONTROL3B_FV(2)
          ELSE IF (i .EQ. npx - 1) THEN
            ke(i, j) = uc(npx, j)*gridstruct%sin_sg(npx-1, j, 3) + v(npx&
&             , j)*gridstruct%cos_sg(npx-1, j, 3)
            CALL PUSHCONTROL3B_FV(1)
          ELSE
            ke(i, j) = uc(i+1, j)
            CALL PUSHCONTROL3B_FV(0)
          END IF
        END DO
      END DO
      DO j=js-1,jep1
        DO i=is-1,iep1
          IF (va(i, j) .GT. 0.) THEN
            IF (j .EQ. 1) THEN
              vort(i, 1) = vc(i, 1)*gridstruct%sin_sg(i, 1, 2) + u(i, 1)&
&               *gridstruct%cos_sg(i, 1, 2)
              CALL PUSHCONTROL3B_FV(5)
            ELSE IF (j .EQ. npy) THEN
              vort(i, j) = vc(i, npy)*gridstruct%sin_sg(i, npy, 2) + u(i&
&               , npy)*gridstruct%cos_sg(i, npy, 2)
              CALL PUSHCONTROL3B_FV(4)
            ELSE
              vort(i, j) = vc(i, j)
              CALL PUSHCONTROL3B_FV(3)
            END IF
          ELSE IF (j .EQ. 0) THEN
            vort(i, 0) = vc(i, 1)*gridstruct%sin_sg(i, 0, 4) + u(i, 1)*&
&             gridstruct%cos_sg(i, 0, 4)
            CALL PUSHCONTROL3B_FV(2)
          ELSE IF (j .EQ. npy - 1) THEN
            vort(i, j) = vc(i, npy)*gridstruct%sin_sg(i, npy-1, 4) + u(i&
&             , npy)*gridstruct%cos_sg(i, npy-1, 4)
            CALL PUSHCONTROL3B_FV(1)
          ELSE
            vort(i, j) = vc(i, j+1)
            CALL PUSHCONTROL3B_FV(0)
          END IF
        END DO
      END DO
      CALL PUSHCONTROL1B_FV(1)
    END IF
    dt4 = 0.5*dt2
    CALL PUSHREALARRAY(ke, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+3)/8)
    CALL PUSHREALARRAY(dt4)
    CALL PUSHREALARRAY(vort, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+3)/8)
    CALL PUSHINTEGER(is)
    DO j=js-1,jep1
      DO i=is-1,iep1
        ke(i, j) = dt4*(ua(i, j)*ke(i, j)+va(i, j)*vort(i, j))
      END DO
    END DO
    CALL PUSHINTEGER(ie)
    CALL PUSHINTEGER(is)
    CALL PUSHREALARRAY(fx, 8*(bd%ie-bd%is+4)*(bd%je-bd%js+3)/8)
!------------------------------
! Compute circulation on C grid
!------------------------------
! To consider using true co-variant winds at face edges?
    DO j=js-1,je+1
      DO i=is,ie+1
        fx(i, j) = uc(i, j)*gridstruct%dxc(i, j)
      END DO
    END DO
    CALL PUSHINTEGER(ie)
    CALL PUSHREALARRAY(fy, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+4)/8)
    DO j=js,je+1
      DO i=is-1,ie+1
        fy(i, j) = vc(i, j)*gridstruct%dyc(i, j)
      END DO
    END DO
    CALL PUSHINTEGER(ie)
    CALL PUSHREALARRAY(vort, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+3)/8)
    DO j=js,je+1
      DO i=is,ie+1
        vort(i, j) = fx(i, j-1) - fx(i, j) - fy(i-1, j) + fy(i, j)
      END DO
    END DO
! Remove the extra term at the corners:
    IF (sw_corner) THEN
      CALL PUSHREALARRAY(vort(1, 1))
      vort(1, 1) = vort(1, 1) + fy(0, 1)
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
    IF (se_corner) THEN
      CALL PUSHREALARRAY(vort(npx, 1))
      vort(npx, 1) = vort(npx, 1) - fy(npx, 1)
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
    IF (ne_corner) THEN
      CALL PUSHREALARRAY(vort(npx, npy))
      vort(npx, npy) = vort(npx, npy) - fy(npx, npy)
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
    IF (nw_corner) THEN
      CALL PUSHREALARRAY(vort(1, npy))
      vort(1, npy) = vort(1, npy) + fy(0, npy)
      CALL PUSHCONTROL1B_FV(1)
    ELSE
      CALL PUSHCONTROL1B_FV(0)
    END IF
    CALL PUSHINTEGER(ie)
    CALL PUSHREALARRAY(vort, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+3)/8)
!----------------------------
! Compute absolute vorticity
!----------------------------
    DO j=js,je+1
      DO i=is,ie+1
        vort(i, j) = gridstruct%fc(i, j) + gridstruct%rarea_c(i, j)*vort&
&         (i, j)
      END DO
    END DO
!----------------------------------
! Transport absolute vorticity:
!----------------------------------
!To go from v to contravariant v at the edges, we divide by sin_sg;
! but we then must multiply by sin_sg to get the proper flux.
! These cancel, leaving us with fy1 = dt2*v at the edges.
! (For the same reason we only divide by sin instead of sin**2 in the interior)
!! TO DO: separate versions for nesting/single-tile and cubed-sphere
    IF (nested .OR. flagstruct%grid_type .GE. 3) THEN
      DO j=js,je
        DO i=is,iep1
          CALL PUSHREALARRAY(fy1(i, j))
          fy1(i, j) = dt2*(v(i, j)-uc(i, j)*gridstruct%cosa_u(i, j))/&
&           gridstruct%sina_u(i, j)
          IF (fy1(i, j) .GT. 0.) THEN
            CALL PUSHREALARRAY(fy(i, j))
            fy(i, j) = vort(i, j)
            CALL PUSHCONTROL1B_FV(1)
          ELSE
            CALL PUSHREALARRAY(fy(i, j))
            fy(i, j) = vort(i, j+1)
            CALL PUSHCONTROL1B_FV(0)
          END IF
        END DO
      END DO
      DO j=js,jep1
        DO i=is,ie
          CALL PUSHREALARRAY(fx1(i, j))
          fx1(i, j) = dt2*(u(i, j)-vc(i, j)*gridstruct%cosa_v(i, j))/&
&           gridstruct%sina_v(i, j)
          IF (fx1(i, j) .GT. 0.) THEN
            CALL PUSHREALARRAY(fx(i, j))
            fx(i, j) = vort(i, j)
            CALL PUSHCONTROL1B_FV(1)
          ELSE
            CALL PUSHREALARRAY(fx(i, j))
            fx(i, j) = vort(i+1, j)
            CALL PUSHCONTROL1B_FV(0)
          END IF
        END DO
      END DO
      CALL PUSHCONTROL1B_FV(1)
    ELSE
      DO j=js,je
!DEC$ VECTOR ALWAYS
        DO i=is,iep1
          IF (i .EQ. 1 .OR. i .EQ. npx) THEN
            CALL PUSHREALARRAY(fy1(i, j))
            fy1(i, j) = dt2*v(i, j)
            CALL PUSHCONTROL1B_FV(0)
          ELSE
            CALL PUSHREALARRAY(fy1(i, j))
            fy1(i, j) = dt2*(v(i, j)-uc(i, j)*gridstruct%cosa_u(i, j))/&
&             gridstruct%sina_u(i, j)
            CALL PUSHCONTROL1B_FV(1)
          END IF
          IF (fy1(i, j) .GT. 0.) THEN
            CALL PUSHREALARRAY(fy(i, j))
            fy(i, j) = vort(i, j)
            CALL PUSHCONTROL1B_FV(1)
          ELSE
            CALL PUSHREALARRAY(fy(i, j))
            fy(i, j) = vort(i, j+1)
            CALL PUSHCONTROL1B_FV(0)
          END IF
        END DO
      END DO
      DO j=js,jep1
        IF (j .EQ. 1 .OR. j .EQ. npy) THEN
!DEC$ VECTOR ALWAYS
          DO i=is,ie
            CALL PUSHREALARRAY(fx1(i, j))
            fx1(i, j) = dt2*u(i, j)
            IF (fx1(i, j) .GT. 0.) THEN
              CALL PUSHREALARRAY(fx(i, j))
              fx(i, j) = vort(i, j)
              CALL PUSHCONTROL1B_FV(1)
            ELSE
              CALL PUSHREALARRAY(fx(i, j))
              fx(i, j) = vort(i+1, j)
              CALL PUSHCONTROL1B_FV(0)
            END IF
          END DO
          CALL PUSHCONTROL1B_FV(1)
        ELSE
!DEC$ VECTOR ALWAYS
          DO i=is,ie
            CALL PUSHREALARRAY(fx1(i, j))
            fx1(i, j) = dt2*(u(i, j)-vc(i, j)*gridstruct%cosa_v(i, j))/&
&             gridstruct%sina_v(i, j)
            IF (fx1(i, j) .GT. 0.) THEN
              CALL PUSHREALARRAY(fx(i, j))
              fx(i, j) = vort(i, j)
              CALL PUSHCONTROL1B_FV(1)
            ELSE
              CALL PUSHREALARRAY(fx(i, j))
              fx(i, j) = vort(i+1, j)
              CALL PUSHCONTROL1B_FV(0)
            END IF
          END DO
          CALL PUSHCONTROL1B_FV(0)
        END IF
      END DO
      CALL PUSHCONTROL1B_FV(0)
    END IF
! Update time-centered winds on the C-Grid
    DO j=js,je
      DO i=is,iep1
        uc(i, j) = uc(i, j) + fy1(i, j)*fy(i, j) + gridstruct%rdxc(i, j)&
&         *(ke(i-1, j)-ke(i, j))
      END DO
    END DO
    DO j=js,jep1
      DO i=is,ie
        vc(i, j) = vc(i, j) - fx1(i, j)*fx(i, j) + gridstruct%rdyc(i, j)&
&         *(ke(i, j-1)-ke(i, j))
      END DO
    END DO
    CALL PUSHINTEGER(js)
    CALL PUSHINTEGER(npx)
    CALL PUSHINTEGER(npy)
    CALL PUSHREALARRAY(fy1, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+4)/8)
    CALL PUSHREALARRAY(fy2, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+4)/8)
    CALL PUSHINTEGER(jep1)
    CALL PUSHINTEGER(iep1)
    CALL PUSHREALARRAY(dt4)
    CALL PUSHINTEGER(ie)
    CALL PUSHREALARRAY(vort, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+3)/8)
    CALL PUSHINTEGER(is)
    CALL PUSHREALARRAY(fx, 8*(bd%ie-bd%is+4)*(bd%je-bd%js+3)/8)
    CALL PUSHREALARRAY(fy, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+4)/8)
    CALL PUSHINTEGER(je)
    CALL PUSHREALARRAY(fx1, 8*(bd%ie-bd%is+4)*(bd%je-bd%js+3)/8)
    CALL PUSHREALARRAY(fx2, 8*(bd%ie-bd%is+4)*(bd%je-bd%js+3)/8)
  END SUBROUTINE C_SW_FWD
!  Differentiation of c_sw in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod.a2
!b_ord4_fb a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo 
!dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.
!grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.raylei
!gh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to_la
!tlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energy f
!v_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mod.
!map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv_tr
!acer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver_c 
!nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core_mo
!d.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_cor
!ner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.c
!ompute_div_damping_fb sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mod.c
!opy_corners_fb tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_mod.
!fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: u v w delp ua uc ptc ut delpc
!                va vc vt divg_d wc pt
!   with respect to varying inputs: u v w delp ua uc ptc ut delpc
!                va vc vt divg_d wc pt
  SUBROUTINE C_SW_BWD(delpc, delpc_ad, delp, delp_ad, ptc, ptc_ad, pt, &
&   pt_ad, u, u_ad, v, v_ad, w, w_ad, uc, uc_ad, vc, vc_ad, ua, ua_ad, &
&   va, va_ad, wc, wc_ad, ut, ut_ad, vt, vt_ad, divg_d, divg_d_ad, nord&
&   , dt2, hydrostatic, dord4, bd, gridstruct, flagstruct)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u, vc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u_ad, vc_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v, uc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v_ad, uc_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delp, pt, ua, va, ut, vt, w
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delp_ad, pt_ad, ua_ad, va_ad, ut_ad, vt_ad, w_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: delpc, ptc, &
&   wc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: delpc_ad, &
&   ptc_ad, wc_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1) :: divg_d
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1) :: &
&   divg_d_ad
    INTEGER, INTENT(IN) :: nord
    REAL(fvprc), INTENT(IN) :: dt2
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: dord4
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
    REAL(fvprc), DIMENSION(bd%is-1:bd%ie+1, bd%js-1:bd%je+1) :: vort, ke
    REAL(fvprc), DIMENSION(bd%is-1:bd%ie+1, bd%js-1:bd%je+1) :: vort_ad&
&   , ke_ad
    REAL(fvprc), DIMENSION(bd%is-1:bd%ie+2, bd%js-1:bd%je+1) :: fx, fx1&
&   , fx2
    REAL(fvprc), DIMENSION(bd%is-1:bd%ie+2, bd%js-1:bd%je+1) :: fx_ad, &
&   fx1_ad, fx2_ad
    REAL(fvprc), DIMENSION(bd%is-1:bd%ie+1, bd%js-1:bd%je+2) :: fy, fy1&
&   , fy2
    REAL(fvprc), DIMENSION(bd%is-1:bd%ie+1, bd%js-1:bd%je+2) :: fy_ad, &
&   fy1_ad, fy2_ad
    REAL(fvprc) :: dt4
    INTEGER :: i, j, is2, ie1
    INTEGER :: iep1, jep1
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTEGER :: npx, npy
    LOGICAL :: nested
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp_ad4
    REAL(fvprc) :: temp_ad5
    REAL(fvprc) :: temp_ad6
    REAL(fvprc) :: temp_ad7
    REAL(fvprc) :: temp_ad8
    REAL(fvprc) :: temp_ad9
    INTEGER :: branch
    REAL(fvprc) :: temp_ad10
    REAL(fvprc) :: temp_ad11
    REAL(fvprc) :: temp_ad12
    REAL(fvprc) :: temp_ad13
    CALL POPREALARRAY(fx2, 8*(bd%ie-bd%is+4)*(bd%je-bd%js+3)/8)
    CALL POPREALARRAY(fx1, 8*(bd%ie-bd%is+4)*(bd%je-bd%js+3)/8)
    CALL POPINTEGER(je)
    CALL POPREALARRAY(fy, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+4)/8)
    CALL POPREALARRAY(fx, 8*(bd%ie-bd%is+4)*(bd%je-bd%js+3)/8)
    CALL POPINTEGER(is)
    CALL POPREALARRAY(vort, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+3)/8)
    CALL POPINTEGER(ie)
    CALL POPREALARRAY(dt4)
    CALL POPINTEGER(iep1)
    CALL POPINTEGER(jep1)
    CALL POPREALARRAY(fy2, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+4)/8)
    CALL POPREALARRAY(fy1, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+4)/8)
    CALL POPINTEGER(npy)
    CALL POPINTEGER(npx)
    CALL POPINTEGER(js)
    ke_ad = 0.0_FVPRC
    fx_ad = 0.0_FVPRC
    fx1_ad = 0.0_FVPRC
    DO j=jep1,js,-1
      DO i=ie,is,-1
        temp_ad9 = gridstruct%rdyc(i, j)*vc_ad(i, j)
        fx1_ad(i, j) = fx1_ad(i, j) - fx(i, j)*vc_ad(i, j)
        fx_ad(i, j) = fx_ad(i, j) - fx1(i, j)*vc_ad(i, j)
        ke_ad(i, j-1) = ke_ad(i, j-1) + temp_ad9
        ke_ad(i, j) = ke_ad(i, j) - temp_ad9
      END DO
    END DO
    fy1_ad = 0.0_FVPRC
    fy_ad = 0.0_FVPRC
    DO j=je,js,-1
      DO i=iep1,is,-1
        temp_ad8 = gridstruct%rdxc(i, j)*uc_ad(i, j)
        fy1_ad(i, j) = fy1_ad(i, j) + fy(i, j)*uc_ad(i, j)
        fy_ad(i, j) = fy_ad(i, j) + fy1(i, j)*uc_ad(i, j)
        ke_ad(i-1, j) = ke_ad(i-1, j) + temp_ad8
        ke_ad(i, j) = ke_ad(i, j) - temp_ad8
      END DO
    END DO
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      vort_ad = 0.0_FVPRC
      DO j=jep1,js,-1
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          DO i=ie,is,-1
            CALL POPCONTROL1B_FV(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY(fx(i, j))
              vort_ad(i+1, j) = vort_ad(i+1, j) + fx_ad(i, j)
              fx_ad(i, j) = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY(fx(i, j))
              vort_ad(i, j) = vort_ad(i, j) + fx_ad(i, j)
              fx_ad(i, j) = 0.0_FVPRC
            END IF
            CALL POPREALARRAY(fx1(i, j))
            temp_ad7 = dt2*fx1_ad(i, j)/gridstruct%sina_v(i, j)
            u_ad(i, j) = u_ad(i, j) + temp_ad7
            vc_ad(i, j) = vc_ad(i, j) - gridstruct%cosa_v(i, j)*temp_ad7
            fx1_ad(i, j) = 0.0_FVPRC
          END DO
        ELSE
          DO i=ie,is,-1
            CALL POPCONTROL1B_FV(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY(fx(i, j))
              vort_ad(i+1, j) = vort_ad(i+1, j) + fx_ad(i, j)
              fx_ad(i, j) = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY(fx(i, j))
              vort_ad(i, j) = vort_ad(i, j) + fx_ad(i, j)
              fx_ad(i, j) = 0.0_FVPRC
            END IF
            CALL POPREALARRAY(fx1(i, j))
            u_ad(i, j) = u_ad(i, j) + dt2*fx1_ad(i, j)
            fx1_ad(i, j) = 0.0_FVPRC
          END DO
        END IF
      END DO
      DO j=je,js,-1
        DO i=iep1,is,-1
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREALARRAY(fy(i, j))
            vort_ad(i, j+1) = vort_ad(i, j+1) + fy_ad(i, j)
            fy_ad(i, j) = 0.0_FVPRC
          ELSE
            CALL POPREALARRAY(fy(i, j))
            vort_ad(i, j) = vort_ad(i, j) + fy_ad(i, j)
            fy_ad(i, j) = 0.0_FVPRC
          END IF
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREALARRAY(fy1(i, j))
            v_ad(i, j) = v_ad(i, j) + dt2*fy1_ad(i, j)
            fy1_ad(i, j) = 0.0_FVPRC
          ELSE
            CALL POPREALARRAY(fy1(i, j))
            temp_ad6 = dt2*fy1_ad(i, j)/gridstruct%sina_u(i, j)
            v_ad(i, j) = v_ad(i, j) + temp_ad6
            uc_ad(i, j) = uc_ad(i, j) - gridstruct%cosa_u(i, j)*temp_ad6
            fy1_ad(i, j) = 0.0_FVPRC
          END IF
        END DO
      END DO
    ELSE
      vort_ad = 0.0_FVPRC
      DO j=jep1,js,-1
        DO i=ie,is,-1
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREALARRAY(fx(i, j))
            vort_ad(i+1, j) = vort_ad(i+1, j) + fx_ad(i, j)
            fx_ad(i, j) = 0.0_FVPRC
          ELSE
            CALL POPREALARRAY(fx(i, j))
            vort_ad(i, j) = vort_ad(i, j) + fx_ad(i, j)
            fx_ad(i, j) = 0.0_FVPRC
          END IF
          CALL POPREALARRAY(fx1(i, j))
          temp_ad5 = dt2*fx1_ad(i, j)/gridstruct%sina_v(i, j)
          u_ad(i, j) = u_ad(i, j) + temp_ad5
          vc_ad(i, j) = vc_ad(i, j) - gridstruct%cosa_v(i, j)*temp_ad5
          fx1_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      DO j=je,js,-1
        DO i=iep1,is,-1
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREALARRAY(fy(i, j))
            vort_ad(i, j+1) = vort_ad(i, j+1) + fy_ad(i, j)
            fy_ad(i, j) = 0.0_FVPRC
          ELSE
            CALL POPREALARRAY(fy(i, j))
            vort_ad(i, j) = vort_ad(i, j) + fy_ad(i, j)
            fy_ad(i, j) = 0.0_FVPRC
          END IF
          CALL POPREALARRAY(fy1(i, j))
          temp_ad4 = dt2*fy1_ad(i, j)/gridstruct%sina_u(i, j)
          v_ad(i, j) = v_ad(i, j) + temp_ad4
          uc_ad(i, j) = uc_ad(i, j) - gridstruct%cosa_u(i, j)*temp_ad4
          fy1_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
    END IF
    CALL POPREALARRAY(vort, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+3)/8)
    CALL POPINTEGER(ie)
    DO j=js,je+1
      DO i=ie+1,is,-1
        vort_ad(i, j) = gridstruct%rarea_c(i, j)*vort_ad(i, j)
      END DO
    END DO
    CALL POPCONTROL1B_FV(branch)
    IF (branch .NE. 0) THEN
      CALL POPREALARRAY(vort(1, npy))
      fy_ad(0, npy) = fy_ad(0, npy) + vort_ad(1, npy)
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(vort(npx, npy))
      fy_ad(npx, npy) = fy_ad(npx, npy) - vort_ad(npx, npy)
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(vort(npx, 1))
      fy_ad(npx, 1) = fy_ad(npx, 1) - vort_ad(npx, 1)
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(vort(1, 1))
      fy_ad(0, 1) = fy_ad(0, 1) + vort_ad(1, 1)
    END IF
    CALL POPREALARRAY(vort, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+3)/8)
    CALL POPINTEGER(ie)
    DO j=js,je+1
      DO i=ie+1,is,-1
        fx_ad(i, j-1) = fx_ad(i, j-1) + vort_ad(i, j)
        fx_ad(i, j) = fx_ad(i, j) - vort_ad(i, j)
        fy_ad(i, j) = fy_ad(i, j) + vort_ad(i, j)
        fy_ad(i-1, j) = fy_ad(i-1, j) - vort_ad(i, j)
        vort_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    CALL POPREALARRAY(fy, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+4)/8)
    CALL POPINTEGER(ie)
    DO j=js,je+1
      DO i=ie+1,is-1,-1
        vc_ad(i, j) = vc_ad(i, j) + gridstruct%dyc(i, j)*fy_ad(i, j)
        fy_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    CALL POPREALARRAY(fx, 8*(bd%ie-bd%is+4)*(bd%je-bd%js+3)/8)
    CALL POPINTEGER(is)
    CALL POPINTEGER(ie)
    DO j=js-1,je+1
      DO i=ie+1,is,-1
        uc_ad(i, j) = uc_ad(i, j) + gridstruct%dxc(i, j)*fx_ad(i, j)
        fx_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    CALL POPINTEGER(is)
    CALL POPREALARRAY(vort, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+3)/8)
    CALL POPREALARRAY(dt4)
    CALL POPREALARRAY(ke, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+3)/8)
    DO j=js-1,jep1
      DO i=iep1,is-1,-1
        temp_ad13 = dt4*ke_ad(i, j)
        ua_ad(i, j) = ua_ad(i, j) + ke(i, j)*temp_ad13
        va_ad(i, j) = va_ad(i, j) + vort(i, j)*temp_ad13
        vort_ad(i, j) = vort_ad(i, j) + va(i, j)*temp_ad13
        ke_ad(i, j) = ua(i, j)*temp_ad13
      END DO
    END DO
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      DO j=jep1,js-1,-1
        DO i=iep1,is-1,-1
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            vc_ad(i, j+1) = vc_ad(i, j+1) + vort_ad(i, j)
            vort_ad(i, j) = 0.0_FVPRC
          ELSE
            vc_ad(i, j) = vc_ad(i, j) + vort_ad(i, j)
            vort_ad(i, j) = 0.0_FVPRC
          END IF
        END DO
      END DO
      DO j=jep1,js-1,-1
        DO i=iep1,is-1,-1
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            uc_ad(i+1, j) = uc_ad(i+1, j) + ke_ad(i, j)
            ke_ad(i, j) = 0.0_FVPRC
          ELSE
            uc_ad(i, j) = uc_ad(i, j) + ke_ad(i, j)
            ke_ad(i, j) = 0.0_FVPRC
          END IF
        END DO
      END DO
    ELSE
      DO j=jep1,js-1,-1
        DO i=iep1,is-1,-1
          CALL POPCONTROL3B_FV(branch)
          IF (branch .LT. 3) THEN
            IF (branch .EQ. 0) THEN
              vc_ad(i, j+1) = vc_ad(i, j+1) + vort_ad(i, j)
              vort_ad(i, j) = 0.0_FVPRC
            ELSE IF (branch .EQ. 1) THEN
              vc_ad(i, npy) = vc_ad(i, npy) + gridstruct%sin_sg(i, npy-1&
&               , 4)*vort_ad(i, j)
              u_ad(i, npy) = u_ad(i, npy) + gridstruct%cos_sg(i, npy-1, &
&               4)*vort_ad(i, j)
              vort_ad(i, j) = 0.0_FVPRC
            ELSE
              vc_ad(i, 1) = vc_ad(i, 1) + gridstruct%sin_sg(i, 0, 4)*&
&               vort_ad(i, 0)
              u_ad(i, 1) = u_ad(i, 1) + gridstruct%cos_sg(i, 0, 4)*&
&               vort_ad(i, 0)
              vort_ad(i, 0) = 0.0_FVPRC
            END IF
          ELSE IF (branch .EQ. 3) THEN
            vc_ad(i, j) = vc_ad(i, j) + vort_ad(i, j)
            vort_ad(i, j) = 0.0_FVPRC
          ELSE IF (branch .EQ. 4) THEN
            vc_ad(i, npy) = vc_ad(i, npy) + gridstruct%sin_sg(i, npy, 2)&
&             *vort_ad(i, j)
            u_ad(i, npy) = u_ad(i, npy) + gridstruct%cos_sg(i, npy, 2)*&
&             vort_ad(i, j)
            vort_ad(i, j) = 0.0_FVPRC
          ELSE
            vc_ad(i, 1) = vc_ad(i, 1) + gridstruct%sin_sg(i, 1, 2)*&
&             vort_ad(i, 1)
            u_ad(i, 1) = u_ad(i, 1) + gridstruct%cos_sg(i, 1, 2)*vort_ad&
&             (i, 1)
            vort_ad(i, 1) = 0.0_FVPRC
          END IF
        END DO
      END DO
      DO j=jep1,js-1,-1
        DO i=iep1,is-1,-1
          CALL POPCONTROL3B_FV(branch)
          IF (branch .LT. 3) THEN
            IF (branch .EQ. 0) THEN
              uc_ad(i+1, j) = uc_ad(i+1, j) + ke_ad(i, j)
              ke_ad(i, j) = 0.0_FVPRC
            ELSE IF (branch .EQ. 1) THEN
              uc_ad(npx, j) = uc_ad(npx, j) + gridstruct%sin_sg(npx-1, j&
&               , 3)*ke_ad(i, j)
              v_ad(npx, j) = v_ad(npx, j) + gridstruct%cos_sg(npx-1, j, &
&               3)*ke_ad(i, j)
              ke_ad(i, j) = 0.0_FVPRC
            ELSE
              uc_ad(1, j) = uc_ad(1, j) + gridstruct%sin_sg(0, j, 3)*&
&               ke_ad(0, j)
              v_ad(1, j) = v_ad(1, j) + gridstruct%cos_sg(0, j, 3)*ke_ad&
&               (0, j)
              ke_ad(0, j) = 0.0_FVPRC
            END IF
          ELSE IF (branch .EQ. 3) THEN
            uc_ad(i, j) = uc_ad(i, j) + ke_ad(i, j)
            ke_ad(i, j) = 0.0_FVPRC
          ELSE IF (branch .EQ. 4) THEN
            uc_ad(npx, j) = uc_ad(npx, j) + gridstruct%sin_sg(npx, j, 1)&
&             *ke_ad(i, j)
            v_ad(npx, j) = v_ad(npx, j) + gridstruct%cos_sg(npx, j, 1)*&
&             ke_ad(i, j)
            ke_ad(i, j) = 0.0_FVPRC
          ELSE
            uc_ad(1, j) = uc_ad(1, j) + gridstruct%sin_sg(1, j, 1)*ke_ad&
&             (1, j)
            v_ad(1, j) = v_ad(1, j) + gridstruct%cos_sg(1, j, 1)*ke_ad(1&
&             , j)
            ke_ad(1, j) = 0.0_FVPRC
          END IF
        END DO
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(fy, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+4)/8)
      CALL POPREALARRAY(fx, 8*(bd%ie-bd%is+4)*(bd%je-bd%js+3)/8)
      CALL POPINTEGER(is)
      CALL POPREALARRAY(ptc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/&
&                  8)
      DO j=js-1,jep1
        DO i=is-1,iep1
          delpc(i, j) = delp(i, j) + (fx1(i, j)-fx1(i+1, j)+fy1(i, j)-&
&           fy1(i, j+1))*gridstruct%rarea(i, j)
!#ifdef SW_DYNAMICS
!                   ptc(i,j) = pt(i,j)
!#else
        END DO
        DO i=iep1,is-1,-1
          temp_ad10 = ptc_ad(i, j)/delpc(i, j)
          temp_ad11 = gridstruct%rarea(i, j)*temp_ad10
          pt_ad(i, j) = pt_ad(i, j) + delp(i, j)*temp_ad10
          fx_ad(i, j) = fx_ad(i, j) + temp_ad11
          fx_ad(i+1, j) = fx_ad(i+1, j) - temp_ad11
          fy_ad(i, j) = fy_ad(i, j) + temp_ad11
          fy_ad(i, j+1) = fy_ad(i, j+1) - temp_ad11
          delpc_ad(i, j) = delpc_ad(i, j) - (pt(i, j)*delp(i, j)+&
&           gridstruct%rarea(i, j)*(fx(i, j)-fx(i+1, j)+fy(i, j)-fy(i, j&
&           +1)))*temp_ad10/delpc(i, j)
          delp_ad(i, j) = delp_ad(i, j) + delpc_ad(i, j) + pt(i, j)*&
&           temp_ad10
          ptc_ad(i, j) = 0.0_FVPRC
          temp_ad12 = gridstruct%rarea(i, j)*delpc_ad(i, j)
          fx1_ad(i, j) = fx1_ad(i, j) + temp_ad12
          fx1_ad(i+1, j) = fx1_ad(i+1, j) - temp_ad12
          fy1_ad(i, j) = fy1_ad(i, j) + temp_ad12
          fy1_ad(i, j+1) = fy1_ad(i, j+1) - temp_ad12
          delpc_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      CALL POPREALARRAY(delpc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                  )/8)
      DO j=jep1+1,js-1,-1
        DO i=iep1,is-1,-1
          CALL POPREALARRAY(fy(i, j))
          fy1_ad(i, j) = fy1_ad(i, j) + fy(i, j)*fy_ad(i, j)
          fy_ad(i, j) = fy1(i, j)*fy_ad(i, j)
          CALL POPREALARRAY(fy1(i, j))
          vt_ad(i, j) = vt_ad(i, j) + fy1(i, j)*fy1_ad(i, j)
          fy1_ad(i, j) = vt(i, j)*fy1_ad(i, j)
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            pt_ad(i, j-1) = pt_ad(i, j-1) + fy_ad(i, j)
            fy_ad(i, j) = 0.0_FVPRC
            delp_ad(i, j-1) = delp_ad(i, j-1) + fy1_ad(i, j)
            fy1_ad(i, j) = 0.0_FVPRC
          ELSE
            pt_ad(i, j) = pt_ad(i, j) + fy_ad(i, j)
            fy_ad(i, j) = 0.0_FVPRC
            delp_ad(i, j) = delp_ad(i, j) + fy1_ad(i, j)
            fy1_ad(i, j) = 0.0_FVPRC
          END IF
        END DO
      END DO
      fx2_ad = 0.0_FVPRC
    ELSE
      fy2_ad = 0.0_FVPRC
      fx2_ad = 0.0_FVPRC
      DO j=je+1,js-1,-1
        DO i=ie+1,is-1,-1
          temp_ad1 = ptc_ad(i, j)/delpc(i, j)
          CALL POPREALARRAY(wc(i, j))
          temp_ad = wc_ad(i, j)/delpc(i, j)
          temp_ad0 = gridstruct%rarea(i, j)*temp_ad
          w_ad(i, j) = w_ad(i, j) + delp(i, j)*temp_ad
          fx2_ad(i, j) = fx2_ad(i, j) + temp_ad0
          fx2_ad(i+1, j) = fx2_ad(i+1, j) - temp_ad0
          fy2_ad(i, j) = fy2_ad(i, j) + temp_ad0
          fy2_ad(i, j+1) = fy2_ad(i, j+1) - temp_ad0
          delpc_ad(i, j) = delpc_ad(i, j) - (pt(i, j)*delp(i, j)+&
&           gridstruct%rarea(i, j)*(fx(i, j)-fx(i+1, j)+fy(i, j)-fy(i, j&
&           +1)))*temp_ad1/delpc(i, j) - (w(i, j)*delp(i, j)+gridstruct%&
&           rarea(i, j)*(fx2(i, j)-fx2(i+1, j)+fy2(i, j)-fy2(i, j+1)))*&
&           temp_ad/delpc(i, j)
          delp_ad(i, j) = delp_ad(i, j) + pt(i, j)*temp_ad1 + delpc_ad(i&
&           , j) + w(i, j)*temp_ad
          wc_ad(i, j) = 0.0_FVPRC
          CALL POPREALARRAY(ptc(i, j))
          temp_ad2 = gridstruct%rarea(i, j)*temp_ad1
          pt_ad(i, j) = pt_ad(i, j) + delp(i, j)*temp_ad1
          fx_ad(i, j) = fx_ad(i, j) + temp_ad2
          fx_ad(i+1, j) = fx_ad(i+1, j) - temp_ad2
          fy_ad(i, j) = fy_ad(i, j) + temp_ad2
          fy_ad(i, j+1) = fy_ad(i, j+1) - temp_ad2
          ptc_ad(i, j) = 0.0_FVPRC
          CALL POPREALARRAY(delpc(i, j))
          temp_ad3 = gridstruct%rarea(i, j)*delpc_ad(i, j)
          fx1_ad(i, j) = fx1_ad(i, j) + temp_ad3
          fx1_ad(i+1, j) = fx1_ad(i+1, j) - temp_ad3
          fy1_ad(i, j) = fy1_ad(i, j) + temp_ad3
          fy1_ad(i, j+1) = fy1_ad(i, j+1) - temp_ad3
          delpc_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      DO j=je+2,js-1,-1
        DO i=ie+1,is-1,-1
          CALL POPREALARRAY(fy2(i, j))
          CALL POPREALARRAY(fy(i, j))
          fy1_ad(i, j) = fy1_ad(i, j) + fy(i, j)*fy_ad(i, j) + fy2(i, j)&
&           *fy2_ad(i, j)
          fy2_ad(i, j) = fy1(i, j)*fy2_ad(i, j)
          fy_ad(i, j) = fy1(i, j)*fy_ad(i, j)
          CALL POPREALARRAY(fy1(i, j))
          vt_ad(i, j) = vt_ad(i, j) + fy1(i, j)*fy1_ad(i, j)
          fy1_ad(i, j) = vt(i, j)*fy1_ad(i, j)
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            w_ad(i, j-1) = w_ad(i, j-1) + fy2_ad(i, j)
            fy2_ad(i, j) = 0.0_FVPRC
            pt_ad(i, j-1) = pt_ad(i, j-1) + fy_ad(i, j)
            fy_ad(i, j) = 0.0_FVPRC
            delp_ad(i, j-1) = delp_ad(i, j-1) + fy1_ad(i, j)
            fy1_ad(i, j) = 0.0_FVPRC
          ELSE
            w_ad(i, j) = w_ad(i, j) + fy2_ad(i, j)
            fy2_ad(i, j) = 0.0_FVPRC
            pt_ad(i, j) = pt_ad(i, j) + fy_ad(i, j)
            fy_ad(i, j) = 0.0_FVPRC
            delp_ad(i, j) = delp_ad(i, j) + fy1_ad(i, j)
            fy1_ad(i, j) = 0.0_FVPRC
          END IF
        END DO
      END DO
      CALL POPCONTROL1B_FV(branch)
      IF (branch .NE. 0) CALL FILL_4CORNERS_BWD(w, w_ad, 2, bd, npx, npy&
&                                         , sw_corner, se_corner, &
&                                         ne_corner, nw_corner)
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) CALL FILL2_4CORNERS_BWD(delp, delp_ad, pt, pt_ad&
&                                        , 2, bd, npx, npy, sw_corner, &
&                                        se_corner, ne_corner, nw_corner&
&                                       )
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      DO j=jep1,js-1,-1
        DO i=ie+2,is-1,-1
          CALL POPREALARRAY(fx(i, j))
          fx1_ad(i, j) = fx1_ad(i, j) + fx(i, j)*fx_ad(i, j)
          fx_ad(i, j) = fx1(i, j)*fx_ad(i, j)
          CALL POPREALARRAY(fx1(i, j))
          ut_ad(i, j) = ut_ad(i, j) + fx1(i, j)*fx1_ad(i, j)
          fx1_ad(i, j) = ut(i, j)*fx1_ad(i, j)
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            pt_ad(i-1, j) = pt_ad(i-1, j) + fx_ad(i, j)
            fx_ad(i, j) = 0.0_FVPRC
            delp_ad(i-1, j) = delp_ad(i-1, j) + fx1_ad(i, j)
            fx1_ad(i, j) = 0.0_FVPRC
          ELSE
            pt_ad(i, j) = pt_ad(i, j) + fx_ad(i, j)
            fx_ad(i, j) = 0.0_FVPRC
            delp_ad(i, j) = delp_ad(i, j) + fx1_ad(i, j)
            fx1_ad(i, j) = 0.0_FVPRC
          END IF
        END DO
      END DO
    ELSE
      DO j=je+1,js-1,-1
        DO i=ie+2,is-1,-1
          CALL POPREALARRAY(fx2(i, j))
          CALL POPREALARRAY(fx(i, j))
          fx1_ad(i, j) = fx1_ad(i, j) + fx(i, j)*fx_ad(i, j) + fx2(i, j)&
&           *fx2_ad(i, j)
          fx2_ad(i, j) = fx1(i, j)*fx2_ad(i, j)
          fx_ad(i, j) = fx1(i, j)*fx_ad(i, j)
          CALL POPREALARRAY(fx1(i, j))
          ut_ad(i, j) = ut_ad(i, j) + fx1(i, j)*fx1_ad(i, j)
          fx1_ad(i, j) = ut(i, j)*fx1_ad(i, j)
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            w_ad(i-1, j) = w_ad(i-1, j) + fx2_ad(i, j)
            fx2_ad(i, j) = 0.0_FVPRC
            pt_ad(i-1, j) = pt_ad(i-1, j) + fx_ad(i, j)
            fx_ad(i, j) = 0.0_FVPRC
            delp_ad(i-1, j) = delp_ad(i-1, j) + fx1_ad(i, j)
            fx1_ad(i, j) = 0.0_FVPRC
          ELSE
            w_ad(i, j) = w_ad(i, j) + fx2_ad(i, j)
            fx2_ad(i, j) = 0.0_FVPRC
            pt_ad(i, j) = pt_ad(i, j) + fx_ad(i, j)
            fx_ad(i, j) = 0.0_FVPRC
            delp_ad(i, j) = delp_ad(i, j) + fx1_ad(i, j)
            fx1_ad(i, j) = 0.0_FVPRC
          END IF
        END DO
      END DO
      CALL POPCONTROL1B_FV(branch)
      IF (branch .NE. 0) CALL FILL_4CORNERS_BWD(w, w_ad, 1, bd, npx, npy&
&                                         , sw_corner, se_corner, &
&                                         ne_corner, nw_corner)
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) CALL FILL2_4CORNERS_BWD(delp, delp_ad, pt, pt_ad&
&                                        , 1, bd, npx, npy, sw_corner, &
&                                        se_corner, ne_corner, nw_corner&
&                                       )
    DO j=je+2,js-1,-1
      DO i=iep1,is-1,-1
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREALARRAY(vt(i, j))
          vt_ad(i, j) = gridstruct%dx(i, j)*gridstruct%sin_sg(i, j, 2)*&
&           dt2*vt_ad(i, j)
        ELSE
          CALL POPREALARRAY(vt(i, j))
          vt_ad(i, j) = gridstruct%dx(i, j)*gridstruct%sin_sg(i, j-1, 4)&
&           *dt2*vt_ad(i, j)
        END IF
      END DO
    END DO
    DO j=jep1,js-1,-1
      DO i=iep1+1,is-1,-1
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREALARRAY(ut(i, j))
          ut_ad(i, j) = gridstruct%dy(i, j)*gridstruct%sin_sg(i, j, 1)*&
&           dt2*ut_ad(i, j)
        ELSE
          CALL POPREALARRAY(ut(i, j))
          ut_ad(i, j) = gridstruct%dy(i, j)*gridstruct%sin_sg(i-1, j, 3)&
&           *dt2*ut_ad(i, j)
        END IF
      END DO
    END DO
    CALL POPCONTROL2B_FV(branch)
    IF (branch .NE. 0) THEN
      IF (branch .EQ. 1) THEN
        CALL DIVERGENCE_CORNER_BWD(u, u_ad, v, v_ad, ua, ua_ad, va, &
&                            va_ad, divg_d, divg_d_ad, gridstruct, &
&                            flagstruct, bd)
      ELSE
        CALL DIVERGENCE_CORNER_NEST_BWD(u, u_ad, v, v_ad, ua, ua_ad, va&
&                                 , va_ad, divg_d, divg_d_ad, gridstruct&
&                                 , flagstruct, bd)
        divg_d_ad = 0.0_FVPRC
      END IF
    END IF
    CALL D2A2C_VECT_BWD(u, u_ad, v, v_ad, ua, ua_ad, va, va_ad, uc, &
&                 uc_ad, vc, vc_ad, ut, ut_ad, vt, vt_ad, dord4, &
&                 gridstruct, bd, npx, npy, nested, flagstruct%grid_type&
&                )
  END SUBROUTINE C_SW_BWD
  SUBROUTINE C_SW(delpc, delp, ptc, pt, u, v, w, uc, vc, ua, va, wc, ut&
&   , vt, divg_d, nord, dt2, hydrostatic, dord4, bd, gridstruct, &
&   flagstruct)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u, vc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v, uc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delp, pt, ua, va, ut, vt, w
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(OUT) ::&
&   delpc, ptc, wc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(OUT&
&   ) :: divg_d
    INTEGER, INTENT(IN) :: nord
    REAL(fvprc), INTENT(IN) :: dt2
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: dord4
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
! Local:
    REAL(fvprc), DIMENSION(bd%is-1:bd%ie+1, bd%js-1:bd%je+1) :: vort, ke
    REAL(fvprc), DIMENSION(bd%is-1:bd%ie+2, bd%js-1:bd%je+1) :: fx, fx1&
&   , fx2
    REAL(fvprc), DIMENSION(bd%is-1:bd%ie+1, bd%js-1:bd%je+2) :: fy, fy1&
&   , fy2
    REAL(fvprc) :: dt4
    INTEGER :: i, j, is2, ie1
    INTEGER :: iep1, jep1
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTEGER :: npx, npy
    LOGICAL :: nested
!      real(FVPRC), pointer, dimension(:,:)   :: rarea, rarea_c
!      real(FVPRC), pointer, dimension(:,:,:) :: sin_sg, cos_sg
!      real(FVPRC), pointer, dimension(:,:)   :: cosa_u, cosa_v
!      real(FVPRC), pointer, dimension(:,:)   :: sina_u, sina_v
!      real(FVPRC), pointer, dimension(:,:) :: fC
!      real(FVPRC), pointer, dimension(:,:) :: rdxc, rdyc, dx, dy, dxc, dyc
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    npx = flagstruct%npx
    npy = flagstruct%npy
    nested = gridstruct%nested
!      rarea   => gridstruct%rarea
!      rarea_c => gridstruct%rarea_c
!      sin_sg  => gridstruct%sin_sg
!      cos_sg  => gridstruct%cos_sg
!      cosa_u  => gridstruct%cosa_u
!      cosa_v  => gridstruct%cosa_v
!      sina_u  => gridstruct%sina_u
!      sina_v  => gridstruct%sina_v
!      fC      => gridstruct%fC
!      rdxc    => gridstruct%rdxc
!      rdyc    => gridstruct%rdyc
!      dx      => gridstruct%dx
!      dy      => gridstruct%dy
!      dxc     => gridstruct%dxc
!      dyc     => gridstruct%dyc
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
    iep1 = ie + 1
    jep1 = je + 1
    CALL D2A2C_VECT(u, v, ua, va, uc, vc, ut, vt, dord4, gridstruct, bd&
&             , npx, npy, nested, flagstruct%grid_type)
    IF (nord .GT. 0) THEN
      IF (nested) THEN
        CALL DIVERGENCE_CORNER_NEST(u, v, ua, va, divg_d, gridstruct, &
&                             flagstruct, bd)
      ELSE
        CALL DIVERGENCE_CORNER(u, v, ua, va, divg_d, gridstruct, &
&                        flagstruct, bd)
      END IF
    END IF
!!! TO DO: remove 'test_up'
!!!   check repro with siena
    DO j=js-1,jep1
      DO i=is-1,iep1+1
        IF (ut(i, j) .GT. 0.) THEN
          ut(i, j) = dt2*ut(i, j)*gridstruct%dy(i, j)*gridstruct%sin_sg(&
&           i-1, j, 3)
        ELSE
          ut(i, j) = dt2*ut(i, j)*gridstruct%dy(i, j)*gridstruct%sin_sg(&
&           i, j, 1)
        END IF
      END DO
    END DO
    DO j=js-1,je+2
      DO i=is-1,iep1
        IF (vt(i, j) .GT. 0.) THEN
          vt(i, j) = dt2*vt(i, j)*gridstruct%dx(i, j)*gridstruct%sin_sg(&
&           i, j-1, 4)
        ELSE
          vt(i, j) = dt2*vt(i, j)*gridstruct%dx(i, j)*gridstruct%sin_sg(&
&           i, j, 2)
        END IF
      END DO
    END DO
!----------------
! Transport delp:
!----------------
! Xdir:
    IF (flagstruct%grid_type .LT. 3 .AND. (.NOT.nested)) CALL &
&     FILL2_4CORNERS(delp, pt, 1, bd, npx, npy, sw_corner, se_corner, &
&              ne_corner, nw_corner)
    IF (hydrostatic) THEN
!#ifdef SW_DYNAMICS
!           do j=js-1,jep1
!              do i=is-1,ie+2
!                 if ( ut(i,j) > 0. ) then
!                      fx1(i,j) = delp(i-1,j)
!                 else
!                      fx1(i,j) = delp(i,j)
!                 endif
!                 fx1(i,j) =  ut(i,j)*fx1(i,j)
!              enddo
!           enddo
!#else
      DO j=js-1,jep1
        DO i=is-1,ie+2
          IF (ut(i, j) .GT. 0.) THEN
            fx1(i, j) = delp(i-1, j)
            fx(i, j) = pt(i-1, j)
          ELSE
            fx1(i, j) = delp(i, j)
            fx(i, j) = pt(i, j)
          END IF
          fx1(i, j) = ut(i, j)*fx1(i, j)
          fx(i, j) = fx1(i, j)*fx(i, j)
        END DO
      END DO
    ELSE
!#endif
      IF (flagstruct%grid_type .LT. 3) CALL FILL_4CORNERS(w, 1, bd, npx&
&                                                   , npy, sw_corner, &
&                                                   se_corner, ne_corner&
&                                                   , nw_corner)
      DO j=js-1,je+1
        DO i=is-1,ie+2
          IF (ut(i, j) .GT. 0.) THEN
            fx1(i, j) = delp(i-1, j)
            fx(i, j) = pt(i-1, j)
            fx2(i, j) = w(i-1, j)
          ELSE
            fx1(i, j) = delp(i, j)
            fx(i, j) = pt(i, j)
            fx2(i, j) = w(i, j)
          END IF
          fx1(i, j) = ut(i, j)*fx1(i, j)
          fx(i, j) = fx1(i, j)*fx(i, j)
          fx2(i, j) = fx1(i, j)*fx2(i, j)
        END DO
      END DO
    END IF
! Ydir:
    IF (flagstruct%grid_type .LT. 3 .AND. (.NOT.nested)) CALL &
&     FILL2_4CORNERS(delp, pt, 2, bd, npx, npy, sw_corner, se_corner, &
&              ne_corner, nw_corner)
    IF (hydrostatic) THEN
      DO j=js-1,jep1+1
        DO i=is-1,iep1
          IF (vt(i, j) .GT. 0.) THEN
            fy1(i, j) = delp(i, j-1)
            fy(i, j) = pt(i, j-1)
          ELSE
            fy1(i, j) = delp(i, j)
            fy(i, j) = pt(i, j)
          END IF
          fy1(i, j) = vt(i, j)*fy1(i, j)
          fy(i, j) = fy1(i, j)*fy(i, j)
        END DO
      END DO
      DO j=js-1,jep1
        DO i=is-1,iep1
          delpc(i, j) = delp(i, j) + (fx1(i, j)-fx1(i+1, j)+fy1(i, j)-&
&           fy1(i, j+1))*gridstruct%rarea(i, j)
!#ifdef SW_DYNAMICS
!                   ptc(i,j) = pt(i,j)
!#else
          ptc(i, j) = (pt(i, j)*delp(i, j)+(fx(i, j)-fx(i+1, j)+fy(i, j)&
&           -fy(i, j+1))*gridstruct%rarea(i, j))/delpc(i, j)
        END DO
      END DO
    ELSE
!#endif
      IF (flagstruct%grid_type .LT. 3) CALL FILL_4CORNERS(w, 2, bd, npx&
&                                                   , npy, sw_corner, &
&                                                   se_corner, ne_corner&
&                                                   , nw_corner)
      DO j=js-1,je+2
        DO i=is-1,ie+1
          IF (vt(i, j) .GT. 0.) THEN
            fy1(i, j) = delp(i, j-1)
            fy(i, j) = pt(i, j-1)
            fy2(i, j) = w(i, j-1)
          ELSE
            fy1(i, j) = delp(i, j)
            fy(i, j) = pt(i, j)
            fy2(i, j) = w(i, j)
          END IF
          fy1(i, j) = vt(i, j)*fy1(i, j)
          fy(i, j) = fy1(i, j)*fy(i, j)
          fy2(i, j) = fy1(i, j)*fy2(i, j)
        END DO
      END DO
      DO j=js-1,je+1
        DO i=is-1,ie+1
          delpc(i, j) = delp(i, j) + (fx1(i, j)-fx1(i+1, j)+fy1(i, j)-&
&           fy1(i, j+1))*gridstruct%rarea(i, j)
          ptc(i, j) = (pt(i, j)*delp(i, j)+(fx(i, j)-fx(i+1, j)+fy(i, j)&
&           -fy(i, j+1))*gridstruct%rarea(i, j))/delpc(i, j)
          wc(i, j) = (w(i, j)*delp(i, j)+(fx2(i, j)-fx2(i+1, j)+fy2(i, j&
&           )-fy2(i, j+1))*gridstruct%rarea(i, j))/delpc(i, j)
        END DO
      END DO
    END IF
!------------
! Compute KE:
!------------
!Since uc = u*, i.e. the covariant wind perpendicular to the face edge, if we want to compute kinetic energy we will need the tru
!e coordinate-parallel covariant wind, computed through u = uc*sina + v*cosa. 
!Use the alpha for the cell KE is being computed in.
!!! TO DO:
!!! Need separate versions for nesting/single-tile
!!!   and for cubed-sphere
    IF (nested .OR. flagstruct%grid_type .GE. 3) THEN
      DO j=js-1,jep1
        DO i=is-1,iep1
          IF (ua(i, j) .GT. 0.) THEN
            ke(i, j) = uc(i, j)
          ELSE
            ke(i, j) = uc(i+1, j)
          END IF
        END DO
      END DO
      DO j=js-1,jep1
        DO i=is-1,iep1
          IF (va(i, j) .GT. 0.) THEN
            vort(i, j) = vc(i, j)
          ELSE
            vort(i, j) = vc(i, j+1)
          END IF
        END DO
      END DO
    ELSE
      DO j=js-1,jep1
        DO i=is-1,iep1
          IF (ua(i, j) .GT. 0.) THEN
            IF (i .EQ. 1) THEN
              ke(1, j) = uc(1, j)*gridstruct%sin_sg(1, j, 1) + v(1, j)*&
&               gridstruct%cos_sg(1, j, 1)
            ELSE IF (i .EQ. npx) THEN
              ke(i, j) = uc(npx, j)*gridstruct%sin_sg(npx, j, 1) + v(npx&
&               , j)*gridstruct%cos_sg(npx, j, 1)
            ELSE
              ke(i, j) = uc(i, j)
            END IF
          ELSE IF (i .EQ. 0) THEN
            ke(0, j) = uc(1, j)*gridstruct%sin_sg(0, j, 3) + v(1, j)*&
&             gridstruct%cos_sg(0, j, 3)
          ELSE IF (i .EQ. npx - 1) THEN
            ke(i, j) = uc(npx, j)*gridstruct%sin_sg(npx-1, j, 3) + v(npx&
&             , j)*gridstruct%cos_sg(npx-1, j, 3)
          ELSE
            ke(i, j) = uc(i+1, j)
          END IF
        END DO
      END DO
      DO j=js-1,jep1
        DO i=is-1,iep1
          IF (va(i, j) .GT. 0.) THEN
            IF (j .EQ. 1) THEN
              vort(i, 1) = vc(i, 1)*gridstruct%sin_sg(i, 1, 2) + u(i, 1)&
&               *gridstruct%cos_sg(i, 1, 2)
            ELSE IF (j .EQ. npy) THEN
              vort(i, j) = vc(i, npy)*gridstruct%sin_sg(i, npy, 2) + u(i&
&               , npy)*gridstruct%cos_sg(i, npy, 2)
            ELSE
              vort(i, j) = vc(i, j)
            END IF
          ELSE IF (j .EQ. 0) THEN
            vort(i, 0) = vc(i, 1)*gridstruct%sin_sg(i, 0, 4) + u(i, 1)*&
&             gridstruct%cos_sg(i, 0, 4)
          ELSE IF (j .EQ. npy - 1) THEN
            vort(i, j) = vc(i, npy)*gridstruct%sin_sg(i, npy-1, 4) + u(i&
&             , npy)*gridstruct%cos_sg(i, npy-1, 4)
          ELSE
            vort(i, j) = vc(i, j+1)
          END IF
        END DO
      END DO
    END IF
    dt4 = 0.5*dt2
    DO j=js-1,jep1
      DO i=is-1,iep1
        ke(i, j) = dt4*(ua(i, j)*ke(i, j)+va(i, j)*vort(i, j))
      END DO
    END DO
!------------------------------
! Compute circulation on C grid
!------------------------------
! To consider using true co-variant winds at face edges?
    DO j=js-1,je+1
      DO i=is,ie+1
        fx(i, j) = uc(i, j)*gridstruct%dxc(i, j)
      END DO
    END DO
    DO j=js,je+1
      DO i=is-1,ie+1
        fy(i, j) = vc(i, j)*gridstruct%dyc(i, j)
      END DO
    END DO
    DO j=js,je+1
      DO i=is,ie+1
        vort(i, j) = fx(i, j-1) - fx(i, j) - fy(i-1, j) + fy(i, j)
      END DO
    END DO
! Remove the extra term at the corners:
    IF (sw_corner) vort(1, 1) = vort(1, 1) + fy(0, 1)
    IF (se_corner) vort(npx, 1) = vort(npx, 1) - fy(npx, 1)
    IF (ne_corner) vort(npx, npy) = vort(npx, npy) - fy(npx, npy)
    IF (nw_corner) vort(1, npy) = vort(1, npy) + fy(0, npy)
!----------------------------
! Compute absolute vorticity
!----------------------------
    DO j=js,je+1
      DO i=is,ie+1
        vort(i, j) = gridstruct%fc(i, j) + gridstruct%rarea_c(i, j)*vort&
&         (i, j)
      END DO
    END DO
!----------------------------------
! Transport absolute vorticity:
!----------------------------------
!To go from v to contravariant v at the edges, we divide by sin_sg;
! but we then must multiply by sin_sg to get the proper flux.
! These cancel, leaving us with fy1 = dt2*v at the edges.
! (For the same reason we only divide by sin instead of sin**2 in the interior)
!! TO DO: separate versions for nesting/single-tile and cubed-sphere
    IF (nested .OR. flagstruct%grid_type .GE. 3) THEN
      DO j=js,je
        DO i=is,iep1
          fy1(i, j) = dt2*(v(i, j)-uc(i, j)*gridstruct%cosa_u(i, j))/&
&           gridstruct%sina_u(i, j)
          IF (fy1(i, j) .GT. 0.) THEN
            fy(i, j) = vort(i, j)
          ELSE
            fy(i, j) = vort(i, j+1)
          END IF
        END DO
      END DO
      DO j=js,jep1
        DO i=is,ie
          fx1(i, j) = dt2*(u(i, j)-vc(i, j)*gridstruct%cosa_v(i, j))/&
&           gridstruct%sina_v(i, j)
          IF (fx1(i, j) .GT. 0.) THEN
            fx(i, j) = vort(i, j)
          ELSE
            fx(i, j) = vort(i+1, j)
          END IF
        END DO
      END DO
    ELSE
      DO j=js,je
!DEC$ VECTOR ALWAYS
        DO i=is,iep1
          IF (i .EQ. 1 .OR. i .EQ. npx) THEN
            fy1(i, j) = dt2*v(i, j)
          ELSE
            fy1(i, j) = dt2*(v(i, j)-uc(i, j)*gridstruct%cosa_u(i, j))/&
&             gridstruct%sina_u(i, j)
          END IF
          IF (fy1(i, j) .GT. 0.) THEN
            fy(i, j) = vort(i, j)
          ELSE
            fy(i, j) = vort(i, j+1)
          END IF
        END DO
      END DO
      DO j=js,jep1
        IF (j .EQ. 1 .OR. j .EQ. npy) THEN
!DEC$ VECTOR ALWAYS
          DO i=is,ie
            fx1(i, j) = dt2*u(i, j)
            IF (fx1(i, j) .GT. 0.) THEN
              fx(i, j) = vort(i, j)
            ELSE
              fx(i, j) = vort(i+1, j)
            END IF
          END DO
        ELSE
!DEC$ VECTOR ALWAYS
          DO i=is,ie
            fx1(i, j) = dt2*(u(i, j)-vc(i, j)*gridstruct%cosa_v(i, j))/&
&             gridstruct%sina_v(i, j)
            IF (fx1(i, j) .GT. 0.) THEN
              fx(i, j) = vort(i, j)
            ELSE
              fx(i, j) = vort(i+1, j)
            END IF
          END DO
        END IF
      END DO
    END IF
! Update time-centered winds on the C-Grid
    DO j=js,je
      DO i=is,iep1
        uc(i, j) = uc(i, j) + fy1(i, j)*fy(i, j) + gridstruct%rdxc(i, j)&
&         *(ke(i-1, j)-ke(i, j))
      END DO
    END DO
    DO j=js,jep1
      DO i=is,ie
        vc(i, j) = vc(i, j) - fx1(i, j)*fx(i, j) + gridstruct%rdyc(i, j)&
&         *(ke(i, j-1)-ke(i, j))
      END DO
    END DO
  END SUBROUTINE C_SW
!  Differentiation of d_sw in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod.a2b
!_ord4_fb a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo d
!yn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.g
!rad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.rayleig
!h_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to_lat
!lon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energy fv
!_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mod.m
!ap1_q2_fb fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv_tra
!cer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver_c n
!h_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core_mod
!.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_corn
!er_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.co
!mpute_div_damping_fb sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mod.co
!py_corners_fb tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_mod.f
!yppm_fb tp_core_mod.deln_flux)):
!   gradient     of useful results: yfx_adv q crx_adv u v w delp
!                ua xfx_adv uc ptc xflux cry_adv delpc va vc yflux
!                divg_d z_rat heat_source pt cx cy
!   with respect to varying inputs: yfx_adv q crx_adv u v w delp
!                ua xfx_adv uc ptc xflux cry_adv delpc va vc yflux
!                divg_d z_rat heat_source pt cx cy
!     d_sw :: D-Grid Shallow Water Routine
  SUBROUTINE D_SW_FWD(delpc, delpc_tj, delp, ptc, pt, u, v, w, uc, vc, &
&   ua, va, divg_d, xflux, yflux, cx, cy, crx_adv, cry_adv, xfx_adv, &
&   yfx_adv, q_con, z_rat, heat_source, zvir, sphum, nq, q, k, km, &
&   inline_q, dt, hord_tr, hord_mt, hord_vt, hord_tm, hord_dp, &
&   hord_tr_pert, hord_mt_pert, hord_vt_pert, hord_tm_pert, hord_dp_pert&
&   , nord, nord_v, nord_w, nord_t, dddmp, d2_bg, d4_bg, damp_v, damp_w&
&   , damp_t, d_con, split_damp, nord_pert, nord_v_pert, nord_w_pert, &
&   nord_t_pert, dddmp_pert, d2_bg_pert, d4_bg_pert, damp_v_pert, &
&   damp_w_pert, damp_t_pert, d_con_pert, hydrostatic, gridstruct, &
&   flagstruct, bd)
    IMPLICIT NONE
!#ifdef SW_DYNAMICS
!      endif ! test_case
!#endif
    INTEGER, INTENT(IN) :: hord_tr, hord_mt, hord_vt, hord_tm, hord_dp
    INTEGER, INTENT(IN) :: hord_tr_pert, hord_mt_pert, hord_vt_pert, &
&   hord_tm_pert, hord_dp_pert
! nord=1 divergence damping; (del-4) or 3 (del-8)
    INTEGER, INTENT(IN) :: nord
! vorticity damping
    INTEGER, INTENT(IN) :: nord_v
! vertical velocity
    INTEGER, INTENT(IN) :: nord_w
! pt
    INTEGER, INTENT(IN) :: nord_t
    LOGICAL, INTENT(IN) :: split_damp
    INTEGER, INTENT(IN) :: nord_pert, nord_v_pert, nord_w_pert, &
&   nord_t_pert
    INTEGER, INTENT(IN) :: sphum, nq, k, km
    REAL(fvprc), INTENT(IN) :: dt, dddmp, d2_bg, d4_bg, d_con
    REAL(fvprc), INTENT(IN) :: dddmp_pert, d2_bg_pert, d4_bg_pert, &
&   d_con_pert
    REAL(fvprc), INTENT(IN) :: zvir
    REAL(fvprc), INTENT(IN) :: damp_v, damp_w, damp_t
    REAL(fvprc), INTENT(IN) :: damp_v_pert, damp_w_pert, damp_t_pert
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! divergence
    REAL(fvprc), INTENT(INOUT) :: divg_d(bd%isd:bd%ied+1, bd%jsd:bd%jed+&
&   1)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   z_rat
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delp, pt, ua, va, w
    REAL(fvprc), DIMENSION(bd%isd:bd%isd, bd%jsd:bd%jsd), INTENT(INOUT) &
&   :: q_con
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u, vc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v, uc
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, km, nq&
&   )
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: delpc, ptc
    REAL(fvprc), DIMENSION(bd%is:bd%ie, bd%js:bd%je) :: heat_source
! The flux capacitors:
    REAL(fvprc), INTENT(INOUT) :: xflux(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc), INTENT(INOUT) :: yflux(bd%is:bd%ie, bd%js:bd%je+1)
!------------------------
    REAL(fvprc), INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1)
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: inline_q
    REAL(fvprc), DIMENSION(bd%is:bd%ie+1, bd%jsd:bd%jed) :: crx_adv, &
&   xfx_adv
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%js:bd%je+1) :: cry_adv, &
&   yfx_adv
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
! Local:
    REAL(fvprc) :: ut(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: vt(bd%isd:bd%ied, bd%jsd:bd%jed+1)
!---
    REAL(fvprc) :: fx2(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: fy2(bd%isd:bd%ied, bd%jsd:bd%jed+1)
!  work array
    REAL(fvprc) :: dw(bd%is:bd%ie, bd%js:bd%je)
!---
    REAL(fvprc), DIMENSION(bd%is:bd%ie+1, bd%js:bd%je+1) :: ub, vb
!  work array
    REAL(fvprc) :: wk(bd%isd:bd%ied, bd%jsd:bd%jed)
!  needs this for corner_comm
    REAL(fvprc) :: ke(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
! Vorticity
    REAL(fvprc) :: vort(bd%isd:bd%ied, bd%jsd:bd%jed)
! 1-D X-direction Fluxes
    REAL(fvprc) :: fx(bd%is:bd%ie+1, bd%js:bd%je)
! 1-D Y-direction Fluxes
    REAL(fvprc) :: fy(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: ra_x(bd%is:bd%ie, bd%jsd:bd%jed)
    REAL(fvprc) :: ra_y(bd%isd:bd%ied, bd%js:bd%je)
    REAL(fvprc) :: gx(bd%is:bd%ie+1, bd%js:bd%je)
! work Y-dir flux array
    REAL(fvprc) :: gy(bd%is:bd%ie, bd%js:bd%je+1)
    LOGICAL :: fill_c
    REAL(fvprc) :: dt2, dt4, dt5, dt6
    REAL(fvprc) :: damp, damp2, damp4, dd8, u2, v2, du2, dv2, damp4_pert
    REAL(fvprc) :: u_lon
    INTEGER :: i, j, ii, jj, is2, ie1, js2, je1, n, nt, n2, iq
!      real(FVPRC), pointer, dimension(:,:) :: area, area_c, rarea, rarea_c
!      real(FVPRC), pointer, dimension(:,:,:) :: sin_sg
!      real(FVPRC), pointer, dimension(:,:)   :: cosa_u, cosa_v, cosa_s
!      real(FVPRC), pointer, dimension(:,:)   :: sina_u, sina_v
!      real(FVPRC), pointer, dimension(:,:)   :: rsin_u, rsin_v, rsina
!      real(FVPRC), pointer, dimension(:,:)   :: f0, rsin2, divg_u, divg_v
!      real(FVPRC), pointer, dimension(:,:) ::  cosa, dx, dy, dxc, dyc, rdxa, rdya, rdx, rdy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTEGER :: npx, npy
    LOGICAL :: nested
    REAL(fvprc) :: da_min, da_min_c
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: delp_tj, &
&   pt_tj, w_tj
    REAL(fvprc) :: q_tj(bd%isd:bd%ied, bd%jsd:bd%jed, km, nq)
    REAL(fvprc) :: vort_tj(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), DIMENSION(bd%is:bd%ie+1, bd%js:bd%je+1) :: ub_tj, vb_tj
    REAL(fvprc) :: fx_tj(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: fy_tj(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: gx_tj(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: gy_tj(bd%is:bd%ie, bd%js:bd%je+1)
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(OUT) ::&
&   delpc_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ptc_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1) :: ke_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1) :: u_tj, &
&   vc_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed) :: v_tj, &
&   uc_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ua_tj, va_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1) :: &
&   divg_d_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: wk_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed) :: ut_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1) :: vt_tj
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
!
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
    fx = 0.0
    fy = 0.0
    gx = 0.0
    gy = 0.0
    ub = 0.0
    vb = 0.0
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    npx = flagstruct%npx
    npy = flagstruct%npy
    nested = gridstruct%nested
    da_min_c = gridstruct%da_min_c
! end grid_type choices
!      area      => gridstruct%area   
!      rarea     => gridstruct%rarea  
!      rarea_c   => gridstruct%rarea_c
!      sin_sg    => gridstruct%sin_sg 
!      cosa_u    => gridstruct%cosa_u 
!      cosa_v    => gridstruct%cosa_v 
!      cosa_s    => gridstruct%cosa_s 
!      sina_u    => gridstruct%sina_u 
!      sina_v    => gridstruct%sina_v 
!      rsin_u    => gridstruct%rsin_u 
!      rsin_v    => gridstruct%rsin_v 
!      rsina     => gridstruct%rsina  
!      f0        => gridstruct%f0     
!      rsin2     => gridstruct%rsin2  
!      divg_u    => gridstruct%divg_u 
!      divg_v    => gridstruct%divg_v 
!      cosa      => gridstruct%cosa   
!      dx        => gridstruct%dx     
!      dy        => gridstruct%dy     
!      dxc       => gridstruct%dxc    
!      dyc       => gridstruct%dyc    
!      rdxa      => gridstruct%rdxa   
!      rdya      => gridstruct%rdya   
!      rdx       => gridstruct%rdx    
!      rdy       => gridstruct%rdy    
!#ifdef SW_DYNAMICS 
!      if ( test_case == 1 ) then
!        do j=jsd,jed
!           do i=is,ie+1
!              xfx_adv(i,j) = dt * uc(i,j) / gridstruct%sina_u(i,j)
!              if (xfx_adv(i,j) > 0.) then
!                  crx_adv(i,j) = xfx_adv(i,j) * gridstruct%rdxa(i-1,j)
!              else
!                  crx_adv(i,j) = xfx_adv(i,j) * gridstruct%rdxa(i,j)
!              endif
!              xfx_adv(i,j) = gridstruct%dy(i,j)*xfx_adv(i,j)*gridstruct%sina_u(i,j)
!           enddo
!        enddo
!
!        do j=js,je+1
!           do i=isd,ied
!              yfx_adv(i,j) = dt * vc(i,j) / gridstruct%sina_v(i,j)
!              if (yfx_adv(i,j) > 0.) then
!                 cry_adv(i,j) = yfx_adv(i,j) * gridstruct%rdya(i,j-1)
!              else
!                 cry_adv(i,j) = yfx_adv(i,j) * gridstruct%rdya(i,j)
!              endif
!              yfx_adv(i,j) = gridstruct%dx(i,j)*yfx_adv(i,j)*gridstruct%sina_v(i,j)
!           enddo
!        enddo
!      else
!#endif
    IF (flagstruct%grid_type .LT. 3) THEN
!!! TO DO: separate versions for nesting and for cubed-sphere
      IF (nested) THEN
        DO j=jsd,jed
          DO i=is-1,ie+2
            ut(i, j) = (uc(i, j)-0.25*gridstruct%cosa_u(i, j)*(vc(i-1, j&
&             )+vc(i, j)+vc(i-1, j+1)+vc(i, j+1)))*gridstruct%rsin_u(i, &
&             j)
          END DO
        END DO
        DO j=js-1,je+2
          DO i=isd,ied
            vt(i, j) = (vc(i, j)-0.25*gridstruct%cosa_v(i, j)*(uc(i, j-1&
&             )+uc(i+1, j-1)+uc(i, j)+uc(i+1, j)))*gridstruct%rsin_v(i, &
&             j)
          END DO
        END DO
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        DO j=jsd,jed
          IF (j .NE. 0 .AND. j .NE. 1 .AND. j .NE. npy - 1 .AND. j .NE. &
&             npy) THEN
            DO i=is-1,ie+2
              ut(i, j) = (uc(i, j)-0.25*gridstruct%cosa_u(i, j)*(vc(i-1&
&               , j)+vc(i, j)+vc(i-1, j+1)+vc(i, j+1)))*gridstruct%&
&               rsin_u(i, j)
            END DO
            CALL PUSHCONTROL1B_FV(1)
          ELSE
            CALL PUSHCONTROL1B_FV(0)
          END IF
        END DO
        DO j=js-1,je+2
          IF (j .NE. 1 .AND. j .NE. npy) THEN
            DO i=isd,ied
              vt(i, j) = (vc(i, j)-0.25*gridstruct%cosa_v(i, j)*(uc(i, j&
&               -1)+uc(i+1, j-1)+uc(i, j)+uc(i+1, j)))*gridstruct%rsin_v&
&               (i, j)
            END DO
            CALL PUSHCONTROL1B_FV(1)
          ELSE
            CALL PUSHCONTROL1B_FV(0)
          END IF
        END DO
        CALL PUSHCONTROL1B_FV(1)
      END IF
!.not. nested
      IF (.NOT.nested) THEN
! West face
! West edge:
        IF (is .EQ. 1) THEN
          DO j=jsd,jed
            IF (uc(1, j)*dt .GT. 0.) THEN
              ut(1, j) = uc(1, j)/gridstruct%sin_sg(0, j, 3)
              CALL PUSHCONTROL1B_FV(1)
            ELSE
              ut(1, j) = uc(1, j)/gridstruct%sin_sg(1, j, 1)
              CALL PUSHCONTROL1B_FV(0)
            END IF
          END DO
          IF (3 .LT. js) THEN
            max1 = js
          ELSE
            max1 = 3
          END IF
          IF (npy - 2 .GT. je + 1) THEN
            min1 = je + 1
          ELSE
            min1 = npy - 2
          END IF
          DO j=max1,min1
            vt(0, j) = vc(0, j) - 0.25*gridstruct%cosa_v(0, j)*(ut(0, j-&
&             1)+ut(1, j-1)+ut(0, j)+ut(1, j))
            vt(1, j) = vc(1, j) - 0.25*gridstruct%cosa_v(1, j)*(ut(1, j-&
&             1)+ut(2, j-1)+ut(1, j)+ut(2, j))
          END DO
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
! East edge:
        IF (ie + 1 .EQ. npx) THEN
          DO j=jsd,jed
            IF (uc(npx, j)*dt .GT. 0.) THEN
              ut(npx, j) = uc(npx, j)/gridstruct%sin_sg(npx-1, j, 3)
              CALL PUSHCONTROL1B_FV(1)
            ELSE
              ut(npx, j) = uc(npx, j)/gridstruct%sin_sg(npx, j, 1)
              CALL PUSHCONTROL1B_FV(0)
            END IF
          END DO
          IF (3 .LT. js) THEN
            max2 = js
          ELSE
            max2 = 3
          END IF
          IF (npy - 2 .GT. je + 1) THEN
            min2 = je + 1
          ELSE
            min2 = npy - 2
          END IF
          DO j=max2,min2
            vt(npx-1, j) = vc(npx-1, j) - 0.25*gridstruct%cosa_v(npx-1, &
&             j)*(ut(npx-1, j-1)+ut(npx, j-1)+ut(npx-1, j)+ut(npx, j))
            vt(npx, j) = vc(npx, j) - 0.25*gridstruct%cosa_v(npx, j)*(ut&
&             (npx, j-1)+ut(npx+1, j-1)+ut(npx, j)+ut(npx+1, j))
          END DO
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
! South (Bottom) edge:
        IF (js .EQ. 1) THEN
          DO i=isd,ied
            IF (vc(i, 1)*dt .GT. 0.) THEN
              vt(i, 1) = vc(i, 1)/gridstruct%sin_sg(i, 0, 4)
              CALL PUSHCONTROL1B_FV(1)
            ELSE
              vt(i, 1) = vc(i, 1)/gridstruct%sin_sg(i, 1, 2)
              CALL PUSHCONTROL1B_FV(0)
            END IF
          END DO
          IF (3 .LT. is) THEN
            max3 = is
          ELSE
            max3 = 3
          END IF
          IF (npx - 2 .GT. ie + 1) THEN
            min3 = ie + 1
          ELSE
            min3 = npx - 2
          END IF
          DO i=max3,min3
            ut(i, 0) = uc(i, 0) - 0.25*gridstruct%cosa_u(i, 0)*(vt(i-1, &
&             0)+vt(i, 0)+vt(i-1, 1)+vt(i, 1))
            ut(i, 1) = uc(i, 1) - 0.25*gridstruct%cosa_u(i, 1)*(vt(i-1, &
&             1)+vt(i, 1)+vt(i-1, 2)+vt(i, 2))
          END DO
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
! North edge:
        IF (je + 1 .EQ. npy) THEN
          DO i=isd,ied
            IF (vc(i, npy)*dt .GT. 0.) THEN
              vt(i, npy) = vc(i, npy)/gridstruct%sin_sg(i, npy-1, 4)
              CALL PUSHCONTROL1B_FV(1)
            ELSE
              vt(i, npy) = vc(i, npy)/gridstruct%sin_sg(i, npy, 2)
              CALL PUSHCONTROL1B_FV(0)
            END IF
          END DO
          IF (3 .LT. is) THEN
            max4 = is
          ELSE
            max4 = 3
          END IF
          IF (npx - 2 .GT. ie + 1) THEN
            min4 = ie + 1
          ELSE
            min4 = npx - 2
          END IF
          DO i=max4,min4
            ut(i, npy-1) = uc(i, npy-1) - 0.25*gridstruct%cosa_u(i, npy-&
&             1)*(vt(i-1, npy-1)+vt(i, npy-1)+vt(i-1, npy)+vt(i, npy))
            ut(i, npy) = uc(i, npy) - 0.25*gridstruct%cosa_u(i, npy)*(vt&
&             (i-1, npy)+vt(i, npy)+vt(i-1, npy+1)+vt(i, npy+1))
          END DO
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
! The following code solves a 2x2 system to get the interior parallel-to-edge uc,vc values 
! near the corners (ex: for the sw corner ut(2,1) and vt(1,2) are solved for simultaneously). 
! It then computes the halo uc, vc values so as to be consistent with the computations on 
! the facing panel. 
!The system solved is:
!  ut(2,1) = uc(2,1) - avg(vt)*gridstruct%cosa_u(2,1)
!  vt(1,2) = vc(1,2) - avg(ut)*gridstruct%cosa_v(1,2)
! in which avg(vt) includes vt(1,2) and avg(ut) includes ut(2,1)
        IF (sw_corner) THEN
          damp = 1./(1.-0.0625*gridstruct%cosa_u(2, 0)*gridstruct%cosa_v&
&           (1, 0))
          ut(2, 0) = (uc(2, 0)-0.25*gridstruct%cosa_u(2, 0)*(vt(1, 1)+vt&
&           (2, 1)+vt(2, 0)+vc(1, 0)-0.25*gridstruct%cosa_v(1, 0)*(ut(1&
&           , 0)+ut(1, -1)+ut(2, -1))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(0, 1)*gridstruct%cosa_v&
&           (0, 2))
          vt(0, 2) = (vc(0, 2)-0.25*gridstruct%cosa_v(0, 2)*(ut(1, 1)+ut&
&           (1, 2)+ut(0, 2)+uc(0, 1)-0.25*gridstruct%cosa_u(0, 1)*(vt(0&
&           , 1)+vt(-1, 1)+vt(-1, 2))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(2, 1)*gridstruct%cosa_v&
&           (1, 2))
          ut(2, 1) = (uc(2, 1)-0.25*gridstruct%cosa_u(2, 1)*(vt(1, 1)+vt&
&           (2, 1)+vt(2, 2)+vc(1, 2)-0.25*gridstruct%cosa_v(1, 2)*(ut(1&
&           , 1)+ut(1, 2)+ut(2, 2))))*damp
          vt(1, 2) = (vc(1, 2)-0.25*gridstruct%cosa_v(1, 2)*(ut(1, 1)+ut&
&           (1, 2)+ut(2, 2)+uc(2, 1)-0.25*gridstruct%cosa_u(2, 1)*(vt(1&
&           , 1)+vt(2, 1)+vt(2, 2))))*damp
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
        IF (se_corner) THEN
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx-1, 0)*gridstruct%&
&           cosa_v(npx-1, 0))
          ut(npx-1, 0) = (uc(npx-1, 0)-0.25*gridstruct%cosa_u(npx-1, 0)*&
&           (vt(npx-1, 1)+vt(npx-2, 1)+vt(npx-2, 0)+vc(npx-1, 0)-0.25*&
&           gridstruct%cosa_v(npx-1, 0)*(ut(npx, 0)+ut(npx, -1)+ut(npx-1&
&           , -1))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx+1, 1)*gridstruct%&
&           cosa_v(npx, 2))
          vt(npx, 2) = (vc(npx, 2)-0.25*gridstruct%cosa_v(npx, 2)*(ut(&
&           npx, 1)+ut(npx, 2)+ut(npx+1, 2)+uc(npx+1, 1)-0.25*gridstruct&
&           %cosa_u(npx+1, 1)*(vt(npx, 1)+vt(npx+1, 1)+vt(npx+1, 2))))*&
&           damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx-1, 1)*gridstruct%&
&           cosa_v(npx-1, 2))
          ut(npx-1, 1) = (uc(npx-1, 1)-0.25*gridstruct%cosa_u(npx-1, 1)*&
&           (vt(npx-1, 1)+vt(npx-2, 1)+vt(npx-2, 2)+vc(npx-1, 2)-0.25*&
&           gridstruct%cosa_v(npx-1, 2)*(ut(npx, 1)+ut(npx, 2)+ut(npx-1&
&           , 2))))*damp
          vt(npx-1, 2) = (vc(npx-1, 2)-0.25*gridstruct%cosa_v(npx-1, 2)*&
&           (ut(npx, 1)+ut(npx, 2)+ut(npx-1, 2)+uc(npx-1, 1)-0.25*&
&           gridstruct%cosa_u(npx-1, 1)*(vt(npx-1, 1)+vt(npx-2, 1)+vt(&
&           npx-2, 2))))*damp
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
        IF (ne_corner) THEN
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx-1, npy)*gridstruct%&
&           cosa_v(npx-1, npy+1))
          ut(npx-1, npy) = (uc(npx-1, npy)-0.25*gridstruct%cosa_u(npx-1&
&           , npy)*(vt(npx-1, npy)+vt(npx-2, npy)+vt(npx-2, npy+1)+vc(&
&           npx-1, npy+1)-0.25*gridstruct%cosa_v(npx-1, npy+1)*(ut(npx, &
&           npy)+ut(npx, npy+1)+ut(npx-1, npy+1))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx+1, npy-1)*&
&           gridstruct%cosa_v(npx, npy-1))
          vt(npx, npy-1) = (vc(npx, npy-1)-0.25*gridstruct%cosa_v(npx, &
&           npy-1)*(ut(npx, npy-1)+ut(npx, npy-2)+ut(npx+1, npy-2)+uc(&
&           npx+1, npy-1)-0.25*gridstruct%cosa_u(npx+1, npy-1)*(vt(npx, &
&           npy)+vt(npx+1, npy)+vt(npx+1, npy-1))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx-1, npy-1)*&
&           gridstruct%cosa_v(npx-1, npy-1))
          ut(npx-1, npy-1) = (uc(npx-1, npy-1)-0.25*gridstruct%cosa_u(&
&           npx-1, npy-1)*(vt(npx-1, npy)+vt(npx-2, npy)+vt(npx-2, npy-1&
&           )+vc(npx-1, npy-1)-0.25*gridstruct%cosa_v(npx-1, npy-1)*(ut(&
&           npx, npy-1)+ut(npx, npy-2)+ut(npx-1, npy-2))))*damp
          vt(npx-1, npy-1) = (vc(npx-1, npy-1)-0.25*gridstruct%cosa_v(&
&           npx-1, npy-1)*(ut(npx, npy-1)+ut(npx, npy-2)+ut(npx-1, npy-2&
&           )+uc(npx-1, npy-1)-0.25*gridstruct%cosa_u(npx-1, npy-1)*(vt(&
&           npx-1, npy)+vt(npx-2, npy)+vt(npx-2, npy-1))))*damp
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
        IF (nw_corner) THEN
          damp = 1./(1.-0.0625*gridstruct%cosa_u(2, npy)*gridstruct%&
&           cosa_v(1, npy+1))
          ut(2, npy) = (uc(2, npy)-0.25*gridstruct%cosa_u(2, npy)*(vt(1&
&           , npy)+vt(2, npy)+vt(2, npy+1)+vc(1, npy+1)-0.25*gridstruct%&
&           cosa_v(1, npy+1)*(ut(1, npy)+ut(1, npy+1)+ut(2, npy+1))))*&
&           damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(0, npy-1)*gridstruct%&
&           cosa_v(0, npy-1))
          vt(0, npy-1) = (vc(0, npy-1)-0.25*gridstruct%cosa_v(0, npy-1)*&
&           (ut(1, npy-1)+ut(1, npy-2)+ut(0, npy-2)+uc(0, npy-1)-0.25*&
&           gridstruct%cosa_u(0, npy-1)*(vt(0, npy)+vt(-1, npy)+vt(-1, &
&           npy-1))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(2, npy-1)*gridstruct%&
&           cosa_v(1, npy-1))
          ut(2, npy-1) = (uc(2, npy-1)-0.25*gridstruct%cosa_u(2, npy-1)*&
&           (vt(1, npy)+vt(2, npy)+vt(2, npy-1)+vc(1, npy-1)-0.25*&
&           gridstruct%cosa_v(1, npy-1)*(ut(1, npy-1)+ut(1, npy-2)+ut(2&
&           , npy-2))))*damp
          vt(1, npy-1) = (vc(1, npy-1)-0.25*gridstruct%cosa_v(1, npy-1)*&
&           (ut(1, npy-1)+ut(1, npy-2)+ut(2, npy-2)+uc(2, npy-1)-0.25*&
&           gridstruct%cosa_u(2, npy-1)*(vt(1, npy)+vt(2, npy)+vt(2, npy&
&           -1))))*damp
          CALL PUSHCONTROL2B_FV(3)
        ELSE
          CALL PUSHCONTROL2B_FV(2)
        END IF
      ELSE
        CALL PUSHCONTROL2B_FV(1)
      END IF
    ELSE
! flagstruct%grid_type >= 3
      DO j=jsd,jed
        DO i=is,ie+1
          ut(i, j) = uc(i, j)
        END DO
      END DO
      DO j=js,je+1
        DO i=isd,ied
          vt(i, j) = vc(i, j)
        END DO
      END DO
      CALL PUSHCONTROL2B_FV(0)
    END IF
    CALL PUSHREALARRAY(xfx_adv, 8*(bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)&
&                 /8)
    CALL PUSHINTEGER(ie)
    DO j=jsd,jed
      DO i=is,ie+1
        xfx_adv(i, j) = dt*ut(i, j)
      END DO
    END DO
    CALL PUSHREALARRAY(yfx_adv, 8*(bd%ied-bd%isd+1)*(bd%je-bd%js+2)&
&                 /8)
    DO j=js,je+1
      DO i=isd,ied
        yfx_adv(i, j) = dt*vt(i, j)
      END DO
    END DO
    CALL PUSHREALARRAY(crx_adv, 8*(bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)&
&                 /8)
    CALL PUSHREALARRAY(xfx_adv, 8*(bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)&
&                 /8)
    CALL PUSHINTEGER(ie)
! Explanation of the following code:
!    xfx_adv = dt*ut*dy   
!    crx_adv = dt*ut/dx
    DO j=jsd,jed
!DEC$ VECTOR ALWAYS
      DO i=is,ie+1
        IF (xfx_adv(i, j) .GT. 0.) THEN
          crx_adv(i, j) = xfx_adv(i, j)*gridstruct%rdxa(i-1, j)
          xfx_adv(i, j) = gridstruct%dy(i, j)*xfx_adv(i, j)*gridstruct%&
&           sin_sg(i-1, j, 3)
        ELSE
          crx_adv(i, j) = xfx_adv(i, j)*gridstruct%rdxa(i, j)
          xfx_adv(i, j) = gridstruct%dy(i, j)*xfx_adv(i, j)*gridstruct%&
&           sin_sg(i, j, 1)
        END IF
      END DO
    END DO
    CALL PUSHREALARRAY(yfx_adv, 8*(bd%ied-bd%isd+1)*(bd%je-bd%js+2)&
&                 /8)
    CALL PUSHREALARRAY(cry_adv, 8*(bd%ied-bd%isd+1)*(bd%je-bd%js+2)&
&                 /8)
    DO j=js,je+1
!DEC$ VECTOR ALWAYS
      DO i=isd,ied
        IF (yfx_adv(i, j) .GT. 0.) THEN
          cry_adv(i, j) = yfx_adv(i, j)*gridstruct%rdya(i, j-1)
          yfx_adv(i, j) = gridstruct%dx(i, j)*yfx_adv(i, j)*gridstruct%&
&           sin_sg(i, j-1, 4)
        ELSE
          cry_adv(i, j) = yfx_adv(i, j)*gridstruct%rdya(i, j)
          yfx_adv(i, j) = gridstruct%dx(i, j)*yfx_adv(i, j)*gridstruct%&
&           sin_sg(i, j, 2)
        END IF
      END DO
    END DO
!#ifdef SW_DYNAMICS
!      endif
!#endif
    DO j=jsd,jed
      DO i=is,ie
        ra_x(i, j) = gridstruct%area(i, j) + xfx_adv(i, j) - xfx_adv(i+1&
&         , j)
      END DO
    END DO
    DO j=js,je
      DO i=isd,ied
        ra_y(i, j) = gridstruct%area(i, j) + yfx_adv(i, j) - yfx_adv(i, &
&         j+1)
      END DO
    END DO
    IF (hord_dp .EQ. hord_dp_pert .AND. (.NOT.split_damp)) THEN
      CALL FV_TP_2D_FWD(delp, crx_adv, cry_adv, npx, npy, hord_dp, fx&
&                    , fy, xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y&
&                    , nord=nord_v, damp_c=damp_v)
      CALL PUSHCONTROL1B_FV(1)
    ELSE
      CALL PUSHREALARRAY(fy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/8)
      CALL PUSHREALARRAY(fx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/8)
      CALL PUSHREALARRAY(delp, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                   )/8)
      CALL FV_TP_2D(delp, crx_adv, cry_adv, npx, npy, hord_dp_pert, fx, &
&             fy, xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y, nord=&
&             nord_v_pert, damp_c=damp_v_pert)
      CALL PUSHCONTROL1B_FV(0)
    END IF
!#ifdef SW_DYNAMICS
!        do j=js,je
!           do i=is,ie
!              delp(i,j) = delp(i,j) +    &
!                         (fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*gridstruct%rarea(i,j)
!              ptc(i,j) = pt(i,j)
!           enddo
!        enddo
!#else
! <<< Save the mass fluxes to the "Flux Capacitor" for tracer transport >>>
    DO j=jsd,jed
      DO i=is,ie+1
        cx(i, j) = cx(i, j) + crx_adv(i, j)
      END DO
    END DO
    DO j=js,je
      DO i=is,ie+1
        xflux(i, j) = xflux(i, j) + fx(i, j)
      END DO
    END DO
    DO j=js,je+1
      DO i=isd,ied
        cy(i, j) = cy(i, j) + cry_adv(i, j)
      END DO
      DO i=is,ie
        yflux(i, j) = yflux(i, j) + fy(i, j)
      END DO
    END DO
    DO j=js,je
      DO i=is,ie
        heat_source(i, j) = 0.
      END DO
    END DO
    IF (.NOT.hydrostatic) THEN
      IF (damp_w .GT. 1.e-5) THEN
        damp4 = (damp_w*da_min_c)**(nord_w+1)
        CALL DEL6_VT_FLUX(nord_w, npx, npy, damp4, w, wk, fx2, fy2, &
&                   gridstruct, bd)
        DO j=js,je
          DO i=is,ie
            dw(i, j) = (fx2(i, j)-fx2(i+1, j)+fy2(i, j)-fy2(i, j+1))*&
&             gridstruct%rarea(i, j)
! 0.5 * [ (w+dw)**2 - w**2 ] = w*dw + 0.5*dw*dw
!                   heat_source(i,j) = -d_con*dw(i,j)*(w(i,j)+0.5*dw(i,j))
            heat_source(i, j) = -(dw(i, j)*(w(i, j)+0.5*dw(i, j)))
          END DO
        END DO
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (hord_vt .EQ. hord_vt_pert) THEN
        CALL FV_TP_2D_FWD(w, crx_adv, cry_adv, npx, npy, hord_vt, gx&
&                      , gy, xfx_adv, yfx_adv, gridstruct, bd, ra_x, &
&                      ra_y, mfx=fx, mfy=fy)
        CALL PUSHCONTROL1B_FV(1)
      ELSE
        CALL PUSHREALARRAY(gy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/8)
        CALL PUSHREALARRAY(gx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/8)
        CALL PUSHREALARRAY(w, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                     /8)
        CALL FV_TP_2D(w, crx_adv, cry_adv, npx, npy, hord_vt_pert, gx, &
&               gy, xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y, mfx=fx&
&               , mfy=fy)
        CALL PUSHCONTROL1B_FV(0)
      END IF
      DO j=js,je
        DO i=is,ie
          CALL PUSHREALARRAY(w(i, j))
          w(i, j) = delp(i, j)*w(i, j) + (gx(i, j)-gx(i+1, j)+gy(i, j)-&
&           gy(i, j+1))*gridstruct%rarea(i, j)
        END DO
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
!#ifdef USE_COND
!           call fv_tp_2d(q_con, crx_adv,cry_adv, npx, npy, hord_dp, gx, gy,  &
!                xfx_adv,yfx_adv, gridstruct, bd, ra_x, ra_y, mfx=fx, mfy=fy, mass=delp, nord=nord_t, damp_c=damp_t)
!            do j=js,je
!               do i=is,ie
!                  q_con(i,j) = delp(i,j)*q_con(i,j) + (gx(i,j)-gx(i+1,j)+gy(i,j)-gy(i,j+1))*gridstruct%rarea(i,j)
!               enddo
!            enddo
!#endif
    IF (inline_q) THEN
      DO j=jsd,jed
        DO i=isd,ied
          CALL PUSHREALARRAY(pt(i, j))
          pt(i, j) = pt(i, j)/(1.+zvir*q(i, j, k, sphum))
        END DO
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
    IF (hord_tm .EQ. hord_tm_pert .AND. (.NOT.split_damp)) THEN
      CALL FV_TP_2D_FWD(pt, crx_adv, cry_adv, npx, npy, hord_tm, gx, &
&                    gy, xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y, &
&                    mfx=fx, mfy=fy, mass=delp, nord=nord_t, damp_c=&
&                    damp_t)
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHREALARRAY(gy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/8)
      CALL PUSHREALARRAY(gx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/8)
      CALL PUSHREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/&
&                   8)
      CALL FV_TP_2D(pt, crx_adv, cry_adv, npx, npy, hord_tm_pert, gx, gy&
&             , xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y, mfx=fx, &
&             mfy=fy, mass=delp, nord=nord_t_pert, damp_c=damp_t_pert)
      CALL PUSHCONTROL1B_FV(1)
    END IF
    IF (inline_q) THEN
      DO j=js,je
        DO i=is,ie
          wk(i, j) = delp(i, j)
          CALL PUSHREALARRAY(delp(i, j))
          delp(i, j) = wk(i, j) + (fx(i, j)-fx(i+1, j)+fy(i, j)-fy(i, j+&
&           1))*gridstruct%rarea(i, j)
          CALL PUSHREALARRAY(pt(i, j))
          pt(i, j) = (pt(i, j)*wk(i, j)+(gx(i, j)-gx(i+1, j)+gy(i, j)-gy&
&           (i, j+1))*gridstruct%rarea(i, j))/delp(i, j)
        END DO
      END DO
      DO iq=1,nq
        IF (hord_tr .EQ. hord_tr_pert) THEN
          CALL FV_TP_2D_FWD(q(isd:ied, jsd:jed, k, iq), crx_adv, &
&                        cry_adv, npx, npy, hord_tr, gx, gy, xfx_adv, &
&                        yfx_adv, gridstruct, bd, ra_x, ra_y, mfx=fx, &
&                        mfy=fy)
          CALL PUSHCONTROL1B_FV(1)
        ELSE
          CALL PUSHREALARRAY(gy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/&
&                       8)
          CALL PUSHREALARRAY(gx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/&
&                       8)
          CALL PUSHREALARRAY(q(isd:ied, jsd:ied, k, iq), 8*(ied-isd&
&                       +1)*(ied-jsd+1)/8)
          CALL FV_TP_2D(q(isd:ied, jsd:ied, k, iq), crx_adv, cry_adv, &
&                 npx, npy, hord_tr_pert, gx, gy, xfx_adv, yfx_adv, &
&                 gridstruct, bd, ra_x, ra_y, mfx=fx, mfy=fy)
          CALL PUSHCONTROL1B_FV(0)
        END IF
        DO j=js,je
          DO i=is,ie
            CALL PUSHREALARRAY(q(i, j, k, iq))
            q(i, j, k, iq) = (q(i, j, k, iq)*wk(i, j)+(gx(i, j)-gx(i+1, &
&             j)+gy(i, j)-gy(i, j+1))*gridstruct%rarea(i, j))/delp(i, j)
          END DO
        END DO
      END DO
      DO j=js,je
        DO i=is,ie
          CALL PUSHREALARRAY(pt(i, j))
          pt(i, j) = pt(i, j)*(1.+zvir*q(i, j, k, sphum))
        END DO
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHREALARRAY(delp, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                   )/8)
      CALL PUSHREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/&
&                   8)
      DO j=js,je
        DO i=is,ie
          pt(i, j) = pt(i, j)*delp(i, j) + (gx(i, j)-gx(i+1, j)+gy(i, j)&
&           -gy(i, j+1))*gridstruct%rarea(i, j)
          delp(i, j) = delp(i, j) + (fx(i, j)-fx(i+1, j)+fy(i, j)-fy(i, &
&           j+1))*gridstruct%rarea(i, j)
        END DO
      END DO
      CALL PUSHREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/&
&                   8)
      DO j=js,je
        DO i=is,ie
          pt(i, j) = pt(i, j)/delp(i, j)
        END DO
      END DO
      CALL PUSHCONTROL1B_FV(1)
    END IF
!#endif
!#ifdef SW_DYNAMICS
!      if (test_case > 1) then
!#endif
!----------------------
! Kinetic Energy Fluxes
!----------------------
! Compute B grid contra-variant components for KE:
    dt5 = 0.5*dt
    dt4 = 0.25*dt
    IF (nested) THEN
      CALL PUSHCONTROL1B_FV(0)
      is2 = is
      ie1 = ie + 1
      js2 = js
      je1 = je + 1
    ELSE
      IF (2 .LT. is) THEN
        is2 = is
      ELSE
        is2 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        ie1 = ie + 1
      ELSE
        ie1 = npx - 1
      END IF
      IF (2 .LT. js) THEN
        js2 = js
      ELSE
        js2 = 2
      END IF
      IF (npy - 1 .GT. je + 1) THEN
        CALL PUSHCONTROL1B_FV(1)
        je1 = je + 1
      ELSE
        CALL PUSHCONTROL1B_FV(1)
        je1 = npy - 1
      END IF
    END IF
!!! TO DO: separate versions for nested and for cubed-sphere
    IF (flagstruct%grid_type .LT. 3) THEN
      IF (nested) THEN
        DO j=js2,je1
          DO i=is2,ie1
            vb(i, j) = dt5*(vc(i-1, j)+vc(i, j)-(uc(i, j-1)+uc(i, j))*&
&             gridstruct%cosa(i, j))*gridstruct%rsina(i, j)
          END DO
        END DO
        CALL PUSHCONTROL2B_FV(0)
      ELSE
        IF (js .EQ. 1) THEN
          DO i=is,ie+1
! corner values are incorrect
            vb(i, 1) = dt5*(vt(i-1, 1)+vt(i, 1))
          END DO
          CALL PUSHCONTROL1B_FV(1)
        ELSE
          CALL PUSHCONTROL1B_FV(0)
        END IF
        DO j=js2,je1
          DO i=is2,ie1
            vb(i, j) = dt5*(vc(i-1, j)+vc(i, j)-(uc(i, j-1)+uc(i, j))*&
&             gridstruct%cosa(i, j))*gridstruct%rsina(i, j)
          END DO
          IF (is .EQ. 1) THEN
! 2-pt extrapolation from both sides:
            vb(1, j) = dt4*(-vt(-1, j)+3.*(vt(0, j)+vt(1, j))-vt(2, j))
            CALL PUSHCONTROL1B_FV(0)
          ELSE
            CALL PUSHCONTROL1B_FV(1)
          END IF
          IF (ie + 1 .EQ. npx) THEN
! 2-pt extrapolation from both sides:
            vb(npx, j) = dt4*(-vt(npx-2, j)+3.*(vt(npx-1, j)+vt(npx, j))&
&             -vt(npx+1, j))
            CALL PUSHCONTROL1B_FV(1)
          ELSE
            CALL PUSHCONTROL1B_FV(0)
          END IF
        END DO
        IF (je + 1 .EQ. npy) THEN
          DO i=is,ie+1
! corner values are incorrect
            vb(i, npy) = dt5*(vt(i-1, npy)+vt(i, npy))
          END DO
          CALL PUSHCONTROL2B_FV(1)
        ELSE
          CALL PUSHCONTROL2B_FV(2)
        END IF
      END IF
    ELSE
      DO j=js,je+1
        DO i=is,ie+1
          vb(i, j) = dt5*(vc(i-1, j)+vc(i, j))
        END DO
      END DO
      CALL PUSHCONTROL2B_FV(3)
    END IF
    IF (hord_mt .EQ. hord_mt_pert) THEN
      CALL YTP_V_FWD(vb, u, v, ub, hord_mt, gridstruct%cosa, &
&                 gridstruct%dy, gridstruct%rdy, bd, npx, npy, &
&                 flagstruct%grid_type, nested)
      CALL PUSHCONTROL1B_FV(1)
    ELSE
      CALL YTP_V(vb, u, v, ub, hord_mt_pert, gridstruct%cosa, gridstruct&
&          %dy, gridstruct%rdy, bd, npx, npy, flagstruct%grid_type, &
&          nested)
      CALL PUSHCONTROL1B_FV(0)
    END IF
    DO j=js,je+1
      DO i=is,ie+1
        ke(i, j) = vb(i, j)*ub(i, j)
      END DO
    END DO
    IF (flagstruct%grid_type .LT. 3) THEN
      IF (nested) THEN
        DO j=js,je+1
          DO i=is2,ie1
            CALL PUSHREALARRAY(ub(i, j))
            ub(i, j) = dt5*(uc(i, j-1)+uc(i, j)-(vc(i-1, j)+vc(i, j))*&
&             gridstruct%cosa(i, j))*gridstruct%rsina(i, j)
          END DO
        END DO
        CALL PUSHCONTROL2B_FV(0)
      ELSE
        IF (is .EQ. 1) THEN
          DO j=js,je+1
! corner values are incorrect
            CALL PUSHREALARRAY(ub(1, j))
            ub(1, j) = dt5*(ut(1, j-1)+ut(1, j))
          END DO
          CALL PUSHCONTROL1B_FV(1)
        ELSE
          CALL PUSHCONTROL1B_FV(0)
        END IF
        DO j=js,je+1
          IF (j .EQ. 1 .OR. j .EQ. npy) THEN
            DO i=is2,ie1
! 2-pt extrapolation from both sides:
              CALL PUSHREALARRAY(ub(i, j))
              ub(i, j) = dt4*(-ut(i, j-2)+3.*(ut(i, j-1)+ut(i, j))-ut(i&
&               , j+1))
            END DO
            CALL PUSHCONTROL1B_FV(1)
          ELSE
            DO i=is2,ie1
              CALL PUSHREALARRAY(ub(i, j))
              ub(i, j) = dt5*(uc(i, j-1)+uc(i, j)-(vc(i-1, j)+vc(i, j))*&
&               gridstruct%cosa(i, j))*gridstruct%rsina(i, j)
            END DO
            CALL PUSHCONTROL1B_FV(0)
          END IF
        END DO
        IF (ie + 1 .EQ. npx) THEN
          DO j=js,je+1
! corner values are incorrect
            CALL PUSHREALARRAY(ub(npx, j))
            ub(npx, j) = dt5*(ut(npx, j-1)+ut(npx, j))
          END DO
          CALL PUSHCONTROL2B_FV(1)
        ELSE
          CALL PUSHCONTROL2B_FV(2)
        END IF
      END IF
    ELSE
      CALL PUSHREALARRAY(ub, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      DO j=js,je+1
        DO i=is,ie+1
          ub(i, j) = dt5*(uc(i, j-1)+uc(i, j))
        END DO
      END DO
      CALL PUSHCONTROL2B_FV(3)
    END IF
    IF (hord_mt .EQ. hord_mt_pert) THEN
      CALL XTP_U_FWD(ub, u, v, vb, hord_mt, gridstruct%cosa, &
&                 gridstruct%dx, gridstruct%rdx, bd, npx, npy, &
&                 flagstruct%grid_type, nested)
      CALL PUSHCONTROL1B_FV(1)
    ELSE
      CALL PUSHREALARRAY(vb, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      CALL XTP_U(ub, u, v, vb, hord_mt_pert, gridstruct%cosa, gridstruct&
&          %dx, gridstruct%rdx, bd, npx, npy, flagstruct%grid_type, &
&          nested)
      CALL PUSHCONTROL1B_FV(0)
    END IF
    DO j=js,je+1
      DO i=is,ie+1
        ke(i, j) = 0.5*(ke(i, j)+ub(i, j)*vb(i, j))
      END DO
    END DO
!-----------------------------------------
! Fix KE at the 4 corners of the face:
!-----------------------------------------
    IF (.NOT.nested) THEN
      dt6 = dt/6.
      IF (sw_corner) THEN
        ke(1, 1) = dt6*((ut(1, 1)+ut(1, 0))*u(1, 1)+(vt(1, 1)+vt(0, 1))*&
&         v(1, 1)+(ut(1, 1)+vt(1, 1))*u(0, 1))
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (se_corner) THEN
        ii = npx
        ke(ii, 1) = dt6*((ut(ii, 1)+ut(ii, 0))*u(ii-1, 1)+(vt(ii, 1)+vt(&
&         ii-1, 1))*v(ii, 1)+(ut(ii, 1)-vt(ii-1, 1))*u(ii, 1))
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (ne_corner) THEN
        ii = npx
        jj = npy
        ke(ii, jj) = dt6*((ut(ii, jj)+ut(ii, jj-1))*u(ii-1, jj)+(vt(ii, &
&         jj)+vt(ii-1, jj))*v(ii, jj-1)+(ut(ii, jj-1)+vt(ii-1, jj))*u(ii&
&         , jj))
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (nw_corner) THEN
        jj = npy
        ke(1, jj) = dt6*((ut(1, jj)+ut(1, jj-1))*u(1, jj)+(vt(1, jj)+vt(&
&         0, jj))*v(1, jj-1)+(ut(1, jj-1)-vt(1, jj))*u(0, jj))
        CALL PUSHCONTROL2B_FV(2)
      ELSE
        CALL PUSHCONTROL2B_FV(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B_FV(0)
    END IF
    CALL PUSHREALARRAY(vt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)/8)
! Compute vorticity:
    DO j=jsd,jed+1
      DO i=isd,ied
        vt(i, j) = u(i, j)*gridstruct%dx(i, j)
      END DO
    END DO
    CALL PUSHREALARRAY(ut, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)/8)
    DO j=jsd,jed
      DO i=isd,ied+1
        ut(i, j) = v(i, j)*gridstruct%dy(i, j)
      END DO
    END DO
    CALL PUSHREALARRAY(wk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8)
! wk is "volume-mean" relative vorticity
    DO j=jsd,jed
      DO i=isd,ied
        wk(i, j) = gridstruct%rarea(i, j)*(vt(i, j)-vt(i, j+1)-ut(i, j)+&
&         ut(i+1, j))
      END DO
    END DO
    IF (.NOT.hydrostatic) THEN
      IF (flagstruct%do_f3d) THEN
        CALL PUSHCONTROL1B_FV(0)
      ELSE
!#ifdef ROT3
!            dt2 = 2.*dt
!            do j=js,je
!               do i=is,ie
!                  w(i,j) = w(i,j)/delp(i,j) + dt2*gridstruct%w00(i,j) *  &
!                         ( gridstruct%a11(i,j)*(u(i,j)+u(i,j+1)) +       &
!                           gridstruct%a12(i,j)*(v(i,j)+v(i+1,j)) )
!               enddo
!            enddo
!#endif
        DO j=js,je
          DO i=is,ie
            CALL PUSHREALARRAY(w(i, j))
            w(i, j) = w(i, j)/delp(i, j)
          END DO
        END DO
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (damp_w .GT. 1.e-5) THEN
        DO j=js,je
          DO i=is,ie
            CALL PUSHREALARRAY(w(i, j))
            w(i, j) = w(i, j) + dw(i, j)
          END DO
        END DO
        CALL PUSHCONTROL2B_FV(0)
      ELSE
        CALL PUSHCONTROL2B_FV(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B_FV(2)
    END IF
!#ifdef USE_COND
!     do j=js,je
!        do i=is,ie
!           q_con(i,j) = q_con(i,j)/delp(i,j)
!        enddo
!     enddo
!#endif
!-----------------------------
! Compute divergence damping
!-----------------------------
!  damp = dddmp * da_min_c
    IF (.NOT.split_damp) THEN
      CALL COMPUTE_DIV_DAMPING_FWD(nord, d2_bg, d4_bg, dddmp, dt, &
&                               vort, ptc, delpc, ke, u, v, uc, vc, ua, &
&                               va, divg_d, wk, gridstruct, flagstruct, &
&                               bd)
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHREALARRAY(wk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/&
&                   8)
      CALL PUSHREALARRAY(divg_d, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd&
&                   +2)/8)
      CALL PUSHREALARRAY(vc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)/&
&                   8)
      CALL PUSHREALARRAY(uc, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)/&
&                   8)
      CALL PUSHREALARRAY(delpc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+&
&                   1)/8)
      CALL PUSHREALARRAY(ptc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                   /8)
      CALL PUSHREALARRAY(vort, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                   )/8)
      CALL COMPUTE_DIV_DAMPING(nord_pert, d2_bg_pert, d4_bg_pert, &
&                        dddmp_pert, dt, vort, ptc, delpc, ke, u, v, uc&
&                        , vc, ua, va, divg_d, wk, gridstruct, &
&                        flagstruct, bd)
      CALL PUSHCONTROL1B_FV(1)
    END IF
    IF (d_con .GT. 1.e-5) THEN
      CALL PUSHREALARRAY(ub, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      DO j=js,je+1
        DO i=is,ie
          ub(i, j) = vort(i, j) - vort(i+1, j)
        END DO
      END DO
      CALL PUSHREALARRAY(vb, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      DO j=js,je
        DO i=is,ie+1
          vb(i, j) = vort(i, j) - vort(i, j+1)
        END DO
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
! Vorticity transport
    IF (hydrostatic) THEN
      DO j=jsd,jed
        DO i=isd,ied
          vort(i, j) = wk(i, j) + gridstruct%f0(i, j)
        END DO
      END DO
      CALL PUSHCONTROL2B_FV(0)
    ELSE IF (flagstruct%do_f3d) THEN
      DO j=jsd,jed
        DO i=isd,ied
          vort(i, j) = wk(i, j) + gridstruct%f0(i, j)*z_rat(i, j)
        END DO
      END DO
      CALL PUSHCONTROL2B_FV(1)
    ELSE
      DO j=jsd,jed
        DO i=isd,ied
          vort(i, j) = wk(i, j) + gridstruct%f0(i, j)
        END DO
      END DO
      CALL PUSHCONTROL2B_FV(2)
    END IF
    IF (hord_vt .EQ. hord_vt_pert) THEN
      CALL FV_TP_2D_FWD(vort, crx_adv, cry_adv, npx, npy, hord_vt, fx&
&                    , fy, xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y)
      CALL PUSHCONTROL1B_FV(1)
    ELSE
      CALL PUSHREALARRAY(fy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/8)
      CALL PUSHREALARRAY(fx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/8)
      CALL PUSHREALARRAY(vort, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                   )/8)
      CALL FV_TP_2D(vort, crx_adv, cry_adv, npx, npy, hord_vt_pert, fx, &
&             fy, xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y)
      CALL PUSHCONTROL1B_FV(0)
    END IF
    CALL PUSHREALARRAY(u, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)/8)
    DO j=js,je+1
      DO i=is,ie
        u(i, j) = vt(i, j) + ke(i, j) - ke(i+1, j) + fy(i, j)
      END DO
    END DO
    CALL PUSHREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)/8)
    DO j=js,je
      DO i=is,ie+1
        v(i, j) = ut(i, j) + ke(i, j) - ke(i, j+1) - fx(i, j)
      END DO
    END DO
!--------------------------------------------------------
! damping applied to relative vorticity (wk):
    IF (damp_v .GT. 1.e-5) THEN
      damp4 = (damp_v*da_min_c)**(nord_v+1)
      CALL PUSHREALARRAY(vt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)/&
&                   8)
      CALL PUSHREALARRAY(ut, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)/&
&                   8)
      CALL PUSHREALARRAY(vort, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                   )/8)
      CALL DEL6_VT_FLUX(nord_v, npx, npy, damp4, wk, vort, ut, vt, &
&                 gridstruct, bd)
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
    IF (damp_v_pert .GT. 1.e-5) THEN
      damp4_pert = (damp_v_pert*da_min_c)**(nord_v_pert+1)
      CALL PUSHREALARRAY(vt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)/&
&                   8)
      CALL PUSHREALARRAY(ut, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)/&
&                   8)
      CALL PUSHREALARRAY(vort, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                   )/8)
      CALL DEL6_VT_FLUX(nord_v_pert, npx, npy, damp4_pert, wk, vort, ut&
&                 , vt, gridstruct, bd)
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
    IF (d_con .GT. 1.e-5) THEN
      CALL PUSHREALARRAY(ub, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      CALL PUSHREALARRAY(fy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/8)
      DO j=js,je+1
        DO i=is,ie
          ub(i, j) = (ub(i, j)+vt(i, j))*gridstruct%rdx(i, j)
          fy(i, j) = u(i, j)*gridstruct%rdx(i, j)
        END DO
      END DO
      CALL PUSHREALARRAY(gy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/8)
      DO j=js,je+1
        DO i=is,ie
          gy(i, j) = fy(i, j)*ub(i, j)
        END DO
      END DO
      CALL PUSHREALARRAY(vb, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      CALL PUSHREALARRAY(fx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/8)
      DO j=js,je
        DO i=is,ie+1
          vb(i, j) = (vb(i, j)-ut(i, j))*gridstruct%rdy(i, j)
          fx(i, j) = v(i, j)*gridstruct%rdy(i, j)
        END DO
      END DO
      CALL PUSHREALARRAY(gx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/8)
      DO j=js,je
        DO i=is,ie+1
          gx(i, j) = fx(i, j)*vb(i, j)
        END DO
      END DO
!----------------------------------
! Heating due to damping:
!----------------------------------
      damp = 0.25*d_con
      DO j=js,je
        DO i=is,ie
          u2 = fy(i, j) + fy(i, j+1)
          du2 = ub(i, j) + ub(i, j+1)
          v2 = fx(i, j) + fx(i+1, j)
          dv2 = vb(i, j) + vb(i+1, j)
! Total energy conserving:
! Convert lost KE due to divergence damping to "heat"
          CALL PUSHREALARRAY(heat_source(i, j))
          heat_source(i, j) = delp(i, j)*(heat_source(i, j)-damp*&
&           gridstruct%rsin2(i, j)*(ub(i, j)**2+ub(i, j+1)**2+vb(i, j)**&
&           2+vb(i+1, j)**2+2.*(gy(i, j)+gy(i, j+1)+gx(i, j)+gx(i+1, j))&
&           -gridstruct%cosa_s(i, j)*(u2*dv2+v2*du2+du2*dv2)))
        END DO
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
! Add diffusive fluxes to the momentum equation:
    IF (damp_v .GT. 1.e-5) THEN
      CALL PUSHREALARRAY(u, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)/8&
&                  )
      DO j=js,je+1
        DO i=is,ie
          u(i, j) = u(i, j) + vt(i, j)
        END DO
      END DO
      CALL PUSHREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)/8&
&                  )
      DO j=js,je
        DO i=is,ie+1
          v(i, j) = v(i, j) - ut(i, j)
        END DO
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
    IF (damp_v_pert .GT. 1.e-5) THEN
      CALL PUSHREALARRAY(u, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)/8&
&                  )
      DO j=js,je+1
        DO i=is,ie
          u(i, j) = u(i, j) + vt(i, j)
        END DO
      END DO
      CALL PUSHREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)/8&
&                  )
      DO j=js,je
        DO i=is,ie+1
          v(i, j) = v(i, j) - ut(i, j)
        END DO
      END DO
      CALL PUSHINTEGER(js)
      CALL PUSHINTEGER(npx)
      CALL PUSHINTEGER(npy)
      CALL PUSHINTEGER(max1)
      CALL PUSHINTEGER(max2)
      CALL PUSHINTEGER(max3)
      CALL PUSHINTEGER(max4)
      CALL PUSHREALARRAY(damp)
      CALL PUSHREALARRAY(gx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/8)
      CALL PUSHREALARRAY(gy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/8)
      CALL PUSHREALARRAY(dw, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8)
      CALL PUSHINTEGER(is2)
      CALL PUSHREALARRAY(ub, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      CALL PUSHREALARRAY(ut, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)/&
&                   8)
      CALL PUSHREALARRAY(da_min_c)
      CALL PUSHINTEGER(je1)
      CALL PUSHREALARRAY(dt4)
      CALL PUSHREALARRAY(dt6)
      CALL PUSHINTEGER(ie)
      CALL PUSHREALARRAY(ra_x, 8*(bd%ie-bd%is+1)*(bd%jed-bd%jsd+1)/&
&                   8)
      CALL PUSHREALARRAY(vb, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      CALL PUSHREALARRAY(ra_y, 8*(bd%ied-bd%isd+1)*(bd%je-bd%js+1)/&
&                   8)
      CALL PUSHREALARRAY(vort, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                   )/8)
      CALL PUSHINTEGER(is)
      CALL PUSHREALARRAY(vt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)/&
&                   8)
      CALL PUSHINTEGER(js2)
      CALL PUSHREALARRAY(fx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/8)
      CALL PUSHINTEGER(min1)
      CALL PUSHREALARRAY(fy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/8)
      CALL PUSHINTEGER(min2)
      CALL PUSHINTEGER(min3)
      CALL PUSHINTEGER(ie1)
      CALL PUSHINTEGER(min4)
      CALL PUSHINTEGER(je)
      CALL PUSHREALARRAY(wk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/&
&                   8)
      CALL PUSHCONTROL1B_FV(1)
    ELSE
      CALL PUSHINTEGER(js)
      CALL PUSHINTEGER(npx)
      CALL PUSHINTEGER(npy)
      CALL PUSHINTEGER(max1)
      CALL PUSHINTEGER(max2)
      CALL PUSHINTEGER(max3)
      CALL PUSHINTEGER(max4)
      CALL PUSHREALARRAY(damp)
      CALL PUSHREALARRAY(gx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/8)
      CALL PUSHREALARRAY(gy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/8)
      CALL PUSHREALARRAY(dw, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8)
      CALL PUSHINTEGER(is2)
      CALL PUSHREALARRAY(ub, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      CALL PUSHREALARRAY(ut, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)/&
&                   8)
      CALL PUSHREALARRAY(da_min_c)
      CALL PUSHINTEGER(je1)
      CALL PUSHREALARRAY(dt4)
      CALL PUSHREALARRAY(dt6)
      CALL PUSHINTEGER(ie)
      CALL PUSHREALARRAY(ra_x, 8*(bd%ie-bd%is+1)*(bd%jed-bd%jsd+1)/&
&                   8)
      CALL PUSHREALARRAY(vb, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      CALL PUSHREALARRAY(ra_y, 8*(bd%ied-bd%isd+1)*(bd%je-bd%js+1)/&
&                   8)
      CALL PUSHREALARRAY(vort, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                   )/8)
      CALL PUSHINTEGER(is)
      CALL PUSHREALARRAY(vt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)/&
&                   8)
      CALL PUSHINTEGER(js2)
      CALL PUSHREALARRAY(fx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/8)
      CALL PUSHINTEGER(min1)
      CALL PUSHREALARRAY(fy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/8)
      CALL PUSHINTEGER(min2)
      CALL PUSHINTEGER(min3)
      CALL PUSHINTEGER(ie1)
      CALL PUSHINTEGER(min4)
      CALL PUSHINTEGER(je)
      CALL PUSHREALARRAY(wk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/&
&                   8)
      CALL PUSHCONTROL1B_FV(0)
    END IF
  END SUBROUTINE D_SW_FWD
!  Differentiation of d_sw in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod.a2
!b_ord4_fb a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo 
!dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.
!grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.raylei
!gh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to_la
!tlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energy f
!v_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mod.
!map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv_tr
!acer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver_c 
!nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core_mo
!d.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_cor
!ner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.c
!ompute_div_damping_fb sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mod.c
!opy_corners_fb tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_mod.
!fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: yfx_adv q crx_adv u v w delp
!                ua xfx_adv uc ptc xflux cry_adv delpc va vc yflux
!                divg_d z_rat heat_source pt cx cy
!   with respect to varying inputs: yfx_adv q crx_adv u v w delp
!                ua xfx_adv uc ptc xflux cry_adv delpc va vc yflux
!                divg_d z_rat heat_source pt cx cy
!     d_sw :: D-Grid Shallow Water Routine
  SUBROUTINE D_SW_BWD(delpc, delpc_ad, delpc_tj, delp, delp_ad, ptc, &
&   ptc_ad, pt, pt_ad, u, u_ad, v, v_ad, w, w_ad, uc, uc_ad, vc, vc_ad, &
&   ua, ua_ad, va, va_ad, divg_d, divg_d_ad, xflux, xflux_ad, yflux, &
&   yflux_ad, cx, cx_ad, cy, cy_ad, crx_adv, crx_adv_ad, cry_adv, &
&   cry_adv_ad, xfx_adv, xfx_adv_ad, yfx_adv, yfx_adv_ad, q_con, z_rat, &
&   z_rat_ad, heat_source, heat_source_ad, zvir, sphum, nq, q, q_ad, k, &
&   km, inline_q, dt, hord_tr, hord_mt, hord_vt, hord_tm, hord_dp, &
&   hord_tr_pert, hord_mt_pert, hord_vt_pert, hord_tm_pert, hord_dp_pert&
&   , nord, nord_v, nord_w, nord_t, dddmp, d2_bg, d4_bg, damp_v, damp_w&
&   , damp_t, d_con, split_damp, nord_pert, nord_v_pert, nord_w_pert, &
&   nord_t_pert, dddmp_pert, d2_bg_pert, d4_bg_pert, damp_v_pert, &
&   damp_w_pert, damp_t_pert, d_con_pert, hydrostatic, gridstruct, &
&   flagstruct, bd)
    IMPLICIT NONE
!#ifdef SW_DYNAMICS
!      endif ! test_case
!#endif
    INTEGER, INTENT(IN) :: hord_tr, hord_mt, hord_vt, hord_tm, hord_dp
    INTEGER, INTENT(IN) :: hord_tr_pert, hord_mt_pert, hord_vt_pert, &
&   hord_tm_pert, hord_dp_pert
    INTEGER, INTENT(IN) :: nord
    INTEGER, INTENT(IN) :: nord_v
    INTEGER, INTENT(IN) :: nord_w
    INTEGER, INTENT(IN) :: nord_t
    LOGICAL, INTENT(IN) :: split_damp
    INTEGER, INTENT(IN) :: nord_pert, nord_v_pert, nord_w_pert, &
&   nord_t_pert
    INTEGER, INTENT(IN) :: sphum, nq, k, km
    REAL(fvprc), INTENT(IN) :: dt, dddmp, d2_bg, d4_bg, d_con
    REAL(fvprc), INTENT(IN) :: dddmp_pert, d2_bg_pert, d4_bg_pert, &
&   d_con_pert
    REAL(fvprc), INTENT(IN) :: zvir
    REAL(fvprc), INTENT(IN) :: damp_v, damp_w, damp_t
    REAL(fvprc), INTENT(IN) :: damp_v_pert, damp_w_pert, damp_t_pert
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(INOUT) :: divg_d(bd%isd:bd%ied+1, bd%jsd:bd%jed+&
&   1)
    REAL(fvprc), INTENT(INOUT) :: divg_d_ad(bd%isd:bd%ied+1, bd%jsd:bd%&
&   jed+1)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   z_rat
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: z_rat_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delp, pt, ua, va, w
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delp_ad, pt_ad, ua_ad, va_ad, w_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%isd, bd%jsd:bd%jsd), INTENT(INOUT) &
&   :: q_con
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u, vc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u_ad, vc_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v, uc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v_ad, uc_ad
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, km, nq&
&   )
    REAL(fvprc), INTENT(INOUT) :: q_ad(bd%isd:bd%ied, bd%jsd:bd%jed, km&
&   , nq)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: delpc, ptc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: delpc_ad, &
&   ptc_ad
    REAL(fvprc), DIMENSION(bd%is:bd%ie, bd%js:bd%je) :: heat_source
    REAL(fvprc), DIMENSION(bd%is:bd%ie, bd%js:bd%je) :: heat_source_ad
    REAL(fvprc), INTENT(INOUT) :: xflux(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc), INTENT(INOUT) :: xflux_ad(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc), INTENT(INOUT) :: yflux(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc), INTENT(INOUT) :: yflux_ad(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc), INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: cx_ad(bd%is:bd%ie+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1)
    REAL(fvprc), INTENT(INOUT) :: cy_ad(bd%isd:bd%ied, bd%js:bd%je+1)
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: inline_q
    REAL(fvprc), DIMENSION(bd%is:bd%ie+1, bd%jsd:bd%jed) :: crx_adv, &
&   xfx_adv
    REAL(fvprc), DIMENSION(bd%is:bd%ie+1, bd%jsd:bd%jed) :: crx_adv_ad, &
&   xfx_adv_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%js:bd%je+1) :: cry_adv, &
&   yfx_adv
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%js:bd%je+1) :: cry_adv_ad, &
&   yfx_adv_ad
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
    REAL(fvprc) :: ut(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: ut_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: vt(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: vt_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: fx2(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: fx2_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: fy2(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: fy2_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: dw(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: dw_ad(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc), DIMENSION(bd%is:bd%ie+1, bd%js:bd%je+1) :: ub, vb
    REAL(fvprc), DIMENSION(bd%is:bd%ie+1, bd%js:bd%je+1) :: ub_ad, vb_ad
    REAL(fvprc) :: wk(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk_ad(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: ke(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
    REAL(fvprc) :: ke_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
    REAL(fvprc) :: vort(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: vort_ad(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: fx(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: fx_ad(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: fy(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: fy_ad(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: ra_x(bd%is:bd%ie, bd%jsd:bd%jed)
    REAL(fvprc) :: ra_x_ad(bd%is:bd%ie, bd%jsd:bd%jed)
    REAL(fvprc) :: ra_y(bd%isd:bd%ied, bd%js:bd%je)
    REAL(fvprc) :: ra_y_ad(bd%isd:bd%ied, bd%js:bd%je)
    REAL(fvprc) :: gx(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: gx_ad(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: gy(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: gy_ad(bd%is:bd%ie, bd%js:bd%je+1)
    LOGICAL :: fill_c
    REAL(fvprc) :: dt2, dt4, dt5, dt6
    REAL(fvprc) :: damp, damp2, damp4, dd8, u2, v2, du2, dv2, damp4_pert
    REAL(fvprc) :: u2_ad, v2_ad, du2_ad, dv2_ad
    REAL(fvprc) :: u_lon
    INTEGER :: i, j, ii, jj, is2, ie1, js2, je1, n, nt, n2, iq
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTEGER :: npx, npy
    LOGICAL :: nested
    REAL(fvprc) :: da_min, da_min_c
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: delp_tj, &
&   pt_tj, w_tj
    REAL(fvprc) :: q_tj(bd%isd:bd%ied, bd%jsd:bd%jed, km, nq)
    REAL(fvprc) :: vort_tj(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), DIMENSION(bd%is:bd%ie+1, bd%js:bd%je+1) :: ub_tj, vb_tj
    REAL(fvprc) :: fx_tj(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: fy_tj(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: gx_tj(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: gy_tj(bd%is:bd%ie, bd%js:bd%je+1)
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(OUT) ::&
&   delpc_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ptc_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1) :: ke_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1) :: u_tj, &
&   vc_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed) :: v_tj, &
&   uc_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ua_tj, va_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1) :: &
&   divg_d_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: wk_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed) :: ut_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1) :: vt_tj
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp_ad4
    REAL(fvprc) :: temp_ad5
    REAL(fvprc) :: temp_ad6
    REAL(fvprc) :: temp_ad7
    REAL(fvprc) :: temp_ad8
    REAL(fvprc) :: temp_ad9
    REAL(fvprc) :: temp_ad10
    REAL(fvprc) :: temp_ad11
    REAL(fvprc) :: temp_ad12
    REAL(fvprc) :: temp_ad13
    REAL(fvprc) :: temp_ad14
    REAL(fvprc) :: temp_ad15
    REAL(fvprc) :: temp_ad16
    REAL(fvprc) :: temp_ad17
    REAL(fvprc) :: temp_ad18
    REAL(fvprc) :: temp_ad19
    REAL(fvprc) :: temp_ad20
    REAL(fvprc) :: temp_ad21
    REAL(fvprc) :: temp_ad22
    REAL(fvprc) :: temp_ad23
    REAL(fvprc) :: temp_ad24
    REAL(fvprc) :: temp_ad25
    REAL(fvprc) :: temp_ad26
    REAL(fvprc) :: temp_ad27
    REAL(fvprc) :: temp_ad28
    REAL(fvprc) :: temp_ad29
    REAL(fvprc) :: temp_ad30
    REAL(fvprc) :: temp_ad31
    REAL(fvprc) :: temp_ad32
    REAL(fvprc) :: temp_ad33
    REAL(fvprc) :: temp_ad34
    REAL(fvprc) :: temp_ad35
    REAL(fvprc) :: temp_ad36
    REAL(fvprc) :: temp_ad37
    REAL(fvprc) :: temp_ad38
    REAL(fvprc) :: temp_ad39
    REAL(fvprc) :: temp_ad40
    REAL(fvprc) :: temp_ad41
    REAL(fvprc) :: temp_ad42
    REAL(fvprc) :: temp_ad43
    REAL(fvprc) :: temp_ad44
    REAL(fvprc) :: temp_ad45
    REAL(fvprc) :: temp_ad46
    REAL(fvprc) :: temp_ad47
    REAL(fvprc) :: temp_ad48
    REAL(fvprc) :: temp_ad49
    REAL(fvprc) :: temp
    REAL(fvprc) :: temp_ad50
    REAL(fvprc) :: temp_ad51
    REAL(fvprc) :: temp_ad52
    REAL(fvprc) :: temp0
    REAL(fvprc) :: temp_ad53
    REAL(fvprc) :: temp_ad54
    REAL(fvprc) :: temp_ad55
    REAL(fvprc) :: temp_ad56
    REAL(fvprc) :: temp_ad57
    REAL(fvprc) :: temp_ad58
    REAL(fvprc) :: temp_ad59
    REAL(fvprc) :: temp_ad60
    REAL(fvprc) :: temp_ad61
    REAL(fvprc) :: temp_ad62
    REAL(fvprc) :: temp_ad63
    REAL(fvprc) :: temp_ad64
    REAL(fvprc) :: temp_ad65
    REAL(fvprc) :: temp_ad66
    REAL(fvprc) :: temp_ad67
    REAL(fvprc) :: temp_ad68
    REAL(fvprc) :: temp_ad69
    REAL(fvprc) :: temp_ad70
    REAL(fvprc) :: temp_ad71
    REAL(fvprc) :: temp_ad72
    REAL(fvprc) :: temp_ad73
    REAL(fvprc) :: temp_ad74
    REAL(fvprc) :: temp_ad75
    REAL(fvprc) :: temp_ad76
    REAL(fvprc) :: temp_ad77
    REAL(fvprc) :: temp_ad78
    REAL(fvprc) :: temp_ad79
    REAL(fvprc) :: temp_ad80
    REAL(fvprc) :: temp1
    REAL(fvprc) :: temp_ad81
    REAL(fvprc) :: temp_ad82
    REAL(fvprc) :: temp_ad83
    REAL(fvprc) :: temp_ad84
    INTEGER :: branch
    REAL(fvprc) :: temp_ad85
    REAL(fvprc) :: temp_ad86
    REAL(fvprc) :: temp_ad87
    REAL(fvprc) :: temp_ad88
    REAL(fvprc) :: temp_ad89
    REAL(fvprc) :: temp_ad90
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(wk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8&
&                 )
      CALL POPINTEGER(je)
      CALL POPINTEGER(min4)
      CALL POPINTEGER(ie1)
      CALL POPINTEGER(min3)
      CALL POPINTEGER(min2)
      CALL POPREALARRAY(fy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/8)
      CALL POPINTEGER(min1)
      CALL POPREALARRAY(fx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/8)
      CALL POPINTEGER(js2)
      CALL POPREALARRAY(vt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)/8&
&                 )
      CALL POPINTEGER(is)
      CALL POPREALARRAY(vort, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                  /8)
      CALL POPREALARRAY(ra_y, 8*(bd%ied-bd%isd+1)*(bd%je-bd%js+1)/8&
&                 )
      CALL POPREALARRAY(vb, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      CALL POPREALARRAY(ra_x, 8*(bd%ie-bd%is+1)*(bd%jed-bd%jsd+1)/8&
&                 )
      CALL POPINTEGER(ie)
      CALL POPREALARRAY(dt6)
      CALL POPREALARRAY(dt4)
      CALL POPINTEGER(je1)
      CALL POPREALARRAY(da_min_c)
      CALL POPREALARRAY(ut, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)/8&
&                 )
      CALL POPREALARRAY(ub, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      CALL POPINTEGER(is2)
      CALL POPREALARRAY(dw, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8)
      CALL POPREALARRAY(gy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/8)
      CALL POPREALARRAY(gx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/8)
      CALL POPREALARRAY(damp)
      CALL POPINTEGER(max4)
      CALL POPINTEGER(max3)
      CALL POPINTEGER(max2)
      CALL POPINTEGER(max1)
      CALL POPINTEGER(npy)
      CALL POPINTEGER(npx)
      CALL POPINTEGER(js)
      ut_ad = 0.0_FVPRC
      vt_ad = 0.0_FVPRC
    ELSE
      CALL POPREALARRAY(wk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8&
&                 )
      CALL POPINTEGER(je)
      CALL POPINTEGER(min4)
      CALL POPINTEGER(ie1)
      CALL POPINTEGER(min3)
      CALL POPINTEGER(min2)
      CALL POPREALARRAY(fy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/8)
      CALL POPINTEGER(min1)
      CALL POPREALARRAY(fx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/8)
      CALL POPINTEGER(js2)
      CALL POPREALARRAY(vt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)/8&
&                 )
      CALL POPINTEGER(is)
      CALL POPREALARRAY(vort, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                  /8)
      CALL POPREALARRAY(ra_y, 8*(bd%ied-bd%isd+1)*(bd%je-bd%js+1)/8&
&                 )
      CALL POPREALARRAY(vb, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      CALL POPREALARRAY(ra_x, 8*(bd%ie-bd%is+1)*(bd%jed-bd%jsd+1)/8&
&                 )
      CALL POPINTEGER(ie)
      CALL POPREALARRAY(dt6)
      CALL POPREALARRAY(dt4)
      CALL POPINTEGER(je1)
      CALL POPREALARRAY(da_min_c)
      CALL POPREALARRAY(ut, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)/8&
&                 )
      CALL POPREALARRAY(ub, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      CALL POPINTEGER(is2)
      CALL POPREALARRAY(dw, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8)
      CALL POPREALARRAY(gy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/8)
      CALL POPREALARRAY(gx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/8)
      CALL POPREALARRAY(damp)
      CALL POPINTEGER(max4)
      CALL POPINTEGER(max3)
      CALL POPINTEGER(max2)
      CALL POPINTEGER(max1)
      CALL POPINTEGER(npy)
      CALL POPINTEGER(npx)
      CALL POPINTEGER(js)
      ut_ad = 0.0_FVPRC
      CALL POPREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)/8)
      DO j=js,je
        DO i=ie+1,is,-1
          ut_ad(i, j) = ut_ad(i, j) - v_ad(i, j)
        END DO
      END DO
      vt_ad = 0.0_FVPRC
      CALL POPREALARRAY(u, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)/8)
      DO j=js,je+1
        DO i=ie,is,-1
          vt_ad(i, j) = vt_ad(i, j) + u_ad(i, j)
        END DO
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)/8)
      DO j=js,je
        DO i=ie+1,is,-1
          ut_ad(i, j) = ut_ad(i, j) - v_ad(i, j)
        END DO
      END DO
      CALL POPREALARRAY(u, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)/8)
      DO j=js,je+1
        DO i=ie,is,-1
          vt_ad(i, j) = vt_ad(i, j) + u_ad(i, j)
        END DO
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      gx_ad = 0.0_FVPRC
      gy_ad = 0.0_FVPRC
      ub_ad = 0.0_FVPRC
      vb_ad = 0.0_FVPRC
      fx_ad = 0.0_FVPRC
      fy_ad = 0.0_FVPRC
      DO j=je,js,-1
        DO i=ie,is,-1
          dv2 = vb(i, j) + vb(i+1, j)
          v2 = fx(i, j) + fx(i+1, j)
          du2 = ub(i, j) + ub(i, j+1)
          u2 = fy(i, j) + fy(i, j+1)
          CALL POPREALARRAY(heat_source(i, j))
          temp1 = damp*gridstruct%rsin2(i, j)
          temp_ad81 = delp(i, j)*heat_source_ad(i, j)
          temp_ad82 = -(temp1*temp_ad81)
          temp_ad83 = 2.*temp_ad82
          temp_ad84 = -(gridstruct%cosa_s(i, j)*temp_ad82)
          delp_ad(i, j) = delp_ad(i, j) + (heat_source(i, j)-temp1*(ub(i&
&           , j)**2+ub(i, j+1)**2+vb(i, j)**2+vb(i+1, j)**2+2.*(gy(i, j)&
&           +gy(i, j+1)+gx(i, j)+gx(i+1, j))-gridstruct%cosa_s(i, j)*(u2&
&           *dv2+v2*du2+du2*dv2)))*heat_source_ad(i, j)
          ub_ad(i, j) = ub_ad(i, j) + 2*ub(i, j)*temp_ad82
          ub_ad(i, j+1) = ub_ad(i, j+1) + 2*ub(i, j+1)*temp_ad82
          vb_ad(i, j) = vb_ad(i, j) + 2*vb(i, j)*temp_ad82
          vb_ad(i+1, j) = vb_ad(i+1, j) + 2*vb(i+1, j)*temp_ad82
          gy_ad(i, j) = gy_ad(i, j) + temp_ad83
          gy_ad(i, j+1) = gy_ad(i, j+1) + temp_ad83
          gx_ad(i, j) = gx_ad(i, j) + temp_ad83
          gx_ad(i+1, j) = gx_ad(i+1, j) + temp_ad83
          u2_ad = dv2*temp_ad84
          dv2_ad = (du2+u2)*temp_ad84
          v2_ad = du2*temp_ad84
          du2_ad = (dv2+v2)*temp_ad84
          heat_source_ad(i, j) = temp_ad81
          vb_ad(i, j) = vb_ad(i, j) + dv2_ad
          vb_ad(i+1, j) = vb_ad(i+1, j) + dv2_ad
          fx_ad(i, j) = fx_ad(i, j) + v2_ad
          fx_ad(i+1, j) = fx_ad(i+1, j) + v2_ad
          ub_ad(i, j) = ub_ad(i, j) + du2_ad
          ub_ad(i, j+1) = ub_ad(i, j+1) + du2_ad
          fy_ad(i, j) = fy_ad(i, j) + u2_ad
          fy_ad(i, j+1) = fy_ad(i, j+1) + u2_ad
        END DO
      END DO
      CALL POPREALARRAY(gx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/8)
      DO j=js,je
        DO i=ie+1,is,-1
          fx_ad(i, j) = fx_ad(i, j) + vb(i, j)*gx_ad(i, j)
          vb_ad(i, j) = vb_ad(i, j) + fx(i, j)*gx_ad(i, j)
          gx_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      CALL POPREALARRAY(fx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/8)
      CALL POPREALARRAY(vb, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      DO j=js,je
        DO i=ie+1,is,-1
          v_ad(i, j) = v_ad(i, j) + gridstruct%rdy(i, j)*fx_ad(i, j)
          fx_ad(i, j) = 0.0_FVPRC
          temp_ad90 = gridstruct%rdy(i, j)*vb_ad(i, j)
          ut_ad(i, j) = ut_ad(i, j) - temp_ad90
          vb_ad(i, j) = temp_ad90
        END DO
      END DO
      CALL POPREALARRAY(gy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/8)
      DO j=js,je+1
        DO i=ie,is,-1
          fy_ad(i, j) = fy_ad(i, j) + ub(i, j)*gy_ad(i, j)
          ub_ad(i, j) = ub_ad(i, j) + fy(i, j)*gy_ad(i, j)
          gy_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      CALL POPREALARRAY(fy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/8)
      CALL POPREALARRAY(ub, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      DO j=js,je+1
        DO i=ie,is,-1
          u_ad(i, j) = u_ad(i, j) + gridstruct%rdx(i, j)*fy_ad(i, j)
          fy_ad(i, j) = 0.0_FVPRC
          temp_ad89 = gridstruct%rdx(i, j)*ub_ad(i, j)
          vt_ad(i, j) = vt_ad(i, j) + temp_ad89
          ub_ad(i, j) = temp_ad89
        END DO
      END DO
    ELSE
      gx_ad = 0.0_FVPRC
      gy_ad = 0.0_FVPRC
      ub_ad = 0.0_FVPRC
      vb_ad = 0.0_FVPRC
      fx_ad = 0.0_FVPRC
      fy_ad = 0.0_FVPRC
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      npx = flagstruct%npx
      npy = flagstruct%npy
      da_min_c = gridstruct%da_min_c
      damp4_pert = (damp_v_pert*da_min_c)**(nord_v_pert+1)
      CALL POPREALARRAY(vort, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                  /8)
      CALL POPREALARRAY(ut, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)/8&
&                 )
      CALL POPREALARRAY(vt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)/8&
&                 )
      wk_ad = 0.0_FVPRC
      vort_ad = 0.0_FVPRC
      CALL DEL6_VT_FLUX_ADM(nord_v_pert, npx, npy, damp4_pert, wk, wk_ad&
&                     , vort, vort_ad, ut, ut_ad, vt, vt_ad, gridstruct&
&                     , bd)
    ELSE
      vort_ad = 0.0_FVPRC
      wk_ad = 0.0_FVPRC
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      damp4 = (damp_v*da_min_c)**(nord_v+1)
      CALL POPREALARRAY(vort, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                  /8)
      CALL POPREALARRAY(ut, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)/8&
&                 )
      CALL POPREALARRAY(vt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)/8&
&                 )
      CALL DEL6_VT_FLUX_ADM(nord_v, npx, npy, damp4, wk, wk_ad, vort, &
&                     vort_ad, ut, ut_ad, vt, vt_ad, gridstruct, bd)
    END IF
    ke_ad = 0.0_FVPRC
    CALL POPREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)/8)
    DO j=js,je
      DO i=ie+1,is,-1
        ut_ad(i, j) = ut_ad(i, j) + v_ad(i, j)
        ke_ad(i, j) = ke_ad(i, j) + v_ad(i, j)
        ke_ad(i, j+1) = ke_ad(i, j+1) - v_ad(i, j)
        fx_ad(i, j) = fx_ad(i, j) - v_ad(i, j)
        v_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    CALL POPREALARRAY(u, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)/8)
    DO j=js,je+1
      DO i=ie,is,-1
        vt_ad(i, j) = vt_ad(i, j) + u_ad(i, j)
        ke_ad(i, j) = ke_ad(i, j) + u_ad(i, j)
        fy_ad(i, j) = fy_ad(i, j) + u_ad(i, j)
        ke_ad(i+1, j) = ke_ad(i+1, j) - u_ad(i, j)
        u_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(vort, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                  /8)
      CALL POPREALARRAY(fx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/8)
      CALL POPREALARRAY(fy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/8)
      ra_x_ad = 0.0_FVPRC
      ra_y_ad = 0.0_FVPRC
      CALL FV_TP_2D_ADM(vort, vort_ad, crx_adv, crx_adv_ad, cry_adv, &
&                 cry_adv_ad, npx, npy, hord_vt_pert, fx, fx_ad, fy, &
&                 fy_ad, xfx_adv, xfx_adv_ad, yfx_adv, yfx_adv_ad, &
&                 gridstruct, bd, ra_x, ra_x_ad, ra_y, ra_y_ad)
    ELSE
      ra_x_ad = 0.0_FVPRC
      ra_y_ad = 0.0_FVPRC
      CALL FV_TP_2D_BWD(vort, vort_ad, crx_adv, crx_adv_ad, cry_adv, &
&                    cry_adv_ad, npx, npy, hord_vt, fx, fx_ad, fy, fy_ad&
&                    , xfx_adv, xfx_adv_ad, yfx_adv, yfx_adv_ad, &
&                    gridstruct, bd, ra_x, ra_x_ad, ra_y, ra_y_ad)
    END IF
    jsd = bd%jsd
    ied = bd%ied
    isd = bd%isd
    jed = bd%jed
    CALL POPCONTROL2B_FV(branch)
    IF (branch .EQ. 0) THEN
      DO j=jed,jsd,-1
        DO i=ied,isd,-1
          wk_ad(i, j) = wk_ad(i, j) + vort_ad(i, j)
          vort_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
    ELSE IF (branch .EQ. 1) THEN
      DO j=jed,jsd,-1
        DO i=ied,isd,-1
          wk_ad(i, j) = wk_ad(i, j) + vort_ad(i, j)
          z_rat_ad(i, j) = z_rat_ad(i, j) + gridstruct%f0(i, j)*vort_ad(&
&           i, j)
          vort_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
    ELSE
      DO j=jed,jsd,-1
        DO i=ied,isd,-1
          wk_ad(i, j) = wk_ad(i, j) + vort_ad(i, j)
          vort_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(vb, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      DO j=js,je
        DO i=ie+1,is,-1
          vort_ad(i, j) = vort_ad(i, j) + vb_ad(i, j)
          vort_ad(i, j+1) = vort_ad(i, j+1) - vb_ad(i, j)
          vb_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      CALL POPREALARRAY(ub, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      DO j=js,je+1
        DO i=ie,is,-1
          vort_ad(i, j) = vort_ad(i, j) + ub_ad(i, j)
          vort_ad(i+1, j) = vort_ad(i+1, j) - ub_ad(i, j)
          ub_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL COMPUTE_DIV_DAMPING_BWD(nord, d2_bg, d4_bg, dddmp, dt, &
&                               vort, vort_ad, ptc, ptc_ad, delpc, &
&                               delpc_ad, ke, ke_ad, u, u_ad, v, v_ad, &
&                               uc, uc_ad, vc, vc_ad, ua, ua_ad, va, &
&                               va_ad, divg_d, divg_d_ad, wk, wk_ad, &
&                               gridstruct, flagstruct, bd)
    ELSE
      CALL POPREALARRAY(vort, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                  /8)
      CALL POPREALARRAY(ptc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/&
&                  8)
      CALL POPREALARRAY(delpc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                  )/8)
      CALL POPREALARRAY(uc, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)/8&
&                 )
      CALL POPREALARRAY(vc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)/8&
&                 )
      CALL POPREALARRAY(divg_d, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+&
&                  2)/8)
      CALL POPREALARRAY(wk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8&
&                 )
      CALL COMPUTE_DIV_DAMPING_ADM(nord_pert, d2_bg_pert, d4_bg_pert, &
&                            dddmp_pert, dt, vort, vort_ad, ptc, ptc_ad&
&                            , delpc, delpc_ad, ke, ke_ad, u, u_ad, v, &
&                            v_ad, uc, uc_ad, vc, vc_ad, ua, ua_ad, va, &
&                            va_ad, divg_d, divg_d_ad, wk, wk_ad, &
&                            gridstruct, flagstruct, bd)
    END IF
    CALL POPCONTROL2B_FV(branch)
    IF (branch .EQ. 0) THEN
      dw_ad = 0.0_FVPRC
      DO j=je,js,-1
        DO i=ie,is,-1
          CALL POPREALARRAY(w(i, j))
          dw_ad(i, j) = dw_ad(i, j) + w_ad(i, j)
        END DO
      END DO
    ELSE IF (branch .EQ. 1) THEN
      dw_ad = 0.0_FVPRC
    ELSE
      dw_ad = 0.0_FVPRC
      GOTO 100
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .NE. 0) THEN
      DO j=je,js,-1
        DO i=ie,is,-1
          CALL POPREALARRAY(w(i, j))
          temp_ad80 = w_ad(i, j)/delp(i, j)
          delp_ad(i, j) = delp_ad(i, j) - w(i, j)*temp_ad80/delp(i, j)
          w_ad(i, j) = temp_ad80
        END DO
      END DO
    END IF
 100 CALL POPREALARRAY(wk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8)
    DO j=jsd,jed
      DO i=ied,isd,-1
        temp_ad88 = gridstruct%rarea(i, j)*wk_ad(i, j)
        vt_ad(i, j) = vt_ad(i, j) + temp_ad88
        vt_ad(i, j+1) = vt_ad(i, j+1) - temp_ad88
        ut_ad(i+1, j) = ut_ad(i+1, j) + temp_ad88
        ut_ad(i, j) = ut_ad(i, j) - temp_ad88
        wk_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    CALL POPREALARRAY(ut, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)/8)
    DO j=jsd,jed
      DO i=ied+1,isd,-1
        v_ad(i, j) = v_ad(i, j) + gridstruct%dy(i, j)*ut_ad(i, j)
        ut_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    CALL POPREALARRAY(vt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)/8)
    DO j=jsd,jed+1
      DO i=ied,isd,-1
        u_ad(i, j) = u_ad(i, j) + gridstruct%dx(i, j)*vt_ad(i, j)
        vt_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    CALL POPCONTROL2B_FV(branch)
    IF (branch .NE. 0) THEN
      IF (branch .NE. 1) THEN
        dt6 = dt/6.
        jj = npy
        temp_ad76 = dt6*ke_ad(1, jj)
        temp_ad77 = u(1, jj)*temp_ad76
        temp_ad78 = v(1, jj-1)*temp_ad76
        temp_ad79 = u(0, jj)*temp_ad76
        ut_ad(1, jj) = ut_ad(1, jj) + temp_ad77
        ut_ad(1, jj-1) = ut_ad(1, jj-1) + temp_ad79 + temp_ad77
        u_ad(1, jj) = u_ad(1, jj) + (ut(1, jj)+ut(1, jj-1))*temp_ad76
        vt_ad(1, jj) = vt_ad(1, jj) + temp_ad78 - temp_ad79
        vt_ad(0, jj) = vt_ad(0, jj) + temp_ad78
        v_ad(1, jj-1) = v_ad(1, jj-1) + (vt(1, jj)+vt(0, jj))*temp_ad76
        u_ad(0, jj) = u_ad(0, jj) + (ut(1, jj-1)-vt(1, jj))*temp_ad76
        ke_ad(1, jj) = 0.0_FVPRC
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        ii = npx
        jj = npy
        temp_ad72 = dt6*ke_ad(ii, jj)
        temp_ad73 = u(ii-1, jj)*temp_ad72
        temp_ad74 = v(ii, jj-1)*temp_ad72
        temp_ad75 = u(ii, jj)*temp_ad72
        ut_ad(ii, jj) = ut_ad(ii, jj) + temp_ad73
        ut_ad(ii, jj-1) = ut_ad(ii, jj-1) + temp_ad75 + temp_ad73
        u_ad(ii-1, jj) = u_ad(ii-1, jj) + (ut(ii, jj)+ut(ii, jj-1))*&
&         temp_ad72
        vt_ad(ii, jj) = vt_ad(ii, jj) + temp_ad74
        vt_ad(ii-1, jj) = vt_ad(ii-1, jj) + temp_ad75 + temp_ad74
        v_ad(ii, jj-1) = v_ad(ii, jj-1) + (vt(ii, jj)+vt(ii-1, jj))*&
&         temp_ad72
        u_ad(ii, jj) = u_ad(ii, jj) + (ut(ii, jj-1)+vt(ii-1, jj))*&
&         temp_ad72
        ke_ad(ii, jj) = 0.0_FVPRC
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        ii = npx
        temp_ad68 = dt6*ke_ad(ii, 1)
        temp_ad69 = u(ii-1, 1)*temp_ad68
        temp_ad70 = v(ii, 1)*temp_ad68
        temp_ad71 = u(ii, 1)*temp_ad68
        ut_ad(ii, 1) = ut_ad(ii, 1) + temp_ad71 + temp_ad69
        ut_ad(ii, 0) = ut_ad(ii, 0) + temp_ad69
        u_ad(ii-1, 1) = u_ad(ii-1, 1) + (ut(ii, 1)+ut(ii, 0))*temp_ad68
        vt_ad(ii, 1) = vt_ad(ii, 1) + temp_ad70
        vt_ad(ii-1, 1) = vt_ad(ii-1, 1) + temp_ad70 - temp_ad71
        v_ad(ii, 1) = v_ad(ii, 1) + (vt(ii, 1)+vt(ii-1, 1))*temp_ad68
        u_ad(ii, 1) = u_ad(ii, 1) + (ut(ii, 1)-vt(ii-1, 1))*temp_ad68
        ke_ad(ii, 1) = 0.0_FVPRC
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        temp_ad67 = dt6*ke_ad(1, 1)
        ut_ad(1, 1) = ut_ad(1, 1) + (u(0, 1)+u(1, 1))*temp_ad67
        ut_ad(1, 0) = ut_ad(1, 0) + u(1, 1)*temp_ad67
        u_ad(1, 1) = u_ad(1, 1) + (ut(1, 1)+ut(1, 0))*temp_ad67
        vt_ad(1, 1) = vt_ad(1, 1) + (u(0, 1)+v(1, 1))*temp_ad67
        vt_ad(0, 1) = vt_ad(0, 1) + v(1, 1)*temp_ad67
        v_ad(1, 1) = v_ad(1, 1) + (vt(1, 1)+vt(0, 1))*temp_ad67
        u_ad(0, 1) = u_ad(0, 1) + (ut(1, 1)+vt(1, 1))*temp_ad67
        ke_ad(1, 1) = 0.0_FVPRC
      END IF
    END IF
    nested = gridstruct%nested
    DO j=je+1,js,-1
      DO i=ie+1,is,-1
        temp_ad66 = 0.5*ke_ad(i, j)
        ub_ad(i, j) = ub_ad(i, j) + vb(i, j)*temp_ad66
        vb_ad(i, j) = vb_ad(i, j) + ub(i, j)*temp_ad66
        ke_ad(i, j) = temp_ad66
      END DO
    END DO
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(vb, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      CALL XTP_U_ADM(ub, ub_ad, u, u_ad, v, vb, vb_ad, hord_mt_pert, &
&              gridstruct%cosa, gridstruct%dx, gridstruct%rdx, bd, npx, &
&              npy, flagstruct%grid_type, nested)
    ELSE
      CALL XTP_U_BWD(ub, ub_ad, u, u_ad, v, vb, vb_ad, hord_mt, &
&                 gridstruct%cosa, gridstruct%dx, gridstruct%rdx, bd, &
&                 npx, npy, flagstruct%grid_type, nested)
    END IF
    dt5 = 0.5*dt
    CALL POPCONTROL2B_FV(branch)
    IF (branch .LT. 2) THEN
      IF (branch .EQ. 0) THEN
        DO j=je+1,js,-1
          DO i=ie1,is2,-1
            CALL POPREALARRAY(ub(i, j))
            temp_ad61 = dt5*gridstruct%rsina(i, j)*ub_ad(i, j)
            temp_ad62 = -(gridstruct%cosa(i, j)*temp_ad61)
            uc_ad(i, j-1) = uc_ad(i, j-1) + temp_ad61
            uc_ad(i, j) = uc_ad(i, j) + temp_ad61
            vc_ad(i-1, j) = vc_ad(i-1, j) + temp_ad62
            vc_ad(i, j) = vc_ad(i, j) + temp_ad62
            ub_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
        GOTO 110
      ELSE
        DO j=je+1,js,-1
          CALL POPREALARRAY(ub(npx, j))
          ut_ad(npx, j-1) = ut_ad(npx, j-1) + dt5*ub_ad(npx, j)
          ut_ad(npx, j) = ut_ad(npx, j) + dt5*ub_ad(npx, j)
          ub_ad(npx, j) = 0.0_FVPRC
        END DO
      END IF
    ELSE IF (branch .NE. 2) THEN
      CALL POPREALARRAY(ub, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      DO j=js,je+1
        DO i=ie+1,is,-1
          uc_ad(i, j-1) = uc_ad(i, j-1) + dt5*ub_ad(i, j)
          uc_ad(i, j) = uc_ad(i, j) + dt5*ub_ad(i, j)
          ub_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      GOTO 110
    END IF
    dt4 = 0.25*dt
    DO j=je+1,js,-1
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        DO i=ie1,is2,-1
          CALL POPREALARRAY(ub(i, j))
          temp_ad64 = dt5*gridstruct%rsina(i, j)*ub_ad(i, j)
          temp_ad65 = -(gridstruct%cosa(i, j)*temp_ad64)
          uc_ad(i, j-1) = uc_ad(i, j-1) + temp_ad64
          uc_ad(i, j) = uc_ad(i, j) + temp_ad64
          vc_ad(i-1, j) = vc_ad(i-1, j) + temp_ad65
          vc_ad(i, j) = vc_ad(i, j) + temp_ad65
          ub_ad(i, j) = 0.0_FVPRC
        END DO
      ELSE
        DO i=ie1,is2,-1
          CALL POPREALARRAY(ub(i, j))
          temp_ad63 = dt4*ub_ad(i, j)
          ut_ad(i, j-1) = ut_ad(i, j-1) + 3.*temp_ad63
          ut_ad(i, j) = ut_ad(i, j) + 3.*temp_ad63
          ut_ad(i, j-2) = ut_ad(i, j-2) - temp_ad63
          ut_ad(i, j+1) = ut_ad(i, j+1) - temp_ad63
          ub_ad(i, j) = 0.0_FVPRC
        END DO
      END IF
    END DO
    CALL POPCONTROL1B_FV(branch)
    IF (branch .NE. 0) THEN
      DO j=je+1,js,-1
        CALL POPREALARRAY(ub(1, j))
        ut_ad(1, j-1) = ut_ad(1, j-1) + dt5*ub_ad(1, j)
        ut_ad(1, j) = ut_ad(1, j) + dt5*ub_ad(1, j)
        ub_ad(1, j) = 0.0_FVPRC
      END DO
    END IF
 110 DO j=je+1,js,-1
      DO i=ie+1,is,-1
        vb_ad(i, j) = vb_ad(i, j) + ub(i, j)*ke_ad(i, j)
        ub_ad(i, j) = ub_ad(i, j) + vb(i, j)*ke_ad(i, j)
        ke_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL YTP_V_ADM(vb, vb_ad, u, v, v_ad, ub, ub_ad, hord_mt_pert, &
&              gridstruct%cosa, gridstruct%dy, gridstruct%rdy, bd, npx, &
&              npy, flagstruct%grid_type, nested)
    ELSE
      CALL YTP_V_BWD(vb, vb_ad, u, v, v_ad, ub, ub_ad, hord_mt, &
&                 gridstruct%cosa, gridstruct%dy, gridstruct%rdy, bd, &
&                 npx, npy, flagstruct%grid_type, nested)
    END IF
    CALL POPCONTROL2B_FV(branch)
    IF (branch .LT. 2) THEN
      IF (branch .EQ. 0) THEN
        DO j=je1,js2,-1
          DO i=ie1,is2,-1
            temp_ad55 = dt5*gridstruct%rsina(i, j)*vb_ad(i, j)
            temp_ad56 = -(gridstruct%cosa(i, j)*temp_ad55)
            vc_ad(i-1, j) = vc_ad(i-1, j) + temp_ad55
            vc_ad(i, j) = vc_ad(i, j) + temp_ad55
            uc_ad(i, j-1) = uc_ad(i, j-1) + temp_ad56
            uc_ad(i, j) = uc_ad(i, j) + temp_ad56
            vb_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
        GOTO 120
      ELSE
        DO i=ie+1,is,-1
          vt_ad(i-1, npy) = vt_ad(i-1, npy) + dt5*vb_ad(i, npy)
          vt_ad(i, npy) = vt_ad(i, npy) + dt5*vb_ad(i, npy)
          vb_ad(i, npy) = 0.0_FVPRC
        END DO
      END IF
    ELSE IF (branch .NE. 2) THEN
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          vc_ad(i-1, j) = vc_ad(i-1, j) + dt5*vb_ad(i, j)
          vc_ad(i, j) = vc_ad(i, j) + dt5*vb_ad(i, j)
          vb_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      GOTO 120
    END IF
    DO j=je1,js2,-1
      CALL POPCONTROL1B_FV(branch)
      IF (branch .NE. 0) THEN
        temp_ad60 = dt4*vb_ad(npx, j)
        vt_ad(npx-1, j) = vt_ad(npx-1, j) + 3.*temp_ad60
        vt_ad(npx, j) = vt_ad(npx, j) + 3.*temp_ad60
        vt_ad(npx-2, j) = vt_ad(npx-2, j) - temp_ad60
        vt_ad(npx+1, j) = vt_ad(npx+1, j) - temp_ad60
        vb_ad(npx, j) = 0.0_FVPRC
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        temp_ad59 = dt4*vb_ad(1, j)
        vt_ad(0, j) = vt_ad(0, j) + 3.*temp_ad59
        vt_ad(1, j) = vt_ad(1, j) + 3.*temp_ad59
        vt_ad(-1, j) = vt_ad(-1, j) - temp_ad59
        vt_ad(2, j) = vt_ad(2, j) - temp_ad59
        vb_ad(1, j) = 0.0_FVPRC
      END IF
      DO i=ie1,is2,-1
        temp_ad57 = dt5*gridstruct%rsina(i, j)*vb_ad(i, j)
        temp_ad58 = -(gridstruct%cosa(i, j)*temp_ad57)
        vc_ad(i-1, j) = vc_ad(i-1, j) + temp_ad57
        vc_ad(i, j) = vc_ad(i, j) + temp_ad57
        uc_ad(i, j-1) = uc_ad(i, j-1) + temp_ad58
        uc_ad(i, j) = uc_ad(i, j) + temp_ad58
        vb_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    CALL POPCONTROL1B_FV(branch)
    IF (branch .NE. 0) THEN
      DO i=ie+1,is,-1
        vt_ad(i-1, 1) = vt_ad(i-1, 1) + dt5*vb_ad(i, 1)
        vt_ad(i, 1) = vt_ad(i, 1) + dt5*vb_ad(i, 1)
        vb_ad(i, 1) = 0.0_FVPRC
      END DO
    END IF
 120 CALL POPCONTROL1B_FV(branch)
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      DO j=je,js,-1
        DO i=ie,is,-1
          CALL POPREALARRAY(pt(i, j))
          q_ad(i, j, k, sphum) = q_ad(i, j, k, sphum) + pt(i, j)*zvir*&
&           pt_ad(i, j)
          pt_ad(i, j) = (zvir*q(i, j, k, sphum)+1.)*pt_ad(i, j)
        END DO
      END DO
      DO iq=nq,1,-1
        DO j=je,js,-1
          DO i=ie,is,-1
            CALL POPREALARRAY(q(i, j, k, iq))
            temp_ad53 = q_ad(i, j, k, iq)/delp(i, j)
            temp0 = q(i, j, k, iq)
            temp_ad54 = gridstruct%rarea(i, j)*temp_ad53
            wk_ad(i, j) = wk_ad(i, j) + temp0*temp_ad53
            gx_ad(i, j) = gx_ad(i, j) + temp_ad54
            gx_ad(i+1, j) = gx_ad(i+1, j) - temp_ad54
            gy_ad(i, j) = gy_ad(i, j) + temp_ad54
            gy_ad(i, j+1) = gy_ad(i, j+1) - temp_ad54
            delp_ad(i, j) = delp_ad(i, j) - (temp0*wk(i, j)+gridstruct%&
&             rarea(i, j)*(gx(i, j)-gx(i+1, j)+gy(i, j)-gy(i, j+1)))*&
&             temp_ad53/delp(i, j)
            q_ad(i, j, k, iq) = wk(i, j)*temp_ad53
          END DO
        END DO
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREALARRAY(q(isd:ied, jsd:ied, k, iq), 8*(ied-isd+&
&                      1)*(ied-jsd+1)/8)
          CALL POPREALARRAY(gx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/8&
&                     )
          CALL POPREALARRAY(gy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/8&
&                     )
          CALL FV_TP_2D_ADM(q(isd:ied, jsd:ied, k, iq), q_ad(isd:ied, &
&                     jsd:ied, k, iq), crx_adv, crx_adv_ad, cry_adv, &
&                     cry_adv_ad, npx, npy, hord_tr_pert, gx, gx_ad, gy&
&                     , gy_ad, xfx_adv, xfx_adv_ad, yfx_adv, yfx_adv_ad&
&                     , gridstruct, bd, ra_x, ra_x_ad, ra_y, ra_y_ad, &
&                     mfx=fx, mfx_ad=fx_ad, mfy=fy, mfy_ad=fy_ad)
        ELSE
          CALL FV_TP_2D_BWD(q(isd:ied, jsd:jed, k, iq), q_ad(isd:ied&
&                        , jsd:jed, k, iq), crx_adv, crx_adv_ad, cry_adv&
&                        , cry_adv_ad, npx, npy, hord_tr, gx, gx_ad, gy&
&                        , gy_ad, xfx_adv, xfx_adv_ad, yfx_adv, &
&                        yfx_adv_ad, gridstruct, bd, ra_x, ra_x_ad, ra_y&
&                        , ra_y_ad, mfx=fx, mfx=fx_ad, mfy=fy, mfy=fy_ad&
&                       )
        END IF
      END DO
      DO j=je,js,-1
        DO i=ie,is,-1
          CALL POPREALARRAY(pt(i, j))
          temp_ad50 = pt_ad(i, j)/delp(i, j)
          temp_ad51 = gridstruct%rarea(i, j)*temp_ad50
          gx_ad(i, j) = gx_ad(i, j) + temp_ad51
          gx_ad(i+1, j) = gx_ad(i+1, j) - temp_ad51
          gy_ad(i, j) = gy_ad(i, j) + temp_ad51
          gy_ad(i, j+1) = gy_ad(i, j+1) - temp_ad51
          delp_ad(i, j) = delp_ad(i, j) - (pt(i, j)*wk(i, j)+gridstruct%&
&           rarea(i, j)*(gx(i, j)-gx(i+1, j)+gy(i, j)-gy(i, j+1)))*&
&           temp_ad50/delp(i, j)
          wk_ad(i, j) = wk_ad(i, j) + delp_ad(i, j) + pt(i, j)*temp_ad50
          pt_ad(i, j) = wk(i, j)*temp_ad50
          CALL POPREALARRAY(delp(i, j))
          temp_ad52 = gridstruct%rarea(i, j)*delp_ad(i, j)
          fx_ad(i, j) = fx_ad(i, j) + temp_ad52
          fx_ad(i+1, j) = fx_ad(i+1, j) - temp_ad52
          fy_ad(i, j) = fy_ad(i, j) + temp_ad52
          fy_ad(i, j+1) = fy_ad(i, j+1) - temp_ad52
          delp_ad(i, j) = wk_ad(i, j)
          wk_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
    ELSE
      CALL POPREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8&
&                 )
      DO j=js,je
        DO i=ie,is,-1
          temp_ad87 = pt_ad(i, j)/delp(i, j)
          delp_ad(i, j) = delp_ad(i, j) - pt(i, j)*temp_ad87/delp(i, j)
          pt_ad(i, j) = temp_ad87
        END DO
      END DO
      CALL POPREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8&
&                 )
      CALL POPREALARRAY(delp, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                  /8)
      DO j=js,je
        DO i=ie,is,-1
          temp_ad85 = gridstruct%rarea(i, j)*delp_ad(i, j)
          fx_ad(i, j) = fx_ad(i, j) + temp_ad85
          fx_ad(i+1, j) = fx_ad(i+1, j) - temp_ad85
          fy_ad(i, j) = fy_ad(i, j) + temp_ad85
          fy_ad(i, j+1) = fy_ad(i, j+1) - temp_ad85
          temp_ad86 = gridstruct%rarea(i, j)*pt_ad(i, j)
          delp_ad(i, j) = delp_ad(i, j) + pt(i, j)*pt_ad(i, j)
          gx_ad(i, j) = gx_ad(i, j) + temp_ad86
          gx_ad(i+1, j) = gx_ad(i+1, j) - temp_ad86
          gy_ad(i, j) = gy_ad(i, j) + temp_ad86
          gy_ad(i, j+1) = gy_ad(i, j+1) - temp_ad86
          pt_ad(i, j) = delp(i, j)*pt_ad(i, j)
        END DO
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL FV_TP_2D_BWD(pt, pt_ad, crx_adv, crx_adv_ad, cry_adv, &
&                    cry_adv_ad, npx, npy, hord_tm, gx, gx_ad, gy, gy_ad&
&                    , xfx_adv, xfx_adv_ad, yfx_adv, yfx_adv_ad, &
&                    gridstruct, bd, ra_x, ra_x_ad, ra_y, ra_y_ad, mfx=&
&                    fx, mfx=fx_ad, mfy=fy, mfy=fy_ad, mass=delp, mass=&
&                    delp_ad, nord=nord_t, damp_c=damp_t)
    ELSE
      CALL POPREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8&
&                 )
      CALL POPREALARRAY(gx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/8)
      CALL POPREALARRAY(gy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/8)
      CALL FV_TP_2D_ADM(pt, pt_ad, crx_adv, crx_adv_ad, cry_adv, &
&                 cry_adv_ad, npx, npy, hord_tm_pert, gx, gx_ad, gy, &
&                 gy_ad, xfx_adv, xfx_adv_ad, yfx_adv, yfx_adv_ad, &
&                 gridstruct, bd, ra_x, ra_x_ad, ra_y, ra_y_ad, mfx=fx, &
&                 mfx_ad=fx_ad, mfy=fy, mfy_ad=fy_ad, mass=delp, mass_ad&
&                 =delp_ad, nord=nord_t_pert, damp_c=damp_t_pert)
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      DO j=jed,jsd,-1
        DO i=ied,isd,-1
          CALL POPREALARRAY(pt(i, j))
          temp = zvir*q(i, j, k, sphum) + 1.
          q_ad(i, j, k, sphum) = q_ad(i, j, k, sphum) - pt(i, j)*zvir*&
&           pt_ad(i, j)/temp**2
          pt_ad(i, j) = pt_ad(i, j)/temp
        END DO
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      DO j=je,js,-1
        DO i=ie,is,-1
          CALL POPREALARRAY(w(i, j))
          temp_ad49 = gridstruct%rarea(i, j)*w_ad(i, j)
          delp_ad(i, j) = delp_ad(i, j) + w(i, j)*w_ad(i, j)
          gx_ad(i, j) = gx_ad(i, j) + temp_ad49
          gx_ad(i+1, j) = gx_ad(i+1, j) - temp_ad49
          gy_ad(i, j) = gy_ad(i, j) + temp_ad49
          gy_ad(i, j+1) = gy_ad(i, j+1) - temp_ad49
          w_ad(i, j) = delp(i, j)*w_ad(i, j)
        END DO
      END DO
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREALARRAY(w, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/&
&                    8)
        CALL POPREALARRAY(gx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/8)
        CALL POPREALARRAY(gy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/8)
        CALL FV_TP_2D_ADM(w, w_ad, crx_adv, crx_adv_ad, cry_adv, &
&                   cry_adv_ad, npx, npy, hord_vt_pert, gx, gx_ad, gy, &
&                   gy_ad, xfx_adv, xfx_adv_ad, yfx_adv, yfx_adv_ad, &
&                   gridstruct, bd, ra_x, ra_x_ad, ra_y, ra_y_ad, mfx=fx&
&                   , mfx_ad=fx_ad, mfy=fy, mfy_ad=fy_ad)
      ELSE
        CALL FV_TP_2D_BWD(w, w_ad, crx_adv, crx_adv_ad, cry_adv, &
&                      cry_adv_ad, npx, npy, hord_vt, gx, gx_ad, gy, &
&                      gy_ad, xfx_adv, xfx_adv_ad, yfx_adv, yfx_adv_ad, &
&                      gridstruct, bd, ra_x, ra_x_ad, ra_y, ra_y_ad, mfx&
&                      =fx, mfx=fx_ad, mfy=fy, mfy=fy_ad)
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        fy2_ad = 0.0_FVPRC
        fx2_ad = 0.0_FVPRC
        DO j=je,js,-1
          DO i=ie,is,-1
            temp_ad47 = -(dw(i, j)*heat_source_ad(i, j))
            dw_ad(i, j) = dw_ad(i, j) + 0.5*temp_ad47 - (w(i, j)+0.5*dw(&
&             i, j))*heat_source_ad(i, j)
            w_ad(i, j) = w_ad(i, j) + temp_ad47
            heat_source_ad(i, j) = 0.0_FVPRC
            temp_ad48 = gridstruct%rarea(i, j)*dw_ad(i, j)
            fx2_ad(i, j) = fx2_ad(i, j) + temp_ad48
            fx2_ad(i+1, j) = fx2_ad(i+1, j) - temp_ad48
            fy2_ad(i, j) = fy2_ad(i, j) + temp_ad48
            fy2_ad(i, j+1) = fy2_ad(i, j+1) - temp_ad48
            dw_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
        damp4 = (damp_w*da_min_c)**(nord_w+1)
        CALL DEL6_VT_FLUX_ADM(nord_w, npx, npy, damp4, w, w_ad, wk, &
&                       wk_ad, fx2, fx2_ad, fy2, fy2_ad, gridstruct, bd)
      END IF
    END IF
    DO j=je,js,-1
      DO i=ie,is,-1
        heat_source_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    DO j=je+1,js,-1
      DO i=ie,is,-1
        fy_ad(i, j) = fy_ad(i, j) + yflux_ad(i, j)
      END DO
      DO i=ied,isd,-1
        cry_adv_ad(i, j) = cry_adv_ad(i, j) + cy_ad(i, j)
      END DO
    END DO
    DO j=je,js,-1
      DO i=ie+1,is,-1
        fx_ad(i, j) = fx_ad(i, j) + xflux_ad(i, j)
      END DO
    END DO
    DO j=jed,jsd,-1
      DO i=ie+1,is,-1
        crx_adv_ad(i, j) = crx_adv_ad(i, j) + cx_ad(i, j)
      END DO
    END DO
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(delp, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                  /8)
      CALL POPREALARRAY(fx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)/8)
      CALL POPREALARRAY(fy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)/8)
      CALL FV_TP_2D_ADM(delp, delp_ad, crx_adv, crx_adv_ad, cry_adv, &
&                 cry_adv_ad, npx, npy, hord_dp_pert, fx, fx_ad, fy, &
&                 fy_ad, xfx_adv, xfx_adv_ad, yfx_adv, yfx_adv_ad, &
&                 gridstruct, bd, ra_x, ra_x_ad, ra_y, ra_y_ad, nord=&
&                 nord_v_pert, damp_c=damp_v_pert)
    ELSE
      CALL FV_TP_2D_BWD(delp, delp_ad, crx_adv, crx_adv_ad, cry_adv, &
&                    cry_adv_ad, npx, npy, hord_dp, fx, fx_ad, fy, fy_ad&
&                    , xfx_adv, xfx_adv_ad, yfx_adv, yfx_adv_ad, &
&                    gridstruct, bd, ra_x, ra_x_ad, ra_y, ra_y_ad, nord=&
&                    nord_v, damp_c=damp_v)
    END IF
    DO j=je,js,-1
      DO i=ied,isd,-1
        yfx_adv_ad(i, j) = yfx_adv_ad(i, j) + ra_y_ad(i, j)
        yfx_adv_ad(i, j+1) = yfx_adv_ad(i, j+1) - ra_y_ad(i, j)
        ra_y_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    DO j=jed,jsd,-1
      DO i=ie,is,-1
        xfx_adv_ad(i, j) = xfx_adv_ad(i, j) + ra_x_ad(i, j)
        xfx_adv_ad(i+1, j) = xfx_adv_ad(i+1, j) - ra_x_ad(i, j)
        ra_x_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    CALL POPREALARRAY(cry_adv, 8*(bd%ied-bd%isd+1)*(bd%je-bd%js+2)/&
&                8)
    CALL POPREALARRAY(yfx_adv, 8*(bd%ied-bd%isd+1)*(bd%je-bd%js+2)/&
&                8)
    DO j=js,je+1
!DEC$ VECTOR ALWAYS
      DO i=isd,ied
        IF (yfx_adv(i, j) .GT. 0.) THEN
          CALL PUSHCONTROL1B_FV(1)
        ELSE
          CALL PUSHCONTROL1B_FV(0)
        END IF
      END DO
      DO i=ied,isd,-1
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          yfx_adv_ad(i, j) = gridstruct%rdya(i, j)*cry_adv_ad(i, j) + &
&           gridstruct%sin_sg(i, j, 2)*gridstruct%dx(i, j)*yfx_adv_ad(i&
&           , j)
          cry_adv_ad(i, j) = 0.0_FVPRC
        ELSE
          yfx_adv_ad(i, j) = gridstruct%rdya(i, j-1)*cry_adv_ad(i, j) + &
&           gridstruct%sin_sg(i, j-1, 4)*gridstruct%dx(i, j)*yfx_adv_ad(&
&           i, j)
          cry_adv_ad(i, j) = 0.0_FVPRC
        END IF
      END DO
    END DO
    CALL POPINTEGER(ie)
    CALL POPREALARRAY(xfx_adv, 8*(bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)/&
&                8)
    CALL POPREALARRAY(crx_adv, 8*(bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)/&
&                8)
    DO j=jsd,jed
!DEC$ VECTOR ALWAYS
      DO i=is,ie+1
        IF (xfx_adv(i, j) .GT. 0.) THEN
          CALL PUSHCONTROL1B_FV(1)
        ELSE
          CALL PUSHCONTROL1B_FV(0)
        END IF
      END DO
      DO i=ie+1,is,-1
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          xfx_adv_ad(i, j) = gridstruct%rdxa(i, j)*crx_adv_ad(i, j) + &
&           gridstruct%sin_sg(i, j, 1)*gridstruct%dy(i, j)*xfx_adv_ad(i&
&           , j)
          crx_adv_ad(i, j) = 0.0_FVPRC
        ELSE
          xfx_adv_ad(i, j) = gridstruct%rdxa(i-1, j)*crx_adv_ad(i, j) + &
&           gridstruct%sin_sg(i-1, j, 3)*gridstruct%dy(i, j)*xfx_adv_ad(&
&           i, j)
          crx_adv_ad(i, j) = 0.0_FVPRC
        END IF
      END DO
    END DO
    CALL POPREALARRAY(yfx_adv, 8*(bd%ied-bd%isd+1)*(bd%je-bd%js+2)/&
&                8)
    DO j=js,je+1
      DO i=ied,isd,-1
        vt_ad(i, j) = vt_ad(i, j) + dt*yfx_adv_ad(i, j)
        yfx_adv_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    CALL POPINTEGER(ie)
    CALL POPREALARRAY(xfx_adv, 8*(bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)/&
&                8)
    DO j=jsd,jed
      DO i=ie+1,is,-1
        ut_ad(i, j) = ut_ad(i, j) + dt*xfx_adv_ad(i, j)
        xfx_adv_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    CALL POPCONTROL2B_FV(branch)
    IF (branch .LT. 2) THEN
      IF (branch .EQ. 0) THEN
        DO j=je+1,js,-1
          DO i=ied,isd,-1
            vc_ad(i, j) = vc_ad(i, j) + vt_ad(i, j)
            vt_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
        DO j=jed,jsd,-1
          DO i=ie+1,is,-1
            uc_ad(i, j) = uc_ad(i, j) + ut_ad(i, j)
            ut_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
        GOTO 130
      END IF
    ELSE
      IF (branch .NE. 2) THEN
        damp = 1./(1.-0.0625*gridstruct%cosa_u(2, npy-1)*gridstruct%&
&         cosa_v(1, npy-1))
        temp_ad39 = -(damp*gridstruct%cosa_v(1, npy-1)*0.25*vt_ad(1, npy&
&         -1))
        temp_ad40 = -(gridstruct%cosa_u(2, npy-1)*0.25*temp_ad39)
        ut_ad(1, npy-1) = ut_ad(1, npy-1) + temp_ad39
        ut_ad(1, npy-2) = ut_ad(1, npy-2) + temp_ad39
        ut_ad(2, npy-2) = ut_ad(2, npy-2) + temp_ad39
        uc_ad(2, npy-1) = uc_ad(2, npy-1) + damp*ut_ad(2, npy-1) + &
&         temp_ad39
        temp_ad41 = -(damp*gridstruct%cosa_u(2, npy-1)*0.25*ut_ad(2, npy&
&         -1))
        vc_ad(1, npy-1) = vc_ad(1, npy-1) + temp_ad41 + damp*vt_ad(1, &
&         npy-1)
        vt_ad(1, npy) = vt_ad(1, npy) + temp_ad40
        vt_ad(2, npy) = vt_ad(2, npy) + temp_ad40
        vt_ad(2, npy-1) = vt_ad(2, npy-1) + temp_ad40
        vt_ad(1, npy-1) = 0.0_FVPRC
        temp_ad42 = -(gridstruct%cosa_v(1, npy-1)*0.25*temp_ad41)
        vt_ad(1, npy) = vt_ad(1, npy) + temp_ad41
        vt_ad(2, npy) = vt_ad(2, npy) + temp_ad41
        vt_ad(2, npy-1) = vt_ad(2, npy-1) + temp_ad41
        ut_ad(1, npy-1) = ut_ad(1, npy-1) + temp_ad42
        ut_ad(1, npy-2) = ut_ad(1, npy-2) + temp_ad42
        ut_ad(2, npy-2) = ut_ad(2, npy-2) + temp_ad42
        ut_ad(2, npy-1) = 0.0_FVPRC
        damp = 1./(1.-0.0625*gridstruct%cosa_u(0, npy-1)*gridstruct%&
&         cosa_v(0, npy-1))
        temp_ad43 = -(damp*gridstruct%cosa_v(0, npy-1)*0.25*vt_ad(0, npy&
&         -1))
        temp_ad44 = -(gridstruct%cosa_u(0, npy-1)*0.25*temp_ad43)
        vc_ad(0, npy-1) = vc_ad(0, npy-1) + damp*vt_ad(0, npy-1)
        ut_ad(1, npy-1) = ut_ad(1, npy-1) + temp_ad43
        ut_ad(1, npy-2) = ut_ad(1, npy-2) + temp_ad43
        ut_ad(0, npy-2) = ut_ad(0, npy-2) + temp_ad43
        uc_ad(0, npy-1) = uc_ad(0, npy-1) + temp_ad43
        vt_ad(0, npy) = vt_ad(0, npy) + temp_ad44
        vt_ad(-1, npy) = vt_ad(-1, npy) + temp_ad44
        vt_ad(-1, npy-1) = vt_ad(-1, npy-1) + temp_ad44
        vt_ad(0, npy-1) = 0.0_FVPRC
        damp = 1./(1.-0.0625*gridstruct%cosa_u(2, npy)*gridstruct%cosa_v&
&         (1, npy+1))
        temp_ad45 = -(damp*gridstruct%cosa_u(2, npy)*0.25*ut_ad(2, npy))
        temp_ad46 = -(gridstruct%cosa_v(1, npy+1)*0.25*temp_ad45)
        uc_ad(2, npy) = uc_ad(2, npy) + damp*ut_ad(2, npy)
        vt_ad(1, npy) = vt_ad(1, npy) + temp_ad45
        vt_ad(2, npy) = vt_ad(2, npy) + temp_ad45
        vt_ad(2, npy+1) = vt_ad(2, npy+1) + temp_ad45
        vc_ad(1, npy+1) = vc_ad(1, npy+1) + temp_ad45
        ut_ad(1, npy) = ut_ad(1, npy) + temp_ad46
        ut_ad(1, npy+1) = ut_ad(1, npy+1) + temp_ad46
        ut_ad(2, npy+1) = ut_ad(2, npy+1) + temp_ad46
        ut_ad(2, npy) = 0.0_FVPRC
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        damp = 1./(1.-0.0625*gridstruct%cosa_u(npx-1, npy-1)*gridstruct%&
&         cosa_v(npx-1, npy-1))
        temp_ad31 = -(damp*gridstruct%cosa_v(npx-1, npy-1)*0.25*vt_ad(&
&         npx-1, npy-1))
        temp_ad32 = -(gridstruct%cosa_u(npx-1, npy-1)*0.25*temp_ad31)
        ut_ad(npx, npy-1) = ut_ad(npx, npy-1) + temp_ad31
        ut_ad(npx, npy-2) = ut_ad(npx, npy-2) + temp_ad31
        ut_ad(npx-1, npy-2) = ut_ad(npx-1, npy-2) + temp_ad31
        uc_ad(npx-1, npy-1) = uc_ad(npx-1, npy-1) + damp*ut_ad(npx-1, &
&         npy-1) + temp_ad31
        temp_ad33 = -(damp*gridstruct%cosa_u(npx-1, npy-1)*0.25*ut_ad(&
&         npx-1, npy-1))
        vc_ad(npx-1, npy-1) = vc_ad(npx-1, npy-1) + temp_ad33 + damp*&
&         vt_ad(npx-1, npy-1)
        vt_ad(npx-1, npy) = vt_ad(npx-1, npy) + temp_ad32
        vt_ad(npx-2, npy) = vt_ad(npx-2, npy) + temp_ad32
        vt_ad(npx-2, npy-1) = vt_ad(npx-2, npy-1) + temp_ad32
        vt_ad(npx-1, npy-1) = 0.0_FVPRC
        temp_ad34 = -(gridstruct%cosa_v(npx-1, npy-1)*0.25*temp_ad33)
        vt_ad(npx-1, npy) = vt_ad(npx-1, npy) + temp_ad33
        vt_ad(npx-2, npy) = vt_ad(npx-2, npy) + temp_ad33
        vt_ad(npx-2, npy-1) = vt_ad(npx-2, npy-1) + temp_ad33
        ut_ad(npx, npy-1) = ut_ad(npx, npy-1) + temp_ad34
        ut_ad(npx, npy-2) = ut_ad(npx, npy-2) + temp_ad34
        ut_ad(npx-1, npy-2) = ut_ad(npx-1, npy-2) + temp_ad34
        ut_ad(npx-1, npy-1) = 0.0_FVPRC
        damp = 1./(1.-0.0625*gridstruct%cosa_u(npx+1, npy-1)*gridstruct%&
&         cosa_v(npx, npy-1))
        temp_ad35 = -(damp*gridstruct%cosa_v(npx, npy-1)*0.25*vt_ad(npx&
&         , npy-1))
        temp_ad36 = -(gridstruct%cosa_u(npx+1, npy-1)*0.25*temp_ad35)
        vc_ad(npx, npy-1) = vc_ad(npx, npy-1) + damp*vt_ad(npx, npy-1)
        ut_ad(npx, npy-1) = ut_ad(npx, npy-1) + temp_ad35
        ut_ad(npx, npy-2) = ut_ad(npx, npy-2) + temp_ad35
        ut_ad(npx+1, npy-2) = ut_ad(npx+1, npy-2) + temp_ad35
        uc_ad(npx+1, npy-1) = uc_ad(npx+1, npy-1) + temp_ad35
        vt_ad(npx, npy) = vt_ad(npx, npy) + temp_ad36
        vt_ad(npx+1, npy) = vt_ad(npx+1, npy) + temp_ad36
        vt_ad(npx+1, npy-1) = vt_ad(npx+1, npy-1) + temp_ad36
        vt_ad(npx, npy-1) = 0.0_FVPRC
        damp = 1./(1.-0.0625*gridstruct%cosa_u(npx-1, npy)*gridstruct%&
&         cosa_v(npx-1, npy+1))
        temp_ad37 = -(damp*gridstruct%cosa_u(npx-1, npy)*0.25*ut_ad(npx-&
&         1, npy))
        temp_ad38 = -(gridstruct%cosa_v(npx-1, npy+1)*0.25*temp_ad37)
        uc_ad(npx-1, npy) = uc_ad(npx-1, npy) + damp*ut_ad(npx-1, npy)
        vt_ad(npx-1, npy) = vt_ad(npx-1, npy) + temp_ad37
        vt_ad(npx-2, npy) = vt_ad(npx-2, npy) + temp_ad37
        vt_ad(npx-2, npy+1) = vt_ad(npx-2, npy+1) + temp_ad37
        vc_ad(npx-1, npy+1) = vc_ad(npx-1, npy+1) + temp_ad37
        ut_ad(npx, npy) = ut_ad(npx, npy) + temp_ad38
        ut_ad(npx, npy+1) = ut_ad(npx, npy+1) + temp_ad38
        ut_ad(npx-1, npy+1) = ut_ad(npx-1, npy+1) + temp_ad38
        ut_ad(npx-1, npy) = 0.0_FVPRC
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        damp = 1./(1.-0.0625*gridstruct%cosa_u(npx-1, 1)*gridstruct%&
&         cosa_v(npx-1, 2))
        temp_ad23 = -(damp*gridstruct%cosa_v(npx-1, 2)*0.25*vt_ad(npx-1&
&         , 2))
        temp_ad24 = -(gridstruct%cosa_u(npx-1, 1)*0.25*temp_ad23)
        ut_ad(npx, 1) = ut_ad(npx, 1) + temp_ad23
        ut_ad(npx, 2) = ut_ad(npx, 2) + temp_ad23
        ut_ad(npx-1, 2) = ut_ad(npx-1, 2) + temp_ad23
        uc_ad(npx-1, 1) = uc_ad(npx-1, 1) + damp*ut_ad(npx-1, 1) + &
&         temp_ad23
        temp_ad25 = -(damp*gridstruct%cosa_u(npx-1, 1)*0.25*ut_ad(npx-1&
&         , 1))
        vc_ad(npx-1, 2) = vc_ad(npx-1, 2) + temp_ad25 + damp*vt_ad(npx-1&
&         , 2)
        vt_ad(npx-1, 1) = vt_ad(npx-1, 1) + temp_ad24
        vt_ad(npx-2, 1) = vt_ad(npx-2, 1) + temp_ad24
        vt_ad(npx-2, 2) = vt_ad(npx-2, 2) + temp_ad24
        vt_ad(npx-1, 2) = 0.0_FVPRC
        temp_ad26 = -(gridstruct%cosa_v(npx-1, 2)*0.25*temp_ad25)
        vt_ad(npx-1, 1) = vt_ad(npx-1, 1) + temp_ad25
        vt_ad(npx-2, 1) = vt_ad(npx-2, 1) + temp_ad25
        vt_ad(npx-2, 2) = vt_ad(npx-2, 2) + temp_ad25
        ut_ad(npx, 1) = ut_ad(npx, 1) + temp_ad26
        ut_ad(npx, 2) = ut_ad(npx, 2) + temp_ad26
        ut_ad(npx-1, 2) = ut_ad(npx-1, 2) + temp_ad26
        ut_ad(npx-1, 1) = 0.0_FVPRC
        damp = 1./(1.-0.0625*gridstruct%cosa_u(npx+1, 1)*gridstruct%&
&         cosa_v(npx, 2))
        temp_ad27 = -(damp*gridstruct%cosa_v(npx, 2)*0.25*vt_ad(npx, 2))
        temp_ad28 = -(gridstruct%cosa_u(npx+1, 1)*0.25*temp_ad27)
        vc_ad(npx, 2) = vc_ad(npx, 2) + damp*vt_ad(npx, 2)
        ut_ad(npx, 1) = ut_ad(npx, 1) + temp_ad27
        ut_ad(npx, 2) = ut_ad(npx, 2) + temp_ad27
        ut_ad(npx+1, 2) = ut_ad(npx+1, 2) + temp_ad27
        uc_ad(npx+1, 1) = uc_ad(npx+1, 1) + temp_ad27
        vt_ad(npx, 1) = vt_ad(npx, 1) + temp_ad28
        vt_ad(npx+1, 1) = vt_ad(npx+1, 1) + temp_ad28
        vt_ad(npx+1, 2) = vt_ad(npx+1, 2) + temp_ad28
        vt_ad(npx, 2) = 0.0_FVPRC
        damp = 1./(1.-0.0625*gridstruct%cosa_u(npx-1, 0)*gridstruct%&
&         cosa_v(npx-1, 0))
        temp_ad29 = -(damp*gridstruct%cosa_u(npx-1, 0)*0.25*ut_ad(npx-1&
&         , 0))
        temp_ad30 = -(gridstruct%cosa_v(npx-1, 0)*0.25*temp_ad29)
        uc_ad(npx-1, 0) = uc_ad(npx-1, 0) + damp*ut_ad(npx-1, 0)
        vt_ad(npx-1, 1) = vt_ad(npx-1, 1) + temp_ad29
        vt_ad(npx-2, 1) = vt_ad(npx-2, 1) + temp_ad29
        vt_ad(npx-2, 0) = vt_ad(npx-2, 0) + temp_ad29
        vc_ad(npx-1, 0) = vc_ad(npx-1, 0) + temp_ad29
        ut_ad(npx, 0) = ut_ad(npx, 0) + temp_ad30
        ut_ad(npx, -1) = ut_ad(npx, -1) + temp_ad30
        ut_ad(npx-1, -1) = ut_ad(npx-1, -1) + temp_ad30
        ut_ad(npx-1, 0) = 0.0_FVPRC
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        damp = 1./(1.-0.0625*gridstruct%cosa_u(2, 1)*gridstruct%cosa_v(1&
&         , 2))
        temp_ad15 = -(damp*gridstruct%cosa_v(1, 2)*0.25*vt_ad(1, 2))
        temp_ad16 = -(gridstruct%cosa_u(2, 1)*0.25*temp_ad15)
        ut_ad(1, 1) = ut_ad(1, 1) + temp_ad15
        ut_ad(1, 2) = ut_ad(1, 2) + temp_ad15
        ut_ad(2, 2) = ut_ad(2, 2) + temp_ad15
        uc_ad(2, 1) = uc_ad(2, 1) + damp*ut_ad(2, 1) + temp_ad15
        temp_ad17 = -(damp*gridstruct%cosa_u(2, 1)*0.25*ut_ad(2, 1))
        vc_ad(1, 2) = vc_ad(1, 2) + temp_ad17 + damp*vt_ad(1, 2)
        vt_ad(1, 1) = vt_ad(1, 1) + temp_ad16
        vt_ad(2, 1) = vt_ad(2, 1) + temp_ad16
        vt_ad(2, 2) = vt_ad(2, 2) + temp_ad16
        vt_ad(1, 2) = 0.0_FVPRC
        temp_ad18 = -(gridstruct%cosa_v(1, 2)*0.25*temp_ad17)
        vt_ad(1, 1) = vt_ad(1, 1) + temp_ad17
        vt_ad(2, 1) = vt_ad(2, 1) + temp_ad17
        vt_ad(2, 2) = vt_ad(2, 2) + temp_ad17
        ut_ad(1, 1) = ut_ad(1, 1) + temp_ad18
        ut_ad(1, 2) = ut_ad(1, 2) + temp_ad18
        ut_ad(2, 2) = ut_ad(2, 2) + temp_ad18
        ut_ad(2, 1) = 0.0_FVPRC
        damp = 1./(1.-0.0625*gridstruct%cosa_u(0, 1)*gridstruct%cosa_v(0&
&         , 2))
        temp_ad19 = -(damp*gridstruct%cosa_v(0, 2)*0.25*vt_ad(0, 2))
        temp_ad20 = -(gridstruct%cosa_u(0, 1)*0.25*temp_ad19)
        vc_ad(0, 2) = vc_ad(0, 2) + damp*vt_ad(0, 2)
        ut_ad(1, 1) = ut_ad(1, 1) + temp_ad19
        ut_ad(1, 2) = ut_ad(1, 2) + temp_ad19
        ut_ad(0, 2) = ut_ad(0, 2) + temp_ad19
        uc_ad(0, 1) = uc_ad(0, 1) + temp_ad19
        vt_ad(0, 1) = vt_ad(0, 1) + temp_ad20
        vt_ad(-1, 1) = vt_ad(-1, 1) + temp_ad20
        vt_ad(-1, 2) = vt_ad(-1, 2) + temp_ad20
        vt_ad(0, 2) = 0.0_FVPRC
        damp = 1./(1.-0.0625*gridstruct%cosa_u(2, 0)*gridstruct%cosa_v(1&
&         , 0))
        temp_ad21 = -(damp*gridstruct%cosa_u(2, 0)*0.25*ut_ad(2, 0))
        temp_ad22 = -(gridstruct%cosa_v(1, 0)*0.25*temp_ad21)
        uc_ad(2, 0) = uc_ad(2, 0) + damp*ut_ad(2, 0)
        vt_ad(1, 1) = vt_ad(1, 1) + temp_ad21
        vt_ad(2, 1) = vt_ad(2, 1) + temp_ad21
        vt_ad(2, 0) = vt_ad(2, 0) + temp_ad21
        vc_ad(1, 0) = vc_ad(1, 0) + temp_ad21
        ut_ad(1, 0) = ut_ad(1, 0) + temp_ad22
        ut_ad(1, -1) = ut_ad(1, -1) + temp_ad22
        ut_ad(2, -1) = ut_ad(2, -1) + temp_ad22
        ut_ad(2, 0) = 0.0_FVPRC
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        DO i=min4,max4,-1
          temp_ad13 = -(gridstruct%cosa_u(i, npy)*0.25*ut_ad(i, npy))
          uc_ad(i, npy) = uc_ad(i, npy) + ut_ad(i, npy)
          vt_ad(i-1, npy) = vt_ad(i-1, npy) + temp_ad13
          vt_ad(i, npy) = vt_ad(i, npy) + temp_ad13
          vt_ad(i-1, npy+1) = vt_ad(i-1, npy+1) + temp_ad13
          vt_ad(i, npy+1) = vt_ad(i, npy+1) + temp_ad13
          ut_ad(i, npy) = 0.0_FVPRC
          temp_ad14 = -(gridstruct%cosa_u(i, npy-1)*0.25*ut_ad(i, npy-1)&
&           )
          uc_ad(i, npy-1) = uc_ad(i, npy-1) + ut_ad(i, npy-1)
          vt_ad(i-1, npy-1) = vt_ad(i-1, npy-1) + temp_ad14
          vt_ad(i, npy-1) = vt_ad(i, npy-1) + temp_ad14
          vt_ad(i-1, npy) = vt_ad(i-1, npy) + temp_ad14
          vt_ad(i, npy) = vt_ad(i, npy) + temp_ad14
          ut_ad(i, npy-1) = 0.0_FVPRC
        END DO
        DO i=ied,isd,-1
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            vc_ad(i, npy) = vc_ad(i, npy) + vt_ad(i, npy)/gridstruct%&
&             sin_sg(i, npy, 2)
            vt_ad(i, npy) = 0.0_FVPRC
          ELSE
            vc_ad(i, npy) = vc_ad(i, npy) + vt_ad(i, npy)/gridstruct%&
&             sin_sg(i, npy-1, 4)
            vt_ad(i, npy) = 0.0_FVPRC
          END IF
        END DO
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        DO i=min3,max3,-1
          temp_ad11 = -(gridstruct%cosa_u(i, 1)*0.25*ut_ad(i, 1))
          uc_ad(i, 1) = uc_ad(i, 1) + ut_ad(i, 1)
          vt_ad(i-1, 1) = vt_ad(i-1, 1) + temp_ad11
          vt_ad(i, 1) = vt_ad(i, 1) + temp_ad11
          vt_ad(i-1, 2) = vt_ad(i-1, 2) + temp_ad11
          vt_ad(i, 2) = vt_ad(i, 2) + temp_ad11
          ut_ad(i, 1) = 0.0_FVPRC
          temp_ad12 = -(gridstruct%cosa_u(i, 0)*0.25*ut_ad(i, 0))
          uc_ad(i, 0) = uc_ad(i, 0) + ut_ad(i, 0)
          vt_ad(i-1, 0) = vt_ad(i-1, 0) + temp_ad12
          vt_ad(i, 0) = vt_ad(i, 0) + temp_ad12
          vt_ad(i-1, 1) = vt_ad(i-1, 1) + temp_ad12
          vt_ad(i, 1) = vt_ad(i, 1) + temp_ad12
          ut_ad(i, 0) = 0.0_FVPRC
        END DO
        DO i=ied,isd,-1
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            vc_ad(i, 1) = vc_ad(i, 1) + vt_ad(i, 1)/gridstruct%sin_sg(i&
&             , 1, 2)
            vt_ad(i, 1) = 0.0_FVPRC
          ELSE
            vc_ad(i, 1) = vc_ad(i, 1) + vt_ad(i, 1)/gridstruct%sin_sg(i&
&             , 0, 4)
            vt_ad(i, 1) = 0.0_FVPRC
          END IF
        END DO
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        DO j=min2,max2,-1
          temp_ad9 = -(gridstruct%cosa_v(npx, j)*0.25*vt_ad(npx, j))
          vc_ad(npx, j) = vc_ad(npx, j) + vt_ad(npx, j)
          ut_ad(npx, j-1) = ut_ad(npx, j-1) + temp_ad9
          ut_ad(npx+1, j-1) = ut_ad(npx+1, j-1) + temp_ad9
          ut_ad(npx, j) = ut_ad(npx, j) + temp_ad9
          ut_ad(npx+1, j) = ut_ad(npx+1, j) + temp_ad9
          vt_ad(npx, j) = 0.0_FVPRC
          temp_ad10 = -(gridstruct%cosa_v(npx-1, j)*0.25*vt_ad(npx-1, j)&
&           )
          vc_ad(npx-1, j) = vc_ad(npx-1, j) + vt_ad(npx-1, j)
          ut_ad(npx-1, j-1) = ut_ad(npx-1, j-1) + temp_ad10
          ut_ad(npx, j-1) = ut_ad(npx, j-1) + temp_ad10
          ut_ad(npx-1, j) = ut_ad(npx-1, j) + temp_ad10
          ut_ad(npx, j) = ut_ad(npx, j) + temp_ad10
          vt_ad(npx-1, j) = 0.0_FVPRC
        END DO
        DO j=jed,jsd,-1
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            uc_ad(npx, j) = uc_ad(npx, j) + ut_ad(npx, j)/gridstruct%&
&             sin_sg(npx, j, 1)
            ut_ad(npx, j) = 0.0_FVPRC
          ELSE
            uc_ad(npx, j) = uc_ad(npx, j) + ut_ad(npx, j)/gridstruct%&
&             sin_sg(npx-1, j, 3)
            ut_ad(npx, j) = 0.0_FVPRC
          END IF
        END DO
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        DO j=min1,max1,-1
          temp_ad7 = -(gridstruct%cosa_v(1, j)*0.25*vt_ad(1, j))
          vc_ad(1, j) = vc_ad(1, j) + vt_ad(1, j)
          ut_ad(1, j-1) = ut_ad(1, j-1) + temp_ad7
          ut_ad(2, j-1) = ut_ad(2, j-1) + temp_ad7
          ut_ad(1, j) = ut_ad(1, j) + temp_ad7
          ut_ad(2, j) = ut_ad(2, j) + temp_ad7
          vt_ad(1, j) = 0.0_FVPRC
          temp_ad8 = -(gridstruct%cosa_v(0, j)*0.25*vt_ad(0, j))
          vc_ad(0, j) = vc_ad(0, j) + vt_ad(0, j)
          ut_ad(0, j-1) = ut_ad(0, j-1) + temp_ad8
          ut_ad(1, j-1) = ut_ad(1, j-1) + temp_ad8
          ut_ad(0, j) = ut_ad(0, j) + temp_ad8
          ut_ad(1, j) = ut_ad(1, j) + temp_ad8
          vt_ad(0, j) = 0.0_FVPRC
        END DO
        DO j=jed,jsd,-1
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            uc_ad(1, j) = uc_ad(1, j) + ut_ad(1, j)/gridstruct%sin_sg(1&
&             , j, 1)
            ut_ad(1, j) = 0.0_FVPRC
          ELSE
            uc_ad(1, j) = uc_ad(1, j) + ut_ad(1, j)/gridstruct%sin_sg(0&
&             , j, 3)
            ut_ad(1, j) = 0.0_FVPRC
          END IF
        END DO
      END IF
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      DO j=je+2,js-1,-1
        DO i=ied,isd,-1
          temp_ad1 = gridstruct%rsin_v(i, j)*vt_ad(i, j)
          temp_ad2 = -(gridstruct%cosa_v(i, j)*0.25*temp_ad1)
          vc_ad(i, j) = vc_ad(i, j) + temp_ad1
          uc_ad(i, j-1) = uc_ad(i, j-1) + temp_ad2
          uc_ad(i+1, j-1) = uc_ad(i+1, j-1) + temp_ad2
          uc_ad(i, j) = uc_ad(i, j) + temp_ad2
          uc_ad(i+1, j) = uc_ad(i+1, j) + temp_ad2
          vt_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      DO j=jed,jsd,-1
        DO i=ie+2,is-1,-1
          temp_ad = gridstruct%rsin_u(i, j)*ut_ad(i, j)
          temp_ad0 = -(gridstruct%cosa_u(i, j)*0.25*temp_ad)
          uc_ad(i, j) = uc_ad(i, j) + temp_ad
          vc_ad(i-1, j) = vc_ad(i-1, j) + temp_ad0
          vc_ad(i, j) = vc_ad(i, j) + temp_ad0
          vc_ad(i-1, j+1) = vc_ad(i-1, j+1) + temp_ad0
          vc_ad(i, j+1) = vc_ad(i, j+1) + temp_ad0
          ut_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
    ELSE
      DO j=je+2,js-1,-1
        CALL POPCONTROL1B_FV(branch)
        IF (branch .NE. 0) THEN
          DO i=ied,isd,-1
            temp_ad5 = gridstruct%rsin_v(i, j)*vt_ad(i, j)
            temp_ad6 = -(gridstruct%cosa_v(i, j)*0.25*temp_ad5)
            vc_ad(i, j) = vc_ad(i, j) + temp_ad5
            uc_ad(i, j-1) = uc_ad(i, j-1) + temp_ad6
            uc_ad(i+1, j-1) = uc_ad(i+1, j-1) + temp_ad6
            uc_ad(i, j) = uc_ad(i, j) + temp_ad6
            uc_ad(i+1, j) = uc_ad(i+1, j) + temp_ad6
            vt_ad(i, j) = 0.0_FVPRC
          END DO
        END IF
      END DO
      DO j=jed,jsd,-1
        CALL POPCONTROL1B_FV(branch)
        IF (branch .NE. 0) THEN
          DO i=ie+2,is-1,-1
            temp_ad3 = gridstruct%rsin_u(i, j)*ut_ad(i, j)
            temp_ad4 = -(gridstruct%cosa_u(i, j)*0.25*temp_ad3)
            uc_ad(i, j) = uc_ad(i, j) + temp_ad3
            vc_ad(i-1, j) = vc_ad(i-1, j) + temp_ad4
            vc_ad(i, j) = vc_ad(i, j) + temp_ad4
            vc_ad(i-1, j+1) = vc_ad(i-1, j+1) + temp_ad4
            vc_ad(i, j+1) = vc_ad(i, j+1) + temp_ad4
            ut_ad(i, j) = 0.0_FVPRC
          END DO
        END IF
      END DO
    END IF
 130 CONTINUE
  END SUBROUTINE D_SW_BWD
!     d_sw :: D-Grid Shallow Water Routine
  SUBROUTINE D_SW(delpc, delpc_tj, delp, ptc, pt, u, v, w, uc, vc, ua, &
&   va, divg_d, xflux, yflux, cx, cy, crx_adv, cry_adv, xfx_adv, yfx_adv&
&   , q_con, z_rat, heat_source, zvir, sphum, nq, q, k, km, inline_q, dt&
&   , hord_tr, hord_mt, hord_vt, hord_tm, hord_dp, hord_tr_pert, &
&   hord_mt_pert, hord_vt_pert, hord_tm_pert, hord_dp_pert, nord, nord_v&
&   , nord_w, nord_t, dddmp, d2_bg, d4_bg, damp_v, damp_w, damp_t, d_con&
&   , split_damp, nord_pert, nord_v_pert, nord_w_pert, nord_t_pert, &
&   dddmp_pert, d2_bg_pert, d4_bg_pert, damp_v_pert, damp_w_pert, &
&   damp_t_pert, d_con_pert, hydrostatic, gridstruct, flagstruct, bd)
    IMPLICIT NONE
!#ifdef SW_DYNAMICS
!      endif ! test_case
!#endif
    INTEGER, INTENT(IN) :: hord_tr, hord_mt, hord_vt, hord_tm, hord_dp
    INTEGER, INTENT(IN) :: hord_tr_pert, hord_mt_pert, hord_vt_pert, &
&   hord_tm_pert, hord_dp_pert
! nord=1 divergence damping; (del-4) or 3 (del-8)
    INTEGER, INTENT(IN) :: nord
! vorticity damping
    INTEGER, INTENT(IN) :: nord_v
! vertical velocity
    INTEGER, INTENT(IN) :: nord_w
! pt
    INTEGER, INTENT(IN) :: nord_t
    LOGICAL, INTENT(IN) :: split_damp
    INTEGER, INTENT(IN) :: nord_pert, nord_v_pert, nord_w_pert, &
&   nord_t_pert
    INTEGER, INTENT(IN) :: sphum, nq, k, km
    REAL(fvprc), INTENT(IN) :: dt, dddmp, d2_bg, d4_bg, d_con
    REAL(fvprc), INTENT(IN) :: dddmp_pert, d2_bg_pert, d4_bg_pert, &
&   d_con_pert
    REAL(fvprc), INTENT(IN) :: zvir
    REAL(fvprc), INTENT(IN) :: damp_v, damp_w, damp_t
    REAL(fvprc), INTENT(IN) :: damp_v_pert, damp_w_pert, damp_t_pert
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! divergence
    REAL(fvprc), INTENT(INOUT) :: divg_d(bd%isd:bd%ied+1, bd%jsd:bd%jed+&
&   1)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   z_rat
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delp, pt, ua, va, w
    REAL(fvprc), DIMENSION(bd%isd:bd%isd, bd%jsd:bd%jsd), INTENT(INOUT) &
&   :: q_con
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u, vc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v, uc
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, km, nq&
&   )
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(OUT) ::&
&   delpc, ptc
    REAL(fvprc), DIMENSION(bd%is:bd%ie, bd%js:bd%je), INTENT(OUT) :: &
&   heat_source
! The flux capacitors:
    REAL(fvprc), INTENT(INOUT) :: xflux(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc), INTENT(INOUT) :: yflux(bd%is:bd%ie, bd%js:bd%je+1)
!------------------------
    REAL(fvprc), INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1)
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: inline_q
    REAL(fvprc), DIMENSION(bd%is:bd%ie+1, bd%jsd:bd%jed), INTENT(OUT) ::&
&   crx_adv, xfx_adv
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%js:bd%je+1), INTENT(OUT) ::&
&   cry_adv, yfx_adv
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
! Local:
    REAL(fvprc) :: ut(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: vt(bd%isd:bd%ied, bd%jsd:bd%jed+1)
!---
    REAL(fvprc) :: fx2(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: fy2(bd%isd:bd%ied, bd%jsd:bd%jed+1)
!  work array
    REAL(fvprc) :: dw(bd%is:bd%ie, bd%js:bd%je)
!---
    REAL(fvprc), DIMENSION(bd%is:bd%ie+1, bd%js:bd%je+1) :: ub, vb
!  work array
    REAL(fvprc) :: wk(bd%isd:bd%ied, bd%jsd:bd%jed)
!  needs this for corner_comm
    REAL(fvprc) :: ke(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
! Vorticity
    REAL(fvprc) :: vort(bd%isd:bd%ied, bd%jsd:bd%jed)
! 1-D X-direction Fluxes
    REAL(fvprc) :: fx(bd%is:bd%ie+1, bd%js:bd%je)
! 1-D Y-direction Fluxes
    REAL(fvprc) :: fy(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: ra_x(bd%is:bd%ie, bd%jsd:bd%jed)
    REAL(fvprc) :: ra_y(bd%isd:bd%ied, bd%js:bd%je)
    REAL(fvprc) :: gx(bd%is:bd%ie+1, bd%js:bd%je)
! work Y-dir flux array
    REAL(fvprc) :: gy(bd%is:bd%ie, bd%js:bd%je+1)
    LOGICAL :: fill_c
    REAL(fvprc) :: dt2, dt4, dt5, dt6
    REAL(fvprc) :: damp, damp2, damp4, dd8, u2, v2, du2, dv2, damp4_pert
    REAL(fvprc) :: u_lon
    INTEGER :: i, j, ii, jj, is2, ie1, js2, je1, n, nt, n2, iq
!      real(FVPRC), pointer, dimension(:,:) :: area, area_c, rarea, rarea_c
!      real(FVPRC), pointer, dimension(:,:,:) :: sin_sg
!      real(FVPRC), pointer, dimension(:,:)   :: cosa_u, cosa_v, cosa_s
!      real(FVPRC), pointer, dimension(:,:)   :: sina_u, sina_v
!      real(FVPRC), pointer, dimension(:,:)   :: rsin_u, rsin_v, rsina
!      real(FVPRC), pointer, dimension(:,:)   :: f0, rsin2, divg_u, divg_v
!      real(FVPRC), pointer, dimension(:,:) ::  cosa, dx, dy, dxc, dyc, rdxa, rdya, rdx, rdy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTEGER :: npx, npy
    LOGICAL :: nested
    REAL(fvprc) :: da_min, da_min_c
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: delp_tj, &
&   pt_tj, w_tj
    REAL(fvprc) :: q_tj(bd%isd:bd%ied, bd%jsd:bd%jed, km, nq)
    REAL(fvprc) :: vort_tj(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), DIMENSION(bd%is:bd%ie+1, bd%js:bd%je+1) :: ub_tj, vb_tj
    REAL(fvprc) :: fx_tj(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: fy_tj(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: gx_tj(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: gy_tj(bd%is:bd%ie, bd%js:bd%je+1)
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(OUT) ::&
&   delpc_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ptc_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1) :: ke_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1) :: u_tj, &
&   vc_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed) :: v_tj, &
&   uc_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ua_tj, va_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1) :: &
&   divg_d_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: wk_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed) :: ut_tj
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1) :: vt_tj
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
!
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
    fx = 0.0
    fy = 0.0
    gx = 0.0
    gy = 0.0
    ub = 0.0
    vb = 0.0
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    npx = flagstruct%npx
    npy = flagstruct%npy
    nested = gridstruct%nested
    da_min = gridstruct%da_min
    da_min_c = gridstruct%da_min_c
! end grid_type choices
!      area      => gridstruct%area   
!      rarea     => gridstruct%rarea  
!      rarea_c   => gridstruct%rarea_c
!      sin_sg    => gridstruct%sin_sg 
!      cosa_u    => gridstruct%cosa_u 
!      cosa_v    => gridstruct%cosa_v 
!      cosa_s    => gridstruct%cosa_s 
!      sina_u    => gridstruct%sina_u 
!      sina_v    => gridstruct%sina_v 
!      rsin_u    => gridstruct%rsin_u 
!      rsin_v    => gridstruct%rsin_v 
!      rsina     => gridstruct%rsina  
!      f0        => gridstruct%f0     
!      rsin2     => gridstruct%rsin2  
!      divg_u    => gridstruct%divg_u 
!      divg_v    => gridstruct%divg_v 
!      cosa      => gridstruct%cosa   
!      dx        => gridstruct%dx     
!      dy        => gridstruct%dy     
!      dxc       => gridstruct%dxc    
!      dyc       => gridstruct%dyc    
!      rdxa      => gridstruct%rdxa   
!      rdya      => gridstruct%rdya   
!      rdx       => gridstruct%rdx    
!      rdy       => gridstruct%rdy    
!#ifdef SW_DYNAMICS 
!      if ( test_case == 1 ) then
!        do j=jsd,jed
!           do i=is,ie+1
!              xfx_adv(i,j) = dt * uc(i,j) / gridstruct%sina_u(i,j)
!              if (xfx_adv(i,j) > 0.) then
!                  crx_adv(i,j) = xfx_adv(i,j) * gridstruct%rdxa(i-1,j)
!              else
!                  crx_adv(i,j) = xfx_adv(i,j) * gridstruct%rdxa(i,j)
!              endif
!              xfx_adv(i,j) = gridstruct%dy(i,j)*xfx_adv(i,j)*gridstruct%sina_u(i,j)
!           enddo
!        enddo
!
!        do j=js,je+1
!           do i=isd,ied
!              yfx_adv(i,j) = dt * vc(i,j) / gridstruct%sina_v(i,j)
!              if (yfx_adv(i,j) > 0.) then
!                 cry_adv(i,j) = yfx_adv(i,j) * gridstruct%rdya(i,j-1)
!              else
!                 cry_adv(i,j) = yfx_adv(i,j) * gridstruct%rdya(i,j)
!              endif
!              yfx_adv(i,j) = gridstruct%dx(i,j)*yfx_adv(i,j)*gridstruct%sina_v(i,j)
!           enddo
!        enddo
!      else
!#endif
    IF (flagstruct%grid_type .LT. 3) THEN
!!! TO DO: separate versions for nesting and for cubed-sphere
      IF (nested) THEN
        DO j=jsd,jed
          DO i=is-1,ie+2
            ut(i, j) = (uc(i, j)-0.25*gridstruct%cosa_u(i, j)*(vc(i-1, j&
&             )+vc(i, j)+vc(i-1, j+1)+vc(i, j+1)))*gridstruct%rsin_u(i, &
&             j)
          END DO
        END DO
        DO j=js-1,je+2
          DO i=isd,ied
            vt(i, j) = (vc(i, j)-0.25*gridstruct%cosa_v(i, j)*(uc(i, j-1&
&             )+uc(i+1, j-1)+uc(i, j)+uc(i+1, j)))*gridstruct%rsin_v(i, &
&             j)
          END DO
        END DO
      ELSE
        DO j=jsd,jed
          IF (j .NE. 0 .AND. j .NE. 1 .AND. j .NE. npy - 1 .AND. j .NE. &
&             npy) THEN
            DO i=is-1,ie+2
              ut(i, j) = (uc(i, j)-0.25*gridstruct%cosa_u(i, j)*(vc(i-1&
&               , j)+vc(i, j)+vc(i-1, j+1)+vc(i, j+1)))*gridstruct%&
&               rsin_u(i, j)
            END DO
          END IF
        END DO
        DO j=js-1,je+2
          IF (j .NE. 1 .AND. j .NE. npy) THEN
            DO i=isd,ied
              vt(i, j) = (vc(i, j)-0.25*gridstruct%cosa_v(i, j)*(uc(i, j&
&               -1)+uc(i+1, j-1)+uc(i, j)+uc(i+1, j)))*gridstruct%rsin_v&
&               (i, j)
            END DO
          END IF
        END DO
      END IF
!.not. nested
      IF (.NOT.nested) THEN
! West face
! West edge:
        IF (is .EQ. 1) THEN
          DO j=jsd,jed
            IF (uc(1, j)*dt .GT. 0.) THEN
              ut(1, j) = uc(1, j)/gridstruct%sin_sg(0, j, 3)
            ELSE
              ut(1, j) = uc(1, j)/gridstruct%sin_sg(1, j, 1)
            END IF
          END DO
          IF (3 .LT. js) THEN
            max1 = js
          ELSE
            max1 = 3
          END IF
          IF (npy - 2 .GT. je + 1) THEN
            min1 = je + 1
          ELSE
            min1 = npy - 2
          END IF
          DO j=max1,min1
            vt(0, j) = vc(0, j) - 0.25*gridstruct%cosa_v(0, j)*(ut(0, j-&
&             1)+ut(1, j-1)+ut(0, j)+ut(1, j))
            vt(1, j) = vc(1, j) - 0.25*gridstruct%cosa_v(1, j)*(ut(1, j-&
&             1)+ut(2, j-1)+ut(1, j)+ut(2, j))
          END DO
        END IF
! East edge:
        IF (ie + 1 .EQ. npx) THEN
          DO j=jsd,jed
            IF (uc(npx, j)*dt .GT. 0.) THEN
              ut(npx, j) = uc(npx, j)/gridstruct%sin_sg(npx-1, j, 3)
            ELSE
              ut(npx, j) = uc(npx, j)/gridstruct%sin_sg(npx, j, 1)
            END IF
          END DO
          IF (3 .LT. js) THEN
            max2 = js
          ELSE
            max2 = 3
          END IF
          IF (npy - 2 .GT. je + 1) THEN
            min2 = je + 1
          ELSE
            min2 = npy - 2
          END IF
          DO j=max2,min2
            vt(npx-1, j) = vc(npx-1, j) - 0.25*gridstruct%cosa_v(npx-1, &
&             j)*(ut(npx-1, j-1)+ut(npx, j-1)+ut(npx-1, j)+ut(npx, j))
            vt(npx, j) = vc(npx, j) - 0.25*gridstruct%cosa_v(npx, j)*(ut&
&             (npx, j-1)+ut(npx+1, j-1)+ut(npx, j)+ut(npx+1, j))
          END DO
        END IF
! South (Bottom) edge:
        IF (js .EQ. 1) THEN
          DO i=isd,ied
            IF (vc(i, 1)*dt .GT. 0.) THEN
              vt(i, 1) = vc(i, 1)/gridstruct%sin_sg(i, 0, 4)
            ELSE
              vt(i, 1) = vc(i, 1)/gridstruct%sin_sg(i, 1, 2)
            END IF
          END DO
          IF (3 .LT. is) THEN
            max3 = is
          ELSE
            max3 = 3
          END IF
          IF (npx - 2 .GT. ie + 1) THEN
            min3 = ie + 1
          ELSE
            min3 = npx - 2
          END IF
          DO i=max3,min3
            ut(i, 0) = uc(i, 0) - 0.25*gridstruct%cosa_u(i, 0)*(vt(i-1, &
&             0)+vt(i, 0)+vt(i-1, 1)+vt(i, 1))
            ut(i, 1) = uc(i, 1) - 0.25*gridstruct%cosa_u(i, 1)*(vt(i-1, &
&             1)+vt(i, 1)+vt(i-1, 2)+vt(i, 2))
          END DO
        END IF
! North edge:
        IF (je + 1 .EQ. npy) THEN
          DO i=isd,ied
            IF (vc(i, npy)*dt .GT. 0.) THEN
              vt(i, npy) = vc(i, npy)/gridstruct%sin_sg(i, npy-1, 4)
            ELSE
              vt(i, npy) = vc(i, npy)/gridstruct%sin_sg(i, npy, 2)
            END IF
          END DO
          IF (3 .LT. is) THEN
            max4 = is
          ELSE
            max4 = 3
          END IF
          IF (npx - 2 .GT. ie + 1) THEN
            min4 = ie + 1
          ELSE
            min4 = npx - 2
          END IF
          DO i=max4,min4
            ut(i, npy-1) = uc(i, npy-1) - 0.25*gridstruct%cosa_u(i, npy-&
&             1)*(vt(i-1, npy-1)+vt(i, npy-1)+vt(i-1, npy)+vt(i, npy))
            ut(i, npy) = uc(i, npy) - 0.25*gridstruct%cosa_u(i, npy)*(vt&
&             (i-1, npy)+vt(i, npy)+vt(i-1, npy+1)+vt(i, npy+1))
          END DO
        END IF
! The following code solves a 2x2 system to get the interior parallel-to-edge uc,vc values 
! near the corners (ex: for the sw corner ut(2,1) and vt(1,2) are solved for simultaneously). 
! It then computes the halo uc, vc values so as to be consistent with the computations on 
! the facing panel. 
!The system solved is:
!  ut(2,1) = uc(2,1) - avg(vt)*gridstruct%cosa_u(2,1)
!  vt(1,2) = vc(1,2) - avg(ut)*gridstruct%cosa_v(1,2)
! in which avg(vt) includes vt(1,2) and avg(ut) includes ut(2,1)
        IF (sw_corner) THEN
          damp = 1./(1.-0.0625*gridstruct%cosa_u(2, 0)*gridstruct%cosa_v&
&           (1, 0))
          ut(2, 0) = (uc(2, 0)-0.25*gridstruct%cosa_u(2, 0)*(vt(1, 1)+vt&
&           (2, 1)+vt(2, 0)+vc(1, 0)-0.25*gridstruct%cosa_v(1, 0)*(ut(1&
&           , 0)+ut(1, -1)+ut(2, -1))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(0, 1)*gridstruct%cosa_v&
&           (0, 2))
          vt(0, 2) = (vc(0, 2)-0.25*gridstruct%cosa_v(0, 2)*(ut(1, 1)+ut&
&           (1, 2)+ut(0, 2)+uc(0, 1)-0.25*gridstruct%cosa_u(0, 1)*(vt(0&
&           , 1)+vt(-1, 1)+vt(-1, 2))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(2, 1)*gridstruct%cosa_v&
&           (1, 2))
          ut(2, 1) = (uc(2, 1)-0.25*gridstruct%cosa_u(2, 1)*(vt(1, 1)+vt&
&           (2, 1)+vt(2, 2)+vc(1, 2)-0.25*gridstruct%cosa_v(1, 2)*(ut(1&
&           , 1)+ut(1, 2)+ut(2, 2))))*damp
          vt(1, 2) = (vc(1, 2)-0.25*gridstruct%cosa_v(1, 2)*(ut(1, 1)+ut&
&           (1, 2)+ut(2, 2)+uc(2, 1)-0.25*gridstruct%cosa_u(2, 1)*(vt(1&
&           , 1)+vt(2, 1)+vt(2, 2))))*damp
        END IF
        IF (se_corner) THEN
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx-1, 0)*gridstruct%&
&           cosa_v(npx-1, 0))
          ut(npx-1, 0) = (uc(npx-1, 0)-0.25*gridstruct%cosa_u(npx-1, 0)*&
&           (vt(npx-1, 1)+vt(npx-2, 1)+vt(npx-2, 0)+vc(npx-1, 0)-0.25*&
&           gridstruct%cosa_v(npx-1, 0)*(ut(npx, 0)+ut(npx, -1)+ut(npx-1&
&           , -1))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx+1, 1)*gridstruct%&
&           cosa_v(npx, 2))
          vt(npx, 2) = (vc(npx, 2)-0.25*gridstruct%cosa_v(npx, 2)*(ut(&
&           npx, 1)+ut(npx, 2)+ut(npx+1, 2)+uc(npx+1, 1)-0.25*gridstruct&
&           %cosa_u(npx+1, 1)*(vt(npx, 1)+vt(npx+1, 1)+vt(npx+1, 2))))*&
&           damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx-1, 1)*gridstruct%&
&           cosa_v(npx-1, 2))
          ut(npx-1, 1) = (uc(npx-1, 1)-0.25*gridstruct%cosa_u(npx-1, 1)*&
&           (vt(npx-1, 1)+vt(npx-2, 1)+vt(npx-2, 2)+vc(npx-1, 2)-0.25*&
&           gridstruct%cosa_v(npx-1, 2)*(ut(npx, 1)+ut(npx, 2)+ut(npx-1&
&           , 2))))*damp
          vt(npx-1, 2) = (vc(npx-1, 2)-0.25*gridstruct%cosa_v(npx-1, 2)*&
&           (ut(npx, 1)+ut(npx, 2)+ut(npx-1, 2)+uc(npx-1, 1)-0.25*&
&           gridstruct%cosa_u(npx-1, 1)*(vt(npx-1, 1)+vt(npx-2, 1)+vt(&
&           npx-2, 2))))*damp
        END IF
        IF (ne_corner) THEN
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx-1, npy)*gridstruct%&
&           cosa_v(npx-1, npy+1))
          ut(npx-1, npy) = (uc(npx-1, npy)-0.25*gridstruct%cosa_u(npx-1&
&           , npy)*(vt(npx-1, npy)+vt(npx-2, npy)+vt(npx-2, npy+1)+vc(&
&           npx-1, npy+1)-0.25*gridstruct%cosa_v(npx-1, npy+1)*(ut(npx, &
&           npy)+ut(npx, npy+1)+ut(npx-1, npy+1))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx+1, npy-1)*&
&           gridstruct%cosa_v(npx, npy-1))
          vt(npx, npy-1) = (vc(npx, npy-1)-0.25*gridstruct%cosa_v(npx, &
&           npy-1)*(ut(npx, npy-1)+ut(npx, npy-2)+ut(npx+1, npy-2)+uc(&
&           npx+1, npy-1)-0.25*gridstruct%cosa_u(npx+1, npy-1)*(vt(npx, &
&           npy)+vt(npx+1, npy)+vt(npx+1, npy-1))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(npx-1, npy-1)*&
&           gridstruct%cosa_v(npx-1, npy-1))
          ut(npx-1, npy-1) = (uc(npx-1, npy-1)-0.25*gridstruct%cosa_u(&
&           npx-1, npy-1)*(vt(npx-1, npy)+vt(npx-2, npy)+vt(npx-2, npy-1&
&           )+vc(npx-1, npy-1)-0.25*gridstruct%cosa_v(npx-1, npy-1)*(ut(&
&           npx, npy-1)+ut(npx, npy-2)+ut(npx-1, npy-2))))*damp
          vt(npx-1, npy-1) = (vc(npx-1, npy-1)-0.25*gridstruct%cosa_v(&
&           npx-1, npy-1)*(ut(npx, npy-1)+ut(npx, npy-2)+ut(npx-1, npy-2&
&           )+uc(npx-1, npy-1)-0.25*gridstruct%cosa_u(npx-1, npy-1)*(vt(&
&           npx-1, npy)+vt(npx-2, npy)+vt(npx-2, npy-1))))*damp
        END IF
        IF (nw_corner) THEN
          damp = 1./(1.-0.0625*gridstruct%cosa_u(2, npy)*gridstruct%&
&           cosa_v(1, npy+1))
          ut(2, npy) = (uc(2, npy)-0.25*gridstruct%cosa_u(2, npy)*(vt(1&
&           , npy)+vt(2, npy)+vt(2, npy+1)+vc(1, npy+1)-0.25*gridstruct%&
&           cosa_v(1, npy+1)*(ut(1, npy)+ut(1, npy+1)+ut(2, npy+1))))*&
&           damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(0, npy-1)*gridstruct%&
&           cosa_v(0, npy-1))
          vt(0, npy-1) = (vc(0, npy-1)-0.25*gridstruct%cosa_v(0, npy-1)*&
&           (ut(1, npy-1)+ut(1, npy-2)+ut(0, npy-2)+uc(0, npy-1)-0.25*&
&           gridstruct%cosa_u(0, npy-1)*(vt(0, npy)+vt(-1, npy)+vt(-1, &
&           npy-1))))*damp
          damp = 1./(1.-0.0625*gridstruct%cosa_u(2, npy-1)*gridstruct%&
&           cosa_v(1, npy-1))
          ut(2, npy-1) = (uc(2, npy-1)-0.25*gridstruct%cosa_u(2, npy-1)*&
&           (vt(1, npy)+vt(2, npy)+vt(2, npy-1)+vc(1, npy-1)-0.25*&
&           gridstruct%cosa_v(1, npy-1)*(ut(1, npy-1)+ut(1, npy-2)+ut(2&
&           , npy-2))))*damp
          vt(1, npy-1) = (vc(1, npy-1)-0.25*gridstruct%cosa_v(1, npy-1)*&
&           (ut(1, npy-1)+ut(1, npy-2)+ut(2, npy-2)+uc(2, npy-1)-0.25*&
&           gridstruct%cosa_u(2, npy-1)*(vt(1, npy)+vt(2, npy)+vt(2, npy&
&           -1))))*damp
        END IF
      END IF
    ELSE
! flagstruct%grid_type >= 3
      DO j=jsd,jed
        DO i=is,ie+1
          ut(i, j) = uc(i, j)
        END DO
      END DO
      DO j=js,je+1
        DO i=isd,ied
          vt(i, j) = vc(i, j)
        END DO
      END DO
    END IF
    DO j=jsd,jed
      DO i=is,ie+1
        xfx_adv(i, j) = dt*ut(i, j)
      END DO
    END DO
    DO j=js,je+1
      DO i=isd,ied
        yfx_adv(i, j) = dt*vt(i, j)
      END DO
    END DO
! Explanation of the following code:
!    xfx_adv = dt*ut*dy   
!    crx_adv = dt*ut/dx
    DO j=jsd,jed
!DEC$ VECTOR ALWAYS
      DO i=is,ie+1
        IF (xfx_adv(i, j) .GT. 0.) THEN
          crx_adv(i, j) = xfx_adv(i, j)*gridstruct%rdxa(i-1, j)
          xfx_adv(i, j) = gridstruct%dy(i, j)*xfx_adv(i, j)*gridstruct%&
&           sin_sg(i-1, j, 3)
        ELSE
          crx_adv(i, j) = xfx_adv(i, j)*gridstruct%rdxa(i, j)
          xfx_adv(i, j) = gridstruct%dy(i, j)*xfx_adv(i, j)*gridstruct%&
&           sin_sg(i, j, 1)
        END IF
      END DO
    END DO
    DO j=js,je+1
!DEC$ VECTOR ALWAYS
      DO i=isd,ied
        IF (yfx_adv(i, j) .GT. 0.) THEN
          cry_adv(i, j) = yfx_adv(i, j)*gridstruct%rdya(i, j-1)
          yfx_adv(i, j) = gridstruct%dx(i, j)*yfx_adv(i, j)*gridstruct%&
&           sin_sg(i, j-1, 4)
        ELSE
          cry_adv(i, j) = yfx_adv(i, j)*gridstruct%rdya(i, j)
          yfx_adv(i, j) = gridstruct%dx(i, j)*yfx_adv(i, j)*gridstruct%&
&           sin_sg(i, j, 2)
        END IF
      END DO
    END DO
!#ifdef SW_DYNAMICS
!      endif
!#endif
    DO j=jsd,jed
      DO i=is,ie
        ra_x(i, j) = gridstruct%area(i, j) + xfx_adv(i, j) - xfx_adv(i+1&
&         , j)
      END DO
    END DO
    DO j=js,je
      DO i=isd,ied
        ra_y(i, j) = gridstruct%area(i, j) + yfx_adv(i, j) - yfx_adv(i, &
&         j+1)
      END DO
    END DO
    IF (hord_dp .EQ. hord_dp_pert .AND. (.NOT.split_damp)) THEN
      CALL FV_TP_2D(delp, crx_adv, cry_adv, npx, npy, hord_dp, fx, fy&
&                , xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y, nord=&
&                nord_v, damp_c=damp_v)
    ELSE
      delp_tj = delp
      fx_tj = fx
      fy_tj = fy
      CALL FV_TP_2D(delp, crx_adv, cry_adv, npx, npy, hord_dp_pert, fx, &
&             fy, xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y, nord=&
&             nord_v_pert, damp_c=damp_v_pert)
    END IF
!#ifdef SW_DYNAMICS
!        do j=js,je
!           do i=is,ie
!              delp(i,j) = delp(i,j) +    &
!                         (fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*gridstruct%rarea(i,j)
!              ptc(i,j) = pt(i,j)
!           enddo
!        enddo
!#else
! <<< Save the mass fluxes to the "Flux Capacitor" for tracer transport >>>
    DO j=jsd,jed
      DO i=is,ie+1
        cx(i, j) = cx(i, j) + crx_adv(i, j)
      END DO
    END DO
    DO j=js,je
      DO i=is,ie+1
        xflux(i, j) = xflux(i, j) + fx(i, j)
      END DO
    END DO
    DO j=js,je+1
      DO i=isd,ied
        cy(i, j) = cy(i, j) + cry_adv(i, j)
      END DO
      DO i=is,ie
        yflux(i, j) = yflux(i, j) + fy(i, j)
      END DO
    END DO
    DO j=js,je
      DO i=is,ie
        heat_source(i, j) = 0.
      END DO
    END DO
    IF (.NOT.hydrostatic) THEN
      IF (damp_w .GT. 1.e-5) THEN
        damp4 = (damp_w*da_min_c)**(nord_w+1)
        CALL DEL6_VT_FLUX(nord_w, npx, npy, damp4, w, wk, fx2, fy2, &
&                   gridstruct, bd)
        DO j=js,je
          DO i=is,ie
            dw(i, j) = (fx2(i, j)-fx2(i+1, j)+fy2(i, j)-fy2(i, j+1))*&
&             gridstruct%rarea(i, j)
! 0.5 * [ (w+dw)**2 - w**2 ] = w*dw + 0.5*dw*dw
!                   heat_source(i,j) = -d_con*dw(i,j)*(w(i,j)+0.5*dw(i,j))
            heat_source(i, j) = -(dw(i, j)*(w(i, j)+0.5*dw(i, j)))
          END DO
        END DO
      END IF
      IF (hord_vt .EQ. hord_vt_pert) THEN
        CALL FV_TP_2D(w, crx_adv, cry_adv, npx, npy, hord_vt, gx, gy&
&                  , xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y, mfx=&
&                  fx, mfy=fy)
      ELSE
        w_tj = w
        gx_tj = gx
        gy_tj = gy
        CALL FV_TP_2D(w, crx_adv, cry_adv, npx, npy, hord_vt_pert, gx, &
&               gy, xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y, mfx=fx&
&               , mfy=fy)
      END IF
      DO j=js,je
        DO i=is,ie
          w(i, j) = delp(i, j)*w(i, j) + (gx(i, j)-gx(i+1, j)+gy(i, j)-&
&           gy(i, j+1))*gridstruct%rarea(i, j)
        END DO
      END DO
    END IF
!#ifdef USE_COND
!           call fv_tp_2d(q_con, crx_adv,cry_adv, npx, npy, hord_dp, gx, gy,  &
!                xfx_adv,yfx_adv, gridstruct, bd, ra_x, ra_y, mfx=fx, mfy=fy, mass=delp, nord=nord_t, damp_c=damp_t)
!            do j=js,je
!               do i=is,ie
!                  q_con(i,j) = delp(i,j)*q_con(i,j) + (gx(i,j)-gx(i+1,j)+gy(i,j)-gy(i,j+1))*gridstruct%rarea(i,j)
!               enddo
!            enddo
!#endif
    IF (inline_q) THEN
      DO j=jsd,jed
        DO i=isd,ied
          pt(i, j) = pt(i, j)/(1.+zvir*q(i, j, k, sphum))
        END DO
      END DO
    END IF
    IF (hord_tm .EQ. hord_tm_pert .AND. (.NOT.split_damp)) THEN
      CALL FV_TP_2D(pt, crx_adv, cry_adv, npx, npy, hord_tm, gx, gy, &
&                xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y, fx, fy, &
&                delp, nord_t, damp_t)
    ELSE
      pt_tj = pt
      gx_tj = gx
      gy_tj = gy
      CALL FV_TP_2D(pt, crx_adv, cry_adv, npx, npy, hord_tm_pert, gx, gy&
&             , xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y, fx, fy, &
&             delp, nord_t_pert, damp_t_pert)
    END IF
    IF (inline_q) THEN
      DO j=js,je
        DO i=is,ie
          wk(i, j) = delp(i, j)
          delp(i, j) = wk(i, j) + (fx(i, j)-fx(i+1, j)+fy(i, j)-fy(i, j+&
&           1))*gridstruct%rarea(i, j)
          pt(i, j) = (pt(i, j)*wk(i, j)+(gx(i, j)-gx(i+1, j)+gy(i, j)-gy&
&           (i, j+1))*gridstruct%rarea(i, j))/delp(i, j)
        END DO
      END DO
      DO iq=1,nq
        IF (hord_tr .EQ. hord_tr_pert) THEN
          CALL FV_TP_2D(q(isd:ied, jsd:jed, k, iq), crx_adv, cry_adv&
&                    , npx, npy, hord_tr, gx, gy, xfx_adv, yfx_adv, &
&                    gridstruct, bd, ra_x, ra_y, mfx=fx, mfy=fy)
        ELSE
          q_tj(:, :, :, iq) = q(:, :, :, iq)
          gx_tj = gx
          gy_tj = gy
          CALL FV_TP_2D(q(isd:ied, jsd:ied, k, iq), crx_adv, cry_adv, &
&                 npx, npy, hord_tr_pert, gx, gy, xfx_adv, yfx_adv, &
&                 gridstruct, bd, ra_x, ra_y, mfx=fx, mfy=fy)
        END IF
        DO j=js,je
          DO i=is,ie
            q(i, j, k, iq) = (q(i, j, k, iq)*wk(i, j)+(gx(i, j)-gx(i+1, &
&             j)+gy(i, j)-gy(i, j+1))*gridstruct%rarea(i, j))/delp(i, j)
          END DO
        END DO
      END DO
      DO j=js,je
        DO i=is,ie
          pt(i, j) = pt(i, j)*(1.+zvir*q(i, j, k, sphum))
        END DO
      END DO
    ELSE
      DO j=js,je
        DO i=is,ie
          pt(i, j) = pt(i, j)*delp(i, j) + (gx(i, j)-gx(i+1, j)+gy(i, j)&
&           -gy(i, j+1))*gridstruct%rarea(i, j)
          delp(i, j) = delp(i, j) + (fx(i, j)-fx(i+1, j)+fy(i, j)-fy(i, &
&           j+1))*gridstruct%rarea(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie
          pt(i, j) = pt(i, j)/delp(i, j)
        END DO
      END DO
    END IF
!#endif
!#ifdef SW_DYNAMICS
!      if (test_case > 1) then
!#endif
!----------------------
! Kinetic Energy Fluxes
!----------------------
! Compute B grid contra-variant components for KE:
    dt5 = 0.5*dt
    dt4 = 0.25*dt
    IF (nested) THEN
      is2 = is
      ie1 = ie + 1
      js2 = js
      je1 = je + 1
    ELSE
      IF (2 .LT. is) THEN
        is2 = is
      ELSE
        is2 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        ie1 = ie + 1
      ELSE
        ie1 = npx - 1
      END IF
      IF (2 .LT. js) THEN
        js2 = js
      ELSE
        js2 = 2
      END IF
      IF (npy - 1 .GT. je + 1) THEN
        je1 = je + 1
      ELSE
        je1 = npy - 1
      END IF
    END IF
!!! TO DO: separate versions for nested and for cubed-sphere
    IF (flagstruct%grid_type .LT. 3) THEN
      IF (nested) THEN
        DO j=js2,je1
          DO i=is2,ie1
            vb(i, j) = dt5*(vc(i-1, j)+vc(i, j)-(uc(i, j-1)+uc(i, j))*&
&             gridstruct%cosa(i, j))*gridstruct%rsina(i, j)
          END DO
        END DO
      ELSE
        IF (js .EQ. 1) THEN
          DO i=is,ie+1
! corner values are incorrect
            vb(i, 1) = dt5*(vt(i-1, 1)+vt(i, 1))
          END DO
        END IF
        DO j=js2,je1
          DO i=is2,ie1
            vb(i, j) = dt5*(vc(i-1, j)+vc(i, j)-(uc(i, j-1)+uc(i, j))*&
&             gridstruct%cosa(i, j))*gridstruct%rsina(i, j)
          END DO
          IF (is .EQ. 1) vb(1, j) = dt4*(-vt(-1, j)+3.*(vt(0, j)+vt(1, j&
&             ))-vt(2, j))
! 2-pt extrapolation from both sides:
          IF (ie + 1 .EQ. npx) vb(npx, j) = dt4*(-vt(npx-2, j)+3.*(vt(&
&             npx-1, j)+vt(npx, j))-vt(npx+1, j))
! 2-pt extrapolation from both sides:
        END DO
        IF (je + 1 .EQ. npy) THEN
          DO i=is,ie+1
! corner values are incorrect
            vb(i, npy) = dt5*(vt(i-1, npy)+vt(i, npy))
          END DO
        END IF
      END IF
    ELSE
      DO j=js,je+1
        DO i=is,ie+1
          vb(i, j) = dt5*(vc(i-1, j)+vc(i, j))
        END DO
      END DO
    END IF
    IF (hord_mt .EQ. hord_mt_pert) THEN
      CALL YTP_V(vb, u, v, ub, hord_mt, gridstruct%cosa, gridstruct%&
&             dy, gridstruct%rdy, bd, npx, npy, flagstruct%grid_type, &
&             nested)
    ELSE
      ub_tj = ub
      CALL YTP_V(vb, u, v, ub, hord_mt_pert, gridstruct%cosa, gridstruct&
&          %dy, gridstruct%rdy, bd, npx, npy, flagstruct%grid_type, &
&          nested)
    END IF
    DO j=js,je+1
      DO i=is,ie+1
        ke(i, j) = vb(i, j)*ub(i, j)
      END DO
    END DO
    IF (flagstruct%grid_type .LT. 3) THEN
      IF (nested) THEN
        DO j=js,je+1
          DO i=is2,ie1
            ub(i, j) = dt5*(uc(i, j-1)+uc(i, j)-(vc(i-1, j)+vc(i, j))*&
&             gridstruct%cosa(i, j))*gridstruct%rsina(i, j)
          END DO
        END DO
      ELSE
        IF (is .EQ. 1) THEN
          DO j=js,je+1
! corner values are incorrect
            ub(1, j) = dt5*(ut(1, j-1)+ut(1, j))
          END DO
        END IF
        DO j=js,je+1
          IF (j .EQ. 1 .OR. j .EQ. npy) THEN
            DO i=is2,ie1
! 2-pt extrapolation from both sides:
              ub(i, j) = dt4*(-ut(i, j-2)+3.*(ut(i, j-1)+ut(i, j))-ut(i&
&               , j+1))
            END DO
          ELSE
            DO i=is2,ie1
              ub(i, j) = dt5*(uc(i, j-1)+uc(i, j)-(vc(i-1, j)+vc(i, j))*&
&               gridstruct%cosa(i, j))*gridstruct%rsina(i, j)
            END DO
          END IF
        END DO
        IF (ie + 1 .EQ. npx) THEN
          DO j=js,je+1
! corner values are incorrect
            ub(npx, j) = dt5*(ut(npx, j-1)+ut(npx, j))
          END DO
        END IF
      END IF
    ELSE
      DO j=js,je+1
        DO i=is,ie+1
          ub(i, j) = dt5*(uc(i, j-1)+uc(i, j))
        END DO
      END DO
    END IF
    IF (hord_mt .EQ. hord_mt_pert) THEN
      CALL XTP_U(ub, u, v, vb, hord_mt, gridstruct%cosa, gridstruct%&
&             dx, gridstruct%rdx, bd, npx, npy, flagstruct%grid_type, &
&             nested)
    ELSE
      vb_tj = vb
      CALL XTP_U(ub, u, v, vb, hord_mt_pert, gridstruct%cosa, gridstruct&
&          %dx, gridstruct%rdx, bd, npx, npy, flagstruct%grid_type, &
&          nested)
    END IF
    DO j=js,je+1
      DO i=is,ie+1
        ke(i, j) = 0.5*(ke(i, j)+ub(i, j)*vb(i, j))
      END DO
    END DO
!-----------------------------------------
! Fix KE at the 4 corners of the face:
!-----------------------------------------
    IF (.NOT.nested) THEN
      dt6 = dt/6.
      IF (sw_corner) ke(1, 1) = dt6*((ut(1, 1)+ut(1, 0))*u(1, 1)+(vt(1, &
&         1)+vt(0, 1))*v(1, 1)+(ut(1, 1)+vt(1, 1))*u(0, 1))
      IF (se_corner) THEN
        ii = npx
        ke(ii, 1) = dt6*((ut(ii, 1)+ut(ii, 0))*u(ii-1, 1)+(vt(ii, 1)+vt(&
&         ii-1, 1))*v(ii, 1)+(ut(ii, 1)-vt(ii-1, 1))*u(ii, 1))
      END IF
      IF (ne_corner) THEN
        ii = npx
        jj = npy
        ke(ii, jj) = dt6*((ut(ii, jj)+ut(ii, jj-1))*u(ii-1, jj)+(vt(ii, &
&         jj)+vt(ii-1, jj))*v(ii, jj-1)+(ut(ii, jj-1)+vt(ii-1, jj))*u(ii&
&         , jj))
      END IF
      IF (nw_corner) THEN
        jj = npy
        ke(1, jj) = dt6*((ut(1, jj)+ut(1, jj-1))*u(1, jj)+(vt(1, jj)+vt(&
&         0, jj))*v(1, jj-1)+(ut(1, jj-1)-vt(1, jj))*u(0, jj))
      END IF
    END IF
! Compute vorticity:
    DO j=jsd,jed+1
      DO i=isd,ied
        vt(i, j) = u(i, j)*gridstruct%dx(i, j)
      END DO
    END DO
    DO j=jsd,jed
      DO i=isd,ied+1
        ut(i, j) = v(i, j)*gridstruct%dy(i, j)
      END DO
    END DO
! wk is "volume-mean" relative vorticity
    DO j=jsd,jed
      DO i=isd,ied
        wk(i, j) = gridstruct%rarea(i, j)*(vt(i, j)-vt(i, j+1)-ut(i, j)+&
&         ut(i+1, j))
      END DO
    END DO
    IF (.NOT.hydrostatic) THEN
      IF (.NOT.flagstruct%do_f3d) THEN
!#ifdef ROT3
!            dt2 = 2.*dt
!            do j=js,je
!               do i=is,ie
!                  w(i,j) = w(i,j)/delp(i,j) + dt2*gridstruct%w00(i,j) *  &
!                         ( gridstruct%a11(i,j)*(u(i,j)+u(i,j+1)) +       &
!                           gridstruct%a12(i,j)*(v(i,j)+v(i+1,j)) )
!               enddo
!            enddo
!#endif
        DO j=js,je
          DO i=is,ie
            w(i, j) = w(i, j)/delp(i, j)
          END DO
        END DO
      END IF
      IF (damp_w .GT. 1.e-5) THEN
        DO j=js,je
          DO i=is,ie
            w(i, j) = w(i, j) + dw(i, j)
          END DO
        END DO
      END IF
    END IF
!#ifdef USE_COND
!     do j=js,je
!        do i=is,ie
!           q_con(i,j) = q_con(i,j)/delp(i,j)
!        enddo
!     enddo
!#endif
!-----------------------------
! Compute divergence damping
!-----------------------------
!  damp = dddmp * da_min_c
    IF (.NOT.split_damp) THEN
      CALL COMPUTE_DIV_DAMPING(nord, d2_bg, d4_bg, dddmp, dt, vort, &
&                           ptc, delpc, ke, u, v, uc, vc, ua, va, divg_d&
&                           , wk, gridstruct, flagstruct, bd)
    ELSE
      delpc_tj = 0.0
      CALL COMPUTE_DIV_DAMPING(nord_pert, d2_bg_pert, d4_bg_pert, &
&                        dddmp_pert, dt, vort, ptc, delpc, ke, u, v, uc&
&                        , vc, ua, va, divg_d, wk, gridstruct, &
&                        flagstruct, bd)
    END IF
    IF (d_con .GT. 1.e-5) THEN
      DO j=js,je+1
        DO i=is,ie
          ub(i, j) = vort(i, j) - vort(i+1, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          vb(i, j) = vort(i, j) - vort(i, j+1)
        END DO
      END DO
    END IF
! Vorticity transport
    IF (hydrostatic) THEN
      DO j=jsd,jed
        DO i=isd,ied
          vort(i, j) = wk(i, j) + gridstruct%f0(i, j)
        END DO
      END DO
    ELSE IF (flagstruct%do_f3d) THEN
      DO j=jsd,jed
        DO i=isd,ied
          vort(i, j) = wk(i, j) + gridstruct%f0(i, j)*z_rat(i, j)
        END DO
      END DO
    ELSE
      DO j=jsd,jed
        DO i=isd,ied
          vort(i, j) = wk(i, j) + gridstruct%f0(i, j)
        END DO
      END DO
    END IF
    IF (hord_vt .EQ. hord_vt_pert) THEN
      CALL FV_TP_2D(vort, crx_adv, cry_adv, npx, npy, hord_vt, fx, fy&
&                , xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y)
    ELSE
      vort_tj = vort
      fx_tj = fx
      fy_tj = fy
      CALL FV_TP_2D(vort, crx_adv, cry_adv, npx, npy, hord_vt_pert, fx, &
&             fy, xfx_adv, yfx_adv, gridstruct, bd, ra_x, ra_y)
    END IF
    DO j=js,je+1
      DO i=is,ie
        u(i, j) = vt(i, j) + ke(i, j) - ke(i+1, j) + fy(i, j)
      END DO
    END DO
    DO j=js,je
      DO i=is,ie+1
        v(i, j) = ut(i, j) + ke(i, j) - ke(i, j+1) - fx(i, j)
      END DO
    END DO
!--------------------------------------------------------
! damping applied to relative vorticity (wk):
    IF (damp_v .GT. 1.e-5) THEN
      damp4 = (damp_v*da_min_c)**(nord_v+1)
      CALL DEL6_VT_FLUX(nord_v, npx, npy, damp4, wk, vort, ut, vt, &
&                 gridstruct, bd)
    END IF
    IF (damp_v_pert .GT. 1.e-5) THEN
      wk_tj = wk
      vort_tj = vort
      ut_tj = ut
      vt_tj = vt
      damp4_pert = (damp_v_pert*da_min_c)**(nord_v_pert+1)
      CALL DEL6_VT_FLUX(nord_v_pert, npx, npy, damp4_pert, wk, vort, ut&
&                 , vt, gridstruct, bd)
    END IF
    IF (d_con .GT. 1.e-5) THEN
      DO j=js,je+1
        DO i=is,ie
          ub(i, j) = (ub(i, j)+vt(i, j))*gridstruct%rdx(i, j)
          fy(i, j) = u(i, j)*gridstruct%rdx(i, j)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          gy(i, j) = fy(i, j)*ub(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          vb(i, j) = (vb(i, j)-ut(i, j))*gridstruct%rdy(i, j)
          fx(i, j) = v(i, j)*gridstruct%rdy(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          gx(i, j) = fx(i, j)*vb(i, j)
        END DO
      END DO
!----------------------------------
! Heating due to damping:
!----------------------------------
      damp = 0.25*d_con
      DO j=js,je
        DO i=is,ie
          u2 = fy(i, j) + fy(i, j+1)
          du2 = ub(i, j) + ub(i, j+1)
          v2 = fx(i, j) + fx(i+1, j)
          dv2 = vb(i, j) + vb(i+1, j)
! Total energy conserving:
! Convert lost KE due to divergence damping to "heat"
          heat_source(i, j) = delp(i, j)*(heat_source(i, j)-damp*&
&           gridstruct%rsin2(i, j)*(ub(i, j)**2+ub(i, j+1)**2+vb(i, j)**&
&           2+vb(i+1, j)**2+2.*(gy(i, j)+gy(i, j+1)+gx(i, j)+gx(i+1, j))&
&           -gridstruct%cosa_s(i, j)*(u2*dv2+v2*du2+du2*dv2)))
        END DO
      END DO
    END IF
! Add diffusive fluxes to the momentum equation:
    IF (damp_v .GT. 1.e-5) THEN
      DO j=js,je+1
        DO i=is,ie
          u(i, j) = u(i, j) + vt(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          v(i, j) = v(i, j) - ut(i, j)
        END DO
      END DO
    END IF
    IF (damp_v_pert .GT. 1.e-5) THEN
      DO j=js,je+1
        DO i=is,ie
          u(i, j) = u(i, j) + vt(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          v(i, j) = v(i, j) - ut(i, j)
        END DO
      END DO
    END IF
  END SUBROUTINE D_SW
!  Differentiation of compute_div_damping in reverse (adjoint) mode (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod.a2b
!_ord4_fb a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo d
!yn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.g
!rad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.rayleig
!h_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to_lat
!lon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energy fv
!_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mod.m
!ap1_q2_fb fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv_tra
!cer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver_c n
!h_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core_mod
!.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_corn
!er_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.co
!mpute_div_damping_fb sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mod.co
!py_corners_fb tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_mod.f
!yppm_fb tp_core_mod.deln_flux)):
!   gradient     of useful results: u v ke ua uc ptc delpc va vc
!                vort divg_d wk
!   with respect to varying inputs: u v ke ua uc ptc delpc va vc
!                divg_d wk
  SUBROUTINE COMPUTE_DIV_DAMPING_ADM(nord, d2_bg, d4_bg, dddmp, dt, vort&
&   , vort_ad, ptc, ptc_ad, delpc, delpc_ad, ke, ke_ad, u, u_ad, v, v_ad&
&   , uc, uc_ad, vc, vc_ad, ua, ua_ad, va, va_ad, divg_d, divg_d_ad, wk&
&   , wk_ad, gridstruct, flagstruct, bd)
    IMPLICIT NONE
!InOut Arguments
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
    INTEGER, INTENT(IN) :: nord
    REAL(fvprc), INTENT(IN) :: d2_bg, d4_bg, dddmp, dt
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: vort
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: vort_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delpc, ptc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delpc_ad, ptc_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(&
&   INOUT) :: ke
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(&
&   INOUT) :: ke_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u, vc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u_ad, vc_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v, uc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v_ad, uc_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: ua_ad, va_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(&
&   INOUT) :: divg_d
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(&
&   INOUT) :: divg_d_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: wk
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: wk_ad
!Locals
    REAL(fvprc) :: damp, dd8, damp2, da_min, da_min_c, absdt
    REAL(fvprc) :: damp_ad, damp2_ad
    INTEGER :: is, ie, js, je, npx, npy, is2, ie1
    LOGICAL :: nested, fill_c
    INTEGER :: i, j, n, n2, nt
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC SQRT
    REAL(fvprc) :: max1
    REAL(fvprc) :: max1_ad
    REAL(fvprc) :: max2
    REAL(fvprc) :: max2_ad
    REAL(fvprc) :: abs0
    REAL(fvprc) :: abs0_ad
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp_ad4
    REAL(fvprc) :: temp_ad5
    REAL(fvprc) :: temp_ad6
    REAL(fvprc) :: y3_ad
    REAL(fvprc) :: y1_ad
    REAL(fvprc) :: temp_ad7
    REAL(fvprc) :: temp_ad8
    REAL(fvprc) :: y2_ad
    INTEGER :: branch
    INTEGER :: ad_from
    INTEGER :: ad_to
    INTEGER :: ad_from0
    INTEGER :: ad_to0
    INTEGER :: ad_from1
    INTEGER :: ad_to1
    INTEGER :: ad_from2
    INTEGER :: ad_to2
    INTEGER :: ad_from3
    INTEGER :: ad_to3
    INTEGER :: ad_from4
    INTEGER :: ad_to4
    INTEGER :: ad_from5
    INTEGER :: ad_to5
    INTEGER :: ad_from6
    INTEGER :: ad_to6
    REAL(fvprc) :: temp_ad9
    REAL(fvprc) :: y3
    REAL(fvprc) :: y2
    REAL(fvprc) :: y1
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
    IF (dt .GE. 0.) THEN
      absdt = dt
    ELSE
      absdt = -dt
    END IF
    da_min = gridstruct%da_min
    da_min_c = gridstruct%da_min_c
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    npx = flagstruct%npx
    npy = flagstruct%npy
    nested = gridstruct%nested
    IF (nested) THEN
      CALL PUSHCONTROL1B(0)
      is2 = is
      ie1 = ie + 1
    ELSE
      IF (2 .LT. is) THEN
        is2 = is
      ELSE
        is2 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        CALL PUSHCONTROL1B(1)
        ie1 = ie + 1
      ELSE
        CALL PUSHCONTROL1B(1)
        ie1 = npx - 1
      END IF
    END IF
    IF (nord .EQ. 0) THEN
!         area ~ dxb*dyb*sin(alpha)
      IF (nested) THEN
        DO j=js,je+1
          DO i=is-1,ie+1
            CALL PUSHREALARRAY_ADM(ptc(i, j))
            ptc(i, j) = (u(i, j)-0.5*(va(i, j-1)+va(i, j))*gridstruct%&
&             cosa_v(i, j))*gridstruct%dyc(i, j)*gridstruct%sina_v(i, j)
          END DO
        END DO
        DO j=js-1,je+1
          DO i=is2,ie1
            vort(i, j) = (v(i, j)-0.5*(ua(i-1, j)+ua(i, j))*gridstruct%&
&             cosa_u(i, j))*gridstruct%dxc(i, j)*gridstruct%sina_u(i, j)
          END DO
        END DO
        CALL PUSHCONTROL1B(1)
      ELSE
        DO j=js,je+1
          IF (j .EQ. 1 .OR. j .EQ. npy) THEN
            DO i=is-1,ie+1
              IF (vc(i, j) .GT. 0) THEN
                CALL PUSHREALARRAY_ADM(ptc(i, j))
                ptc(i, j) = u(i, j)*gridstruct%dyc(i, j)*gridstruct%&
&                 sin_sg(i, j-1, 4)
                CALL PUSHCONTROL1B(1)
              ELSE
                CALL PUSHREALARRAY_ADM(ptc(i, j))
                ptc(i, j) = u(i, j)*gridstruct%dyc(i, j)*gridstruct%&
&                 sin_sg(i, j, 2)
                CALL PUSHCONTROL1B(0)
              END IF
            END DO
            CALL PUSHCONTROL1B(1)
          ELSE
            DO i=is-1,ie+1
              CALL PUSHREALARRAY_ADM(ptc(i, j))
              ptc(i, j) = (u(i, j)-0.5*(va(i, j-1)+va(i, j))*gridstruct%&
&               cosa_v(i, j))*gridstruct%dyc(i, j)*gridstruct%sina_v(i, &
&               j)
            END DO
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
        DO j=js-1,je+1
          DO i=is2,ie1
            vort(i, j) = (v(i, j)-0.5*(ua(i-1, j)+ua(i, j))*gridstruct%&
&             cosa_u(i, j))*gridstruct%dxc(i, j)*gridstruct%sina_u(i, j)
          END DO
          IF (is .EQ. 1) THEN
            IF (uc(1, j) .GT. 0) THEN
              vort(1, j) = v(1, j)*gridstruct%dxc(1, j)*gridstruct%&
&               sin_sg(0, j, 3)
              CALL PUSHCONTROL2B(0)
            ELSE
              vort(1, j) = v(1, j)*gridstruct%dxc(1, j)*gridstruct%&
&               sin_sg(1, j, 1)
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B(2)
          END IF
          IF (ie + 1 .EQ. npx) THEN
            IF (uc(npx, j) .GT. 0) THEN
              vort(npx, j) = v(npx, j)*gridstruct%dxc(npx, j)*gridstruct&
&               %sin_sg(npx-1, j, 3)
              CALL PUSHCONTROL2B(2)
            ELSE
              vort(npx, j) = v(npx, j)*gridstruct%dxc(npx, j)*gridstruct&
&               %sin_sg(npx, j, 1)
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B(0)
          END IF
        END DO
        CALL PUSHCONTROL1B(0)
      END IF
      CALL PUSHREALARRAY_ADM(delpc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+&
&                   1)/8)
      DO j=js,je+1
        DO i=is,ie+1
          delpc(i, j) = vort(i, j-1) - vort(i, j) + ptc(i-1, j) - ptc(i&
&           , j)
        END DO
      END DO
! Remove the extra term at the corners:
      IF (sw_corner) THEN
        CALL PUSHREALARRAY_ADM(delpc(1, 1))
        delpc(1, 1) = delpc(1, 1) - vort(1, 0)
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (se_corner) THEN
        CALL PUSHREALARRAY_ADM(delpc(npx, 1))
        delpc(npx, 1) = delpc(npx, 1) - vort(npx, 0)
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (ne_corner) THEN
        CALL PUSHREALARRAY_ADM(delpc(npx, npy))
        delpc(npx, npy) = delpc(npx, npy) + vort(npx, npy)
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (nw_corner) THEN
        CALL PUSHREALARRAY_ADM(delpc(1, npy))
        delpc(1, npy) = delpc(1, npy) + vort(1, npy)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          CALL PUSHREALARRAY_ADM(delpc(i, j))
          delpc(i, j) = gridstruct%rarea_c(i, j)*delpc(i, j)
          IF (delpc(i, j)*dt .GE. 0.) THEN
            abs0 = delpc(i, j)*dt
            CALL PUSHCONTROL1B(0)
          ELSE
            abs0 = -(delpc(i, j)*dt)
            CALL PUSHCONTROL1B(1)
          END IF
          y3 = dddmp*abs0
          IF (0.20 .GT. y3) THEN
            y1 = y3
            CALL PUSHCONTROL1B(0)
          ELSE
            y1 = 0.20
            CALL PUSHCONTROL1B(1)
          END IF
          IF (d2_bg .LT. y1) THEN
            max1 = y1
            CALL PUSHCONTROL1B(0)
          ELSE
            max1 = d2_bg
            CALL PUSHCONTROL1B(1)
          END IF
          CALL PUSHREALARRAY_ADM(damp)
          damp = da_min_c*max1
        END DO
      END DO
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          vort_ad(i, j) = vort_ad(i, j) + ke_ad(i, j)
          damp_ad = delpc(i, j)*vort_ad(i, j)
          delpc_ad(i, j) = delpc_ad(i, j) + damp*vort_ad(i, j)
          vort_ad(i, j) = 0.0_FVPRC
          CALL POPREALARRAY_ADM(damp)
          max1_ad = da_min_c*damp_ad
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            y1_ad = max1_ad
          ELSE
            y1_ad = 0.0_FVPRC
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            y3_ad = y1_ad
          ELSE
            y3_ad = 0.0_FVPRC
          END IF
          abs0_ad = dddmp*y3_ad
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            delpc_ad(i, j) = delpc_ad(i, j) + dt*abs0_ad
          ELSE
            delpc_ad(i, j) = delpc_ad(i, j) - dt*abs0_ad
          END IF
          CALL POPREALARRAY_ADM(delpc(i, j))
          delpc_ad(i, j) = gridstruct%rarea_c(i, j)*delpc_ad(i, j)
        END DO
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        CALL POPREALARRAY_ADM(delpc(1, npy))
        vort_ad(1, npy) = vort_ad(1, npy) + delpc_ad(1, npy)
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREALARRAY_ADM(delpc(npx, npy))
        vort_ad(npx, npy) = vort_ad(npx, npy) + delpc_ad(npx, npy)
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREALARRAY_ADM(delpc(npx, 1))
        vort_ad(npx, 0) = vort_ad(npx, 0) - delpc_ad(npx, 1)
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREALARRAY_ADM(delpc(1, 1))
        vort_ad(1, 0) = vort_ad(1, 0) - delpc_ad(1, 1)
      END IF
      CALL POPREALARRAY_ADM(delpc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                  )/8)
      DO j=js,je+1
        DO i=ie+1,is,-1
          vort_ad(i, j-1) = vort_ad(i, j-1) + delpc_ad(i, j)
          vort_ad(i, j) = vort_ad(i, j) - delpc_ad(i, j)
          ptc_ad(i-1, j) = ptc_ad(i-1, j) + delpc_ad(i, j)
          ptc_ad(i, j) = ptc_ad(i, j) - delpc_ad(i, j)
          delpc_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO j=je+1,js-1,-1
          CALL POPCONTROL2B(branch)
          IF (branch .NE. 0) THEN
            IF (branch .EQ. 1) THEN
              v_ad(npx, j) = v_ad(npx, j) + gridstruct%sin_sg(npx, j, 1)&
&               *gridstruct%dxc(npx, j)*vort_ad(npx, j)
              vort_ad(npx, j) = 0.0_FVPRC
            ELSE
              v_ad(npx, j) = v_ad(npx, j) + gridstruct%sin_sg(npx-1, j, &
&               3)*gridstruct%dxc(npx, j)*vort_ad(npx, j)
              vort_ad(npx, j) = 0.0_FVPRC
            END IF
          END IF
          CALL POPCONTROL2B(branch)
          IF (branch .EQ. 0) THEN
            v_ad(1, j) = v_ad(1, j) + gridstruct%sin_sg(0, j, 3)*&
&             gridstruct%dxc(1, j)*vort_ad(1, j)
            vort_ad(1, j) = 0.0_FVPRC
          ELSE IF (branch .EQ. 1) THEN
            v_ad(1, j) = v_ad(1, j) + gridstruct%sin_sg(1, j, 1)*&
&             gridstruct%dxc(1, j)*vort_ad(1, j)
            vort_ad(1, j) = 0.0_FVPRC
          END IF
          DO i=ie1,is2,-1
            temp_ad5 = gridstruct%dxc(i, j)*gridstruct%sina_u(i, j)*&
&             vort_ad(i, j)
            temp_ad6 = -(gridstruct%cosa_u(i, j)*0.5*temp_ad5)
            v_ad(i, j) = v_ad(i, j) + temp_ad5
            ua_ad(i-1, j) = ua_ad(i-1, j) + temp_ad6
            ua_ad(i, j) = ua_ad(i, j) + temp_ad6
            vort_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
        DO j=je+1,js,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            DO i=ie+1,is-1,-1
              CALL POPREALARRAY_ADM(ptc(i, j))
              temp_ad3 = gridstruct%dyc(i, j)*gridstruct%sina_v(i, j)*&
&               ptc_ad(i, j)
              temp_ad4 = -(gridstruct%cosa_v(i, j)*0.5*temp_ad3)
              u_ad(i, j) = u_ad(i, j) + temp_ad3
              va_ad(i, j-1) = va_ad(i, j-1) + temp_ad4
              va_ad(i, j) = va_ad(i, j) + temp_ad4
              ptc_ad(i, j) = 0.0_FVPRC
            END DO
          ELSE
            DO i=ie+1,is-1,-1
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                CALL POPREALARRAY_ADM(ptc(i, j))
                u_ad(i, j) = u_ad(i, j) + gridstruct%sin_sg(i, j, 2)*&
&                 gridstruct%dyc(i, j)*ptc_ad(i, j)
                ptc_ad(i, j) = 0.0_FVPRC
              ELSE
                CALL POPREALARRAY_ADM(ptc(i, j))
                u_ad(i, j) = u_ad(i, j) + gridstruct%sin_sg(i, j-1, 4)*&
&                 gridstruct%dyc(i, j)*ptc_ad(i, j)
                ptc_ad(i, j) = 0.0_FVPRC
              END IF
            END DO
          END IF
        END DO
      ELSE
        DO j=je+1,js-1,-1
          DO i=ie1,is2,-1
            temp_ad1 = gridstruct%dxc(i, j)*gridstruct%sina_u(i, j)*&
&             vort_ad(i, j)
            temp_ad2 = -(gridstruct%cosa_u(i, j)*0.5*temp_ad1)
            v_ad(i, j) = v_ad(i, j) + temp_ad1
            ua_ad(i-1, j) = ua_ad(i-1, j) + temp_ad2
            ua_ad(i, j) = ua_ad(i, j) + temp_ad2
            vort_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
        DO j=je+1,js,-1
          DO i=ie+1,is-1,-1
            CALL POPREALARRAY_ADM(ptc(i, j))
            temp_ad = gridstruct%dyc(i, j)*gridstruct%sina_v(i, j)*&
&             ptc_ad(i, j)
            temp_ad0 = -(gridstruct%cosa_v(i, j)*0.5*temp_ad)
            u_ad(i, j) = u_ad(i, j) + temp_ad
            va_ad(i, j-1) = va_ad(i, j-1) + temp_ad0
            va_ad(i, j) = va_ad(i, j) + temp_ad0
            ptc_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
      END IF
    ELSE
      CALL PUSHREALARRAY_ADM(delpc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+&
&                   1)/8)
!--------------------------
! Higher order divg damping
!--------------------------
      DO j=js,je+1
        DO i=is,ie+1
! Save divergence for external mode filter
          delpc(i, j) = divg_d(i, j)
        END DO
      END DO
! N > 1
      n2 = nord + 1
      DO n=1,nord
        nt = nord - n
        fill_c = nt .NE. 0 .AND. flagstruct%grid_type .LT. 3 .AND. (((&
&         sw_corner .OR. se_corner) .OR. ne_corner) .OR. nw_corner) &
&         .AND. (.NOT.nested)
        IF (fill_c) THEN
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        ad_from0 = js - nt
        DO j=ad_from0,je+1+nt
          ad_from = is - 1 - nt
          i = ie + nt + 2
          CALL PUSHINTEGER4(i - 1)
          CALL PUSHINTEGER4(ad_from)
        END DO
        CALL PUSHINTEGER4(j - 1)
        CALL PUSHINTEGER4(ad_from0)
        IF (fill_c) THEN
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        ad_from2 = js - 1 - nt
        DO j=ad_from2,je+1+nt
          ad_from1 = is - nt
          i = ie + nt + 2
          CALL PUSHINTEGER4(i - 1)
          CALL PUSHINTEGER4(ad_from1)
        END DO
        CALL PUSHINTEGER4(j - 1)
        CALL PUSHINTEGER4(ad_from2)
        IF (fill_c) THEN
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        ad_from4 = js - nt
        DO j=ad_from4,je+1+nt
          ad_from3 = is - nt
          i = ie + nt + 2
          CALL PUSHINTEGER4(i - 1)
          CALL PUSHINTEGER4(ad_from3)
        END DO
        CALL PUSHINTEGER4(j - 1)
        CALL PUSHINTEGER4(ad_from4)
! Remove the extra term at the corners:
        IF (sw_corner) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (se_corner) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (ne_corner) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (nw_corner) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (.NOT.gridstruct%stretched_grid) THEN
          ad_from6 = js - nt
          DO j=ad_from6,je+1+nt
            ad_from5 = is - nt
            i = ie + nt + 2
            CALL PUSHINTEGER4(i - 1)
            CALL PUSHINTEGER4(ad_from5)
          END DO
          CALL PUSHINTEGER4(j - 1)
          CALL PUSHINTEGER4(ad_from6)
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
! n-loop
      IF (dddmp .LT. 1.e-5) THEN
        CALL PUSHCONTROL2B(0)
        vort(:, :) = 0.
      ELSE IF (flagstruct%grid_type .LT. 3) THEN
! Interpolate relative vort to cell corners
        CALL PUSHREALARRAY_ADM(wk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                     )/8)
        CALL A2B_ORD4(wk, vort, gridstruct, npx, npy, is, ie, js, je, ng&
&               , .false.)
        CALL PUSHREALARRAY_ADM(vort, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd&
&                     +1)/8)
        DO j=js,je+1
          DO i=is,ie+1
! The following is an approxi form of Smagorinsky diffusion
            vort(i, j) = absdt*SQRT(delpc(i, j)**2+vort(i, j)**2)
          END DO
        END DO
        CALL PUSHCONTROL2B(1)
      ELSE
! Correct form: works only for doubly preiodic domain
        CALL PUSHREALARRAY_ADM(vort, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd&
&                     +1)/8)
        CALL SMAG_CORNER(absdt, u, v, ua, va, vort, bd, npx, npy, &
&                  gridstruct, ng)
        CALL PUSHCONTROL2B(2)
      END IF
      IF (gridstruct%stretched_grid) THEN
! Stretched grid with variable damping ~ area
        dd8 = da_min*d4_bg**n2
      ELSE
        dd8 = (da_min_c*d4_bg)**n2
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          IF (0.20 .GT. dddmp*vort(i, j)) THEN
            y2 = dddmp*vort(i, j)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
            y2 = 0.20
          END IF
          IF (d2_bg .LT. y2) THEN
            max2 = y2
            CALL PUSHCONTROL1B(0)
          ELSE
            max2 = d2_bg
            CALL PUSHCONTROL1B(1)
          END IF
! del-2
          CALL PUSHREALARRAY_ADM(damp2)
          damp2 = da_min_c*max2
        END DO
      END DO
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          vort_ad(i, j) = vort_ad(i, j) + ke_ad(i, j)
          damp2_ad = delpc(i, j)*vort_ad(i, j)
          delpc_ad(i, j) = delpc_ad(i, j) + damp2*vort_ad(i, j)
          divg_d_ad(i, j) = divg_d_ad(i, j) + dd8*vort_ad(i, j)
          vort_ad(i, j) = 0.0_FVPRC
          CALL POPREALARRAY_ADM(damp2)
          max2_ad = da_min_c*damp2_ad
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            y2_ad = max2_ad
          ELSE
            y2_ad = 0.0_FVPRC
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) vort_ad(i, j) = vort_ad(i, j) + dddmp*y2_ad
        END DO
      END DO
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .EQ. 1) THEN
          CALL POPREALARRAY_ADM(vort, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%&
&                      jsd+1)/8)
          DO j=js,je+1
            DO i=ie+1,is,-1
              IF (delpc(i, j)**2 + vort(i, j)**2 .EQ. 0.0_FVPRC) THEN
                temp_ad9 = 0.0
              ELSE
                temp_ad9 = absdt*vort_ad(i, j)/(2.0*SQRT(delpc(i, j)**2+&
&                 vort(i, j)**2))
              END IF
              delpc_ad(i, j) = delpc_ad(i, j) + 2*delpc(i, j)*temp_ad9
              vort_ad(i, j) = 2*vort(i, j)*temp_ad9
            END DO
          END DO
          CALL POPREALARRAY_ADM(wk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+&
&                      1)/8)
          CALL A2B_ORD4_ADM(wk, wk_ad, vort, vort_ad, gridstruct, npx, &
&                     npy, is, ie, js, je, ng, .false.)
        ELSE
          CALL POPREALARRAY_ADM(vort, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%&
&                      jsd+1)/8)
          CALL SMAG_CORNER_ADM(absdt, u, u_ad, v, v_ad, ua, va, vort, &
&                        vort_ad, bd, npx, npy, gridstruct, ng)
        END IF
      END IF
      DO n=nord,1,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          CALL POPINTEGER4(ad_from6)
          CALL POPINTEGER4(ad_to6)
          DO j=ad_to6,ad_from6,-1
            CALL POPINTEGER4(ad_from5)
            CALL POPINTEGER4(ad_to5)
            DO i=ad_to5,ad_from5,-1
              divg_d_ad(i, j) = gridstruct%rarea_c(i, j)*divg_d_ad(i, j)
            END DO
          END DO
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) uc_ad(1, npy) = uc_ad(1, npy) + divg_d_ad(1, &
&           npy)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) uc_ad(npx, npy) = uc_ad(npx, npy) + divg_d_ad&
&           (npx, npy)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) uc_ad(npx, 0) = uc_ad(npx, 0) - divg_d_ad(npx&
&           , 1)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) uc_ad(1, 0) = uc_ad(1, 0) - divg_d_ad(1, 1)
        CALL POPINTEGER4(ad_from4)
        CALL POPINTEGER4(ad_to4)
        DO j=ad_to4,ad_from4,-1
          CALL POPINTEGER4(ad_from3)
          CALL POPINTEGER4(ad_to3)
          DO i=ad_to3,ad_from3,-1
            uc_ad(i, j-1) = uc_ad(i, j-1) + divg_d_ad(i, j)
            uc_ad(i, j) = uc_ad(i, j) - divg_d_ad(i, j)
            vc_ad(i-1, j) = vc_ad(i-1, j) + divg_d_ad(i, j)
            vc_ad(i, j) = vc_ad(i, j) - divg_d_ad(i, j)
            divg_d_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) CALL FILL_CORNERS_ADM(vc, vc_ad, uc, uc_ad, &
&                                          npx, npy, dgrid=.true., &
&                                          vector=.true.)
        CALL POPINTEGER4(ad_from2)
        CALL POPINTEGER4(ad_to2)
        DO j=ad_to2,ad_from2,-1
          CALL POPINTEGER4(ad_from1)
          CALL POPINTEGER4(ad_to1)
          DO i=ad_to1,ad_from1,-1
            temp_ad8 = gridstruct%divg_v(i, j)*uc_ad(i, j)
            divg_d_ad(i, j+1) = divg_d_ad(i, j+1) + temp_ad8
            divg_d_ad(i, j) = divg_d_ad(i, j) - temp_ad8
            uc_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) CALL FILL_CORNERS_ADM(divg_d, divg_d_ad, npx&
&                                          , npy, fill=ydir, bgrid=&
&                                          .true.)
        CALL POPINTEGER4(ad_from0)
        CALL POPINTEGER4(ad_to0)
        DO j=ad_to0,ad_from0,-1
          CALL POPINTEGER4(ad_from)
          CALL POPINTEGER4(ad_to)
          DO i=ad_to,ad_from,-1
            temp_ad7 = gridstruct%divg_u(i, j)*vc_ad(i, j)
            divg_d_ad(i+1, j) = divg_d_ad(i+1, j) + temp_ad7
            divg_d_ad(i, j) = divg_d_ad(i, j) - temp_ad7
            vc_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) CALL FILL_CORNERS_ADM(divg_d, divg_d_ad, npx&
&                                          , npy, fill=xdir, bgrid=&
&                                          .true.)
      END DO
      CALL POPREALARRAY_ADM(delpc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                  )/8)
      DO j=js,je+1
        DO i=ie+1,is,-1
          divg_d_ad(i, j) = divg_d_ad(i, j) + delpc_ad(i, j)
          delpc_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
    END IF
    CALL POPCONTROL1B(branch)
  END SUBROUTINE COMPUTE_DIV_DAMPING_ADM
  SUBROUTINE COMPUTE_DIV_DAMPING(nord, d2_bg, d4_bg, dddmp, dt, vort, &
&   ptc, delpc, ke, u, v, uc, vc, ua, va, divg_d, wk, gridstruct, &
&   flagstruct, bd)
    IMPLICIT NONE
!InOut Arguments
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
    INTEGER, INTENT(IN) :: nord
    REAL(fvprc), INTENT(IN) :: d2_bg, d4_bg, dddmp, dt
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: vort
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delpc, ptc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(&
&   INOUT) :: ke
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u, vc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v, uc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(&
&   INOUT) :: divg_d
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: wk
!Locals
    REAL(fvprc) :: damp, dd8, damp2, da_min, da_min_c, absdt
    INTEGER :: is, ie, js, je, npx, npy, is2, ie1
    LOGICAL :: nested, fill_c
    INTEGER :: i, j, n, n2, nt
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC SQRT
    REAL(fvprc) :: max1
    REAL(fvprc) :: max2
    REAL(fvprc) :: abs0
    REAL(fvprc) :: y3
    REAL(fvprc) :: y2
    REAL(fvprc) :: y1
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
    IF (dt .GE. 0.) THEN
      absdt = dt
    ELSE
      absdt = -dt
    END IF
    da_min = gridstruct%da_min
    da_min_c = gridstruct%da_min_c
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    npx = flagstruct%npx
    npy = flagstruct%npy
    nested = gridstruct%nested
    IF (nested) THEN
      is2 = is
      ie1 = ie + 1
    ELSE
      IF (2 .LT. is) THEN
        is2 = is
      ELSE
        is2 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        ie1 = ie + 1
      ELSE
        ie1 = npx - 1
      END IF
    END IF
    IF (nord .EQ. 0) THEN
!         area ~ dxb*dyb*sin(alpha)
      IF (nested) THEN
        DO j=js,je+1
          DO i=is-1,ie+1
            ptc(i, j) = (u(i, j)-0.5*(va(i, j-1)+va(i, j))*gridstruct%&
&             cosa_v(i, j))*gridstruct%dyc(i, j)*gridstruct%sina_v(i, j)
          END DO
        END DO
        DO j=js-1,je+1
          DO i=is2,ie1
            vort(i, j) = (v(i, j)-0.5*(ua(i-1, j)+ua(i, j))*gridstruct%&
&             cosa_u(i, j))*gridstruct%dxc(i, j)*gridstruct%sina_u(i, j)
          END DO
        END DO
      ELSE
        DO j=js,je+1
          IF (j .EQ. 1 .OR. j .EQ. npy) THEN
            DO i=is-1,ie+1
              IF (vc(i, j) .GT. 0) THEN
                ptc(i, j) = u(i, j)*gridstruct%dyc(i, j)*gridstruct%&
&                 sin_sg(i, j-1, 4)
              ELSE
                ptc(i, j) = u(i, j)*gridstruct%dyc(i, j)*gridstruct%&
&                 sin_sg(i, j, 2)
              END IF
            END DO
          ELSE
            DO i=is-1,ie+1
              ptc(i, j) = (u(i, j)-0.5*(va(i, j-1)+va(i, j))*gridstruct%&
&               cosa_v(i, j))*gridstruct%dyc(i, j)*gridstruct%sina_v(i, &
&               j)
            END DO
          END IF
        END DO
        DO j=js-1,je+1
          DO i=is2,ie1
            vort(i, j) = (v(i, j)-0.5*(ua(i-1, j)+ua(i, j))*gridstruct%&
&             cosa_u(i, j))*gridstruct%dxc(i, j)*gridstruct%sina_u(i, j)
          END DO
          IF (is .EQ. 1) THEN
            IF (uc(1, j) .GT. 0) THEN
              vort(1, j) = v(1, j)*gridstruct%dxc(1, j)*gridstruct%&
&               sin_sg(0, j, 3)
            ELSE
              vort(1, j) = v(1, j)*gridstruct%dxc(1, j)*gridstruct%&
&               sin_sg(1, j, 1)
            END IF
          END IF
          IF (ie + 1 .EQ. npx) THEN
            IF (uc(npx, j) .GT. 0) THEN
              vort(npx, j) = v(npx, j)*gridstruct%dxc(npx, j)*gridstruct&
&               %sin_sg(npx-1, j, 3)
            ELSE
              vort(npx, j) = v(npx, j)*gridstruct%dxc(npx, j)*gridstruct&
&               %sin_sg(npx, j, 1)
            END IF
          END IF
        END DO
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          delpc(i, j) = vort(i, j-1) - vort(i, j) + ptc(i-1, j) - ptc(i&
&           , j)
        END DO
      END DO
! Remove the extra term at the corners:
      IF (sw_corner) delpc(1, 1) = delpc(1, 1) - vort(1, 0)
      IF (se_corner) delpc(npx, 1) = delpc(npx, 1) - vort(npx, 0)
      IF (ne_corner) delpc(npx, npy) = delpc(npx, npy) + vort(npx, npy)
      IF (nw_corner) delpc(1, npy) = delpc(1, npy) + vort(1, npy)
      DO j=js,je+1
        DO i=is,ie+1
          delpc(i, j) = gridstruct%rarea_c(i, j)*delpc(i, j)
          IF (delpc(i, j)*dt .GE. 0.) THEN
            abs0 = delpc(i, j)*dt
          ELSE
            abs0 = -(delpc(i, j)*dt)
          END IF
          y3 = dddmp*abs0
          IF (0.20 .GT. y3) THEN
            y1 = y3
          ELSE
            y1 = 0.20
          END IF
          IF (d2_bg .LT. y1) THEN
            max1 = y1
          ELSE
            max1 = d2_bg
          END IF
          damp = da_min_c*max1
          vort(i, j) = damp*delpc(i, j)
          ke(i, j) = ke(i, j) + vort(i, j)
        END DO
      END DO
    ELSE
!--------------------------
! Higher order divg damping
!--------------------------
      DO j=js,je+1
        DO i=is,ie+1
! Save divergence for external mode filter
          delpc(i, j) = divg_d(i, j)
        END DO
      END DO
! N > 1
      n2 = nord + 1
      DO n=1,nord
        nt = nord - n
        fill_c = nt .NE. 0 .AND. flagstruct%grid_type .LT. 3 .AND. (((&
&         sw_corner .OR. se_corner) .OR. ne_corner) .OR. nw_corner) &
&         .AND. (.NOT.nested)
        IF (fill_c) CALL FILL_CORNERS(divg_d, npx, npy, fill=xdir, bgrid&
&                               =.true.)
        DO j=js-nt,je+1+nt
          DO i=is-1-nt,ie+1+nt
            vc(i, j) = (divg_d(i+1, j)-divg_d(i, j))*gridstruct%divg_u(i&
&             , j)
          END DO
        END DO
        IF (fill_c) CALL FILL_CORNERS(divg_d, npx, npy, fill=ydir, bgrid&
&                               =.true.)
        DO j=js-1-nt,je+1+nt
          DO i=is-nt,ie+1+nt
            uc(i, j) = (divg_d(i, j+1)-divg_d(i, j))*gridstruct%divg_v(i&
&             , j)
          END DO
        END DO
        IF (fill_c) CALL FILL_CORNERS(vc, uc, npx, npy, dgrid=.true., &
&                               vector=.true.)
        DO j=js-nt,je+1+nt
          DO i=is-nt,ie+1+nt
            divg_d(i, j) = uc(i, j-1) - uc(i, j) + vc(i-1, j) - vc(i, j)
          END DO
        END DO
! Remove the extra term at the corners:
        IF (sw_corner) divg_d(1, 1) = divg_d(1, 1) - uc(1, 0)
        IF (se_corner) divg_d(npx, 1) = divg_d(npx, 1) - uc(npx, 0)
        IF (ne_corner) divg_d(npx, npy) = divg_d(npx, npy) + uc(npx, npy&
&           )
        IF (nw_corner) divg_d(1, npy) = divg_d(1, npy) + uc(1, npy)
        IF (.NOT.gridstruct%stretched_grid) THEN
          DO j=js-nt,je+1+nt
            DO i=is-nt,ie+1+nt
              divg_d(i, j) = divg_d(i, j)*gridstruct%rarea_c(i, j)
            END DO
          END DO
        END IF
      END DO
! n-loop
      IF (dddmp .LT. 1.e-5) THEN
        vort(:, :) = 0.
      ELSE IF (flagstruct%grid_type .LT. 3) THEN
! Interpolate relative vort to cell corners
        CALL A2B_ORD4(wk, vort, gridstruct, npx, npy, is, ie, js, je, ng&
&               , .false.)
        DO j=js,je+1
          DO i=is,ie+1
! The following is an approxi form of Smagorinsky diffusion
            vort(i, j) = absdt*SQRT(delpc(i, j)**2+vort(i, j)**2)
          END DO
        END DO
      ELSE
! Correct form: works only for doubly preiodic domain
        CALL SMAG_CORNER(absdt, u, v, ua, va, vort, bd, npx, npy, &
&                  gridstruct, ng)
      END IF
      IF (gridstruct%stretched_grid) THEN
! Stretched grid with variable damping ~ area
        dd8 = da_min*d4_bg**n2
      ELSE
        dd8 = (da_min_c*d4_bg)**n2
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          IF (0.20 .GT. dddmp*vort(i, j)) THEN
            y2 = dddmp*vort(i, j)
          ELSE
            y2 = 0.20
          END IF
          IF (d2_bg .LT. y2) THEN
            max2 = y2
          ELSE
            max2 = d2_bg
          END IF
! del-2
          damp2 = da_min_c*max2
          vort(i, j) = damp2*delpc(i, j) + dd8*divg_d(i, j)
          ke(i, j) = ke(i, j) + vort(i, j)
        END DO
      END DO
    END IF
  END SUBROUTINE COMPUTE_DIV_DAMPING
!  Differentiation of compute_div_damping in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord
!2 a2b_edge_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_
!core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_gra
!d_p dyn_core_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dy
!namics_mod.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_util
!s_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compu
!te_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_trace
!r_fb fv_mapz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz
!_mod.steepz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_m
!od.riem_solver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_
!solver nh_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_m
!od.divergence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corn
!ers sw_core_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d
!_fb tp_core_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxpp
!m_fb tp_core_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: u v ke ua uc ptc delpc va vc
!                vort divg_d wk
!   with respect to varying inputs: u v ke ua uc ptc delpc va vc
!                divg_d wk
  SUBROUTINE COMPUTE_DIV_DAMPING_FWD(nord, d2_bg, d4_bg, dddmp, dt, &
&   vort, ptc, delpc, ke, u, v, uc, vc, ua, va, divg_d, wk, gridstruct, &
&   flagstruct, bd)
    IMPLICIT NONE
!InOut Arguments
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
    INTEGER, INTENT(IN) :: nord
    REAL(fvprc), INTENT(IN) :: d2_bg, d4_bg, dddmp, dt
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: vort
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delpc, ptc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(&
&   INOUT) :: ke
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u, vc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v, uc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(&
&   INOUT) :: divg_d
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: wk
!Locals
    REAL(fvprc) :: damp, dd8, damp2, da_min, da_min_c, absdt
    INTEGER :: is, ie, js, je, npx, npy, is2, ie1
    LOGICAL :: nested, fill_c
    INTEGER :: i, j, n, n2, nt
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC SQRT
    REAL(fvprc) :: max1
    REAL(fvprc) :: max2
    REAL(fvprc) :: abs0
    INTEGER :: ad_from
    INTEGER :: ad_from0
    INTEGER :: ad_from1
    INTEGER :: ad_from2
    INTEGER :: ad_from3
    INTEGER :: ad_from4
    INTEGER :: ad_from5
    INTEGER :: ad_from6
    REAL(fvprc) :: y3
    REAL(fvprc) :: y2
    REAL(fvprc) :: y1
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
    da_min = gridstruct%da_min
    da_min_c = gridstruct%da_min_c
    IF (dt .GE. 0.) THEN
      absdt = dt
    ELSE
      absdt = -dt
    END IF
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    npx = flagstruct%npx
    npy = flagstruct%npy
    nested = gridstruct%nested
    IF (nested) THEN
      CALL PUSHCONTROL1B_FV(0)
      is2 = is
      ie1 = ie + 1
    ELSE
      IF (2 .LT. is) THEN
        is2 = is
      ELSE
        is2 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        CALL PUSHCONTROL1B_FV(1)
        ie1 = ie + 1
      ELSE
        CALL PUSHCONTROL1B_FV(1)
        ie1 = npx - 1
      END IF
    END IF
    IF (nord .EQ. 0) THEN
!         area ~ dxb*dyb*sin(alpha)
      IF (nested) THEN
        DO j=js,je+1
          DO i=is-1,ie+1
            CALL PUSHREALARRAY(ptc(i, j))
            ptc(i, j) = (u(i, j)-0.5*(va(i, j-1)+va(i, j))*gridstruct%&
&             cosa_v(i, j))*gridstruct%dyc(i, j)*gridstruct%sina_v(i, j)
          END DO
        END DO
        DO j=js-1,je+1
          DO i=is2,ie1
            vort(i, j) = (v(i, j)-0.5*(ua(i-1, j)+ua(i, j))*gridstruct%&
&             cosa_u(i, j))*gridstruct%dxc(i, j)*gridstruct%sina_u(i, j)
          END DO
        END DO
        CALL PUSHCONTROL1B_FV(1)
      ELSE
        DO j=js,je+1
          IF (j .EQ. 1 .OR. j .EQ. npy) THEN
            DO i=is-1,ie+1
              IF (vc(i, j) .GT. 0) THEN
                CALL PUSHREALARRAY(ptc(i, j))
                ptc(i, j) = u(i, j)*gridstruct%dyc(i, j)*gridstruct%&
&                 sin_sg(i, j-1, 4)
                CALL PUSHCONTROL1B_FV(1)
              ELSE
                CALL PUSHREALARRAY(ptc(i, j))
                ptc(i, j) = u(i, j)*gridstruct%dyc(i, j)*gridstruct%&
&                 sin_sg(i, j, 2)
                CALL PUSHCONTROL1B_FV(0)
              END IF
            END DO
            CALL PUSHCONTROL1B_FV(1)
          ELSE
            DO i=is-1,ie+1
              CALL PUSHREALARRAY(ptc(i, j))
              ptc(i, j) = (u(i, j)-0.5*(va(i, j-1)+va(i, j))*gridstruct%&
&               cosa_v(i, j))*gridstruct%dyc(i, j)*gridstruct%sina_v(i, &
&               j)
            END DO
            CALL PUSHCONTROL1B_FV(0)
          END IF
        END DO
        DO j=js-1,je+1
          DO i=is2,ie1
            vort(i, j) = (v(i, j)-0.5*(ua(i-1, j)+ua(i, j))*gridstruct%&
&             cosa_u(i, j))*gridstruct%dxc(i, j)*gridstruct%sina_u(i, j)
          END DO
          IF (is .EQ. 1) THEN
            IF (uc(1, j) .GT. 0) THEN
              vort(1, j) = v(1, j)*gridstruct%dxc(1, j)*gridstruct%&
&               sin_sg(0, j, 3)
              CALL PUSHCONTROL2B_FV(0)
            ELSE
              vort(1, j) = v(1, j)*gridstruct%dxc(1, j)*gridstruct%&
&               sin_sg(1, j, 1)
              CALL PUSHCONTROL2B_FV(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B_FV(2)
          END IF
          IF (ie + 1 .EQ. npx) THEN
            IF (uc(npx, j) .GT. 0) THEN
              vort(npx, j) = v(npx, j)*gridstruct%dxc(npx, j)*gridstruct&
&               %sin_sg(npx-1, j, 3)
              CALL PUSHCONTROL2B_FV(2)
            ELSE
              vort(npx, j) = v(npx, j)*gridstruct%dxc(npx, j)*gridstruct&
&               %sin_sg(npx, j, 1)
              CALL PUSHCONTROL2B_FV(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B_FV(0)
          END IF
        END DO
        CALL PUSHCONTROL1B_FV(0)
      END IF
      CALL PUSHREALARRAY(delpc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+&
&                   1)/8)
      CALL PUSHINTEGER(ie)
      CALL PUSHINTEGER(is)
      DO j=js,je+1
        DO i=is,ie+1
          delpc(i, j) = vort(i, j-1) - vort(i, j) + ptc(i-1, j) - ptc(i&
&           , j)
        END DO
      END DO
! Remove the extra term at the corners:
      IF (sw_corner) THEN
        CALL PUSHREALARRAY(delpc(1, 1))
        delpc(1, 1) = delpc(1, 1) - vort(1, 0)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (se_corner) THEN
        CALL PUSHREALARRAY(delpc(npx, 1))
        delpc(npx, 1) = delpc(npx, 1) - vort(npx, 0)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (ne_corner) THEN
        CALL PUSHREALARRAY(delpc(npx, npy))
        delpc(npx, npy) = delpc(npx, npy) + vort(npx, npy)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (nw_corner) THEN
        CALL PUSHREALARRAY(delpc(1, npy))
        delpc(1, npy) = delpc(1, npy) + vort(1, npy)
        CALL PUSHCONTROL1B_FV(1)
      ELSE
        CALL PUSHCONTROL1B_FV(0)
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          CALL PUSHREALARRAY(delpc(i, j))
          delpc(i, j) = gridstruct%rarea_c(i, j)*delpc(i, j)
          IF (delpc(i, j)*dt .GE. 0.) THEN
            abs0 = delpc(i, j)*dt
            CALL PUSHCONTROL1B_FV(0)
          ELSE
            abs0 = -(delpc(i, j)*dt)
            CALL PUSHCONTROL1B_FV(1)
          END IF
          y3 = dddmp*abs0
          IF (0.20 .GT. y3) THEN
            y1 = y3
            CALL PUSHCONTROL1B_FV(0)
          ELSE
            y1 = 0.20
            CALL PUSHCONTROL1B_FV(1)
          END IF
          IF (d2_bg .LT. y1) THEN
            max1 = y1
            CALL PUSHCONTROL1B_FV(0)
          ELSE
            max1 = d2_bg
            CALL PUSHCONTROL1B_FV(1)
          END IF
          CALL PUSHREALARRAY(damp)
          damp = da_min_c*max1
          vort(i, j) = damp*delpc(i, j)
          ke(i, j) = ke(i, j) + vort(i, j)
        END DO
      END DO
      CALL PUSHINTEGER(js)
      CALL PUSHINTEGER(npx)
      CALL PUSHINTEGER(npy)
      CALL PUSHREALARRAY(damp)
      CALL PUSHINTEGER(is2)
      CALL PUSHREALARRAY(da_min_c)
      CALL PUSHINTEGER(is)
      CALL PUSHINTEGER(ie1)
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHREALARRAY(delpc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+&
&                   1)/8)
      CALL PUSHINTEGER(ie)
      CALL PUSHINTEGER(is)
!--------------------------
! Higher order divg damping
!--------------------------
      DO j=js,je+1
        DO i=is,ie+1
! Save divergence for external mode filter
          delpc(i, j) = divg_d(i, j)
        END DO
      END DO
! N > 1
      n2 = nord + 1
      DO n=1,nord
        nt = nord - n
        fill_c = nt .NE. 0 .AND. flagstruct%grid_type .LT. 3 .AND. (((&
&         sw_corner .OR. se_corner) .OR. ne_corner) .OR. nw_corner) &
&         .AND. (.NOT.nested)
        IF (fill_c) THEN
          CALL FILL_CORNERS(divg_d, npx, npy, fill=xdir, bgrid=.true.)
          CALL PUSHCONTROL1B_FV(1)
        ELSE
          CALL PUSHCONTROL1B_FV(0)
        END IF
        ad_from0 = js - nt
        DO j=ad_from0,je+1+nt
          ad_from = is - 1 - nt
          DO i=ad_from,ie+1+nt
            vc(i, j) = (divg_d(i+1, j)-divg_d(i, j))*gridstruct%divg_u(i&
&             , j)
          END DO
          CALL PUSHINTEGER(i - 1)
          CALL PUSHINTEGER(ad_from)
        END DO
        CALL PUSHINTEGER(j - 1)
        CALL PUSHINTEGER(ad_from0)
        IF (fill_c) THEN
          CALL FILL_CORNERS(divg_d, npx, npy, fill=ydir, bgrid=.true.)
          CALL PUSHCONTROL1B_FV(1)
        ELSE
          CALL PUSHCONTROL1B_FV(0)
        END IF
        ad_from2 = js - 1 - nt
        DO j=ad_from2,je+1+nt
          ad_from1 = is - nt
          DO i=ad_from1,ie+1+nt
            uc(i, j) = (divg_d(i, j+1)-divg_d(i, j))*gridstruct%divg_v(i&
&             , j)
          END DO
          CALL PUSHINTEGER(i - 1)
          CALL PUSHINTEGER(ad_from1)
        END DO
        CALL PUSHINTEGER(j - 1)
        CALL PUSHINTEGER(ad_from2)
        IF (fill_c) THEN
          CALL FILL_CORNERS(vc, uc, npx, npy, vector=.true., dgrid=&
&                     .true.)
          CALL PUSHCONTROL1B_FV(1)
        ELSE
          CALL PUSHCONTROL1B_FV(0)
        END IF
        ad_from4 = js - nt
        DO j=ad_from4,je+1+nt
          ad_from3 = is - nt
          DO i=ad_from3,ie+1+nt
            divg_d(i, j) = uc(i, j-1) - uc(i, j) + vc(i-1, j) - vc(i, j)
          END DO
          CALL PUSHINTEGER(i - 1)
          CALL PUSHINTEGER(ad_from3)
        END DO
        CALL PUSHINTEGER(j - 1)
        CALL PUSHINTEGER(ad_from4)
! Remove the extra term at the corners:
        IF (sw_corner) THEN
          divg_d(1, 1) = divg_d(1, 1) - uc(1, 0)
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
        IF (se_corner) THEN
          divg_d(npx, 1) = divg_d(npx, 1) - uc(npx, 0)
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
        IF (ne_corner) THEN
          divg_d(npx, npy) = divg_d(npx, npy) + uc(npx, npy)
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
        IF (nw_corner) THEN
          divg_d(1, npy) = divg_d(1, npy) + uc(1, npy)
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
        IF (.NOT.gridstruct%stretched_grid) THEN
          ad_from6 = js - nt
          DO j=ad_from6,je+1+nt
            ad_from5 = is - nt
            DO i=ad_from5,ie+1+nt
              divg_d(i, j) = divg_d(i, j)*gridstruct%rarea_c(i, j)
            END DO
            CALL PUSHINTEGER(i - 1)
            CALL PUSHINTEGER(ad_from5)
          END DO
          CALL PUSHINTEGER(j - 1)
          CALL PUSHINTEGER(ad_from6)
          CALL PUSHCONTROL1B_FV(1)
        ELSE
          CALL PUSHCONTROL1B_FV(0)
        END IF
      END DO
! n-loop
      IF (dddmp .LT. 1.e-5) THEN
        vort(:, :) = 0.
        CALL PUSHCONTROL2B_FV(0)
      ELSE IF (flagstruct%grid_type .LT. 3) THEN
! Interpolate relative vort to cell corners
        CALL A2B_ORD4_FWD(wk, vort, gridstruct, npx, npy, is, ie, js&
&                      , je, ng, .false.)
        CALL PUSHREALARRAY(vort, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd&
&                     +1)/8)
        CALL PUSHINTEGER(ie)
        CALL PUSHREALARRAY(absdt)
        DO j=js,je+1
          DO i=is,ie+1
! The following is an approxi form of Smagorinsky diffusion
            vort(i, j) = absdt*SQRT(delpc(i, j)**2+vort(i, j)**2)
          END DO
        END DO
        CALL PUSHCONTROL2B_FV(1)
      ELSE
! Correct form: works only for doubly preiodic domain
        CALL SMAG_CORNER_FWD(absdt, u, v, ua, va, vort, bd, npx, npy&
&                         , gridstruct, ng)
        CALL PUSHCONTROL2B_FV(2)
      END IF
      IF (gridstruct%stretched_grid) THEN
! Stretched grid with variable damping ~ area
        dd8 = da_min*d4_bg**n2
      ELSE
        dd8 = (da_min_c*d4_bg)**n2
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          IF (0.20 .GT. dddmp*vort(i, j)) THEN
            y2 = dddmp*vort(i, j)
            CALL PUSHCONTROL1B_FV(0)
          ELSE
            CALL PUSHCONTROL1B_FV(1)
            y2 = 0.20
          END IF
          IF (d2_bg .LT. y2) THEN
            max2 = y2
            CALL PUSHCONTROL1B_FV(0)
          ELSE
            max2 = d2_bg
            CALL PUSHCONTROL1B_FV(1)
          END IF
! del-2
          CALL PUSHREALARRAY(damp2)
          damp2 = da_min_c*max2
          vort(i, j) = damp2*delpc(i, j) + dd8*divg_d(i, j)
          ke(i, j) = ke(i, j) + vort(i, j)
        END DO
      END DO
      CALL PUSHINTEGER(js)
      CALL PUSHREALARRAY(da_min_c)
      CALL PUSHREALARRAY(dd8)
      CALL PUSHINTEGER(is)
      CALL PUSHREALARRAY(absdt)
      CALL PUSHREALARRAY(damp2)
      CALL PUSHCONTROL1B_FV(1)
    END IF
  END SUBROUTINE COMPUTE_DIV_DAMPING_FWD
!  Differentiation of compute_div_damping in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_or
!d2 a2b_edge_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn
!_core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_gr
!ad_p dyn_core_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_d
!ynamics_mod.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_uti
!ls_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.comp
!ute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_trac
!er_fb fv_mapz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_map
!z_mod.steepz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_
!mod.riem_solver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1
!_solver nh_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_
!mod.divergence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4cor
!ners sw_core_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2
!d_fb tp_core_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxp
!pm_fb tp_core_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: u v ke ua uc ptc delpc va vc
!                vort divg_d wk
!   with respect to varying inputs: u v ke ua uc ptc delpc va vc
!                divg_d wk
  SUBROUTINE COMPUTE_DIV_DAMPING_BWD(nord, d2_bg, d4_bg, dddmp, dt, &
&   vort, vort_ad, ptc, ptc_ad, delpc, delpc_ad, ke, ke_ad, u, u_ad, v, &
&   v_ad, uc, uc_ad, vc, vc_ad, ua, ua_ad, va, va_ad, divg_d, divg_d_ad&
&   , wk, wk_ad, gridstruct, flagstruct, bd)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
    INTEGER, INTENT(IN) :: nord
    REAL(fvprc), INTENT(IN) :: d2_bg, d4_bg, dddmp, dt
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: vort
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: vort_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delpc, ptc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: delpc_ad, ptc_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(&
&   INOUT) :: ke
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(&
&   INOUT) :: ke_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u, vc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(INOUT&
&   ) :: u_ad, vc_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v, uc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(INOUT&
&   ) :: v_ad, uc_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: ua_ad, va_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(&
&   INOUT) :: divg_d
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(&
&   INOUT) :: divg_d_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: wk
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(INOUT) &
&   :: wk_ad
    REAL(fvprc) :: damp, dd8, damp2, da_min, da_min_c, absdt
    REAL(fvprc) :: damp_ad, damp2_ad
    INTEGER :: is, ie, js, je, npx, npy, is2, ie1
    LOGICAL :: nested, fill_c
    INTEGER :: i, j, n, n2, nt
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC SQRT
    REAL(fvprc) :: max1
    REAL(fvprc) :: max1_ad
    REAL(fvprc) :: max2
    REAL(fvprc) :: max2_ad
    REAL(fvprc) :: abs0
    REAL(fvprc) :: abs0_ad
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp_ad4
    REAL(fvprc) :: temp_ad5
    REAL(fvprc) :: temp_ad6
    REAL(fvprc) :: y3_ad
    REAL(fvprc) :: y1_ad
    REAL(fvprc) :: temp_ad7
    REAL(fvprc) :: temp_ad8
    REAL(fvprc) :: y2_ad
    INTEGER :: branch
    INTEGER :: ad_from
    INTEGER :: ad_to
    INTEGER :: ad_from0
    INTEGER :: ad_to0
    INTEGER :: ad_from1
    INTEGER :: ad_to1
    INTEGER :: ad_from2
    INTEGER :: ad_to2
    INTEGER :: ad_from3
    INTEGER :: ad_to3
    INTEGER :: ad_from4
    INTEGER :: ad_to4
    INTEGER :: ad_from5
    INTEGER :: ad_to5
    INTEGER :: ad_from6
    INTEGER :: ad_to6
    REAL(fvprc) :: temp_ad9
    REAL(fvprc) :: y3
    REAL(fvprc) :: y2
    REAL(fvprc) :: y1
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPINTEGER(ie1)
      CALL POPINTEGER(is)
      CALL POPREALARRAY(da_min_c)
      CALL POPINTEGER(is2)
      CALL POPREALARRAY(damp)
      CALL POPINTEGER(npy)
      CALL POPINTEGER(npx)
      CALL POPINTEGER(js)
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          vort_ad(i, j) = vort_ad(i, j) + ke_ad(i, j)
          damp_ad = delpc(i, j)*vort_ad(i, j)
          delpc_ad(i, j) = delpc_ad(i, j) + damp*vort_ad(i, j)
          vort_ad(i, j) = 0.0_FVPRC
          CALL POPREALARRAY(damp)
          max1_ad = da_min_c*damp_ad
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            y1_ad = max1_ad
          ELSE
            y1_ad = 0.0_FVPRC
          END IF
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            y3_ad = y1_ad
          ELSE
            y3_ad = 0.0_FVPRC
          END IF
          abs0_ad = dddmp*y3_ad
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            delpc_ad(i, j) = delpc_ad(i, j) + dt*abs0_ad
          ELSE
            delpc_ad(i, j) = delpc_ad(i, j) - dt*abs0_ad
          END IF
          CALL POPREALARRAY(delpc(i, j))
          delpc_ad(i, j) = gridstruct%rarea_c(i, j)*delpc_ad(i, j)
        END DO
      END DO
      CALL POPCONTROL1B_FV(branch)
      IF (branch .NE. 0) THEN
        npy = flagstruct%npy
        CALL POPREALARRAY(delpc(1, npy))
        vort_ad(1, npy) = vort_ad(1, npy) + delpc_ad(1, npy)
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        npx = flagstruct%npx
        CALL POPREALARRAY(delpc(npx, npy))
        vort_ad(npx, npy) = vort_ad(npx, npy) + delpc_ad(npx, npy)
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREALARRAY(delpc(npx, 1))
        vort_ad(npx, 0) = vort_ad(npx, 0) - delpc_ad(npx, 1)
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREALARRAY(delpc(1, 1))
        vort_ad(1, 0) = vort_ad(1, 0) - delpc_ad(1, 1)
      END IF
      CALL POPINTEGER(is)
      CALL POPINTEGER(ie)
      CALL POPREALARRAY(delpc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                  )/8)
      DO j=js,je+1
        DO i=ie+1,is,-1
          vort_ad(i, j-1) = vort_ad(i, j-1) + delpc_ad(i, j)
          vort_ad(i, j) = vort_ad(i, j) - delpc_ad(i, j)
          ptc_ad(i-1, j) = ptc_ad(i-1, j) + delpc_ad(i, j)
          ptc_ad(i, j) = ptc_ad(i, j) - delpc_ad(i, j)
          delpc_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        DO j=je+1,js-1,-1
          CALL POPCONTROL2B_FV(branch)
          IF (branch .NE. 0) THEN
            IF (branch .EQ. 1) THEN
              v_ad(npx, j) = v_ad(npx, j) + gridstruct%sin_sg(npx, j, 1)&
&               *gridstruct%dxc(npx, j)*vort_ad(npx, j)
              vort_ad(npx, j) = 0.0_FVPRC
            ELSE
              v_ad(npx, j) = v_ad(npx, j) + gridstruct%sin_sg(npx-1, j, &
&               3)*gridstruct%dxc(npx, j)*vort_ad(npx, j)
              vort_ad(npx, j) = 0.0_FVPRC
            END IF
          END IF
          CALL POPCONTROL2B_FV(branch)
          IF (branch .EQ. 0) THEN
            v_ad(1, j) = v_ad(1, j) + gridstruct%sin_sg(0, j, 3)*&
&             gridstruct%dxc(1, j)*vort_ad(1, j)
            vort_ad(1, j) = 0.0_FVPRC
          ELSE IF (branch .EQ. 1) THEN
            v_ad(1, j) = v_ad(1, j) + gridstruct%sin_sg(1, j, 1)*&
&             gridstruct%dxc(1, j)*vort_ad(1, j)
            vort_ad(1, j) = 0.0_FVPRC
          END IF
          DO i=ie1,is2,-1
            temp_ad5 = gridstruct%dxc(i, j)*gridstruct%sina_u(i, j)*&
&             vort_ad(i, j)
            temp_ad6 = -(gridstruct%cosa_u(i, j)*0.5*temp_ad5)
            v_ad(i, j) = v_ad(i, j) + temp_ad5
            ua_ad(i-1, j) = ua_ad(i-1, j) + temp_ad6
            ua_ad(i, j) = ua_ad(i, j) + temp_ad6
            vort_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
        DO j=je+1,js,-1
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            DO i=ie+1,is-1,-1
              CALL POPREALARRAY(ptc(i, j))
              temp_ad3 = gridstruct%dyc(i, j)*gridstruct%sina_v(i, j)*&
&               ptc_ad(i, j)
              temp_ad4 = -(gridstruct%cosa_v(i, j)*0.5*temp_ad3)
              u_ad(i, j) = u_ad(i, j) + temp_ad3
              va_ad(i, j-1) = va_ad(i, j-1) + temp_ad4
              va_ad(i, j) = va_ad(i, j) + temp_ad4
              ptc_ad(i, j) = 0.0_FVPRC
            END DO
          ELSE
            DO i=ie+1,is-1,-1
              CALL POPCONTROL1B_FV(branch)
              IF (branch .EQ. 0) THEN
                CALL POPREALARRAY(ptc(i, j))
                u_ad(i, j) = u_ad(i, j) + gridstruct%sin_sg(i, j, 2)*&
&                 gridstruct%dyc(i, j)*ptc_ad(i, j)
                ptc_ad(i, j) = 0.0_FVPRC
              ELSE
                CALL POPREALARRAY(ptc(i, j))
                u_ad(i, j) = u_ad(i, j) + gridstruct%sin_sg(i, j-1, 4)*&
&                 gridstruct%dyc(i, j)*ptc_ad(i, j)
                ptc_ad(i, j) = 0.0_FVPRC
              END IF
            END DO
          END IF
        END DO
      ELSE
        DO j=je+1,js-1,-1
          DO i=ie1,is2,-1
            temp_ad1 = gridstruct%dxc(i, j)*gridstruct%sina_u(i, j)*&
&             vort_ad(i, j)
            temp_ad2 = -(gridstruct%cosa_u(i, j)*0.5*temp_ad1)
            v_ad(i, j) = v_ad(i, j) + temp_ad1
            ua_ad(i-1, j) = ua_ad(i-1, j) + temp_ad2
            ua_ad(i, j) = ua_ad(i, j) + temp_ad2
            vort_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
        DO j=je+1,js,-1
          DO i=ie+1,is-1,-1
            CALL POPREALARRAY(ptc(i, j))
            temp_ad = gridstruct%dyc(i, j)*gridstruct%sina_v(i, j)*&
&             ptc_ad(i, j)
            temp_ad0 = -(gridstruct%cosa_v(i, j)*0.5*temp_ad)
            u_ad(i, j) = u_ad(i, j) + temp_ad
            va_ad(i, j-1) = va_ad(i, j-1) + temp_ad0
            va_ad(i, j) = va_ad(i, j) + temp_ad0
            ptc_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
      END IF
    ELSE
      CALL POPREALARRAY(damp2)
      CALL POPREALARRAY(absdt)
      CALL POPINTEGER(is)
      CALL POPREALARRAY(dd8)
      CALL POPREALARRAY(da_min_c)
      CALL POPINTEGER(js)
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          vort_ad(i, j) = vort_ad(i, j) + ke_ad(i, j)
          damp2_ad = delpc(i, j)*vort_ad(i, j)
          delpc_ad(i, j) = delpc_ad(i, j) + damp2*vort_ad(i, j)
          divg_d_ad(i, j) = divg_d_ad(i, j) + dd8*vort_ad(i, j)
          vort_ad(i, j) = 0.0_FVPRC
          CALL POPREALARRAY(damp2)
          max2_ad = da_min_c*damp2_ad
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            y2_ad = max2_ad
          ELSE
            y2_ad = 0.0_FVPRC
          END IF
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) vort_ad(i, j) = vort_ad(i, j) + dddmp*y2_ad
        END DO
      END DO
      CALL POPCONTROL2B_FV(branch)
      IF (branch .EQ. 0) THEN
        npx = flagstruct%npx
        npy = flagstruct%npy
      ELSE IF (branch .EQ. 1) THEN
        CALL POPREALARRAY(absdt)
        CALL POPINTEGER(ie)
        CALL POPREALARRAY(vort, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+&
&                    1)/8)
        DO j=js,je+1
          DO i=ie+1,is,-1
            IF (delpc(i, j)**2 + vort(i, j)**2 .EQ. 0.0_FVPRC) THEN
              temp_ad9 = 0.0
            ELSE
              temp_ad9 = absdt*vort_ad(i, j)/(2.0*SQRT(delpc(i, j)**2+&
&               vort(i, j)**2))
            END IF
            delpc_ad(i, j) = delpc_ad(i, j) + 2*delpc(i, j)*temp_ad9
            vort_ad(i, j) = 2*vort(i, j)*temp_ad9
          END DO
        END DO
        npx = flagstruct%npx
        npy = flagstruct%npy
        CALL A2B_ORD4_BWD(wk, wk_ad, vort, vort_ad, gridstruct, npx, &
&                      npy, is, ie, js, je, ng, .false.)
      ELSE
        npx = flagstruct%npx
        npy = flagstruct%npy
        CALL SMAG_CORNER_BWD(absdt, u, u_ad, v, v_ad, ua, va, vort, &
&                         vort_ad, bd, npx, npy, gridstruct, ng)
      END IF
      DO n=nord,1,-1
        CALL POPCONTROL1B_FV(branch)
        IF (branch .NE. 0) THEN
          CALL POPINTEGER(ad_from6)
          CALL POPINTEGER(ad_to6)
          DO j=ad_to6,ad_from6,-1
            CALL POPINTEGER(ad_from5)
            CALL POPINTEGER(ad_to5)
            DO i=ad_to5,ad_from5,-1
              divg_d_ad(i, j) = gridstruct%rarea_c(i, j)*divg_d_ad(i, j)
            END DO
          END DO
        END IF
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) uc_ad(1, npy) = uc_ad(1, npy) + divg_d_ad(1, &
&           npy)
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) uc_ad(npx, npy) = uc_ad(npx, npy) + divg_d_ad&
&           (npx, npy)
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) uc_ad(npx, 0) = uc_ad(npx, 0) - divg_d_ad(npx&
&           , 1)
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) uc_ad(1, 0) = uc_ad(1, 0) - divg_d_ad(1, 1)
        CALL POPINTEGER(ad_from4)
        CALL POPINTEGER(ad_to4)
        DO j=ad_to4,ad_from4,-1
          CALL POPINTEGER(ad_from3)
          CALL POPINTEGER(ad_to3)
          DO i=ad_to3,ad_from3,-1
            uc_ad(i, j-1) = uc_ad(i, j-1) + divg_d_ad(i, j)
            uc_ad(i, j) = uc_ad(i, j) - divg_d_ad(i, j)
            vc_ad(i-1, j) = vc_ad(i-1, j) + divg_d_ad(i, j)
            vc_ad(i, j) = vc_ad(i, j) - divg_d_ad(i, j)
            divg_d_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
        CALL POPCONTROL1B_FV(branch)
        IF (branch .NE. 0) CALL FILL_CORNERS_ADM(vc, vc_ad, uc, uc_ad, &
&                                          npx, npy, dgrid=.true., &
&                                          vector=.true.)
        CALL POPINTEGER(ad_from2)
        CALL POPINTEGER(ad_to2)
        DO j=ad_to2,ad_from2,-1
          CALL POPINTEGER(ad_from1)
          CALL POPINTEGER(ad_to1)
          DO i=ad_to1,ad_from1,-1
            temp_ad8 = gridstruct%divg_v(i, j)*uc_ad(i, j)
            divg_d_ad(i, j+1) = divg_d_ad(i, j+1) + temp_ad8
            divg_d_ad(i, j) = divg_d_ad(i, j) - temp_ad8
            uc_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
        CALL POPCONTROL1B_FV(branch)
        IF (branch .NE. 0) CALL FILL_CORNERS_ADM(divg_d, divg_d_ad, npx&
&                                          , npy, fill=ydir, bgrid=&
&                                          .true.)
        CALL POPINTEGER(ad_from0)
        CALL POPINTEGER(ad_to0)
        DO j=ad_to0,ad_from0,-1
          CALL POPINTEGER(ad_from)
          CALL POPINTEGER(ad_to)
          DO i=ad_to,ad_from,-1
            temp_ad7 = gridstruct%divg_u(i, j)*vc_ad(i, j)
            divg_d_ad(i+1, j) = divg_d_ad(i+1, j) + temp_ad7
            divg_d_ad(i, j) = divg_d_ad(i, j) - temp_ad7
            vc_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
        CALL POPCONTROL1B_FV(branch)
        IF (branch .NE. 0) CALL FILL_CORNERS_ADM(divg_d, divg_d_ad, npx&
&                                          , npy, fill=xdir, bgrid=&
&                                          .true.)
      END DO
      CALL POPINTEGER(is)
      CALL POPINTEGER(ie)
      CALL POPREALARRAY(delpc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                  )/8)
      DO j=js,je+1
        DO i=ie+1,is,-1
          divg_d_ad(i, j) = divg_d_ad(i, j) + delpc_ad(i, j)
          delpc_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
  END SUBROUTINE COMPUTE_DIV_DAMPING_BWD
!  Differentiation of del6_vt_flux in reverse (adjoint) mode (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod.a2b_ord4_f
!b a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core
!_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_
!update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.rayleigh_super
! fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to_latlon fv_
!grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energy fv_mapz_m
!od.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mod.map1_q2_
!fb fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv_tracer2d_m
!od.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver_c nh_core_
!mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core_mod.sim_so
!lver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest
! sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.compute_d
!iv_damping_fb sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mod.copy_corn
!ers_fb tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_mod.fyppm
! tp_core_mod.deln_flux)):
!   gradient     of useful results: q fy2 d2 fx2
!   with respect to varying inputs: q fy2 d2 fx2
  SUBROUTINE DEL6_VT_FLUX_ADM(nord, npx, npy, damp, q, q_ad, d2, d2_ad, &
&   fx2, fx2_ad, fy2, fy2_ad, gridstruct, bd)
    IMPLICIT NONE
! Del-nord damping for the relative vorticity
! nord must be <= 2
!------------------
! nord = 0:   del-2
! nord = 1:   del-4
! nord = 2:   del-6
!------------------
    INTEGER, INTENT(IN) :: nord, npx, npy
    REAL(fvprc), INTENT(IN) :: damp
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! rel. vorticity ghosted on input
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: q_ad(bd%isd:bd%ied, bd%jsd:bd%jed)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
! Work arrays:
    REAL(fvprc) :: d2(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: d2_ad(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: fx2(bd%isd:bd%ied+1, bd%jsd:bd%jed), fy2(bd%isd:bd%&
&   ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: fx2_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed), fy2_ad(bd%isd&
&   :bd%ied, bd%jsd:bd%jed+1)
    INTEGER :: i, j, nt, n, i1, i2, j1, j2
    LOGICAL :: nested
!  real(FVPRC), pointer, dimension(:,:) :: rarea
!  real(FVPRC), pointer, dimension(:,:,:) :: sin_sg
!  real(FVPRC), pointer, dimension(:,:)   :: sina_u, sina_v
!  real(FVPRC), pointer, dimension(:,:) ::  rdxc, rdyc, dx,dy
    INTEGER :: is, ie, js, je
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    INTEGER :: ad_from
    INTEGER :: ad_to
    INTEGER :: ad_from0
    INTEGER :: ad_to0
    INTEGER :: ad_from1
    INTEGER :: ad_to1
    INTEGER :: ad_from2
    INTEGER :: ad_to2
    INTEGER :: ad_from3
    INTEGER :: ad_to3
    INTEGER :: ad_from4
    INTEGER :: ad_to4
    INTEGER :: branch
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
!   rarea    => gridstruct%rarea 
!   sin_sg   => gridstruct%sin_sg
!   sina_u   => gridstruct%sina_u
!   sina_v   => gridstruct%sina_v
!   rdxc     => gridstruct%rdxc  
!   rdyc     => gridstruct%rdyc  
!   dx       => gridstruct%dx    
!   dy       => gridstruct%dy    
    nested = gridstruct%nested
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    i1 = is - 1 - nord
    i2 = ie + 1 + nord
    j1 = js - 1 - nord
    j2 = je + 1 + nord
    IF (nord .GT. 0) THEN
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (nord .GT. 0) THEN
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (nord .GT. 0) THEN
      DO n=1,nord
        nt = nord - n
        ad_from0 = js - nt - 1
        DO j=ad_from0,je+nt+1
          ad_from = is - nt - 1
          i = ie + nt + 2
          CALL PUSHINTEGER4(i - 1)
          CALL PUSHINTEGER4(ad_from)
        END DO
        CALL PUSHINTEGER4(j - 1)
        CALL PUSHINTEGER4(ad_from0)
        ad_from2 = js - nt
        DO j=ad_from2,je+nt
          ad_from1 = is - nt
          i = ie + nt + 2
          CALL PUSHINTEGER4(i - 1)
          CALL PUSHINTEGER4(ad_from1)
        END DO
        CALL PUSHINTEGER4(j - 1)
        CALL PUSHINTEGER4(ad_from2)
        ad_from4 = js - nt
        DO j=ad_from4,je+nt+1
          ad_from3 = is - nt
          i = ie + nt + 1
          CALL PUSHINTEGER4(i - 1)
          CALL PUSHINTEGER4(ad_from3)
        END DO
        CALL PUSHINTEGER4(j - 1)
        CALL PUSHINTEGER4(ad_from4)
      END DO
      DO n=nord,1,-1
        CALL POPINTEGER4(ad_from4)
        CALL POPINTEGER4(ad_to4)
        DO j=ad_to4,ad_from4,-1
          CALL POPINTEGER4(ad_from3)
          CALL POPINTEGER4(ad_to3)
          DO i=ad_to3,ad_from3,-1
            temp_ad3 = gridstruct%dx(i, j)*0.5*gridstruct%rdyc(i, j)*(&
&             gridstruct%sin_sg(i, j-1, 4)+gridstruct%sin_sg(i, j, 2))*&
&             fy2_ad(i, j)
            d2_ad(i, j) = d2_ad(i, j) + temp_ad3
            d2_ad(i, j-1) = d2_ad(i, j-1) - temp_ad3
            fy2_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
        CALL COPY_CORNERS_ADM(d2, d2_ad, npx, npy, 2, nested, bd, &
&                       sw_corner, se_corner, nw_corner, ne_corner)
        CALL POPINTEGER4(ad_from2)
        CALL POPINTEGER4(ad_to2)
        DO j=ad_to2,ad_from2,-1
          CALL POPINTEGER4(ad_from1)
          CALL POPINTEGER4(ad_to1)
          DO i=ad_to1,ad_from1,-1
            temp_ad2 = gridstruct%dy(i, j)*0.5*gridstruct%rdxc(i, j)*(&
&             gridstruct%sin_sg(i-1, j, 3)+gridstruct%sin_sg(i, j, 1))*&
&             fx2_ad(i, j)
            d2_ad(i, j) = d2_ad(i, j) + temp_ad2
            d2_ad(i-1, j) = d2_ad(i-1, j) - temp_ad2
            fx2_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
        CALL COPY_CORNERS_ADM(d2, d2_ad, npx, npy, 1, nested, bd, &
&                       sw_corner, se_corner, nw_corner, ne_corner)
        CALL POPINTEGER4(ad_from0)
        CALL POPINTEGER4(ad_to0)
        DO j=ad_to0,ad_from0,-1
          CALL POPINTEGER4(ad_from)
          CALL POPINTEGER4(ad_to)
          DO i=ad_to,ad_from,-1
            temp_ad1 = gridstruct%rarea(i, j)*d2_ad(i, j)
            fx2_ad(i, j) = fx2_ad(i, j) + temp_ad1
            fx2_ad(i+1, j) = fx2_ad(i+1, j) - temp_ad1
            fy2_ad(i, j) = fy2_ad(i, j) + temp_ad1
            fy2_ad(i, j+1) = fy2_ad(i, j+1) - temp_ad1
            d2_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
      END DO
    END IF
    DO j=je+nord+1,js-nord,-1
      DO i=ie+nord,is-nord,-1
        temp_ad0 = gridstruct%dx(i, j)*0.5*gridstruct%rdyc(i, j)*(&
&         gridstruct%sin_sg(i, j-1, 4)+gridstruct%sin_sg(i, j, 2))*&
&         fy2_ad(i, j)
        d2_ad(i, j-1) = d2_ad(i, j-1) + temp_ad0
        d2_ad(i, j) = d2_ad(i, j) - temp_ad0
        fy2_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) CALL COPY_CORNERS_ADM(d2, d2_ad, npx, npy, 2, &
&                                      nested, bd, sw_corner, se_corner&
&                                      , nw_corner, ne_corner)
    DO j=je+nord,js-nord,-1
      DO i=ie+nord+1,is-nord,-1
        temp_ad = gridstruct%dy(i, j)*0.5*gridstruct%rdxc(i, j)*(&
&         gridstruct%sin_sg(i-1, j, 3)+gridstruct%sin_sg(i, j, 1))*&
&         fx2_ad(i, j)
        d2_ad(i-1, j) = d2_ad(i-1, j) + temp_ad
        d2_ad(i, j) = d2_ad(i, j) - temp_ad
        fx2_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) CALL COPY_CORNERS_ADM(d2, d2_ad, npx, npy, 1, &
&                                      nested, bd, sw_corner, se_corner&
&                                      , nw_corner, ne_corner)
    DO j=j2,j1,-1
      DO i=i2,i1,-1
        q_ad(i, j) = q_ad(i, j) + damp*d2_ad(i, j)
        d2_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
  END SUBROUTINE DEL6_VT_FLUX_ADM
  SUBROUTINE DEL6_VT_FLUX(nord, npx, npy, damp, q, d2, fx2, fy2, &
&   gridstruct, bd)
    IMPLICIT NONE
! Del-nord damping for the relative vorticity
! nord must be <= 2
!------------------
! nord = 0:   del-2
! nord = 1:   del-4
! nord = 2:   del-6
!------------------
    INTEGER, INTENT(IN) :: nord, npx, npy
    REAL(fvprc), INTENT(IN) :: damp
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! rel. vorticity ghosted on input
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
! Work arrays:
    REAL(fvprc), INTENT(OUT) :: d2(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(OUT) :: fx2(bd%isd:bd%ied+1, bd%jsd:bd%jed), fy2&
&   (bd%isd:bd%ied, bd%jsd:bd%jed+1)
    INTEGER :: i, j, nt, n, i1, i2, j1, j2
    LOGICAL :: nested
!  real(FVPRC), pointer, dimension(:,:) :: rarea
!  real(FVPRC), pointer, dimension(:,:,:) :: sin_sg
!  real(FVPRC), pointer, dimension(:,:)   :: sina_u, sina_v
!  real(FVPRC), pointer, dimension(:,:) ::  rdxc, rdyc, dx,dy
    INTEGER :: is, ie, js, je
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
!   rarea    => gridstruct%rarea 
!   sin_sg   => gridstruct%sin_sg
!   sina_u   => gridstruct%sina_u
!   sina_v   => gridstruct%sina_v
!   rdxc     => gridstruct%rdxc  
!   rdyc     => gridstruct%rdyc  
!   dx       => gridstruct%dx    
!   dy       => gridstruct%dy    
    nested = gridstruct%nested
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    i1 = is - 1 - nord
    i2 = ie + 1 + nord
    j1 = js - 1 - nord
    j2 = je + 1 + nord
    DO j=j1,j2
      DO i=i1,i2
        d2(i, j) = damp*q(i, j)
      END DO
    END DO
    IF (nord .GT. 0) CALL COPY_CORNERS(d2, npx, npy, 1, nested, bd, &
&                                sw_corner, se_corner, nw_corner, &
&                                ne_corner)
    DO j=js-nord,je+nord
      DO i=is-nord,ie+nord+1
!        fx2(i,j) = gridstruct%dy(i,j)*gridstruct%sina_u(i,j)*(d2(i-1,j)-d2(i,j))*gridstruct%rdxc(i,j)
        fx2(i, j) = 0.5*(gridstruct%sin_sg(i-1, j, 3)+gridstruct%sin_sg(&
&         i, j, 1))*gridstruct%dy(i, j)*(d2(i-1, j)-d2(i, j))*gridstruct&
&         %rdxc(i, j)
      END DO
    END DO
    IF (nord .GT. 0) CALL COPY_CORNERS(d2, npx, npy, 2, nested, bd, &
&                                sw_corner, se_corner, nw_corner, &
&                                ne_corner)
    DO j=js-nord,je+nord+1
      DO i=is-nord,ie+nord
!        fy2(i,j) = gridstruct%dx(i,j)*gridstruct%sina_v(i,j)*(d2(i,j-1)-d2(i,j))*gridstruct%rdyc(i,j)
        fy2(i, j) = 0.5*(gridstruct%sin_sg(i, j-1, 4)+gridstruct%sin_sg(&
&         i, j, 2))*gridstruct%dx(i, j)*(d2(i, j-1)-d2(i, j))*gridstruct&
&         %rdyc(i, j)
      END DO
    END DO
    IF (nord .GT. 0) THEN
      DO n=1,nord
        nt = nord - n
        DO j=js-nt-1,je+nt+1
          DO i=is-nt-1,ie+nt+1
            d2(i, j) = (fx2(i, j)-fx2(i+1, j)+fy2(i, j)-fy2(i, j+1))*&
&             gridstruct%rarea(i, j)
          END DO
        END DO
        CALL COPY_CORNERS(d2, npx, npy, 1, nested, bd, sw_corner, &
&                   se_corner, nw_corner, ne_corner)
        DO j=js-nt,je+nt
          DO i=is-nt,ie+nt+1
!           fx2(i,j) = gridstruct%dy(i,j)*gridstruct%sina_u(i,j)*(d2(i,j)-d2(i-1,j))*gridstruct%rdxc(i,j)
            fx2(i, j) = 0.5*(gridstruct%sin_sg(i-1, j, 3)+gridstruct%&
&             sin_sg(i, j, 1))*gridstruct%dy(i, j)*(d2(i, j)-d2(i-1, j))&
&             *gridstruct%rdxc(i, j)
          END DO
        END DO
        CALL COPY_CORNERS(d2, npx, npy, 2, nested, bd, sw_corner, &
&                   se_corner, nw_corner, ne_corner)
        DO j=js-nt,je+nt+1
          DO i=is-nt,ie+nt
!           fy2(i,j) = gridstruct%dx(i,j)*gridstruct%sina_v(i,j)*(d2(i,j)-d2(i,j-1))*gridstruct%rdyc(i,j)
            fy2(i, j) = 0.5*(gridstruct%sin_sg(i, j-1, 4)+gridstruct%&
&             sin_sg(i, j, 2))*gridstruct%dx(i, j)*(d2(i, j)-d2(i, j-1))&
&             *gridstruct%rdyc(i, j)
          END DO
        END DO
      END DO
    END IF
  END SUBROUTINE DEL6_VT_FLUX
!  Differentiation of divergence_corner in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b
!_edge_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_
!mod.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p d
!yn_core_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamic
!s_mod.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod
!.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_to
!tal_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer 
!fv_mapz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.
!steepz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.ri
!em_solver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solve
!r nh_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.di
!vergence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners s
!w_core_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d t
!p_core_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm 
!tp_core_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: u v ua va divg_d
!   with respect to varying inputs: u v ua va divg_d
  SUBROUTINE DIVERGENCE_CORNER_FWD(u, v, ua, va, divg_d, gridstruct, &
&   flagstruct, bd)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(IN) &
&   :: u
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(IN) &
&   :: v
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1) :: divg_d
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
! local
    REAL(fvprc) :: uf(bd%is-2:bd%ie+2, bd%js-1:bd%je+2)
    REAL(fvprc) :: vf(bd%is-1:bd%ie+2, bd%js-2:bd%je+2)
    INTEGER :: i, j
    INTEGER :: is2, ie1
!  real(FVPRC), pointer, dimension(:,:) :: rarea_c
!  real(FVPRC), pointer, dimension(:,:,:) :: sin_sg, cos_sg
!  real(FVPRC), pointer, dimension(:,:)   :: cosa_u, cosa_v
!  real(FVPRC), pointer, dimension(:,:)   :: sina_u, sina_v
!  real(FVPRC), pointer, dimension(:,:) ::  dxc,dyc
    INTEGER :: is, ie, js, je
    INTEGER :: npx, npy
    LOGICAL :: nested
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    INTRINSIC MAX
    INTRINSIC MIN
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    npx = flagstruct%npx
    npy = flagstruct%npy
    nested = gridstruct%nested
!      rarea_c    => gridstruct%rarea_c
!      sin_sg     => gridstruct%sin_sg 
!      cos_sg     => gridstruct%cos_sg 
!      cosa_u     => gridstruct%cosa_u 
!      cosa_v     => gridstruct%cosa_v 
!      sina_u     => gridstruct%sina_u 
!      sina_v     => gridstruct%sina_v 
!      dxc        => gridstruct%dxc    
!      dyc        => gridstruct%dyc    
    IF (nested) THEN
      CALL PUSHCONTROL1B_FV(0)
      is2 = is
      ie1 = ie + 1
    ELSE
      IF (2 .LT. is) THEN
        is2 = is
      ELSE
        is2 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        CALL PUSHCONTROL1B_FV(1)
        ie1 = ie + 1
      ELSE
        CALL PUSHCONTROL1B_FV(1)
        ie1 = npx - 1
      END IF
    END IF
    IF (flagstruct%grid_type .EQ. 4) THEN
      DO j=js-1,je+2
        DO i=is-2,ie+2
          uf(i, j) = u(i, j)*gridstruct%dyc(i, j)
        END DO
      END DO
      DO j=js-2,je+2
        DO i=is-1,ie+2
          vf(i, j) = v(i, j)*gridstruct%dxc(i, j)
        END DO
      END DO
      DO j=js-1,je+2
        DO i=is-1,ie+2
          divg_d(i, j) = gridstruct%rarea_c(i, j)*(vf(i, j-1)-vf(i, j)+&
&           uf(i-1, j)-uf(i, j))
        END DO
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
!#ifdef USE_UPWIND
!    do j=js,je+1
!!!! TO DO: separate versions for nested and for cubed-sphere
!       if ( (j==1 .or. j==npy)  .and. .not. nested ) then
!            do i=is-1,ie+1
!               if ( va(i,j) + va(i,j-1) > 0. ) then 
!                   uf(i,j) = u(i,j)*gridstruct%dyc(i,j) * gridstruct%sin_sg(i,j-1,4)
!               else
!                   uf(i,j) = u(i,j)*gridstruct%dyc(i,j) * gridstruct%sin_sg(i,j,2)
!               end if
!            enddo
!       else
!            do i=is-1,ie+1
!               uf(i,j) = (u(i,j)-0.5*(va(i,j-1)+va(i,j))*gridstruct%cosa_v(i,j))   &
!                        *gridstruct%dyc(i,j)*gridstruct%sina_v(i,j)
!            enddo
!       endif
!    enddo
!
!    do j=js-1,je+1
!       do i=is2,ie1
!          vf(i,j) = (v(i,j) - 0.5*(ua(i-1,j)+ua(i,j))*gridstruct%cosa_u(i,j))  &
!                    *gridstruct%dxc(i,j)*gridstruct%sina_u(i,j)
!       enddo
!       if (  is == 1 .and. .not. nested) then
!          if (ua(1,j) + ua(0,j) > 0.) then
!             vf(1,j) = v(1,j)*gridstruct%dxc(1,j)*gridstruct%sin_sg(0,j,3)
!          else
!             vf(1,j) = v(1,j)*gridstruct%dxc(1,j)*gridstruct%sin_sg(1,j,1)
!          end if
!       end if
!       if ( (ie+1)==npx .and. .not. nested ) then
!          if (ua(npx-1,j) + ua(npx,j) > 0.) then
!             vf(npx,j) = v(npx,j)*gridstruct%dxc(npx,j)*gridstruct%sin_sg(npx-1,j,3)
!          else
!             vf(npx,j) = v(npx,j)*gridstruct%dxc(npx,j)*gridstruct%sin_sg(npx,j,1)
!          end if
!       end if
!    enddo
!#else
!     9---4---8
!     |       |
!     1   5   3
!     |       |
!     6---2---7
      DO j=js,je+1
        IF (j .EQ. 1 .OR. j .EQ. npy) THEN
          DO i=is-1,ie+1
            uf(i, j) = u(i, j)*gridstruct%dyc(i, j)*0.5*(gridstruct%&
&             sin_sg(i, j-1, 4)+gridstruct%sin_sg(i, j, 2))
          END DO
          CALL PUSHCONTROL1B_FV(1)
        ELSE
          DO i=is-1,ie+1
            uf(i, j) = (u(i, j)-0.25*(va(i, j-1)+va(i, j))*(gridstruct%&
&             cos_sg(i, j-1, 4)+gridstruct%cos_sg(i, j, 2)))*gridstruct%&
&             dyc(i, j)*0.5*(gridstruct%sin_sg(i, j-1, 4)+gridstruct%&
&             sin_sg(i, j, 2))
          END DO
          CALL PUSHCONTROL1B_FV(0)
        END IF
      END DO
      DO j=js-1,je+1
        DO i=is2,ie1
          vf(i, j) = (v(i, j)-0.25*(ua(i-1, j)+ua(i, j))*(gridstruct%&
&           cos_sg(i-1, j, 3)+gridstruct%cos_sg(i, j, 1)))*gridstruct%&
&           dxc(i, j)*0.5*(gridstruct%sin_sg(i-1, j, 3)+gridstruct%&
&           sin_sg(i, j, 1))
        END DO
        IF (is .EQ. 1) THEN
          vf(1, j) = v(1, j)*gridstruct%dxc(1, j)*0.5*(gridstruct%sin_sg&
&           (0, j, 3)+gridstruct%sin_sg(1, j, 1))
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
        IF (ie + 1 .EQ. npx) THEN
          vf(npx, j) = v(npx, j)*gridstruct%dxc(npx, j)*0.5*(gridstruct%&
&           sin_sg(npx-1, j, 3)+gridstruct%sin_sg(npx, j, 1))
          CALL PUSHCONTROL1B_FV(1)
        ELSE
          CALL PUSHCONTROL1B_FV(0)
        END IF
      END DO
!#endif
      DO j=js,je+1
        DO i=is,ie+1
          divg_d(i, j) = vf(i, j-1) - vf(i, j) + uf(i-1, j) - uf(i, j)
        END DO
      END DO
! Remove the extra term at the corners:
      IF (sw_corner) THEN
        divg_d(1, 1) = divg_d(1, 1) - vf(1, 0)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (se_corner) THEN
        divg_d(npx, 1) = divg_d(npx, 1) - vf(npx, 0)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (ne_corner) THEN
        divg_d(npx, npy) = divg_d(npx, npy) + vf(npx, npy)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (nw_corner) THEN
        divg_d(1, npy) = divg_d(1, npy) + vf(1, npy)
        CALL PUSHCONTROL1B_FV(1)
      ELSE
        CALL PUSHCONTROL1B_FV(0)
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          divg_d(i, j) = gridstruct%rarea_c(i, j)*divg_d(i, j)
        END DO
      END DO
      CALL PUSHINTEGER(js)
      CALL PUSHINTEGER(npx)
      CALL PUSHINTEGER(npy)
      CALL PUSHINTEGER(is2)
      CALL PUSHINTEGER(is)
      CALL PUSHINTEGER(ie1)
      CALL PUSHCONTROL1B_FV(1)
    END IF
  END SUBROUTINE DIVERGENCE_CORNER_FWD
!  Differentiation of divergence_corner in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2
!b_edge_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core
!_mod.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p 
!dyn_core_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynami
!cs_mod.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mo
!d.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_t
!otal_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer
! fv_mapz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod
!.steepz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.r
!iem_solver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solv
!er nh_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.d
!ivergence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners 
!sw_core_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d 
!tp_core_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm
! tp_core_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: u v ua va divg_d
!   with respect to varying inputs: u v ua va divg_d
  SUBROUTINE DIVERGENCE_CORNER_BWD(u, u_ad, v, v_ad, ua, ua_ad, va, &
&   va_ad, divg_d, divg_d_ad, gridstruct, flagstruct, bd)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(IN) &
&   :: u
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1) :: u_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(IN) &
&   :: v
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed) :: v_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ua_ad, va_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1) :: divg_d
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1) :: &
&   divg_d_ad
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
    REAL(fvprc) :: uf(bd%is-2:bd%ie+2, bd%js-1:bd%je+2)
    REAL(fvprc) :: uf_ad(bd%is-2:bd%ie+2, bd%js-1:bd%je+2)
    REAL(fvprc) :: vf(bd%is-1:bd%ie+2, bd%js-2:bd%je+2)
    REAL(fvprc) :: vf_ad(bd%is-1:bd%ie+2, bd%js-2:bd%je+2)
    INTEGER :: i, j
    INTEGER :: is2, ie1
    INTEGER :: is, ie, js, je
    INTEGER :: npx, npy
    LOGICAL :: nested
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    INTEGER :: branch
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      uf_ad = 0.0_FVPRC
      vf_ad = 0.0_FVPRC
      DO j=je+2,js-1,-1
        DO i=ie+2,is-1,-1
          temp_ad = gridstruct%rarea_c(i, j)*divg_d_ad(i, j)
          vf_ad(i, j-1) = vf_ad(i, j-1) + temp_ad
          vf_ad(i, j) = vf_ad(i, j) - temp_ad
          uf_ad(i-1, j) = uf_ad(i-1, j) + temp_ad
          uf_ad(i, j) = uf_ad(i, j) - temp_ad
          divg_d_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      DO j=je+2,js-2,-1
        DO i=ie+2,is-1,-1
          v_ad(i, j) = v_ad(i, j) + gridstruct%dxc(i, j)*vf_ad(i, j)
          vf_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      DO j=je+2,js-1,-1
        DO i=ie+2,is-2,-1
          u_ad(i, j) = u_ad(i, j) + gridstruct%dyc(i, j)*uf_ad(i, j)
          uf_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
    ELSE
      CALL POPINTEGER(ie1)
      CALL POPINTEGER(is)
      CALL POPINTEGER(is2)
      CALL POPINTEGER(npy)
      CALL POPINTEGER(npx)
      CALL POPINTEGER(js)
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          divg_d_ad(i, j) = gridstruct%rarea_c(i, j)*divg_d_ad(i, j)
        END DO
      END DO
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        vf_ad = 0.0_FVPRC
      ELSE
        npy = flagstruct%npy
        vf_ad = 0.0_FVPRC
        vf_ad(1, npy) = vf_ad(1, npy) + divg_d_ad(1, npy)
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        npx = flagstruct%npx
        vf_ad(npx, npy) = vf_ad(npx, npy) + divg_d_ad(npx, npy)
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) vf_ad(npx, 0) = vf_ad(npx, 0) - divg_d_ad(npx, &
&         1)
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) vf_ad(1, 0) = vf_ad(1, 0) - divg_d_ad(1, 1)
      uf_ad = 0.0_FVPRC
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          vf_ad(i, j-1) = vf_ad(i, j-1) + divg_d_ad(i, j)
          vf_ad(i, j) = vf_ad(i, j) - divg_d_ad(i, j)
          uf_ad(i-1, j) = uf_ad(i-1, j) + divg_d_ad(i, j)
          uf_ad(i, j) = uf_ad(i, j) - divg_d_ad(i, j)
          divg_d_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      DO j=je+1,js-1,-1
        CALL POPCONTROL1B_FV(branch)
        IF (branch .NE. 0) THEN
          v_ad(npx, j) = v_ad(npx, j) + gridstruct%dxc(npx, j)*(&
&           gridstruct%sin_sg(npx-1, j, 3)+gridstruct%sin_sg(npx, j, 1))&
&           *0.5*vf_ad(npx, j)
          vf_ad(npx, j) = 0.0_FVPRC
        END IF
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          v_ad(1, j) = v_ad(1, j) + gridstruct%dxc(1, j)*(gridstruct%&
&           sin_sg(0, j, 3)+gridstruct%sin_sg(1, j, 1))*0.5*vf_ad(1, j)
          vf_ad(1, j) = 0.0_FVPRC
        END IF
        DO i=ie1,is2,-1
          temp_ad2 = gridstruct%dxc(i, j)*0.5*(gridstruct%sin_sg(i-1, j&
&           , 3)+gridstruct%sin_sg(i, j, 1))*vf_ad(i, j)
          temp_ad3 = -((gridstruct%cos_sg(i-1, j, 3)+gridstruct%cos_sg(i&
&           , j, 1))*0.25*temp_ad2)
          v_ad(i, j) = v_ad(i, j) + temp_ad2
          ua_ad(i-1, j) = ua_ad(i-1, j) + temp_ad3
          ua_ad(i, j) = ua_ad(i, j) + temp_ad3
          vf_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      DO j=je+1,js,-1
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          DO i=ie+1,is-1,-1
            temp_ad0 = gridstruct%dyc(i, j)*0.5*(gridstruct%sin_sg(i, j-&
&             1, 4)+gridstruct%sin_sg(i, j, 2))*uf_ad(i, j)
            temp_ad1 = -((gridstruct%cos_sg(i, j-1, 4)+gridstruct%cos_sg&
&             (i, j, 2))*0.25*temp_ad0)
            u_ad(i, j) = u_ad(i, j) + temp_ad0
            va_ad(i, j-1) = va_ad(i, j-1) + temp_ad1
            va_ad(i, j) = va_ad(i, j) + temp_ad1
            uf_ad(i, j) = 0.0_FVPRC
          END DO
        ELSE
          DO i=ie+1,is-1,-1
            u_ad(i, j) = u_ad(i, j) + gridstruct%dyc(i, j)*(gridstruct%&
&             sin_sg(i, j-1, 4)+gridstruct%sin_sg(i, j, 2))*0.5*uf_ad(i&
&             , j)
            uf_ad(i, j) = 0.0_FVPRC
          END DO
        END IF
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
  END SUBROUTINE DIVERGENCE_CORNER_BWD
  SUBROUTINE DIVERGENCE_CORNER(u, v, ua, va, divg_d, gridstruct, &
&   flagstruct, bd)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(IN) &
&   :: u
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(IN) &
&   :: v
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(OUT&
&   ) :: divg_d
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
! local
    REAL(fvprc) :: uf(bd%is-2:bd%ie+2, bd%js-1:bd%je+2)
    REAL(fvprc) :: vf(bd%is-1:bd%ie+2, bd%js-2:bd%je+2)
    INTEGER :: i, j
    INTEGER :: is2, ie1
!  real(FVPRC), pointer, dimension(:,:) :: rarea_c
!  real(FVPRC), pointer, dimension(:,:,:) :: sin_sg, cos_sg
!  real(FVPRC), pointer, dimension(:,:)   :: cosa_u, cosa_v
!  real(FVPRC), pointer, dimension(:,:)   :: sina_u, sina_v
!  real(FVPRC), pointer, dimension(:,:) ::  dxc,dyc
    INTEGER :: is, ie, js, je
    INTEGER :: npx, npy
    LOGICAL :: nested
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    INTRINSIC MAX
    INTRINSIC MIN
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    npx = flagstruct%npx
    npy = flagstruct%npy
    nested = gridstruct%nested
!      rarea_c    => gridstruct%rarea_c
!      sin_sg     => gridstruct%sin_sg 
!      cos_sg     => gridstruct%cos_sg 
!      cosa_u     => gridstruct%cosa_u 
!      cosa_v     => gridstruct%cosa_v 
!      sina_u     => gridstruct%sina_u 
!      sina_v     => gridstruct%sina_v 
!      dxc        => gridstruct%dxc    
!      dyc        => gridstruct%dyc    
    IF (nested) THEN
      is2 = is
      ie1 = ie + 1
    ELSE
      IF (2 .LT. is) THEN
        is2 = is
      ELSE
        is2 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        ie1 = ie + 1
      ELSE
        ie1 = npx - 1
      END IF
    END IF
    IF (flagstruct%grid_type .EQ. 4) THEN
      DO j=js-1,je+2
        DO i=is-2,ie+2
          uf(i, j) = u(i, j)*gridstruct%dyc(i, j)
        END DO
      END DO
      DO j=js-2,je+2
        DO i=is-1,ie+2
          vf(i, j) = v(i, j)*gridstruct%dxc(i, j)
        END DO
      END DO
      DO j=js-1,je+2
        DO i=is-1,ie+2
          divg_d(i, j) = gridstruct%rarea_c(i, j)*(vf(i, j-1)-vf(i, j)+&
&           uf(i-1, j)-uf(i, j))
        END DO
      END DO
    ELSE
!#ifdef USE_UPWIND
!    do j=js,je+1
!!!! TO DO: separate versions for nested and for cubed-sphere
!       if ( (j==1 .or. j==npy)  .and. .not. nested ) then
!            do i=is-1,ie+1
!               if ( va(i,j) + va(i,j-1) > 0. ) then 
!                   uf(i,j) = u(i,j)*gridstruct%dyc(i,j) * gridstruct%sin_sg(i,j-1,4)
!               else
!                   uf(i,j) = u(i,j)*gridstruct%dyc(i,j) * gridstruct%sin_sg(i,j,2)
!               end if
!            enddo
!       else
!            do i=is-1,ie+1
!               uf(i,j) = (u(i,j)-0.5*(va(i,j-1)+va(i,j))*gridstruct%cosa_v(i,j))   &
!                        *gridstruct%dyc(i,j)*gridstruct%sina_v(i,j)
!            enddo
!       endif
!    enddo
!
!    do j=js-1,je+1
!       do i=is2,ie1
!          vf(i,j) = (v(i,j) - 0.5*(ua(i-1,j)+ua(i,j))*gridstruct%cosa_u(i,j))  &
!                    *gridstruct%dxc(i,j)*gridstruct%sina_u(i,j)
!       enddo
!       if (  is == 1 .and. .not. nested) then
!          if (ua(1,j) + ua(0,j) > 0.) then
!             vf(1,j) = v(1,j)*gridstruct%dxc(1,j)*gridstruct%sin_sg(0,j,3)
!          else
!             vf(1,j) = v(1,j)*gridstruct%dxc(1,j)*gridstruct%sin_sg(1,j,1)
!          end if
!       end if
!       if ( (ie+1)==npx .and. .not. nested ) then
!          if (ua(npx-1,j) + ua(npx,j) > 0.) then
!             vf(npx,j) = v(npx,j)*gridstruct%dxc(npx,j)*gridstruct%sin_sg(npx-1,j,3)
!          else
!             vf(npx,j) = v(npx,j)*gridstruct%dxc(npx,j)*gridstruct%sin_sg(npx,j,1)
!          end if
!       end if
!    enddo
!#else
!     9---4---8
!     |       |
!     1   5   3
!     |       |
!     6---2---7
      DO j=js,je+1
        IF (j .EQ. 1 .OR. j .EQ. npy) THEN
          DO i=is-1,ie+1
            uf(i, j) = u(i, j)*gridstruct%dyc(i, j)*0.5*(gridstruct%&
&             sin_sg(i, j-1, 4)+gridstruct%sin_sg(i, j, 2))
          END DO
        ELSE
          DO i=is-1,ie+1
            uf(i, j) = (u(i, j)-0.25*(va(i, j-1)+va(i, j))*(gridstruct%&
&             cos_sg(i, j-1, 4)+gridstruct%cos_sg(i, j, 2)))*gridstruct%&
&             dyc(i, j)*0.5*(gridstruct%sin_sg(i, j-1, 4)+gridstruct%&
&             sin_sg(i, j, 2))
          END DO
        END IF
      END DO
      DO j=js-1,je+1
        DO i=is2,ie1
          vf(i, j) = (v(i, j)-0.25*(ua(i-1, j)+ua(i, j))*(gridstruct%&
&           cos_sg(i-1, j, 3)+gridstruct%cos_sg(i, j, 1)))*gridstruct%&
&           dxc(i, j)*0.5*(gridstruct%sin_sg(i-1, j, 3)+gridstruct%&
&           sin_sg(i, j, 1))
        END DO
        IF (is .EQ. 1) vf(1, j) = v(1, j)*gridstruct%dxc(1, j)*0.5*(&
&           gridstruct%sin_sg(0, j, 3)+gridstruct%sin_sg(1, j, 1))
        IF (ie + 1 .EQ. npx) vf(npx, j) = v(npx, j)*gridstruct%dxc(npx, &
&           j)*0.5*(gridstruct%sin_sg(npx-1, j, 3)+gridstruct%sin_sg(npx&
&           , j, 1))
      END DO
!#endif
      DO j=js,je+1
        DO i=is,ie+1
          divg_d(i, j) = vf(i, j-1) - vf(i, j) + uf(i-1, j) - uf(i, j)
        END DO
      END DO
! Remove the extra term at the corners:
      IF (sw_corner) divg_d(1, 1) = divg_d(1, 1) - vf(1, 0)
      IF (se_corner) divg_d(npx, 1) = divg_d(npx, 1) - vf(npx, 0)
      IF (ne_corner) divg_d(npx, npy) = divg_d(npx, npy) + vf(npx, npy)
      IF (nw_corner) divg_d(1, npy) = divg_d(1, npy) + vf(1, npy)
      DO j=js,je+1
        DO i=is,ie+1
          divg_d(i, j) = gridstruct%rarea_c(i, j)*divg_d(i, j)
        END DO
      END DO
    END IF
  END SUBROUTINE DIVERGENCE_CORNER
!  Differentiation of divergence_corner_nest in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord
!2 a2b_edge_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_
!core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_gra
!d_p dyn_core_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dy
!namics_mod.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_util
!s_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compu
!te_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_trace
!r_fb fv_mapz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz
!_mod.steepz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_m
!od.riem_solver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_
!solver nh_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_m
!od.divergence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corn
!ers sw_core_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d
!_fb tp_core_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxpp
!m_fb tp_core_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: u v ua va divg_d
!   with respect to varying inputs: u v ua va
  SUBROUTINE DIVERGENCE_CORNER_NEST_FWD(u, v, ua, va, divg_d, gridstruct&
&   , flagstruct, bd)
    IMPLICIT NONE
!!$       !Edges
!!$
!!$       !West, East
!!$       do j=jsd+1,jed
!!$          divg_d(isd  ,j) = (vf(isd,j-1) - vf(isd,j) + uf(isd,j) - uf(isd+1,j))*gridstruct%rarea_c(isd,j)
!!$          divg_d(ied+1,j) = (vf(ied+1,j-1) - vf(ied+1,j) + uf(ied-1,j) - uf(ied,j))*gridstruct%rarea_c(ied,j)
!!$       end do
!!$
!!$       !North, South
!!$       do i=isd+1,ied
!!$          divg_d(i,jsd  ) = (vf(i,jsd) - vf(i,jsd+1) + uf(i-1,jsd) - uf(i,jsd))*gridstruct%rarea_c(i,jsd)
!!$          divg_d(i,jed+1) = (vf(i,jed-1) - vf(i,jed) + uf(i-1,jed+1) - uf(i,jed+1))*gridstruct%rarea_c(i,jed)
!!$       end do
!!$
!!$       !Corners (just use next corner value)
!!$       divg_d(isd,jsd)   = divg_d(isd+1,jsd+1)
!!$       divg_d(isd,jed+1) = divg_d(isd+1,jed)
!!$       divg_d(ied+1,jsd)   = divg_d(ied,jsd+1)
!!$       divg_d(ied+1,jed+1) = divg_d(ied,jed)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(IN) &
&   :: u
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(IN) &
&   :: v
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1) :: divg_d
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
! local
    REAL(fvprc) :: uf(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: vf(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    INTEGER :: i, j
!  real(FVPRC), pointer, dimension(:,:) :: rarea_c
!  real(FVPRC), pointer, dimension(:,:,:) :: sin_sg, cos_sg
!  real(FVPRC), pointer, dimension(:,:)   :: cosa_u, cosa_v
!  real(FVPRC), pointer, dimension(:,:)   :: sina_u, sina_v
!  real(FVPRC), pointer, dimension(:,:) ::  dxc,dyc
    INTEGER :: isd, ied, jsd, jed
    INTEGER :: npx, npy
    LOGICAL :: nested
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
!      rarea_c    => gridstruct%rarea_c
!      sin_sg     => gridstruct%sin_sg 
!      cos_sg     => gridstruct%cos_sg 
!      cosa_u     => gridstruct%cosa_u 
!      cosa_v     => gridstruct%cosa_v 
!      sina_u     => gridstruct%sina_u 
!      sina_v     => gridstruct%sina_v 
!      dxc        => gridstruct%dxc    
!      dyc        => gridstruct%dyc    
    divg_d = 1.e25
    IF (flagstruct%grid_type .EQ. 4) THEN
      DO j=jsd,jed
        DO i=isd,ied
          uf(i, j) = u(i, j)*gridstruct%dyc(i, j)
        END DO
      END DO
      DO j=jsd,jed
        DO i=isd,ied
          vf(i, j) = v(i, j)*gridstruct%dxc(i, j)
        END DO
      END DO
      DO j=jsd+1,jed
        DO i=isd+1,ied
          divg_d(i, j) = gridstruct%rarea_c(i, j)*(vf(i, j-1)-vf(i, j)+&
&           uf(i-1, j)-uf(i, j))
        END DO
      END DO
      CALL PUSHINTEGER(jsd)
      CALL PUSHINTEGER(ied)
      CALL PUSHINTEGER(isd)
      CALL PUSHINTEGER(jed)
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      DO j=jsd+1,jed
        DO i=isd,ied
          uf(i, j) = (u(i, j)-0.25*(va(i, j-1)+va(i, j))*(gridstruct%&
&           cos_sg(i, j-1, 4)+gridstruct%cos_sg(i, j, 2)))*gridstruct%&
&           dyc(i, j)*0.5*(gridstruct%sin_sg(i, j-1, 4)+gridstruct%&
&           sin_sg(i, j, 2))
        END DO
      END DO
      DO j=jsd,jed
        DO i=isd+1,ied
          vf(i, j) = (v(i, j)-0.25*(ua(i-1, j)+ua(i, j))*(gridstruct%&
&           cos_sg(i-1, j, 3)+gridstruct%cos_sg(i, j, 1)))*gridstruct%&
&           dxc(i, j)*0.5*(gridstruct%sin_sg(i-1, j, 3)+gridstruct%&
&           sin_sg(i, j, 1))
        END DO
      END DO
      DO j=jsd+1,jed
        DO i=isd+1,ied
          divg_d(i, j) = (vf(i, j-1)-vf(i, j)+uf(i-1, j)-uf(i, j))*&
&           gridstruct%rarea_c(i, j)
        END DO
      END DO
      CALL PUSHINTEGER(jsd)
      CALL PUSHINTEGER(ied)
      CALL PUSHINTEGER(isd)
      CALL PUSHINTEGER(jed)
      CALL PUSHCONTROL1B_FV(1)
    END IF
  END SUBROUTINE DIVERGENCE_CORNER_NEST_FWD
!  Differentiation of divergence_corner_nest in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_or
!d2 a2b_edge_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn
!_core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_gr
!ad_p dyn_core_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_d
!ynamics_mod.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_uti
!ls_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.comp
!ute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_trac
!er_fb fv_mapz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_map
!z_mod.steepz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_
!mod.riem_solver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1
!_solver nh_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_
!mod.divergence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4cor
!ners sw_core_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2
!d_fb tp_core_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxp
!pm_fb tp_core_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: u v ua va divg_d
!   with respect to varying inputs: u v ua va
  SUBROUTINE DIVERGENCE_CORNER_NEST_BWD(u, u_ad, v, v_ad, ua, ua_ad, va&
&   , va_ad, divg_d, divg_d_ad, gridstruct, flagstruct, bd)
    IMPLICIT NONE
!!$       !Edges
!!$
!!$       !West, East
!!$       do j=jsd+1,jed
!!$          divg_d(isd  ,j) = (vf(isd,j-1) - vf(isd,j) + uf(isd,j) - uf(isd+1,j))*gridstruct%rarea_c(isd,j)
!!$          divg_d(ied+1,j) = (vf(ied+1,j-1) - vf(ied+1,j) + uf(ied-1,j) - uf(ied,j))*gridstruct%rarea_c(ied,j)
!!$       end do
!!$
!!$       !North, South
!!$       do i=isd+1,ied
!!$          divg_d(i,jsd  ) = (vf(i,jsd) - vf(i,jsd+1) + uf(i-1,jsd) - uf(i,jsd))*gridstruct%rarea_c(i,jsd)
!!$          divg_d(i,jed+1) = (vf(i,jed-1) - vf(i,jed) + uf(i-1,jed+1) - uf(i,jed+1))*gridstruct%rarea_c(i,jed)
!!$       end do
!!$
!!$       !Corners (just use next corner value)
!!$       divg_d(isd,jsd)   = divg_d(isd+1,jsd+1)
!!$       divg_d(isd,jed+1) = divg_d(isd+1,jed)
!!$       divg_d(ied+1,jsd)   = divg_d(ied,jsd+1)
!!$       divg_d(ied+1,jed+1) = divg_d(ied,jed)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(IN) &
&   :: u
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1) :: u_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(IN) &
&   :: v
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed) :: v_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ua_ad, va_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1) :: divg_d
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1) :: &
&   divg_d_ad
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
    REAL(fvprc) :: uf(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: uf_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: vf(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: vf_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    INTEGER :: i, j
    INTEGER :: isd, ied, jsd, jed
    INTEGER :: npx, npy
    LOGICAL :: nested
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp_ad4
    INTEGER :: branch
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPINTEGER(jed)
      CALL POPINTEGER(isd)
      CALL POPINTEGER(ied)
      CALL POPINTEGER(jsd)
      uf_ad = 0.0_FVPRC
      vf_ad = 0.0_FVPRC
      DO j=jed,jsd+1,-1
        DO i=ied,isd+1,-1
          temp_ad = gridstruct%rarea_c(i, j)*divg_d_ad(i, j)
          vf_ad(i, j-1) = vf_ad(i, j-1) + temp_ad
          vf_ad(i, j) = vf_ad(i, j) - temp_ad
          uf_ad(i-1, j) = uf_ad(i-1, j) + temp_ad
          uf_ad(i, j) = uf_ad(i, j) - temp_ad
          divg_d_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      DO j=jed,jsd,-1
        DO i=ied,isd,-1
          v_ad(i, j) = v_ad(i, j) + gridstruct%dxc(i, j)*vf_ad(i, j)
          vf_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      DO j=jed,jsd,-1
        DO i=ied,isd,-1
          u_ad(i, j) = u_ad(i, j) + gridstruct%dyc(i, j)*uf_ad(i, j)
          uf_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
    ELSE
      CALL POPINTEGER(jed)
      CALL POPINTEGER(isd)
      CALL POPINTEGER(ied)
      CALL POPINTEGER(jsd)
      uf_ad = 0.0_FVPRC
      vf_ad = 0.0_FVPRC
      DO j=jed,jsd+1,-1
        DO i=ied,isd+1,-1
          temp_ad4 = gridstruct%rarea_c(i, j)*divg_d_ad(i, j)
          vf_ad(i, j-1) = vf_ad(i, j-1) + temp_ad4
          vf_ad(i, j) = vf_ad(i, j) - temp_ad4
          uf_ad(i-1, j) = uf_ad(i-1, j) + temp_ad4
          uf_ad(i, j) = uf_ad(i, j) - temp_ad4
          divg_d_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      DO j=jed,jsd,-1
        DO i=ied,isd+1,-1
          temp_ad2 = gridstruct%dxc(i, j)*0.5*(gridstruct%sin_sg(i-1, j&
&           , 3)+gridstruct%sin_sg(i, j, 1))*vf_ad(i, j)
          temp_ad3 = -((gridstruct%cos_sg(i-1, j, 3)+gridstruct%cos_sg(i&
&           , j, 1))*0.25*temp_ad2)
          v_ad(i, j) = v_ad(i, j) + temp_ad2
          ua_ad(i-1, j) = ua_ad(i-1, j) + temp_ad3
          ua_ad(i, j) = ua_ad(i, j) + temp_ad3
          vf_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      DO j=jed,jsd+1,-1
        DO i=ied,isd,-1
          temp_ad0 = gridstruct%dyc(i, j)*0.5*(gridstruct%sin_sg(i, j-1&
&           , 4)+gridstruct%sin_sg(i, j, 2))*uf_ad(i, j)
          temp_ad1 = -((gridstruct%cos_sg(i, j-1, 4)+gridstruct%cos_sg(i&
&           , j, 2))*0.25*temp_ad0)
          u_ad(i, j) = u_ad(i, j) + temp_ad0
          va_ad(i, j-1) = va_ad(i, j-1) + temp_ad1
          va_ad(i, j) = va_ad(i, j) + temp_ad1
          uf_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
    END IF
  END SUBROUTINE DIVERGENCE_CORNER_NEST_BWD
  SUBROUTINE DIVERGENCE_CORNER_NEST(u, v, ua, va, divg_d, gridstruct, &
&   flagstruct, bd)
    IMPLICIT NONE
!!$       !Edges
!!$
!!$       !West, East
!!$       do j=jsd+1,jed
!!$          divg_d(isd  ,j) = (vf(isd,j-1) - vf(isd,j) + uf(isd,j) - uf(isd+1,j))*gridstruct%rarea_c(isd,j)
!!$          divg_d(ied+1,j) = (vf(ied+1,j-1) - vf(ied+1,j) + uf(ied-1,j) - uf(ied,j))*gridstruct%rarea_c(ied,j)
!!$       end do
!!$
!!$       !North, South
!!$       do i=isd+1,ied
!!$          divg_d(i,jsd  ) = (vf(i,jsd) - vf(i,jsd+1) + uf(i-1,jsd) - uf(i,jsd))*gridstruct%rarea_c(i,jsd)
!!$          divg_d(i,jed+1) = (vf(i,jed-1) - vf(i,jed) + uf(i-1,jed+1) - uf(i,jed+1))*gridstruct%rarea_c(i,jed)
!!$       end do
!!$
!!$       !Corners (just use next corner value)
!!$       divg_d(isd,jsd)   = divg_d(isd+1,jsd+1)
!!$       divg_d(isd,jed+1) = divg_d(isd+1,jed)
!!$       divg_d(ied+1,jsd)   = divg_d(ied,jsd+1)
!!$       divg_d(ied+1,jed+1) = divg_d(ied,jed)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(IN) &
&   :: u
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(IN) &
&   :: v
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed+1), INTENT(OUT&
&   ) :: divg_d
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
! local
    REAL(fvprc) :: uf(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: vf(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    INTEGER :: i, j
!  real(FVPRC), pointer, dimension(:,:) :: rarea_c
!  real(FVPRC), pointer, dimension(:,:,:) :: sin_sg, cos_sg
!  real(FVPRC), pointer, dimension(:,:)   :: cosa_u, cosa_v
!  real(FVPRC), pointer, dimension(:,:)   :: sina_u, sina_v
!  real(FVPRC), pointer, dimension(:,:) ::  dxc,dyc
    INTEGER :: isd, ied, jsd, jed
    INTEGER :: npx, npy
    LOGICAL :: nested
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    npx = flagstruct%npx
    npy = flagstruct%npy
    nested = gridstruct%nested
!      rarea_c    => gridstruct%rarea_c
!      sin_sg     => gridstruct%sin_sg 
!      cos_sg     => gridstruct%cos_sg 
!      cosa_u     => gridstruct%cosa_u 
!      cosa_v     => gridstruct%cosa_v 
!      sina_u     => gridstruct%sina_u 
!      sina_v     => gridstruct%sina_v 
!      dxc        => gridstruct%dxc    
!      dyc        => gridstruct%dyc    
    divg_d = 1.e25
    IF (flagstruct%grid_type .EQ. 4) THEN
      DO j=jsd,jed
        DO i=isd,ied
          uf(i, j) = u(i, j)*gridstruct%dyc(i, j)
        END DO
      END DO
      DO j=jsd,jed
        DO i=isd,ied
          vf(i, j) = v(i, j)*gridstruct%dxc(i, j)
        END DO
      END DO
      DO j=jsd+1,jed
        DO i=isd+1,ied
          divg_d(i, j) = gridstruct%rarea_c(i, j)*(vf(i, j-1)-vf(i, j)+&
&           uf(i-1, j)-uf(i, j))
        END DO
      END DO
    ELSE
      DO j=jsd+1,jed
        DO i=isd,ied
          uf(i, j) = (u(i, j)-0.25*(va(i, j-1)+va(i, j))*(gridstruct%&
&           cos_sg(i, j-1, 4)+gridstruct%cos_sg(i, j, 2)))*gridstruct%&
&           dyc(i, j)*0.5*(gridstruct%sin_sg(i, j-1, 4)+gridstruct%&
&           sin_sg(i, j, 2))
        END DO
      END DO
      DO j=jsd,jed
        DO i=isd+1,ied
          vf(i, j) = (v(i, j)-0.25*(ua(i-1, j)+ua(i, j))*(gridstruct%&
&           cos_sg(i-1, j, 3)+gridstruct%cos_sg(i, j, 1)))*gridstruct%&
&           dxc(i, j)*0.5*(gridstruct%sin_sg(i-1, j, 3)+gridstruct%&
&           sin_sg(i, j, 1))
        END DO
      END DO
      DO j=jsd+1,jed
        DO i=isd+1,ied
          divg_d(i, j) = (vf(i, j-1)-vf(i, j)+uf(i-1, j)-uf(i, j))*&
&           gridstruct%rarea_c(i, j)
        END DO
      END DO
    END IF
  END SUBROUTINE DIVERGENCE_CORNER_NEST
!  Differentiation of smag_corner in reverse (adjoint) mode (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod.a2b_ord4
! a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_
!mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_u
!pdate dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.rayleigh_super 
!fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to_latlon fv_g
!rid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energy fv_mapz_mo
!d.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mod.map1_q2_f
!b fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv_tracer2d_mo
!d.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver_c nh_core_m
!od.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core_mod.sim_sol
!ver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest 
!sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.compute_di
!v_damping_fb sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mod.copy_corne
!rs_fb tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_mod.fyppm 
!tp_core_mod.deln_flux)):
!   gradient     of useful results: smag_c u v
!   with respect to varying inputs: u v
  SUBROUTINE SMAG_CORNER_ADM(dt, u, u_ad, v, v_ad, ua, va, smag_c, &
&   smag_c_ad, bd, npx, npy, gridstruct, ng)
    IMPLICIT NONE
! Compute the Tension_Shear strain at cell corners for Smagorinsky diffusion
!!!  work only if (grid_type==4)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: dt
    INTEGER, INTENT(IN) :: npx, npy, ng
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(IN) &
&   :: u
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1) :: u_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(IN) &
&   :: v
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed) :: v_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: smag_c
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: smag_c_ad
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
! local
    REAL(fvprc) :: ut(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: ut_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: vt(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: vt_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1)
!  work array
    REAL(fvprc) :: wk(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk_ad(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: sh(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: sh_ad(bd%isd:bd%ied, bd%jsd:bd%jed)
    INTEGER :: i, j
    INTEGER :: is2, ie1
! real(FVPRC), pointer, dimension(:,:) :: dxc, dyc, dx, dy, rarea, rarea_c
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC SQRT
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
! Smag = sqrt [ T**2 + S**2 ]:  unit = 1/s
! where T = du/dx - dv/dy;   S = du/dy + dv/dx
! Compute tension strain at corners:
    DO j=js,je+1
      DO i=is-1,ie+1
        ut(i, j) = u(i, j)*gridstruct%dyc(i, j)
      END DO
    END DO
    DO j=js-1,je+1
      DO i=is,ie+1
        vt(i, j) = v(i, j)*gridstruct%dxc(i, j)
      END DO
    END DO
    DO j=js,je+1
      DO i=is,ie+1
        smag_c(i, j) = gridstruct%rarea_c(i, j)*(vt(i, j-1)-vt(i, j)-ut(&
&         i-1, j)+ut(i, j))
      END DO
    END DO
! Fix the corners?? if grid_type /= 4
! Compute shear strain:
    DO j=jsd,jed+1
      DO i=isd,ied
        vt(i, j) = u(i, j)*gridstruct%dx(i, j)
      END DO
    END DO
    DO j=jsd,jed
      DO i=isd,ied+1
        ut(i, j) = v(i, j)*gridstruct%dy(i, j)
      END DO
    END DO
    DO j=jsd,jed
      DO i=isd,ied
        wk(i, j) = gridstruct%rarea(i, j)*(vt(i, j)-vt(i, j+1)+ut(i, j)-&
&         ut(i+1, j))
      END DO
    END DO
    CALL A2B_ORD4(wk, sh, gridstruct, npx, npy, is, ie, js, je, ng, &
&           .false.)
    sh_ad = 0.0_FVPRC
    DO j=js,je+1
      DO i=ie+1,is,-1
        IF (sh(i, j)**2 + smag_c(i, j)**2 .EQ. 0.0_FVPRC) THEN
          temp_ad1 = 0.0
        ELSE
          temp_ad1 = dt*smag_c_ad(i, j)/(2.0*SQRT(sh(i, j)**2+smag_c(i, &
&           j)**2))
        END IF
        sh_ad(i, j) = sh_ad(i, j) + 2*sh(i, j)*temp_ad1
        smag_c_ad(i, j) = 2*smag_c(i, j)*temp_ad1
      END DO
    END DO
    wk_ad = 0.0_FVPRC
    CALL A2B_ORD4_ADM(wk, wk_ad, sh, sh_ad, gridstruct, npx, npy, is, ie&
&               , js, je, ng, .false.)
    ut_ad = 0.0_FVPRC
    vt_ad = 0.0_FVPRC
    DO j=jed,jsd,-1
      DO i=ied,isd,-1
        temp_ad0 = gridstruct%rarea(i, j)*wk_ad(i, j)
        vt_ad(i, j) = vt_ad(i, j) + temp_ad0
        vt_ad(i, j+1) = vt_ad(i, j+1) - temp_ad0
        ut_ad(i, j) = ut_ad(i, j) + temp_ad0
        ut_ad(i+1, j) = ut_ad(i+1, j) - temp_ad0
        wk_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    DO j=jed,jsd,-1
      DO i=ied+1,isd,-1
        v_ad(i, j) = v_ad(i, j) + gridstruct%dy(i, j)*ut_ad(i, j)
        ut_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    DO j=jed+1,jsd,-1
      DO i=ied,isd,-1
        u_ad(i, j) = u_ad(i, j) + gridstruct%dx(i, j)*vt_ad(i, j)
        vt_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    DO j=je+1,js,-1
      DO i=ie+1,is,-1
        temp_ad = gridstruct%rarea_c(i, j)*smag_c_ad(i, j)
        vt_ad(i, j-1) = vt_ad(i, j-1) + temp_ad
        vt_ad(i, j) = vt_ad(i, j) - temp_ad
        ut_ad(i, j) = ut_ad(i, j) + temp_ad
        ut_ad(i-1, j) = ut_ad(i-1, j) - temp_ad
        smag_c_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    DO j=je+1,js-1,-1
      DO i=ie+1,is,-1
        v_ad(i, j) = v_ad(i, j) + gridstruct%dxc(i, j)*vt_ad(i, j)
        vt_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    DO j=je+1,js,-1
      DO i=ie+1,is-1,-1
        u_ad(i, j) = u_ad(i, j) + gridstruct%dyc(i, j)*ut_ad(i, j)
        ut_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
  END SUBROUTINE SMAG_CORNER_ADM
  SUBROUTINE SMAG_CORNER(dt, u, v, ua, va, smag_c, bd, npx, npy, &
&   gridstruct, ng)
    IMPLICIT NONE
! Compute the Tension_Shear strain at cell corners for Smagorinsky diffusion
!!!  work only if (grid_type==4)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: dt
    INTEGER, INTENT(IN) :: npx, npy, ng
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(IN) &
&   :: u
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(IN) &
&   :: v
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(OUT) ::&
&   smag_c
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
! local
    REAL(fvprc) :: ut(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: vt(bd%isd:bd%ied, bd%jsd:bd%jed+1)
!  work array
    REAL(fvprc) :: wk(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: sh(bd%isd:bd%ied, bd%jsd:bd%jed)
    INTEGER :: i, j
    INTEGER :: is2, ie1
! real(FVPRC), pointer, dimension(:,:) :: dxc, dyc, dx, dy, rarea, rarea_c
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC SQRT
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    IF (2 .LT. is) THEN
      is2 = is
    ELSE
      is2 = 2
    END IF
    IF (npx - 1 .GT. ie + 1) THEN
      ie1 = ie + 1
    ELSE
      ie1 = npx - 1
    END IF
! Smag = sqrt [ T**2 + S**2 ]:  unit = 1/s
! where T = du/dx - dv/dy;   S = du/dy + dv/dx
! Compute tension strain at corners:
    DO j=js,je+1
      DO i=is-1,ie+1
        ut(i, j) = u(i, j)*gridstruct%dyc(i, j)
      END DO
    END DO
    DO j=js-1,je+1
      DO i=is,ie+1
        vt(i, j) = v(i, j)*gridstruct%dxc(i, j)
      END DO
    END DO
    DO j=js,je+1
      DO i=is,ie+1
        smag_c(i, j) = gridstruct%rarea_c(i, j)*(vt(i, j-1)-vt(i, j)-ut(&
&         i-1, j)+ut(i, j))
      END DO
    END DO
! Fix the corners?? if grid_type /= 4
! Compute shear strain:
    DO j=jsd,jed+1
      DO i=isd,ied
        vt(i, j) = u(i, j)*gridstruct%dx(i, j)
      END DO
    END DO
    DO j=jsd,jed
      DO i=isd,ied+1
        ut(i, j) = v(i, j)*gridstruct%dy(i, j)
      END DO
    END DO
    DO j=jsd,jed
      DO i=isd,ied
        wk(i, j) = gridstruct%rarea(i, j)*(vt(i, j)-vt(i, j+1)+ut(i, j)-&
&         ut(i+1, j))
      END DO
    END DO
    CALL A2B_ORD4(wk, sh, gridstruct, npx, npy, is, ie, js, je, ng, &
&           .false.)
    DO j=js,je+1
      DO i=is,ie+1
        smag_c(i, j) = dt*SQRT(sh(i, j)**2+smag_c(i, j)**2)
      END DO
    END DO
  END SUBROUTINE SMAG_CORNER
!  Differentiation of smag_corner in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_ed
!ge_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod
!.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_
!core_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_m
!od.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cu
!bed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total
!_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_
!mapz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.ste
!epz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_
!solver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver n
!h_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.diver
!gence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_c
!ore_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_c
!ore_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_
!core_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: smag_c u v
!   with respect to varying inputs: u v
  SUBROUTINE SMAG_CORNER_FWD(dt, u, v, ua, va, smag_c, bd, npx, npy, &
&   gridstruct, ng)
    IMPLICIT NONE
! Compute the Tension_Shear strain at cell corners for Smagorinsky diffusion
!!!  work only if (grid_type==4)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: dt
    INTEGER, INTENT(IN) :: npx, npy, ng
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(IN) &
&   :: u
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(IN) &
&   :: v
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: smag_c
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
! local
    REAL(fvprc) :: ut(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: vt(bd%isd:bd%ied, bd%jsd:bd%jed+1)
!  work array
    REAL(fvprc) :: wk(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: sh(bd%isd:bd%ied, bd%jsd:bd%jed)
    INTEGER :: i, j
    INTEGER :: is2, ie1
! real(FVPRC), pointer, dimension(:,:) :: dxc, dyc, dx, dy, rarea, rarea_c
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC SQRT
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
! Smag = sqrt [ T**2 + S**2 ]:  unit = 1/s
! where T = du/dx - dv/dy;   S = du/dy + dv/dx
! Compute tension strain at corners:
    DO j=js,je+1
      DO i=is-1,ie+1
        ut(i, j) = u(i, j)*gridstruct%dyc(i, j)
      END DO
    END DO
    DO j=js-1,je+1
      DO i=is,ie+1
        vt(i, j) = v(i, j)*gridstruct%dxc(i, j)
      END DO
    END DO
    DO j=js,je+1
      DO i=is,ie+1
        smag_c(i, j) = gridstruct%rarea_c(i, j)*(vt(i, j-1)-vt(i, j)-ut(&
&         i-1, j)+ut(i, j))
      END DO
    END DO
! Fix the corners?? if grid_type /= 4
! Compute shear strain:
    DO j=jsd,jed+1
      DO i=isd,ied
        vt(i, j) = u(i, j)*gridstruct%dx(i, j)
      END DO
    END DO
    DO j=jsd,jed
      DO i=isd,ied+1
        ut(i, j) = v(i, j)*gridstruct%dy(i, j)
      END DO
    END DO
    DO j=jsd,jed
      DO i=isd,ied
        wk(i, j) = gridstruct%rarea(i, j)*(vt(i, j)-vt(i, j+1)+ut(i, j)-&
&         ut(i+1, j))
      END DO
    END DO
    CALL A2B_ORD4_FWD(wk, sh, gridstruct, npx, npy, is, ie, js, je, &
&                  ng, .false.)
    CALL PUSHREALARRAY(smag_c, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                 )/8)
    DO j=js,je+1
      DO i=is,ie+1
        smag_c(i, j) = dt*SQRT(sh(i, j)**2+smag_c(i, j)**2)
      END DO
    END DO
    CALL PUSHINTEGER(js)
    CALL PUSHREALARRAY(sh, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8)
    CALL PUSHINTEGER(is)
  END SUBROUTINE SMAG_CORNER_FWD
!  Differentiation of smag_corner in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_e
!dge_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mo
!d.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn
!_core_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_
!mod.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.c
!ubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_tota
!l_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv
!_mapz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.st
!eepz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem
!_solver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver 
!nh_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.dive
!rgence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_
!core_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_
!core_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp
!_core_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: smag_c u v
!   with respect to varying inputs: u v
  SUBROUTINE SMAG_CORNER_BWD(dt, u, u_ad, v, v_ad, ua, va, smag_c, &
&   smag_c_ad, bd, npx, npy, gridstruct, ng)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: dt
    INTEGER, INTENT(IN) :: npx, npy, ng
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(IN) &
&   :: u
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1) :: u_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(IN) &
&   :: v
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed) :: v_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(IN) :: &
&   ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: smag_c
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: smag_c_ad
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    REAL(fvprc) :: ut(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: ut_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: vt(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: vt_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: wk(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk_ad(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: sh(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: sh_ad(bd%isd:bd%ied, bd%jsd:bd%jed)
    INTEGER :: i, j
    INTEGER :: is2, ie1
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC SQRT
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    CALL POPINTEGER(is)
    CALL POPREALARRAY(sh, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8)
    CALL POPINTEGER(js)
    sh_ad = 0.0_FVPRC
    CALL POPREALARRAY(smag_c, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                /8)
    DO j=js,je+1
      DO i=ie+1,is,-1
        IF (sh(i, j)**2 + smag_c(i, j)**2 .EQ. 0.0_FVPRC) THEN
          temp_ad1 = 0.0
        ELSE
          temp_ad1 = dt*smag_c_ad(i, j)/(2.0*SQRT(sh(i, j)**2+smag_c(i, &
&           j)**2))
        END IF
        sh_ad(i, j) = sh_ad(i, j) + 2*sh(i, j)*temp_ad1
        smag_c_ad(i, j) = 2*smag_c(i, j)*temp_ad1
      END DO
    END DO
    wk_ad = 0.0_FVPRC
    CALL A2B_ORD4_BWD(wk, wk_ad, sh, sh_ad, gridstruct, npx, npy, is&
&                  , ie, js, je, ng, .false.)
    jsd = bd%jsd
    ied = bd%ied
    isd = bd%isd
    jed = bd%jed
    ut_ad = 0.0_FVPRC
    vt_ad = 0.0_FVPRC
    DO j=jed,jsd,-1
      DO i=ied,isd,-1
        temp_ad0 = gridstruct%rarea(i, j)*wk_ad(i, j)
        vt_ad(i, j) = vt_ad(i, j) + temp_ad0
        vt_ad(i, j+1) = vt_ad(i, j+1) - temp_ad0
        ut_ad(i, j) = ut_ad(i, j) + temp_ad0
        ut_ad(i+1, j) = ut_ad(i+1, j) - temp_ad0
        wk_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    DO j=jed,jsd,-1
      DO i=ied+1,isd,-1
        v_ad(i, j) = v_ad(i, j) + gridstruct%dy(i, j)*ut_ad(i, j)
        ut_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    DO j=jed+1,jsd,-1
      DO i=ied,isd,-1
        u_ad(i, j) = u_ad(i, j) + gridstruct%dx(i, j)*vt_ad(i, j)
        vt_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    DO j=je+1,js,-1
      DO i=ie+1,is,-1
        temp_ad = gridstruct%rarea_c(i, j)*smag_c_ad(i, j)
        vt_ad(i, j-1) = vt_ad(i, j-1) + temp_ad
        vt_ad(i, j) = vt_ad(i, j) - temp_ad
        ut_ad(i, j) = ut_ad(i, j) + temp_ad
        ut_ad(i-1, j) = ut_ad(i-1, j) - temp_ad
        smag_c_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    DO j=je+1,js-1,-1
      DO i=ie+1,is,-1
        v_ad(i, j) = v_ad(i, j) + gridstruct%dxc(i, j)*vt_ad(i, j)
        vt_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    DO j=je+1,js,-1
      DO i=ie+1,is-1,-1
        u_ad(i, j) = u_ad(i, j) + gridstruct%dyc(i, j)*ut_ad(i, j)
        ut_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
  END SUBROUTINE SMAG_CORNER_BWD
!  Differentiation of xtp_u in reverse (adjoint) mode (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod.a2b_ord4 a2b_e
!dge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.ad
!v_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update 
!dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.rayleigh_super fv_dyn
!amics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to_latlon fv_grid_ut
!ils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energy fv_mapz_mod.pkez
! fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mod.map1_q2 fv_m
!apz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv_tracer2d_mod.trac
!er_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver_c nh_core_mod.rie
!m_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core_mod.sim_solver nh
!_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_cor
!e_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.compute_div_damp
!ing_fb sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mod.copy_corners 
!tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_mod.fyppm tp_cor
!e_mod.deln_flux)):
!   gradient     of useful results: flux u c
!   with respect to varying inputs: flux u c
  SUBROUTINE XTP_U_ADM(c, c_ad, u, u_ad, v, flux, flux_ad, iord, cosa, &
&   dx, rdx, bd, npx, npy, grid_type, nested)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: u_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(IN) :: c(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: c_ad(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: flux(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: flux_ad(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(IN) :: dx(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: rdx(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: cosa(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
    INTEGER, INTENT(IN) :: iord, npx, npy, grid_type
    LOGICAL, INTENT(IN) :: nested
! Local
    LOGICAL :: extm(bd%is-2:bd%ie+2)
    REAL(fvprc) :: al(bd%is-1:bd%ie+2), dm(bd%is-2:bd%ie+2)
    REAL(fvprc) :: al_ad(bd%is-1:bd%ie+2), dm_ad(bd%is-2:bd%ie+2)
    REAL(fvprc) :: bl(bd%is-1:bd%ie+1)
    REAL(fvprc) :: bl_ad(bd%is-1:bd%ie+1)
    REAL(fvprc) :: br(bd%is-1:bd%ie+1)
    REAL(fvprc) :: br_ad(bd%is-1:bd%ie+1)
    REAL(fvprc) :: dq(bd%is-3:bd%ie+2)
    REAL(fvprc) :: dq_ad(bd%is-3:bd%ie+2)
    REAL(fvprc) :: dl, dr, xt, pmp, lac, cfl
    REAL(fvprc) :: dl_ad, dr_ad, xt_ad, pmp_ad, lac_ad, cfl_ad
    REAL(fvprc) :: pmp_1, lac_1, pmp_2, lac_2
    REAL(fvprc) :: pmp_1_ad, lac_1_ad, pmp_2_ad, lac_2_ad
    REAL(fvprc) :: x0, x1, x0l, x0r
    REAL(fvprc) :: x0_ad, x1_ad, x0l_ad, x0r_ad
    INTEGER :: i, j
    INTEGER :: is3, ie3
    INTEGER :: is, ie, js, je
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC SIGN
    REAL(fvprc) :: min1
    REAL(fvprc) :: min1_ad
    REAL(fvprc) :: min2
    REAL(fvprc) :: min2_ad
    REAL(fvprc) :: min3
    REAL(fvprc) :: min3_ad
    REAL(fvprc) :: min4
    REAL(fvprc) :: min4_ad
    REAL(fvprc) :: min5
    REAL(fvprc) :: min5_ad
    REAL(fvprc) :: min6
    REAL(fvprc) :: min6_ad
    INTEGER :: max1
    REAL(fvprc) :: min7
    REAL(fvprc) :: min7_ad
    REAL(fvprc) :: min8
    REAL(fvprc) :: min8_ad
    REAL(fvprc) :: min9
    REAL(fvprc) :: min9_ad
    REAL(fvprc) :: min10
    REAL(fvprc) :: min10_ad
    REAL(fvprc) :: min11
    REAL(fvprc) :: min11_ad
    REAL(fvprc) :: min12
    REAL(fvprc) :: min12_ad
    REAL(fvprc) :: min13
    REAL(fvprc) :: min13_ad
    REAL(fvprc) :: abs0
    REAL(fvprc) :: abs1
    REAL(fvprc) :: abs2
    REAL(fvprc) :: max2
    REAL(fvprc) :: max2_ad
    REAL(fvprc) :: min14
    REAL(fvprc) :: min14_ad
    REAL(fvprc) :: max3
    REAL(fvprc) :: max3_ad
    REAL(fvprc) :: min15
    REAL(fvprc) :: min15_ad
    REAL(fvprc) :: max4
    REAL(fvprc) :: max4_ad
    REAL(fvprc) :: min16
    REAL(fvprc) :: min16_ad
    REAL(fvprc) :: max5
    REAL(fvprc) :: max5_ad
    REAL(fvprc) :: min17
    REAL(fvprc) :: min17_ad
    REAL(fvprc) :: max6
    REAL(fvprc) :: max6_ad
    REAL(fvprc) :: min18
    REAL(fvprc) :: min18_ad
    REAL(fvprc) :: max7
    REAL(fvprc) :: max7_ad
    REAL(fvprc) :: min19
    REAL(fvprc) :: min19_ad
    INTEGER :: min20
    REAL(fvprc) :: max8
    REAL(fvprc) :: max8_ad
    REAL(fvprc) :: min21
    REAL(fvprc) :: min21_ad
    REAL(fvprc) :: abs3
    REAL(fvprc) :: abs4
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp_ad4
    REAL(fvprc) :: temp_ad5
    REAL(fvprc) :: temp_ad6
    REAL(fvprc) :: temp_ad7
    REAL(fvprc) :: temp_ad8
    REAL(fvprc) :: x2_ad
    REAL(fvprc) :: y1_ad
    REAL(fvprc) :: z1_ad
    REAL(fvprc) :: temp_ad9
    REAL(fvprc) :: temp_ad10
    REAL(fvprc) :: x3_ad
    REAL(fvprc) :: y2_ad
    REAL(fvprc) :: z2_ad
    REAL(fvprc) :: x4_ad
    REAL(fvprc) :: y3_ad
    REAL(fvprc) :: z3_ad
    REAL(fvprc) :: temp_ad11
    REAL(fvprc) :: temp_ad12
    REAL(fvprc) :: x5_ad
    REAL(fvprc) :: y4_ad
    REAL(fvprc) :: z4_ad
    REAL(fvprc) :: x6_ad
    REAL(fvprc) :: y5_ad
    REAL(fvprc) :: z5_ad
    REAL(fvprc) :: x7_ad
    REAL(fvprc) :: y6_ad
    REAL(fvprc) :: z6_ad
    REAL(fvprc) :: temp_ad13
    REAL(fvprc) :: temp_ad14
    REAL(fvprc) :: temp_ad15
    REAL(fvprc) :: temp_ad16
    REAL(fvprc) :: x8_ad
    REAL(fvprc) :: y7_ad
    REAL(fvprc) :: x9_ad
    REAL(fvprc) :: y8_ad
    REAL(fvprc) :: temp_ad17
    REAL(fvprc) :: x10_ad
    REAL(fvprc) :: y9_ad
    REAL(fvprc) :: x11_ad
    REAL(fvprc) :: y10_ad
    REAL(fvprc) :: temp_ad18
    REAL(fvprc) :: temp_ad19
    REAL(fvprc) :: temp_ad20
    REAL(fvprc) :: temp_ad21
    REAL(fvprc) :: temp_ad22
    REAL(fvprc) :: temp
    REAL(fvprc) :: temp_ad23
    REAL(fvprc) :: temp_ad24
    REAL(fvprc) :: x12_ad
    REAL(fvprc) :: y11_ad
    REAL(fvprc) :: z7_ad
    REAL(fvprc) :: x13_ad
    REAL(fvprc) :: y12_ad
    REAL(fvprc) :: x14_ad
    REAL(fvprc) :: y13_ad
    REAL(fvprc) :: x15_ad
    REAL(fvprc) :: y20_ad
    REAL(fvprc) :: y14_ad
    REAL(fvprc) :: x16_ad
    REAL(fvprc) :: y21_ad
    REAL(fvprc) :: y15_ad
    REAL(fvprc) :: x17_ad
    REAL(fvprc) :: y22_ad
    REAL(fvprc) :: y16_ad
    REAL(fvprc) :: x18_ad
    REAL(fvprc) :: y23_ad
    REAL(fvprc) :: y17_ad
    REAL(fvprc) :: temp_ad25
    REAL(fvprc) :: temp_ad26
    REAL(fvprc) :: temp_ad27
    REAL(fvprc) :: temp_ad28
    REAL(fvprc) :: x19_ad
    REAL(fvprc) :: y24_ad
    REAL(fvprc) :: y18_ad
    REAL(fvprc) :: x20_ad
    REAL(fvprc) :: y25_ad
    REAL(fvprc) :: y19_ad
    REAL(fvprc) :: temp0
    REAL(fvprc) :: temp_ad29
    REAL(fvprc) :: temp_ad30
    INTEGER :: branch
    INTEGER :: ad_from
    INTEGER :: ad_to
    REAL(fvprc) :: x19
    REAL(fvprc) :: x18
    REAL(fvprc) :: x17
    REAL(fvprc) :: x16
    REAL(fvprc) :: x15
    REAL(fvprc) :: x14
    REAL(fvprc) :: x13
    REAL(fvprc) :: x12
    REAL(fvprc) :: x11
    REAL(fvprc) :: x10
    REAL(fvprc) :: y25
    REAL(fvprc) :: y24
    REAL(fvprc) :: y23
    REAL(fvprc) :: y22
    REAL(fvprc) :: y21
    REAL(fvprc) :: y20
    REAL(fvprc) :: x9
    REAL(fvprc) :: x8
    REAL(fvprc) :: x7
    REAL(fvprc) :: x6
    REAL(fvprc) :: x5
    REAL(fvprc) :: x4
    REAL(fvprc) :: x3
    REAL(fvprc) :: x2
    REAL(fvprc) :: y19
    REAL(fvprc) :: y18
    REAL(fvprc) :: y17
    REAL(fvprc) :: y16
    REAL(fvprc) :: y15
    REAL(fvprc) :: y14
    REAL(fvprc) :: y13
    REAL(fvprc) :: y12
    REAL(fvprc) :: y11
    REAL(fvprc) :: y10
    REAL(fvprc) :: z7
    REAL(fvprc) :: z6
    REAL(fvprc) :: z5
    REAL(fvprc) :: z4
    REAL(fvprc) :: z3
    REAL(fvprc) :: z2
    REAL(fvprc) :: z1
    REAL(fvprc) :: x20
    REAL(fvprc) :: y9
    REAL(fvprc) :: y8
    REAL(fvprc) :: y7
    REAL(fvprc) :: y6
    REAL(fvprc) :: y5
    REAL(fvprc) :: y4
    REAL(fvprc) :: y3
    REAL(fvprc) :: y2
    REAL(fvprc) :: y1
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    IF (nested .OR. grid_type .GT. 3) THEN
      CALL PUSHCONTROL1B(0)
      is3 = is - 1
      ie3 = ie + 1
    ELSE
      IF (3 .LT. is - 1) THEN
        is3 = is - 1
      ELSE
        is3 = 3
      END IF
      IF (npx - 3 .GT. ie + 1) THEN
        CALL PUSHCONTROL1B(1)
        ie3 = ie + 1
      ELSE
        CALL PUSHCONTROL1B(1)
        ie3 = npx - 3
      END IF
    END IF
    SELECT CASE  (iord) 
    CASE (1) 
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            u_ad(i, j) = u_ad(i, j) + flux_ad(i, j)
            flux_ad(i, j) = 0.0_FVPRC
          ELSE
            u_ad(i-1, j) = u_ad(i-1, j) + flux_ad(i, j)
            flux_ad(i, j) = 0.0_FVPRC
          END IF
        END DO
      END DO
    CASE (333) 
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            temp_ad4 = flux_ad(i, j)/6.0
            temp_ad5 = -(rdx(i, j)*0.5*flux_ad(i, j))
            temp_ad6 = c(i, j)*temp_ad5
            temp_ad7 = rdx(i, j)**2*flux_ad(i, j)
            temp_ad8 = c(i, j)**2*temp_ad7/6.0
            u_ad(i-1, j) = u_ad(i-1, j) + temp_ad8 - temp_ad6 + 2.0*&
&             temp_ad4
            u_ad(i, j) = u_ad(i, j) + temp_ad6 - 2.0*temp_ad8 + 5.0*&
&             temp_ad4
            u_ad(i+1, j) = u_ad(i+1, j) + temp_ad8 - temp_ad4
            c_ad(i, j) = c_ad(i, j) + (u(i+1, j)-2.0*u(i, j)+u(i-1, j))*&
&             2*c(i, j)*temp_ad7/6.0 + (u(i, j)-u(i-1, j))*temp_ad5
            flux_ad(i, j) = 0.0_FVPRC
          ELSE
            temp_ad = flux_ad(i, j)/6.0
            temp_ad0 = -(rdx(i-1, j)*0.5*flux_ad(i, j))
            temp_ad1 = c(i, j)*temp_ad0
            temp_ad2 = rdx(i-1, j)**2*flux_ad(i, j)
            temp_ad3 = c(i, j)**2*temp_ad2/6.0
            u_ad(i, j) = u_ad(i, j) + temp_ad3 + temp_ad1 + 2.0*temp_ad
            u_ad(i-1, j) = u_ad(i-1, j) + 5.0*temp_ad - temp_ad1 - 2.0*&
&             temp_ad3
            u_ad(i-2, j) = u_ad(i-2, j) + temp_ad3 - temp_ad
            c_ad(i, j) = c_ad(i, j) + (u(i, j)-2.0*u(i-1, j)+u(i-2, j))*&
&             2*c(i, j)*temp_ad2/6.0 + (u(i, j)-u(i-1, j))*temp_ad0
            flux_ad(i, j) = 0.0_FVPRC
          END IF
        END DO
      END DO
    CASE (2) 
      DO j=js,je+1
        DO i=is-2,ie+2
          xt = 0.25*(u(i+1, j)-u(i-1, j))
          IF (xt .GE. 0.) THEN
            x2 = xt
            CALL PUSHCONTROL1B(0)
          ELSE
            x2 = -xt
            CALL PUSHCONTROL1B(1)
          END IF
          IF (u(i-1, j) .LT. u(i, j)) THEN
            IF (u(i, j) .LT. u(i+1, j)) THEN
              max2 = u(i+1, j)
              CALL PUSHCONTROL2B(0)
            ELSE
              max2 = u(i, j)
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE IF (u(i-1, j) .LT. u(i+1, j)) THEN
            max2 = u(i+1, j)
            CALL PUSHCONTROL2B(2)
          ELSE
            max2 = u(i-1, j)
            CALL PUSHCONTROL2B(3)
          END IF
          y1 = max2 - u(i, j)
          IF (u(i-1, j) .GT. u(i, j)) THEN
            IF (u(i, j) .GT. u(i+1, j)) THEN
              min14 = u(i+1, j)
              CALL PUSHCONTROL2B(0)
            ELSE
              min14 = u(i, j)
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE IF (u(i-1, j) .GT. u(i+1, j)) THEN
            min14 = u(i+1, j)
            CALL PUSHCONTROL2B(2)
          ELSE
            min14 = u(i-1, j)
            CALL PUSHCONTROL2B(3)
          END IF
          z1 = u(i, j) - min14
          IF (x2 .GT. y1) THEN
            IF (y1 .GT. z1) THEN
              CALL PUSHREALARRAY_ADM(min1)
              min1 = z1
              CALL PUSHCONTROL2B(0)
            ELSE
              CALL PUSHREALARRAY_ADM(min1)
              min1 = y1
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE IF (x2 .GT. z1) THEN
            CALL PUSHREALARRAY_ADM(min1)
            min1 = z1
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHREALARRAY_ADM(min1)
            min1 = x2
            CALL PUSHCONTROL2B(3)
          END IF
          CALL PUSHREALARRAY_ADM(dm(i))
          dm(i) = SIGN(min1, xt)
        END DO
! Fix slopes near edges:
!!! TO DO: separate versions for nested and for cubed-sphere
        IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
          IF (is .EQ. 1) THEN
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
              CALL PUSHREALARRAY_ADM(dm(0))
              dm(0) = 0.
              CALL PUSHREALARRAY_ADM(dm(1))
              dm(1) = 0.
              CALL PUSHCONTROL2B(0)
            ELSE
              x0l = 0.5*((2.*dx(0, j)+dx(-1, j))*u(0, j)-dx(0, j)*u(-1, &
&               j))/(dx(0, j)+dx(-1, j))
              x0r = 0.5*((2.*dx(1, j)+dx(2, j))*u(1, j)-dx(1, j)*u(2, j)&
&               )/(dx(1, j)+dx(2, j))
              x0 = x0l + x0r
              x1 = s15*u(0, j) + s11*u(-1, j) + s14*dm(-1)
!          dm(0) = u(0,j) - x1
              CALL PUSHREALARRAY_ADM(dm(0))
              dm(0) = 0.5*(x0-x1)
              IF (dm(0) .GE. 0.) THEN
                x3 = dm(0)
                CALL PUSHCONTROL1B(0)
              ELSE
                x3 = -dm(0)
                CALL PUSHCONTROL1B(1)
              END IF
              IF (u(0, j) .LT. x0) THEN
                IF (x0 .LT. x1) THEN
                  max3 = x1
                  CALL PUSHCONTROL2B(0)
                ELSE
                  max3 = x0
                  CALL PUSHCONTROL2B(1)
                END IF
              ELSE IF (u(0, j) .LT. x1) THEN
                max3 = x1
                CALL PUSHCONTROL2B(2)
              ELSE
                max3 = u(0, j)
                CALL PUSHCONTROL2B(3)
              END IF
              y2 = max3 - u(0, j)
              IF (u(0, j) .GT. x0) THEN
                IF (x0 .GT. x1) THEN
                  min15 = x1
                  CALL PUSHCONTROL2B(0)
                ELSE
                  min15 = x0
                  CALL PUSHCONTROL2B(1)
                END IF
              ELSE IF (u(0, j) .GT. x1) THEN
                min15 = x1
                CALL PUSHCONTROL2B(2)
              ELSE
                min15 = u(0, j)
                CALL PUSHCONTROL2B(3)
              END IF
              z2 = u(0, j) - min15
              IF (x3 .GT. y2) THEN
                IF (y2 .GT. z2) THEN
                  CALL PUSHREALARRAY_ADM(min2)
                  min2 = z2
                  CALL PUSHCONTROL2B(0)
                ELSE
                  CALL PUSHREALARRAY_ADM(min2)
                  min2 = y2
                  CALL PUSHCONTROL2B(1)
                END IF
              ELSE IF (x3 .GT. z2) THEN
                CALL PUSHREALARRAY_ADM(min2)
                min2 = z2
                CALL PUSHCONTROL2B(2)
              ELSE
                CALL PUSHREALARRAY_ADM(min2)
                min2 = x3
                CALL PUSHCONTROL2B(3)
              END IF
              CALL PUSHREALARRAY_ADM(dm(0))
              dm(0) = SIGN(min2, dm(0))
              x1 = s15*u(1, j) + s11*u(2, j) - s14*dm(2)
!          dm(1) = x1 - u(1,j)
              CALL PUSHREALARRAY_ADM(dm(1))
              dm(1) = 0.5*(x1-x0)
              IF (dm(1) .GE. 0.) THEN
                x4 = dm(1)
                CALL PUSHCONTROL1B(0)
              ELSE
                x4 = -dm(1)
                CALL PUSHCONTROL1B(1)
              END IF
              IF (u(1, j) .LT. x0) THEN
                IF (x0 .LT. x1) THEN
                  max4 = x1
                  CALL PUSHCONTROL2B(0)
                ELSE
                  max4 = x0
                  CALL PUSHCONTROL2B(1)
                END IF
              ELSE IF (u(1, j) .LT. x1) THEN
                max4 = x1
                CALL PUSHCONTROL2B(2)
              ELSE
                max4 = u(1, j)
                CALL PUSHCONTROL2B(3)
              END IF
              y3 = max4 - u(1, j)
              IF (u(1, j) .GT. x0) THEN
                IF (x0 .GT. x1) THEN
                  min16 = x1
                  CALL PUSHCONTROL2B(0)
                ELSE
                  min16 = x0
                  CALL PUSHCONTROL2B(1)
                END IF
              ELSE IF (u(1, j) .GT. x1) THEN
                min16 = x1
                CALL PUSHCONTROL2B(2)
              ELSE
                min16 = u(1, j)
                CALL PUSHCONTROL2B(3)
              END IF
              z3 = u(1, j) - min16
              IF (x4 .GT. y3) THEN
                IF (y3 .GT. z3) THEN
                  CALL PUSHREALARRAY_ADM(min3)
                  min3 = z3
                  CALL PUSHCONTROL2B(0)
                ELSE
                  CALL PUSHREALARRAY_ADM(min3)
                  min3 = y3
                  CALL PUSHCONTROL2B(1)
                END IF
              ELSE IF (x4 .GT. z3) THEN
                CALL PUSHREALARRAY_ADM(min3)
                min3 = z3
                CALL PUSHCONTROL2B(2)
              ELSE
                CALL PUSHREALARRAY_ADM(min3)
                min3 = x4
                CALL PUSHCONTROL2B(3)
              END IF
              CALL PUSHREALARRAY_ADM(dm(1))
              dm(1) = SIGN(min3, dm(1))
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B(2)
          END IF
          IF (ie + 1 .EQ. npx) THEN
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
              CALL PUSHREALARRAY_ADM(dm(npx-1))
              dm(npx-1) = 0.
              CALL PUSHREALARRAY_ADM(dm(npx))
              dm(npx) = 0.
              CALL PUSHCONTROL2B(3)
            ELSE
              x0l = 0.5*((2.*dx(npx-1, j)+dx(npx-2, j))*u(npx-1, j)-dx(&
&               npx-1, j)*u(npx-2, j))/(dx(npx-1, j)+dx(npx-2, j))
              x0r = 0.5*((2.*dx(npx, j)+dx(npx+1, j))*u(npx, j)-dx(npx, &
&               j)*u(npx+1, j))/(dx(npx, j)+dx(npx+1, j))
              x0 = x0l + x0r
              x1 = s15*u(npx-1, j) + s11*u(npx-2, j) + s14*dm(npx-2)
!          dm(npx-1) = u(npx-1,j) - x1
              CALL PUSHREALARRAY_ADM(dm(npx-1))
              dm(npx-1) = 0.5*(x0-x1)
              IF (dm(npx-1) .GE. 0.) THEN
                x5 = dm(npx-1)
                CALL PUSHCONTROL1B(0)
              ELSE
                x5 = -dm(npx-1)
                CALL PUSHCONTROL1B(1)
              END IF
              IF (u(npx-1, j) .LT. x0) THEN
                IF (x0 .LT. x1) THEN
                  max5 = x1
                  CALL PUSHCONTROL2B(0)
                ELSE
                  max5 = x0
                  CALL PUSHCONTROL2B(1)
                END IF
              ELSE IF (u(npx-1, j) .LT. x1) THEN
                max5 = x1
                CALL PUSHCONTROL2B(2)
              ELSE
                max5 = u(npx-1, j)
                CALL PUSHCONTROL2B(3)
              END IF
              y4 = max5 - u(npx-1, j)
              IF (u(npx-1, j) .GT. x0) THEN
                IF (x0 .GT. x1) THEN
                  min17 = x1
                  CALL PUSHCONTROL2B(0)
                ELSE
                  min17 = x0
                  CALL PUSHCONTROL2B(1)
                END IF
              ELSE IF (u(npx-1, j) .GT. x1) THEN
                min17 = x1
                CALL PUSHCONTROL2B(2)
              ELSE
                min17 = u(npx-1, j)
                CALL PUSHCONTROL2B(3)
              END IF
              z4 = u(npx-1, j) - min17
              IF (x5 .GT. y4) THEN
                IF (y4 .GT. z4) THEN
                  CALL PUSHREALARRAY_ADM(min4)
                  min4 = z4
                  CALL PUSHCONTROL2B(0)
                ELSE
                  CALL PUSHREALARRAY_ADM(min4)
                  min4 = y4
                  CALL PUSHCONTROL2B(1)
                END IF
              ELSE IF (x5 .GT. z4) THEN
                CALL PUSHREALARRAY_ADM(min4)
                min4 = z4
                CALL PUSHCONTROL2B(2)
              ELSE
                CALL PUSHREALARRAY_ADM(min4)
                min4 = x5
                CALL PUSHCONTROL2B(3)
              END IF
              CALL PUSHREALARRAY_ADM(dm(npx-1))
              dm(npx-1) = SIGN(min4, dm(npx-1))
              x1 = s15*u(npx, j) + s11*u(npx+1, j) - s14*dm(npx+1)
!          dm(npx) = x1 - u(npx,j)
              CALL PUSHREALARRAY_ADM(dm(npx))
              dm(npx) = 0.5*(x1-x0)
              IF (dm(npx) .GE. 0.) THEN
                x6 = dm(npx)
                CALL PUSHCONTROL1B(0)
              ELSE
                x6 = -dm(npx)
                CALL PUSHCONTROL1B(1)
              END IF
              IF (u(npx, j) .LT. x0) THEN
                IF (x0 .LT. x1) THEN
                  max6 = x1
                  CALL PUSHCONTROL2B(0)
                ELSE
                  max6 = x0
                  CALL PUSHCONTROL2B(1)
                END IF
              ELSE IF (u(npx, j) .LT. x1) THEN
                max6 = x1
                CALL PUSHCONTROL2B(2)
              ELSE
                max6 = u(npx, j)
                CALL PUSHCONTROL2B(3)
              END IF
              y5 = max6 - u(npx, j)
              IF (u(npx, j) .GT. x0) THEN
                IF (x0 .GT. x1) THEN
                  min18 = x1
                  CALL PUSHCONTROL2B(0)
                ELSE
                  min18 = x0
                  CALL PUSHCONTROL2B(1)
                END IF
              ELSE IF (u(npx, j) .GT. x1) THEN
                min18 = x1
                CALL PUSHCONTROL2B(2)
              ELSE
                min18 = u(npx, j)
                CALL PUSHCONTROL2B(3)
              END IF
              z5 = u(npx, j) - min18
              IF (x6 .GT. y5) THEN
                IF (y5 .GT. z5) THEN
                  CALL PUSHREALARRAY_ADM(min5)
                  min5 = z5
                  CALL PUSHCONTROL2B(0)
                ELSE
                  CALL PUSHREALARRAY_ADM(min5)
                  min5 = y5
                  CALL PUSHCONTROL2B(1)
                END IF
              ELSE IF (x6 .GT. z5) THEN
                CALL PUSHREALARRAY_ADM(min5)
                min5 = z5
                CALL PUSHCONTROL2B(2)
              ELSE
                CALL PUSHREALARRAY_ADM(min5)
                min5 = x6
                CALL PUSHCONTROL2B(3)
              END IF
              CALL PUSHREALARRAY_ADM(dm(npx))
              dm(npx) = SIGN(min5, dm(npx))
              CALL PUSHCONTROL2B(2)
            END IF
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      dm_ad = 0.0_FVPRC
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            u_ad(i, j) = u_ad(i, j) + flux_ad(i, j)
            c_ad(i, j) = c_ad(i, j) - dm(i)*rdx(i, j)*flux_ad(i, j)
            dm_ad(i) = dm_ad(i) - (rdx(i, j)*c(i, j)+1.)*flux_ad(i, j)
            flux_ad(i, j) = 0.0_FVPRC
          ELSE
            u_ad(i-1, j) = u_ad(i-1, j) + flux_ad(i, j)
            c_ad(i, j) = c_ad(i, j) - dm(i-1)*rdx(i-1, j)*flux_ad(i, j)
            dm_ad(i-1) = dm_ad(i-1) + (1.-rdx(i-1, j)*c(i, j))*flux_ad(i&
&             , j)
            flux_ad(i, j) = 0.0_FVPRC
          END IF
        END DO
        CALL POPCONTROL2B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) GOTO 100
        ELSE IF (branch .EQ. 2) THEN
          CALL POPREALARRAY_ADM(dm(npx))
          min5_ad = SIGN(1.d0, min5*dm(npx))*dm_ad(npx)
          dm_ad(npx) = 0.0_FVPRC
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(min5)
              z5_ad = min5_ad
              y5_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min5)
              y5_ad = min5_ad
              z5_ad = 0.0_FVPRC
            END IF
            x6_ad = 0.0_FVPRC
          ELSE
            IF (branch .EQ. 2) THEN
              CALL POPREALARRAY_ADM(min5)
              z5_ad = min5_ad
              x6_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min5)
              x6_ad = min5_ad
              z5_ad = 0.0_FVPRC
            END IF
            y5_ad = 0.0_FVPRC
          END IF
          u_ad(npx, j) = u_ad(npx, j) + z5_ad
          min18_ad = -z5_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              x1_ad = min18_ad
              x0_ad = 0.0_FVPRC
            ELSE
              x0_ad = min18_ad
              x1_ad = 0.0_FVPRC
            END IF
          ELSE
            IF (branch .EQ. 2) THEN
              x1_ad = min18_ad
            ELSE
              u_ad(npx, j) = u_ad(npx, j) + min18_ad
              x1_ad = 0.0_FVPRC
            END IF
            x0_ad = 0.0_FVPRC
          END IF
          max6_ad = y5_ad
          u_ad(npx, j) = u_ad(npx, j) - y5_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              x1_ad = x1_ad + max6_ad
            ELSE
              x0_ad = x0_ad + max6_ad
            END IF
          ELSE IF (branch .EQ. 2) THEN
            x1_ad = x1_ad + max6_ad
          ELSE
            u_ad(npx, j) = u_ad(npx, j) + max6_ad
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            dm_ad(npx) = dm_ad(npx) + x6_ad
          ELSE
            dm_ad(npx) = dm_ad(npx) - x6_ad
          END IF
          CALL POPREALARRAY_ADM(dm(npx))
          x1_ad = x1_ad + 0.5*dm_ad(npx)
          x0_ad = x0_ad - 0.5*dm_ad(npx)
          dm_ad(npx) = 0.0_FVPRC
          u_ad(npx, j) = u_ad(npx, j) + s15*x1_ad
          u_ad(npx+1, j) = u_ad(npx+1, j) + s11*x1_ad
          dm_ad(npx+1) = dm_ad(npx+1) - s14*x1_ad
          CALL POPREALARRAY_ADM(dm(npx-1))
          min4_ad = SIGN(1.d0, min4*dm(npx-1))*dm_ad(npx-1)
          dm_ad(npx-1) = 0.0_FVPRC
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(min4)
              z4_ad = min4_ad
              y4_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min4)
              y4_ad = min4_ad
              z4_ad = 0.0_FVPRC
            END IF
            x5_ad = 0.0_FVPRC
          ELSE
            IF (branch .EQ. 2) THEN
              CALL POPREALARRAY_ADM(min4)
              z4_ad = min4_ad
              x5_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min4)
              x5_ad = min4_ad
              z4_ad = 0.0_FVPRC
            END IF
            y4_ad = 0.0_FVPRC
          END IF
          u_ad(npx-1, j) = u_ad(npx-1, j) + z4_ad
          min17_ad = -z4_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              x1_ad = min17_ad
            ELSE
              x0_ad = x0_ad + min17_ad
              x1_ad = 0.0_FVPRC
            END IF
          ELSE IF (branch .EQ. 2) THEN
            x1_ad = min17_ad
          ELSE
            u_ad(npx-1, j) = u_ad(npx-1, j) + min17_ad
            x1_ad = 0.0_FVPRC
          END IF
          max5_ad = y4_ad
          u_ad(npx-1, j) = u_ad(npx-1, j) - y4_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              x1_ad = x1_ad + max5_ad
            ELSE
              x0_ad = x0_ad + max5_ad
            END IF
          ELSE IF (branch .EQ. 2) THEN
            x1_ad = x1_ad + max5_ad
          ELSE
            u_ad(npx-1, j) = u_ad(npx-1, j) + max5_ad
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            dm_ad(npx-1) = dm_ad(npx-1) + x5_ad
          ELSE
            dm_ad(npx-1) = dm_ad(npx-1) - x5_ad
          END IF
          CALL POPREALARRAY_ADM(dm(npx-1))
          x0_ad = x0_ad + 0.5*dm_ad(npx-1)
          x1_ad = x1_ad - 0.5*dm_ad(npx-1)
          dm_ad(npx-1) = 0.0_FVPRC
          u_ad(npx-1, j) = u_ad(npx-1, j) + s15*x1_ad
          u_ad(npx-2, j) = u_ad(npx-2, j) + s11*x1_ad
          dm_ad(npx-2) = dm_ad(npx-2) + s14*x1_ad
          x0l_ad = x0_ad
          x0r_ad = x0_ad
          temp_ad11 = 0.5*x0r_ad/(dx(npx, j)+dx(npx+1, j))
          u_ad(npx, j) = u_ad(npx, j) + (dx(npx, j)*2.+dx(npx+1, j))*&
&           temp_ad11
          u_ad(npx+1, j) = u_ad(npx+1, j) - dx(npx, j)*temp_ad11
          temp_ad12 = 0.5*x0l_ad/(dx(npx-1, j)+dx(npx-2, j))
          u_ad(npx-1, j) = u_ad(npx-1, j) + (dx(npx-1, j)*2.+dx(npx-2, j&
&           ))*temp_ad12
          u_ad(npx-2, j) = u_ad(npx-2, j) - dx(npx-1, j)*temp_ad12
        ELSE
          CALL POPREALARRAY_ADM(dm(npx))
          dm_ad(npx) = 0.0_FVPRC
          CALL POPREALARRAY_ADM(dm(npx-1))
          dm_ad(npx-1) = 0.0_FVPRC
        END IF
        CALL POPCONTROL2B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREALARRAY_ADM(dm(1))
          dm_ad(1) = 0.0_FVPRC
          CALL POPREALARRAY_ADM(dm(0))
          dm_ad(0) = 0.0_FVPRC
        ELSE IF (branch .EQ. 1) THEN
          CALL POPREALARRAY_ADM(dm(1))
          min3_ad = SIGN(1.d0, min3*dm(1))*dm_ad(1)
          dm_ad(1) = 0.0_FVPRC
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(min3)
              z3_ad = min3_ad
              y3_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min3)
              y3_ad = min3_ad
              z3_ad = 0.0_FVPRC
            END IF
            x4_ad = 0.0_FVPRC
          ELSE
            IF (branch .EQ. 2) THEN
              CALL POPREALARRAY_ADM(min3)
              z3_ad = min3_ad
              x4_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min3)
              x4_ad = min3_ad
              z3_ad = 0.0_FVPRC
            END IF
            y3_ad = 0.0_FVPRC
          END IF
          u_ad(1, j) = u_ad(1, j) + z3_ad
          min16_ad = -z3_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              x1_ad = min16_ad
              x0_ad = 0.0_FVPRC
            ELSE
              x0_ad = min16_ad
              x1_ad = 0.0_FVPRC
            END IF
          ELSE
            IF (branch .EQ. 2) THEN
              x1_ad = min16_ad
            ELSE
              u_ad(1, j) = u_ad(1, j) + min16_ad
              x1_ad = 0.0_FVPRC
            END IF
            x0_ad = 0.0_FVPRC
          END IF
          max4_ad = y3_ad
          u_ad(1, j) = u_ad(1, j) - y3_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              x1_ad = x1_ad + max4_ad
            ELSE
              x0_ad = x0_ad + max4_ad
            END IF
          ELSE IF (branch .EQ. 2) THEN
            x1_ad = x1_ad + max4_ad
          ELSE
            u_ad(1, j) = u_ad(1, j) + max4_ad
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            dm_ad(1) = dm_ad(1) + x4_ad
          ELSE
            dm_ad(1) = dm_ad(1) - x4_ad
          END IF
          CALL POPREALARRAY_ADM(dm(1))
          x1_ad = x1_ad + 0.5*dm_ad(1)
          x0_ad = x0_ad - 0.5*dm_ad(1)
          dm_ad(1) = 0.0_FVPRC
          u_ad(1, j) = u_ad(1, j) + s15*x1_ad
          u_ad(2, j) = u_ad(2, j) + s11*x1_ad
          dm_ad(2) = dm_ad(2) - s14*x1_ad
          CALL POPREALARRAY_ADM(dm(0))
          min2_ad = SIGN(1.d0, min2*dm(0))*dm_ad(0)
          dm_ad(0) = 0.0_FVPRC
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(min2)
              z2_ad = min2_ad
              y2_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min2)
              y2_ad = min2_ad
              z2_ad = 0.0_FVPRC
            END IF
            x3_ad = 0.0_FVPRC
          ELSE
            IF (branch .EQ. 2) THEN
              CALL POPREALARRAY_ADM(min2)
              z2_ad = min2_ad
              x3_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min2)
              x3_ad = min2_ad
              z2_ad = 0.0_FVPRC
            END IF
            y2_ad = 0.0_FVPRC
          END IF
          u_ad(0, j) = u_ad(0, j) + z2_ad
          min15_ad = -z2_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              x1_ad = min15_ad
            ELSE
              x0_ad = x0_ad + min15_ad
              x1_ad = 0.0_FVPRC
            END IF
          ELSE IF (branch .EQ. 2) THEN
            x1_ad = min15_ad
          ELSE
            u_ad(0, j) = u_ad(0, j) + min15_ad
            x1_ad = 0.0_FVPRC
          END IF
          max3_ad = y2_ad
          u_ad(0, j) = u_ad(0, j) - y2_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              x1_ad = x1_ad + max3_ad
            ELSE
              x0_ad = x0_ad + max3_ad
            END IF
          ELSE IF (branch .EQ. 2) THEN
            x1_ad = x1_ad + max3_ad
          ELSE
            u_ad(0, j) = u_ad(0, j) + max3_ad
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            dm_ad(0) = dm_ad(0) + x3_ad
          ELSE
            dm_ad(0) = dm_ad(0) - x3_ad
          END IF
          CALL POPREALARRAY_ADM(dm(0))
          x0_ad = x0_ad + 0.5*dm_ad(0)
          x1_ad = x1_ad - 0.5*dm_ad(0)
          dm_ad(0) = 0.0_FVPRC
          u_ad(0, j) = u_ad(0, j) + s15*x1_ad
          u_ad(-1, j) = u_ad(-1, j) + s11*x1_ad
          dm_ad(-1) = dm_ad(-1) + s14*x1_ad
          x0l_ad = x0_ad
          x0r_ad = x0_ad
          temp_ad9 = 0.5*x0r_ad/(dx(1, j)+dx(2, j))
          u_ad(1, j) = u_ad(1, j) + (dx(1, j)*2.+dx(2, j))*temp_ad9
          u_ad(2, j) = u_ad(2, j) - dx(1, j)*temp_ad9
          temp_ad10 = 0.5*x0l_ad/(dx(0, j)+dx(-1, j))
          u_ad(0, j) = u_ad(0, j) + (dx(0, j)*2.+dx(-1, j))*temp_ad10
          u_ad(-1, j) = u_ad(-1, j) - dx(0, j)*temp_ad10
        END IF
 100    DO i=ie+2,is-2,-1
          xt = 0.25*(u(i+1, j)-u(i-1, j))
          CALL POPREALARRAY_ADM(dm(i))
          min1_ad = SIGN(1.d0, min1*xt)*dm_ad(i)
          dm_ad(i) = 0.0_FVPRC
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(min1)
              z1_ad = min1_ad
              y1_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min1)
              y1_ad = min1_ad
              z1_ad = 0.0_FVPRC
            END IF
            x2_ad = 0.0_FVPRC
          ELSE
            IF (branch .EQ. 2) THEN
              CALL POPREALARRAY_ADM(min1)
              z1_ad = min1_ad
              x2_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min1)
              x2_ad = min1_ad
              z1_ad = 0.0_FVPRC
            END IF
            y1_ad = 0.0_FVPRC
          END IF
          u_ad(i, j) = u_ad(i, j) + z1_ad
          min14_ad = -z1_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              u_ad(i+1, j) = u_ad(i+1, j) + min14_ad
            ELSE
              u_ad(i, j) = u_ad(i, j) + min14_ad
            END IF
          ELSE IF (branch .EQ. 2) THEN
            u_ad(i+1, j) = u_ad(i+1, j) + min14_ad
          ELSE
            u_ad(i-1, j) = u_ad(i-1, j) + min14_ad
          END IF
          max2_ad = y1_ad
          u_ad(i, j) = u_ad(i, j) - y1_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              u_ad(i+1, j) = u_ad(i+1, j) + max2_ad
            ELSE
              u_ad(i, j) = u_ad(i, j) + max2_ad
            END IF
          ELSE IF (branch .EQ. 2) THEN
            u_ad(i+1, j) = u_ad(i+1, j) + max2_ad
          ELSE
            u_ad(i-1, j) = u_ad(i-1, j) + max2_ad
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            xt_ad = x2_ad
          ELSE
            xt_ad = -x2_ad
          END IF
          u_ad(i+1, j) = u_ad(i+1, j) + 0.25*xt_ad
          u_ad(i-1, j) = u_ad(i-1, j) - 0.25*xt_ad
        END DO
      END DO
    CASE (4) 
      DO j=js,je+1
        DO i=is-2,ie+2
          CALL PUSHREALARRAY_ADM(xt)
          xt = 0.25*(u(i+1, j)-u(i-1, j))
          IF (xt .GE. 0.) THEN
            x7 = xt
            CALL PUSHCONTROL1B(0)
          ELSE
            x7 = -xt
            CALL PUSHCONTROL1B(1)
          END IF
          IF (u(i-1, j) .LT. u(i, j)) THEN
            IF (u(i, j) .LT. u(i+1, j)) THEN
              max7 = u(i+1, j)
              CALL PUSHCONTROL2B(0)
            ELSE
              max7 = u(i, j)
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE IF (u(i-1, j) .LT. u(i+1, j)) THEN
            max7 = u(i+1, j)
            CALL PUSHCONTROL2B(2)
          ELSE
            max7 = u(i-1, j)
            CALL PUSHCONTROL2B(3)
          END IF
          y6 = max7 - u(i, j)
          IF (u(i-1, j) .GT. u(i, j)) THEN
            IF (u(i, j) .GT. u(i+1, j)) THEN
              min19 = u(i+1, j)
              CALL PUSHCONTROL2B(0)
            ELSE
              min19 = u(i, j)
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE IF (u(i-1, j) .GT. u(i+1, j)) THEN
            min19 = u(i+1, j)
            CALL PUSHCONTROL2B(2)
          ELSE
            min19 = u(i-1, j)
            CALL PUSHCONTROL2B(3)
          END IF
          z6 = u(i, j) - min19
          IF (x7 .GT. y6) THEN
            IF (y6 .GT. z6) THEN
              CALL PUSHREALARRAY_ADM(min6)
              min6 = z6
              CALL PUSHCONTROL2B(0)
            ELSE
              CALL PUSHREALARRAY_ADM(min6)
              min6 = y6
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE IF (x7 .GT. z6) THEN
            CALL PUSHREALARRAY_ADM(min6)
            min6 = z6
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHREALARRAY_ADM(min6)
            min6 = x7
            CALL PUSHCONTROL2B(3)
          END IF
          dm(i) = SIGN(min6, xt)
        END DO
        IF (3 .LT. is - 1) THEN
          max1 = is - 1
        ELSE
          max1 = 3
        END IF
        IF (npx - 2 .GT. ie + 2) THEN
          min20 = ie + 2
        ELSE
          min20 = npx - 2
        END IF
        ad_from = max1
        DO i=ad_from,min20
          al(i) = 0.5*(u(i-1, j)+u(i, j)) + r3*(dm(i-1)-dm(i))
        END DO
        CALL PUSHINTEGER4(i - 1)
        CALL PUSHINTEGER4(ad_from)
! Fix slopes near edges:
        IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
          IF (is .EQ. 1) THEN
            x0l = 0.5*((2.*dx(0, j)+dx(-1, j))*u(0, j)-dx(0, j)*u(-1, j)&
&             )/(dx(0, j)+dx(-1, j))
            x0r = 0.5*((2.*dx(1, j)+dx(2, j))*u(1, j)-dx(1, j)*u(2, j))/&
&             (dx(1, j)+dx(2, j))
            x0 = x0l + x0r
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
              dm(0) = 0.
              dm(1) = 0.
              al(0) = 0.5*(u(-1, j)+u(0, j)) + r3*dm(-1)
              al(1) = x0
              al(2) = 0.5*(u(1, j)+u(2, j)) - r3*dm(2)
              CALL PUSHCONTROL2B(0)
            ELSE
              x1 = s15*u(1, j) + s11*u(2, j) - s14*dm(2)
              dm(1) = 0.5*(x1-x0)
!          dm(1) = sign(min(abs(dm(1)), max(u(1,j), x0, x1) - u(1,j),   &
!                              u(1,j) - min(u(1,j), x0, x1)), dm(1))
              x1 = s15*u(0, j) + s11*u(-1, j) + s14*dm(-1)
              dm(0) = 0.5*(x0-x1)
!          dm(0) = sign(min(abs(dm(0)), max(u(0,j), x0, x1) - u(0,j),   &
!                              u(0,j) - min(u(0,j), x0, x1)), dm(0))
              al(0) = 0.5*(u(-1, j)+u(0, j)) + r3*(dm(-1)-dm(0))
              al(1) = x0
              al(2) = 0.5*(u(1, j)+u(2, j)) + r3*(dm(1)-dm(2))
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B(2)
          END IF
          IF (ie + 1 .EQ. npx) THEN
            x0l = 0.5*((2.*dx(npx-1, j)+dx(npx-2, j))*u(npx-1, j)-dx(npx&
&             -1, j)*u(npx-2, j))/(dx(npx-1, j)+dx(npx-2, j))
            x0r = 0.5*((2.*dx(npx, j)+dx(npx+1, j))*u(npx, j)-dx(npx, j)&
&             *u(npx+1, j))/(dx(npx, j)+dx(npx+1, j))
            x0 = x0l + x0r
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
              dm(npx-1) = 0.
              dm(npx) = 0.
              al(npx-1) = 0.5*(u(npx-2, j)+u(npx-1, j)) + r3*dm(npx-2)
              al(npx) = x0
              al(npx+1) = 0.5*(u(npx, j)+u(npx+1, j)) - r3*dm(npx+1)
              CALL PUSHCONTROL2B(3)
            ELSE
              x1 = s15*u(npx-1, j) + s11*u(npx-2, j) + s14*dm(npx-2)
              dm(npx-1) = 0.5*(x0-x1)
!          dm(npx-1) = sign(min(abs(dm(npx-1)), max(u(npx-1,j), x0, x1) - u(npx-1,j),  &
!                                  u(npx-1,j) - min(u(npx-1,j), x0, x1)), dm(npx-1))
              x1 = s15*u(npx, j) + s11*u(npx+1, j) - s14*dm(npx+1)
              dm(npx) = 0.5*(x1-x0)
!          dm(npx) = sign(min(abs(dm(npx)), max(u(npx,j), x0, x1) - u(npx,j),   &
!                                u(npx,j) - min(u(npx,j), x0, x1)), dm(npx))
              al(npx-1) = 0.5*(u(npx-2, j)+u(npx-1, j)) + r3*(dm(npx-2)-&
&               dm(npx-1))
              al(npx) = x0
              al(npx+1) = 0.5*(u(npx, j)+u(npx+1, j)) + r3*(dm(npx)-dm(&
&               npx+1))
              CALL PUSHCONTROL2B(2)
            END IF
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            CALL PUSHREALARRAY_ADM(xt)
            xt = 2.*dm(i-1)
            IF (xt .GE. 0.) THEN
              x8 = xt
              CALL PUSHCONTROL1B(0)
            ELSE
              x8 = -xt
              CALL PUSHCONTROL1B(1)
            END IF
            IF (al(i-1) - u(i-1, j) .GE. 0.) THEN
              y7 = al(i-1) - u(i-1, j)
              CALL PUSHCONTROL1B(0)
            ELSE
              y7 = -(al(i-1)-u(i-1, j))
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x8 .GT. y7) THEN
              CALL PUSHREALARRAY_ADM(min7)
              min7 = y7
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREALARRAY_ADM(min7)
              min7 = x8
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREALARRAY_ADM(dl)
            dl = SIGN(min7, xt)
            IF (xt .GE. 0.) THEN
              x9 = xt
              CALL PUSHCONTROL1B(0)
            ELSE
              x9 = -xt
              CALL PUSHCONTROL1B(1)
            END IF
            IF (al(i) - u(i-1, j) .GE. 0.) THEN
              y8 = al(i) - u(i-1, j)
              CALL PUSHCONTROL1B(0)
            ELSE
              y8 = -(al(i)-u(i-1, j))
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x9 .GT. y8) THEN
              CALL PUSHREALARRAY_ADM(min8)
              min8 = y8
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREALARRAY_ADM(min8)
              min8 = x9
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREALARRAY_ADM(dr)
            dr = SIGN(min8, xt)
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHREALARRAY_ADM(xt)
            xt = 2.*dm(i)
            IF (xt .GE. 0.) THEN
              x10 = xt
              CALL PUSHCONTROL1B(0)
            ELSE
              x10 = -xt
              CALL PUSHCONTROL1B(1)
            END IF
            IF (al(i) - u(i, j) .GE. 0.) THEN
              y9 = al(i) - u(i, j)
              CALL PUSHCONTROL1B(0)
            ELSE
              y9 = -(al(i)-u(i, j))
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x10 .GT. y9) THEN
              CALL PUSHREALARRAY_ADM(min9)
              min9 = y9
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREALARRAY_ADM(min9)
              min9 = x10
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREALARRAY_ADM(dl)
            dl = SIGN(min9, xt)
            IF (xt .GE. 0.) THEN
              x11 = xt
              CALL PUSHCONTROL1B(0)
            ELSE
              x11 = -xt
              CALL PUSHCONTROL1B(1)
            END IF
            IF (al(i+1) - u(i, j) .GE. 0.) THEN
              y10 = al(i+1) - u(i, j)
              CALL PUSHCONTROL1B(0)
            ELSE
              y10 = -(al(i+1)-u(i, j))
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x11 .GT. y10) THEN
              CALL PUSHREALARRAY_ADM(min10)
              min10 = y10
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREALARRAY_ADM(min10)
              min10 = x11
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREALARRAY_ADM(dr)
            dr = SIGN(min10, xt)
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      dm_ad = 0.0_FVPRC
      al_ad = 0.0_FVPRC
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            cfl = c(i, j)*rdx(i, j)
            temp_ad18 = -((cfl+1.)*flux_ad(i, j))
            u_ad(i, j) = u_ad(i, j) + flux_ad(i, j)
            cfl_ad = (dl-dr)*temp_ad18 - (dl+cfl*(dl-dr))*flux_ad(i, j)
            dl_ad = (cfl+1.0)*temp_ad18
            dr_ad = -(cfl*temp_ad18)
            flux_ad(i, j) = 0.0_FVPRC
            c_ad(i, j) = c_ad(i, j) + rdx(i, j)*cfl_ad
            CALL POPREALARRAY_ADM(dr)
            min10_ad = SIGN(1.d0, min10*xt)*dr_ad
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(min10)
              y10_ad = min10_ad
              x11_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min10)
              x11_ad = min10_ad
              y10_ad = 0.0_FVPRC
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              al_ad(i+1) = al_ad(i+1) + y10_ad
              u_ad(i, j) = u_ad(i, j) - y10_ad
            ELSE
              u_ad(i, j) = u_ad(i, j) + y10_ad
              al_ad(i+1) = al_ad(i+1) - y10_ad
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              xt_ad = x11_ad
            ELSE
              xt_ad = -x11_ad
            END IF
            CALL POPREALARRAY_ADM(dl)
            min9_ad = SIGN(1.d0, min9*xt)*dl_ad
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(min9)
              y9_ad = min9_ad
              x10_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min9)
              x10_ad = min9_ad
              y9_ad = 0.0_FVPRC
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              al_ad(i) = al_ad(i) + y9_ad
              u_ad(i, j) = u_ad(i, j) - y9_ad
            ELSE
              u_ad(i, j) = u_ad(i, j) + y9_ad
              al_ad(i) = al_ad(i) - y9_ad
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              xt_ad = xt_ad + x10_ad
            ELSE
              xt_ad = xt_ad - x10_ad
            END IF
            CALL POPREALARRAY_ADM(xt)
            dm_ad(i) = dm_ad(i) + 2.*xt_ad
          ELSE
            cfl = c(i, j)*rdx(i-1, j)
            temp_ad17 = (1.-cfl)*flux_ad(i, j)
            u_ad(i-1, j) = u_ad(i-1, j) + flux_ad(i, j)
            cfl_ad = (dl-dr)*temp_ad17 - (dr+cfl*(dl-dr))*flux_ad(i, j)
            dr_ad = (1.0-cfl)*temp_ad17
            dl_ad = cfl*temp_ad17
            flux_ad(i, j) = 0.0_FVPRC
            c_ad(i, j) = c_ad(i, j) + rdx(i-1, j)*cfl_ad
            CALL POPREALARRAY_ADM(dr)
            min8_ad = SIGN(1.d0, min8*xt)*dr_ad
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(min8)
              y8_ad = min8_ad
              x9_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min8)
              x9_ad = min8_ad
              y8_ad = 0.0_FVPRC
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              al_ad(i) = al_ad(i) + y8_ad
              u_ad(i-1, j) = u_ad(i-1, j) - y8_ad
            ELSE
              u_ad(i-1, j) = u_ad(i-1, j) + y8_ad
              al_ad(i) = al_ad(i) - y8_ad
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              xt_ad = x9_ad
            ELSE
              xt_ad = -x9_ad
            END IF
            CALL POPREALARRAY_ADM(dl)
            min7_ad = SIGN(1.d0, min7*xt)*dl_ad
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(min7)
              y7_ad = min7_ad
              x8_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min7)
              x8_ad = min7_ad
              y7_ad = 0.0_FVPRC
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              al_ad(i-1) = al_ad(i-1) + y7_ad
              u_ad(i-1, j) = u_ad(i-1, j) - y7_ad
            ELSE
              u_ad(i-1, j) = u_ad(i-1, j) + y7_ad
              al_ad(i-1) = al_ad(i-1) - y7_ad
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              xt_ad = xt_ad + x8_ad
            ELSE
              xt_ad = xt_ad - x8_ad
            END IF
            CALL POPREALARRAY_ADM(xt)
            dm_ad(i-1) = dm_ad(i-1) + 2.*xt_ad
          END IF
        END DO
        CALL POPCONTROL2B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) GOTO 110
        ELSE
          IF (branch .EQ. 2) THEN
            u_ad(npx, j) = u_ad(npx, j) + 0.5*al_ad(npx+1)
            u_ad(npx+1, j) = u_ad(npx+1, j) + 0.5*al_ad(npx+1)
            dm_ad(npx) = dm_ad(npx) + r3*al_ad(npx+1)
            dm_ad(npx+1) = dm_ad(npx+1) - r3*al_ad(npx+1)
            al_ad(npx+1) = 0.0_FVPRC
            x0_ad = al_ad(npx)
            al_ad(npx) = 0.0_FVPRC
            u_ad(npx-2, j) = u_ad(npx-2, j) + 0.5*al_ad(npx-1)
            u_ad(npx-1, j) = u_ad(npx-1, j) + 0.5*al_ad(npx-1)
            dm_ad(npx-2) = dm_ad(npx-2) + r3*al_ad(npx-1)
            dm_ad(npx-1) = dm_ad(npx-1) - r3*al_ad(npx-1)
            al_ad(npx-1) = 0.0_FVPRC
            x1_ad = 0.5*dm_ad(npx)
            x0_ad = x0_ad - 0.5*dm_ad(npx)
            dm_ad(npx) = 0.0_FVPRC
            u_ad(npx, j) = u_ad(npx, j) + s15*x1_ad
            u_ad(npx+1, j) = u_ad(npx+1, j) + s11*x1_ad
            dm_ad(npx+1) = dm_ad(npx+1) - s14*x1_ad
            x0_ad = x0_ad + 0.5*dm_ad(npx-1)
            x1_ad = -(0.5*dm_ad(npx-1))
            dm_ad(npx-1) = 0.0_FVPRC
            u_ad(npx-1, j) = u_ad(npx-1, j) + s15*x1_ad
            u_ad(npx-2, j) = u_ad(npx-2, j) + s11*x1_ad
            dm_ad(npx-2) = dm_ad(npx-2) + s14*x1_ad
          ELSE
            u_ad(npx, j) = u_ad(npx, j) + 0.5*al_ad(npx+1)
            u_ad(npx+1, j) = u_ad(npx+1, j) + 0.5*al_ad(npx+1)
            dm_ad(npx+1) = dm_ad(npx+1) - r3*al_ad(npx+1)
            al_ad(npx+1) = 0.0_FVPRC
            x0_ad = al_ad(npx)
            al_ad(npx) = 0.0_FVPRC
            u_ad(npx-2, j) = u_ad(npx-2, j) + 0.5*al_ad(npx-1)
            u_ad(npx-1, j) = u_ad(npx-1, j) + 0.5*al_ad(npx-1)
            dm_ad(npx-2) = dm_ad(npx-2) + r3*al_ad(npx-1)
            al_ad(npx-1) = 0.0_FVPRC
            dm_ad(npx) = 0.0_FVPRC
            dm_ad(npx-1) = 0.0_FVPRC
          END IF
          x0l_ad = x0_ad
          x0r_ad = x0_ad
          temp_ad15 = 0.5*x0r_ad/(dx(npx, j)+dx(npx+1, j))
          u_ad(npx, j) = u_ad(npx, j) + (dx(npx, j)*2.+dx(npx+1, j))*&
&           temp_ad15
          u_ad(npx+1, j) = u_ad(npx+1, j) - dx(npx, j)*temp_ad15
          temp_ad16 = 0.5*x0l_ad/(dx(npx-1, j)+dx(npx-2, j))
          u_ad(npx-1, j) = u_ad(npx-1, j) + (dx(npx-1, j)*2.+dx(npx-2, j&
&           ))*temp_ad16
          u_ad(npx-2, j) = u_ad(npx-2, j) - dx(npx-1, j)*temp_ad16
        END IF
        CALL POPCONTROL2B(branch)
        IF (branch .EQ. 0) THEN
          u_ad(1, j) = u_ad(1, j) + 0.5*al_ad(2)
          u_ad(2, j) = u_ad(2, j) + 0.5*al_ad(2)
          dm_ad(2) = dm_ad(2) - r3*al_ad(2)
          al_ad(2) = 0.0_FVPRC
          x0_ad = al_ad(1)
          al_ad(1) = 0.0_FVPRC
          u_ad(-1, j) = u_ad(-1, j) + 0.5*al_ad(0)
          u_ad(0, j) = u_ad(0, j) + 0.5*al_ad(0)
          dm_ad(-1) = dm_ad(-1) + r3*al_ad(0)
          al_ad(0) = 0.0_FVPRC
          dm_ad(1) = 0.0_FVPRC
          dm_ad(0) = 0.0_FVPRC
        ELSE IF (branch .EQ. 1) THEN
          u_ad(1, j) = u_ad(1, j) + 0.5*al_ad(2)
          u_ad(2, j) = u_ad(2, j) + 0.5*al_ad(2)
          dm_ad(1) = dm_ad(1) + r3*al_ad(2)
          dm_ad(2) = dm_ad(2) - r3*al_ad(2)
          al_ad(2) = 0.0_FVPRC
          x0_ad = al_ad(1)
          al_ad(1) = 0.0_FVPRC
          u_ad(-1, j) = u_ad(-1, j) + 0.5*al_ad(0)
          dm_ad(-1) = dm_ad(-1) + r3*al_ad(0)
          dm_ad(0) = dm_ad(0) - r3*al_ad(0)
          x0_ad = x0_ad + 0.5*dm_ad(0)
          x1_ad = -(0.5*dm_ad(0))
          u_ad(0, j) = u_ad(0, j) + s15*x1_ad + 0.5*al_ad(0)
          al_ad(0) = 0.0_FVPRC
          dm_ad(0) = 0.0_FVPRC
          u_ad(-1, j) = u_ad(-1, j) + s11*x1_ad
          dm_ad(-1) = dm_ad(-1) + s14*x1_ad
          x1_ad = 0.5*dm_ad(1)
          x0_ad = x0_ad - 0.5*dm_ad(1)
          dm_ad(1) = 0.0_FVPRC
          u_ad(1, j) = u_ad(1, j) + s15*x1_ad
          u_ad(2, j) = u_ad(2, j) + s11*x1_ad
          dm_ad(2) = dm_ad(2) - s14*x1_ad
        ELSE
          GOTO 110
        END IF
        x0l_ad = x0_ad
        x0r_ad = x0_ad
        temp_ad13 = 0.5*x0r_ad/(dx(1, j)+dx(2, j))
        u_ad(1, j) = u_ad(1, j) + (dx(1, j)*2.+dx(2, j))*temp_ad13
        u_ad(2, j) = u_ad(2, j) - dx(1, j)*temp_ad13
        temp_ad14 = 0.5*x0l_ad/(dx(0, j)+dx(-1, j))
        u_ad(0, j) = u_ad(0, j) + (dx(0, j)*2.+dx(-1, j))*temp_ad14
        u_ad(-1, j) = u_ad(-1, j) - dx(0, j)*temp_ad14
 110    CALL POPINTEGER4(ad_from)
        CALL POPINTEGER4(ad_to)
        DO i=ad_to,ad_from,-1
          u_ad(i-1, j) = u_ad(i-1, j) + 0.5*al_ad(i)
          u_ad(i, j) = u_ad(i, j) + 0.5*al_ad(i)
          dm_ad(i-1) = dm_ad(i-1) + r3*al_ad(i)
          dm_ad(i) = dm_ad(i) - r3*al_ad(i)
          al_ad(i) = 0.0_FVPRC
        END DO
        DO i=ie+2,is-2,-1
          xt = 0.25*(u(i+1, j)-u(i-1, j))
          min6_ad = SIGN(1.d0, min6*xt)*dm_ad(i)
          dm_ad(i) = 0.0_FVPRC
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(min6)
              z6_ad = min6_ad
              y6_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min6)
              y6_ad = min6_ad
              z6_ad = 0.0_FVPRC
            END IF
            x7_ad = 0.0_FVPRC
          ELSE
            IF (branch .EQ. 2) THEN
              CALL POPREALARRAY_ADM(min6)
              z6_ad = min6_ad
              x7_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min6)
              x7_ad = min6_ad
              z6_ad = 0.0_FVPRC
            END IF
            y6_ad = 0.0_FVPRC
          END IF
          u_ad(i, j) = u_ad(i, j) + z6_ad
          min19_ad = -z6_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              u_ad(i+1, j) = u_ad(i+1, j) + min19_ad
            ELSE
              u_ad(i, j) = u_ad(i, j) + min19_ad
            END IF
          ELSE IF (branch .EQ. 2) THEN
            u_ad(i+1, j) = u_ad(i+1, j) + min19_ad
          ELSE
            u_ad(i-1, j) = u_ad(i-1, j) + min19_ad
          END IF
          max7_ad = y6_ad
          u_ad(i, j) = u_ad(i, j) - y6_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              u_ad(i+1, j) = u_ad(i+1, j) + max7_ad
            ELSE
              u_ad(i, j) = u_ad(i, j) + max7_ad
            END IF
          ELSE IF (branch .EQ. 2) THEN
            u_ad(i+1, j) = u_ad(i+1, j) + max7_ad
          ELSE
            u_ad(i-1, j) = u_ad(i-1, j) + max7_ad
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            xt_ad = x7_ad
          ELSE
            xt_ad = -x7_ad
          END IF
          CALL POPREALARRAY_ADM(xt)
          u_ad(i+1, j) = u_ad(i+1, j) + 0.25*xt_ad
          u_ad(i-1, j) = u_ad(i-1, j) - 0.25*xt_ad
        END DO
      END DO
    CASE (6) 
      DO j=js,je+1
!            is3 = max(3,is-1) ; ie3 = min(npx-3,ie+1)
        DO i=is3,ie3+1
          al(i) = p1*(u(i-1, j)+u(i, j)) + p2*(u(i-2, j)+u(i+1, j))
        END DO
        DO i=is3,ie3
          CALL PUSHREALARRAY_ADM(bl(i))
          bl(i) = al(i) - u(i, j)
          CALL PUSHREALARRAY_ADM(br(i))
          br(i) = al(i+1) - u(i, j)
        END DO
        IF (.NOT.nested .AND. grid_type .LT. 3) THEN
          IF (is .EQ. 1) THEN
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
! out
              CALL PUSHREALARRAY_ADM(bl(0))
              bl(0) = 0.
! edge
              CALL PUSHREALARRAY_ADM(br(0))
              br(0) = 0.
! edge
              CALL PUSHREALARRAY_ADM(bl(1))
              bl(1) = 0.
! in
              CALL PUSHREALARRAY_ADM(br(1))
              br(1) = 0.
              CALL PUSHREALARRAY_ADM(bl(2))
              bl(2) = c3*u(1, j) + c2*u(2, j) + c1*u(3, j) - u(2, j)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREALARRAY_ADM(bl(0))
              bl(0) = c1*u(-2, j) + c2*u(-1, j) + c3*u(0, j) - u(0, j)
              xt = 0.5*(((2.*dx(0, j)+dx(-1, j))*u(0, j)-dx(0, j)*u(-1, &
&               j))/(dx(0, j)+dx(-1, j))+((2.*dx(1, j)+dx(2, j))*u(1, j)&
&               -dx(1, j)*u(2, j))/(dx(1, j)+dx(2, j)))
              CALL PUSHREALARRAY_ADM(br(0))
              br(0) = xt - u(0, j)
              CALL PUSHREALARRAY_ADM(bl(1))
              bl(1) = xt - u(1, j)
              xt = c3*u(1, j) + c2*u(2, j) + c1*u(3, j)
              CALL PUSHREALARRAY_ADM(br(1))
              br(1) = xt - u(1, j)
              CALL PUSHREALARRAY_ADM(bl(2))
              bl(2) = xt - u(2, j)
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREALARRAY_ADM(br(2))
            br(2) = al(3) - u(2, j)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (ie + 1 .EQ. npx) THEN
            CALL PUSHREALARRAY_ADM(bl(npx-2))
            bl(npx-2) = al(npx-2) - u(npx-2, j)
            xt = c1*u(npx-3, j) + c2*u(npx-2, j) + c3*u(npx-1, j)
            CALL PUSHREALARRAY_ADM(br(npx-2))
            br(npx-2) = xt - u(npx-2, j)
            CALL PUSHREALARRAY_ADM(bl(npx-1))
            bl(npx-1) = xt - u(npx-1, j)
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
! in
              CALL PUSHREALARRAY_ADM(bl(npx-1))
              bl(npx-1) = 0.
! edge
              CALL PUSHREALARRAY_ADM(br(npx-1))
              br(npx-1) = 0.
! edge
              CALL PUSHREALARRAY_ADM(bl(npx))
              bl(npx) = 0.
! out
              CALL PUSHREALARRAY_ADM(br(npx))
              br(npx) = 0.
              CALL PUSHCONTROL2B(3)
            ELSE
              xt = 0.5*(((2.*dx(npx-1, j)+dx(npx-2, j))*u(npx-1, j)-dx(&
&               npx-1, j)*u(npx-2, j))/(dx(npx-1, j)+dx(npx-2, j))+((2.*&
&               dx(npx, j)+dx(npx+1, j))*u(npx, j)-dx(npx, j)*u(npx+1, j&
&               ))/(dx(npx, j)+dx(npx+1, j)))
              CALL PUSHREALARRAY_ADM(br(npx-1))
              br(npx-1) = xt - u(npx-1, j)
              CALL PUSHREALARRAY_ADM(bl(npx))
              bl(npx) = xt - u(npx, j)
              CALL PUSHREALARRAY_ADM(br(npx))
              br(npx) = c3*u(npx, j) + c2*u(npx+1, j) + c1*u(npx+2, j) -&
&               u(npx, j)
              CALL PUSHCONTROL2B(2)
            END IF
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      al_ad = 0.0_FVPRC
      bl_ad = 0.0_FVPRC
      br_ad = 0.0_FVPRC
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            cfl = c(i, j)*rdx(i, j)
            temp_ad24 = (cfl+1.)*flux_ad(i, j)
            u_ad(i, j) = u_ad(i, j) + flux_ad(i, j)
            cfl_ad = (bl(i)+br(i))*temp_ad24 + (bl(i)+cfl*(bl(i)+br(i)))&
&             *flux_ad(i, j)
            bl_ad(i) = bl_ad(i) + (cfl+1.0)*temp_ad24
            br_ad(i) = br_ad(i) + cfl*temp_ad24
            flux_ad(i, j) = 0.0_FVPRC
            c_ad(i, j) = c_ad(i, j) + rdx(i, j)*cfl_ad
          ELSE
            cfl = c(i, j)*rdx(i-1, j)
            temp = bl(i-1) + br(i-1)
            temp_ad23 = (1.-cfl)*flux_ad(i, j)
            u_ad(i-1, j) = u_ad(i-1, j) + flux_ad(i, j)
            cfl_ad = -(temp*temp_ad23) - (br(i-1)-cfl*temp)*flux_ad(i, j&
&             )
            br_ad(i-1) = br_ad(i-1) + (1.0-cfl)*temp_ad23
            bl_ad(i-1) = bl_ad(i-1) - cfl*temp_ad23
            flux_ad(i, j) = 0.0_FVPRC
            c_ad(i, j) = c_ad(i, j) + rdx(i-1, j)*cfl_ad
          END IF
        END DO
        CALL POPCONTROL2B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) GOTO 120
        ELSE
          IF (branch .EQ. 2) THEN
            CALL POPREALARRAY_ADM(br(npx))
            u_ad(npx, j) = u_ad(npx, j) + (c3-1.0)*br_ad(npx)
            u_ad(npx+1, j) = u_ad(npx+1, j) + c2*br_ad(npx)
            u_ad(npx+2, j) = u_ad(npx+2, j) + c1*br_ad(npx)
            br_ad(npx) = 0.0_FVPRC
            CALL POPREALARRAY_ADM(bl(npx))
            xt_ad = br_ad(npx-1) + bl_ad(npx)
            u_ad(npx, j) = u_ad(npx, j) - bl_ad(npx)
            bl_ad(npx) = 0.0_FVPRC
            CALL POPREALARRAY_ADM(br(npx-1))
            temp_ad21 = 0.5*xt_ad/(dx(npx-1, j)+dx(npx-2, j))
            u_ad(npx-1, j) = u_ad(npx-1, j) + (dx(npx-1, j)*2.+dx(npx-2&
&             , j))*temp_ad21 - br_ad(npx-1)
            br_ad(npx-1) = 0.0_FVPRC
            temp_ad22 = 0.5*xt_ad/(dx(npx, j)+dx(npx+1, j))
            u_ad(npx-2, j) = u_ad(npx-2, j) - dx(npx-1, j)*temp_ad21
            u_ad(npx, j) = u_ad(npx, j) + (dx(npx, j)*2.+dx(npx+1, j))*&
&             temp_ad22
            u_ad(npx+1, j) = u_ad(npx+1, j) - dx(npx, j)*temp_ad22
          ELSE
            CALL POPREALARRAY_ADM(br(npx))
            br_ad(npx) = 0.0_FVPRC
            CALL POPREALARRAY_ADM(bl(npx))
            bl_ad(npx) = 0.0_FVPRC
            CALL POPREALARRAY_ADM(br(npx-1))
            br_ad(npx-1) = 0.0_FVPRC
            CALL POPREALARRAY_ADM(bl(npx-1))
            bl_ad(npx-1) = 0.0_FVPRC
          END IF
          CALL POPREALARRAY_ADM(bl(npx-1))
          xt_ad = br_ad(npx-2) + bl_ad(npx-1)
          u_ad(npx-1, j) = u_ad(npx-1, j) - bl_ad(npx-1)
          bl_ad(npx-1) = 0.0_FVPRC
          CALL POPREALARRAY_ADM(br(npx-2))
          u_ad(npx-2, j) = u_ad(npx-2, j) - br_ad(npx-2)
          br_ad(npx-2) = 0.0_FVPRC
          u_ad(npx-3, j) = u_ad(npx-3, j) + c1*xt_ad
          u_ad(npx-2, j) = u_ad(npx-2, j) + c2*xt_ad
          u_ad(npx-1, j) = u_ad(npx-1, j) + c3*xt_ad
          CALL POPREALARRAY_ADM(bl(npx-2))
          al_ad(npx-2) = al_ad(npx-2) + bl_ad(npx-2)
          u_ad(npx-2, j) = u_ad(npx-2, j) - bl_ad(npx-2)
          bl_ad(npx-2) = 0.0_FVPRC
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREALARRAY_ADM(br(2))
          al_ad(3) = al_ad(3) + br_ad(2)
          u_ad(2, j) = u_ad(2, j) - br_ad(2)
          br_ad(2) = 0.0_FVPRC
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREALARRAY_ADM(bl(2))
            u_ad(1, j) = u_ad(1, j) + c3*bl_ad(2)
            u_ad(2, j) = u_ad(2, j) + (c2-1.0)*bl_ad(2)
            u_ad(3, j) = u_ad(3, j) + c1*bl_ad(2)
            bl_ad(2) = 0.0_FVPRC
            CALL POPREALARRAY_ADM(br(1))
            br_ad(1) = 0.0_FVPRC
            CALL POPREALARRAY_ADM(bl(1))
            bl_ad(1) = 0.0_FVPRC
            CALL POPREALARRAY_ADM(br(0))
            br_ad(0) = 0.0_FVPRC
            CALL POPREALARRAY_ADM(bl(0))
            bl_ad(0) = 0.0_FVPRC
          ELSE
            CALL POPREALARRAY_ADM(bl(2))
            xt_ad = br_ad(1) + bl_ad(2)
            u_ad(2, j) = u_ad(2, j) - bl_ad(2)
            bl_ad(2) = 0.0_FVPRC
            CALL POPREALARRAY_ADM(br(1))
            u_ad(1, j) = u_ad(1, j) + c3*xt_ad - br_ad(1)
            br_ad(1) = 0.0_FVPRC
            u_ad(2, j) = u_ad(2, j) + c2*xt_ad
            u_ad(3, j) = u_ad(3, j) + c1*xt_ad
            CALL POPREALARRAY_ADM(bl(1))
            xt_ad = br_ad(0) + bl_ad(1)
            u_ad(1, j) = u_ad(1, j) - bl_ad(1)
            bl_ad(1) = 0.0_FVPRC
            CALL POPREALARRAY_ADM(br(0))
            temp_ad19 = 0.5*xt_ad/(dx(0, j)+dx(-1, j))
            u_ad(0, j) = u_ad(0, j) + (dx(0, j)*2.+dx(-1, j))*temp_ad19 &
&             - br_ad(0)
            br_ad(0) = 0.0_FVPRC
            temp_ad20 = 0.5*xt_ad/(dx(1, j)+dx(2, j))
            u_ad(-1, j) = u_ad(-1, j) - dx(0, j)*temp_ad19
            u_ad(1, j) = u_ad(1, j) + (dx(1, j)*2.+dx(2, j))*temp_ad20
            u_ad(2, j) = u_ad(2, j) - dx(1, j)*temp_ad20
            CALL POPREALARRAY_ADM(bl(0))
            u_ad(-2, j) = u_ad(-2, j) + c1*bl_ad(0)
            u_ad(-1, j) = u_ad(-1, j) + c2*bl_ad(0)
            u_ad(0, j) = u_ad(0, j) + (c3-1.0)*bl_ad(0)
            bl_ad(0) = 0.0_FVPRC
          END IF
        END IF
 120    DO i=ie3,is3,-1
          CALL POPREALARRAY_ADM(br(i))
          al_ad(i+1) = al_ad(i+1) + br_ad(i)
          u_ad(i, j) = u_ad(i, j) - bl_ad(i) - br_ad(i)
          br_ad(i) = 0.0_FVPRC
          CALL POPREALARRAY_ADM(bl(i))
          al_ad(i) = al_ad(i) + bl_ad(i)
          bl_ad(i) = 0.0_FVPRC
        END DO
        DO i=ie3+1,is3,-1
          u_ad(i-1, j) = u_ad(i-1, j) + p1*al_ad(i)
          u_ad(i, j) = u_ad(i, j) + p1*al_ad(i)
          u_ad(i-2, j) = u_ad(i-2, j) + p2*al_ad(i)
          u_ad(i+1, j) = u_ad(i+1, j) + p2*al_ad(i)
          al_ad(i) = 0.0_FVPRC
        END DO
      END DO
    CASE DEFAULT
! iord = 8, 9, 10
      DO j=js,je+1
        DO i=is-2,ie+2
          CALL PUSHREALARRAY_ADM(xt)
          xt = 0.25*(u(i+1, j)-u(i-1, j))
          IF (xt .GE. 0.) THEN
            x12 = xt
            CALL PUSHCONTROL1B(0)
          ELSE
            x12 = -xt
            CALL PUSHCONTROL1B(1)
          END IF
          IF (u(i-1, j) .LT. u(i, j)) THEN
            IF (u(i, j) .LT. u(i+1, j)) THEN
              max8 = u(i+1, j)
              CALL PUSHCONTROL2B(0)
            ELSE
              max8 = u(i, j)
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE IF (u(i-1, j) .LT. u(i+1, j)) THEN
            max8 = u(i+1, j)
            CALL PUSHCONTROL2B(2)
          ELSE
            max8 = u(i-1, j)
            CALL PUSHCONTROL2B(3)
          END IF
          y11 = max8 - u(i, j)
          IF (u(i-1, j) .GT. u(i, j)) THEN
            IF (u(i, j) .GT. u(i+1, j)) THEN
              min21 = u(i+1, j)
              CALL PUSHCONTROL2B(0)
            ELSE
              min21 = u(i, j)
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE IF (u(i-1, j) .GT. u(i+1, j)) THEN
            min21 = u(i+1, j)
            CALL PUSHCONTROL2B(2)
          ELSE
            min21 = u(i-1, j)
            CALL PUSHCONTROL2B(3)
          END IF
          z7 = u(i, j) - min21
          IF (x12 .GT. y11) THEN
            IF (y11 .GT. z7) THEN
              CALL PUSHREALARRAY_ADM(min11)
              min11 = z7
              CALL PUSHCONTROL2B(0)
            ELSE
              CALL PUSHREALARRAY_ADM(min11)
              min11 = y11
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE IF (x12 .GT. z7) THEN
            CALL PUSHREALARRAY_ADM(min11)
            min11 = z7
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHREALARRAY_ADM(min11)
            min11 = x12
            CALL PUSHCONTROL2B(3)
          END IF
          dm(i) = SIGN(min11, xt)
        END DO
        DO i=is-3,ie+2
          dq(i) = u(i+1, j) - u(i, j)
        END DO
        IF (grid_type .LT. 3) THEN
          DO i=is3,ie3+1
            al(i) = 0.5*(u(i-1, j)+u(i, j)) + r3*(dm(i-1)-dm(i))
          END DO
! Perturbation form:
          IF (iord .EQ. 8) THEN
            DO i=is3,ie3
              CALL PUSHREALARRAY_ADM(xt)
              xt = 2.*dm(i)
              IF (xt .GE. 0.) THEN
                x13 = xt
                CALL PUSHCONTROL1B(0)
              ELSE
                x13 = -xt
                CALL PUSHCONTROL1B(1)
              END IF
              IF (al(i) - u(i, j) .GE. 0.) THEN
                y12 = al(i) - u(i, j)
                CALL PUSHCONTROL1B(0)
              ELSE
                y12 = -(al(i)-u(i, j))
                CALL PUSHCONTROL1B(1)
              END IF
              IF (x13 .GT. y12) THEN
                CALL PUSHREALARRAY_ADM(min12)
                min12 = y12
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHREALARRAY_ADM(min12)
                min12 = x13
                CALL PUSHCONTROL1B(1)
              END IF
              CALL PUSHREALARRAY_ADM(bl(i))
              bl(i) = -SIGN(min12, xt)
              IF (xt .GE. 0.) THEN
                x14 = xt
                CALL PUSHCONTROL1B(0)
              ELSE
                x14 = -xt
                CALL PUSHCONTROL1B(1)
              END IF
              IF (al(i+1) - u(i, j) .GE. 0.) THEN
                y13 = al(i+1) - u(i, j)
                CALL PUSHCONTROL1B(0)
              ELSE
                y13 = -(al(i+1)-u(i, j))
                CALL PUSHCONTROL1B(1)
              END IF
              IF (x14 .GT. y13) THEN
                CALL PUSHREALARRAY_ADM(min13)
                min13 = y13
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHREALARRAY_ADM(min13)
                min13 = x14
                CALL PUSHCONTROL1B(1)
              END IF
              CALL PUSHREALARRAY_ADM(br(i))
              br(i) = SIGN(min13, xt)
            END DO
            CALL PUSHCONTROL2B(0)
          ELSE IF (iord .EQ. 9) THEN
            DO i=is3,ie3
              pmp_1 = -(2.*dq(i))
              lac_1 = pmp_1 + 1.5*dq(i+1)
              IF (0. .LT. pmp_1) THEN
                IF (pmp_1 .LT. lac_1) THEN
                  x15 = lac_1
                  CALL PUSHCONTROL2B(0)
                ELSE
                  x15 = pmp_1
                  CALL PUSHCONTROL2B(1)
                END IF
              ELSE IF (0. .LT. lac_1) THEN
                x15 = lac_1
                CALL PUSHCONTROL2B(2)
              ELSE
                CALL PUSHCONTROL2B(3)
                x15 = 0.
              END IF
              IF (0. .GT. pmp_1) THEN
                IF (pmp_1 .GT. lac_1) THEN
                  y20 = lac_1
                  CALL PUSHCONTROL2B(0)
                ELSE
                  y20 = pmp_1
                  CALL PUSHCONTROL2B(1)
                END IF
              ELSE IF (0. .GT. lac_1) THEN
                y20 = lac_1
                CALL PUSHCONTROL2B(2)
              ELSE
                y20 = 0.
                CALL PUSHCONTROL2B(3)
              END IF
              IF (al(i) - u(i, j) .LT. y20) THEN
                y14 = y20
                CALL PUSHCONTROL1B(0)
              ELSE
                y14 = al(i) - u(i, j)
                CALL PUSHCONTROL1B(1)
              END IF
              IF (x15 .GT. y14) THEN
                CALL PUSHREALARRAY_ADM(bl(i))
                bl(i) = y14
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHREALARRAY_ADM(bl(i))
                bl(i) = x15
                CALL PUSHCONTROL1B(1)
              END IF
              pmp_2 = 2.*dq(i-1)
              lac_2 = pmp_2 - 1.5*dq(i-2)
              IF (0. .LT. pmp_2) THEN
                IF (pmp_2 .LT. lac_2) THEN
                  x16 = lac_2
                  CALL PUSHCONTROL2B(0)
                ELSE
                  x16 = pmp_2
                  CALL PUSHCONTROL2B(1)
                END IF
              ELSE IF (0. .LT. lac_2) THEN
                x16 = lac_2
                CALL PUSHCONTROL2B(2)
              ELSE
                CALL PUSHCONTROL2B(3)
                x16 = 0.
              END IF
              IF (0. .GT. pmp_2) THEN
                IF (pmp_2 .GT. lac_2) THEN
                  y21 = lac_2
                  CALL PUSHCONTROL2B(0)
                ELSE
                  y21 = pmp_2
                  CALL PUSHCONTROL2B(1)
                END IF
              ELSE IF (0. .GT. lac_2) THEN
                y21 = lac_2
                CALL PUSHCONTROL2B(2)
              ELSE
                y21 = 0.
                CALL PUSHCONTROL2B(3)
              END IF
              IF (al(i+1) - u(i, j) .LT. y21) THEN
                y15 = y21
                CALL PUSHCONTROL1B(0)
              ELSE
                y15 = al(i+1) - u(i, j)
                CALL PUSHCONTROL1B(1)
              END IF
              IF (x16 .GT. y15) THEN
                CALL PUSHREALARRAY_ADM(br(i))
                br(i) = y15
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHREALARRAY_ADM(br(i))
                br(i) = x16
                CALL PUSHCONTROL1B(1)
              END IF
            END DO
            CALL PUSHCONTROL2B(1)
          ELSE IF (iord .EQ. 10) THEN
            DO i=is3,ie3
              CALL PUSHREALARRAY_ADM(bl(i))
              bl(i) = al(i) - u(i, j)
              CALL PUSHREALARRAY_ADM(br(i))
              br(i) = al(i+1) - u(i, j)
              IF (dm(i) .GE. 0.) THEN
                abs0 = dm(i)
              ELSE
                abs0 = -dm(i)
              END IF
!             if ( abs(dm(i-1))+abs(dm(i))+abs(dm(i+1)) < near_zero ) then
              IF (abs0 .LT. near_zero) THEN
                IF (dm(i-1) .GE. 0.) THEN
                  abs1 = dm(i-1)
                ELSE
                  abs1 = -dm(i-1)
                END IF
                IF (dm(i+1) .GE. 0.) THEN
                  abs3 = dm(i+1)
                ELSE
                  abs3 = -dm(i+1)
                END IF
                IF (abs1 + abs3 .LT. near_zero) THEN
! 2-delta-x structure detected within 3 cells
                  bl(i) = 0.
                  br(i) = 0.
                  CALL PUSHCONTROL3B(4)
                ELSE
                  CALL PUSHCONTROL3B(3)
                END IF
              ELSE
                IF (3.*(bl(i)+br(i)) .GE. 0.) THEN
                  abs2 = 3.*(bl(i)+br(i))
                ELSE
                  abs2 = -(3.*(bl(i)+br(i)))
                END IF
                IF (bl(i) - br(i) .GE. 0.) THEN
                  abs4 = bl(i) - br(i)
                ELSE
                  abs4 = -(bl(i)-br(i))
                END IF
                IF (abs2 .GT. abs4) THEN
                  pmp_1 = -(2.*dq(i))
                  lac_1 = pmp_1 + 1.5*dq(i+1)
                  IF (0. .LT. pmp_1) THEN
                    IF (pmp_1 .LT. lac_1) THEN
                      x17 = lac_1
                      CALL PUSHCONTROL2B(0)
                    ELSE
                      x17 = pmp_1
                      CALL PUSHCONTROL2B(1)
                    END IF
                  ELSE IF (0. .LT. lac_1) THEN
                    x17 = lac_1
                    CALL PUSHCONTROL2B(2)
                  ELSE
                    CALL PUSHCONTROL2B(3)
                    x17 = 0.
                  END IF
                  IF (0. .GT. pmp_1) THEN
                    IF (pmp_1 .GT. lac_1) THEN
                      y22 = lac_1
                      CALL PUSHCONTROL2B(0)
                    ELSE
                      y22 = pmp_1
                      CALL PUSHCONTROL2B(1)
                    END IF
                  ELSE IF (0. .GT. lac_1) THEN
                    y22 = lac_1
                    CALL PUSHCONTROL2B(2)
                  ELSE
                    y22 = 0.
                    CALL PUSHCONTROL2B(3)
                  END IF
                  IF (bl(i) .LT. y22) THEN
                    y16 = y22
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    y16 = bl(i)
                    CALL PUSHCONTROL1B(1)
                  END IF
                  IF (x17 .GT. y16) THEN
                    bl(i) = y16
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    bl(i) = x17
                    CALL PUSHCONTROL1B(1)
                  END IF
                  pmp_2 = 2.*dq(i-1)
                  lac_2 = pmp_2 - 1.5*dq(i-2)
                  IF (0. .LT. pmp_2) THEN
                    IF (pmp_2 .LT. lac_2) THEN
                      x18 = lac_2
                      CALL PUSHCONTROL2B(0)
                    ELSE
                      x18 = pmp_2
                      CALL PUSHCONTROL2B(1)
                    END IF
                  ELSE IF (0. .LT. lac_2) THEN
                    x18 = lac_2
                    CALL PUSHCONTROL2B(2)
                  ELSE
                    CALL PUSHCONTROL2B(3)
                    x18 = 0.
                  END IF
                  IF (0. .GT. pmp_2) THEN
                    IF (pmp_2 .GT. lac_2) THEN
                      y23 = lac_2
                      CALL PUSHCONTROL2B(0)
                    ELSE
                      y23 = pmp_2
                      CALL PUSHCONTROL2B(1)
                    END IF
                  ELSE IF (0. .GT. lac_2) THEN
                    y23 = lac_2
                    CALL PUSHCONTROL2B(2)
                  ELSE
                    y23 = 0.
                    CALL PUSHCONTROL2B(3)
                  END IF
                  IF (br(i) .LT. y23) THEN
                    y17 = y23
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    y17 = br(i)
                    CALL PUSHCONTROL1B(1)
                  END IF
                  IF (x18 .GT. y17) THEN
                    br(i) = y17
                    CALL PUSHCONTROL3B(1)
                  ELSE
                    br(i) = x18
                    CALL PUSHCONTROL3B(2)
                  END IF
                ELSE
                  CALL PUSHCONTROL3B(0)
                END IF
              END IF
            END DO
            CALL PUSHCONTROL2B(2)
          ELSE
! un-limited:
            DO i=is3,ie3
              CALL PUSHREALARRAY_ADM(bl(i))
              bl(i) = al(i) - u(i, j)
              CALL PUSHREALARRAY_ADM(br(i))
              br(i) = al(i+1) - u(i, j)
            END DO
            CALL PUSHCONTROL2B(3)
          END IF
!--------------
! fix the edges
!--------------
!!! TO DO: separate versions for nested and for cubed-sphere
          IF (is .EQ. 1 .AND. (.NOT.nested)) THEN
            CALL PUSHREALARRAY_ADM(br(2))
            br(2) = al(3) - u(2, j)
            CALL PUSHREALARRAY_ADM(xt)
            xt = s15*u(1, j) + s11*u(2, j) - s14*dm(2)
            CALL PUSHREALARRAY_ADM(bl(2))
            bl(2) = xt - u(2, j)
            CALL PUSHREALARRAY_ADM(br(1))
            br(1) = xt - u(1, j)
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
! out
              CALL PUSHREALARRAY_ADM(bl(0))
              bl(0) = 0.
! edge
              CALL PUSHREALARRAY_ADM(br(0))
              br(0) = 0.
! edge
              CALL PUSHREALARRAY_ADM(bl(1))
              bl(1) = 0.
! in
              CALL PUSHREALARRAY_ADM(br(1))
              br(1) = 0.
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREALARRAY_ADM(bl(0))
              bl(0) = s14*dm(-1) - s11*dq(-1)
!---------------------------------------------------------------
!#ifdef ONE_SIDE
!                 xt = t14*u(0,j) + t12*u(-1,j) + t15*u(-2,j)
!                 br(0) = 2.*xt - u(0,j)
!                 xt = t14*u(1,j) + t12*u(2,j) + t15*u(3,j)
!                 bl(1) = 2.*xt - u(1,j)
!#else
              x0l = 0.5*((2.*dx(0, j)+dx(-1, j))*u(0, j)-dx(0, j)*u(-1, &
&               j))/(dx(0, j)+dx(-1, j))
              x0r = 0.5*((2.*dx(1, j)+dx(2, j))*u(1, j)-dx(1, j)*u(2, j)&
&               )/(dx(1, j)+dx(2, j))
              xt = x0l + x0r
              CALL PUSHREALARRAY_ADM(br(0))
              br(0) = xt - u(0, j)
              CALL PUSHREALARRAY_ADM(bl(1))
              bl(1) = xt - u(1, j)
!#endif
!---------------------------------------------------------------
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREALARRAY_ADM(br(2), 8*bd%ie/8)
            CALL PUSHREALARRAY_ADM(bl(2), 8*bd%ie/8)
            CALL PERT_PPM(1, u(2, j), bl(2), br(2), -1)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (ie + 1 .EQ. npx .AND. (.NOT.nested)) THEN
            CALL PUSHREALARRAY_ADM(bl(npx-2))
            bl(npx-2) = al(npx-2) - u(npx-2, j)
            CALL PUSHREALARRAY_ADM(xt)
            xt = s15*u(npx-1, j) + s11*u(npx-2, j) + s14*dm(npx-2)
            CALL PUSHREALARRAY_ADM(br(npx-2))
            br(npx-2) = xt - u(npx-2, j)
            CALL PUSHREALARRAY_ADM(bl(npx-1))
            bl(npx-1) = xt - u(npx-1, j)
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
! in
              CALL PUSHREALARRAY_ADM(bl(npx-1))
              bl(npx-1) = 0.
! edge
              CALL PUSHREALARRAY_ADM(br(npx-1))
              br(npx-1) = 0.
! edge
              CALL PUSHREALARRAY_ADM(bl(npx))
              bl(npx) = 0.
! out
              CALL PUSHREALARRAY_ADM(br(npx))
              br(npx) = 0.
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREALARRAY_ADM(br(npx))
              br(npx) = s11*dq(npx) - s14*dm(npx+1)
!#ifdef ONE_SIDE
!                 xt = t14*u(npx-1,j) + t12*u(npx-2,j) + t15*u(npx-3,j)
!                 br(npx-1) = 2.*xt - u(npx-1,j)
!                 xt = t14*u(npx,j) + t12*u(npx+1,j) + t15*u(npx+2,j)
!                 bl(npx  ) = 2.*xt - u(npx  ,j)
!#else
              x0l = 0.5*((2.*dx(npx-1, j)+dx(npx-2, j))*u(npx-1, j)-dx(&
&               npx-1, j)*u(npx-2, j))/(dx(npx-1, j)+dx(npx-2, j))
              x0r = 0.5*((2.*dx(npx, j)+dx(npx+1, j))*u(npx, j)-dx(npx, &
&               j)*u(npx+1, j))/(dx(npx, j)+dx(npx+1, j))
              xt = x0l + x0r
              CALL PUSHREALARRAY_ADM(br(npx-1))
              br(npx-1) = xt - u(npx-1, j)
              CALL PUSHREALARRAY_ADM(bl(npx))
              bl(npx) = xt - u(npx, j)
!#endif
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREALARRAY_ADM(br(npx-2), 8*(bd%ie-npx+4)/8)
            CALL PUSHREALARRAY_ADM(bl(npx-2), 8*(bd%ie-npx+4)/8)
            CALL PERT_PPM(1, u(npx-2, j), bl(npx-2), br(npx-2), -1)
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          DO i=is-1,ie+2
            al(i) = 0.5*(u(i-1, j)+u(i, j)) + r3*(dm(i-1)-dm(i))
          END DO
          DO i=is-1,ie+1
            pmp = -(2.*dq(i))
            lac = pmp + 1.5*dq(i+1)
            IF (0. .LT. pmp) THEN
              IF (pmp .LT. lac) THEN
                x19 = lac
                CALL PUSHCONTROL2B(0)
              ELSE
                x19 = pmp
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE IF (0. .LT. lac) THEN
              x19 = lac
              CALL PUSHCONTROL2B(2)
            ELSE
              CALL PUSHCONTROL2B(3)
              x19 = 0.
            END IF
            IF (0. .GT. pmp) THEN
              IF (pmp .GT. lac) THEN
                y24 = lac
                CALL PUSHCONTROL2B(0)
              ELSE
                y24 = pmp
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE IF (0. .GT. lac) THEN
              y24 = lac
              CALL PUSHCONTROL2B(2)
            ELSE
              y24 = 0.
              CALL PUSHCONTROL2B(3)
            END IF
            IF (al(i) - u(i, j) .LT. y24) THEN
              y18 = y24
              CALL PUSHCONTROL1B(0)
            ELSE
              y18 = al(i) - u(i, j)
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x19 .GT. y18) THEN
              CALL PUSHREALARRAY_ADM(bl(i))
              bl(i) = y18
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREALARRAY_ADM(bl(i))
              bl(i) = x19
              CALL PUSHCONTROL1B(1)
            END IF
            pmp = 2.*dq(i-1)
            lac = pmp - 1.5*dq(i-2)
            IF (0. .LT. pmp) THEN
              IF (pmp .LT. lac) THEN
                x20 = lac
                CALL PUSHCONTROL2B(0)
              ELSE
                x20 = pmp
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE IF (0. .LT. lac) THEN
              x20 = lac
              CALL PUSHCONTROL2B(2)
            ELSE
              CALL PUSHCONTROL2B(3)
              x20 = 0.
            END IF
            IF (0. .GT. pmp) THEN
              IF (pmp .GT. lac) THEN
                y25 = lac
                CALL PUSHCONTROL2B(0)
              ELSE
                y25 = pmp
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE IF (0. .GT. lac) THEN
              y25 = lac
              CALL PUSHCONTROL2B(2)
            ELSE
              y25 = 0.
              CALL PUSHCONTROL2B(3)
            END IF
            IF (al(i+1) - u(i, j) .LT. y25) THEN
              y19 = y25
              CALL PUSHCONTROL1B(0)
            ELSE
              y19 = al(i+1) - u(i, j)
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x20 .GT. y19) THEN
              CALL PUSHREALARRAY_ADM(br(i))
              br(i) = y19
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREALARRAY_ADM(br(i))
              br(i) = x20
              CALL PUSHCONTROL1B(1)
            END IF
          END DO
          CALL PUSHCONTROL2B(0)
        END IF
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      dm_ad = 0.0_FVPRC
      dq_ad = 0.0_FVPRC
      al_ad = 0.0_FVPRC
      bl_ad = 0.0_FVPRC
      br_ad = 0.0_FVPRC
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            cfl = c(i, j)*rdx(i, j)
            temp_ad30 = (cfl+1.)*flux_ad(i, j)
            u_ad(i, j) = u_ad(i, j) + flux_ad(i, j)
            cfl_ad = (bl(i)+br(i))*temp_ad30 + (bl(i)+cfl*(bl(i)+br(i)))&
&             *flux_ad(i, j)
            bl_ad(i) = bl_ad(i) + (cfl+1.0)*temp_ad30
            br_ad(i) = br_ad(i) + cfl*temp_ad30
            flux_ad(i, j) = 0.0_FVPRC
            c_ad(i, j) = c_ad(i, j) + rdx(i, j)*cfl_ad
          ELSE
            cfl = c(i, j)*rdx(i-1, j)
            temp0 = bl(i-1) + br(i-1)
            temp_ad29 = (1.-cfl)*flux_ad(i, j)
            u_ad(i-1, j) = u_ad(i-1, j) + flux_ad(i, j)
            cfl_ad = -(temp0*temp_ad29) - (br(i-1)-cfl*temp0)*flux_ad(i&
&             , j)
            br_ad(i-1) = br_ad(i-1) + (1.0-cfl)*temp_ad29
            bl_ad(i-1) = bl_ad(i-1) - cfl*temp_ad29
            flux_ad(i, j) = 0.0_FVPRC
            c_ad(i, j) = c_ad(i, j) + rdx(i-1, j)*cfl_ad
          END IF
        END DO
        CALL POPCONTROL2B(branch)
        IF (branch .EQ. 0) THEN
          DO i=ie+1,is-1,-1
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(br(i))
              y19_ad = br_ad(i)
              br_ad(i) = 0.0_FVPRC
              x20_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(br(i))
              x20_ad = br_ad(i)
              br_ad(i) = 0.0_FVPRC
              y19_ad = 0.0_FVPRC
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              y25_ad = y19_ad
            ELSE
              al_ad(i+1) = al_ad(i+1) + y19_ad
              u_ad(i, j) = u_ad(i, j) - y19_ad
              y25_ad = 0.0_FVPRC
            END IF
            CALL POPCONTROL2B(branch)
            IF (branch .LT. 2) THEN
              IF (branch .EQ. 0) THEN
                lac_ad = y25_ad
                pmp_ad = 0.0_FVPRC
              ELSE
                pmp_ad = y25_ad
                lac_ad = 0.0_FVPRC
              END IF
            ELSE
              IF (branch .EQ. 2) THEN
                lac_ad = y25_ad
              ELSE
                lac_ad = 0.0_FVPRC
              END IF
              pmp_ad = 0.0_FVPRC
            END IF
            CALL POPCONTROL2B(branch)
            IF (branch .LT. 2) THEN
              IF (branch .EQ. 0) THEN
                lac_ad = lac_ad + x20_ad
              ELSE
                pmp_ad = pmp_ad + x20_ad
              END IF
            ELSE IF (branch .EQ. 2) THEN
              lac_ad = lac_ad + x20_ad
            END IF
            pmp_ad = pmp_ad + lac_ad
            dq_ad(i-2) = dq_ad(i-2) - 1.5*lac_ad
            dq_ad(i-1) = dq_ad(i-1) + 2.*pmp_ad
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(bl(i))
              y18_ad = bl_ad(i)
              bl_ad(i) = 0.0_FVPRC
              x19_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(bl(i))
              x19_ad = bl_ad(i)
              bl_ad(i) = 0.0_FVPRC
              y18_ad = 0.0_FVPRC
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              y24_ad = y18_ad
            ELSE
              al_ad(i) = al_ad(i) + y18_ad
              u_ad(i, j) = u_ad(i, j) - y18_ad
              y24_ad = 0.0_FVPRC
            END IF
            CALL POPCONTROL2B(branch)
            IF (branch .LT. 2) THEN
              IF (branch .EQ. 0) THEN
                lac_ad = y24_ad
                pmp_ad = 0.0_FVPRC
              ELSE
                pmp_ad = y24_ad
                lac_ad = 0.0_FVPRC
              END IF
            ELSE
              IF (branch .EQ. 2) THEN
                lac_ad = y24_ad
              ELSE
                lac_ad = 0.0_FVPRC
              END IF
              pmp_ad = 0.0_FVPRC
            END IF
            CALL POPCONTROL2B(branch)
            IF (branch .LT. 2) THEN
              IF (branch .EQ. 0) THEN
                lac_ad = lac_ad + x19_ad
              ELSE
                pmp_ad = pmp_ad + x19_ad
              END IF
            ELSE IF (branch .EQ. 2) THEN
              lac_ad = lac_ad + x19_ad
            END IF
            pmp_ad = pmp_ad + lac_ad
            dq_ad(i+1) = dq_ad(i+1) + 1.5*lac_ad
            dq_ad(i) = dq_ad(i) - 2.*pmp_ad
          END DO
          DO i=ie+2,is-1,-1
            u_ad(i-1, j) = u_ad(i-1, j) + 0.5*al_ad(i)
            u_ad(i, j) = u_ad(i, j) + 0.5*al_ad(i)
            dm_ad(i-1) = dm_ad(i-1) + r3*al_ad(i)
            dm_ad(i) = dm_ad(i) - r3*al_ad(i)
            al_ad(i) = 0.0_FVPRC
          END DO
        ELSE
          IF (branch .NE. 1) THEN
            CALL POPREALARRAY_ADM(bl(npx-2), 8*(bd%ie-npx+4)/8)
            CALL POPREALARRAY_ADM(br(npx-2), 8*(bd%ie-npx+4)/8)
            CALL PERT_PPM_ADM(1, u(npx-2, j), bl(npx-2:), bl_ad(npx-2:)&
&                       , br(npx-2:), br_ad(npx-2:), -1)
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(br(npx))
              br_ad(npx) = 0.0_FVPRC
              CALL POPREALARRAY_ADM(bl(npx))
              bl_ad(npx) = 0.0_FVPRC
              CALL POPREALARRAY_ADM(br(npx-1))
              br_ad(npx-1) = 0.0_FVPRC
              CALL POPREALARRAY_ADM(bl(npx-1))
              bl_ad(npx-1) = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(bl(npx))
              xt_ad = br_ad(npx-1) + bl_ad(npx)
              u_ad(npx, j) = u_ad(npx, j) - bl_ad(npx)
              bl_ad(npx) = 0.0_FVPRC
              CALL POPREALARRAY_ADM(br(npx-1))
              u_ad(npx-1, j) = u_ad(npx-1, j) - br_ad(npx-1)
              br_ad(npx-1) = 0.0_FVPRC
              x0l_ad = xt_ad
              x0r_ad = xt_ad
              temp_ad27 = 0.5*x0r_ad/(dx(npx, j)+dx(npx+1, j))
              u_ad(npx, j) = u_ad(npx, j) + (dx(npx, j)*2.+dx(npx+1, j))&
&               *temp_ad27
              u_ad(npx+1, j) = u_ad(npx+1, j) - dx(npx, j)*temp_ad27
              temp_ad28 = 0.5*x0l_ad/(dx(npx-1, j)+dx(npx-2, j))
              u_ad(npx-1, j) = u_ad(npx-1, j) + (dx(npx-1, j)*2.+dx(npx-&
&               2, j))*temp_ad28
              u_ad(npx-2, j) = u_ad(npx-2, j) - dx(npx-1, j)*temp_ad28
              CALL POPREALARRAY_ADM(br(npx))
              dq_ad(npx) = dq_ad(npx) + s11*br_ad(npx)
              dm_ad(npx+1) = dm_ad(npx+1) - s14*br_ad(npx)
              br_ad(npx) = 0.0_FVPRC
            END IF
            CALL POPREALARRAY_ADM(bl(npx-1))
            xt_ad = br_ad(npx-2) + bl_ad(npx-1)
            u_ad(npx-1, j) = u_ad(npx-1, j) - bl_ad(npx-1)
            bl_ad(npx-1) = 0.0_FVPRC
            CALL POPREALARRAY_ADM(br(npx-2))
            u_ad(npx-2, j) = u_ad(npx-2, j) - br_ad(npx-2)
            br_ad(npx-2) = 0.0_FVPRC
            CALL POPREALARRAY_ADM(xt)
            u_ad(npx-1, j) = u_ad(npx-1, j) + s15*xt_ad
            u_ad(npx-2, j) = u_ad(npx-2, j) + s11*xt_ad - bl_ad(npx-2)
            dm_ad(npx-2) = dm_ad(npx-2) + s14*xt_ad
            CALL POPREALARRAY_ADM(bl(npx-2))
            al_ad(npx-2) = al_ad(npx-2) + bl_ad(npx-2)
            bl_ad(npx-2) = 0.0_FVPRC
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREALARRAY_ADM(bl(2), 8*bd%ie/8)
            CALL POPREALARRAY_ADM(br(2), 8*bd%ie/8)
            CALL PERT_PPM_ADM(1, u(2, j), bl(2:), bl_ad(2:), br(2:), &
&                       br_ad(2:), -1)
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(br(1))
              br_ad(1) = 0.0_FVPRC
              CALL POPREALARRAY_ADM(bl(1))
              bl_ad(1) = 0.0_FVPRC
              CALL POPREALARRAY_ADM(br(0))
              br_ad(0) = 0.0_FVPRC
              CALL POPREALARRAY_ADM(bl(0))
              bl_ad(0) = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(bl(1))
              xt_ad = br_ad(0) + bl_ad(1)
              u_ad(1, j) = u_ad(1, j) - bl_ad(1)
              bl_ad(1) = 0.0_FVPRC
              CALL POPREALARRAY_ADM(br(0))
              u_ad(0, j) = u_ad(0, j) - br_ad(0)
              br_ad(0) = 0.0_FVPRC
              x0l_ad = xt_ad
              x0r_ad = xt_ad
              temp_ad25 = 0.5*x0r_ad/(dx(1, j)+dx(2, j))
              u_ad(1, j) = u_ad(1, j) + (dx(1, j)*2.+dx(2, j))*temp_ad25
              u_ad(2, j) = u_ad(2, j) - dx(1, j)*temp_ad25
              temp_ad26 = 0.5*x0l_ad/(dx(0, j)+dx(-1, j))
              u_ad(0, j) = u_ad(0, j) + (dx(0, j)*2.+dx(-1, j))*&
&               temp_ad26
              u_ad(-1, j) = u_ad(-1, j) - dx(0, j)*temp_ad26
              CALL POPREALARRAY_ADM(bl(0))
              dm_ad(-1) = dm_ad(-1) + s14*bl_ad(0)
              dq_ad(-1) = dq_ad(-1) - s11*bl_ad(0)
              bl_ad(0) = 0.0_FVPRC
            END IF
            CALL POPREALARRAY_ADM(br(1))
            xt_ad = bl_ad(2) + br_ad(1)
            u_ad(1, j) = u_ad(1, j) - br_ad(1)
            br_ad(1) = 0.0_FVPRC
            CALL POPREALARRAY_ADM(bl(2))
            u_ad(2, j) = u_ad(2, j) - bl_ad(2)
            bl_ad(2) = 0.0_FVPRC
            CALL POPREALARRAY_ADM(xt)
            u_ad(1, j) = u_ad(1, j) + s15*xt_ad
            u_ad(2, j) = u_ad(2, j) + s11*xt_ad - br_ad(2)
            dm_ad(2) = dm_ad(2) - s14*xt_ad
            CALL POPREALARRAY_ADM(br(2))
            al_ad(3) = al_ad(3) + br_ad(2)
            br_ad(2) = 0.0_FVPRC
          END IF
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              DO i=ie3,is3,-1
                CALL POPREALARRAY_ADM(br(i))
                min13_ad = SIGN(1.d0, min13*xt)*br_ad(i)
                br_ad(i) = 0.0_FVPRC
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  CALL POPREALARRAY_ADM(min13)
                  y13_ad = min13_ad
                  x14_ad = 0.0_FVPRC
                ELSE
                  CALL POPREALARRAY_ADM(min13)
                  x14_ad = min13_ad
                  y13_ad = 0.0_FVPRC
                END IF
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  al_ad(i+1) = al_ad(i+1) + y13_ad
                  u_ad(i, j) = u_ad(i, j) - y13_ad
                ELSE
                  u_ad(i, j) = u_ad(i, j) + y13_ad
                  al_ad(i+1) = al_ad(i+1) - y13_ad
                END IF
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  xt_ad = x14_ad
                ELSE
                  xt_ad = -x14_ad
                END IF
                CALL POPREALARRAY_ADM(bl(i))
                min12_ad = -(SIGN(1.d0, min12*xt)*bl_ad(i))
                bl_ad(i) = 0.0_FVPRC
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  CALL POPREALARRAY_ADM(min12)
                  y12_ad = min12_ad
                  x13_ad = 0.0_FVPRC
                ELSE
                  CALL POPREALARRAY_ADM(min12)
                  x13_ad = min12_ad
                  y12_ad = 0.0_FVPRC
                END IF
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  al_ad(i) = al_ad(i) + y12_ad
                  u_ad(i, j) = u_ad(i, j) - y12_ad
                ELSE
                  u_ad(i, j) = u_ad(i, j) + y12_ad
                  al_ad(i) = al_ad(i) - y12_ad
                END IF
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  xt_ad = xt_ad + x13_ad
                ELSE
                  xt_ad = xt_ad - x13_ad
                END IF
                CALL POPREALARRAY_ADM(xt)
                dm_ad(i) = dm_ad(i) + 2.*xt_ad
              END DO
            ELSE
              DO i=ie3,is3,-1
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  CALL POPREALARRAY_ADM(br(i))
                  y15_ad = br_ad(i)
                  br_ad(i) = 0.0_FVPRC
                  x16_ad = 0.0_FVPRC
                ELSE
                  CALL POPREALARRAY_ADM(br(i))
                  x16_ad = br_ad(i)
                  br_ad(i) = 0.0_FVPRC
                  y15_ad = 0.0_FVPRC
                END IF
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  y21_ad = y15_ad
                ELSE
                  al_ad(i+1) = al_ad(i+1) + y15_ad
                  u_ad(i, j) = u_ad(i, j) - y15_ad
                  y21_ad = 0.0_FVPRC
                END IF
                CALL POPCONTROL2B(branch)
                IF (branch .LT. 2) THEN
                  IF (branch .EQ. 0) THEN
                    lac_2_ad = y21_ad
                    pmp_2_ad = 0.0_FVPRC
                  ELSE
                    pmp_2_ad = y21_ad
                    lac_2_ad = 0.0_FVPRC
                  END IF
                ELSE
                  IF (branch .EQ. 2) THEN
                    lac_2_ad = y21_ad
                  ELSE
                    lac_2_ad = 0.0_FVPRC
                  END IF
                  pmp_2_ad = 0.0_FVPRC
                END IF
                CALL POPCONTROL2B(branch)
                IF (branch .LT. 2) THEN
                  IF (branch .EQ. 0) THEN
                    lac_2_ad = lac_2_ad + x16_ad
                  ELSE
                    pmp_2_ad = pmp_2_ad + x16_ad
                  END IF
                ELSE IF (branch .EQ. 2) THEN
                  lac_2_ad = lac_2_ad + x16_ad
                END IF
                pmp_2_ad = pmp_2_ad + lac_2_ad
                dq_ad(i-2) = dq_ad(i-2) - 1.5*lac_2_ad
                dq_ad(i-1) = dq_ad(i-1) + 2.*pmp_2_ad
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  CALL POPREALARRAY_ADM(bl(i))
                  y14_ad = bl_ad(i)
                  bl_ad(i) = 0.0_FVPRC
                  x15_ad = 0.0_FVPRC
                ELSE
                  CALL POPREALARRAY_ADM(bl(i))
                  x15_ad = bl_ad(i)
                  bl_ad(i) = 0.0_FVPRC
                  y14_ad = 0.0_FVPRC
                END IF
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  y20_ad = y14_ad
                ELSE
                  al_ad(i) = al_ad(i) + y14_ad
                  u_ad(i, j) = u_ad(i, j) - y14_ad
                  y20_ad = 0.0_FVPRC
                END IF
                CALL POPCONTROL2B(branch)
                IF (branch .LT. 2) THEN
                  IF (branch .EQ. 0) THEN
                    lac_1_ad = y20_ad
                    pmp_1_ad = 0.0_FVPRC
                  ELSE
                    pmp_1_ad = y20_ad
                    lac_1_ad = 0.0_FVPRC
                  END IF
                ELSE
                  IF (branch .EQ. 2) THEN
                    lac_1_ad = y20_ad
                  ELSE
                    lac_1_ad = 0.0_FVPRC
                  END IF
                  pmp_1_ad = 0.0_FVPRC
                END IF
                CALL POPCONTROL2B(branch)
                IF (branch .LT. 2) THEN
                  IF (branch .EQ. 0) THEN
                    lac_1_ad = lac_1_ad + x15_ad
                  ELSE
                    pmp_1_ad = pmp_1_ad + x15_ad
                  END IF
                ELSE IF (branch .EQ. 2) THEN
                  lac_1_ad = lac_1_ad + x15_ad
                END IF
                pmp_1_ad = pmp_1_ad + lac_1_ad
                dq_ad(i+1) = dq_ad(i+1) + 1.5*lac_1_ad
                dq_ad(i) = dq_ad(i) - 2.*pmp_1_ad
              END DO
            END IF
          ELSE IF (branch .EQ. 2) THEN
            DO i=ie3,is3,-1
              CALL POPCONTROL3B(branch)
              IF (branch .LT. 2) THEN
                IF (branch .EQ. 0) THEN
                  GOTO 130
                ELSE
                  y17_ad = br_ad(i)
                  br_ad(i) = 0.0_FVPRC
                  x18_ad = 0.0_FVPRC
                END IF
              ELSE IF (branch .EQ. 2) THEN
                x18_ad = br_ad(i)
                br_ad(i) = 0.0_FVPRC
                y17_ad = 0.0_FVPRC
              ELSE
                IF (branch .NE. 3) THEN
                  br_ad(i) = 0.0_FVPRC
                  bl_ad(i) = 0.0_FVPRC
                END IF
                GOTO 130
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                y23_ad = y17_ad
              ELSE
                br_ad(i) = br_ad(i) + y17_ad
                y23_ad = 0.0_FVPRC
              END IF
              CALL POPCONTROL2B(branch)
              IF (branch .LT. 2) THEN
                IF (branch .EQ. 0) THEN
                  lac_2_ad = y23_ad
                  pmp_2_ad = 0.0_FVPRC
                ELSE
                  pmp_2_ad = y23_ad
                  lac_2_ad = 0.0_FVPRC
                END IF
              ELSE
                IF (branch .EQ. 2) THEN
                  lac_2_ad = y23_ad
                ELSE
                  lac_2_ad = 0.0_FVPRC
                END IF
                pmp_2_ad = 0.0_FVPRC
              END IF
              CALL POPCONTROL2B(branch)
              IF (branch .LT. 2) THEN
                IF (branch .EQ. 0) THEN
                  lac_2_ad = lac_2_ad + x18_ad
                ELSE
                  pmp_2_ad = pmp_2_ad + x18_ad
                END IF
              ELSE IF (branch .EQ. 2) THEN
                lac_2_ad = lac_2_ad + x18_ad
              END IF
              pmp_2_ad = pmp_2_ad + lac_2_ad
              dq_ad(i-2) = dq_ad(i-2) - 1.5*lac_2_ad
              dq_ad(i-1) = dq_ad(i-1) + 2.*pmp_2_ad
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                y16_ad = bl_ad(i)
                bl_ad(i) = 0.0_FVPRC
                x17_ad = 0.0_FVPRC
              ELSE
                x17_ad = bl_ad(i)
                bl_ad(i) = 0.0_FVPRC
                y16_ad = 0.0_FVPRC
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                y22_ad = y16_ad
              ELSE
                bl_ad(i) = bl_ad(i) + y16_ad
                y22_ad = 0.0_FVPRC
              END IF
              CALL POPCONTROL2B(branch)
              IF (branch .LT. 2) THEN
                IF (branch .EQ. 0) THEN
                  lac_1_ad = y22_ad
                  pmp_1_ad = 0.0_FVPRC
                ELSE
                  pmp_1_ad = y22_ad
                  lac_1_ad = 0.0_FVPRC
                END IF
              ELSE
                IF (branch .EQ. 2) THEN
                  lac_1_ad = y22_ad
                ELSE
                  lac_1_ad = 0.0_FVPRC
                END IF
                pmp_1_ad = 0.0_FVPRC
              END IF
              CALL POPCONTROL2B(branch)
              IF (branch .LT. 2) THEN
                IF (branch .EQ. 0) THEN
                  lac_1_ad = lac_1_ad + x17_ad
                ELSE
                  pmp_1_ad = pmp_1_ad + x17_ad
                END IF
              ELSE IF (branch .EQ. 2) THEN
                lac_1_ad = lac_1_ad + x17_ad
              END IF
              pmp_1_ad = pmp_1_ad + lac_1_ad
              dq_ad(i+1) = dq_ad(i+1) + 1.5*lac_1_ad
              dq_ad(i) = dq_ad(i) - 2.*pmp_1_ad
 130          CALL POPREALARRAY_ADM(br(i))
              al_ad(i+1) = al_ad(i+1) + br_ad(i)
              u_ad(i, j) = u_ad(i, j) - bl_ad(i) - br_ad(i)
              br_ad(i) = 0.0_FVPRC
              CALL POPREALARRAY_ADM(bl(i))
              al_ad(i) = al_ad(i) + bl_ad(i)
              bl_ad(i) = 0.0_FVPRC
            END DO
          ELSE
            DO i=ie3,is3,-1
              CALL POPREALARRAY_ADM(br(i))
              al_ad(i+1) = al_ad(i+1) + br_ad(i)
              u_ad(i, j) = u_ad(i, j) - bl_ad(i) - br_ad(i)
              br_ad(i) = 0.0_FVPRC
              CALL POPREALARRAY_ADM(bl(i))
              al_ad(i) = al_ad(i) + bl_ad(i)
              bl_ad(i) = 0.0_FVPRC
            END DO
          END IF
          DO i=ie3+1,is3,-1
            u_ad(i-1, j) = u_ad(i-1, j) + 0.5*al_ad(i)
            u_ad(i, j) = u_ad(i, j) + 0.5*al_ad(i)
            dm_ad(i-1) = dm_ad(i-1) + r3*al_ad(i)
            dm_ad(i) = dm_ad(i) - r3*al_ad(i)
            al_ad(i) = 0.0_FVPRC
          END DO
        END IF
        DO i=ie+2,is-3,-1
          u_ad(i+1, j) = u_ad(i+1, j) + dq_ad(i)
          u_ad(i, j) = u_ad(i, j) - dq_ad(i)
          dq_ad(i) = 0.0_FVPRC
        END DO
        DO i=ie+2,is-2,-1
          xt = 0.25*(u(i+1, j)-u(i-1, j))
          min11_ad = SIGN(1.d0, min11*xt)*dm_ad(i)
          dm_ad(i) = 0.0_FVPRC
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(min11)
              z7_ad = min11_ad
              y11_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min11)
              y11_ad = min11_ad
              z7_ad = 0.0_FVPRC
            END IF
            x12_ad = 0.0_FVPRC
          ELSE
            IF (branch .EQ. 2) THEN
              CALL POPREALARRAY_ADM(min11)
              z7_ad = min11_ad
              x12_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min11)
              x12_ad = min11_ad
              z7_ad = 0.0_FVPRC
            END IF
            y11_ad = 0.0_FVPRC
          END IF
          u_ad(i, j) = u_ad(i, j) + z7_ad
          min21_ad = -z7_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              u_ad(i+1, j) = u_ad(i+1, j) + min21_ad
            ELSE
              u_ad(i, j) = u_ad(i, j) + min21_ad
            END IF
          ELSE IF (branch .EQ. 2) THEN
            u_ad(i+1, j) = u_ad(i+1, j) + min21_ad
          ELSE
            u_ad(i-1, j) = u_ad(i-1, j) + min21_ad
          END IF
          max8_ad = y11_ad
          u_ad(i, j) = u_ad(i, j) - y11_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              u_ad(i+1, j) = u_ad(i+1, j) + max8_ad
            ELSE
              u_ad(i, j) = u_ad(i, j) + max8_ad
            END IF
          ELSE IF (branch .EQ. 2) THEN
            u_ad(i+1, j) = u_ad(i+1, j) + max8_ad
          ELSE
            u_ad(i-1, j) = u_ad(i-1, j) + max8_ad
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            xt_ad = x12_ad
          ELSE
            xt_ad = -x12_ad
          END IF
          CALL POPREALARRAY_ADM(xt)
          u_ad(i+1, j) = u_ad(i+1, j) + 0.25*xt_ad
          u_ad(i-1, j) = u_ad(i-1, j) - 0.25*xt_ad
        END DO
      END DO
    END SELECT
    CALL POPCONTROL1B(branch)
  END SUBROUTINE XTP_U_ADM
  SUBROUTINE XTP_U(c, u, v, flux, iord, cosa, dx, rdx, bd, npx, npy, &
&   grid_type, nested)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(IN) :: c(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(OUT) :: flux(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(IN) :: dx(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: rdx(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: cosa(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
    INTEGER, INTENT(IN) :: iord, npx, npy, grid_type
    LOGICAL, INTENT(IN) :: nested
! Local
    LOGICAL :: extm(bd%is-2:bd%ie+2)
    REAL(fvprc) :: al(bd%is-1:bd%ie+2), dm(bd%is-2:bd%ie+2)
    REAL(fvprc) :: bl(bd%is-1:bd%ie+1)
    REAL(fvprc) :: br(bd%is-1:bd%ie+1)
    REAL(fvprc) :: dq(bd%is-3:bd%ie+2)
    REAL(fvprc) :: dl, dr, xt, pmp, lac, cfl
    REAL(fvprc) :: pmp_1, lac_1, pmp_2, lac_2
    REAL(fvprc) :: x0, x1, x0l, x0r
    INTEGER :: i, j
    INTEGER :: is3, ie3
    INTEGER :: is, ie, js, je
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC SIGN
    REAL(fvprc) :: min1
    REAL(fvprc) :: min2
    REAL(fvprc) :: min3
    REAL(fvprc) :: min4
    REAL(fvprc) :: min5
    REAL(fvprc) :: min6
    INTEGER :: max1
    REAL(fvprc) :: min7
    REAL(fvprc) :: min8
    REAL(fvprc) :: min9
    REAL(fvprc) :: min10
    REAL(fvprc) :: min11
    REAL(fvprc) :: min12
    REAL(fvprc) :: min13
    REAL(fvprc) :: abs0
    REAL(fvprc) :: abs1
    REAL(fvprc) :: abs2
    REAL(fvprc) :: max2
    REAL(fvprc) :: min14
    REAL(fvprc) :: max3
    REAL(fvprc) :: min15
    REAL(fvprc) :: max4
    REAL(fvprc) :: min16
    REAL(fvprc) :: max5
    REAL(fvprc) :: min17
    REAL(fvprc) :: max6
    REAL(fvprc) :: min18
    REAL(fvprc) :: max7
    REAL(fvprc) :: min19
    INTEGER :: min20
    REAL(fvprc) :: max8
    REAL(fvprc) :: min21
    REAL(fvprc) :: abs3
    REAL(fvprc) :: abs4
    REAL(fvprc) :: x19
    REAL(fvprc) :: x18
    REAL(fvprc) :: x17
    REAL(fvprc) :: x16
    REAL(fvprc) :: x15
    REAL(fvprc) :: x14
    REAL(fvprc) :: x13
    REAL(fvprc) :: x12
    REAL(fvprc) :: x11
    REAL(fvprc) :: x10
    REAL(fvprc) :: y25
    REAL(fvprc) :: y24
    REAL(fvprc) :: y23
    REAL(fvprc) :: y22
    REAL(fvprc) :: y21
    REAL(fvprc) :: y20
    REAL(fvprc) :: x9
    REAL(fvprc) :: x8
    REAL(fvprc) :: x7
    REAL(fvprc) :: x6
    REAL(fvprc) :: x5
    REAL(fvprc) :: x4
    REAL(fvprc) :: x3
    REAL(fvprc) :: x2
    REAL(fvprc) :: y19
    REAL(fvprc) :: y18
    REAL(fvprc) :: y17
    REAL(fvprc) :: y16
    REAL(fvprc) :: y15
    REAL(fvprc) :: y14
    REAL(fvprc) :: y13
    REAL(fvprc) :: y12
    REAL(fvprc) :: y11
    REAL(fvprc) :: y10
    REAL(fvprc) :: z7
    REAL(fvprc) :: z6
    REAL(fvprc) :: z5
    REAL(fvprc) :: z4
    REAL(fvprc) :: z3
    REAL(fvprc) :: z2
    REAL(fvprc) :: z1
    REAL(fvprc) :: x20
    REAL(fvprc) :: y9
    REAL(fvprc) :: y8
    REAL(fvprc) :: y7
    REAL(fvprc) :: y6
    REAL(fvprc) :: y5
    REAL(fvprc) :: y4
    REAL(fvprc) :: y3
    REAL(fvprc) :: y2
    REAL(fvprc) :: y1
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    IF (nested .OR. grid_type .GT. 3) THEN
      is3 = is - 1
      ie3 = ie + 1
    ELSE
      IF (3 .LT. is - 1) THEN
        is3 = is - 1
      ELSE
        is3 = 3
      END IF
      IF (npx - 3 .GT. ie + 1) THEN
        ie3 = ie + 1
      ELSE
        ie3 = npx - 3
      END IF
    END IF
    SELECT CASE  (iord) 
    CASE (1) 
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            flux(i, j) = u(i-1, j)
          ELSE
            flux(i, j) = u(i, j)
          END IF
        END DO
      END DO
    CASE (333) 
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            flux(i, j) = (2.0*u(i, j)+5.0*u(i-1, j)-u(i-2, j))/6.0 - 0.5&
&             *c(i, j)*rdx(i-1, j)*(u(i, j)-u(i-1, j)) + c(i, j)*rdx(i-1&
&             , j)*c(i, j)*rdx(i-1, j)/6.0*(u(i, j)-2.0*u(i-1, j)+u(i-2&
&             , j))
          ELSE
            flux(i, j) = (2.0*u(i-1, j)+5.0*u(i, j)-u(i+1, j))/6.0 - 0.5&
&             *c(i, j)*rdx(i, j)*(u(i, j)-u(i-1, j)) + c(i, j)*rdx(i, j)&
&             *c(i, j)*rdx(i, j)/6.0*(u(i+1, j)-2.0*u(i, j)+u(i-1, j))
          END IF
        END DO
      END DO
    CASE (2) 
      DO j=js,je+1
        DO i=is-2,ie+2
          xt = 0.25*(u(i+1, j)-u(i-1, j))
          IF (xt .GE. 0.) THEN
            x2 = xt
          ELSE
            x2 = -xt
          END IF
          IF (u(i-1, j) .LT. u(i, j)) THEN
            IF (u(i, j) .LT. u(i+1, j)) THEN
              max2 = u(i+1, j)
            ELSE
              max2 = u(i, j)
            END IF
          ELSE IF (u(i-1, j) .LT. u(i+1, j)) THEN
            max2 = u(i+1, j)
          ELSE
            max2 = u(i-1, j)
          END IF
          y1 = max2 - u(i, j)
          IF (u(i-1, j) .GT. u(i, j)) THEN
            IF (u(i, j) .GT. u(i+1, j)) THEN
              min14 = u(i+1, j)
            ELSE
              min14 = u(i, j)
            END IF
          ELSE IF (u(i-1, j) .GT. u(i+1, j)) THEN
            min14 = u(i+1, j)
          ELSE
            min14 = u(i-1, j)
          END IF
          z1 = u(i, j) - min14
          IF (x2 .GT. y1) THEN
            IF (y1 .GT. z1) THEN
              min1 = z1
            ELSE
              min1 = y1
            END IF
          ELSE IF (x2 .GT. z1) THEN
            min1 = z1
          ELSE
            min1 = x2
          END IF
          dm(i) = SIGN(min1, xt)
        END DO
! Fix slopes near edges:
!!! TO DO: separate versions for nested and for cubed-sphere
        IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
          IF (is .EQ. 1) THEN
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
              dm(0) = 0.
              dm(1) = 0.
            ELSE
              x0l = 0.5*((2.*dx(0, j)+dx(-1, j))*u(0, j)-dx(0, j)*u(-1, &
&               j))/(dx(0, j)+dx(-1, j))
              x0r = 0.5*((2.*dx(1, j)+dx(2, j))*u(1, j)-dx(1, j)*u(2, j)&
&               )/(dx(1, j)+dx(2, j))
              x0 = x0l + x0r
              x1 = s15*u(0, j) + s11*u(-1, j) + s14*dm(-1)
!          dm(0) = u(0,j) - x1
              dm(0) = 0.5*(x0-x1)
              IF (dm(0) .GE. 0.) THEN
                x3 = dm(0)
              ELSE
                x3 = -dm(0)
              END IF
              IF (u(0, j) .LT. x0) THEN
                IF (x0 .LT. x1) THEN
                  max3 = x1
                ELSE
                  max3 = x0
                END IF
              ELSE IF (u(0, j) .LT. x1) THEN
                max3 = x1
              ELSE
                max3 = u(0, j)
              END IF
              y2 = max3 - u(0, j)
              IF (u(0, j) .GT. x0) THEN
                IF (x0 .GT. x1) THEN
                  min15 = x1
                ELSE
                  min15 = x0
                END IF
              ELSE IF (u(0, j) .GT. x1) THEN
                min15 = x1
              ELSE
                min15 = u(0, j)
              END IF
              z2 = u(0, j) - min15
              IF (x3 .GT. y2) THEN
                IF (y2 .GT. z2) THEN
                  min2 = z2
                ELSE
                  min2 = y2
                END IF
              ELSE IF (x3 .GT. z2) THEN
                min2 = z2
              ELSE
                min2 = x3
              END IF
              dm(0) = SIGN(min2, dm(0))
              x1 = s15*u(1, j) + s11*u(2, j) - s14*dm(2)
!          dm(1) = x1 - u(1,j)
              dm(1) = 0.5*(x1-x0)
              IF (dm(1) .GE. 0.) THEN
                x4 = dm(1)
              ELSE
                x4 = -dm(1)
              END IF
              IF (u(1, j) .LT. x0) THEN
                IF (x0 .LT. x1) THEN
                  max4 = x1
                ELSE
                  max4 = x0
                END IF
              ELSE IF (u(1, j) .LT. x1) THEN
                max4 = x1
              ELSE
                max4 = u(1, j)
              END IF
              y3 = max4 - u(1, j)
              IF (u(1, j) .GT. x0) THEN
                IF (x0 .GT. x1) THEN
                  min16 = x1
                ELSE
                  min16 = x0
                END IF
              ELSE IF (u(1, j) .GT. x1) THEN
                min16 = x1
              ELSE
                min16 = u(1, j)
              END IF
              z3 = u(1, j) - min16
              IF (x4 .GT. y3) THEN
                IF (y3 .GT. z3) THEN
                  min3 = z3
                ELSE
                  min3 = y3
                END IF
              ELSE IF (x4 .GT. z3) THEN
                min3 = z3
              ELSE
                min3 = x4
              END IF
              dm(1) = SIGN(min3, dm(1))
            END IF
          END IF
          IF (ie + 1 .EQ. npx) THEN
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
              dm(npx-1) = 0.
              dm(npx) = 0.
            ELSE
              x0l = 0.5*((2.*dx(npx-1, j)+dx(npx-2, j))*u(npx-1, j)-dx(&
&               npx-1, j)*u(npx-2, j))/(dx(npx-1, j)+dx(npx-2, j))
              x0r = 0.5*((2.*dx(npx, j)+dx(npx+1, j))*u(npx, j)-dx(npx, &
&               j)*u(npx+1, j))/(dx(npx, j)+dx(npx+1, j))
              x0 = x0l + x0r
              x1 = s15*u(npx-1, j) + s11*u(npx-2, j) + s14*dm(npx-2)
!          dm(npx-1) = u(npx-1,j) - x1
              dm(npx-1) = 0.5*(x0-x1)
              IF (dm(npx-1) .GE. 0.) THEN
                x5 = dm(npx-1)
              ELSE
                x5 = -dm(npx-1)
              END IF
              IF (u(npx-1, j) .LT. x0) THEN
                IF (x0 .LT. x1) THEN
                  max5 = x1
                ELSE
                  max5 = x0
                END IF
              ELSE IF (u(npx-1, j) .LT. x1) THEN
                max5 = x1
              ELSE
                max5 = u(npx-1, j)
              END IF
              y4 = max5 - u(npx-1, j)
              IF (u(npx-1, j) .GT. x0) THEN
                IF (x0 .GT. x1) THEN
                  min17 = x1
                ELSE
                  min17 = x0
                END IF
              ELSE IF (u(npx-1, j) .GT. x1) THEN
                min17 = x1
              ELSE
                min17 = u(npx-1, j)
              END IF
              z4 = u(npx-1, j) - min17
              IF (x5 .GT. y4) THEN
                IF (y4 .GT. z4) THEN
                  min4 = z4
                ELSE
                  min4 = y4
                END IF
              ELSE IF (x5 .GT. z4) THEN
                min4 = z4
              ELSE
                min4 = x5
              END IF
              dm(npx-1) = SIGN(min4, dm(npx-1))
              x1 = s15*u(npx, j) + s11*u(npx+1, j) - s14*dm(npx+1)
!          dm(npx) = x1 - u(npx,j)
              dm(npx) = 0.5*(x1-x0)
              IF (dm(npx) .GE. 0.) THEN
                x6 = dm(npx)
              ELSE
                x6 = -dm(npx)
              END IF
              IF (u(npx, j) .LT. x0) THEN
                IF (x0 .LT. x1) THEN
                  max6 = x1
                ELSE
                  max6 = x0
                END IF
              ELSE IF (u(npx, j) .LT. x1) THEN
                max6 = x1
              ELSE
                max6 = u(npx, j)
              END IF
              y5 = max6 - u(npx, j)
              IF (u(npx, j) .GT. x0) THEN
                IF (x0 .GT. x1) THEN
                  min18 = x1
                ELSE
                  min18 = x0
                END IF
              ELSE IF (u(npx, j) .GT. x1) THEN
                min18 = x1
              ELSE
                min18 = u(npx, j)
              END IF
              z5 = u(npx, j) - min18
              IF (x6 .GT. y5) THEN
                IF (y5 .GT. z5) THEN
                  min5 = z5
                ELSE
                  min5 = y5
                END IF
              ELSE IF (x6 .GT. z5) THEN
                min5 = z5
              ELSE
                min5 = x6
              END IF
              dm(npx) = SIGN(min5, dm(npx))
            END IF
          END IF
        END IF
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            flux(i, j) = u(i-1, j) + (1.-c(i, j)*rdx(i-1, j))*dm(i-1)
          ELSE
            flux(i, j) = u(i, j) - (1.+c(i, j)*rdx(i, j))*dm(i)
          END IF
        END DO
      END DO
    CASE (4) 
      DO j=js,je+1
        DO i=is-2,ie+2
          xt = 0.25*(u(i+1, j)-u(i-1, j))
          IF (xt .GE. 0.) THEN
            x7 = xt
          ELSE
            x7 = -xt
          END IF
          IF (u(i-1, j) .LT. u(i, j)) THEN
            IF (u(i, j) .LT. u(i+1, j)) THEN
              max7 = u(i+1, j)
            ELSE
              max7 = u(i, j)
            END IF
          ELSE IF (u(i-1, j) .LT. u(i+1, j)) THEN
            max7 = u(i+1, j)
          ELSE
            max7 = u(i-1, j)
          END IF
          y6 = max7 - u(i, j)
          IF (u(i-1, j) .GT. u(i, j)) THEN
            IF (u(i, j) .GT. u(i+1, j)) THEN
              min19 = u(i+1, j)
            ELSE
              min19 = u(i, j)
            END IF
          ELSE IF (u(i-1, j) .GT. u(i+1, j)) THEN
            min19 = u(i+1, j)
          ELSE
            min19 = u(i-1, j)
          END IF
          z6 = u(i, j) - min19
          IF (x7 .GT. y6) THEN
            IF (y6 .GT. z6) THEN
              min6 = z6
            ELSE
              min6 = y6
            END IF
          ELSE IF (x7 .GT. z6) THEN
            min6 = z6
          ELSE
            min6 = x7
          END IF
          dm(i) = SIGN(min6, xt)
        END DO
        IF (3 .LT. is - 1) THEN
          max1 = is - 1
        ELSE
          max1 = 3
        END IF
        IF (npx - 2 .GT. ie + 2) THEN
          min20 = ie + 2
        ELSE
          min20 = npx - 2
        END IF
        DO i=max1,min20
          al(i) = 0.5*(u(i-1, j)+u(i, j)) + r3*(dm(i-1)-dm(i))
        END DO
! Fix slopes near edges:
        IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
          IF (is .EQ. 1) THEN
            x0l = 0.5*((2.*dx(0, j)+dx(-1, j))*u(0, j)-dx(0, j)*u(-1, j)&
&             )/(dx(0, j)+dx(-1, j))
            x0r = 0.5*((2.*dx(1, j)+dx(2, j))*u(1, j)-dx(1, j)*u(2, j))/&
&             (dx(1, j)+dx(2, j))
            x0 = x0l + x0r
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
              dm(0) = 0.
              dm(1) = 0.
              al(0) = 0.5*(u(-1, j)+u(0, j)) + r3*dm(-1)
              al(1) = x0
              al(2) = 0.5*(u(1, j)+u(2, j)) - r3*dm(2)
            ELSE
              x1 = s15*u(1, j) + s11*u(2, j) - s14*dm(2)
              dm(1) = 0.5*(x1-x0)
!          dm(1) = sign(min(abs(dm(1)), max(u(1,j), x0, x1) - u(1,j),   &
!                              u(1,j) - min(u(1,j), x0, x1)), dm(1))
              x1 = s15*u(0, j) + s11*u(-1, j) + s14*dm(-1)
              dm(0) = 0.5*(x0-x1)
!          dm(0) = sign(min(abs(dm(0)), max(u(0,j), x0, x1) - u(0,j),   &
!                              u(0,j) - min(u(0,j), x0, x1)), dm(0))
              al(0) = 0.5*(u(-1, j)+u(0, j)) + r3*(dm(-1)-dm(0))
              al(1) = x0
              al(2) = 0.5*(u(1, j)+u(2, j)) + r3*(dm(1)-dm(2))
            END IF
          END IF
          IF (ie + 1 .EQ. npx) THEN
            x0l = 0.5*((2.*dx(npx-1, j)+dx(npx-2, j))*u(npx-1, j)-dx(npx&
&             -1, j)*u(npx-2, j))/(dx(npx-1, j)+dx(npx-2, j))
            x0r = 0.5*((2.*dx(npx, j)+dx(npx+1, j))*u(npx, j)-dx(npx, j)&
&             *u(npx+1, j))/(dx(npx, j)+dx(npx+1, j))
            x0 = x0l + x0r
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
              dm(npx-1) = 0.
              dm(npx) = 0.
              al(npx-1) = 0.5*(u(npx-2, j)+u(npx-1, j)) + r3*dm(npx-2)
              al(npx) = x0
              al(npx+1) = 0.5*(u(npx, j)+u(npx+1, j)) - r3*dm(npx+1)
            ELSE
              x1 = s15*u(npx-1, j) + s11*u(npx-2, j) + s14*dm(npx-2)
              dm(npx-1) = 0.5*(x0-x1)
!          dm(npx-1) = sign(min(abs(dm(npx-1)), max(u(npx-1,j), x0, x1) - u(npx-1,j),  &
!                                  u(npx-1,j) - min(u(npx-1,j), x0, x1)), dm(npx-1))
              x1 = s15*u(npx, j) + s11*u(npx+1, j) - s14*dm(npx+1)
              dm(npx) = 0.5*(x1-x0)
!          dm(npx) = sign(min(abs(dm(npx)), max(u(npx,j), x0, x1) - u(npx,j),   &
!                                u(npx,j) - min(u(npx,j), x0, x1)), dm(npx))
              al(npx-1) = 0.5*(u(npx-2, j)+u(npx-1, j)) + r3*(dm(npx-2)-&
&               dm(npx-1))
              al(npx) = x0
              al(npx+1) = 0.5*(u(npx, j)+u(npx+1, j)) + r3*(dm(npx)-dm(&
&               npx+1))
            END IF
          END IF
        END IF
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            xt = 2.*dm(i-1)
            IF (xt .GE. 0.) THEN
              x8 = xt
            ELSE
              x8 = -xt
            END IF
            IF (al(i-1) - u(i-1, j) .GE. 0.) THEN
              y7 = al(i-1) - u(i-1, j)
            ELSE
              y7 = -(al(i-1)-u(i-1, j))
            END IF
            IF (x8 .GT. y7) THEN
              min7 = y7
            ELSE
              min7 = x8
            END IF
            dl = SIGN(min7, xt)
            IF (xt .GE. 0.) THEN
              x9 = xt
            ELSE
              x9 = -xt
            END IF
            IF (al(i) - u(i-1, j) .GE. 0.) THEN
              y8 = al(i) - u(i-1, j)
            ELSE
              y8 = -(al(i)-u(i-1, j))
            END IF
            IF (x9 .GT. y8) THEN
              min8 = y8
            ELSE
              min8 = x9
            END IF
            dr = SIGN(min8, xt)
            cfl = c(i, j)*rdx(i-1, j)
            flux(i, j) = u(i-1, j) + (1.-cfl)*(dr+cfl*(dl-dr))
          ELSE
            xt = 2.*dm(i)
            IF (xt .GE. 0.) THEN
              x10 = xt
            ELSE
              x10 = -xt
            END IF
            IF (al(i) - u(i, j) .GE. 0.) THEN
              y9 = al(i) - u(i, j)
            ELSE
              y9 = -(al(i)-u(i, j))
            END IF
            IF (x10 .GT. y9) THEN
              min9 = y9
            ELSE
              min9 = x10
            END IF
            dl = SIGN(min9, xt)
            IF (xt .GE. 0.) THEN
              x11 = xt
            ELSE
              x11 = -xt
            END IF
            IF (al(i+1) - u(i, j) .GE. 0.) THEN
              y10 = al(i+1) - u(i, j)
            ELSE
              y10 = -(al(i+1)-u(i, j))
            END IF
            IF (x11 .GT. y10) THEN
              min10 = y10
            ELSE
              min10 = x11
            END IF
            dr = SIGN(min10, xt)
            cfl = c(i, j)*rdx(i, j)
            flux(i, j) = u(i, j) - (1.+cfl)*(dl+cfl*(dl-dr))
          END IF
        END DO
      END DO
    CASE (6) 
      DO j=js,je+1
!            is3 = max(3,is-1) ; ie3 = min(npx-3,ie+1)
        DO i=is3,ie3+1
          al(i) = p1*(u(i-1, j)+u(i, j)) + p2*(u(i-2, j)+u(i+1, j))
        END DO
        DO i=is3,ie3
          bl(i) = al(i) - u(i, j)
          br(i) = al(i+1) - u(i, j)
        END DO
        IF (.NOT.nested .AND. grid_type .LT. 3) THEN
          IF (is .EQ. 1) THEN
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
! out
              bl(0) = 0.
! edge
              br(0) = 0.
! edge
              bl(1) = 0.
! in
              br(1) = 0.
              bl(2) = c3*u(1, j) + c2*u(2, j) + c1*u(3, j) - u(2, j)
            ELSE
              bl(0) = c1*u(-2, j) + c2*u(-1, j) + c3*u(0, j) - u(0, j)
              xt = 0.5*(((2.*dx(0, j)+dx(-1, j))*u(0, j)-dx(0, j)*u(-1, &
&               j))/(dx(0, j)+dx(-1, j))+((2.*dx(1, j)+dx(2, j))*u(1, j)&
&               -dx(1, j)*u(2, j))/(dx(1, j)+dx(2, j)))
              br(0) = xt - u(0, j)
              bl(1) = xt - u(1, j)
              xt = c3*u(1, j) + c2*u(2, j) + c1*u(3, j)
              br(1) = xt - u(1, j)
              bl(2) = xt - u(2, j)
            END IF
            br(2) = al(3) - u(2, j)
          END IF
          IF (ie + 1 .EQ. npx) THEN
            bl(npx-2) = al(npx-2) - u(npx-2, j)
            xt = c1*u(npx-3, j) + c2*u(npx-2, j) + c3*u(npx-1, j)
            br(npx-2) = xt - u(npx-2, j)
            bl(npx-1) = xt - u(npx-1, j)
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
! in
              bl(npx-1) = 0.
! edge
              br(npx-1) = 0.
! edge
              bl(npx) = 0.
! out
              br(npx) = 0.
            ELSE
              xt = 0.5*(((2.*dx(npx-1, j)+dx(npx-2, j))*u(npx-1, j)-dx(&
&               npx-1, j)*u(npx-2, j))/(dx(npx-1, j)+dx(npx-2, j))+((2.*&
&               dx(npx, j)+dx(npx+1, j))*u(npx, j)-dx(npx, j)*u(npx+1, j&
&               ))/(dx(npx, j)+dx(npx+1, j)))
              br(npx-1) = xt - u(npx-1, j)
              bl(npx) = xt - u(npx, j)
              br(npx) = c3*u(npx, j) + c2*u(npx+1, j) + c1*u(npx+2, j) -&
&               u(npx, j)
            END IF
          END IF
        END IF
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            cfl = c(i, j)*rdx(i-1, j)
            flux(i, j) = u(i-1, j) + (1.-cfl)*(br(i-1)-cfl*(bl(i-1)+br(i&
&             -1)))
          ELSE
            cfl = c(i, j)*rdx(i, j)
            flux(i, j) = u(i, j) + (1.+cfl)*(bl(i)+cfl*(bl(i)+br(i)))
          END IF
        END DO
      END DO
    CASE DEFAULT
! iord = 8, 9, 10
      DO j=js,je+1
        DO i=is-2,ie+2
          xt = 0.25*(u(i+1, j)-u(i-1, j))
          IF (xt .GE. 0.) THEN
            x12 = xt
          ELSE
            x12 = -xt
          END IF
          IF (u(i-1, j) .LT. u(i, j)) THEN
            IF (u(i, j) .LT. u(i+1, j)) THEN
              max8 = u(i+1, j)
            ELSE
              max8 = u(i, j)
            END IF
          ELSE IF (u(i-1, j) .LT. u(i+1, j)) THEN
            max8 = u(i+1, j)
          ELSE
            max8 = u(i-1, j)
          END IF
          y11 = max8 - u(i, j)
          IF (u(i-1, j) .GT. u(i, j)) THEN
            IF (u(i, j) .GT. u(i+1, j)) THEN
              min21 = u(i+1, j)
            ELSE
              min21 = u(i, j)
            END IF
          ELSE IF (u(i-1, j) .GT. u(i+1, j)) THEN
            min21 = u(i+1, j)
          ELSE
            min21 = u(i-1, j)
          END IF
          z7 = u(i, j) - min21
          IF (x12 .GT. y11) THEN
            IF (y11 .GT. z7) THEN
              min11 = z7
            ELSE
              min11 = y11
            END IF
          ELSE IF (x12 .GT. z7) THEN
            min11 = z7
          ELSE
            min11 = x12
          END IF
          dm(i) = SIGN(min11, xt)
        END DO
        DO i=is-3,ie+2
          dq(i) = u(i+1, j) - u(i, j)
        END DO
        IF (grid_type .LT. 3) THEN
          DO i=is3,ie3+1
            al(i) = 0.5*(u(i-1, j)+u(i, j)) + r3*(dm(i-1)-dm(i))
          END DO
! Perturbation form:
          IF (iord .EQ. 8) THEN
            DO i=is3,ie3
              xt = 2.*dm(i)
              IF (xt .GE. 0.) THEN
                x13 = xt
              ELSE
                x13 = -xt
              END IF
              IF (al(i) - u(i, j) .GE. 0.) THEN
                y12 = al(i) - u(i, j)
              ELSE
                y12 = -(al(i)-u(i, j))
              END IF
              IF (x13 .GT. y12) THEN
                min12 = y12
              ELSE
                min12 = x13
              END IF
              bl(i) = -SIGN(min12, xt)
              IF (xt .GE. 0.) THEN
                x14 = xt
              ELSE
                x14 = -xt
              END IF
              IF (al(i+1) - u(i, j) .GE. 0.) THEN
                y13 = al(i+1) - u(i, j)
              ELSE
                y13 = -(al(i+1)-u(i, j))
              END IF
              IF (x14 .GT. y13) THEN
                min13 = y13
              ELSE
                min13 = x14
              END IF
              br(i) = SIGN(min13, xt)
            END DO
          ELSE IF (iord .EQ. 9) THEN
            DO i=is3,ie3
              pmp_1 = -(2.*dq(i))
              lac_1 = pmp_1 + 1.5*dq(i+1)
              IF (0. .LT. pmp_1) THEN
                IF (pmp_1 .LT. lac_1) THEN
                  x15 = lac_1
                ELSE
                  x15 = pmp_1
                END IF
              ELSE IF (0. .LT. lac_1) THEN
                x15 = lac_1
              ELSE
                x15 = 0.
              END IF
              IF (0. .GT. pmp_1) THEN
                IF (pmp_1 .GT. lac_1) THEN
                  y20 = lac_1
                ELSE
                  y20 = pmp_1
                END IF
              ELSE IF (0. .GT. lac_1) THEN
                y20 = lac_1
              ELSE
                y20 = 0.
              END IF
              IF (al(i) - u(i, j) .LT. y20) THEN
                y14 = y20
              ELSE
                y14 = al(i) - u(i, j)
              END IF
              IF (x15 .GT. y14) THEN
                bl(i) = y14
              ELSE
                bl(i) = x15
              END IF
              pmp_2 = 2.*dq(i-1)
              lac_2 = pmp_2 - 1.5*dq(i-2)
              IF (0. .LT. pmp_2) THEN
                IF (pmp_2 .LT. lac_2) THEN
                  x16 = lac_2
                ELSE
                  x16 = pmp_2
                END IF
              ELSE IF (0. .LT. lac_2) THEN
                x16 = lac_2
              ELSE
                x16 = 0.
              END IF
              IF (0. .GT. pmp_2) THEN
                IF (pmp_2 .GT. lac_2) THEN
                  y21 = lac_2
                ELSE
                  y21 = pmp_2
                END IF
              ELSE IF (0. .GT. lac_2) THEN
                y21 = lac_2
              ELSE
                y21 = 0.
              END IF
              IF (al(i+1) - u(i, j) .LT. y21) THEN
                y15 = y21
              ELSE
                y15 = al(i+1) - u(i, j)
              END IF
              IF (x16 .GT. y15) THEN
                br(i) = y15
              ELSE
                br(i) = x16
              END IF
            END DO
          ELSE IF (iord .EQ. 10) THEN
            DO i=is3,ie3
              bl(i) = al(i) - u(i, j)
              br(i) = al(i+1) - u(i, j)
              IF (dm(i) .GE. 0.) THEN
                abs0 = dm(i)
              ELSE
                abs0 = -dm(i)
              END IF
!             if ( abs(dm(i-1))+abs(dm(i))+abs(dm(i+1)) < near_zero ) then
              IF (abs0 .LT. near_zero) THEN
                IF (dm(i-1) .GE. 0.) THEN
                  abs1 = dm(i-1)
                ELSE
                  abs1 = -dm(i-1)
                END IF
                IF (dm(i+1) .GE. 0.) THEN
                  abs3 = dm(i+1)
                ELSE
                  abs3 = -dm(i+1)
                END IF
                IF (abs1 + abs3 .LT. near_zero) THEN
! 2-delta-x structure detected within 3 cells
                  bl(i) = 0.
                  br(i) = 0.
                END IF
              ELSE
                IF (3.*(bl(i)+br(i)) .GE. 0.) THEN
                  abs2 = 3.*(bl(i)+br(i))
                ELSE
                  abs2 = -(3.*(bl(i)+br(i)))
                END IF
                IF (bl(i) - br(i) .GE. 0.) THEN
                  abs4 = bl(i) - br(i)
                ELSE
                  abs4 = -(bl(i)-br(i))
                END IF
                IF (abs2 .GT. abs4) THEN
                  pmp_1 = -(2.*dq(i))
                  lac_1 = pmp_1 + 1.5*dq(i+1)
                  IF (0. .LT. pmp_1) THEN
                    IF (pmp_1 .LT. lac_1) THEN
                      x17 = lac_1
                    ELSE
                      x17 = pmp_1
                    END IF
                  ELSE IF (0. .LT. lac_1) THEN
                    x17 = lac_1
                  ELSE
                    x17 = 0.
                  END IF
                  IF (0. .GT. pmp_1) THEN
                    IF (pmp_1 .GT. lac_1) THEN
                      y22 = lac_1
                    ELSE
                      y22 = pmp_1
                    END IF
                  ELSE IF (0. .GT. lac_1) THEN
                    y22 = lac_1
                  ELSE
                    y22 = 0.
                  END IF
                  IF (bl(i) .LT. y22) THEN
                    y16 = y22
                  ELSE
                    y16 = bl(i)
                  END IF
                  IF (x17 .GT. y16) THEN
                    bl(i) = y16
                  ELSE
                    bl(i) = x17
                  END IF
                  pmp_2 = 2.*dq(i-1)
                  lac_2 = pmp_2 - 1.5*dq(i-2)
                  IF (0. .LT. pmp_2) THEN
                    IF (pmp_2 .LT. lac_2) THEN
                      x18 = lac_2
                    ELSE
                      x18 = pmp_2
                    END IF
                  ELSE IF (0. .LT. lac_2) THEN
                    x18 = lac_2
                  ELSE
                    x18 = 0.
                  END IF
                  IF (0. .GT. pmp_2) THEN
                    IF (pmp_2 .GT. lac_2) THEN
                      y23 = lac_2
                    ELSE
                      y23 = pmp_2
                    END IF
                  ELSE IF (0. .GT. lac_2) THEN
                    y23 = lac_2
                  ELSE
                    y23 = 0.
                  END IF
                  IF (br(i) .LT. y23) THEN
                    y17 = y23
                  ELSE
                    y17 = br(i)
                  END IF
                  IF (x18 .GT. y17) THEN
                    br(i) = y17
                  ELSE
                    br(i) = x18
                  END IF
                END IF
              END IF
            END DO
          ELSE
! un-limited:
            DO i=is3,ie3
              bl(i) = al(i) - u(i, j)
              br(i) = al(i+1) - u(i, j)
            END DO
          END IF
!--------------
! fix the edges
!--------------
!!! TO DO: separate versions for nested and for cubed-sphere
          IF (is .EQ. 1 .AND. (.NOT.nested)) THEN
            br(2) = al(3) - u(2, j)
            xt = s15*u(1, j) + s11*u(2, j) - s14*dm(2)
            bl(2) = xt - u(2, j)
            br(1) = xt - u(1, j)
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
! out
              bl(0) = 0.
! edge
              br(0) = 0.
! edge
              bl(1) = 0.
! in
              br(1) = 0.
            ELSE
              bl(0) = s14*dm(-1) - s11*dq(-1)
!---------------------------------------------------------------
!#ifdef ONE_SIDE
!                 xt = t14*u(0,j) + t12*u(-1,j) + t15*u(-2,j)
!                 br(0) = 2.*xt - u(0,j)
!                 xt = t14*u(1,j) + t12*u(2,j) + t15*u(3,j)
!                 bl(1) = 2.*xt - u(1,j)
!#else
              x0l = 0.5*((2.*dx(0, j)+dx(-1, j))*u(0, j)-dx(0, j)*u(-1, &
&               j))/(dx(0, j)+dx(-1, j))
              x0r = 0.5*((2.*dx(1, j)+dx(2, j))*u(1, j)-dx(1, j)*u(2, j)&
&               )/(dx(1, j)+dx(2, j))
              xt = x0l + x0r
              br(0) = xt - u(0, j)
              bl(1) = xt - u(1, j)
!#endif
!---------------------------------------------------------------
            END IF
            CALL PERT_PPM(1, u(2, j), bl(2), br(2), -1)
          END IF
          IF (ie + 1 .EQ. npx .AND. (.NOT.nested)) THEN
            bl(npx-2) = al(npx-2) - u(npx-2, j)
            xt = s15*u(npx-1, j) + s11*u(npx-2, j) + s14*dm(npx-2)
            br(npx-2) = xt - u(npx-2, j)
            bl(npx-1) = xt - u(npx-1, j)
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
! in
              bl(npx-1) = 0.
! edge
              br(npx-1) = 0.
! edge
              bl(npx) = 0.
! out
              br(npx) = 0.
            ELSE
              br(npx) = s11*dq(npx) - s14*dm(npx+1)
!#ifdef ONE_SIDE
!                 xt = t14*u(npx-1,j) + t12*u(npx-2,j) + t15*u(npx-3,j)
!                 br(npx-1) = 2.*xt - u(npx-1,j)
!                 xt = t14*u(npx,j) + t12*u(npx+1,j) + t15*u(npx+2,j)
!                 bl(npx  ) = 2.*xt - u(npx  ,j)
!#else
              x0l = 0.5*((2.*dx(npx-1, j)+dx(npx-2, j))*u(npx-1, j)-dx(&
&               npx-1, j)*u(npx-2, j))/(dx(npx-1, j)+dx(npx-2, j))
              x0r = 0.5*((2.*dx(npx, j)+dx(npx+1, j))*u(npx, j)-dx(npx, &
&               j)*u(npx+1, j))/(dx(npx, j)+dx(npx+1, j))
              xt = x0l + x0r
              br(npx-1) = xt - u(npx-1, j)
              bl(npx) = xt - u(npx, j)
!#endif
            END IF
            CALL PERT_PPM(1, u(npx-2, j), bl(npx-2), br(npx-2), -1)
          END IF
        ELSE
          DO i=is-1,ie+2
            al(i) = 0.5*(u(i-1, j)+u(i, j)) + r3*(dm(i-1)-dm(i))
          END DO
          DO i=is-1,ie+1
            pmp = -(2.*dq(i))
            lac = pmp + 1.5*dq(i+1)
            IF (0. .LT. pmp) THEN
              IF (pmp .LT. lac) THEN
                x19 = lac
              ELSE
                x19 = pmp
              END IF
            ELSE IF (0. .LT. lac) THEN
              x19 = lac
            ELSE
              x19 = 0.
            END IF
            IF (0. .GT. pmp) THEN
              IF (pmp .GT. lac) THEN
                y24 = lac
              ELSE
                y24 = pmp
              END IF
            ELSE IF (0. .GT. lac) THEN
              y24 = lac
            ELSE
              y24 = 0.
            END IF
            IF (al(i) - u(i, j) .LT. y24) THEN
              y18 = y24
            ELSE
              y18 = al(i) - u(i, j)
            END IF
            IF (x19 .GT. y18) THEN
              bl(i) = y18
            ELSE
              bl(i) = x19
            END IF
            pmp = 2.*dq(i-1)
            lac = pmp - 1.5*dq(i-2)
            IF (0. .LT. pmp) THEN
              IF (pmp .LT. lac) THEN
                x20 = lac
              ELSE
                x20 = pmp
              END IF
            ELSE IF (0. .LT. lac) THEN
              x20 = lac
            ELSE
              x20 = 0.
            END IF
            IF (0. .GT. pmp) THEN
              IF (pmp .GT. lac) THEN
                y25 = lac
              ELSE
                y25 = pmp
              END IF
            ELSE IF (0. .GT. lac) THEN
              y25 = lac
            ELSE
              y25 = 0.
            END IF
            IF (al(i+1) - u(i, j) .LT. y25) THEN
              y19 = y25
            ELSE
              y19 = al(i+1) - u(i, j)
            END IF
            IF (x20 .GT. y19) THEN
              br(i) = y19
            ELSE
              br(i) = x20
            END IF
          END DO
        END IF
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            cfl = c(i, j)*rdx(i-1, j)
            flux(i, j) = u(i-1, j) + (1.-cfl)*(br(i-1)-cfl*(bl(i-1)+br(i&
&             -1)))
          ELSE
            cfl = c(i, j)*rdx(i, j)
            flux(i, j) = u(i, j) + (1.+cfl)*(bl(i)+cfl*(bl(i)+br(i)))
          END IF
        END DO
      END DO
    END SELECT
  END SUBROUTINE XTP_U
!  Differentiation of xtp_u in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod
!.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_ha
!lo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_m
!od.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.ray
!leigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to
!_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energ
!y fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_m
!od.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv
!_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver
!_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core
!_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_
!corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mo
!d.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mo
!d.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_m
!od.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: flux u c
!   with respect to varying inputs: flux u c
  SUBROUTINE XTP_U_FWD(c, u, v, flux, iord, cosa, dx, rdx, bd, npx, &
&   npy, grid_type, nested)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(IN) :: c(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: flux(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(IN) :: dx(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: rdx(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: cosa(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
    INTEGER, INTENT(IN) :: iord, npx, npy, grid_type
    LOGICAL, INTENT(IN) :: nested
! Local
    REAL(fvprc) :: al(bd%is-1:bd%ie+2, bd%js:bd%je+1)
    REAL(fvprc) :: bl(bd%is-1:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: br(bd%is-1:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: dl, dr, xt, pmp, lac, cfl
    REAL(fvprc) :: pmp_1, lac_1, pmp_2, lac_2
    REAL(fvprc) :: x0, x1, x0l, x0r
    INTEGER :: i, j
    INTEGER :: is3, ie3
    INTEGER :: is, ie, js, je
    INTRINSIC MAX
    INTRINSIC MIN
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    IF (nested .OR. grid_type .GT. 3) THEN
      CALL PUSHCONTROL1B_FV(0)
      is3 = is - 1
      ie3 = ie + 1
    ELSE
      IF (3 .LT. is - 1) THEN
        is3 = is - 1
      ELSE
        is3 = 3
      END IF
      IF (npx - 3 .GT. ie + 1) THEN
        CALL PUSHCONTROL1B_FV(1)
        ie3 = ie + 1
      ELSE
        CALL PUSHCONTROL1B_FV(1)
        ie3 = npx - 3
      END IF
    END IF
    SELECT CASE  (iord) 
    CASE (1) 
      CALL PUSHREALARRAY(flux, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            flux(i, j) = u(i-1, j)
          ELSE
            flux(i, j) = u(i, j)
          END IF
        END DO
      END DO
      CALL PUSHINTEGER(js)
      CALL PUSHINTEGER(is)
      CALL PUSHCONTROL2B_FV(1)
    CASE (333) 
      CALL PUSHREALARRAY(flux, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            flux(i, j) = (2.0*u(i, j)+5.0*u(i-1, j)-u(i-2, j))/6.0 - 0.5&
&             *c(i, j)*rdx(i-1, j)*(u(i, j)-u(i-1, j)) + c(i, j)*rdx(i-1&
&             , j)*c(i, j)*rdx(i-1, j)/6.0*(u(i, j)-2.0*u(i-1, j)+u(i-2&
&             , j))
          ELSE
            flux(i, j) = (2.0*u(i-1, j)+5.0*u(i, j)-u(i+1, j))/6.0 - 0.5&
&             *c(i, j)*rdx(i, j)*(u(i, j)-u(i-1, j)) + c(i, j)*rdx(i, j)&
&             *c(i, j)*rdx(i, j)/6.0*(u(i+1, j)-2.0*u(i, j)+u(i-1, j))
          END IF
        END DO
      END DO
      CALL PUSHINTEGER(js)
      CALL PUSHINTEGER(is)
      CALL PUSHCONTROL2B_FV(2)
    CASE (6) 
      DO j=js,je+1
!            is3 = max(3,is-1) ; ie3 = min(npx-3,ie+1)
        DO i=is3,ie3+1
          al(i, j) = p1*(u(i-1, j)+u(i, j)) + p2*(u(i-2, j)+u(i+1, j))
        END DO
      END DO
      DO j=js,je+1
        DO i=is3,ie3
          bl(i, j) = al(i, j) - u(i, j)
          br(i, j) = al(i+1, j) - u(i, j)
        END DO
      END DO
      DO j=js,je+1
        IF (.NOT.nested .AND. grid_type .LT. 3) THEN
          IF (is .EQ. 1) THEN
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
! out
              bl(0, j) = 0.
! edge
              br(0, j) = 0.
! edge
              bl(1, j) = 0.
! in
              br(1, j) = 0.
              bl(2, j) = c3*u(1, j) + c2*u(2, j) + c1*u(3, j) - u(2, j)
              CALL PUSHCONTROL1B_FV(0)
            ELSE
              bl(0, j) = c1*u(-2, j) + c2*u(-1, j) + c3*u(0, j) - u(0, j&
&               )
              xt = 0.5*(((2.*dx(0, j)+dx(-1, j))*u(0, j)-dx(0, j)*u(-1, &
&               j))/(dx(0, j)+dx(-1, j))+((2.*dx(1, j)+dx(2, j))*u(1, j)&
&               -dx(1, j)*u(2, j))/(dx(1, j)+dx(2, j)))
              br(0, j) = xt - u(0, j)
              bl(1, j) = xt - u(1, j)
              xt = c3*u(1, j) + c2*u(2, j) + c1*u(3, j)
              br(1, j) = xt - u(1, j)
              bl(2, j) = xt - u(2, j)
              CALL PUSHCONTROL1B_FV(1)
            END IF
            br(2, j) = al(3, j) - u(2, j)
            CALL PUSHCONTROL1B_FV(0)
          ELSE
            CALL PUSHCONTROL1B_FV(1)
          END IF
          IF (ie + 1 .EQ. npx) THEN
            bl(npx-2, j) = al(npx-2, j) - u(npx-2, j)
            xt = c1*u(npx-3, j) + c2*u(npx-2, j) + c3*u(npx-1, j)
            br(npx-2, j) = xt - u(npx-2, j)
            bl(npx-1, j) = xt - u(npx-1, j)
            IF (j .EQ. 1 .OR. j .EQ. npy) THEN
! in
              bl(npx-1, j) = 0.
! edge
              br(npx-1, j) = 0.
! edge
              bl(npx, j) = 0.
! out
              br(npx, j) = 0.
              CALL PUSHCONTROL2B_FV(3)
            ELSE
              xt = 0.5*(((2.*dx(npx-1, j)+dx(npx-2, j))*u(npx-1, j)-dx(&
&               npx-1, j)*u(npx-2, j))/(dx(npx-1, j)+dx(npx-2, j))+((2.*&
&               dx(npx, j)+dx(npx+1, j))*u(npx, j)-dx(npx, j)*u(npx+1, j&
&               ))/(dx(npx, j)+dx(npx+1, j)))
              br(npx-1, j) = xt - u(npx-1, j)
              bl(npx, j) = xt - u(npx, j)
              br(npx, j) = c3*u(npx, j) + c2*u(npx+1, j) + c1*u(npx+2, j&
&               ) - u(npx, j)
              CALL PUSHCONTROL2B_FV(2)
            END IF
          ELSE
            CALL PUSHCONTROL2B_FV(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B_FV(0)
        END IF
      END DO
      CALL PUSHREALARRAY(flux, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            cfl = c(i, j)*rdx(i-1, j)
            flux(i, j) = u(i-1, j) + (1.-cfl)*(br(i-1, j)-cfl*(bl(i-1, j&
&             )+br(i-1, j)))
          ELSE
            cfl = c(i, j)*rdx(i, j)
            flux(i, j) = u(i, j) + (1.+cfl)*(bl(i, j)+cfl*(bl(i, j)+br(i&
&             , j)))
          END IF
        END DO
      END DO
      CALL PUSHINTEGER(js)
      CALL PUSHINTEGER(is3)
      CALL PUSHREALARRAY(bl, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+2)/8)
      CALL PUSHREALARRAY(br, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+2)/8)
      CALL PUSHINTEGER(is)
      CALL PUSHINTEGER(ie3)
      CALL PUSHCONTROL2B_FV(3)
    CASE DEFAULT
      CALL PUSHCONTROL2B_FV(0)
    END SELECT
  END SUBROUTINE XTP_U_FWD
!  Differentiation of xtp_u in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mo
!d.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_h
!alo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_
!mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.ra
!yleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_t
!o_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_ener
!gy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_
!mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz f
!v_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solve
!r_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_cor
!e_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence
!_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_m
!od.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_m
!od.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_
!mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: flux u c
!   with respect to varying inputs: flux u c
  SUBROUTINE XTP_U_BWD(c, c_ad, u, u_ad, v, flux, flux_ad, iord, cosa&
&   , dx, rdx, bd, npx, npy, grid_type, nested)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: u_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(IN) :: c(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: c_ad(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: flux(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: flux_ad(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(IN) :: dx(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: rdx(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: cosa(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
    INTEGER, INTENT(IN) :: iord, npx, npy, grid_type
    LOGICAL, INTENT(IN) :: nested
    REAL(fvprc) :: al(bd%is-1:bd%ie+2, bd%js:bd%je+1)
    REAL(fvprc) :: al_ad(bd%is-1:bd%ie+2, bd%js:bd%je+1)
    REAL(fvprc) :: bl(bd%is-1:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: bl_ad(bd%is-1:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: br(bd%is-1:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: br_ad(bd%is-1:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: dl, dr, xt, pmp, lac, cfl
    REAL(fvprc) :: xt_ad, cfl_ad
    REAL(fvprc) :: pmp_1, lac_1, pmp_2, lac_2
    REAL(fvprc) :: x0, x1, x0l, x0r
    INTEGER :: i, j
    INTEGER :: is3, ie3
    INTEGER :: is, ie, js, je
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    INTEGER :: branch
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp_ad4
    REAL(fvprc) :: temp_ad5
    REAL(fvprc) :: temp_ad6
    REAL(fvprc) :: temp_ad7
    REAL(fvprc) :: temp_ad8
    REAL(fvprc) :: temp_ad9
    REAL(fvprc) :: temp_ad10
    REAL(fvprc) :: temp_ad11
    REAL(fvprc) :: temp_ad12
    REAL(fvprc) :: temp
    REAL(fvprc) :: temp_ad13
    REAL(fvprc) :: temp0
    REAL(fvprc) :: temp_ad14
    CALL POPCONTROL2B_FV(branch)
    IF (branch .LT. 2) THEN
      IF (branch .NE. 0) THEN
        CALL POPINTEGER(is)
        CALL POPINTEGER(js)
        CALL POPREALARRAY(flux, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8&
&                   )
        DO j=js,je+1
          DO i=is,ie+1
            IF (c(i, j) .GT. 0.) THEN
              CALL PUSHCONTROL1B_FV(1)
            ELSE
              CALL PUSHCONTROL1B_FV(0)
            END IF
          END DO
          DO i=ie+1,is,-1
            CALL POPCONTROL1B_FV(branch)
            IF (branch .EQ. 0) THEN
              u_ad(i, j) = u_ad(i, j) + flux_ad(i, j)
              flux_ad(i, j) = 0.0_FVPRC
            ELSE
              u_ad(i-1, j) = u_ad(i-1, j) + flux_ad(i, j)
              flux_ad(i, j) = 0.0_FVPRC
            END IF
          END DO
        END DO
      END IF
    ELSE IF (branch .EQ. 2) THEN
      CALL POPINTEGER(is)
      CALL POPINTEGER(js)
      CALL POPREALARRAY(flux, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            CALL PUSHCONTROL1B_FV(1)
          ELSE
            CALL PUSHCONTROL1B_FV(0)
          END IF
        END DO
        DO i=ie+1,is,-1
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            temp_ad8 = flux_ad(i, j)/6.0
            temp_ad9 = -(rdx(i, j)*0.5*flux_ad(i, j))
            temp_ad10 = c(i, j)*temp_ad9
            temp_ad11 = rdx(i, j)**2*flux_ad(i, j)
            temp_ad12 = c(i, j)**2*temp_ad11/6.0
            u_ad(i-1, j) = u_ad(i-1, j) + temp_ad12 - temp_ad10 + 2.0*&
&             temp_ad8
            u_ad(i, j) = u_ad(i, j) + temp_ad10 - 2.0*temp_ad12 + 5.0*&
&             temp_ad8
            u_ad(i+1, j) = u_ad(i+1, j) + temp_ad12 - temp_ad8
            c_ad(i, j) = c_ad(i, j) + (u(i+1, j)-2.0*u(i, j)+u(i-1, j))*&
&             2*c(i, j)*temp_ad11/6.0 + (u(i, j)-u(i-1, j))*temp_ad9
            flux_ad(i, j) = 0.0_FVPRC
          ELSE
            temp_ad3 = flux_ad(i, j)/6.0
            temp_ad4 = -(rdx(i-1, j)*0.5*flux_ad(i, j))
            temp_ad5 = c(i, j)*temp_ad4
            temp_ad6 = rdx(i-1, j)**2*flux_ad(i, j)
            temp_ad7 = c(i, j)**2*temp_ad6/6.0
            u_ad(i, j) = u_ad(i, j) + temp_ad7 + temp_ad5 + 2.0*temp_ad3
            u_ad(i-1, j) = u_ad(i-1, j) + 5.0*temp_ad3 - temp_ad5 - 2.0*&
&             temp_ad7
            u_ad(i-2, j) = u_ad(i-2, j) + temp_ad7 - temp_ad3
            c_ad(i, j) = c_ad(i, j) + (u(i, j)-2.0*u(i-1, j)+u(i-2, j))*&
&             2*c(i, j)*temp_ad6/6.0 + (u(i, j)-u(i-1, j))*temp_ad4
            flux_ad(i, j) = 0.0_FVPRC
          END IF
        END DO
      END DO
    ELSE
      CALL POPINTEGER(ie3)
      CALL POPINTEGER(is)
      CALL POPREALARRAY(br, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+2)/8)
      CALL POPREALARRAY(bl, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+2)/8)
      CALL POPINTEGER(is3)
      CALL POPINTEGER(js)
      bl_ad = 0.0_FVPRC
      br_ad = 0.0_FVPRC
      CALL POPREALARRAY(flux, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            CALL PUSHCONTROL1B_FV(1)
          ELSE
            CALL PUSHCONTROL1B_FV(0)
          END IF
        END DO
        DO i=ie+1,is,-1
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            cfl = c(i, j)*rdx(i, j)
            temp0 = bl(i, j) + br(i, j)
            temp_ad14 = (cfl+1.)*flux_ad(i, j)
            u_ad(i, j) = u_ad(i, j) + flux_ad(i, j)
            cfl_ad = temp0*temp_ad14 + (bl(i, j)+cfl*temp0)*flux_ad(i, j&
&             )
            bl_ad(i, j) = bl_ad(i, j) + (cfl+1.0)*temp_ad14
            br_ad(i, j) = br_ad(i, j) + cfl*temp_ad14
            flux_ad(i, j) = 0.0_FVPRC
            c_ad(i, j) = c_ad(i, j) + rdx(i, j)*cfl_ad
          ELSE
            cfl = c(i, j)*rdx(i-1, j)
            temp = bl(i-1, j) + br(i-1, j)
            temp_ad13 = (1.-cfl)*flux_ad(i, j)
            u_ad(i-1, j) = u_ad(i-1, j) + flux_ad(i, j)
            cfl_ad = -(temp*temp_ad13) - (br(i-1, j)-cfl*temp)*flux_ad(i&
&             , j)
            br_ad(i-1, j) = br_ad(i-1, j) + (1.0-cfl)*temp_ad13
            bl_ad(i-1, j) = bl_ad(i-1, j) - cfl*temp_ad13
            flux_ad(i, j) = 0.0_FVPRC
            c_ad(i, j) = c_ad(i, j) + rdx(i-1, j)*cfl_ad
          END IF
        END DO
      END DO
      al_ad = 0.0_FVPRC
      DO 100 j=je+1,js,-1
        CALL POPCONTROL2B_FV(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) GOTO 100
        ELSE
          IF (branch .EQ. 2) THEN
            u_ad(npx, j) = u_ad(npx, j) + (c3-1.0)*br_ad(npx, j)
            u_ad(npx+1, j) = u_ad(npx+1, j) + c2*br_ad(npx, j)
            u_ad(npx+2, j) = u_ad(npx+2, j) + c1*br_ad(npx, j)
            br_ad(npx, j) = 0.0_FVPRC
            xt_ad = br_ad(npx-1, j) + bl_ad(npx, j)
            u_ad(npx, j) = u_ad(npx, j) - bl_ad(npx, j)
            bl_ad(npx, j) = 0.0_FVPRC
            temp_ad1 = 0.5*xt_ad/(dx(npx-1, j)+dx(npx-2, j))
            u_ad(npx-1, j) = u_ad(npx-1, j) + (dx(npx-1, j)*2.+dx(npx-2&
&             , j))*temp_ad1 - br_ad(npx-1, j)
            br_ad(npx-1, j) = 0.0_FVPRC
            temp_ad2 = 0.5*xt_ad/(dx(npx, j)+dx(npx+1, j))
            u_ad(npx-2, j) = u_ad(npx-2, j) - dx(npx-1, j)*temp_ad1
            u_ad(npx, j) = u_ad(npx, j) + (dx(npx, j)*2.+dx(npx+1, j))*&
&             temp_ad2
            u_ad(npx+1, j) = u_ad(npx+1, j) - dx(npx, j)*temp_ad2
          ELSE
            br_ad(npx, j) = 0.0_FVPRC
            bl_ad(npx, j) = 0.0_FVPRC
            br_ad(npx-1, j) = 0.0_FVPRC
            bl_ad(npx-1, j) = 0.0_FVPRC
          END IF
          xt_ad = br_ad(npx-2, j) + bl_ad(npx-1, j)
          u_ad(npx-1, j) = u_ad(npx-1, j) - bl_ad(npx-1, j)
          bl_ad(npx-1, j) = 0.0_FVPRC
          u_ad(npx-2, j) = u_ad(npx-2, j) - br_ad(npx-2, j)
          br_ad(npx-2, j) = 0.0_FVPRC
          u_ad(npx-3, j) = u_ad(npx-3, j) + c1*xt_ad
          u_ad(npx-2, j) = u_ad(npx-2, j) + c2*xt_ad
          u_ad(npx-1, j) = u_ad(npx-1, j) + c3*xt_ad
          al_ad(npx-2, j) = al_ad(npx-2, j) + bl_ad(npx-2, j)
          u_ad(npx-2, j) = u_ad(npx-2, j) - bl_ad(npx-2, j)
          bl_ad(npx-2, j) = 0.0_FVPRC
        END IF
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          al_ad(3, j) = al_ad(3, j) + br_ad(2, j)
          u_ad(2, j) = u_ad(2, j) - br_ad(2, j)
          br_ad(2, j) = 0.0_FVPRC
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            u_ad(1, j) = u_ad(1, j) + c3*bl_ad(2, j)
            u_ad(2, j) = u_ad(2, j) + (c2-1.0)*bl_ad(2, j)
            u_ad(3, j) = u_ad(3, j) + c1*bl_ad(2, j)
            bl_ad(2, j) = 0.0_FVPRC
            br_ad(1, j) = 0.0_FVPRC
            bl_ad(1, j) = 0.0_FVPRC
            br_ad(0, j) = 0.0_FVPRC
            bl_ad(0, j) = 0.0_FVPRC
          ELSE
            xt_ad = br_ad(1, j) + bl_ad(2, j)
            u_ad(2, j) = u_ad(2, j) - bl_ad(2, j)
            bl_ad(2, j) = 0.0_FVPRC
            u_ad(1, j) = u_ad(1, j) + c3*xt_ad - br_ad(1, j)
            br_ad(1, j) = 0.0_FVPRC
            u_ad(2, j) = u_ad(2, j) + c2*xt_ad
            u_ad(3, j) = u_ad(3, j) + c1*xt_ad
            xt_ad = br_ad(0, j) + bl_ad(1, j)
            u_ad(1, j) = u_ad(1, j) - bl_ad(1, j)
            bl_ad(1, j) = 0.0_FVPRC
            temp_ad = 0.5*xt_ad/(dx(0, j)+dx(-1, j))
            u_ad(0, j) = u_ad(0, j) + (dx(0, j)*2.+dx(-1, j))*temp_ad - &
&             br_ad(0, j)
            br_ad(0, j) = 0.0_FVPRC
            temp_ad0 = 0.5*xt_ad/(dx(1, j)+dx(2, j))
            u_ad(-1, j) = u_ad(-1, j) - dx(0, j)*temp_ad
            u_ad(1, j) = u_ad(1, j) + (dx(1, j)*2.+dx(2, j))*temp_ad0
            u_ad(2, j) = u_ad(2, j) - dx(1, j)*temp_ad0
            u_ad(-2, j) = u_ad(-2, j) + c1*bl_ad(0, j)
            u_ad(-1, j) = u_ad(-1, j) + c2*bl_ad(0, j)
            u_ad(0, j) = u_ad(0, j) + (c3-1.0)*bl_ad(0, j)
            bl_ad(0, j) = 0.0_FVPRC
          END IF
        END IF
 100  CONTINUE
      DO j=je+1,js,-1
        DO i=ie3,is3,-1
          al_ad(i+1, j) = al_ad(i+1, j) + br_ad(i, j)
          u_ad(i, j) = u_ad(i, j) - bl_ad(i, j) - br_ad(i, j)
          br_ad(i, j) = 0.0_FVPRC
          al_ad(i, j) = al_ad(i, j) + bl_ad(i, j)
          bl_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      DO j=je+1,js,-1
        DO i=ie3+1,is3,-1
          u_ad(i-1, j) = u_ad(i-1, j) + p1*al_ad(i, j)
          u_ad(i, j) = u_ad(i, j) + p1*al_ad(i, j)
          u_ad(i-2, j) = u_ad(i-2, j) + p2*al_ad(i, j)
          u_ad(i+1, j) = u_ad(i+1, j) + p2*al_ad(i, j)
          al_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
  END SUBROUTINE XTP_U_BWD
!  Differentiation of ytp_v in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod
!.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_ha
!lo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_m
!od.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.ray
!leigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to
!_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energ
!y fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_m
!od.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv
!_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver
!_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core
!_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_
!corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mo
!d.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mo
!d.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_m
!od.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: flux v c
!   with respect to varying inputs: v c
  SUBROUTINE YTP_V_FWD(c, u, v, flux, jord, cosa, dy, rdy, bd, npx, &
&   npy, grid_type, nested)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: jord
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed)
!  Courant   N (like FLUX)
    REAL(fvprc), INTENT(IN) :: c(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: flux(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(IN) :: dy(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(IN) :: rdy(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(IN) :: cosa(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
    INTEGER, INTENT(IN) :: npx, npy, grid_type
    LOGICAL, INTENT(IN) :: nested
! Local:
    LOGICAL :: extm(bd%is:bd%ie+1, bd%js-2:bd%je+2)
    REAL(fvprc) :: dm(bd%is:bd%ie+1, bd%js-2:bd%je+2)
    REAL(fvprc) :: al(bd%is:bd%ie+1, bd%js-1:bd%je+2)
    REAL(fvprc) :: bl(bd%is:bd%ie+1, bd%js-1:bd%je+1)
    REAL(fvprc) :: br(bd%is:bd%ie+1, bd%js-1:bd%je+1)
    REAL(fvprc) :: dq(bd%is:bd%ie+1, bd%js-3:bd%je+2)
    REAL(fvprc) :: xt, dl, dr, pmp, lac, cfl
    REAL(fvprc) :: pmp_1, lac_1, pmp_2, lac_2
    REAL(fvprc) :: x0, x1, x0r, x0l
    INTEGER :: i, j, js3, je3
    INTEGER :: is, ie, js, je
    INTRINSIC MAX
    INTRINSIC MIN
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    IF (nested .OR. grid_type .GT. 3) THEN
      CALL PUSHCONTROL1B_FV(0)
      js3 = js - 1
      je3 = je + 1
    ELSE
      IF (3 .LT. js - 1) THEN
        js3 = js - 1
      ELSE
        js3 = 3
      END IF
      IF (npy - 3 .GT. je + 1) THEN
        CALL PUSHCONTROL1B_FV(1)
        je3 = je + 1
      ELSE
        CALL PUSHCONTROL1B_FV(1)
        je3 = npy - 3
      END IF
    END IF
    SELECT CASE  (jord) 
    CASE (1) 
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            flux(i, j) = v(i, j-1)
          ELSE
            flux(i, j) = v(i, j)
          END IF
        END DO
      END DO
      CALL PUSHINTEGER(js)
      CALL PUSHINTEGER(is)
      CALL PUSHCONTROL2B_FV(1)
    CASE (333) 
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            flux(i, j) = (2.0*v(i, j)+5.0*v(i, j-1)-v(i, j-2))/6.0 - 0.5&
&             *c(i, j)*rdy(i, j-1)*(v(i, j)-v(i, j-1)) + c(i, j)*rdy(i, &
&             j-1)*c(i, j)*rdy(i, j-1)/6.0*(v(i, j)-2.0*v(i, j-1)+v(i, j&
&             -2))
          ELSE
            flux(i, j) = (2.0*v(i, j-1)+5.0*v(i, j)-v(i, j+1))/6.0 - 0.5&
&             *c(i, j)*rdy(i, j)*(v(i, j)-v(i, j-1)) + c(i, j)*rdy(i, j)&
&             *c(i, j)*rdy(i, j)/6.0*(v(i, j+1)-2.0*v(i, j)+v(i, j-1))
          END IF
        END DO
      END DO
      CALL PUSHINTEGER(js)
      CALL PUSHINTEGER(is)
      CALL PUSHCONTROL2B_FV(2)
    CASE (6) 
      DO j=js3,je3+1
        DO i=is,ie+1
          al(i, j) = p1*(v(i, j-1)+v(i, j)) + p2*(v(i, j-2)+v(i, j+1))
        END DO
      END DO
      DO j=js3,je3
        DO i=is,ie+1
          bl(i, j) = al(i, j) - v(i, j)
          br(i, j) = al(i, j+1) - v(i, j)
        END DO
      END DO
      IF (.NOT.nested .AND. grid_type .LT. 3) THEN
        IF (js .EQ. 1) THEN
          DO i=is,ie+1
            bl(i, 0) = c1*v(i, -2) + c2*v(i, -1) + c3*v(i, 0) - v(i, 0)
            xt = 0.5*(((2.*dy(i, 0)+dy(i, -1))*v(i, 0)-dy(i, 0)*v(i, -1)&
&             )/(dy(i, 0)+dy(i, -1))+((2.*dy(i, 1)+dy(i, 2))*v(i, 1)-dy(&
&             i, 1)*v(i, 2))/(dy(i, 1)+dy(i, 2)))
            br(i, 0) = xt - v(i, 0)
            bl(i, 1) = xt - v(i, 1)
            xt = c3*v(i, 1) + c2*v(i, 2) + c1*v(i, 3)
            br(i, 1) = xt - v(i, 1)
            bl(i, 2) = xt - v(i, 2)
            br(i, 2) = al(i, 3) - v(i, 2)
          END DO
          IF (is .EQ. 1) THEN
! out
            bl(1, 0) = 0.
! edge
            br(1, 0) = 0.
! edge
            bl(1, 1) = 0.
! in
            br(1, 1) = 0.
            CALL PUSHCONTROL1B_FV(0)
          ELSE
            CALL PUSHCONTROL1B_FV(1)
          END IF
          IF (ie + 1 .EQ. npx) THEN
! out
            bl(npx, 0) = 0.
! edge
            br(npx, 0) = 0.
! edge
            bl(npx, 1) = 0.
! in
            br(npx, 1) = 0.
            CALL PUSHCONTROL2B_FV(0)
          ELSE
            CALL PUSHCONTROL2B_FV(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B_FV(2)
        END IF
        IF (je + 1 .EQ. npy) THEN
          DO i=is,ie+1
            bl(i, npy-2) = al(i, npy-2) - v(i, npy-2)
            xt = c1*v(i, npy-3) + c2*v(i, npy-2) + c3*v(i, npy-1)
            br(i, npy-2) = xt - v(i, npy-2)
            bl(i, npy-1) = xt - v(i, npy-1)
            xt = 0.5*(((2.*dy(i, npy-1)+dy(i, npy-2))*v(i, npy-1)-dy(i, &
&             npy-1)*v(i, npy-2))/(dy(i, npy-1)+dy(i, npy-2))+((2.*dy(i&
&             , npy)+dy(i, npy+1))*v(i, npy)-dy(i, npy)*v(i, npy+1))/(dy&
&             (i, npy)+dy(i, npy+1)))
            br(i, npy-1) = xt - v(i, npy-1)
            bl(i, npy) = xt - v(i, npy)
            br(i, npy) = c3*v(i, npy) + c2*v(i, npy+1) + c1*v(i, npy+2) &
&             - v(i, npy)
          END DO
          IF (is .EQ. 1) THEN
! in
            bl(1, npy-1) = 0.
! edge
            br(1, npy-1) = 0.
! edge
            bl(1, npy) = 0.
! out
            br(1, npy) = 0.
            CALL PUSHCONTROL1B_FV(0)
          ELSE
            CALL PUSHCONTROL1B_FV(1)
          END IF
          IF (ie + 1 .EQ. npx) THEN
! in
            bl(npx, npy-1) = 0.
! edge
            br(npx, npy-1) = 0.
! edge
            bl(npx, npy) = 0.
! out
            br(npx, npy) = 0.
            CALL PUSHCONTROL2B_FV(3)
          ELSE
            CALL PUSHCONTROL2B_FV(2)
          END IF
        ELSE
          CALL PUSHCONTROL2B_FV(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B_FV(0)
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            cfl = c(i, j)*rdy(i, j-1)
            flux(i, j) = v(i, j-1) + (1.-cfl)*(br(i, j-1)-cfl*(bl(i, j-1&
&             )+br(i, j-1)))
          ELSE
            cfl = c(i, j)*rdy(i, j)
            flux(i, j) = v(i, j) + (1.+cfl)*(bl(i, j)+cfl*(bl(i, j)+br(i&
&             , j)))
          END IF
        END DO
      END DO
      CALL PUSHINTEGER(js)
      CALL PUSHREALARRAY(bl, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+3)/8)
      CALL PUSHINTEGER(je3)
      CALL PUSHREALARRAY(br, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+3)/8)
      CALL PUSHINTEGER(is)
      CALL PUSHINTEGER(js3)
      CALL PUSHCONTROL2B_FV(3)
    CASE DEFAULT
      CALL PUSHCONTROL2B_FV(0)
    END SELECT
  END SUBROUTINE YTP_V_FWD
!  Differentiation of ytp_v in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mo
!d.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_h
!alo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_
!mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.ra
!yleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_t
!o_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_ener
!gy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_
!mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz f
!v_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solve
!r_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_cor
!e_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence
!_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_m
!od.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_m
!od.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_
!mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: flux v c
!   with respect to varying inputs: v c
  SUBROUTINE YTP_V_BWD(c, c_ad, u, v, v_ad, flux, flux_ad, jord, cosa&
&   , dy, rdy, bd, npx, npy, grid_type, nested)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: jord
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: v_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(IN) :: c(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: c_ad(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: flux(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: flux_ad(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(IN) :: dy(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(IN) :: rdy(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(IN) :: cosa(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
    INTEGER, INTENT(IN) :: npx, npy, grid_type
    LOGICAL, INTENT(IN) :: nested
    LOGICAL :: extm(bd%is:bd%ie+1, bd%js-2:bd%je+2)
    REAL(fvprc) :: dm(bd%is:bd%ie+1, bd%js-2:bd%je+2)
    REAL(fvprc) :: al(bd%is:bd%ie+1, bd%js-1:bd%je+2)
    REAL(fvprc) :: al_ad(bd%is:bd%ie+1, bd%js-1:bd%je+2)
    REAL(fvprc) :: bl(bd%is:bd%ie+1, bd%js-1:bd%je+1)
    REAL(fvprc) :: bl_ad(bd%is:bd%ie+1, bd%js-1:bd%je+1)
    REAL(fvprc) :: br(bd%is:bd%ie+1, bd%js-1:bd%je+1)
    REAL(fvprc) :: br_ad(bd%is:bd%ie+1, bd%js-1:bd%je+1)
    REAL(fvprc) :: dq(bd%is:bd%ie+1, bd%js-3:bd%je+2)
    REAL(fvprc) :: xt, dl, dr, pmp, lac, cfl
    REAL(fvprc) :: xt_ad, cfl_ad
    REAL(fvprc) :: pmp_1, lac_1, pmp_2, lac_2
    REAL(fvprc) :: x0, x1, x0r, x0l
    INTEGER :: i, j, js3, je3
    INTEGER :: is, ie, js, je
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    INTEGER :: branch
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp_ad4
    REAL(fvprc) :: temp_ad5
    REAL(fvprc) :: temp_ad6
    REAL(fvprc) :: temp_ad7
    REAL(fvprc) :: temp_ad8
    REAL(fvprc) :: temp_ad9
    REAL(fvprc) :: temp_ad10
    REAL(fvprc) :: temp_ad11
    REAL(fvprc) :: temp_ad12
    REAL(fvprc) :: temp
    REAL(fvprc) :: temp_ad13
    REAL(fvprc) :: temp0
    REAL(fvprc) :: temp_ad14
    CALL POPCONTROL2B_FV(branch)
    IF (branch .LT. 2) THEN
      IF (branch .NE. 0) THEN
        CALL POPINTEGER(is)
        CALL POPINTEGER(js)
        DO j=js,je+1
          DO i=is,ie+1
            IF (c(i, j) .GT. 0.) THEN
              CALL PUSHCONTROL1B_FV(1)
            ELSE
              CALL PUSHCONTROL1B_FV(0)
            END IF
          END DO
          DO i=ie+1,is,-1
            CALL POPCONTROL1B_FV(branch)
            IF (branch .EQ. 0) THEN
              v_ad(i, j) = v_ad(i, j) + flux_ad(i, j)
              flux_ad(i, j) = 0.0_FVPRC
            ELSE
              v_ad(i, j-1) = v_ad(i, j-1) + flux_ad(i, j)
              flux_ad(i, j) = 0.0_FVPRC
            END IF
          END DO
        END DO
      END IF
    ELSE IF (branch .EQ. 2) THEN
      CALL POPINTEGER(is)
      CALL POPINTEGER(js)
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            CALL PUSHCONTROL1B_FV(1)
          ELSE
            CALL PUSHCONTROL1B_FV(0)
          END IF
        END DO
        DO i=ie+1,is,-1
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            temp_ad8 = flux_ad(i, j)/6.0
            temp_ad9 = -(rdy(i, j)*0.5*flux_ad(i, j))
            temp_ad10 = c(i, j)*temp_ad9
            temp_ad11 = rdy(i, j)**2*flux_ad(i, j)
            temp_ad12 = c(i, j)**2*temp_ad11/6.0
            v_ad(i, j-1) = v_ad(i, j-1) + temp_ad12 - temp_ad10 + 2.0*&
&             temp_ad8
            v_ad(i, j) = v_ad(i, j) + temp_ad10 - 2.0*temp_ad12 + 5.0*&
&             temp_ad8
            v_ad(i, j+1) = v_ad(i, j+1) + temp_ad12 - temp_ad8
            c_ad(i, j) = c_ad(i, j) + (v(i, j+1)-2.0*v(i, j)+v(i, j-1))*&
&             2*c(i, j)*temp_ad11/6.0 + (v(i, j)-v(i, j-1))*temp_ad9
            flux_ad(i, j) = 0.0_FVPRC
          ELSE
            temp_ad3 = flux_ad(i, j)/6.0
            temp_ad4 = -(rdy(i, j-1)*0.5*flux_ad(i, j))
            temp_ad5 = c(i, j)*temp_ad4
            temp_ad6 = rdy(i, j-1)**2*flux_ad(i, j)
            temp_ad7 = c(i, j)**2*temp_ad6/6.0
            v_ad(i, j) = v_ad(i, j) + temp_ad7 + temp_ad5 + 2.0*temp_ad3
            v_ad(i, j-1) = v_ad(i, j-1) + 5.0*temp_ad3 - temp_ad5 - 2.0*&
&             temp_ad7
            v_ad(i, j-2) = v_ad(i, j-2) + temp_ad7 - temp_ad3
            c_ad(i, j) = c_ad(i, j) + (v(i, j)-2.0*v(i, j-1)+v(i, j-2))*&
&             2*c(i, j)*temp_ad6/6.0 + (v(i, j)-v(i, j-1))*temp_ad4
            flux_ad(i, j) = 0.0_FVPRC
          END IF
        END DO
      END DO
    ELSE
      CALL POPINTEGER(js3)
      CALL POPINTEGER(is)
      CALL POPREALARRAY(br, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+3)/8)
      CALL POPINTEGER(je3)
      CALL POPREALARRAY(bl, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+3)/8)
      CALL POPINTEGER(js)
      bl_ad = 0.0_FVPRC
      br_ad = 0.0_FVPRC
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            CALL PUSHCONTROL1B_FV(1)
          ELSE
            CALL PUSHCONTROL1B_FV(0)
          END IF
        END DO
        DO i=ie+1,is,-1
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            cfl = c(i, j)*rdy(i, j)
            temp0 = bl(i, j) + br(i, j)
            temp_ad14 = (cfl+1.)*flux_ad(i, j)
            v_ad(i, j) = v_ad(i, j) + flux_ad(i, j)
            cfl_ad = temp0*temp_ad14 + (bl(i, j)+cfl*temp0)*flux_ad(i, j&
&             )
            bl_ad(i, j) = bl_ad(i, j) + (cfl+1.0)*temp_ad14
            br_ad(i, j) = br_ad(i, j) + cfl*temp_ad14
            flux_ad(i, j) = 0.0_FVPRC
            c_ad(i, j) = c_ad(i, j) + rdy(i, j)*cfl_ad
          ELSE
            cfl = c(i, j)*rdy(i, j-1)
            temp = bl(i, j-1) + br(i, j-1)
            temp_ad13 = (1.-cfl)*flux_ad(i, j)
            v_ad(i, j-1) = v_ad(i, j-1) + flux_ad(i, j)
            cfl_ad = -(temp*temp_ad13) - (br(i, j-1)-cfl*temp)*flux_ad(i&
&             , j)
            br_ad(i, j-1) = br_ad(i, j-1) + (1.0-cfl)*temp_ad13
            bl_ad(i, j-1) = bl_ad(i, j-1) - cfl*temp_ad13
            flux_ad(i, j) = 0.0_FVPRC
            c_ad(i, j) = c_ad(i, j) + rdy(i, j-1)*cfl_ad
          END IF
        END DO
      END DO
      CALL POPCONTROL2B_FV(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          al_ad = 0.0_FVPRC
          GOTO 100
        ELSE
          al_ad = 0.0_FVPRC
        END IF
      ELSE
        IF (branch .NE. 2) THEN
          br_ad(npx, npy) = 0.0_FVPRC
          bl_ad(npx, npy) = 0.0_FVPRC
          br_ad(npx, npy-1) = 0.0_FVPRC
          bl_ad(npx, npy-1) = 0.0_FVPRC
        END IF
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          br_ad(1, npy) = 0.0_FVPRC
          bl_ad(1, npy) = 0.0_FVPRC
          br_ad(1, npy-1) = 0.0_FVPRC
          bl_ad(1, npy-1) = 0.0_FVPRC
        END IF
        al_ad = 0.0_FVPRC
        DO i=ie+1,is,-1
          v_ad(i, npy) = v_ad(i, npy) + (c3-1.0)*br_ad(i, npy)
          v_ad(i, npy+1) = v_ad(i, npy+1) + c2*br_ad(i, npy)
          v_ad(i, npy+2) = v_ad(i, npy+2) + c1*br_ad(i, npy)
          br_ad(i, npy) = 0.0_FVPRC
          xt_ad = br_ad(i, npy-1) + bl_ad(i, npy)
          v_ad(i, npy) = v_ad(i, npy) - bl_ad(i, npy)
          bl_ad(i, npy) = 0.0_FVPRC
          temp_ad1 = 0.5*xt_ad/(dy(i, npy-1)+dy(i, npy-2))
          v_ad(i, npy-1) = v_ad(i, npy-1) + (dy(i, npy-1)*2.+dy(i, npy-2&
&           ))*temp_ad1 - br_ad(i, npy-1)
          br_ad(i, npy-1) = 0.0_FVPRC
          temp_ad2 = 0.5*xt_ad/(dy(i, npy)+dy(i, npy+1))
          v_ad(i, npy-2) = v_ad(i, npy-2) - dy(i, npy-1)*temp_ad1
          v_ad(i, npy) = v_ad(i, npy) + (dy(i, npy)*2.+dy(i, npy+1))*&
&           temp_ad2
          v_ad(i, npy+1) = v_ad(i, npy+1) - dy(i, npy)*temp_ad2
          xt_ad = br_ad(i, npy-2) + bl_ad(i, npy-1)
          v_ad(i, npy-1) = v_ad(i, npy-1) - bl_ad(i, npy-1)
          bl_ad(i, npy-1) = 0.0_FVPRC
          v_ad(i, npy-2) = v_ad(i, npy-2) - br_ad(i, npy-2)
          br_ad(i, npy-2) = 0.0_FVPRC
          v_ad(i, npy-3) = v_ad(i, npy-3) + c1*xt_ad
          v_ad(i, npy-2) = v_ad(i, npy-2) + c2*xt_ad
          v_ad(i, npy-1) = v_ad(i, npy-1) + c3*xt_ad
          al_ad(i, npy-2) = al_ad(i, npy-2) + bl_ad(i, npy-2)
          v_ad(i, npy-2) = v_ad(i, npy-2) - bl_ad(i, npy-2)
          bl_ad(i, npy-2) = 0.0_FVPRC
        END DO
      END IF
      CALL POPCONTROL2B_FV(branch)
      IF (branch .EQ. 0) THEN
        br_ad(npx, 1) = 0.0_FVPRC
        bl_ad(npx, 1) = 0.0_FVPRC
        br_ad(npx, 0) = 0.0_FVPRC
        bl_ad(npx, 0) = 0.0_FVPRC
      ELSE IF (branch .NE. 1) THEN
        GOTO 100
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        br_ad(1, 1) = 0.0_FVPRC
        bl_ad(1, 1) = 0.0_FVPRC
        br_ad(1, 0) = 0.0_FVPRC
        bl_ad(1, 0) = 0.0_FVPRC
      END IF
      DO i=ie+1,is,-1
        al_ad(i, 3) = al_ad(i, 3) + br_ad(i, 2)
        v_ad(i, 2) = v_ad(i, 2) - bl_ad(i, 2) - br_ad(i, 2)
        br_ad(i, 2) = 0.0_FVPRC
        xt_ad = br_ad(i, 1) + bl_ad(i, 2)
        bl_ad(i, 2) = 0.0_FVPRC
        v_ad(i, 1) = v_ad(i, 1) + c3*xt_ad - br_ad(i, 1)
        br_ad(i, 1) = 0.0_FVPRC
        v_ad(i, 2) = v_ad(i, 2) + c2*xt_ad
        v_ad(i, 3) = v_ad(i, 3) + c1*xt_ad
        xt_ad = br_ad(i, 0) + bl_ad(i, 1)
        v_ad(i, 1) = v_ad(i, 1) - bl_ad(i, 1)
        bl_ad(i, 1) = 0.0_FVPRC
        temp_ad = 0.5*xt_ad/(dy(i, 0)+dy(i, -1))
        v_ad(i, 0) = v_ad(i, 0) + (dy(i, 0)*2.+dy(i, -1))*temp_ad - &
&         br_ad(i, 0)
        br_ad(i, 0) = 0.0_FVPRC
        temp_ad0 = 0.5*xt_ad/(dy(i, 1)+dy(i, 2))
        v_ad(i, -1) = v_ad(i, -1) - dy(i, 0)*temp_ad
        v_ad(i, 1) = v_ad(i, 1) + (dy(i, 1)*2.+dy(i, 2))*temp_ad0
        v_ad(i, 2) = v_ad(i, 2) - dy(i, 1)*temp_ad0
        v_ad(i, -2) = v_ad(i, -2) + c1*bl_ad(i, 0)
        v_ad(i, -1) = v_ad(i, -1) + c2*bl_ad(i, 0)
        v_ad(i, 0) = v_ad(i, 0) + (c3-1.0)*bl_ad(i, 0)
        bl_ad(i, 0) = 0.0_FVPRC
      END DO
 100  DO j=je3,js3,-1
        DO i=ie+1,is,-1
          al_ad(i, j+1) = al_ad(i, j+1) + br_ad(i, j)
          v_ad(i, j) = v_ad(i, j) - bl_ad(i, j) - br_ad(i, j)
          br_ad(i, j) = 0.0_FVPRC
          al_ad(i, j) = al_ad(i, j) + bl_ad(i, j)
          bl_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      DO j=je3+1,js3,-1
        DO i=ie+1,is,-1
          v_ad(i, j-1) = v_ad(i, j-1) + p1*al_ad(i, j)
          v_ad(i, j) = v_ad(i, j) + p1*al_ad(i, j)
          v_ad(i, j-2) = v_ad(i, j-2) + p2*al_ad(i, j)
          v_ad(i, j+1) = v_ad(i, j+1) + p2*al_ad(i, j)
          al_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
  END SUBROUTINE YTP_V_BWD
!  Differentiation of ytp_v in reverse (adjoint) mode (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod.a2b_ord4 a2b_e
!dge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.ad
!v_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update 
!dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.rayleigh_super fv_dyn
!amics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to_latlon fv_grid_ut
!ils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energy fv_mapz_mod.pkez
! fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mod.map1_q2 fv_m
!apz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv_tracer2d_mod.trac
!er_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver_c nh_core_mod.rie
!m_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core_mod.sim_solver nh
!_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_cor
!e_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.compute_div_damp
!ing_fb sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mod.copy_corners 
!tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_mod.fyppm tp_cor
!e_mod.deln_flux)):
!   gradient     of useful results: flux v c
!   with respect to varying inputs: v c
  SUBROUTINE YTP_V_ADM(c, c_ad, u, v, v_ad, flux, flux_ad, jord, cosa, &
&   dy, rdy, bd, npx, npy, grid_type, nested)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: jord
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: v_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed)
!  Courant   N (like FLUX)
    REAL(fvprc), INTENT(IN) :: c(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: c_ad(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: flux(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: flux_ad(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(IN) :: dy(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(IN) :: rdy(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(IN) :: cosa(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
    INTEGER, INTENT(IN) :: npx, npy, grid_type
    LOGICAL, INTENT(IN) :: nested
! Local:
    LOGICAL :: extm(bd%is:bd%ie+1, bd%js-2:bd%je+2)
    REAL(fvprc) :: dm(bd%is:bd%ie+1, bd%js-2:bd%je+2)
    REAL(fvprc) :: dm_ad(bd%is:bd%ie+1, bd%js-2:bd%je+2)
    REAL(fvprc) :: al(bd%is:bd%ie+1, bd%js-1:bd%je+2)
    REAL(fvprc) :: al_ad(bd%is:bd%ie+1, bd%js-1:bd%je+2)
    REAL(fvprc) :: bl(bd%is:bd%ie+1, bd%js-1:bd%je+1)
    REAL(fvprc) :: bl_ad(bd%is:bd%ie+1, bd%js-1:bd%je+1)
    REAL(fvprc) :: br(bd%is:bd%ie+1, bd%js-1:bd%je+1)
    REAL(fvprc) :: br_ad(bd%is:bd%ie+1, bd%js-1:bd%je+1)
    REAL(fvprc) :: dq(bd%is:bd%ie+1, bd%js-3:bd%je+2)
    REAL(fvprc) :: dq_ad(bd%is:bd%ie+1, bd%js-3:bd%je+2)
    REAL(fvprc) :: xt, dl, dr, pmp, lac, cfl
    REAL(fvprc) :: xt_ad, dl_ad, dr_ad, pmp_ad, lac_ad, cfl_ad
    REAL(fvprc) :: pmp_1, lac_1, pmp_2, lac_2
    REAL(fvprc) :: pmp_1_ad, lac_1_ad, pmp_2_ad, lac_2_ad
    REAL(fvprc) :: x0, x1, x0r, x0l
    REAL(fvprc) :: x0_ad, x1_ad, x0r_ad, x0l_ad
    INTEGER :: i, j, js3, je3
    INTEGER :: is, ie, js, je
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC SIGN
    REAL(fvprc) :: min1
    REAL(fvprc) :: min1_ad
    REAL(fvprc) :: min2
    REAL(fvprc) :: min2_ad
    REAL(fvprc) :: min3
    REAL(fvprc) :: min3_ad
    REAL(fvprc) :: min4
    REAL(fvprc) :: min4_ad
    REAL(fvprc) :: min5
    REAL(fvprc) :: min5_ad
    REAL(fvprc) :: min6
    REAL(fvprc) :: min6_ad
    REAL(fvprc) :: min7
    REAL(fvprc) :: min7_ad
    REAL(fvprc) :: min8
    REAL(fvprc) :: min8_ad
    REAL(fvprc) :: min9
    REAL(fvprc) :: min9_ad
    REAL(fvprc) :: min10
    REAL(fvprc) :: min10_ad
    REAL(fvprc) :: min11
    REAL(fvprc) :: min11_ad
    REAL(fvprc) :: min12
    REAL(fvprc) :: min12_ad
    REAL(fvprc) :: min13
    REAL(fvprc) :: min13_ad
    REAL(fvprc) :: abs0
    REAL(fvprc) :: abs1
    REAL(fvprc) :: abs2
    REAL(fvprc) :: max1
    REAL(fvprc) :: max1_ad
    REAL(fvprc) :: min14
    REAL(fvprc) :: min14_ad
    REAL(fvprc) :: max2
    REAL(fvprc) :: max2_ad
    REAL(fvprc) :: min15
    REAL(fvprc) :: min15_ad
    REAL(fvprc) :: max3
    REAL(fvprc) :: max3_ad
    REAL(fvprc) :: min16
    REAL(fvprc) :: min16_ad
    REAL(fvprc) :: max4
    REAL(fvprc) :: max4_ad
    REAL(fvprc) :: min17
    REAL(fvprc) :: min17_ad
    REAL(fvprc) :: max5
    REAL(fvprc) :: max5_ad
    REAL(fvprc) :: min18
    REAL(fvprc) :: min18_ad
    REAL(fvprc) :: max6
    REAL(fvprc) :: max6_ad
    REAL(fvprc) :: min19
    REAL(fvprc) :: min19_ad
    REAL(fvprc) :: max7
    REAL(fvprc) :: max7_ad
    REAL(fvprc) :: min20
    REAL(fvprc) :: min20_ad
    REAL(fvprc) :: abs3
    REAL(fvprc) :: abs4
    INTEGER :: arg1
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp_ad4
    REAL(fvprc) :: temp_ad5
    REAL(fvprc) :: temp_ad6
    REAL(fvprc) :: temp_ad7
    REAL(fvprc) :: temp_ad8
    REAL(fvprc) :: x2_ad
    REAL(fvprc) :: y1_ad
    REAL(fvprc) :: z1_ad
    REAL(fvprc) :: temp_ad9
    REAL(fvprc) :: temp_ad10
    REAL(fvprc) :: x3_ad
    REAL(fvprc) :: y2_ad
    REAL(fvprc) :: z2_ad
    REAL(fvprc) :: x4_ad
    REAL(fvprc) :: y3_ad
    REAL(fvprc) :: z3_ad
    REAL(fvprc) :: temp_ad11
    REAL(fvprc) :: temp_ad12
    REAL(fvprc) :: x5_ad
    REAL(fvprc) :: y4_ad
    REAL(fvprc) :: z4_ad
    REAL(fvprc) :: x6_ad
    REAL(fvprc) :: y5_ad
    REAL(fvprc) :: z5_ad
    REAL(fvprc) :: x7_ad
    REAL(fvprc) :: y6_ad
    REAL(fvprc) :: z6_ad
    REAL(fvprc) :: temp_ad13
    REAL(fvprc) :: temp_ad14
    REAL(fvprc) :: temp_ad15
    REAL(fvprc) :: temp_ad16
    REAL(fvprc) :: x8_ad
    REAL(fvprc) :: y7_ad
    REAL(fvprc) :: x9_ad
    REAL(fvprc) :: y8_ad
    REAL(fvprc) :: temp_ad17
    REAL(fvprc) :: x10_ad
    REAL(fvprc) :: y9_ad
    REAL(fvprc) :: x11_ad
    REAL(fvprc) :: y10_ad
    REAL(fvprc) :: temp_ad18
    REAL(fvprc) :: temp_ad19
    REAL(fvprc) :: temp_ad20
    REAL(fvprc) :: temp_ad21
    REAL(fvprc) :: temp_ad22
    REAL(fvprc) :: temp
    REAL(fvprc) :: temp_ad23
    REAL(fvprc) :: temp0
    REAL(fvprc) :: temp_ad24
    REAL(fvprc) :: x12_ad
    REAL(fvprc) :: y11_ad
    REAL(fvprc) :: z7_ad
    REAL(fvprc) :: x13_ad
    REAL(fvprc) :: y12_ad
    REAL(fvprc) :: x14_ad
    REAL(fvprc) :: y13_ad
    REAL(fvprc) :: x15_ad
    REAL(fvprc) :: y20_ad
    REAL(fvprc) :: y14_ad
    REAL(fvprc) :: x16_ad
    REAL(fvprc) :: y21_ad
    REAL(fvprc) :: y15_ad
    REAL(fvprc) :: x17_ad
    REAL(fvprc) :: y22_ad
    REAL(fvprc) :: y16_ad
    REAL(fvprc) :: x18_ad
    REAL(fvprc) :: y23_ad
    REAL(fvprc) :: y17_ad
    REAL(fvprc) :: temp_ad25
    REAL(fvprc) :: temp_ad26
    REAL(fvprc) :: temp_ad27
    REAL(fvprc) :: temp_ad28
    REAL(fvprc) :: x19_ad
    REAL(fvprc) :: y24_ad
    REAL(fvprc) :: y18_ad
    REAL(fvprc) :: x20_ad
    REAL(fvprc) :: y25_ad
    REAL(fvprc) :: y19_ad
    REAL(fvprc) :: temp1
    REAL(fvprc) :: temp_ad29
    REAL(fvprc) :: temp2
    REAL(fvprc) :: temp_ad30
    INTEGER :: branch
    REAL(fvprc) :: x19
    REAL(fvprc) :: x18
    REAL(fvprc) :: x17
    REAL(fvprc) :: x16
    REAL(fvprc) :: x15
    REAL(fvprc) :: x14
    REAL(fvprc) :: x13
    REAL(fvprc) :: x12
    REAL(fvprc) :: x11
    REAL(fvprc) :: x10
    REAL(fvprc) :: y25
    REAL(fvprc) :: y24
    REAL(fvprc) :: y23
    REAL(fvprc) :: y22
    REAL(fvprc) :: y21
    REAL(fvprc) :: y20
    REAL(fvprc) :: x9
    REAL(fvprc) :: x8
    REAL(fvprc) :: x7
    REAL(fvprc) :: x6
    REAL(fvprc) :: x5
    REAL(fvprc) :: x4
    REAL(fvprc) :: x3
    REAL(fvprc) :: x2
    REAL(fvprc) :: y19
    REAL(fvprc) :: y18
    REAL(fvprc) :: y17
    REAL(fvprc) :: y16
    REAL(fvprc) :: y15
    REAL(fvprc) :: y14
    REAL(fvprc) :: y13
    REAL(fvprc) :: y12
    REAL(fvprc) :: y11
    REAL(fvprc) :: y10
    REAL(fvprc) :: z7
    REAL(fvprc) :: z6
    REAL(fvprc) :: z5
    REAL(fvprc) :: z4
    REAL(fvprc) :: z3
    REAL(fvprc) :: z2
    REAL(fvprc) :: z1
    REAL(fvprc) :: x20
    REAL(fvprc) :: y9
    REAL(fvprc) :: y8
    REAL(fvprc) :: y7
    REAL(fvprc) :: y6
    REAL(fvprc) :: y5
    REAL(fvprc) :: y4
    REAL(fvprc) :: y3
    REAL(fvprc) :: y2
    REAL(fvprc) :: y1
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    IF (nested .OR. grid_type .GT. 3) THEN
      CALL PUSHCONTROL1B(0)
      js3 = js - 1
      je3 = je + 1
    ELSE
      IF (3 .LT. js - 1) THEN
        js3 = js - 1
      ELSE
        js3 = 3
      END IF
      IF (npy - 3 .GT. je + 1) THEN
        CALL PUSHCONTROL1B(1)
        je3 = je + 1
      ELSE
        CALL PUSHCONTROL1B(1)
        je3 = npy - 3
      END IF
    END IF
    SELECT CASE  (jord) 
    CASE (1) 
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            v_ad(i, j) = v_ad(i, j) + flux_ad(i, j)
            flux_ad(i, j) = 0.0_FVPRC
          ELSE
            v_ad(i, j-1) = v_ad(i, j-1) + flux_ad(i, j)
            flux_ad(i, j) = 0.0_FVPRC
          END IF
        END DO
      END DO
    CASE (333) 
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            temp_ad4 = flux_ad(i, j)/6.0
            temp_ad5 = -(rdy(i, j)*0.5*flux_ad(i, j))
            temp_ad6 = c(i, j)*temp_ad5
            temp_ad7 = rdy(i, j)**2*flux_ad(i, j)
            temp_ad8 = c(i, j)**2*temp_ad7/6.0
            v_ad(i, j-1) = v_ad(i, j-1) + temp_ad8 - temp_ad6 + 2.0*&
&             temp_ad4
            v_ad(i, j) = v_ad(i, j) + temp_ad6 - 2.0*temp_ad8 + 5.0*&
&             temp_ad4
            v_ad(i, j+1) = v_ad(i, j+1) + temp_ad8 - temp_ad4
            c_ad(i, j) = c_ad(i, j) + (v(i, j+1)-2.0*v(i, j)+v(i, j-1))*&
&             2*c(i, j)*temp_ad7/6.0 + (v(i, j)-v(i, j-1))*temp_ad5
            flux_ad(i, j) = 0.0_FVPRC
          ELSE
            temp_ad = flux_ad(i, j)/6.0
            temp_ad0 = -(rdy(i, j-1)*0.5*flux_ad(i, j))
            temp_ad1 = c(i, j)*temp_ad0
            temp_ad2 = rdy(i, j-1)**2*flux_ad(i, j)
            temp_ad3 = c(i, j)**2*temp_ad2/6.0
            v_ad(i, j) = v_ad(i, j) + temp_ad3 + temp_ad1 + 2.0*temp_ad
            v_ad(i, j-1) = v_ad(i, j-1) + 5.0*temp_ad - temp_ad1 - 2.0*&
&             temp_ad3
            v_ad(i, j-2) = v_ad(i, j-2) + temp_ad3 - temp_ad
            c_ad(i, j) = c_ad(i, j) + (v(i, j)-2.0*v(i, j-1)+v(i, j-2))*&
&             2*c(i, j)*temp_ad2/6.0 + (v(i, j)-v(i, j-1))*temp_ad0
            flux_ad(i, j) = 0.0_FVPRC
          END IF
        END DO
      END DO
    CASE (2) 
      DO j=js-2,je+2
        DO i=is,ie+1
          xt = 0.25*(v(i, j+1)-v(i, j-1))
          IF (xt .GE. 0.) THEN
            x2 = xt
            CALL PUSHCONTROL1B(0)
          ELSE
            x2 = -xt
            CALL PUSHCONTROL1B(1)
          END IF
          IF (v(i, j-1) .LT. v(i, j)) THEN
            IF (v(i, j) .LT. v(i, j+1)) THEN
              max1 = v(i, j+1)
              CALL PUSHCONTROL2B(0)
            ELSE
              max1 = v(i, j)
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE IF (v(i, j-1) .LT. v(i, j+1)) THEN
            max1 = v(i, j+1)
            CALL PUSHCONTROL2B(2)
          ELSE
            max1 = v(i, j-1)
            CALL PUSHCONTROL2B(3)
          END IF
          y1 = max1 - v(i, j)
          IF (v(i, j-1) .GT. v(i, j)) THEN
            IF (v(i, j) .GT. v(i, j+1)) THEN
              min14 = v(i, j+1)
              CALL PUSHCONTROL2B(0)
            ELSE
              min14 = v(i, j)
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE IF (v(i, j-1) .GT. v(i, j+1)) THEN
            min14 = v(i, j+1)
            CALL PUSHCONTROL2B(2)
          ELSE
            min14 = v(i, j-1)
            CALL PUSHCONTROL2B(3)
          END IF
          z1 = v(i, j) - min14
          IF (x2 .GT. y1) THEN
            IF (y1 .GT. z1) THEN
              CALL PUSHREALARRAY_ADM(min1)
              min1 = z1
              CALL PUSHCONTROL2B(0)
            ELSE
              CALL PUSHREALARRAY_ADM(min1)
              min1 = y1
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE IF (x2 .GT. z1) THEN
            CALL PUSHREALARRAY_ADM(min1)
            min1 = z1
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHREALARRAY_ADM(min1)
            min1 = x2
            CALL PUSHCONTROL2B(3)
          END IF
          dm(i, j) = SIGN(min1, xt)
        END DO
      END DO
      IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
        IF (js .EQ. 1) THEN
          DO i=is,ie+1
            x0l = 0.5*((2.*dy(i, 0)+dy(i, -1))*v(i, 0)-dy(i, 0)*v(i, -1)&
&             )/(dy(i, 0)+dy(i, -1))
            x0r = 0.5*((2.*dy(i, 1)+dy(i, 2))*v(i, 1)-dy(i, 1)*v(i, 2))/&
&             (dy(i, 1)+dy(i, 2))
            x0 = x0l + x0r
            x1 = s15*v(i, 1) + s11*v(i, 2) - s14*dm(i, 2)
!           dm(i,1) = x1 - v(i,1)
            dm(i, 1) = 0.5*(x1-x0)
            IF (dm(i, 1) .GE. 0.) THEN
              x3 = dm(i, 1)
              CALL PUSHCONTROL1B(0)
            ELSE
              x3 = -dm(i, 1)
              CALL PUSHCONTROL1B(1)
            END IF
            IF (v(i, 1) .LT. x0) THEN
              IF (x0 .LT. x1) THEN
                max2 = x1
                CALL PUSHCONTROL2B(0)
              ELSE
                max2 = x0
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE IF (v(i, 1) .LT. x1) THEN
              max2 = x1
              CALL PUSHCONTROL2B(2)
            ELSE
              max2 = v(i, 1)
              CALL PUSHCONTROL2B(3)
            END IF
            y2 = max2 - v(i, 1)
            IF (v(i, 1) .GT. x0) THEN
              IF (x0 .GT. x1) THEN
                min15 = x1
                CALL PUSHCONTROL2B(0)
              ELSE
                min15 = x0
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE IF (v(i, 1) .GT. x1) THEN
              min15 = x1
              CALL PUSHCONTROL2B(2)
            ELSE
              min15 = v(i, 1)
              CALL PUSHCONTROL2B(3)
            END IF
            z2 = v(i, 1) - min15
            IF (x3 .GT. y2) THEN
              IF (y2 .GT. z2) THEN
                CALL PUSHREALARRAY_ADM(min2)
                min2 = z2
                CALL PUSHCONTROL2B(0)
              ELSE
                CALL PUSHREALARRAY_ADM(min2)
                min2 = y2
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE IF (x3 .GT. z2) THEN
              CALL PUSHREALARRAY_ADM(min2)
              min2 = z2
              CALL PUSHCONTROL2B(2)
            ELSE
              CALL PUSHREALARRAY_ADM(min2)
              min2 = x3
              CALL PUSHCONTROL2B(3)
            END IF
            CALL PUSHREALARRAY_ADM(dm(i, 1))
            dm(i, 1) = SIGN(min2, dm(i, 1))
            x1 = s15*v(i, 0) + s11*v(i, -1) + s14*dm(i, -1)
!           dm(i,0) = v(i,0) - x1
            CALL PUSHREALARRAY_ADM(dm(i, 0))
            dm(i, 0) = 0.5*(x0-x1)
            IF (dm(i, 0) .GE. 0.) THEN
              x4 = dm(i, 0)
              CALL PUSHCONTROL1B(0)
            ELSE
              x4 = -dm(i, 0)
              CALL PUSHCONTROL1B(1)
            END IF
            IF (v(i, 0) .LT. x0) THEN
              IF (x0 .LT. x1) THEN
                max3 = x1
                CALL PUSHCONTROL2B(0)
              ELSE
                max3 = x0
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE IF (v(i, 0) .LT. x1) THEN
              max3 = x1
              CALL PUSHCONTROL2B(2)
            ELSE
              max3 = v(i, 0)
              CALL PUSHCONTROL2B(3)
            END IF
            y3 = max3 - v(i, 0)
            IF (v(i, 0) .GT. x0) THEN
              IF (x0 .GT. x1) THEN
                min16 = x1
                CALL PUSHCONTROL2B(0)
              ELSE
                min16 = x0
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE IF (v(i, 0) .GT. x1) THEN
              min16 = x1
              CALL PUSHCONTROL2B(2)
            ELSE
              min16 = v(i, 0)
              CALL PUSHCONTROL2B(3)
            END IF
            z3 = v(i, 0) - min16
            IF (x4 .GT. y3) THEN
              IF (y3 .GT. z3) THEN
                CALL PUSHREALARRAY_ADM(min3)
                min3 = z3
                CALL PUSHCONTROL2B(0)
              ELSE
                CALL PUSHREALARRAY_ADM(min3)
                min3 = y3
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE IF (x4 .GT. z3) THEN
              CALL PUSHREALARRAY_ADM(min3)
              min3 = z3
              CALL PUSHCONTROL2B(2)
            ELSE
              CALL PUSHREALARRAY_ADM(min3)
              min3 = x4
              CALL PUSHCONTROL2B(3)
            END IF
            CALL PUSHREALARRAY_ADM(dm(i, 0))
            dm(i, 0) = SIGN(min3, dm(i, 0))
          END DO
          IF (is .EQ. 1) THEN
            CALL PUSHREALARRAY_ADM(dm(1, 0))
            dm(1, 0) = 0.
            CALL PUSHREALARRAY_ADM(dm(1, 1))
            dm(1, 1) = 0.
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (ie + 1 .EQ. npx) THEN
            CALL PUSHREALARRAY_ADM(dm(npx, 0))
            dm(npx, 0) = 0.
            CALL PUSHREALARRAY_ADM(dm(npx, 1))
            dm(npx, 1) = 0.
            CALL PUSHCONTROL2B(0)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
        IF (je + 1 .EQ. npy) THEN
          DO i=is,ie+1
            x0l = 0.5*((2.*dy(i, npy-1)+dy(i, npy-2))*v(i, npy-1)-dy(i, &
&             npy-1)*v(i, npy-2))/(dy(i, npy-1)+dy(i, npy-2))
            x0r = 0.5*((2.*dy(i, npy)+dy(i, npy+1))*v(i, npy)-dy(i, npy)&
&             *v(i, npy+1))/(dy(i, npy)+dy(i, npy+1))
            x0 = x0l + x0r
            x1 = s15*v(i, npy-1) + s11*v(i, npy-2) + s14*dm(i, npy-2)
!           dm(i,npy-1) = v(i,npy-1) - x1
            CALL PUSHREALARRAY_ADM(dm(i, npy-1))
            dm(i, npy-1) = 0.5*(x0-x1)
            IF (dm(i, npy-1) .GE. 0.) THEN
              x5 = dm(i, npy-1)
              CALL PUSHCONTROL1B(0)
            ELSE
              x5 = -dm(i, npy-1)
              CALL PUSHCONTROL1B(1)
            END IF
            IF (v(i, npy-1) .LT. x0) THEN
              IF (x0 .LT. x1) THEN
                max4 = x1
                CALL PUSHCONTROL2B(0)
              ELSE
                max4 = x0
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE IF (v(i, npy-1) .LT. x1) THEN
              max4 = x1
              CALL PUSHCONTROL2B(2)
            ELSE
              max4 = v(i, npy-1)
              CALL PUSHCONTROL2B(3)
            END IF
            y4 = max4 - v(i, npy-1)
            IF (v(i, npy-1) .GT. x0) THEN
              IF (x0 .GT. x1) THEN
                min17 = x1
                CALL PUSHCONTROL2B(0)
              ELSE
                min17 = x0
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE IF (v(i, npy-1) .GT. x1) THEN
              min17 = x1
              CALL PUSHCONTROL2B(2)
            ELSE
              min17 = v(i, npy-1)
              CALL PUSHCONTROL2B(3)
            END IF
            z4 = v(i, npy-1) - min17
            IF (x5 .GT. y4) THEN
              IF (y4 .GT. z4) THEN
                CALL PUSHREALARRAY_ADM(min4)
                min4 = z4
                CALL PUSHCONTROL2B(0)
              ELSE
                CALL PUSHREALARRAY_ADM(min4)
                min4 = y4
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE IF (x5 .GT. z4) THEN
              CALL PUSHREALARRAY_ADM(min4)
              min4 = z4
              CALL PUSHCONTROL2B(2)
            ELSE
              CALL PUSHREALARRAY_ADM(min4)
              min4 = x5
              CALL PUSHCONTROL2B(3)
            END IF
            CALL PUSHREALARRAY_ADM(dm(i, npy-1))
            dm(i, npy-1) = SIGN(min4, dm(i, npy-1))
            x1 = s15*v(i, npy) + s11*v(i, npy+1) - s14*dm(i, npy+1)
!           dm(i,npy) = x1 - v(i,npy)
            CALL PUSHREALARRAY_ADM(dm(i, npy))
            dm(i, npy) = 0.5*(x1-x0)
            IF (dm(i, npy) .GE. 0.) THEN
              x6 = dm(i, npy)
              CALL PUSHCONTROL1B(0)
            ELSE
              x6 = -dm(i, npy)
              CALL PUSHCONTROL1B(1)
            END IF
            IF (v(i, npy) .LT. x0) THEN
              IF (x0 .LT. x1) THEN
                max5 = x1
                CALL PUSHCONTROL2B(0)
              ELSE
                max5 = x0
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE IF (v(i, npy) .LT. x1) THEN
              max5 = x1
              CALL PUSHCONTROL2B(2)
            ELSE
              max5 = v(i, npy)
              CALL PUSHCONTROL2B(3)
            END IF
            y5 = max5 - v(i, npy)
            IF (v(i, npy) .GT. x0) THEN
              IF (x0 .GT. x1) THEN
                min18 = x1
                CALL PUSHCONTROL2B(0)
              ELSE
                min18 = x0
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE IF (v(i, npy) .GT. x1) THEN
              min18 = x1
              CALL PUSHCONTROL2B(2)
            ELSE
              min18 = v(i, npy)
              CALL PUSHCONTROL2B(3)
            END IF
            z5 = v(i, npy) - min18
            IF (x6 .GT. y5) THEN
              IF (y5 .GT. z5) THEN
                CALL PUSHREALARRAY_ADM(min5)
                min5 = z5
                CALL PUSHCONTROL2B(0)
              ELSE
                CALL PUSHREALARRAY_ADM(min5)
                min5 = y5
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE IF (x6 .GT. z5) THEN
              CALL PUSHREALARRAY_ADM(min5)
              min5 = z5
              CALL PUSHCONTROL2B(2)
            ELSE
              CALL PUSHREALARRAY_ADM(min5)
              min5 = x6
              CALL PUSHCONTROL2B(3)
            END IF
            CALL PUSHREALARRAY_ADM(dm(i, npy))
            dm(i, npy) = SIGN(min5, dm(i, npy))
          END DO
          IF (is .EQ. 1) THEN
            CALL PUSHREALARRAY_ADM(dm(1, npy-1))
            dm(1, npy-1) = 0.
            CALL PUSHREALARRAY_ADM(dm(1, npy))
            dm(1, npy) = 0.
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (ie + 1 .EQ. npx) THEN
            CALL PUSHREALARRAY_ADM(dm(npx, npy-1))
            dm(npx, npy-1) = 0.
            CALL PUSHREALARRAY_ADM(dm(npx, npy))
            dm(npx, npy) = 0.
            CALL PUSHCONTROL2B(3)
          ELSE
            CALL PUSHCONTROL2B(2)
          END IF
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      dm_ad = 0.0_FVPRC
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            v_ad(i, j) = v_ad(i, j) + flux_ad(i, j)
            c_ad(i, j) = c_ad(i, j) - dm(i, j)*rdy(i, j)*flux_ad(i, j)
            dm_ad(i, j) = dm_ad(i, j) - (rdy(i, j)*c(i, j)+1.)*flux_ad(i&
&             , j)
            flux_ad(i, j) = 0.0_FVPRC
          ELSE
            v_ad(i, j-1) = v_ad(i, j-1) + flux_ad(i, j)
            c_ad(i, j) = c_ad(i, j) - dm(i, j-1)*rdy(i, j-1)*flux_ad(i, &
&             j)
            dm_ad(i, j-1) = dm_ad(i, j-1) + (1.-rdy(i, j-1)*c(i, j))*&
&             flux_ad(i, j)
            flux_ad(i, j) = 0.0_FVPRC
          END IF
        END DO
      END DO
      CALL POPCONTROL2B(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) GOTO 100
      ELSE
        IF (branch .NE. 2) THEN
          CALL POPREALARRAY_ADM(dm(npx, npy))
          dm_ad(npx, npy) = 0.0_FVPRC
          CALL POPREALARRAY_ADM(dm(npx, npy-1))
          dm_ad(npx, npy-1) = 0.0_FVPRC
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREALARRAY_ADM(dm(1, npy))
          dm_ad(1, npy) = 0.0_FVPRC
          CALL POPREALARRAY_ADM(dm(1, npy-1))
          dm_ad(1, npy-1) = 0.0_FVPRC
        END IF
        DO i=ie+1,is,-1
          CALL POPREALARRAY_ADM(dm(i, npy))
          min5_ad = SIGN(1.d0, min5*dm(i, npy))*dm_ad(i, npy)
          dm_ad(i, npy) = 0.0_FVPRC
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(min5)
              z5_ad = min5_ad
              y5_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min5)
              y5_ad = min5_ad
              z5_ad = 0.0_FVPRC
            END IF
            x6_ad = 0.0_FVPRC
          ELSE
            IF (branch .EQ. 2) THEN
              CALL POPREALARRAY_ADM(min5)
              z5_ad = min5_ad
              x6_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min5)
              x6_ad = min5_ad
              z5_ad = 0.0_FVPRC
            END IF
            y5_ad = 0.0_FVPRC
          END IF
          v_ad(i, npy) = v_ad(i, npy) + z5_ad
          min18_ad = -z5_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              x1_ad = min18_ad
              x0_ad = 0.0_FVPRC
            ELSE
              x0_ad = min18_ad
              x1_ad = 0.0_FVPRC
            END IF
          ELSE
            IF (branch .EQ. 2) THEN
              x1_ad = min18_ad
            ELSE
              v_ad(i, npy) = v_ad(i, npy) + min18_ad
              x1_ad = 0.0_FVPRC
            END IF
            x0_ad = 0.0_FVPRC
          END IF
          max5_ad = y5_ad
          v_ad(i, npy) = v_ad(i, npy) - y5_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              x1_ad = x1_ad + max5_ad
            ELSE
              x0_ad = x0_ad + max5_ad
            END IF
          ELSE IF (branch .EQ. 2) THEN
            x1_ad = x1_ad + max5_ad
          ELSE
            v_ad(i, npy) = v_ad(i, npy) + max5_ad
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            dm_ad(i, npy) = dm_ad(i, npy) + x6_ad
          ELSE
            dm_ad(i, npy) = dm_ad(i, npy) - x6_ad
          END IF
          CALL POPREALARRAY_ADM(dm(i, npy))
          x1_ad = x1_ad + 0.5*dm_ad(i, npy)
          x0_ad = x0_ad - 0.5*dm_ad(i, npy)
          dm_ad(i, npy) = 0.0_FVPRC
          v_ad(i, npy) = v_ad(i, npy) + s15*x1_ad
          v_ad(i, npy+1) = v_ad(i, npy+1) + s11*x1_ad
          dm_ad(i, npy+1) = dm_ad(i, npy+1) - s14*x1_ad
          CALL POPREALARRAY_ADM(dm(i, npy-1))
          min4_ad = SIGN(1.d0, min4*dm(i, npy-1))*dm_ad(i, npy-1)
          dm_ad(i, npy-1) = 0.0_FVPRC
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(min4)
              z4_ad = min4_ad
              y4_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min4)
              y4_ad = min4_ad
              z4_ad = 0.0_FVPRC
            END IF
            x5_ad = 0.0_FVPRC
          ELSE
            IF (branch .EQ. 2) THEN
              CALL POPREALARRAY_ADM(min4)
              z4_ad = min4_ad
              x5_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min4)
              x5_ad = min4_ad
              z4_ad = 0.0_FVPRC
            END IF
            y4_ad = 0.0_FVPRC
          END IF
          v_ad(i, npy-1) = v_ad(i, npy-1) + z4_ad
          min17_ad = -z4_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              x1_ad = min17_ad
            ELSE
              x0_ad = x0_ad + min17_ad
              x1_ad = 0.0_FVPRC
            END IF
          ELSE IF (branch .EQ. 2) THEN
            x1_ad = min17_ad
          ELSE
            v_ad(i, npy-1) = v_ad(i, npy-1) + min17_ad
            x1_ad = 0.0_FVPRC
          END IF
          max4_ad = y4_ad
          v_ad(i, npy-1) = v_ad(i, npy-1) - y4_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              x1_ad = x1_ad + max4_ad
            ELSE
              x0_ad = x0_ad + max4_ad
            END IF
          ELSE IF (branch .EQ. 2) THEN
            x1_ad = x1_ad + max4_ad
          ELSE
            v_ad(i, npy-1) = v_ad(i, npy-1) + max4_ad
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            dm_ad(i, npy-1) = dm_ad(i, npy-1) + x5_ad
          ELSE
            dm_ad(i, npy-1) = dm_ad(i, npy-1) - x5_ad
          END IF
          CALL POPREALARRAY_ADM(dm(i, npy-1))
          x0_ad = x0_ad + 0.5*dm_ad(i, npy-1)
          x1_ad = x1_ad - 0.5*dm_ad(i, npy-1)
          dm_ad(i, npy-1) = 0.0_FVPRC
          v_ad(i, npy-1) = v_ad(i, npy-1) + s15*x1_ad
          v_ad(i, npy-2) = v_ad(i, npy-2) + s11*x1_ad
          dm_ad(i, npy-2) = dm_ad(i, npy-2) + s14*x1_ad
          x0l_ad = x0_ad
          x0r_ad = x0_ad
          temp_ad11 = 0.5*x0r_ad/(dy(i, npy)+dy(i, npy+1))
          v_ad(i, npy) = v_ad(i, npy) + (dy(i, npy)*2.+dy(i, npy+1))*&
&           temp_ad11
          v_ad(i, npy+1) = v_ad(i, npy+1) - dy(i, npy)*temp_ad11
          temp_ad12 = 0.5*x0l_ad/(dy(i, npy-1)+dy(i, npy-2))
          v_ad(i, npy-1) = v_ad(i, npy-1) + (dy(i, npy-1)*2.+dy(i, npy-2&
&           ))*temp_ad12
          v_ad(i, npy-2) = v_ad(i, npy-2) - dy(i, npy-1)*temp_ad12
        END DO
      END IF
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREALARRAY_ADM(dm(npx, 1))
        dm_ad(npx, 1) = 0.0_FVPRC
        CALL POPREALARRAY_ADM(dm(npx, 0))
        dm_ad(npx, 0) = 0.0_FVPRC
      ELSE IF (branch .NE. 1) THEN
        GOTO 100
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREALARRAY_ADM(dm(1, 1))
        dm_ad(1, 1) = 0.0_FVPRC
        CALL POPREALARRAY_ADM(dm(1, 0))
        dm_ad(1, 0) = 0.0_FVPRC
      END IF
      DO i=ie+1,is,-1
        CALL POPREALARRAY_ADM(dm(i, 0))
        min3_ad = SIGN(1.d0, min3*dm(i, 0))*dm_ad(i, 0)
        dm_ad(i, 0) = 0.0_FVPRC
        CALL POPCONTROL2B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) THEN
            CALL POPREALARRAY_ADM(min3)
            z3_ad = min3_ad
            y3_ad = 0.0_FVPRC
          ELSE
            CALL POPREALARRAY_ADM(min3)
            y3_ad = min3_ad
            z3_ad = 0.0_FVPRC
          END IF
          x4_ad = 0.0_FVPRC
        ELSE
          IF (branch .EQ. 2) THEN
            CALL POPREALARRAY_ADM(min3)
            z3_ad = min3_ad
            x4_ad = 0.0_FVPRC
          ELSE
            CALL POPREALARRAY_ADM(min3)
            x4_ad = min3_ad
            z3_ad = 0.0_FVPRC
          END IF
          y3_ad = 0.0_FVPRC
        END IF
        v_ad(i, 0) = v_ad(i, 0) + z3_ad
        min16_ad = -z3_ad
        CALL POPCONTROL2B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) THEN
            x1_ad = min16_ad
            x0_ad = 0.0_FVPRC
          ELSE
            x0_ad = min16_ad
            x1_ad = 0.0_FVPRC
          END IF
        ELSE
          IF (branch .EQ. 2) THEN
            x1_ad = min16_ad
          ELSE
            v_ad(i, 0) = v_ad(i, 0) + min16_ad
            x1_ad = 0.0_FVPRC
          END IF
          x0_ad = 0.0_FVPRC
        END IF
        max3_ad = y3_ad
        v_ad(i, 0) = v_ad(i, 0) - y3_ad
        CALL POPCONTROL2B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) THEN
            x1_ad = x1_ad + max3_ad
          ELSE
            x0_ad = x0_ad + max3_ad
          END IF
        ELSE IF (branch .EQ. 2) THEN
          x1_ad = x1_ad + max3_ad
        ELSE
          v_ad(i, 0) = v_ad(i, 0) + max3_ad
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          dm_ad(i, 0) = dm_ad(i, 0) + x4_ad
        ELSE
          dm_ad(i, 0) = dm_ad(i, 0) - x4_ad
        END IF
        CALL POPREALARRAY_ADM(dm(i, 0))
        x0_ad = x0_ad + 0.5*dm_ad(i, 0)
        x1_ad = x1_ad - 0.5*dm_ad(i, 0)
        dm_ad(i, 0) = 0.0_FVPRC
        v_ad(i, 0) = v_ad(i, 0) + s15*x1_ad
        v_ad(i, -1) = v_ad(i, -1) + s11*x1_ad
        dm_ad(i, -1) = dm_ad(i, -1) + s14*x1_ad
        CALL POPREALARRAY_ADM(dm(i, 1))
        min2_ad = SIGN(1.d0, min2*dm(i, 1))*dm_ad(i, 1)
        dm_ad(i, 1) = 0.0_FVPRC
        CALL POPCONTROL2B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) THEN
            CALL POPREALARRAY_ADM(min2)
            z2_ad = min2_ad
            y2_ad = 0.0_FVPRC
          ELSE
            CALL POPREALARRAY_ADM(min2)
            y2_ad = min2_ad
            z2_ad = 0.0_FVPRC
          END IF
          x3_ad = 0.0_FVPRC
        ELSE
          IF (branch .EQ. 2) THEN
            CALL POPREALARRAY_ADM(min2)
            z2_ad = min2_ad
            x3_ad = 0.0_FVPRC
          ELSE
            CALL POPREALARRAY_ADM(min2)
            x3_ad = min2_ad
            z2_ad = 0.0_FVPRC
          END IF
          y2_ad = 0.0_FVPRC
        END IF
        v_ad(i, 1) = v_ad(i, 1) + z2_ad
        min15_ad = -z2_ad
        CALL POPCONTROL2B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) THEN
            x1_ad = min15_ad
          ELSE
            x0_ad = x0_ad + min15_ad
            x1_ad = 0.0_FVPRC
          END IF
        ELSE IF (branch .EQ. 2) THEN
          x1_ad = min15_ad
        ELSE
          v_ad(i, 1) = v_ad(i, 1) + min15_ad
          x1_ad = 0.0_FVPRC
        END IF
        max2_ad = y2_ad
        v_ad(i, 1) = v_ad(i, 1) - y2_ad
        CALL POPCONTROL2B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) THEN
            x1_ad = x1_ad + max2_ad
          ELSE
            x0_ad = x0_ad + max2_ad
          END IF
        ELSE IF (branch .EQ. 2) THEN
          x1_ad = x1_ad + max2_ad
        ELSE
          v_ad(i, 1) = v_ad(i, 1) + max2_ad
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          dm_ad(i, 1) = dm_ad(i, 1) + x3_ad
        ELSE
          dm_ad(i, 1) = dm_ad(i, 1) - x3_ad
        END IF
        x1_ad = x1_ad + 0.5*dm_ad(i, 1)
        x0_ad = x0_ad - 0.5*dm_ad(i, 1)
        dm_ad(i, 1) = 0.0_FVPRC
        v_ad(i, 1) = v_ad(i, 1) + s15*x1_ad
        v_ad(i, 2) = v_ad(i, 2) + s11*x1_ad
        dm_ad(i, 2) = dm_ad(i, 2) - s14*x1_ad
        x0l_ad = x0_ad
        x0r_ad = x0_ad
        temp_ad9 = 0.5*x0r_ad/(dy(i, 1)+dy(i, 2))
        v_ad(i, 1) = v_ad(i, 1) + (dy(i, 1)*2.+dy(i, 2))*temp_ad9
        v_ad(i, 2) = v_ad(i, 2) - dy(i, 1)*temp_ad9
        temp_ad10 = 0.5*x0l_ad/(dy(i, 0)+dy(i, -1))
        v_ad(i, 0) = v_ad(i, 0) + (dy(i, 0)*2.+dy(i, -1))*temp_ad10
        v_ad(i, -1) = v_ad(i, -1) - dy(i, 0)*temp_ad10
      END DO
 100  DO j=je+2,js-2,-1
        DO i=ie+1,is,-1
          xt = 0.25*(v(i, j+1)-v(i, j-1))
          min1_ad = SIGN(1.d0, min1*xt)*dm_ad(i, j)
          dm_ad(i, j) = 0.0_FVPRC
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(min1)
              z1_ad = min1_ad
              y1_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min1)
              y1_ad = min1_ad
              z1_ad = 0.0_FVPRC
            END IF
            x2_ad = 0.0_FVPRC
          ELSE
            IF (branch .EQ. 2) THEN
              CALL POPREALARRAY_ADM(min1)
              z1_ad = min1_ad
              x2_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min1)
              x2_ad = min1_ad
              z1_ad = 0.0_FVPRC
            END IF
            y1_ad = 0.0_FVPRC
          END IF
          v_ad(i, j) = v_ad(i, j) + z1_ad
          min14_ad = -z1_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              v_ad(i, j+1) = v_ad(i, j+1) + min14_ad
            ELSE
              v_ad(i, j) = v_ad(i, j) + min14_ad
            END IF
          ELSE IF (branch .EQ. 2) THEN
            v_ad(i, j+1) = v_ad(i, j+1) + min14_ad
          ELSE
            v_ad(i, j-1) = v_ad(i, j-1) + min14_ad
          END IF
          max1_ad = y1_ad
          v_ad(i, j) = v_ad(i, j) - y1_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              v_ad(i, j+1) = v_ad(i, j+1) + max1_ad
            ELSE
              v_ad(i, j) = v_ad(i, j) + max1_ad
            END IF
          ELSE IF (branch .EQ. 2) THEN
            v_ad(i, j+1) = v_ad(i, j+1) + max1_ad
          ELSE
            v_ad(i, j-1) = v_ad(i, j-1) + max1_ad
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            xt_ad = x2_ad
          ELSE
            xt_ad = -x2_ad
          END IF
          v_ad(i, j+1) = v_ad(i, j+1) + 0.25*xt_ad
          v_ad(i, j-1) = v_ad(i, j-1) - 0.25*xt_ad
        END DO
      END DO
    CASE (4) 
      DO j=js-2,je+2
        DO i=is,ie+1
          xt = 0.25*(v(i, j+1)-v(i, j-1))
          IF (xt .GE. 0.) THEN
            x7 = xt
            CALL PUSHCONTROL1B(0)
          ELSE
            x7 = -xt
            CALL PUSHCONTROL1B(1)
          END IF
          IF (v(i, j-1) .LT. v(i, j)) THEN
            IF (v(i, j) .LT. v(i, j+1)) THEN
              max6 = v(i, j+1)
              CALL PUSHCONTROL2B(0)
            ELSE
              max6 = v(i, j)
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE IF (v(i, j-1) .LT. v(i, j+1)) THEN
            max6 = v(i, j+1)
            CALL PUSHCONTROL2B(2)
          ELSE
            max6 = v(i, j-1)
            CALL PUSHCONTROL2B(3)
          END IF
          y6 = max6 - v(i, j)
          IF (v(i, j-1) .GT. v(i, j)) THEN
            IF (v(i, j) .GT. v(i, j+1)) THEN
              min19 = v(i, j+1)
              CALL PUSHCONTROL2B(0)
            ELSE
              min19 = v(i, j)
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE IF (v(i, j-1) .GT. v(i, j+1)) THEN
            min19 = v(i, j+1)
            CALL PUSHCONTROL2B(2)
          ELSE
            min19 = v(i, j-1)
            CALL PUSHCONTROL2B(3)
          END IF
          z6 = v(i, j) - min19
          IF (x7 .GT. y6) THEN
            IF (y6 .GT. z6) THEN
              CALL PUSHREALARRAY_ADM(min6)
              min6 = z6
              CALL PUSHCONTROL2B(0)
            ELSE
              CALL PUSHREALARRAY_ADM(min6)
              min6 = y6
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE IF (x7 .GT. z6) THEN
            CALL PUSHREALARRAY_ADM(min6)
            min6 = z6
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHREALARRAY_ADM(min6)
            min6 = x7
            CALL PUSHCONTROL2B(3)
          END IF
          dm(i, j) = SIGN(min6, xt)
        END DO
      END DO
      DO j=js-1,je+2
        DO i=is,ie+1
          al(i, j) = 0.5*(v(i, j-1)+v(i, j)) + r3*(dm(i, j-1)-dm(i, j))
        END DO
      END DO
      IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
        IF (js .EQ. 1) THEN
          DO i=is,ie+1
            x0l = 0.5*((2.*dy(i, 0)+dy(i, -1))*v(i, 0)-dy(i, 0)*v(i, -1)&
&             )/(dy(i, 0)+dy(i, -1))
            x0r = 0.5*((2.*dy(i, 1)+dy(i, 2))*v(i, 1)-dy(i, 1)*v(i, 2))/&
&             (dy(i, 1)+dy(i, 2))
            x0 = x0l + x0r
            x1 = s15*v(i, 1) + s11*v(i, 2) - s14*dm(i, 2)
            dm(i, 1) = 0.5*(x1-x0)
!           dm(i,1) = sign(min(abs(dm(i,1)), max(v(i,1), x0, x1) - v(i,1),   &
!                                   v(i,1) - min(v(i,1), x0, x1)), dm(i,1))
            x1 = s15*v(i, 0) + s11*v(i, -1) + s14*dm(i, -1)
            dm(i, 0) = 0.5*(x0-x1)
!           dm(i,0) = sign(min(abs(dm(i,0)), max(v(i,0), x0, x1) - v(i,0),   &
!                                   v(i,0) - min(v(i,0), x0, x1)), dm(i,0))
            al(i, 0) = 0.5*(v(i, -1)+v(i, 0)) + r3*(dm(i, -1)-dm(i, 0))
            al(i, 1) = x0
            al(i, 2) = 0.5*(v(i, 1)+v(i, 2)) + r3*(dm(i, 1)-dm(i, 2))
          END DO
          IF (is .EQ. 1) THEN
            dm(1, 0) = 0.
            dm(1, 1) = 0.
            i = 1
            al(i, 0) = 0.5*(v(i, -1)+v(i, 0)) + r3*(dm(i, -1)-dm(i, 0))
            al(i, 2) = 0.5*(v(i, 1)+v(i, 2)) + r3*(dm(i, 1)-dm(i, 2))
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (ie + 1 .EQ. npx) THEN
            dm(npx, 0) = 0.
            dm(npx, 1) = 0.
            i = npx
            al(i, 0) = 0.5*(v(i, -1)+v(i, 0)) + r3*dm(i, -1)
            al(i, 2) = 0.5*(v(i, 1)+v(i, 2)) - r3*dm(i, 2)
            CALL PUSHCONTROL2B(0)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
        IF (je + 1 .EQ. npy) THEN
          CALL PUSHINTEGER4(i)
          DO i=is,ie+1
            x0l = 0.5*((2.*dy(i, npy-1)+dy(i, npy-2))*v(i, npy-1)-dy(i, &
&             npy-1)*v(i, npy-2))/(dy(i, npy-1)+dy(i, npy-2))
            x0r = 0.5*((2.*dy(i, npy)+dy(i, npy+1))*v(i, npy)-dy(i, npy)&
&             *v(i, npy+1))/(dy(i, npy)+dy(i, npy+1))
            x0 = x0l + x0r
            x1 = s15*v(i, npy-1) + s11*v(i, npy-2) + s14*dm(i, npy-2)
            dm(i, npy-1) = 0.5*(x0-x1)
!           dm(i,npy-1) = sign(min(abs(dm(i,npy-1)), max(v(i,npy-1), x0, x1) - v(i,npy-1),  &
!                                       v(i,npy-1) - min(v(i,npy-1), x0, x1)), dm(i,npy-1))
            x1 = s15*v(i, npy) + s11*v(i, npy+1) - s14*dm(i, npy+1)
            dm(i, npy) = 0.5*(x1-x0)
!           dm(i,npy) = sign(min(abs(dm(i,npy)), max(v(i,npy), x0, x1) - v(i,npy),   &
!                                     v(i,npy) - min(v(i,npy), x0, x1)), dm(i,npy))
            al(i, npy-1) = 0.5*(v(i, npy-2)+v(i, npy-1)) + r3*(dm(i, npy&
&             -2)-dm(i, npy-1))
            al(i, npy) = x0
            al(i, npy+1) = 0.5*(v(i, npy)+v(i, npy+1)) + r3*(dm(i, npy)-&
&             dm(i, npy+1))
          END DO
          IF (is .EQ. 1) THEN
            dm(1, npy-1) = 0.
            dm(1, npy) = 0.
            i = 1
            al(i, npy-1) = 0.5*(v(i, npy-2)+v(i, npy-1)) + r3*dm(i, npy-&
&             2)
            al(i, npy+1) = 0.5*(v(i, npy)+v(i, npy+1)) - r3*dm(i, npy+1)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (ie + 1 .EQ. npx) THEN
            dm(npx, npy-1) = 0.
            dm(npx, npy) = 0.
            i = npx
            al(i, npy-1) = 0.5*(v(i, npy-2)+v(i, npy-1)) + r3*dm(i, npy-&
&             2)
            al(i, npy+1) = 0.5*(v(i, npy)+v(i, npy+1)) - r3*dm(i, npy+1)
            CALL PUSHCONTROL2B(3)
          ELSE
            CALL PUSHCONTROL2B(2)
          END IF
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
      DO j=js,je+1
        CALL PUSHINTEGER4(i)
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            xt = 2.*dm(i, j-1)
            IF (xt .GE. 0.) THEN
              x8 = xt
              CALL PUSHCONTROL1B(0)
            ELSE
              x8 = -xt
              CALL PUSHCONTROL1B(1)
            END IF
            IF (al(i, j-1) - v(i, j-1) .GE. 0.) THEN
              y7 = al(i, j-1) - v(i, j-1)
              CALL PUSHCONTROL1B(0)
            ELSE
              y7 = -(al(i, j-1)-v(i, j-1))
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x8 .GT. y7) THEN
              CALL PUSHREALARRAY_ADM(min7)
              min7 = y7
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREALARRAY_ADM(min7)
              min7 = x8
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREALARRAY_ADM(dl)
            dl = SIGN(min7, xt)
            IF (xt .GE. 0.) THEN
              x9 = xt
              CALL PUSHCONTROL1B(0)
            ELSE
              x9 = -xt
              CALL PUSHCONTROL1B(1)
            END IF
            IF (al(i, j) - v(i, j-1) .GE. 0.) THEN
              y8 = al(i, j) - v(i, j-1)
              CALL PUSHCONTROL1B(0)
            ELSE
              y8 = -(al(i, j)-v(i, j-1))
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x9 .GT. y8) THEN
              CALL PUSHREALARRAY_ADM(min8)
              min8 = y8
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREALARRAY_ADM(min8)
              min8 = x9
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREALARRAY_ADM(dr)
            dr = SIGN(min8, xt)
            CALL PUSHCONTROL1B(1)
          ELSE
            xt = 2.*dm(i, j)
            IF (xt .GE. 0.) THEN
              x10 = xt
              CALL PUSHCONTROL1B(0)
            ELSE
              x10 = -xt
              CALL PUSHCONTROL1B(1)
            END IF
            IF (al(i, j) - v(i, j) .GE. 0.) THEN
              y9 = al(i, j) - v(i, j)
              CALL PUSHCONTROL1B(0)
            ELSE
              y9 = -(al(i, j)-v(i, j))
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x10 .GT. y9) THEN
              CALL PUSHREALARRAY_ADM(min9)
              min9 = y9
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREALARRAY_ADM(min9)
              min9 = x10
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREALARRAY_ADM(dl)
            dl = SIGN(min9, xt)
            IF (xt .GE. 0.) THEN
              x11 = xt
              CALL PUSHCONTROL1B(0)
            ELSE
              x11 = -xt
              CALL PUSHCONTROL1B(1)
            END IF
            IF (al(i, j+1) - v(i, j) .GE. 0.) THEN
              y10 = al(i, j+1) - v(i, j)
              CALL PUSHCONTROL1B(0)
            ELSE
              y10 = -(al(i, j+1)-v(i, j))
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x11 .GT. y10) THEN
              CALL PUSHREALARRAY_ADM(min10)
              min10 = y10
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHREALARRAY_ADM(min10)
              min10 = x11
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREALARRAY_ADM(dr)
            dr = SIGN(min10, xt)
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      dm_ad = 0.0_FVPRC
      al_ad = 0.0_FVPRC
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            cfl = c(i, j)*rdy(i, j)
            temp_ad18 = -((cfl+1.)*flux_ad(i, j))
            v_ad(i, j) = v_ad(i, j) + flux_ad(i, j)
            cfl_ad = (dl-dr)*temp_ad18 - (dl+cfl*(dl-dr))*flux_ad(i, j)
            dl_ad = (cfl+1.0)*temp_ad18
            dr_ad = -(cfl*temp_ad18)
            flux_ad(i, j) = 0.0_FVPRC
            c_ad(i, j) = c_ad(i, j) + rdy(i, j)*cfl_ad
            xt = 2.*dm(i, j)
            CALL POPREALARRAY_ADM(dr)
            min10_ad = SIGN(1.d0, min10*xt)*dr_ad
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(min10)
              y10_ad = min10_ad
              x11_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min10)
              x11_ad = min10_ad
              y10_ad = 0.0_FVPRC
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              al_ad(i, j+1) = al_ad(i, j+1) + y10_ad
              v_ad(i, j) = v_ad(i, j) - y10_ad
            ELSE
              v_ad(i, j) = v_ad(i, j) + y10_ad
              al_ad(i, j+1) = al_ad(i, j+1) - y10_ad
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              xt_ad = x11_ad
            ELSE
              xt_ad = -x11_ad
            END IF
            CALL POPREALARRAY_ADM(dl)
            min9_ad = SIGN(1.d0, min9*xt)*dl_ad
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(min9)
              y9_ad = min9_ad
              x10_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min9)
              x10_ad = min9_ad
              y9_ad = 0.0_FVPRC
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              al_ad(i, j) = al_ad(i, j) + y9_ad
              v_ad(i, j) = v_ad(i, j) - y9_ad
            ELSE
              v_ad(i, j) = v_ad(i, j) + y9_ad
              al_ad(i, j) = al_ad(i, j) - y9_ad
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              xt_ad = xt_ad + x10_ad
            ELSE
              xt_ad = xt_ad - x10_ad
            END IF
            dm_ad(i, j) = dm_ad(i, j) + 2.*xt_ad
          ELSE
            cfl = c(i, j)*rdy(i, j-1)
            temp_ad17 = (1.-cfl)*flux_ad(i, j)
            v_ad(i, j-1) = v_ad(i, j-1) + flux_ad(i, j)
            cfl_ad = (dl-dr)*temp_ad17 - (dr+cfl*(dl-dr))*flux_ad(i, j)
            dr_ad = (1.0-cfl)*temp_ad17
            dl_ad = cfl*temp_ad17
            flux_ad(i, j) = 0.0_FVPRC
            c_ad(i, j) = c_ad(i, j) + rdy(i, j-1)*cfl_ad
            xt = 2.*dm(i, j-1)
            CALL POPREALARRAY_ADM(dr)
            min8_ad = SIGN(1.d0, min8*xt)*dr_ad
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(min8)
              y8_ad = min8_ad
              x9_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min8)
              x9_ad = min8_ad
              y8_ad = 0.0_FVPRC
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              al_ad(i, j) = al_ad(i, j) + y8_ad
              v_ad(i, j-1) = v_ad(i, j-1) - y8_ad
            ELSE
              v_ad(i, j-1) = v_ad(i, j-1) + y8_ad
              al_ad(i, j) = al_ad(i, j) - y8_ad
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              xt_ad = x9_ad
            ELSE
              xt_ad = -x9_ad
            END IF
            CALL POPREALARRAY_ADM(dl)
            min7_ad = SIGN(1.d0, min7*xt)*dl_ad
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(min7)
              y7_ad = min7_ad
              x8_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min7)
              x8_ad = min7_ad
              y7_ad = 0.0_FVPRC
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              al_ad(i, j-1) = al_ad(i, j-1) + y7_ad
              v_ad(i, j-1) = v_ad(i, j-1) - y7_ad
            ELSE
              v_ad(i, j-1) = v_ad(i, j-1) + y7_ad
              al_ad(i, j-1) = al_ad(i, j-1) - y7_ad
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              xt_ad = xt_ad + x8_ad
            ELSE
              xt_ad = xt_ad - x8_ad
            END IF
            dm_ad(i, j-1) = dm_ad(i, j-1) + 2.*xt_ad
          END IF
        END DO
        CALL POPINTEGER4(i)
      END DO
      CALL POPCONTROL2B(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) GOTO 110
      ELSE
        IF (branch .NE. 2) THEN
          i = npx
          v_ad(i, npy) = v_ad(i, npy) + 0.5*al_ad(i, npy+1)
          v_ad(i, npy+1) = v_ad(i, npy+1) + 0.5*al_ad(i, npy+1)
          dm_ad(i, npy+1) = dm_ad(i, npy+1) - r3*al_ad(i, npy+1)
          al_ad(i, npy+1) = 0.0_FVPRC
          v_ad(i, npy-2) = v_ad(i, npy-2) + 0.5*al_ad(i, npy-1)
          v_ad(i, npy-1) = v_ad(i, npy-1) + 0.5*al_ad(i, npy-1)
          dm_ad(i, npy-2) = dm_ad(i, npy-2) + r3*al_ad(i, npy-1)
          al_ad(i, npy-1) = 0.0_FVPRC
          dm_ad(npx, npy) = 0.0_FVPRC
          dm_ad(npx, npy-1) = 0.0_FVPRC
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          i = 1
          v_ad(i, npy) = v_ad(i, npy) + 0.5*al_ad(i, npy+1)
          v_ad(i, npy+1) = v_ad(i, npy+1) + 0.5*al_ad(i, npy+1)
          dm_ad(i, npy+1) = dm_ad(i, npy+1) - r3*al_ad(i, npy+1)
          al_ad(i, npy+1) = 0.0_FVPRC
          v_ad(i, npy-2) = v_ad(i, npy-2) + 0.5*al_ad(i, npy-1)
          v_ad(i, npy-1) = v_ad(i, npy-1) + 0.5*al_ad(i, npy-1)
          dm_ad(i, npy-2) = dm_ad(i, npy-2) + r3*al_ad(i, npy-1)
          al_ad(i, npy-1) = 0.0_FVPRC
          dm_ad(1, npy) = 0.0_FVPRC
          dm_ad(1, npy-1) = 0.0_FVPRC
        END IF
        DO i=ie+1,is,-1
          v_ad(i, npy) = v_ad(i, npy) + 0.5*al_ad(i, npy+1)
          v_ad(i, npy+1) = v_ad(i, npy+1) + 0.5*al_ad(i, npy+1)
          dm_ad(i, npy) = dm_ad(i, npy) + r3*al_ad(i, npy+1)
          dm_ad(i, npy+1) = dm_ad(i, npy+1) - r3*al_ad(i, npy+1)
          al_ad(i, npy+1) = 0.0_FVPRC
          x0_ad = al_ad(i, npy)
          al_ad(i, npy) = 0.0_FVPRC
          v_ad(i, npy-2) = v_ad(i, npy-2) + 0.5*al_ad(i, npy-1)
          v_ad(i, npy-1) = v_ad(i, npy-1) + 0.5*al_ad(i, npy-1)
          dm_ad(i, npy-2) = dm_ad(i, npy-2) + r3*al_ad(i, npy-1)
          dm_ad(i, npy-1) = dm_ad(i, npy-1) - r3*al_ad(i, npy-1)
          al_ad(i, npy-1) = 0.0_FVPRC
          x1_ad = 0.5*dm_ad(i, npy)
          x0_ad = x0_ad - 0.5*dm_ad(i, npy)
          dm_ad(i, npy) = 0.0_FVPRC
          v_ad(i, npy) = v_ad(i, npy) + s15*x1_ad
          v_ad(i, npy+1) = v_ad(i, npy+1) + s11*x1_ad
          dm_ad(i, npy+1) = dm_ad(i, npy+1) - s14*x1_ad
          x0_ad = x0_ad + 0.5*dm_ad(i, npy-1)
          x1_ad = -(0.5*dm_ad(i, npy-1))
          dm_ad(i, npy-1) = 0.0_FVPRC
          v_ad(i, npy-1) = v_ad(i, npy-1) + s15*x1_ad
          v_ad(i, npy-2) = v_ad(i, npy-2) + s11*x1_ad
          dm_ad(i, npy-2) = dm_ad(i, npy-2) + s14*x1_ad
          x0l_ad = x0_ad
          x0r_ad = x0_ad
          temp_ad15 = 0.5*x0r_ad/(dy(i, npy)+dy(i, npy+1))
          v_ad(i, npy) = v_ad(i, npy) + (dy(i, npy)*2.+dy(i, npy+1))*&
&           temp_ad15
          v_ad(i, npy+1) = v_ad(i, npy+1) - dy(i, npy)*temp_ad15
          temp_ad16 = 0.5*x0l_ad/(dy(i, npy-1)+dy(i, npy-2))
          v_ad(i, npy-1) = v_ad(i, npy-1) + (dy(i, npy-1)*2.+dy(i, npy-2&
&           ))*temp_ad16
          v_ad(i, npy-2) = v_ad(i, npy-2) - dy(i, npy-1)*temp_ad16
        END DO
        CALL POPINTEGER4(i)
      END IF
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        i = npx
        v_ad(i, 1) = v_ad(i, 1) + 0.5*al_ad(i, 2)
        v_ad(i, 2) = v_ad(i, 2) + 0.5*al_ad(i, 2)
        dm_ad(i, 2) = dm_ad(i, 2) - r3*al_ad(i, 2)
        al_ad(i, 2) = 0.0_FVPRC
        v_ad(i, -1) = v_ad(i, -1) + 0.5*al_ad(i, 0)
        v_ad(i, 0) = v_ad(i, 0) + 0.5*al_ad(i, 0)
        dm_ad(i, -1) = dm_ad(i, -1) + r3*al_ad(i, 0)
        al_ad(i, 0) = 0.0_FVPRC
        dm_ad(npx, 1) = 0.0_FVPRC
        dm_ad(npx, 0) = 0.0_FVPRC
      ELSE IF (branch .NE. 1) THEN
        GOTO 110
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        i = 1
        v_ad(i, 1) = v_ad(i, 1) + 0.5*al_ad(i, 2)
        v_ad(i, 2) = v_ad(i, 2) + 0.5*al_ad(i, 2)
        dm_ad(i, 1) = dm_ad(i, 1) + r3*al_ad(i, 2)
        dm_ad(i, 2) = dm_ad(i, 2) - r3*al_ad(i, 2)
        al_ad(i, 2) = 0.0_FVPRC
        v_ad(i, -1) = v_ad(i, -1) + 0.5*al_ad(i, 0)
        v_ad(i, 0) = v_ad(i, 0) + 0.5*al_ad(i, 0)
        dm_ad(i, -1) = dm_ad(i, -1) + r3*al_ad(i, 0)
        dm_ad(i, 0) = dm_ad(i, 0) - r3*al_ad(i, 0)
        al_ad(i, 0) = 0.0_FVPRC
        dm_ad(1, 1) = 0.0_FVPRC
        dm_ad(1, 0) = 0.0_FVPRC
      END IF
      DO i=ie+1,is,-1
        v_ad(i, 1) = v_ad(i, 1) + 0.5*al_ad(i, 2)
        v_ad(i, 2) = v_ad(i, 2) + 0.5*al_ad(i, 2)
        dm_ad(i, 1) = dm_ad(i, 1) + r3*al_ad(i, 2)
        dm_ad(i, 2) = dm_ad(i, 2) - r3*al_ad(i, 2)
        al_ad(i, 2) = 0.0_FVPRC
        x0_ad = al_ad(i, 1)
        al_ad(i, 1) = 0.0_FVPRC
        v_ad(i, -1) = v_ad(i, -1) + 0.5*al_ad(i, 0)
        dm_ad(i, -1) = dm_ad(i, -1) + r3*al_ad(i, 0)
        dm_ad(i, 0) = dm_ad(i, 0) - r3*al_ad(i, 0)
        x0_ad = x0_ad + 0.5*dm_ad(i, 0)
        x1_ad = -(0.5*dm_ad(i, 0))
        v_ad(i, 0) = v_ad(i, 0) + s15*x1_ad + 0.5*al_ad(i, 0)
        al_ad(i, 0) = 0.0_FVPRC
        dm_ad(i, 0) = 0.0_FVPRC
        v_ad(i, -1) = v_ad(i, -1) + s11*x1_ad
        dm_ad(i, -1) = dm_ad(i, -1) + s14*x1_ad
        x1_ad = 0.5*dm_ad(i, 1)
        x0_ad = x0_ad - 0.5*dm_ad(i, 1)
        dm_ad(i, 1) = 0.0_FVPRC
        v_ad(i, 1) = v_ad(i, 1) + s15*x1_ad
        v_ad(i, 2) = v_ad(i, 2) + s11*x1_ad
        dm_ad(i, 2) = dm_ad(i, 2) - s14*x1_ad
        x0l_ad = x0_ad
        x0r_ad = x0_ad
        temp_ad13 = 0.5*x0r_ad/(dy(i, 1)+dy(i, 2))
        v_ad(i, 1) = v_ad(i, 1) + (dy(i, 1)*2.+dy(i, 2))*temp_ad13
        v_ad(i, 2) = v_ad(i, 2) - dy(i, 1)*temp_ad13
        temp_ad14 = 0.5*x0l_ad/(dy(i, 0)+dy(i, -1))
        v_ad(i, 0) = v_ad(i, 0) + (dy(i, 0)*2.+dy(i, -1))*temp_ad14
        v_ad(i, -1) = v_ad(i, -1) - dy(i, 0)*temp_ad14
      END DO
 110  DO j=je+2,js-1,-1
        DO i=ie+1,is,-1
          v_ad(i, j-1) = v_ad(i, j-1) + 0.5*al_ad(i, j)
          v_ad(i, j) = v_ad(i, j) + 0.5*al_ad(i, j)
          dm_ad(i, j-1) = dm_ad(i, j-1) + r3*al_ad(i, j)
          dm_ad(i, j) = dm_ad(i, j) - r3*al_ad(i, j)
          al_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      DO j=je+2,js-2,-1
        DO i=ie+1,is,-1
          xt = 0.25*(v(i, j+1)-v(i, j-1))
          min6_ad = SIGN(1.d0, min6*xt)*dm_ad(i, j)
          dm_ad(i, j) = 0.0_FVPRC
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(min6)
              z6_ad = min6_ad
              y6_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min6)
              y6_ad = min6_ad
              z6_ad = 0.0_FVPRC
            END IF
            x7_ad = 0.0_FVPRC
          ELSE
            IF (branch .EQ. 2) THEN
              CALL POPREALARRAY_ADM(min6)
              z6_ad = min6_ad
              x7_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min6)
              x7_ad = min6_ad
              z6_ad = 0.0_FVPRC
            END IF
            y6_ad = 0.0_FVPRC
          END IF
          v_ad(i, j) = v_ad(i, j) + z6_ad
          min19_ad = -z6_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              v_ad(i, j+1) = v_ad(i, j+1) + min19_ad
            ELSE
              v_ad(i, j) = v_ad(i, j) + min19_ad
            END IF
          ELSE IF (branch .EQ. 2) THEN
            v_ad(i, j+1) = v_ad(i, j+1) + min19_ad
          ELSE
            v_ad(i, j-1) = v_ad(i, j-1) + min19_ad
          END IF
          max6_ad = y6_ad
          v_ad(i, j) = v_ad(i, j) - y6_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              v_ad(i, j+1) = v_ad(i, j+1) + max6_ad
            ELSE
              v_ad(i, j) = v_ad(i, j) + max6_ad
            END IF
          ELSE IF (branch .EQ. 2) THEN
            v_ad(i, j+1) = v_ad(i, j+1) + max6_ad
          ELSE
            v_ad(i, j-1) = v_ad(i, j-1) + max6_ad
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            xt_ad = x7_ad
          ELSE
            xt_ad = -x7_ad
          END IF
          v_ad(i, j+1) = v_ad(i, j+1) + 0.25*xt_ad
          v_ad(i, j-1) = v_ad(i, j-1) - 0.25*xt_ad
        END DO
      END DO
    CASE (6) 
      DO j=js3,je3+1
        DO i=is,ie+1
          al(i, j) = p1*(v(i, j-1)+v(i, j)) + p2*(v(i, j-2)+v(i, j+1))
        END DO
      END DO
      DO j=js3,je3
        DO i=is,ie+1
          bl(i, j) = al(i, j) - v(i, j)
          br(i, j) = al(i, j+1) - v(i, j)
        END DO
      END DO
      IF (.NOT.nested .AND. grid_type .LT. 3) THEN
        IF (js .EQ. 1) THEN
          DO i=is,ie+1
            bl(i, 0) = c1*v(i, -2) + c2*v(i, -1) + c3*v(i, 0) - v(i, 0)
            xt = 0.5*(((2.*dy(i, 0)+dy(i, -1))*v(i, 0)-dy(i, 0)*v(i, -1)&
&             )/(dy(i, 0)+dy(i, -1))+((2.*dy(i, 1)+dy(i, 2))*v(i, 1)-dy(&
&             i, 1)*v(i, 2))/(dy(i, 1)+dy(i, 2)))
            br(i, 0) = xt - v(i, 0)
            bl(i, 1) = xt - v(i, 1)
            xt = c3*v(i, 1) + c2*v(i, 2) + c1*v(i, 3)
            br(i, 1) = xt - v(i, 1)
            bl(i, 2) = xt - v(i, 2)
            br(i, 2) = al(i, 3) - v(i, 2)
          END DO
          IF (is .EQ. 1) THEN
! out
            bl(1, 0) = 0.
! edge
            br(1, 0) = 0.
! edge
            bl(1, 1) = 0.
! in
            br(1, 1) = 0.
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (ie + 1 .EQ. npx) THEN
! out
            bl(npx, 0) = 0.
! edge
            br(npx, 0) = 0.
! edge
            bl(npx, 1) = 0.
! in
            br(npx, 1) = 0.
            CALL PUSHCONTROL2B(0)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
        IF (je + 1 .EQ. npy) THEN
          DO i=is,ie+1
            bl(i, npy-2) = al(i, npy-2) - v(i, npy-2)
            xt = c1*v(i, npy-3) + c2*v(i, npy-2) + c3*v(i, npy-1)
            br(i, npy-2) = xt - v(i, npy-2)
            bl(i, npy-1) = xt - v(i, npy-1)
            xt = 0.5*(((2.*dy(i, npy-1)+dy(i, npy-2))*v(i, npy-1)-dy(i, &
&             npy-1)*v(i, npy-2))/(dy(i, npy-1)+dy(i, npy-2))+((2.*dy(i&
&             , npy)+dy(i, npy+1))*v(i, npy)-dy(i, npy)*v(i, npy+1))/(dy&
&             (i, npy)+dy(i, npy+1)))
            br(i, npy-1) = xt - v(i, npy-1)
            bl(i, npy) = xt - v(i, npy)
            br(i, npy) = c3*v(i, npy) + c2*v(i, npy+1) + c1*v(i, npy+2) &
&             - v(i, npy)
          END DO
          IF (is .EQ. 1) THEN
! in
            bl(1, npy-1) = 0.
! edge
            br(1, npy-1) = 0.
! edge
            bl(1, npy) = 0.
! out
            br(1, npy) = 0.
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (ie + 1 .EQ. npx) THEN
! in
            bl(npx, npy-1) = 0.
! edge
            br(npx, npy-1) = 0.
! edge
            bl(npx, npy) = 0.
! out
            br(npx, npy) = 0.
            CALL PUSHCONTROL2B(3)
          ELSE
            CALL PUSHCONTROL2B(2)
          END IF
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      bl_ad = 0.0_FVPRC
      br_ad = 0.0_FVPRC
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            cfl = c(i, j)*rdy(i, j)
            temp0 = bl(i, j) + br(i, j)
            temp_ad24 = (cfl+1.)*flux_ad(i, j)
            v_ad(i, j) = v_ad(i, j) + flux_ad(i, j)
            cfl_ad = temp0*temp_ad24 + (bl(i, j)+cfl*temp0)*flux_ad(i, j&
&             )
            bl_ad(i, j) = bl_ad(i, j) + (cfl+1.0)*temp_ad24
            br_ad(i, j) = br_ad(i, j) + cfl*temp_ad24
            flux_ad(i, j) = 0.0_FVPRC
            c_ad(i, j) = c_ad(i, j) + rdy(i, j)*cfl_ad
          ELSE
            cfl = c(i, j)*rdy(i, j-1)
            temp = bl(i, j-1) + br(i, j-1)
            temp_ad23 = (1.-cfl)*flux_ad(i, j)
            v_ad(i, j-1) = v_ad(i, j-1) + flux_ad(i, j)
            cfl_ad = -(temp*temp_ad23) - (br(i, j-1)-cfl*temp)*flux_ad(i&
&             , j)
            br_ad(i, j-1) = br_ad(i, j-1) + (1.0-cfl)*temp_ad23
            bl_ad(i, j-1) = bl_ad(i, j-1) - cfl*temp_ad23
            flux_ad(i, j) = 0.0_FVPRC
            c_ad(i, j) = c_ad(i, j) + rdy(i, j-1)*cfl_ad
          END IF
        END DO
      END DO
      CALL POPCONTROL2B(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          al_ad = 0.0_FVPRC
          GOTO 120
        ELSE
          al_ad = 0.0_FVPRC
        END IF
      ELSE
        IF (branch .NE. 2) THEN
          br_ad(npx, npy) = 0.0_FVPRC
          bl_ad(npx, npy) = 0.0_FVPRC
          br_ad(npx, npy-1) = 0.0_FVPRC
          bl_ad(npx, npy-1) = 0.0_FVPRC
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          br_ad(1, npy) = 0.0_FVPRC
          bl_ad(1, npy) = 0.0_FVPRC
          br_ad(1, npy-1) = 0.0_FVPRC
          bl_ad(1, npy-1) = 0.0_FVPRC
        END IF
        al_ad = 0.0_FVPRC
        DO i=ie+1,is,-1
          v_ad(i, npy) = v_ad(i, npy) + (c3-1.0)*br_ad(i, npy)
          v_ad(i, npy+1) = v_ad(i, npy+1) + c2*br_ad(i, npy)
          v_ad(i, npy+2) = v_ad(i, npy+2) + c1*br_ad(i, npy)
          br_ad(i, npy) = 0.0_FVPRC
          xt_ad = br_ad(i, npy-1) + bl_ad(i, npy)
          v_ad(i, npy) = v_ad(i, npy) - bl_ad(i, npy)
          bl_ad(i, npy) = 0.0_FVPRC
          temp_ad21 = 0.5*xt_ad/(dy(i, npy-1)+dy(i, npy-2))
          v_ad(i, npy-1) = v_ad(i, npy-1) + (dy(i, npy-1)*2.+dy(i, npy-2&
&           ))*temp_ad21 - br_ad(i, npy-1)
          br_ad(i, npy-1) = 0.0_FVPRC
          temp_ad22 = 0.5*xt_ad/(dy(i, npy)+dy(i, npy+1))
          v_ad(i, npy-2) = v_ad(i, npy-2) - dy(i, npy-1)*temp_ad21
          v_ad(i, npy) = v_ad(i, npy) + (dy(i, npy)*2.+dy(i, npy+1))*&
&           temp_ad22
          v_ad(i, npy+1) = v_ad(i, npy+1) - dy(i, npy)*temp_ad22
          xt_ad = br_ad(i, npy-2) + bl_ad(i, npy-1)
          v_ad(i, npy-1) = v_ad(i, npy-1) - bl_ad(i, npy-1)
          bl_ad(i, npy-1) = 0.0_FVPRC
          v_ad(i, npy-2) = v_ad(i, npy-2) - br_ad(i, npy-2)
          br_ad(i, npy-2) = 0.0_FVPRC
          v_ad(i, npy-3) = v_ad(i, npy-3) + c1*xt_ad
          v_ad(i, npy-2) = v_ad(i, npy-2) + c2*xt_ad
          v_ad(i, npy-1) = v_ad(i, npy-1) + c3*xt_ad
          al_ad(i, npy-2) = al_ad(i, npy-2) + bl_ad(i, npy-2)
          v_ad(i, npy-2) = v_ad(i, npy-2) - bl_ad(i, npy-2)
          bl_ad(i, npy-2) = 0.0_FVPRC
        END DO
      END IF
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        br_ad(npx, 1) = 0.0_FVPRC
        bl_ad(npx, 1) = 0.0_FVPRC
        br_ad(npx, 0) = 0.0_FVPRC
        bl_ad(npx, 0) = 0.0_FVPRC
      ELSE IF (branch .NE. 1) THEN
        GOTO 120
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        br_ad(1, 1) = 0.0_FVPRC
        bl_ad(1, 1) = 0.0_FVPRC
        br_ad(1, 0) = 0.0_FVPRC
        bl_ad(1, 0) = 0.0_FVPRC
      END IF
      DO i=ie+1,is,-1
        al_ad(i, 3) = al_ad(i, 3) + br_ad(i, 2)
        v_ad(i, 2) = v_ad(i, 2) - bl_ad(i, 2) - br_ad(i, 2)
        br_ad(i, 2) = 0.0_FVPRC
        xt_ad = br_ad(i, 1) + bl_ad(i, 2)
        bl_ad(i, 2) = 0.0_FVPRC
        v_ad(i, 1) = v_ad(i, 1) + c3*xt_ad - br_ad(i, 1)
        br_ad(i, 1) = 0.0_FVPRC
        v_ad(i, 2) = v_ad(i, 2) + c2*xt_ad
        v_ad(i, 3) = v_ad(i, 3) + c1*xt_ad
        xt_ad = br_ad(i, 0) + bl_ad(i, 1)
        v_ad(i, 1) = v_ad(i, 1) - bl_ad(i, 1)
        bl_ad(i, 1) = 0.0_FVPRC
        temp_ad19 = 0.5*xt_ad/(dy(i, 0)+dy(i, -1))
        v_ad(i, 0) = v_ad(i, 0) + (dy(i, 0)*2.+dy(i, -1))*temp_ad19 - &
&         br_ad(i, 0)
        br_ad(i, 0) = 0.0_FVPRC
        temp_ad20 = 0.5*xt_ad/(dy(i, 1)+dy(i, 2))
        v_ad(i, -1) = v_ad(i, -1) - dy(i, 0)*temp_ad19
        v_ad(i, 1) = v_ad(i, 1) + (dy(i, 1)*2.+dy(i, 2))*temp_ad20
        v_ad(i, 2) = v_ad(i, 2) - dy(i, 1)*temp_ad20
        v_ad(i, -2) = v_ad(i, -2) + c1*bl_ad(i, 0)
        v_ad(i, -1) = v_ad(i, -1) + c2*bl_ad(i, 0)
        v_ad(i, 0) = v_ad(i, 0) + (c3-1.0)*bl_ad(i, 0)
        bl_ad(i, 0) = 0.0_FVPRC
      END DO
 120  DO j=je3,js3,-1
        DO i=ie+1,is,-1
          al_ad(i, j+1) = al_ad(i, j+1) + br_ad(i, j)
          v_ad(i, j) = v_ad(i, j) - bl_ad(i, j) - br_ad(i, j)
          br_ad(i, j) = 0.0_FVPRC
          al_ad(i, j) = al_ad(i, j) + bl_ad(i, j)
          bl_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      DO j=je3+1,js3,-1
        DO i=ie+1,is,-1
          v_ad(i, j-1) = v_ad(i, j-1) + p1*al_ad(i, j)
          v_ad(i, j) = v_ad(i, j) + p1*al_ad(i, j)
          v_ad(i, j-2) = v_ad(i, j-2) + p2*al_ad(i, j)
          v_ad(i, j+1) = v_ad(i, j+1) + p2*al_ad(i, j)
          al_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
    CASE DEFAULT
! jord= 8, 9, 10
      DO j=js-2,je+2
        DO i=is,ie+1
          xt = 0.25*(v(i, j+1)-v(i, j-1))
          IF (xt .GE. 0.) THEN
            x12 = xt
            CALL PUSHCONTROL1B(0)
          ELSE
            x12 = -xt
            CALL PUSHCONTROL1B(1)
          END IF
          IF (v(i, j-1) .LT. v(i, j)) THEN
            IF (v(i, j) .LT. v(i, j+1)) THEN
              max7 = v(i, j+1)
              CALL PUSHCONTROL2B(0)
            ELSE
              max7 = v(i, j)
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE IF (v(i, j-1) .LT. v(i, j+1)) THEN
            max7 = v(i, j+1)
            CALL PUSHCONTROL2B(2)
          ELSE
            max7 = v(i, j-1)
            CALL PUSHCONTROL2B(3)
          END IF
          y11 = max7 - v(i, j)
          IF (v(i, j-1) .GT. v(i, j)) THEN
            IF (v(i, j) .GT. v(i, j+1)) THEN
              min20 = v(i, j+1)
              CALL PUSHCONTROL2B(0)
            ELSE
              min20 = v(i, j)
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE IF (v(i, j-1) .GT. v(i, j+1)) THEN
            min20 = v(i, j+1)
            CALL PUSHCONTROL2B(2)
          ELSE
            min20 = v(i, j-1)
            CALL PUSHCONTROL2B(3)
          END IF
          z7 = v(i, j) - min20
          IF (x12 .GT. y11) THEN
            IF (y11 .GT. z7) THEN
              CALL PUSHREALARRAY_ADM(min11)
              min11 = z7
              CALL PUSHCONTROL2B(0)
            ELSE
              CALL PUSHREALARRAY_ADM(min11)
              min11 = y11
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE IF (x12 .GT. z7) THEN
            CALL PUSHREALARRAY_ADM(min11)
            min11 = z7
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHREALARRAY_ADM(min11)
            min11 = x12
            CALL PUSHCONTROL2B(3)
          END IF
          dm(i, j) = SIGN(min11, xt)
        END DO
      END DO
      DO j=js-3,je+2
        DO i=is,ie+1
          dq(i, j) = v(i, j+1) - v(i, j)
        END DO
      END DO
      IF (grid_type .LT. 3) THEN
        DO j=js3,je3+1
          DO i=is,ie+1
            al(i, j) = 0.5*(v(i, j-1)+v(i, j)) + r3*(dm(i, j-1)-dm(i, j)&
&             )
          END DO
        END DO
        IF (jord .EQ. 8) THEN
          DO j=js3,je3
            DO i=is,ie+1
              xt = 2.*dm(i, j)
              IF (xt .GE. 0.) THEN
                x13 = xt
                CALL PUSHCONTROL1B(0)
              ELSE
                x13 = -xt
                CALL PUSHCONTROL1B(1)
              END IF
              IF (al(i, j) - v(i, j) .GE. 0.) THEN
                y12 = al(i, j) - v(i, j)
                CALL PUSHCONTROL1B(0)
              ELSE
                y12 = -(al(i, j)-v(i, j))
                CALL PUSHCONTROL1B(1)
              END IF
              IF (x13 .GT. y12) THEN
                CALL PUSHREALARRAY_ADM(min12)
                min12 = y12
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHREALARRAY_ADM(min12)
                min12 = x13
                CALL PUSHCONTROL1B(1)
              END IF
              bl(i, j) = -SIGN(min12, xt)
              IF (xt .GE. 0.) THEN
                x14 = xt
                CALL PUSHCONTROL1B(0)
              ELSE
                x14 = -xt
                CALL PUSHCONTROL1B(1)
              END IF
              IF (al(i, j+1) - v(i, j) .GE. 0.) THEN
                y13 = al(i, j+1) - v(i, j)
                CALL PUSHCONTROL1B(0)
              ELSE
                y13 = -(al(i, j+1)-v(i, j))
                CALL PUSHCONTROL1B(1)
              END IF
              IF (x14 .GT. y13) THEN
                CALL PUSHREALARRAY_ADM(min13)
                min13 = y13
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHREALARRAY_ADM(min13)
                min13 = x14
                CALL PUSHCONTROL1B(1)
              END IF
              br(i, j) = SIGN(min13, xt)
            END DO
          END DO
          CALL PUSHCONTROL2B(0)
        ELSE IF (jord .EQ. 9) THEN
          DO j=js3,je3
            DO i=is,ie+1
              pmp_1 = -(2.*dq(i, j))
              lac_1 = pmp_1 + 1.5*dq(i, j+1)
              IF (0. .LT. pmp_1) THEN
                IF (pmp_1 .LT. lac_1) THEN
                  x15 = lac_1
                  CALL PUSHCONTROL2B(0)
                ELSE
                  x15 = pmp_1
                  CALL PUSHCONTROL2B(1)
                END IF
              ELSE IF (0. .LT. lac_1) THEN
                x15 = lac_1
                CALL PUSHCONTROL2B(2)
              ELSE
                CALL PUSHCONTROL2B(3)
                x15 = 0.
              END IF
              IF (0. .GT. pmp_1) THEN
                IF (pmp_1 .GT. lac_1) THEN
                  y20 = lac_1
                  CALL PUSHCONTROL2B(0)
                ELSE
                  y20 = pmp_1
                  CALL PUSHCONTROL2B(1)
                END IF
              ELSE IF (0. .GT. lac_1) THEN
                y20 = lac_1
                CALL PUSHCONTROL2B(2)
              ELSE
                y20 = 0.
                CALL PUSHCONTROL2B(3)
              END IF
              IF (al(i, j) - v(i, j) .LT. y20) THEN
                y14 = y20
                CALL PUSHCONTROL1B(0)
              ELSE
                y14 = al(i, j) - v(i, j)
                CALL PUSHCONTROL1B(1)
              END IF
              IF (x15 .GT. y14) THEN
                bl(i, j) = y14
                CALL PUSHCONTROL1B(0)
              ELSE
                bl(i, j) = x15
                CALL PUSHCONTROL1B(1)
              END IF
              pmp_2 = 2.*dq(i, j-1)
              lac_2 = pmp_2 - 1.5*dq(i, j-2)
              IF (0. .LT. pmp_2) THEN
                IF (pmp_2 .LT. lac_2) THEN
                  x16 = lac_2
                  CALL PUSHCONTROL2B(0)
                ELSE
                  x16 = pmp_2
                  CALL PUSHCONTROL2B(1)
                END IF
              ELSE IF (0. .LT. lac_2) THEN
                x16 = lac_2
                CALL PUSHCONTROL2B(2)
              ELSE
                CALL PUSHCONTROL2B(3)
                x16 = 0.
              END IF
              IF (0. .GT. pmp_2) THEN
                IF (pmp_2 .GT. lac_2) THEN
                  y21 = lac_2
                  CALL PUSHCONTROL2B(0)
                ELSE
                  y21 = pmp_2
                  CALL PUSHCONTROL2B(1)
                END IF
              ELSE IF (0. .GT. lac_2) THEN
                y21 = lac_2
                CALL PUSHCONTROL2B(2)
              ELSE
                y21 = 0.
                CALL PUSHCONTROL2B(3)
              END IF
              IF (al(i, j+1) - v(i, j) .LT. y21) THEN
                y15 = y21
                CALL PUSHCONTROL1B(0)
              ELSE
                y15 = al(i, j+1) - v(i, j)
                CALL PUSHCONTROL1B(1)
              END IF
              IF (x16 .GT. y15) THEN
                br(i, j) = y15
                CALL PUSHCONTROL1B(0)
              ELSE
                br(i, j) = x16
                CALL PUSHCONTROL1B(1)
              END IF
            END DO
          END DO
          CALL PUSHCONTROL2B(1)
        ELSE IF (jord .EQ. 10) THEN
          DO j=js3,je3
            DO i=is,ie+1
              bl(i, j) = al(i, j) - v(i, j)
              br(i, j) = al(i, j+1) - v(i, j)
              IF (dm(i, j) .GE. 0.) THEN
                abs0 = dm(i, j)
              ELSE
                abs0 = -dm(i, j)
              END IF
!           if ( abs(dm(i,j-1))+abs(dm(i,j))+abs(dm(i,j+1)) < near_zero ) then
              IF (abs0 .LT. near_zero) THEN
                IF (dm(i, j-1) .GE. 0.) THEN
                  abs1 = dm(i, j-1)
                ELSE
                  abs1 = -dm(i, j-1)
                END IF
                IF (dm(i, j+1) .GE. 0.) THEN
                  abs3 = dm(i, j+1)
                ELSE
                  abs3 = -dm(i, j+1)
                END IF
                IF (abs1 + abs3 .LT. near_zero) THEN
                  bl(i, j) = 0.
                  br(i, j) = 0.
                  CALL PUSHCONTROL3B(4)
                ELSE
                  CALL PUSHCONTROL3B(3)
                END IF
              ELSE
                IF (3.*(bl(i, j)+br(i, j)) .GE. 0.) THEN
                  abs2 = 3.*(bl(i, j)+br(i, j))
                ELSE
                  abs2 = -(3.*(bl(i, j)+br(i, j)))
                END IF
                IF (bl(i, j) - br(i, j) .GE. 0.) THEN
                  abs4 = bl(i, j) - br(i, j)
                ELSE
                  abs4 = -(bl(i, j)-br(i, j))
                END IF
                IF (abs2 .GT. abs4) THEN
                  pmp_1 = -(2.*dq(i, j))
                  lac_1 = pmp_1 + 1.5*dq(i, j+1)
                  IF (0. .LT. pmp_1) THEN
                    IF (pmp_1 .LT. lac_1) THEN
                      x17 = lac_1
                      CALL PUSHCONTROL2B(0)
                    ELSE
                      x17 = pmp_1
                      CALL PUSHCONTROL2B(1)
                    END IF
                  ELSE IF (0. .LT. lac_1) THEN
                    x17 = lac_1
                    CALL PUSHCONTROL2B(2)
                  ELSE
                    CALL PUSHCONTROL2B(3)
                    x17 = 0.
                  END IF
                  IF (0. .GT. pmp_1) THEN
                    IF (pmp_1 .GT. lac_1) THEN
                      y22 = lac_1
                      CALL PUSHCONTROL2B(0)
                    ELSE
                      y22 = pmp_1
                      CALL PUSHCONTROL2B(1)
                    END IF
                  ELSE IF (0. .GT. lac_1) THEN
                    y22 = lac_1
                    CALL PUSHCONTROL2B(2)
                  ELSE
                    y22 = 0.
                    CALL PUSHCONTROL2B(3)
                  END IF
                  IF (bl(i, j) .LT. y22) THEN
                    y16 = y22
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    y16 = bl(i, j)
                    CALL PUSHCONTROL1B(1)
                  END IF
                  IF (x17 .GT. y16) THEN
                    bl(i, j) = y16
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    bl(i, j) = x17
                    CALL PUSHCONTROL1B(1)
                  END IF
                  pmp_2 = 2.*dq(i, j-1)
                  lac_2 = pmp_2 - 1.5*dq(i, j-2)
                  IF (0. .LT. pmp_2) THEN
                    IF (pmp_2 .LT. lac_2) THEN
                      x18 = lac_2
                      CALL PUSHCONTROL2B(0)
                    ELSE
                      x18 = pmp_2
                      CALL PUSHCONTROL2B(1)
                    END IF
                  ELSE IF (0. .LT. lac_2) THEN
                    x18 = lac_2
                    CALL PUSHCONTROL2B(2)
                  ELSE
                    CALL PUSHCONTROL2B(3)
                    x18 = 0.
                  END IF
                  IF (0. .GT. pmp_2) THEN
                    IF (pmp_2 .GT. lac_2) THEN
                      y23 = lac_2
                      CALL PUSHCONTROL2B(0)
                    ELSE
                      y23 = pmp_2
                      CALL PUSHCONTROL2B(1)
                    END IF
                  ELSE IF (0. .GT. lac_2) THEN
                    y23 = lac_2
                    CALL PUSHCONTROL2B(2)
                  ELSE
                    y23 = 0.
                    CALL PUSHCONTROL2B(3)
                  END IF
                  IF (br(i, j) .LT. y23) THEN
                    y17 = y23
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    y17 = br(i, j)
                    CALL PUSHCONTROL1B(1)
                  END IF
                  IF (x18 .GT. y17) THEN
                    br(i, j) = y17
                    CALL PUSHCONTROL3B(1)
                  ELSE
                    br(i, j) = x18
                    CALL PUSHCONTROL3B(2)
                  END IF
                ELSE
                  CALL PUSHCONTROL3B(0)
                END IF
              END IF
            END DO
          END DO
          CALL PUSHCONTROL2B(2)
        ELSE
! Unlimited:
          DO j=js3,je3
            DO i=is,ie+1
              bl(i, j) = al(i, j) - v(i, j)
              br(i, j) = al(i, j+1) - v(i, j)
            END DO
          END DO
          CALL PUSHCONTROL2B(3)
        END IF
!--------------
! fix the edges
!--------------
        IF (js .EQ. 1 .AND. (.NOT.nested)) THEN
          DO i=is,ie+1
            br(i, 2) = al(i, 3) - v(i, 2)
            xt = s15*v(i, 1) + s11*v(i, 2) - s14*dm(i, 2)
            br(i, 1) = xt - v(i, 1)
            bl(i, 2) = xt - v(i, 2)
            bl(i, 0) = s14*dm(i, -1) - s11*dq(i, -1)
!#ifdef ONE_SIDE
!            xt =  t14*v(i,1) +  t12*v(i,2) + t15*v(i,3)
!            bl(i,1) = 2.*xt - v(i,1)
!            xt =  t14*v(i,0) +  t12*v(i,-1) + t15*v(i,-2)
!            br(i,0) = 2.*xt - v(i,0)
!#else
            x0l = 0.5*((2.*dy(i, 0)+dy(i, -1))*v(i, 0)-dy(i, 0)*v(i, -1)&
&             )/(dy(i, 0)+dy(i, -1))
            x0r = 0.5*((2.*dy(i, 1)+dy(i, 2))*v(i, 1)-dy(i, 1)*v(i, 2))/&
&             (dy(i, 1)+dy(i, 2))
            xt = x0l + x0r
            bl(i, 1) = xt - v(i, 1)
            br(i, 0) = xt - v(i, 0)
          END DO
!#endif
          IF (is .EQ. 1) THEN
! out
            bl(1, 0) = 0.
! edge
            br(1, 0) = 0.
! edge
            bl(1, 1) = 0.
! in
            br(1, 1) = 0.
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (ie + 1 .EQ. npx) THEN
! out
            bl(npx, 0) = 0.
! edge
            br(npx, 0) = 0.
! edge
            bl(npx, 1) = 0.
! in
            br(npx, 1) = 0.
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          j = 2
          arg1 = ie - is + 2
          CALL PUSHREALARRAY_ADM(br(is, j), 8*(bd%ie-is+2)/8)
          CALL PUSHREALARRAY_ADM(bl(is, j), 8*(bd%ie-is+2)/8)
          CALL PERT_PPM(arg1, v(is, j), bl(is, j), br(is, j), -1)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (je + 1 .EQ. npy .AND. (.NOT.nested)) THEN
          DO i=is,ie+1
            bl(i, npy-2) = al(i, npy-2) - v(i, npy-2)
            xt = s15*v(i, npy-1) + s11*v(i, npy-2) + s14*dm(i, npy-2)
            br(i, npy-2) = xt - v(i, npy-2)
            bl(i, npy-1) = xt - v(i, npy-1)
            br(i, npy) = s11*dq(i, npy) - s14*dm(i, npy+1)
!#ifdef ONE_SIDE
!            xt = t14*v(i,npy-1) + t12*v(i,npy-2) + t15*v(i,npy-3)
!            br(i,npy-1) = 2.*xt - v(i,npy-1)
!            xt = t14*v(i,npy) + t12*v(i,npy+1) + t15*v(i,npy+2)
!            bl(i,npy  ) = 2.*xt - v(i,npy)
!#else
            x0l = 0.5*((2.*dy(i, npy-1)+dy(i, npy-2))*v(i, npy-1)-dy(i, &
&             npy-1)*v(i, npy-2))/(dy(i, npy-1)+dy(i, npy-2))
            x0r = 0.5*((2.*dy(i, npy)+dy(i, npy+1))*v(i, npy)-dy(i, npy)&
&             *v(i, npy+1))/(dy(i, npy)+dy(i, npy+1))
            xt = x0l + x0r
            br(i, npy-1) = xt - v(i, npy-1)
            bl(i, npy) = xt - v(i, npy)
          END DO
!#endif
          IF (is .EQ. 1) THEN
! in
            bl(1, npy-1) = 0.
! edge
            br(1, npy-1) = 0.
! edge
            bl(1, npy) = 0.
! out
            br(1, npy) = 0.
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (ie + 1 .EQ. npx) THEN
! in
            bl(npx, npy-1) = 0.
! edge
            br(npx, npy-1) = 0.
! edge
            bl(npx, npy) = 0.
! out
            br(npx, npy) = 0.
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          j = npy - 2
          arg1 = ie - is + 2
          CALL PUSHREALARRAY_ADM(br(is, j), 8*(bd%ie-is+2)/8)
          CALL PUSHREALARRAY_ADM(bl(is, j), 8*(bd%ie-is+2)/8)
          CALL PERT_PPM(arg1, v(is, j), bl(is, j), br(is, j), -1)
          CALL PUSHCONTROL2B(2)
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        DO j=js-1,je+2
          DO i=is,ie+1
            al(i, j) = 0.5*(v(i, j-1)+v(i, j)) + r3*(dm(i, j-1)-dm(i, j)&
&             )
          END DO
        END DO
        DO j=js-1,je+1
          DO i=is,ie+1
            pmp = 2.*dq(i, j-1)
            lac = pmp - 1.5*dq(i, j-2)
            IF (0. .LT. pmp) THEN
              IF (pmp .LT. lac) THEN
                x19 = lac
                CALL PUSHCONTROL2B(0)
              ELSE
                x19 = pmp
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE IF (0. .LT. lac) THEN
              x19 = lac
              CALL PUSHCONTROL2B(2)
            ELSE
              CALL PUSHCONTROL2B(3)
              x19 = 0.
            END IF
            IF (0. .GT. pmp) THEN
              IF (pmp .GT. lac) THEN
                y24 = lac
                CALL PUSHCONTROL2B(0)
              ELSE
                y24 = pmp
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE IF (0. .GT. lac) THEN
              y24 = lac
              CALL PUSHCONTROL2B(2)
            ELSE
              y24 = 0.
              CALL PUSHCONTROL2B(3)
            END IF
            IF (al(i, j+1) - v(i, j) .LT. y24) THEN
              y18 = y24
              CALL PUSHCONTROL1B(0)
            ELSE
              y18 = al(i, j+1) - v(i, j)
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x19 .GT. y18) THEN
              br(i, j) = y18
              CALL PUSHCONTROL1B(0)
            ELSE
              br(i, j) = x19
              CALL PUSHCONTROL1B(1)
            END IF
            pmp = -(2.*dq(i, j))
            lac = pmp + 1.5*dq(i, j+1)
            IF (0. .LT. pmp) THEN
              IF (pmp .LT. lac) THEN
                x20 = lac
                CALL PUSHCONTROL2B(0)
              ELSE
                x20 = pmp
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE IF (0. .LT. lac) THEN
              x20 = lac
              CALL PUSHCONTROL2B(2)
            ELSE
              CALL PUSHCONTROL2B(3)
              x20 = 0.
            END IF
            IF (0. .GT. pmp) THEN
              IF (pmp .GT. lac) THEN
                y25 = lac
                CALL PUSHCONTROL2B(0)
              ELSE
                y25 = pmp
                CALL PUSHCONTROL2B(1)
              END IF
            ELSE IF (0. .GT. lac) THEN
              y25 = lac
              CALL PUSHCONTROL2B(2)
            ELSE
              y25 = 0.
              CALL PUSHCONTROL2B(3)
            END IF
            IF (al(i, j) - v(i, j) .LT. y25) THEN
              y19 = y25
              CALL PUSHCONTROL1B(0)
            ELSE
              y19 = al(i, j) - v(i, j)
              CALL PUSHCONTROL1B(1)
            END IF
            IF (x20 .GT. y19) THEN
              bl(i, j) = y19
              CALL PUSHCONTROL1B(0)
            ELSE
              bl(i, j) = x20
              CALL PUSHCONTROL1B(1)
            END IF
          END DO
        END DO
        CALL PUSHCONTROL2B(0)
      END IF
      CALL PUSHINTEGER4(j)
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      bl_ad = 0.0_FVPRC
      br_ad = 0.0_FVPRC
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            cfl = c(i, j)*rdy(i, j)
            temp2 = bl(i, j) + br(i, j)
            temp_ad30 = (cfl+1.)*flux_ad(i, j)
            v_ad(i, j) = v_ad(i, j) + flux_ad(i, j)
            cfl_ad = temp2*temp_ad30 + (bl(i, j)+cfl*temp2)*flux_ad(i, j&
&             )
            bl_ad(i, j) = bl_ad(i, j) + (cfl+1.0)*temp_ad30
            br_ad(i, j) = br_ad(i, j) + cfl*temp_ad30
            flux_ad(i, j) = 0.0_FVPRC
            c_ad(i, j) = c_ad(i, j) + rdy(i, j)*cfl_ad
          ELSE
            cfl = c(i, j)*rdy(i, j-1)
            temp1 = bl(i, j-1) + br(i, j-1)
            temp_ad29 = (1.-cfl)*flux_ad(i, j)
            v_ad(i, j-1) = v_ad(i, j-1) + flux_ad(i, j)
            cfl_ad = -(temp1*temp_ad29) - (br(i, j-1)-cfl*temp1)*flux_ad&
&             (i, j)
            br_ad(i, j-1) = br_ad(i, j-1) + (1.0-cfl)*temp_ad29
            bl_ad(i, j-1) = bl_ad(i, j-1) - cfl*temp_ad29
            flux_ad(i, j) = 0.0_FVPRC
            c_ad(i, j) = c_ad(i, j) + rdy(i, j-1)*cfl_ad
          END IF
        END DO
      END DO
      CALL POPINTEGER4(j)
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        dq_ad = 0.0_FVPRC
        al_ad = 0.0_FVPRC
        DO j=je+1,js-1,-1
          DO i=ie+1,is,-1
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              y19_ad = bl_ad(i, j)
              bl_ad(i, j) = 0.0_FVPRC
              x20_ad = 0.0_FVPRC
            ELSE
              x20_ad = bl_ad(i, j)
              bl_ad(i, j) = 0.0_FVPRC
              y19_ad = 0.0_FVPRC
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              y25_ad = y19_ad
            ELSE
              al_ad(i, j) = al_ad(i, j) + y19_ad
              v_ad(i, j) = v_ad(i, j) - y19_ad
              y25_ad = 0.0_FVPRC
            END IF
            CALL POPCONTROL2B(branch)
            IF (branch .LT. 2) THEN
              IF (branch .EQ. 0) THEN
                lac_ad = y25_ad
                pmp_ad = 0.0_FVPRC
              ELSE
                pmp_ad = y25_ad
                lac_ad = 0.0_FVPRC
              END IF
            ELSE
              IF (branch .EQ. 2) THEN
                lac_ad = y25_ad
              ELSE
                lac_ad = 0.0_FVPRC
              END IF
              pmp_ad = 0.0_FVPRC
            END IF
            CALL POPCONTROL2B(branch)
            IF (branch .LT. 2) THEN
              IF (branch .EQ. 0) THEN
                lac_ad = lac_ad + x20_ad
              ELSE
                pmp_ad = pmp_ad + x20_ad
              END IF
            ELSE IF (branch .EQ. 2) THEN
              lac_ad = lac_ad + x20_ad
            END IF
            pmp_ad = pmp_ad + lac_ad
            dq_ad(i, j+1) = dq_ad(i, j+1) + 1.5*lac_ad
            dq_ad(i, j) = dq_ad(i, j) - 2.*pmp_ad
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              y18_ad = br_ad(i, j)
              br_ad(i, j) = 0.0_FVPRC
              x19_ad = 0.0_FVPRC
            ELSE
              x19_ad = br_ad(i, j)
              br_ad(i, j) = 0.0_FVPRC
              y18_ad = 0.0_FVPRC
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              y24_ad = y18_ad
            ELSE
              al_ad(i, j+1) = al_ad(i, j+1) + y18_ad
              v_ad(i, j) = v_ad(i, j) - y18_ad
              y24_ad = 0.0_FVPRC
            END IF
            CALL POPCONTROL2B(branch)
            IF (branch .LT. 2) THEN
              IF (branch .EQ. 0) THEN
                lac_ad = y24_ad
                pmp_ad = 0.0_FVPRC
              ELSE
                pmp_ad = y24_ad
                lac_ad = 0.0_FVPRC
              END IF
            ELSE
              IF (branch .EQ. 2) THEN
                lac_ad = y24_ad
              ELSE
                lac_ad = 0.0_FVPRC
              END IF
              pmp_ad = 0.0_FVPRC
            END IF
            CALL POPCONTROL2B(branch)
            IF (branch .LT. 2) THEN
              IF (branch .EQ. 0) THEN
                lac_ad = lac_ad + x19_ad
              ELSE
                pmp_ad = pmp_ad + x19_ad
              END IF
            ELSE IF (branch .EQ. 2) THEN
              lac_ad = lac_ad + x19_ad
            END IF
            pmp_ad = pmp_ad + lac_ad
            dq_ad(i, j-2) = dq_ad(i, j-2) - 1.5*lac_ad
            dq_ad(i, j-1) = dq_ad(i, j-1) + 2.*pmp_ad
          END DO
        END DO
        dm_ad = 0.0_FVPRC
        DO j=je+2,js-1,-1
          DO i=ie+1,is,-1
            v_ad(i, j-1) = v_ad(i, j-1) + 0.5*al_ad(i, j)
            v_ad(i, j) = v_ad(i, j) + 0.5*al_ad(i, j)
            dm_ad(i, j-1) = dm_ad(i, j-1) + r3*al_ad(i, j)
            dm_ad(i, j) = dm_ad(i, j) - r3*al_ad(i, j)
            al_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
      ELSE
        IF (branch .EQ. 1) THEN
          dm_ad = 0.0_FVPRC
          dq_ad = 0.0_FVPRC
          al_ad = 0.0_FVPRC
        ELSE
          j = npy - 2
          CALL POPREALARRAY_ADM(bl(is, j), 8*(bd%ie-is+2)/8)
          CALL POPREALARRAY_ADM(br(is, j), 8*(bd%ie-is+2)/8)
          CALL PERT_PPM_ADM(arg1, v(is, j), bl(is:, j), bl_ad(is:, j), &
&                     br(is:, j), br_ad(is:, j), -1)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            br_ad(npx, npy) = 0.0_FVPRC
            bl_ad(npx, npy) = 0.0_FVPRC
            br_ad(npx, npy-1) = 0.0_FVPRC
            bl_ad(npx, npy-1) = 0.0_FVPRC
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            br_ad(1, npy) = 0.0_FVPRC
            bl_ad(1, npy) = 0.0_FVPRC
            br_ad(1, npy-1) = 0.0_FVPRC
            bl_ad(1, npy-1) = 0.0_FVPRC
          END IF
          dm_ad = 0.0_FVPRC
          dq_ad = 0.0_FVPRC
          al_ad = 0.0_FVPRC
          DO i=ie+1,is,-1
            xt_ad = br_ad(i, npy-1) + bl_ad(i, npy)
            v_ad(i, npy) = v_ad(i, npy) - bl_ad(i, npy)
            bl_ad(i, npy) = 0.0_FVPRC
            v_ad(i, npy-1) = v_ad(i, npy-1) - br_ad(i, npy-1)
            br_ad(i, npy-1) = 0.0_FVPRC
            x0l_ad = xt_ad
            x0r_ad = xt_ad
            temp_ad27 = 0.5*x0r_ad/(dy(i, npy)+dy(i, npy+1))
            v_ad(i, npy) = v_ad(i, npy) + (dy(i, npy)*2.+dy(i, npy+1))*&
&             temp_ad27
            v_ad(i, npy+1) = v_ad(i, npy+1) - dy(i, npy)*temp_ad27
            temp_ad28 = 0.5*x0l_ad/(dy(i, npy-1)+dy(i, npy-2))
            v_ad(i, npy-1) = v_ad(i, npy-1) + (dy(i, npy-1)*2.+dy(i, npy&
&             -2))*temp_ad28
            v_ad(i, npy-2) = v_ad(i, npy-2) - dy(i, npy-1)*temp_ad28
            dq_ad(i, npy) = dq_ad(i, npy) + s11*br_ad(i, npy)
            dm_ad(i, npy+1) = dm_ad(i, npy+1) - s14*br_ad(i, npy)
            br_ad(i, npy) = 0.0_FVPRC
            xt_ad = br_ad(i, npy-2) + bl_ad(i, npy-1)
            v_ad(i, npy-1) = v_ad(i, npy-1) - bl_ad(i, npy-1)
            bl_ad(i, npy-1) = 0.0_FVPRC
            v_ad(i, npy-2) = v_ad(i, npy-2) - br_ad(i, npy-2)
            br_ad(i, npy-2) = 0.0_FVPRC
            v_ad(i, npy-1) = v_ad(i, npy-1) + s15*xt_ad
            v_ad(i, npy-2) = v_ad(i, npy-2) + s11*xt_ad - bl_ad(i, npy-2&
&             )
            dm_ad(i, npy-2) = dm_ad(i, npy-2) + s14*xt_ad
            al_ad(i, npy-2) = al_ad(i, npy-2) + bl_ad(i, npy-2)
            bl_ad(i, npy-2) = 0.0_FVPRC
          END DO
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          j = 2
          arg1 = ie - is + 2
          CALL POPREALARRAY_ADM(bl(is, j), 8*(bd%ie-is+2)/8)
          CALL POPREALARRAY_ADM(br(is, j), 8*(bd%ie-is+2)/8)
          CALL PERT_PPM_ADM(arg1, v(is, j), bl(is:, j), bl_ad(is:, j), &
&                     br(is:, j), br_ad(is:, j), -1)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            br_ad(npx, 1) = 0.0_FVPRC
            bl_ad(npx, 1) = 0.0_FVPRC
            br_ad(npx, 0) = 0.0_FVPRC
            bl_ad(npx, 0) = 0.0_FVPRC
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            br_ad(1, 1) = 0.0_FVPRC
            bl_ad(1, 1) = 0.0_FVPRC
            br_ad(1, 0) = 0.0_FVPRC
            bl_ad(1, 0) = 0.0_FVPRC
          END IF
          DO i=ie+1,is,-1
            xt_ad = bl_ad(i, 1) + br_ad(i, 0)
            v_ad(i, 0) = v_ad(i, 0) - br_ad(i, 0)
            br_ad(i, 0) = 0.0_FVPRC
            x0l_ad = xt_ad
            x0r_ad = xt_ad
            temp_ad25 = 0.5*x0r_ad/(dy(i, 1)+dy(i, 2))
            v_ad(i, 1) = v_ad(i, 1) + (dy(i, 1)*2.+dy(i, 2))*temp_ad25 -&
&             bl_ad(i, 1)
            bl_ad(i, 1) = 0.0_FVPRC
            v_ad(i, 2) = v_ad(i, 2) - dy(i, 1)*temp_ad25
            temp_ad26 = 0.5*x0l_ad/(dy(i, 0)+dy(i, -1))
            v_ad(i, 0) = v_ad(i, 0) + (dy(i, 0)*2.+dy(i, -1))*temp_ad26
            v_ad(i, -1) = v_ad(i, -1) - dy(i, 0)*temp_ad26
            dm_ad(i, -1) = dm_ad(i, -1) + s14*bl_ad(i, 0)
            dq_ad(i, -1) = dq_ad(i, -1) - s11*bl_ad(i, 0)
            bl_ad(i, 0) = 0.0_FVPRC
            xt_ad = br_ad(i, 1) + bl_ad(i, 2)
            v_ad(i, 2) = v_ad(i, 2) - bl_ad(i, 2)
            bl_ad(i, 2) = 0.0_FVPRC
            v_ad(i, 1) = v_ad(i, 1) + s15*xt_ad - br_ad(i, 1)
            br_ad(i, 1) = 0.0_FVPRC
            v_ad(i, 2) = v_ad(i, 2) + s11*xt_ad - br_ad(i, 2)
            dm_ad(i, 2) = dm_ad(i, 2) - s14*xt_ad
            al_ad(i, 3) = al_ad(i, 3) + br_ad(i, 2)
            br_ad(i, 2) = 0.0_FVPRC
          END DO
        END IF
        CALL POPCONTROL2B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) THEN
            DO j=je3,js3,-1
              DO i=ie+1,is,-1
                xt = 2.*dm(i, j)
                min13_ad = SIGN(1.d0, min13*xt)*br_ad(i, j)
                br_ad(i, j) = 0.0_FVPRC
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  CALL POPREALARRAY_ADM(min13)
                  y13_ad = min13_ad
                  x14_ad = 0.0_FVPRC
                ELSE
                  CALL POPREALARRAY_ADM(min13)
                  x14_ad = min13_ad
                  y13_ad = 0.0_FVPRC
                END IF
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  al_ad(i, j+1) = al_ad(i, j+1) + y13_ad
                  v_ad(i, j) = v_ad(i, j) - y13_ad
                ELSE
                  v_ad(i, j) = v_ad(i, j) + y13_ad
                  al_ad(i, j+1) = al_ad(i, j+1) - y13_ad
                END IF
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  xt_ad = x14_ad
                ELSE
                  xt_ad = -x14_ad
                END IF
                min12_ad = -(SIGN(1.d0, min12*xt)*bl_ad(i, j))
                bl_ad(i, j) = 0.0_FVPRC
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  CALL POPREALARRAY_ADM(min12)
                  y12_ad = min12_ad
                  x13_ad = 0.0_FVPRC
                ELSE
                  CALL POPREALARRAY_ADM(min12)
                  x13_ad = min12_ad
                  y12_ad = 0.0_FVPRC
                END IF
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  al_ad(i, j) = al_ad(i, j) + y12_ad
                  v_ad(i, j) = v_ad(i, j) - y12_ad
                ELSE
                  v_ad(i, j) = v_ad(i, j) + y12_ad
                  al_ad(i, j) = al_ad(i, j) - y12_ad
                END IF
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  xt_ad = xt_ad + x13_ad
                ELSE
                  xt_ad = xt_ad - x13_ad
                END IF
                dm_ad(i, j) = dm_ad(i, j) + 2.*xt_ad
              END DO
            END DO
          ELSE
            DO j=je3,js3,-1
              DO i=ie+1,is,-1
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  y15_ad = br_ad(i, j)
                  br_ad(i, j) = 0.0_FVPRC
                  x16_ad = 0.0_FVPRC
                ELSE
                  x16_ad = br_ad(i, j)
                  br_ad(i, j) = 0.0_FVPRC
                  y15_ad = 0.0_FVPRC
                END IF
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  y21_ad = y15_ad
                ELSE
                  al_ad(i, j+1) = al_ad(i, j+1) + y15_ad
                  v_ad(i, j) = v_ad(i, j) - y15_ad
                  y21_ad = 0.0_FVPRC
                END IF
                CALL POPCONTROL2B(branch)
                IF (branch .LT. 2) THEN
                  IF (branch .EQ. 0) THEN
                    lac_2_ad = y21_ad
                    pmp_2_ad = 0.0_FVPRC
                  ELSE
                    pmp_2_ad = y21_ad
                    lac_2_ad = 0.0_FVPRC
                  END IF
                ELSE
                  IF (branch .EQ. 2) THEN
                    lac_2_ad = y21_ad
                  ELSE
                    lac_2_ad = 0.0_FVPRC
                  END IF
                  pmp_2_ad = 0.0_FVPRC
                END IF
                CALL POPCONTROL2B(branch)
                IF (branch .LT. 2) THEN
                  IF (branch .EQ. 0) THEN
                    lac_2_ad = lac_2_ad + x16_ad
                  ELSE
                    pmp_2_ad = pmp_2_ad + x16_ad
                  END IF
                ELSE IF (branch .EQ. 2) THEN
                  lac_2_ad = lac_2_ad + x16_ad
                END IF
                pmp_2_ad = pmp_2_ad + lac_2_ad
                dq_ad(i, j-2) = dq_ad(i, j-2) - 1.5*lac_2_ad
                dq_ad(i, j-1) = dq_ad(i, j-1) + 2.*pmp_2_ad
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  y14_ad = bl_ad(i, j)
                  bl_ad(i, j) = 0.0_FVPRC
                  x15_ad = 0.0_FVPRC
                ELSE
                  x15_ad = bl_ad(i, j)
                  bl_ad(i, j) = 0.0_FVPRC
                  y14_ad = 0.0_FVPRC
                END IF
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  y20_ad = y14_ad
                ELSE
                  al_ad(i, j) = al_ad(i, j) + y14_ad
                  v_ad(i, j) = v_ad(i, j) - y14_ad
                  y20_ad = 0.0_FVPRC
                END IF
                CALL POPCONTROL2B(branch)
                IF (branch .LT. 2) THEN
                  IF (branch .EQ. 0) THEN
                    lac_1_ad = y20_ad
                    pmp_1_ad = 0.0_FVPRC
                  ELSE
                    pmp_1_ad = y20_ad
                    lac_1_ad = 0.0_FVPRC
                  END IF
                ELSE
                  IF (branch .EQ. 2) THEN
                    lac_1_ad = y20_ad
                  ELSE
                    lac_1_ad = 0.0_FVPRC
                  END IF
                  pmp_1_ad = 0.0_FVPRC
                END IF
                CALL POPCONTROL2B(branch)
                IF (branch .LT. 2) THEN
                  IF (branch .EQ. 0) THEN
                    lac_1_ad = lac_1_ad + x15_ad
                  ELSE
                    pmp_1_ad = pmp_1_ad + x15_ad
                  END IF
                ELSE IF (branch .EQ. 2) THEN
                  lac_1_ad = lac_1_ad + x15_ad
                END IF
                pmp_1_ad = pmp_1_ad + lac_1_ad
                dq_ad(i, j+1) = dq_ad(i, j+1) + 1.5*lac_1_ad
                dq_ad(i, j) = dq_ad(i, j) - 2.*pmp_1_ad
              END DO
            END DO
          END IF
        ELSE IF (branch .EQ. 2) THEN
          DO j=je3,js3,-1
            DO i=ie+1,is,-1
              CALL POPCONTROL3B(branch)
              IF (branch .LT. 2) THEN
                IF (branch .EQ. 0) THEN
                  GOTO 130
                ELSE
                  y17_ad = br_ad(i, j)
                  br_ad(i, j) = 0.0_FVPRC
                  x18_ad = 0.0_FVPRC
                END IF
              ELSE IF (branch .EQ. 2) THEN
                x18_ad = br_ad(i, j)
                br_ad(i, j) = 0.0_FVPRC
                y17_ad = 0.0_FVPRC
              ELSE
                IF (branch .NE. 3) THEN
                  br_ad(i, j) = 0.0_FVPRC
                  bl_ad(i, j) = 0.0_FVPRC
                END IF
                GOTO 130
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                y23_ad = y17_ad
              ELSE
                br_ad(i, j) = br_ad(i, j) + y17_ad
                y23_ad = 0.0_FVPRC
              END IF
              CALL POPCONTROL2B(branch)
              IF (branch .LT. 2) THEN
                IF (branch .EQ. 0) THEN
                  lac_2_ad = y23_ad
                  pmp_2_ad = 0.0_FVPRC
                ELSE
                  pmp_2_ad = y23_ad
                  lac_2_ad = 0.0_FVPRC
                END IF
              ELSE
                IF (branch .EQ. 2) THEN
                  lac_2_ad = y23_ad
                ELSE
                  lac_2_ad = 0.0_FVPRC
                END IF
                pmp_2_ad = 0.0_FVPRC
              END IF
              CALL POPCONTROL2B(branch)
              IF (branch .LT. 2) THEN
                IF (branch .EQ. 0) THEN
                  lac_2_ad = lac_2_ad + x18_ad
                ELSE
                  pmp_2_ad = pmp_2_ad + x18_ad
                END IF
              ELSE IF (branch .EQ. 2) THEN
                lac_2_ad = lac_2_ad + x18_ad
              END IF
              pmp_2_ad = pmp_2_ad + lac_2_ad
              dq_ad(i, j-2) = dq_ad(i, j-2) - 1.5*lac_2_ad
              dq_ad(i, j-1) = dq_ad(i, j-1) + 2.*pmp_2_ad
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                y16_ad = bl_ad(i, j)
                bl_ad(i, j) = 0.0_FVPRC
                x17_ad = 0.0_FVPRC
              ELSE
                x17_ad = bl_ad(i, j)
                bl_ad(i, j) = 0.0_FVPRC
                y16_ad = 0.0_FVPRC
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                y22_ad = y16_ad
              ELSE
                bl_ad(i, j) = bl_ad(i, j) + y16_ad
                y22_ad = 0.0_FVPRC
              END IF
              CALL POPCONTROL2B(branch)
              IF (branch .LT. 2) THEN
                IF (branch .EQ. 0) THEN
                  lac_1_ad = y22_ad
                  pmp_1_ad = 0.0_FVPRC
                ELSE
                  pmp_1_ad = y22_ad
                  lac_1_ad = 0.0_FVPRC
                END IF
              ELSE
                IF (branch .EQ. 2) THEN
                  lac_1_ad = y22_ad
                ELSE
                  lac_1_ad = 0.0_FVPRC
                END IF
                pmp_1_ad = 0.0_FVPRC
              END IF
              CALL POPCONTROL2B(branch)
              IF (branch .LT. 2) THEN
                IF (branch .EQ. 0) THEN
                  lac_1_ad = lac_1_ad + x17_ad
                ELSE
                  pmp_1_ad = pmp_1_ad + x17_ad
                END IF
              ELSE IF (branch .EQ. 2) THEN
                lac_1_ad = lac_1_ad + x17_ad
              END IF
              pmp_1_ad = pmp_1_ad + lac_1_ad
              dq_ad(i, j+1) = dq_ad(i, j+1) + 1.5*lac_1_ad
              dq_ad(i, j) = dq_ad(i, j) - 2.*pmp_1_ad
 130          al_ad(i, j+1) = al_ad(i, j+1) + br_ad(i, j)
              v_ad(i, j) = v_ad(i, j) - bl_ad(i, j) - br_ad(i, j)
              br_ad(i, j) = 0.0_FVPRC
              al_ad(i, j) = al_ad(i, j) + bl_ad(i, j)
              bl_ad(i, j) = 0.0_FVPRC
            END DO
          END DO
        ELSE
          DO j=je3,js3,-1
            DO i=ie+1,is,-1
              al_ad(i, j+1) = al_ad(i, j+1) + br_ad(i, j)
              v_ad(i, j) = v_ad(i, j) - bl_ad(i, j) - br_ad(i, j)
              br_ad(i, j) = 0.0_FVPRC
              al_ad(i, j) = al_ad(i, j) + bl_ad(i, j)
              bl_ad(i, j) = 0.0_FVPRC
            END DO
          END DO
        END IF
        DO j=je3+1,js3,-1
          DO i=ie+1,is,-1
            v_ad(i, j-1) = v_ad(i, j-1) + 0.5*al_ad(i, j)
            v_ad(i, j) = v_ad(i, j) + 0.5*al_ad(i, j)
            dm_ad(i, j-1) = dm_ad(i, j-1) + r3*al_ad(i, j)
            dm_ad(i, j) = dm_ad(i, j) - r3*al_ad(i, j)
            al_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
      END IF
      DO j=je+2,js-3,-1
        DO i=ie+1,is,-1
          v_ad(i, j+1) = v_ad(i, j+1) + dq_ad(i, j)
          v_ad(i, j) = v_ad(i, j) - dq_ad(i, j)
          dq_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      DO j=je+2,js-2,-1
        DO i=ie+1,is,-1
          xt = 0.25*(v(i, j+1)-v(i, j-1))
          min11_ad = SIGN(1.d0, min11*xt)*dm_ad(i, j)
          dm_ad(i, j) = 0.0_FVPRC
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY_ADM(min11)
              z7_ad = min11_ad
              y11_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min11)
              y11_ad = min11_ad
              z7_ad = 0.0_FVPRC
            END IF
            x12_ad = 0.0_FVPRC
          ELSE
            IF (branch .EQ. 2) THEN
              CALL POPREALARRAY_ADM(min11)
              z7_ad = min11_ad
              x12_ad = 0.0_FVPRC
            ELSE
              CALL POPREALARRAY_ADM(min11)
              x12_ad = min11_ad
              z7_ad = 0.0_FVPRC
            END IF
            y11_ad = 0.0_FVPRC
          END IF
          v_ad(i, j) = v_ad(i, j) + z7_ad
          min20_ad = -z7_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              v_ad(i, j+1) = v_ad(i, j+1) + min20_ad
            ELSE
              v_ad(i, j) = v_ad(i, j) + min20_ad
            END IF
          ELSE IF (branch .EQ. 2) THEN
            v_ad(i, j+1) = v_ad(i, j+1) + min20_ad
          ELSE
            v_ad(i, j-1) = v_ad(i, j-1) + min20_ad
          END IF
          max7_ad = y11_ad
          v_ad(i, j) = v_ad(i, j) - y11_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              v_ad(i, j+1) = v_ad(i, j+1) + max7_ad
            ELSE
              v_ad(i, j) = v_ad(i, j) + max7_ad
            END IF
          ELSE IF (branch .EQ. 2) THEN
            v_ad(i, j+1) = v_ad(i, j+1) + max7_ad
          ELSE
            v_ad(i, j-1) = v_ad(i, j-1) + max7_ad
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            xt_ad = x12_ad
          ELSE
            xt_ad = -x12_ad
          END IF
          v_ad(i, j+1) = v_ad(i, j+1) + 0.25*xt_ad
          v_ad(i, j-1) = v_ad(i, j-1) - 0.25*xt_ad
        END DO
      END DO
    END SELECT
    CALL POPCONTROL1B(branch)
  END SUBROUTINE YTP_V_ADM
  SUBROUTINE YTP_V(c, u, v, flux, jord, cosa, dy, rdy, bd, npx, npy, &
&   grid_type, nested)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: jord
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed)
!  Courant   N (like FLUX)
    REAL(fvprc), INTENT(IN) :: c(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(OUT) :: flux(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(IN) :: dy(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(IN) :: rdy(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(IN) :: cosa(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
    INTEGER, INTENT(IN) :: npx, npy, grid_type
    LOGICAL, INTENT(IN) :: nested
! Local:
    LOGICAL :: extm(bd%is:bd%ie+1, bd%js-2:bd%je+2)
    REAL(fvprc) :: dm(bd%is:bd%ie+1, bd%js-2:bd%je+2)
    REAL(fvprc) :: al(bd%is:bd%ie+1, bd%js-1:bd%je+2)
    REAL(fvprc) :: bl(bd%is:bd%ie+1, bd%js-1:bd%je+1)
    REAL(fvprc) :: br(bd%is:bd%ie+1, bd%js-1:bd%je+1)
    REAL(fvprc) :: dq(bd%is:bd%ie+1, bd%js-3:bd%je+2)
    REAL(fvprc) :: xt, dl, dr, pmp, lac, cfl
    REAL(fvprc) :: pmp_1, lac_1, pmp_2, lac_2
    REAL(fvprc) :: x0, x1, x0r, x0l
    INTEGER :: i, j, js3, je3
    INTEGER :: is, ie, js, je
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTRINSIC SIGN
    REAL(fvprc) :: min1
    REAL(fvprc) :: min2
    REAL(fvprc) :: min3
    REAL(fvprc) :: min4
    REAL(fvprc) :: min5
    REAL(fvprc) :: min6
    REAL(fvprc) :: min7
    REAL(fvprc) :: min8
    REAL(fvprc) :: min9
    REAL(fvprc) :: min10
    REAL(fvprc) :: min11
    REAL(fvprc) :: min12
    REAL(fvprc) :: min13
    REAL(fvprc) :: abs0
    REAL(fvprc) :: abs1
    REAL(fvprc) :: abs2
    REAL(fvprc) :: max1
    REAL(fvprc) :: min14
    REAL(fvprc) :: max2
    REAL(fvprc) :: min15
    REAL(fvprc) :: max3
    REAL(fvprc) :: min16
    REAL(fvprc) :: max4
    REAL(fvprc) :: min17
    REAL(fvprc) :: max5
    REAL(fvprc) :: min18
    REAL(fvprc) :: max6
    REAL(fvprc) :: min19
    REAL(fvprc) :: max7
    REAL(fvprc) :: min20
    REAL(fvprc) :: abs3
    REAL(fvprc) :: abs4
    INTEGER :: arg1
    REAL(fvprc) :: x19
    REAL(fvprc) :: x18
    REAL(fvprc) :: x17
    REAL(fvprc) :: x16
    REAL(fvprc) :: x15
    REAL(fvprc) :: x14
    REAL(fvprc) :: x13
    REAL(fvprc) :: x12
    REAL(fvprc) :: x11
    REAL(fvprc) :: x10
    REAL(fvprc) :: y25
    REAL(fvprc) :: y24
    REAL(fvprc) :: y23
    REAL(fvprc) :: y22
    REAL(fvprc) :: y21
    REAL(fvprc) :: y20
    REAL(fvprc) :: x9
    REAL(fvprc) :: x8
    REAL(fvprc) :: x7
    REAL(fvprc) :: x6
    REAL(fvprc) :: x5
    REAL(fvprc) :: x4
    REAL(fvprc) :: x3
    REAL(fvprc) :: x2
    REAL(fvprc) :: y19
    REAL(fvprc) :: y18
    REAL(fvprc) :: y17
    REAL(fvprc) :: y16
    REAL(fvprc) :: y15
    REAL(fvprc) :: y14
    REAL(fvprc) :: y13
    REAL(fvprc) :: y12
    REAL(fvprc) :: y11
    REAL(fvprc) :: y10
    REAL(fvprc) :: z7
    REAL(fvprc) :: z6
    REAL(fvprc) :: z5
    REAL(fvprc) :: z4
    REAL(fvprc) :: z3
    REAL(fvprc) :: z2
    REAL(fvprc) :: z1
    REAL(fvprc) :: x20
    REAL(fvprc) :: y9
    REAL(fvprc) :: y8
    REAL(fvprc) :: y7
    REAL(fvprc) :: y6
    REAL(fvprc) :: y5
    REAL(fvprc) :: y4
    REAL(fvprc) :: y3
    REAL(fvprc) :: y2
    REAL(fvprc) :: y1
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    IF (nested .OR. grid_type .GT. 3) THEN
      js3 = js - 1
      je3 = je + 1
    ELSE
      IF (3 .LT. js - 1) THEN
        js3 = js - 1
      ELSE
        js3 = 3
      END IF
      IF (npy - 3 .GT. je + 1) THEN
        je3 = je + 1
      ELSE
        je3 = npy - 3
      END IF
    END IF
    SELECT CASE  (jord) 
    CASE (1) 
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            flux(i, j) = v(i, j-1)
          ELSE
            flux(i, j) = v(i, j)
          END IF
        END DO
      END DO
    CASE (333) 
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            flux(i, j) = (2.0*v(i, j)+5.0*v(i, j-1)-v(i, j-2))/6.0 - 0.5&
&             *c(i, j)*rdy(i, j-1)*(v(i, j)-v(i, j-1)) + c(i, j)*rdy(i, &
&             j-1)*c(i, j)*rdy(i, j-1)/6.0*(v(i, j)-2.0*v(i, j-1)+v(i, j&
&             -2))
          ELSE
            flux(i, j) = (2.0*v(i, j-1)+5.0*v(i, j)-v(i, j+1))/6.0 - 0.5&
&             *c(i, j)*rdy(i, j)*(v(i, j)-v(i, j-1)) + c(i, j)*rdy(i, j)&
&             *c(i, j)*rdy(i, j)/6.0*(v(i, j+1)-2.0*v(i, j)+v(i, j-1))
          END IF
        END DO
      END DO
    CASE (2) 
      DO j=js-2,je+2
        DO i=is,ie+1
          xt = 0.25*(v(i, j+1)-v(i, j-1))
          IF (xt .GE. 0.) THEN
            x2 = xt
          ELSE
            x2 = -xt
          END IF
          IF (v(i, j-1) .LT. v(i, j)) THEN
            IF (v(i, j) .LT. v(i, j+1)) THEN
              max1 = v(i, j+1)
            ELSE
              max1 = v(i, j)
            END IF
          ELSE IF (v(i, j-1) .LT. v(i, j+1)) THEN
            max1 = v(i, j+1)
          ELSE
            max1 = v(i, j-1)
          END IF
          y1 = max1 - v(i, j)
          IF (v(i, j-1) .GT. v(i, j)) THEN
            IF (v(i, j) .GT. v(i, j+1)) THEN
              min14 = v(i, j+1)
            ELSE
              min14 = v(i, j)
            END IF
          ELSE IF (v(i, j-1) .GT. v(i, j+1)) THEN
            min14 = v(i, j+1)
          ELSE
            min14 = v(i, j-1)
          END IF
          z1 = v(i, j) - min14
          IF (x2 .GT. y1) THEN
            IF (y1 .GT. z1) THEN
              min1 = z1
            ELSE
              min1 = y1
            END IF
          ELSE IF (x2 .GT. z1) THEN
            min1 = z1
          ELSE
            min1 = x2
          END IF
          dm(i, j) = SIGN(min1, xt)
        END DO
      END DO
      IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
        IF (js .EQ. 1) THEN
          DO i=is,ie+1
            x0l = 0.5*((2.*dy(i, 0)+dy(i, -1))*v(i, 0)-dy(i, 0)*v(i, -1)&
&             )/(dy(i, 0)+dy(i, -1))
            x0r = 0.5*((2.*dy(i, 1)+dy(i, 2))*v(i, 1)-dy(i, 1)*v(i, 2))/&
&             (dy(i, 1)+dy(i, 2))
            x0 = x0l + x0r
            x1 = s15*v(i, 1) + s11*v(i, 2) - s14*dm(i, 2)
!           dm(i,1) = x1 - v(i,1)
            dm(i, 1) = 0.5*(x1-x0)
            IF (dm(i, 1) .GE. 0.) THEN
              x3 = dm(i, 1)
            ELSE
              x3 = -dm(i, 1)
            END IF
            IF (v(i, 1) .LT. x0) THEN
              IF (x0 .LT. x1) THEN
                max2 = x1
              ELSE
                max2 = x0
              END IF
            ELSE IF (v(i, 1) .LT. x1) THEN
              max2 = x1
            ELSE
              max2 = v(i, 1)
            END IF
            y2 = max2 - v(i, 1)
            IF (v(i, 1) .GT. x0) THEN
              IF (x0 .GT. x1) THEN
                min15 = x1
              ELSE
                min15 = x0
              END IF
            ELSE IF (v(i, 1) .GT. x1) THEN
              min15 = x1
            ELSE
              min15 = v(i, 1)
            END IF
            z2 = v(i, 1) - min15
            IF (x3 .GT. y2) THEN
              IF (y2 .GT. z2) THEN
                min2 = z2
              ELSE
                min2 = y2
              END IF
            ELSE IF (x3 .GT. z2) THEN
              min2 = z2
            ELSE
              min2 = x3
            END IF
            dm(i, 1) = SIGN(min2, dm(i, 1))
            x1 = s15*v(i, 0) + s11*v(i, -1) + s14*dm(i, -1)
!           dm(i,0) = v(i,0) - x1
            dm(i, 0) = 0.5*(x0-x1)
            IF (dm(i, 0) .GE. 0.) THEN
              x4 = dm(i, 0)
            ELSE
              x4 = -dm(i, 0)
            END IF
            IF (v(i, 0) .LT. x0) THEN
              IF (x0 .LT. x1) THEN
                max3 = x1
              ELSE
                max3 = x0
              END IF
            ELSE IF (v(i, 0) .LT. x1) THEN
              max3 = x1
            ELSE
              max3 = v(i, 0)
            END IF
            y3 = max3 - v(i, 0)
            IF (v(i, 0) .GT. x0) THEN
              IF (x0 .GT. x1) THEN
                min16 = x1
              ELSE
                min16 = x0
              END IF
            ELSE IF (v(i, 0) .GT. x1) THEN
              min16 = x1
            ELSE
              min16 = v(i, 0)
            END IF
            z3 = v(i, 0) - min16
            IF (x4 .GT. y3) THEN
              IF (y3 .GT. z3) THEN
                min3 = z3
              ELSE
                min3 = y3
              END IF
            ELSE IF (x4 .GT. z3) THEN
              min3 = z3
            ELSE
              min3 = x4
            END IF
            dm(i, 0) = SIGN(min3, dm(i, 0))
          END DO
          IF (is .EQ. 1) THEN
            dm(1, 0) = 0.
            dm(1, 1) = 0.
          END IF
          IF (ie + 1 .EQ. npx) THEN
            dm(npx, 0) = 0.
            dm(npx, 1) = 0.
          END IF
        END IF
        IF (je + 1 .EQ. npy) THEN
          DO i=is,ie+1
            x0l = 0.5*((2.*dy(i, npy-1)+dy(i, npy-2))*v(i, npy-1)-dy(i, &
&             npy-1)*v(i, npy-2))/(dy(i, npy-1)+dy(i, npy-2))
            x0r = 0.5*((2.*dy(i, npy)+dy(i, npy+1))*v(i, npy)-dy(i, npy)&
&             *v(i, npy+1))/(dy(i, npy)+dy(i, npy+1))
            x0 = x0l + x0r
            x1 = s15*v(i, npy-1) + s11*v(i, npy-2) + s14*dm(i, npy-2)
!           dm(i,npy-1) = v(i,npy-1) - x1
            dm(i, npy-1) = 0.5*(x0-x1)
            IF (dm(i, npy-1) .GE. 0.) THEN
              x5 = dm(i, npy-1)
            ELSE
              x5 = -dm(i, npy-1)
            END IF
            IF (v(i, npy-1) .LT. x0) THEN
              IF (x0 .LT. x1) THEN
                max4 = x1
              ELSE
                max4 = x0
              END IF
            ELSE IF (v(i, npy-1) .LT. x1) THEN
              max4 = x1
            ELSE
              max4 = v(i, npy-1)
            END IF
            y4 = max4 - v(i, npy-1)
            IF (v(i, npy-1) .GT. x0) THEN
              IF (x0 .GT. x1) THEN
                min17 = x1
              ELSE
                min17 = x0
              END IF
            ELSE IF (v(i, npy-1) .GT. x1) THEN
              min17 = x1
            ELSE
              min17 = v(i, npy-1)
            END IF
            z4 = v(i, npy-1) - min17
            IF (x5 .GT. y4) THEN
              IF (y4 .GT. z4) THEN
                min4 = z4
              ELSE
                min4 = y4
              END IF
            ELSE IF (x5 .GT. z4) THEN
              min4 = z4
            ELSE
              min4 = x5
            END IF
            dm(i, npy-1) = SIGN(min4, dm(i, npy-1))
            x1 = s15*v(i, npy) + s11*v(i, npy+1) - s14*dm(i, npy+1)
!           dm(i,npy) = x1 - v(i,npy)
            dm(i, npy) = 0.5*(x1-x0)
            IF (dm(i, npy) .GE. 0.) THEN
              x6 = dm(i, npy)
            ELSE
              x6 = -dm(i, npy)
            END IF
            IF (v(i, npy) .LT. x0) THEN
              IF (x0 .LT. x1) THEN
                max5 = x1
              ELSE
                max5 = x0
              END IF
            ELSE IF (v(i, npy) .LT. x1) THEN
              max5 = x1
            ELSE
              max5 = v(i, npy)
            END IF
            y5 = max5 - v(i, npy)
            IF (v(i, npy) .GT. x0) THEN
              IF (x0 .GT. x1) THEN
                min18 = x1
              ELSE
                min18 = x0
              END IF
            ELSE IF (v(i, npy) .GT. x1) THEN
              min18 = x1
            ELSE
              min18 = v(i, npy)
            END IF
            z5 = v(i, npy) - min18
            IF (x6 .GT. y5) THEN
              IF (y5 .GT. z5) THEN
                min5 = z5
              ELSE
                min5 = y5
              END IF
            ELSE IF (x6 .GT. z5) THEN
              min5 = z5
            ELSE
              min5 = x6
            END IF
            dm(i, npy) = SIGN(min5, dm(i, npy))
          END DO
          IF (is .EQ. 1) THEN
            dm(1, npy-1) = 0.
            dm(1, npy) = 0.
          END IF
          IF (ie + 1 .EQ. npx) THEN
            dm(npx, npy-1) = 0.
            dm(npx, npy) = 0.
          END IF
        END IF
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            flux(i, j) = v(i, j-1) + (1.-c(i, j)*rdy(i, j-1))*dm(i, j-1)
          ELSE
            flux(i, j) = v(i, j) - (1.+c(i, j)*rdy(i, j))*dm(i, j)
          END IF
        END DO
      END DO
    CASE (4) 
      DO j=js-2,je+2
        DO i=is,ie+1
          xt = 0.25*(v(i, j+1)-v(i, j-1))
          IF (xt .GE. 0.) THEN
            x7 = xt
          ELSE
            x7 = -xt
          END IF
          IF (v(i, j-1) .LT. v(i, j)) THEN
            IF (v(i, j) .LT. v(i, j+1)) THEN
              max6 = v(i, j+1)
            ELSE
              max6 = v(i, j)
            END IF
          ELSE IF (v(i, j-1) .LT. v(i, j+1)) THEN
            max6 = v(i, j+1)
          ELSE
            max6 = v(i, j-1)
          END IF
          y6 = max6 - v(i, j)
          IF (v(i, j-1) .GT. v(i, j)) THEN
            IF (v(i, j) .GT. v(i, j+1)) THEN
              min19 = v(i, j+1)
            ELSE
              min19 = v(i, j)
            END IF
          ELSE IF (v(i, j-1) .GT. v(i, j+1)) THEN
            min19 = v(i, j+1)
          ELSE
            min19 = v(i, j-1)
          END IF
          z6 = v(i, j) - min19
          IF (x7 .GT. y6) THEN
            IF (y6 .GT. z6) THEN
              min6 = z6
            ELSE
              min6 = y6
            END IF
          ELSE IF (x7 .GT. z6) THEN
            min6 = z6
          ELSE
            min6 = x7
          END IF
          dm(i, j) = SIGN(min6, xt)
        END DO
      END DO
      DO j=js-1,je+2
        DO i=is,ie+1
          al(i, j) = 0.5*(v(i, j-1)+v(i, j)) + r3*(dm(i, j-1)-dm(i, j))
        END DO
      END DO
      IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
        IF (js .EQ. 1) THEN
          DO i=is,ie+1
            x0l = 0.5*((2.*dy(i, 0)+dy(i, -1))*v(i, 0)-dy(i, 0)*v(i, -1)&
&             )/(dy(i, 0)+dy(i, -1))
            x0r = 0.5*((2.*dy(i, 1)+dy(i, 2))*v(i, 1)-dy(i, 1)*v(i, 2))/&
&             (dy(i, 1)+dy(i, 2))
            x0 = x0l + x0r
            x1 = s15*v(i, 1) + s11*v(i, 2) - s14*dm(i, 2)
            dm(i, 1) = 0.5*(x1-x0)
!           dm(i,1) = sign(min(abs(dm(i,1)), max(v(i,1), x0, x1) - v(i,1),   &
!                                   v(i,1) - min(v(i,1), x0, x1)), dm(i,1))
            x1 = s15*v(i, 0) + s11*v(i, -1) + s14*dm(i, -1)
            dm(i, 0) = 0.5*(x0-x1)
!           dm(i,0) = sign(min(abs(dm(i,0)), max(v(i,0), x0, x1) - v(i,0),   &
!                                   v(i,0) - min(v(i,0), x0, x1)), dm(i,0))
            al(i, 0) = 0.5*(v(i, -1)+v(i, 0)) + r3*(dm(i, -1)-dm(i, 0))
            al(i, 1) = x0
            al(i, 2) = 0.5*(v(i, 1)+v(i, 2)) + r3*(dm(i, 1)-dm(i, 2))
          END DO
          IF (is .EQ. 1) THEN
            dm(1, 0) = 0.
            dm(1, 1) = 0.
            i = 1
            al(i, 0) = 0.5*(v(i, -1)+v(i, 0)) + r3*(dm(i, -1)-dm(i, 0))
            al(i, 2) = 0.5*(v(i, 1)+v(i, 2)) + r3*(dm(i, 1)-dm(i, 2))
          END IF
          IF (ie + 1 .EQ. npx) THEN
            dm(npx, 0) = 0.
            dm(npx, 1) = 0.
            i = npx
            al(i, 0) = 0.5*(v(i, -1)+v(i, 0)) + r3*dm(i, -1)
            al(i, 2) = 0.5*(v(i, 1)+v(i, 2)) - r3*dm(i, 2)
          END IF
        END IF
        IF (je + 1 .EQ. npy) THEN
          DO i=is,ie+1
            x0l = 0.5*((2.*dy(i, npy-1)+dy(i, npy-2))*v(i, npy-1)-dy(i, &
&             npy-1)*v(i, npy-2))/(dy(i, npy-1)+dy(i, npy-2))
            x0r = 0.5*((2.*dy(i, npy)+dy(i, npy+1))*v(i, npy)-dy(i, npy)&
&             *v(i, npy+1))/(dy(i, npy)+dy(i, npy+1))
            x0 = x0l + x0r
            x1 = s15*v(i, npy-1) + s11*v(i, npy-2) + s14*dm(i, npy-2)
            dm(i, npy-1) = 0.5*(x0-x1)
!           dm(i,npy-1) = sign(min(abs(dm(i,npy-1)), max(v(i,npy-1), x0, x1) - v(i,npy-1),  &
!                                       v(i,npy-1) - min(v(i,npy-1), x0, x1)), dm(i,npy-1))
            x1 = s15*v(i, npy) + s11*v(i, npy+1) - s14*dm(i, npy+1)
            dm(i, npy) = 0.5*(x1-x0)
!           dm(i,npy) = sign(min(abs(dm(i,npy)), max(v(i,npy), x0, x1) - v(i,npy),   &
!                                     v(i,npy) - min(v(i,npy), x0, x1)), dm(i,npy))
            al(i, npy-1) = 0.5*(v(i, npy-2)+v(i, npy-1)) + r3*(dm(i, npy&
&             -2)-dm(i, npy-1))
            al(i, npy) = x0
            al(i, npy+1) = 0.5*(v(i, npy)+v(i, npy+1)) + r3*(dm(i, npy)-&
&             dm(i, npy+1))
          END DO
          IF (is .EQ. 1) THEN
            dm(1, npy-1) = 0.
            dm(1, npy) = 0.
            i = 1
            al(i, npy-1) = 0.5*(v(i, npy-2)+v(i, npy-1)) + r3*dm(i, npy-&
&             2)
            al(i, npy+1) = 0.5*(v(i, npy)+v(i, npy+1)) - r3*dm(i, npy+1)
          END IF
          IF (ie + 1 .EQ. npx) THEN
            dm(npx, npy-1) = 0.
            dm(npx, npy) = 0.
            i = npx
            al(i, npy-1) = 0.5*(v(i, npy-2)+v(i, npy-1)) + r3*dm(i, npy-&
&             2)
            al(i, npy+1) = 0.5*(v(i, npy)+v(i, npy+1)) - r3*dm(i, npy+1)
          END IF
        END IF
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            xt = 2.*dm(i, j-1)
            IF (xt .GE. 0.) THEN
              x8 = xt
            ELSE
              x8 = -xt
            END IF
            IF (al(i, j-1) - v(i, j-1) .GE. 0.) THEN
              y7 = al(i, j-1) - v(i, j-1)
            ELSE
              y7 = -(al(i, j-1)-v(i, j-1))
            END IF
            IF (x8 .GT. y7) THEN
              min7 = y7
            ELSE
              min7 = x8
            END IF
            dl = SIGN(min7, xt)
            IF (xt .GE. 0.) THEN
              x9 = xt
            ELSE
              x9 = -xt
            END IF
            IF (al(i, j) - v(i, j-1) .GE. 0.) THEN
              y8 = al(i, j) - v(i, j-1)
            ELSE
              y8 = -(al(i, j)-v(i, j-1))
            END IF
            IF (x9 .GT. y8) THEN
              min8 = y8
            ELSE
              min8 = x9
            END IF
            dr = SIGN(min8, xt)
            cfl = c(i, j)*rdy(i, j-1)
            flux(i, j) = v(i, j-1) + (1.-cfl)*(dr+cfl*(dl-dr))
          ELSE
            xt = 2.*dm(i, j)
            IF (xt .GE. 0.) THEN
              x10 = xt
            ELSE
              x10 = -xt
            END IF
            IF (al(i, j) - v(i, j) .GE. 0.) THEN
              y9 = al(i, j) - v(i, j)
            ELSE
              y9 = -(al(i, j)-v(i, j))
            END IF
            IF (x10 .GT. y9) THEN
              min9 = y9
            ELSE
              min9 = x10
            END IF
            dl = SIGN(min9, xt)
            IF (xt .GE. 0.) THEN
              x11 = xt
            ELSE
              x11 = -xt
            END IF
            IF (al(i, j+1) - v(i, j) .GE. 0.) THEN
              y10 = al(i, j+1) - v(i, j)
            ELSE
              y10 = -(al(i, j+1)-v(i, j))
            END IF
            IF (x11 .GT. y10) THEN
              min10 = y10
            ELSE
              min10 = x11
            END IF
            dr = SIGN(min10, xt)
            cfl = c(i, j)*rdy(i, j)
            flux(i, j) = v(i, j) - (1.+cfl)*(dl+cfl*(dl-dr))
          END IF
        END DO
      END DO
    CASE (6) 
      DO j=js3,je3+1
        DO i=is,ie+1
          al(i, j) = p1*(v(i, j-1)+v(i, j)) + p2*(v(i, j-2)+v(i, j+1))
        END DO
      END DO
      DO j=js3,je3
        DO i=is,ie+1
          bl(i, j) = al(i, j) - v(i, j)
          br(i, j) = al(i, j+1) - v(i, j)
        END DO
      END DO
      IF (.NOT.nested .AND. grid_type .LT. 3) THEN
        IF (js .EQ. 1) THEN
          DO i=is,ie+1
            bl(i, 0) = c1*v(i, -2) + c2*v(i, -1) + c3*v(i, 0) - v(i, 0)
            xt = 0.5*(((2.*dy(i, 0)+dy(i, -1))*v(i, 0)-dy(i, 0)*v(i, -1)&
&             )/(dy(i, 0)+dy(i, -1))+((2.*dy(i, 1)+dy(i, 2))*v(i, 1)-dy(&
&             i, 1)*v(i, 2))/(dy(i, 1)+dy(i, 2)))
            br(i, 0) = xt - v(i, 0)
            bl(i, 1) = xt - v(i, 1)
            xt = c3*v(i, 1) + c2*v(i, 2) + c1*v(i, 3)
            br(i, 1) = xt - v(i, 1)
            bl(i, 2) = xt - v(i, 2)
            br(i, 2) = al(i, 3) - v(i, 2)
          END DO
          IF (is .EQ. 1) THEN
! out
            bl(1, 0) = 0.
! edge
            br(1, 0) = 0.
! edge
            bl(1, 1) = 0.
! in
            br(1, 1) = 0.
          END IF
          IF (ie + 1 .EQ. npx) THEN
! out
            bl(npx, 0) = 0.
! edge
            br(npx, 0) = 0.
! edge
            bl(npx, 1) = 0.
! in
            br(npx, 1) = 0.
          END IF
        END IF
        IF (je + 1 .EQ. npy) THEN
          DO i=is,ie+1
            bl(i, npy-2) = al(i, npy-2) - v(i, npy-2)
            xt = c1*v(i, npy-3) + c2*v(i, npy-2) + c3*v(i, npy-1)
            br(i, npy-2) = xt - v(i, npy-2)
            bl(i, npy-1) = xt - v(i, npy-1)
            xt = 0.5*(((2.*dy(i, npy-1)+dy(i, npy-2))*v(i, npy-1)-dy(i, &
&             npy-1)*v(i, npy-2))/(dy(i, npy-1)+dy(i, npy-2))+((2.*dy(i&
&             , npy)+dy(i, npy+1))*v(i, npy)-dy(i, npy)*v(i, npy+1))/(dy&
&             (i, npy)+dy(i, npy+1)))
            br(i, npy-1) = xt - v(i, npy-1)
            bl(i, npy) = xt - v(i, npy)
            br(i, npy) = c3*v(i, npy) + c2*v(i, npy+1) + c1*v(i, npy+2) &
&             - v(i, npy)
          END DO
          IF (is .EQ. 1) THEN
! in
            bl(1, npy-1) = 0.
! edge
            br(1, npy-1) = 0.
! edge
            bl(1, npy) = 0.
! out
            br(1, npy) = 0.
          END IF
          IF (ie + 1 .EQ. npx) THEN
! in
            bl(npx, npy-1) = 0.
! edge
            br(npx, npy-1) = 0.
! edge
            bl(npx, npy) = 0.
! out
            br(npx, npy) = 0.
          END IF
        END IF
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            cfl = c(i, j)*rdy(i, j-1)
            flux(i, j) = v(i, j-1) + (1.-cfl)*(br(i, j-1)-cfl*(bl(i, j-1&
&             )+br(i, j-1)))
          ELSE
            cfl = c(i, j)*rdy(i, j)
            flux(i, j) = v(i, j) + (1.+cfl)*(bl(i, j)+cfl*(bl(i, j)+br(i&
&             , j)))
          END IF
        END DO
      END DO
    CASE DEFAULT
! jord= 8, 9, 10
      DO j=js-2,je+2
        DO i=is,ie+1
          xt = 0.25*(v(i, j+1)-v(i, j-1))
          IF (xt .GE. 0.) THEN
            x12 = xt
          ELSE
            x12 = -xt
          END IF
          IF (v(i, j-1) .LT. v(i, j)) THEN
            IF (v(i, j) .LT. v(i, j+1)) THEN
              max7 = v(i, j+1)
            ELSE
              max7 = v(i, j)
            END IF
          ELSE IF (v(i, j-1) .LT. v(i, j+1)) THEN
            max7 = v(i, j+1)
          ELSE
            max7 = v(i, j-1)
          END IF
          y11 = max7 - v(i, j)
          IF (v(i, j-1) .GT. v(i, j)) THEN
            IF (v(i, j) .GT. v(i, j+1)) THEN
              min20 = v(i, j+1)
            ELSE
              min20 = v(i, j)
            END IF
          ELSE IF (v(i, j-1) .GT. v(i, j+1)) THEN
            min20 = v(i, j+1)
          ELSE
            min20 = v(i, j-1)
          END IF
          z7 = v(i, j) - min20
          IF (x12 .GT. y11) THEN
            IF (y11 .GT. z7) THEN
              min11 = z7
            ELSE
              min11 = y11
            END IF
          ELSE IF (x12 .GT. z7) THEN
            min11 = z7
          ELSE
            min11 = x12
          END IF
          dm(i, j) = SIGN(min11, xt)
        END DO
      END DO
      DO j=js-3,je+2
        DO i=is,ie+1
          dq(i, j) = v(i, j+1) - v(i, j)
        END DO
      END DO
      IF (grid_type .LT. 3) THEN
        DO j=js3,je3+1
          DO i=is,ie+1
            al(i, j) = 0.5*(v(i, j-1)+v(i, j)) + r3*(dm(i, j-1)-dm(i, j)&
&             )
          END DO
        END DO
        IF (jord .EQ. 8) THEN
          DO j=js3,je3
            DO i=is,ie+1
              xt = 2.*dm(i, j)
              IF (xt .GE. 0.) THEN
                x13 = xt
              ELSE
                x13 = -xt
              END IF
              IF (al(i, j) - v(i, j) .GE. 0.) THEN
                y12 = al(i, j) - v(i, j)
              ELSE
                y12 = -(al(i, j)-v(i, j))
              END IF
              IF (x13 .GT. y12) THEN
                min12 = y12
              ELSE
                min12 = x13
              END IF
              bl(i, j) = -SIGN(min12, xt)
              IF (xt .GE. 0.) THEN
                x14 = xt
              ELSE
                x14 = -xt
              END IF
              IF (al(i, j+1) - v(i, j) .GE. 0.) THEN
                y13 = al(i, j+1) - v(i, j)
              ELSE
                y13 = -(al(i, j+1)-v(i, j))
              END IF
              IF (x14 .GT. y13) THEN
                min13 = y13
              ELSE
                min13 = x14
              END IF
              br(i, j) = SIGN(min13, xt)
            END DO
          END DO
        ELSE IF (jord .EQ. 9) THEN
          DO j=js3,je3
            DO i=is,ie+1
              pmp_1 = -(2.*dq(i, j))
              lac_1 = pmp_1 + 1.5*dq(i, j+1)
              IF (0. .LT. pmp_1) THEN
                IF (pmp_1 .LT. lac_1) THEN
                  x15 = lac_1
                ELSE
                  x15 = pmp_1
                END IF
              ELSE IF (0. .LT. lac_1) THEN
                x15 = lac_1
              ELSE
                x15 = 0.
              END IF
              IF (0. .GT. pmp_1) THEN
                IF (pmp_1 .GT. lac_1) THEN
                  y20 = lac_1
                ELSE
                  y20 = pmp_1
                END IF
              ELSE IF (0. .GT. lac_1) THEN
                y20 = lac_1
              ELSE
                y20 = 0.
              END IF
              IF (al(i, j) - v(i, j) .LT. y20) THEN
                y14 = y20
              ELSE
                y14 = al(i, j) - v(i, j)
              END IF
              IF (x15 .GT. y14) THEN
                bl(i, j) = y14
              ELSE
                bl(i, j) = x15
              END IF
              pmp_2 = 2.*dq(i, j-1)
              lac_2 = pmp_2 - 1.5*dq(i, j-2)
              IF (0. .LT. pmp_2) THEN
                IF (pmp_2 .LT. lac_2) THEN
                  x16 = lac_2
                ELSE
                  x16 = pmp_2
                END IF
              ELSE IF (0. .LT. lac_2) THEN
                x16 = lac_2
              ELSE
                x16 = 0.
              END IF
              IF (0. .GT. pmp_2) THEN
                IF (pmp_2 .GT. lac_2) THEN
                  y21 = lac_2
                ELSE
                  y21 = pmp_2
                END IF
              ELSE IF (0. .GT. lac_2) THEN
                y21 = lac_2
              ELSE
                y21 = 0.
              END IF
              IF (al(i, j+1) - v(i, j) .LT. y21) THEN
                y15 = y21
              ELSE
                y15 = al(i, j+1) - v(i, j)
              END IF
              IF (x16 .GT. y15) THEN
                br(i, j) = y15
              ELSE
                br(i, j) = x16
              END IF
            END DO
          END DO
        ELSE IF (jord .EQ. 10) THEN
          DO j=js3,je3
            DO i=is,ie+1
              bl(i, j) = al(i, j) - v(i, j)
              br(i, j) = al(i, j+1) - v(i, j)
              IF (dm(i, j) .GE. 0.) THEN
                abs0 = dm(i, j)
              ELSE
                abs0 = -dm(i, j)
              END IF
!           if ( abs(dm(i,j-1))+abs(dm(i,j))+abs(dm(i,j+1)) < near_zero ) then
              IF (abs0 .LT. near_zero) THEN
                IF (dm(i, j-1) .GE. 0.) THEN
                  abs1 = dm(i, j-1)
                ELSE
                  abs1 = -dm(i, j-1)
                END IF
                IF (dm(i, j+1) .GE. 0.) THEN
                  abs3 = dm(i, j+1)
                ELSE
                  abs3 = -dm(i, j+1)
                END IF
                IF (abs1 + abs3 .LT. near_zero) THEN
                  bl(i, j) = 0.
                  br(i, j) = 0.
                END IF
              ELSE
                IF (3.*(bl(i, j)+br(i, j)) .GE. 0.) THEN
                  abs2 = 3.*(bl(i, j)+br(i, j))
                ELSE
                  abs2 = -(3.*(bl(i, j)+br(i, j)))
                END IF
                IF (bl(i, j) - br(i, j) .GE. 0.) THEN
                  abs4 = bl(i, j) - br(i, j)
                ELSE
                  abs4 = -(bl(i, j)-br(i, j))
                END IF
                IF (abs2 .GT. abs4) THEN
                  pmp_1 = -(2.*dq(i, j))
                  lac_1 = pmp_1 + 1.5*dq(i, j+1)
                  IF (0. .LT. pmp_1) THEN
                    IF (pmp_1 .LT. lac_1) THEN
                      x17 = lac_1
                    ELSE
                      x17 = pmp_1
                    END IF
                  ELSE IF (0. .LT. lac_1) THEN
                    x17 = lac_1
                  ELSE
                    x17 = 0.
                  END IF
                  IF (0. .GT. pmp_1) THEN
                    IF (pmp_1 .GT. lac_1) THEN
                      y22 = lac_1
                    ELSE
                      y22 = pmp_1
                    END IF
                  ELSE IF (0. .GT. lac_1) THEN
                    y22 = lac_1
                  ELSE
                    y22 = 0.
                  END IF
                  IF (bl(i, j) .LT. y22) THEN
                    y16 = y22
                  ELSE
                    y16 = bl(i, j)
                  END IF
                  IF (x17 .GT. y16) THEN
                    bl(i, j) = y16
                  ELSE
                    bl(i, j) = x17
                  END IF
                  pmp_2 = 2.*dq(i, j-1)
                  lac_2 = pmp_2 - 1.5*dq(i, j-2)
                  IF (0. .LT. pmp_2) THEN
                    IF (pmp_2 .LT. lac_2) THEN
                      x18 = lac_2
                    ELSE
                      x18 = pmp_2
                    END IF
                  ELSE IF (0. .LT. lac_2) THEN
                    x18 = lac_2
                  ELSE
                    x18 = 0.
                  END IF
                  IF (0. .GT. pmp_2) THEN
                    IF (pmp_2 .GT. lac_2) THEN
                      y23 = lac_2
                    ELSE
                      y23 = pmp_2
                    END IF
                  ELSE IF (0. .GT. lac_2) THEN
                    y23 = lac_2
                  ELSE
                    y23 = 0.
                  END IF
                  IF (br(i, j) .LT. y23) THEN
                    y17 = y23
                  ELSE
                    y17 = br(i, j)
                  END IF
                  IF (x18 .GT. y17) THEN
                    br(i, j) = y17
                  ELSE
                    br(i, j) = x18
                  END IF
                END IF
              END IF
            END DO
          END DO
        ELSE
! Unlimited:
          DO j=js3,je3
            DO i=is,ie+1
              bl(i, j) = al(i, j) - v(i, j)
              br(i, j) = al(i, j+1) - v(i, j)
            END DO
          END DO
        END IF
!--------------
! fix the edges
!--------------
        IF (js .EQ. 1 .AND. (.NOT.nested)) THEN
          DO i=is,ie+1
            br(i, 2) = al(i, 3) - v(i, 2)
            xt = s15*v(i, 1) + s11*v(i, 2) - s14*dm(i, 2)
            br(i, 1) = xt - v(i, 1)
            bl(i, 2) = xt - v(i, 2)
            bl(i, 0) = s14*dm(i, -1) - s11*dq(i, -1)
!#ifdef ONE_SIDE
!            xt =  t14*v(i,1) +  t12*v(i,2) + t15*v(i,3)
!            bl(i,1) = 2.*xt - v(i,1)
!            xt =  t14*v(i,0) +  t12*v(i,-1) + t15*v(i,-2)
!            br(i,0) = 2.*xt - v(i,0)
!#else
            x0l = 0.5*((2.*dy(i, 0)+dy(i, -1))*v(i, 0)-dy(i, 0)*v(i, -1)&
&             )/(dy(i, 0)+dy(i, -1))
            x0r = 0.5*((2.*dy(i, 1)+dy(i, 2))*v(i, 1)-dy(i, 1)*v(i, 2))/&
&             (dy(i, 1)+dy(i, 2))
            xt = x0l + x0r
            bl(i, 1) = xt - v(i, 1)
            br(i, 0) = xt - v(i, 0)
          END DO
!#endif
          IF (is .EQ. 1) THEN
! out
            bl(1, 0) = 0.
! edge
            br(1, 0) = 0.
! edge
            bl(1, 1) = 0.
! in
            br(1, 1) = 0.
          END IF
          IF (ie + 1 .EQ. npx) THEN
! out
            bl(npx, 0) = 0.
! edge
            br(npx, 0) = 0.
! edge
            bl(npx, 1) = 0.
! in
            br(npx, 1) = 0.
          END IF
          j = 2
          arg1 = ie - is + 2
          CALL PERT_PPM(arg1, v(is, j), bl(is, j), br(is, j), -1)
        END IF
        IF (je + 1 .EQ. npy .AND. (.NOT.nested)) THEN
          DO i=is,ie+1
            bl(i, npy-2) = al(i, npy-2) - v(i, npy-2)
            xt = s15*v(i, npy-1) + s11*v(i, npy-2) + s14*dm(i, npy-2)
            br(i, npy-2) = xt - v(i, npy-2)
            bl(i, npy-1) = xt - v(i, npy-1)
            br(i, npy) = s11*dq(i, npy) - s14*dm(i, npy+1)
!#ifdef ONE_SIDE
!            xt = t14*v(i,npy-1) + t12*v(i,npy-2) + t15*v(i,npy-3)
!            br(i,npy-1) = 2.*xt - v(i,npy-1)
!            xt = t14*v(i,npy) + t12*v(i,npy+1) + t15*v(i,npy+2)
!            bl(i,npy  ) = 2.*xt - v(i,npy)
!#else
            x0l = 0.5*((2.*dy(i, npy-1)+dy(i, npy-2))*v(i, npy-1)-dy(i, &
&             npy-1)*v(i, npy-2))/(dy(i, npy-1)+dy(i, npy-2))
            x0r = 0.5*((2.*dy(i, npy)+dy(i, npy+1))*v(i, npy)-dy(i, npy)&
&             *v(i, npy+1))/(dy(i, npy)+dy(i, npy+1))
            xt = x0l + x0r
            br(i, npy-1) = xt - v(i, npy-1)
            bl(i, npy) = xt - v(i, npy)
          END DO
!#endif
          IF (is .EQ. 1) THEN
! in
            bl(1, npy-1) = 0.
! edge
            br(1, npy-1) = 0.
! edge
            bl(1, npy) = 0.
! out
            br(1, npy) = 0.
          END IF
          IF (ie + 1 .EQ. npx) THEN
! in
            bl(npx, npy-1) = 0.
! edge
            br(npx, npy-1) = 0.
! edge
            bl(npx, npy) = 0.
! out
            br(npx, npy) = 0.
          END IF
          j = npy - 2
          arg1 = ie - is + 2
          CALL PERT_PPM(arg1, v(is, j), bl(is, j), br(is, j), -1)
        END IF
      ELSE
        DO j=js-1,je+2
          DO i=is,ie+1
            al(i, j) = 0.5*(v(i, j-1)+v(i, j)) + r3*(dm(i, j-1)-dm(i, j)&
&             )
          END DO
        END DO
        DO j=js-1,je+1
          DO i=is,ie+1
            pmp = 2.*dq(i, j-1)
            lac = pmp - 1.5*dq(i, j-2)
            IF (0. .LT. pmp) THEN
              IF (pmp .LT. lac) THEN
                x19 = lac
              ELSE
                x19 = pmp
              END IF
            ELSE IF (0. .LT. lac) THEN
              x19 = lac
            ELSE
              x19 = 0.
            END IF
            IF (0. .GT. pmp) THEN
              IF (pmp .GT. lac) THEN
                y24 = lac
              ELSE
                y24 = pmp
              END IF
            ELSE IF (0. .GT. lac) THEN
              y24 = lac
            ELSE
              y24 = 0.
            END IF
            IF (al(i, j+1) - v(i, j) .LT. y24) THEN
              y18 = y24
            ELSE
              y18 = al(i, j+1) - v(i, j)
            END IF
            IF (x19 .GT. y18) THEN
              br(i, j) = y18
            ELSE
              br(i, j) = x19
            END IF
            pmp = -(2.*dq(i, j))
            lac = pmp + 1.5*dq(i, j+1)
            IF (0. .LT. pmp) THEN
              IF (pmp .LT. lac) THEN
                x20 = lac
              ELSE
                x20 = pmp
              END IF
            ELSE IF (0. .LT. lac) THEN
              x20 = lac
            ELSE
              x20 = 0.
            END IF
            IF (0. .GT. pmp) THEN
              IF (pmp .GT. lac) THEN
                y25 = lac
              ELSE
                y25 = pmp
              END IF
            ELSE IF (0. .GT. lac) THEN
              y25 = lac
            ELSE
              y25 = 0.
            END IF
            IF (al(i, j) - v(i, j) .LT. y25) THEN
              y19 = y25
            ELSE
              y19 = al(i, j) - v(i, j)
            END IF
            IF (x20 .GT. y19) THEN
              bl(i, j) = y19
            ELSE
              bl(i, j) = x20
            END IF
          END DO
        END DO
      END IF
      DO j=js,je+1
        DO i=is,ie+1
          IF (c(i, j) .GT. 0.) THEN
            cfl = c(i, j)*rdy(i, j-1)
            flux(i, j) = v(i, j-1) + (1.-cfl)*(br(i, j-1)-cfl*(bl(i, j-1&
&             )+br(i, j-1)))
          ELSE
            cfl = c(i, j)*rdy(i, j)
            flux(i, j) = v(i, j) + (1.+cfl)*(bl(i, j)+cfl*(bl(i, j)+br(i&
&             , j)))
          END IF
        END DO
      END DO
    END SELECT
  END SUBROUTINE YTP_V
!  Differentiation of d2a2c_vect in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_m
!od.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_
!halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core
!_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.r
!ayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_
!to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_ene
!rgy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz
!_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz 
!fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solv
!er_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_co
!re_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergenc
!e_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_
!mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_
!mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core
!_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: u v ua uc ut va vc vt
!   with respect to varying inputs: u v ua uc ut va vc vt
!There is a limit to how far this routine can fill uc and vc in the
! halo, and so either mpp_update_domains or some sort of boundary
!  routine (extrapolation, outflow, interpolation from a nested grid)
!   is needed after c_sw is completed if these variables are needed
!    in the halo
  SUBROUTINE D2A2C_VECT_FWD(u, v, ua, va, uc, vc, ut, vt, dord4, &
&   gridstruct, bd, npx, npy, nested, grid_type)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    LOGICAL, INTENT(IN) :: dord4
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed) :: uc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1) :: vc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ua, va, ut, &
&   vt
    INTEGER, INTENT(IN) :: npx, npy, grid_type
    LOGICAL, INTENT(IN) :: nested
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
! Local 
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: utmp, vtmp
    INTEGER :: npt, i, j, ii, jj, ifirst, ilast, id
!  real(FVPRC), pointer, dimension(:,:,:) :: sin_sg
!  real(FVPRC), pointer, dimension(:,:)   :: cosa_u, cosa_v, cosa_s
!  real(FVPRC), pointer, dimension(:,:)   :: rsin_u, rsin_v, rsin2
!  real(FVPRC), pointer, dimension(:,:)   ::  dxa,dya
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: max5
    INTEGER :: max6
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    INTEGER :: min5
    INTEGER :: min6
    INTEGER :: ad_from
    INTEGER :: ad_from0
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
!      sin_sg    => gridstruct%sin_sg  
!      cosa_u    => gridstruct%cosa_u  
!      cosa_v    => gridstruct%cosa_v  
!      cosa_s    => gridstruct%cosa_s  
!      rsin_u    => gridstruct%rsin_u  
!      rsin_v    => gridstruct%rsin_v  
!      rsin2     => gridstruct%rsin2   
!      dxa       => gridstruct%dxa     
!      dya       => gridstruct%dya     
    IF (dord4) THEN
      id = 1
    ELSE
      id = 0
    END IF
    IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
      npt = 4
    ELSE
      npt = -2
    END IF
! Initialize the non-existing corner regions
    utmp = big_number
    vtmp = big_number
    IF (nested) THEN
      DO j=jsd+1,jed-1
        DO i=isd,ied
          utmp(i, j) = a2*(u(i, j-1)+u(i, j+2)) + a1*(u(i, j)+u(i, j+1))
        END DO
      END DO
      DO i=isd,ied
        jj = jsd
        utmp(i, jj) = 0.5*(u(i, jj)+u(i, jj+1))
        jj = jed
        utmp(i, jj) = 0.5*(u(i, jj)+u(i, jj+1))
      END DO
      DO j=jsd,jed
        DO i=isd+1,ied-1
          vtmp(i, j) = a2*(v(i-1, j)+v(i+2, j)) + a1*(v(i, j)+v(i+1, j))
        END DO
!i = isd
        vtmp(isd, j) = 0.5*(v(isd, j)+v(isd+1, j))
!i = ied
        vtmp(ied, j) = 0.5*(v(ied, j)+v(ied+1, j))
      END DO
      CALL PUSHREALARRAY(ua, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/&
&                   8)
      CALL PUSHREALARRAY(va, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/&
&                   8)
      DO j=jsd,jed
        DO i=isd,ied
          ua(i, j) = (utmp(i, j)-vtmp(i, j)*gridstruct%cosa_s(i, j))*&
&           gridstruct%rsin2(i, j)
          va(i, j) = (vtmp(i, j)-utmp(i, j)*gridstruct%cosa_s(i, j))*&
&           gridstruct%rsin2(i, j)
        END DO
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      IF (npt .LT. js - 1) THEN
        max1 = js - 1
      ELSE
        max1 = npt
      END IF
      IF (npy - npt .GT. je + 1) THEN
        min1 = je + 1
      ELSE
        min1 = npy - npt
      END IF
!----------
! Interior:
!----------
      DO j=max1,min1
        IF (npt .LT. isd) THEN
          max2 = isd
        ELSE
          max2 = npt
        END IF
        IF (npx - npt .GT. ied) THEN
          min2 = ied
        ELSE
          min2 = npx - npt
        END IF
        ad_from = max2
        DO i=ad_from,min2
          utmp(i, j) = a2*(u(i, j-1)+u(i, j+2)) + a1*(u(i, j)+u(i, j+1))
        END DO
        CALL PUSHINTEGER(i - 1)
        CALL PUSHINTEGER(ad_from)
      END DO
      IF (npt .LT. jsd) THEN
        max3 = jsd
      ELSE
        max3 = npt
      END IF
      IF (npy - npt .GT. jed) THEN
        min3 = jed
      ELSE
        min3 = npy - npt
      END IF
      DO j=max3,min3
        IF (npt .LT. is - 1) THEN
          max4 = is - 1
        ELSE
          max4 = npt
        END IF
        IF (npx - npt .GT. ie + 1) THEN
          min4 = ie + 1
        ELSE
          min4 = npx - npt
        END IF
        ad_from0 = max4
        DO i=ad_from0,min4
          vtmp(i, j) = a2*(v(i-1, j)+v(i+2, j)) + a1*(v(i, j)+v(i+1, j))
        END DO
        CALL PUSHINTEGER(i - 1)
        CALL PUSHINTEGER(ad_from0)
      END DO
!#ifdef EDGE_TEST
!                                                     call timing_on('COMM_TOTAL')
!  call mpp_update_domains(utmp, vtmp, domain)
!                                                     call timing_off('COMM_TOTAL')
!#else
!----------
! edges:
!----------
      IF (grid_type .LT. 3) THEN
        IF (js .EQ. 1 .OR. jsd .LT. npt) THEN
          DO j=jsd,npt-1
            DO i=isd,ied
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
        IF (je + 1 .EQ. npy .OR. jed .GE. npy - npt) THEN
          DO j=npy-npt+1,jed
            DO i=isd,ied
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
        IF (is .EQ. 1 .OR. isd .LT. npt) THEN
          IF (npt .LT. jsd) THEN
            max5 = jsd
          ELSE
            max5 = npt
          END IF
          IF (npy - npt .GT. jed) THEN
            min5 = jed
          ELSE
            min5 = npy - npt
          END IF
          DO j=max5,min5
            DO i=isd,npt-1
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
        IF (ie + 1 .EQ. npx .OR. ied .GE. npx - npt) THEN
          IF (npt .LT. jsd) THEN
            CALL PUSHCONTROL1B_FV(1)
            max6 = jsd
          ELSE
            max6 = npt
            CALL PUSHCONTROL1B_FV(0)
          END IF
          IF (npy - npt .GT. jed) THEN
            CALL PUSHCONTROL1B_FV(1)
            min6 = jed
          ELSE
            min6 = npy - npt
            CALL PUSHCONTROL1B_FV(0)
          END IF
          DO j=max6,min6
            DO i=npx-npt+1,ied
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
          CALL PUSHCONTROL2B_FV(2)
        ELSE
          CALL PUSHCONTROL2B_FV(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B_FV(0)
      END IF
      CALL PUSHREALARRAY(ua, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/&
&                   8)
      CALL PUSHREALARRAY(va, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/&
&                   8)
      CALL PUSHINTEGER(id)
      CALL PUSHINTEGER(ie)
      CALL PUSHINTEGER(is)
!#endif
      DO j=js-1-id,je+1+id
        DO i=is-1-id,ie+1+id
          ua(i, j) = (utmp(i, j)-vtmp(i, j)*gridstruct%cosa_s(i, j))*&
&           gridstruct%rsin2(i, j)
          va(i, j) = (vtmp(i, j)-utmp(i, j)*gridstruct%cosa_s(i, j))*&
&           gridstruct%rsin2(i, j)
        END DO
      END DO
      CALL PUSHCONTROL1B_FV(1)
    END IF
! A -> C
!--------------
! Fix the edges
!--------------
! Xdir:
    IF (sw_corner) THEN
      DO i=-2,0
        utmp(i, 0) = -vtmp(0, 1-i)
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
    IF (se_corner) THEN
      DO i=0,2
        utmp(npx+i, 0) = vtmp(npx, i+1)
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
    IF (ne_corner) THEN
      DO i=0,2
        utmp(npx+i, npy) = -vtmp(npx, je-i)
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
    IF (nw_corner) THEN
      DO i=-2,0
        utmp(i, npy) = vtmp(0, je+i)
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
    IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
      IF (3 .LT. is - 1) THEN
        ifirst = is - 1
      ELSE
        ifirst = 3
      END IF
      IF (npx - 2 .GT. ie + 2) THEN
        CALL PUSHCONTROL1B_FV(1)
        ilast = ie + 2
      ELSE
        CALL PUSHCONTROL1B_FV(1)
        ilast = npx - 2
      END IF
    ELSE
      CALL PUSHCONTROL1B_FV(0)
      ifirst = is - 1
      ilast = ie + 2
    END IF
!---------------------------------------------
! 4th order interpolation for interior points:
!---------------------------------------------
    DO j=js-1,je+1
      DO i=ifirst,ilast
        uc(i, j) = a1*(utmp(i-1, j)+utmp(i, j)) + a2*(utmp(i-2, j)+utmp(&
&         i+1, j))
      END DO
    END DO
    CALL PUSHREALARRAY(ut, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8)
    DO j=js-1,je+1
      DO i=ifirst,ilast
        ut(i, j) = (uc(i, j)-v(i, j)*gridstruct%cosa_u(i, j))*gridstruct&
&         %rsin_u(i, j)
      END DO
    END DO
    IF (grid_type .LT. 3) THEN
!#ifndef TEST_NEW
! Xdir:
      IF (sw_corner) THEN
        CALL PUSHREALARRAY(ua(-1, 0))
        ua(-1, 0) = -va(0, 2)
        CALL PUSHREALARRAY(ua(0, 0))
        ua(0, 0) = -va(0, 1)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (se_corner) THEN
        CALL PUSHREALARRAY(ua(npx, 0))
        ua(npx, 0) = va(npx, 1)
        CALL PUSHREALARRAY(ua(npx+1, 0))
        ua(npx+1, 0) = va(npx, 2)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (ne_corner) THEN
        CALL PUSHREALARRAY(ua(npx, npy))
        ua(npx, npy) = -va(npx, npy-1)
        CALL PUSHREALARRAY(ua(npx+1, npy))
        ua(npx+1, npy) = -va(npx, npy-2)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (nw_corner) THEN
        CALL PUSHREALARRAY(ua(-1, npy))
        ua(-1, npy) = va(0, npy-2)
        CALL PUSHREALARRAY(ua(0, npy))
        ua(0, npy) = va(0, npy-1)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
!#endif
      IF (is .EQ. 1 .AND. (.NOT.nested)) THEN
        DO j=js-1,je+1
          uc(0, j) = c1*utmp(-2, j) + c2*utmp(-1, j) + c3*utmp(0, j)
!#ifndef TEST_NEW
!ut(1,j) = 0.25*(-ua(-1,j) + 3.*(ua(0,j)+ua(1,j)) - ua(2,j))
!           uc(1,j) = 0.25*(-utmp(-1,j) + 3.*(utmp(0,j)+utmp(1,j)) - utmp(2,j))
          CALL PUSHREALARRAY(ut(1, j))
          ut(1, j) = EDGE_INTERPOLATE4_FWD(ua(-1:2, j), gridstruct%dxa(-&
&           1:2, j))
!Want to use the UPSTREAM value
!#ifdef UPSTREAM_FIXED
!           if (ut(1,j) > 0.) then
!#else
          IF (ut(1, j) .LT. 0.) THEN
!#endif
            uc(1, j) = ut(1, j)*gridstruct%sin_sg(0, j, 3)
            CALL PUSHCONTROL1B_FV(0)
          ELSE
            uc(1, j) = ut(1, j)*gridstruct%sin_sg(1, j, 1)
            CALL PUSHCONTROL1B_FV(1)
          END IF
!#else
!! 3-pt extrapolation: grid symmetry assumed --------------------------------
!           uc(1,j) = ( t14*(utmp( 0,j)+utmp(1,j))    &
!                     + t12*(utmp(-1,j)+utmp(2,j))    &
!                     + t15*(utmp(-2,j)+utmp(3,j)) )*gridstruct%rsin_u(1,j)
!           ut(1,j) =  uc(1,j) * gridstruct%rsin_u(1,j)
!! 3-pt extrapolation: grid symmetry assumed --------------------------------
!#endif
          uc(2, j) = c1*utmp(3, j) + c2*utmp(2, j) + c3*utmp(1, j)
          CALL PUSHREALARRAY(ut(0, j))
          ut(0, j) = (uc(0, j)-v(0, j)*gridstruct%cosa_u(0, j))*&
&           gridstruct%rsin_u(0, j)
          CALL PUSHREALARRAY(ut(2, j))
          ut(2, j) = (uc(2, j)-v(2, j)*gridstruct%cosa_u(2, j))*&
&           gridstruct%rsin_u(2, j)
        END DO
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (ie + 1 .EQ. npx .AND. (.NOT.nested)) THEN
        DO j=js-1,je+1
          uc(npx-1, j) = c1*utmp(npx-3, j) + c2*utmp(npx-2, j) + c3*utmp&
&           (npx-1, j)
!#ifndef TEST_NEW
          ii = npx
          CALL PUSHREALARRAY(ut(ii, j))
          ut(ii, j) = 0.25*(-ua(ii-2, j)+3.*(ua(ii-1, j)+ua(ii, j))-ua(&
&           ii+1, j))
          CALL PUSHREALARRAY(ut(ii, j))
          ut(ii, j) = EDGE_INTERPOLATE4_FWD(ua(ii-2:ii+1, j), gridstruct&
&           %dxa(ii-2:ii+1, j))
!#ifdef UPSTREAM_FIXED
!        if (ut(ii,j) > 0.) then
!#else
          IF (ut(ii, j) .LT. 0.) THEN
!#endif
            uc(ii, j) = ut(ii, j)*gridstruct%sin_sg(ii-1, j, 3)
            CALL PUSHCONTROL1B_FV(0)
          ELSE
            uc(ii, j) = ut(ii, j)*gridstruct%sin_sg(ii, j, 1)
            CALL PUSHCONTROL1B_FV(1)
          END IF
!#else
!! 3-pt extrapolation --------------------------------------------------------
!           uc(npx,j) = (t14*(utmp(npx-1,j)+utmp(npx,j))+      &
!                        t12*(utmp(npx-2,j)+utmp(npx+1,j))     &
!                      + t15*(utmp(npx-3,j)+utmp(npx+2,j)))*gridstruct%rsin_u(npx,j)
!           ut(npx,  j) =  uc(npx,j) * gridstruct%rsin_u(npx,j)
!! 3-pt extrapolation --------------------------------------------------------
!#endif
          uc(npx+1, j) = c3*utmp(npx, j) + c2*utmp(npx+1, j) + c1*utmp(&
&           npx+2, j)
          CALL PUSHREALARRAY(ut(npx-1, j))
          ut(npx-1, j) = (uc(npx-1, j)-v(npx-1, j)*gridstruct%cosa_u(npx&
&           -1, j))*gridstruct%rsin_u(npx-1, j)
          CALL PUSHREALARRAY(ut(npx+1, j))
          ut(npx+1, j) = (uc(npx+1, j)-v(npx+1, j)*gridstruct%cosa_u(npx&
&           +1, j))*gridstruct%rsin_u(npx+1, j)
        END DO
        CALL PUSHCONTROL2B_FV(0)
      ELSE
        CALL PUSHCONTROL2B_FV(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B_FV(2)
    END IF
!------
! Ydir:
!------
    IF (sw_corner) THEN
      DO j=-2,0
        vtmp(0, j) = -utmp(1-j, 0)
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
    IF (nw_corner) THEN
      DO j=0,2
        vtmp(0, npy+j) = utmp(j+1, npy)
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
    IF (se_corner) THEN
      DO j=-2,0
        vtmp(npx, j) = utmp(ie+j, 0)
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
    IF (ne_corner) THEN
      DO j=0,2
        vtmp(npx, npy+j) = -utmp(ie-j, npy)
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
!#ifndef TEST_NEW
    IF (sw_corner) THEN
      CALL PUSHREALARRAY(va(0, -1))
      va(0, -1) = -ua(2, 0)
      CALL PUSHREALARRAY(va(0, 0))
      va(0, 0) = -ua(1, 0)
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
    IF (se_corner) THEN
      CALL PUSHREALARRAY(va(npx, 0))
      va(npx, 0) = ua(npx-1, 0)
      CALL PUSHREALARRAY(va(npx, -1))
      va(npx, -1) = ua(npx-2, 0)
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
    IF (ne_corner) THEN
      CALL PUSHREALARRAY(va(npx, npy))
      va(npx, npy) = -ua(npx-1, npy)
      CALL PUSHREALARRAY(va(npx, npy+1))
      va(npx, npy+1) = -ua(npx-2, npy)
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
    IF (nw_corner) THEN
      CALL PUSHREALARRAY(va(0, npy))
      va(0, npy) = ua(1, npy)
      CALL PUSHREALARRAY(va(0, npy+1))
      va(0, npy+1) = ua(2, npy)
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
!#endif
    IF (grid_type .LT. 3) THEN
      DO j=js-1,je+2
        IF (j .EQ. 1 .AND. (.NOT.nested)) THEN
          DO i=is-1,ie+1
!#ifndef TEST_NEW
!vt(i,j) = 0.25*(-va(i,j-2) + 3.*(va(i,j-1)+va(i,j)) - va(i,j+1))
!           vc(i,j) = 0.25*(-vtmp(i,j-2) + 3.*(vtmp(i,j-1)+vtmp(i,j)) - vtmp(i,j+1))
            CALL PUSHREALARRAY(vt(i, j))
            vt(i, j) = EDGE_INTERPOLATE4_FWD(va(i, -1:2), gridstruct%dya&
&             (i, -1:2))
!#ifdef UPSTREAM_FIXED
!           if (vt(i,j) > 0.) then
!#else
            IF (vt(i, j) .LT. 0.) THEN
!#endif
              vc(i, j) = vt(i, j)*gridstruct%sin_sg(i, j-1, 4)
              CALL PUSHCONTROL1B_FV(1)
            ELSE
              vc(i, j) = vt(i, j)*gridstruct%sin_sg(i, j, 2)
              CALL PUSHCONTROL1B_FV(0)
            END IF
          END DO
          CALL PUSHCONTROL3B_FV(4)
        ELSE IF (j .EQ. 0 .OR. (j .EQ. npy - 1 .AND. (.NOT.nested))) &
&       THEN
!#else
!! 3-pt extrapolation -----------------------------------------
!           vc(i,1) = (t14*(vtmp(i, 0)+vtmp(i,1))    &
!                    + t12*(vtmp(i,-1)+vtmp(i,2))    &
!                    + t15*(vtmp(i,-2)+vtmp(i,3)))*gridstruct%rsin_v(i,1)
!           vt(i,1) = vc(i,1) * gridstruct%rsin_v(i,1)
!! 3-pt extrapolation -----------------------------------------
!#endif
          DO i=is-1,ie+1
            vc(i, j) = c1*vtmp(i, j-2) + c2*vtmp(i, j-1) + c3*vtmp(i, j)
            CALL PUSHREALARRAY(vt(i, j))
            vt(i, j) = (vc(i, j)-u(i, j)*gridstruct%cosa_v(i, j))*&
&             gridstruct%rsin_v(i, j)
          END DO
          CALL PUSHCONTROL3B_FV(3)
        ELSE IF (j .EQ. 2 .OR. (j .EQ. npy + 1 .AND. (.NOT.nested))) &
&       THEN
          DO i=is-1,ie+1
            vc(i, j) = c1*vtmp(i, j+1) + c2*vtmp(i, j) + c3*vtmp(i, j-1)
            CALL PUSHREALARRAY(vt(i, j))
            vt(i, j) = (vc(i, j)-u(i, j)*gridstruct%cosa_v(i, j))*&
&             gridstruct%rsin_v(i, j)
          END DO
          CALL PUSHCONTROL3B_FV(2)
        ELSE IF (j .EQ. npy .AND. (.NOT.nested)) THEN
          DO i=is-1,ie+1
!#ifndef TEST_NEW
!           vc(i,j) = 0.25*(-vtmp(i,j-2) + 3.*(vtmp(i,j-1)+vtmp(i,j)) - vtmp(i,j+1))
            CALL PUSHREALARRAY(vt(i, j))
            vt(i, j) = EDGE_INTERPOLATE4_FWD(va(i, j-2:j+1), gridstruct%&
&             dya(i, j-2:j+1))
!#ifdef UPSTREAM_FIXED
!           if (vt(i,j) > 0.) then
!#else
            IF (vt(i, j) .LT. 0.) THEN
!#endif
              vc(i, j) = vt(i, j)*gridstruct%sin_sg(i, j-1, 4)
              CALL PUSHCONTROL1B_FV(1)
            ELSE
              vc(i, j) = vt(i, j)*gridstruct%sin_sg(i, j, 2)
              CALL PUSHCONTROL1B_FV(0)
            END IF
          END DO
          CALL PUSHCONTROL3B_FV(1)
        ELSE
!#else
!! 3-pt extrapolation --------------------------------------------------------
!           vc(i,npy) = (t14*(vtmp(i,npy-1)+vtmp(i,npy))    &
!                      + t12*(vtmp(i,npy-2)+vtmp(i,npy+1))  &
!                      + t15*(vtmp(i,npy-3)+vtmp(i,npy+2)))*gridstruct%rsin_v(i,npy)
!           vt(i,npy) = vc(i,npy) * gridstruct%rsin_v(i,npy)
!! 3-pt extrapolation -----------------------------------------
!#endif
! 4th order interpolation for interior points:
          DO i=is-1,ie+1
            vc(i, j) = a2*(vtmp(i, j-2)+vtmp(i, j+1)) + a1*(vtmp(i, j-1)&
&             +vtmp(i, j))
            CALL PUSHREALARRAY(vt(i, j))
            vt(i, j) = (vc(i, j)-u(i, j)*gridstruct%cosa_v(i, j))*&
&             gridstruct%rsin_v(i, j)
          END DO
          CALL PUSHCONTROL3B_FV(0)
        END IF
      END DO
      CALL PUSHINTEGER(max1)
      CALL PUSHINTEGER(max3)
      CALL PUSHINTEGER(max5)
      CALL PUSHINTEGER(max6)
      CALL PUSHINTEGER(jsd)
      CALL PUSHINTEGER(ilast)
      CALL PUSHINTEGER(ied)
      CALL PUSHINTEGER(ie)
      CALL PUSHINTEGER(isd)
      CALL PUSHINTEGER(min1)
      CALL PUSHINTEGER(min3)
      CALL PUSHINTEGER(min5)
      CALL PUSHINTEGER(je)
      CALL PUSHINTEGER(min6)
      CALL PUSHINTEGER(ifirst)
      CALL PUSHINTEGER(jed)
      CALL PUSHCONTROL1B_FV(0)
    ELSE
! 4th order interpolation:
      DO j=js-1,je+2
        DO i=is-1,ie+1
          vc(i, j) = a2*(vtmp(i, j-2)+vtmp(i, j+1)) + a1*(vtmp(i, j-1)+&
&           vtmp(i, j))
        END DO
      END DO
      CALL PUSHREALARRAY(vt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/&
&                   8)
      DO j=js-1,je+2
        DO i=is-1,ie+1
          vt(i, j) = vc(i, j)
        END DO
      END DO
      CALL PUSHINTEGER(max1)
      CALL PUSHINTEGER(max3)
      CALL PUSHINTEGER(max5)
      CALL PUSHINTEGER(max6)
      CALL PUSHINTEGER(jsd)
      CALL PUSHINTEGER(ilast)
      CALL PUSHINTEGER(ied)
      CALL PUSHINTEGER(ie)
      CALL PUSHINTEGER(isd)
      CALL PUSHINTEGER(min1)
      CALL PUSHINTEGER(min3)
      CALL PUSHINTEGER(min5)
      CALL PUSHINTEGER(je)
      CALL PUSHINTEGER(min6)
      CALL PUSHINTEGER(ifirst)
      CALL PUSHINTEGER(jed)
      CALL PUSHCONTROL1B_FV(1)
    END IF
  END SUBROUTINE D2A2C_VECT_FWD
!  Differentiation of d2a2c_vect in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_
!mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe
!_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_cor
!e_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.
!rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed
!_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_en
!ergy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_map
!z_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz
! fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_sol
!ver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_c
!ore_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergen
!ce_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core
!_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core
!_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_cor
!e_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: u v ua uc ut va vc vt
!   with respect to varying inputs: u v ua uc ut va vc vt
!There is a limit to how far this routine can fill uc and vc in the
! halo, and so either mpp_update_domains or some sort of boundary
!  routine (extrapolation, outflow, interpolation from a nested grid)
!   is needed after c_sw is completed if these variables are needed
!    in the halo
  SUBROUTINE D2A2C_VECT_BWD(u, u_ad, v, v_ad, ua, ua_ad, va, va_ad, uc, &
&   uc_ad, vc, vc_ad, ut, ut_ad, vt, vt_ad, dord4, gridstruct, bd, npx, &
&   npy, nested, grid_type)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    LOGICAL, INTENT(IN) :: dord4
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: u_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc) :: v_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed) :: uc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed) :: uc_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1) :: vc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1) :: vc_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ua, va, ut, &
&   vt
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ua_ad, va_ad&
&   , ut_ad, vt_ad
    INTEGER, INTENT(IN) :: npx, npy, grid_type
    LOGICAL, INTENT(IN) :: nested
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: utmp, vtmp
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: utmp_ad, &
&   vtmp_ad
    INTEGER :: npt, i, j, ii, jj, ifirst, ilast, id
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: max5
    INTEGER :: max6
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    INTEGER :: min5
    INTEGER :: min6
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp_ad4
    REAL(fvprc) :: temp_ad5
    REAL(fvprc) :: temp_ad6
    REAL(fvprc) :: temp_ad7
    REAL(fvprc) :: temp_ad8
    REAL(fvprc) :: temp_ad9
    INTEGER :: ad_from
    INTEGER :: ad_to
    INTEGER :: ad_from0
    INTEGER :: ad_to0
    REAL(fvprc) :: temp_ad10
    REAL(fvprc) :: temp_ad11
    REAL(fvprc) :: temp_ad12
    INTEGER :: branch
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPINTEGER(jed)
      CALL POPINTEGER(ifirst)
      CALL POPINTEGER(min6)
      CALL POPINTEGER(je)
      CALL POPINTEGER(min5)
      CALL POPINTEGER(min3)
      CALL POPINTEGER(min1)
      CALL POPINTEGER(isd)
      CALL POPINTEGER(ie)
      CALL POPINTEGER(ied)
      CALL POPINTEGER(ilast)
      CALL POPINTEGER(jsd)
      CALL POPINTEGER(max6)
      CALL POPINTEGER(max5)
      CALL POPINTEGER(max3)
      CALL POPINTEGER(max1)
      vtmp_ad = 0.0_FVPRC
      DO j=je+2,js-1,-1
        CALL POPCONTROL3B_FV(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) THEN
            DO i=ie+1,is-1,-1
              CALL POPREALARRAY(vt(i, j))
              temp_ad7 = gridstruct%rsin_v(i, j)*vt_ad(i, j)
              vc_ad(i, j) = vc_ad(i, j) + temp_ad7
              u_ad(i, j) = u_ad(i, j) - gridstruct%cosa_v(i, j)*temp_ad7
              vt_ad(i, j) = 0.0_FVPRC
              vtmp_ad(i, j-2) = vtmp_ad(i, j-2) + a2*vc_ad(i, j)
              vtmp_ad(i, j+1) = vtmp_ad(i, j+1) + a2*vc_ad(i, j)
              vtmp_ad(i, j-1) = vtmp_ad(i, j-1) + a1*vc_ad(i, j)
              vtmp_ad(i, j) = vtmp_ad(i, j) + a1*vc_ad(i, j)
              vc_ad(i, j) = 0.0_FVPRC
            END DO
          ELSE
            DO i=ie+1,is-1,-1
              CALL POPCONTROL1B_FV(branch)
              IF (branch .EQ. 0) THEN
                vt_ad(i, j) = vt_ad(i, j) + gridstruct%sin_sg(i, j, 2)*&
&                 vc_ad(i, j)
                vc_ad(i, j) = 0.0_FVPRC
              ELSE
                vt_ad(i, j) = vt_ad(i, j) + gridstruct%sin_sg(i, j-1, 4)&
&                 *vc_ad(i, j)
                vc_ad(i, j) = 0.0_FVPRC
              END IF
              CALL EDGE_INTERPOLATE4_BWD(va(i, j-2:j+1), va_ad(i, j-2:j+&
&                                  1), gridstruct%dya(i, j-2:j+1), vt_ad&
&                                  (i, j))
              vt_ad(i, j) = 0.0_FVPRC
              CALL POPREALARRAY(vt(i, j))
              temp_ad6 = 0.25*vt_ad(i, j)
              va_ad(i, j-1) = va_ad(i, j-1) + 3.*temp_ad6
              va_ad(i, j) = va_ad(i, j) + 3.*temp_ad6
              va_ad(i, j-2) = va_ad(i, j-2) - temp_ad6
              va_ad(i, j+1) = va_ad(i, j+1) - temp_ad6
              vt_ad(i, j) = 0.0_FVPRC
            END DO
          END IF
        ELSE IF (branch .EQ. 2) THEN
          DO i=ie+1,is-1,-1
            CALL POPREALARRAY(vt(i, j))
            temp_ad5 = gridstruct%rsin_v(i, j)*vt_ad(i, j)
            vc_ad(i, j) = vc_ad(i, j) + temp_ad5
            u_ad(i, j) = u_ad(i, j) - gridstruct%cosa_v(i, j)*temp_ad5
            vt_ad(i, j) = 0.0_FVPRC
            vtmp_ad(i, j+1) = vtmp_ad(i, j+1) + c1*vc_ad(i, j)
            vtmp_ad(i, j) = vtmp_ad(i, j) + c2*vc_ad(i, j)
            vtmp_ad(i, j-1) = vtmp_ad(i, j-1) + c3*vc_ad(i, j)
            vc_ad(i, j) = 0.0_FVPRC
          END DO
        ELSE IF (branch .EQ. 3) THEN
          DO i=ie+1,is-1,-1
            CALL POPREALARRAY(vt(i, j))
            temp_ad4 = gridstruct%rsin_v(i, j)*vt_ad(i, j)
            vc_ad(i, j) = vc_ad(i, j) + temp_ad4
            u_ad(i, j) = u_ad(i, j) - gridstruct%cosa_v(i, j)*temp_ad4
            vt_ad(i, j) = 0.0_FVPRC
            vtmp_ad(i, j-2) = vtmp_ad(i, j-2) + c1*vc_ad(i, j)
            vtmp_ad(i, j-1) = vtmp_ad(i, j-1) + c2*vc_ad(i, j)
            vtmp_ad(i, j) = vtmp_ad(i, j) + c3*vc_ad(i, j)
            vc_ad(i, j) = 0.0_FVPRC
          END DO
        ELSE
          DO i=ie+1,is-1,-1
            CALL POPCONTROL1B_FV(branch)
            IF (branch .EQ. 0) THEN
              vt_ad(i, j) = vt_ad(i, j) + gridstruct%sin_sg(i, j, 2)*&
&               vc_ad(i, j)
              vc_ad(i, j) = 0.0_FVPRC
            ELSE
              vt_ad(i, j) = vt_ad(i, j) + gridstruct%sin_sg(i, j-1, 4)*&
&               vc_ad(i, j)
              vc_ad(i, j) = 0.0_FVPRC
            END IF
            CALL EDGE_INTERPOLATE4_BWD(va(i, -1:2), va_ad(i, -1:2), &
&                                gridstruct%dya(i, -1:2), vt_ad(i, j))
            vt_ad(i, j) = 0.0_FVPRC
            CALL POPREALARRAY(vt(i, j))
          END DO
        END IF
      END DO
    ELSE
      CALL POPINTEGER(jed)
      CALL POPINTEGER(ifirst)
      CALL POPINTEGER(min6)
      CALL POPINTEGER(je)
      CALL POPINTEGER(min5)
      CALL POPINTEGER(min3)
      CALL POPINTEGER(min1)
      CALL POPINTEGER(isd)
      CALL POPINTEGER(ie)
      CALL POPINTEGER(ied)
      CALL POPINTEGER(ilast)
      CALL POPINTEGER(jsd)
      CALL POPINTEGER(max6)
      CALL POPINTEGER(max5)
      CALL POPINTEGER(max3)
      CALL POPINTEGER(max1)
      CALL POPREALARRAY(vt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8&
&                 )
      DO j=js-1,je+2
        DO i=ie+1,is-1,-1
          vc_ad(i, j) = vc_ad(i, j) + vt_ad(i, j)
          vt_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      vtmp_ad = 0.0_FVPRC
      DO j=je+2,js-1,-1
        DO i=ie+1,is-1,-1
          vtmp_ad(i, j-2) = vtmp_ad(i, j-2) + a2*vc_ad(i, j)
          vtmp_ad(i, j+1) = vtmp_ad(i, j+1) + a2*vc_ad(i, j)
          vtmp_ad(i, j-1) = vtmp_ad(i, j-1) + a1*vc_ad(i, j)
          vtmp_ad(i, j) = vtmp_ad(i, j) + a1*vc_ad(i, j)
          vc_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(va(0, npy+1))
      ua_ad(2, npy) = ua_ad(2, npy) + va_ad(0, npy+1)
      va_ad(0, npy+1) = 0.0_FVPRC
      CALL POPREALARRAY(va(0, npy))
      ua_ad(1, npy) = ua_ad(1, npy) + va_ad(0, npy)
      va_ad(0, npy) = 0.0_FVPRC
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(va(npx, npy+1))
      ua_ad(npx-2, npy) = ua_ad(npx-2, npy) - va_ad(npx, npy+1)
      va_ad(npx, npy+1) = 0.0_FVPRC
      CALL POPREALARRAY(va(npx, npy))
      ua_ad(npx-1, npy) = ua_ad(npx-1, npy) - va_ad(npx, npy)
      va_ad(npx, npy) = 0.0_FVPRC
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(va(npx, -1))
      ua_ad(npx-2, 0) = ua_ad(npx-2, 0) + va_ad(npx, -1)
      va_ad(npx, -1) = 0.0_FVPRC
      CALL POPREALARRAY(va(npx, 0))
      ua_ad(npx-1, 0) = ua_ad(npx-1, 0) + va_ad(npx, 0)
      va_ad(npx, 0) = 0.0_FVPRC
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(va(0, 0))
      ua_ad(1, 0) = ua_ad(1, 0) - va_ad(0, 0)
      va_ad(0, 0) = 0.0_FVPRC
      CALL POPREALARRAY(va(0, -1))
      ua_ad(2, 0) = ua_ad(2, 0) - va_ad(0, -1)
      va_ad(0, -1) = 0.0_FVPRC
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      utmp_ad = 0.0_FVPRC
      DO j=2,0,-1
        utmp_ad(ie-j, npy) = utmp_ad(ie-j, npy) - vtmp_ad(npx, npy+j)
        vtmp_ad(npx, npy+j) = 0.0_FVPRC
      END DO
    ELSE
      utmp_ad = 0.0_FVPRC
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      DO j=0,-2,-1
        utmp_ad(ie+j, 0) = utmp_ad(ie+j, 0) + vtmp_ad(npx, j)
        vtmp_ad(npx, j) = 0.0_FVPRC
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      DO j=2,0,-1
        utmp_ad(j+1, npy) = utmp_ad(j+1, npy) + vtmp_ad(0, npy+j)
        vtmp_ad(0, npy+j) = 0.0_FVPRC
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      DO j=0,-2,-1
        utmp_ad(1-j, 0) = utmp_ad(1-j, 0) - vtmp_ad(0, j)
        vtmp_ad(0, j) = 0.0_FVPRC
      END DO
    END IF
    CALL POPCONTROL2B_FV(branch)
    IF (branch .EQ. 0) THEN
      DO j=je+1,js-1,-1
        CALL POPREALARRAY(ut(npx+1, j))
        temp_ad2 = gridstruct%rsin_u(npx+1, j)*ut_ad(npx+1, j)
        uc_ad(npx+1, j) = uc_ad(npx+1, j) + temp_ad2
        v_ad(npx+1, j) = v_ad(npx+1, j) - gridstruct%cosa_u(npx+1, j)*&
&         temp_ad2
        ut_ad(npx+1, j) = 0.0_FVPRC
        CALL POPREALARRAY(ut(npx-1, j))
        temp_ad3 = gridstruct%rsin_u(npx-1, j)*ut_ad(npx-1, j)
        uc_ad(npx-1, j) = uc_ad(npx-1, j) + temp_ad3
        v_ad(npx-1, j) = v_ad(npx-1, j) - gridstruct%cosa_u(npx-1, j)*&
&         temp_ad3
        ut_ad(npx-1, j) = 0.0_FVPRC
        utmp_ad(npx, j) = utmp_ad(npx, j) + c3*uc_ad(npx+1, j)
        utmp_ad(npx+1, j) = utmp_ad(npx+1, j) + c2*uc_ad(npx+1, j)
        utmp_ad(npx+2, j) = utmp_ad(npx+2, j) + c1*uc_ad(npx+1, j)
        uc_ad(npx+1, j) = 0.0_FVPRC
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          ii = npx
          ut_ad(ii, j) = ut_ad(ii, j) + gridstruct%sin_sg(ii-1, j, 3)*&
&           uc_ad(ii, j)
          uc_ad(ii, j) = 0.0_FVPRC
        ELSE
          ii = npx
          ut_ad(ii, j) = ut_ad(ii, j) + gridstruct%sin_sg(ii, j, 1)*&
&           uc_ad(ii, j)
          uc_ad(ii, j) = 0.0_FVPRC
        END IF
        CALL EDGE_INTERPOLATE4_BWD(ua(ii-2:ii+1, j), ua_ad(ii-2:ii+1, j)&
&                            , gridstruct%dxa(ii-2:ii+1, j), ut_ad(ii, j&
&                            ))
        ut_ad(ii, j) = 0.0_FVPRC
        CALL POPREALARRAY(ut(ii, j))
        CALL POPREALARRAY(ut(ii, j))
        temp_ad1 = 0.25*ut_ad(ii, j)
        ua_ad(ii-1, j) = ua_ad(ii-1, j) + 3.*temp_ad1
        ua_ad(ii, j) = ua_ad(ii, j) + 3.*temp_ad1
        ua_ad(ii-2, j) = ua_ad(ii-2, j) - temp_ad1
        ua_ad(ii+1, j) = ua_ad(ii+1, j) - temp_ad1
        ut_ad(ii, j) = 0.0_FVPRC
        utmp_ad(npx-3, j) = utmp_ad(npx-3, j) + c1*uc_ad(npx-1, j)
        utmp_ad(npx-2, j) = utmp_ad(npx-2, j) + c2*uc_ad(npx-1, j)
        utmp_ad(npx-1, j) = utmp_ad(npx-1, j) + c3*uc_ad(npx-1, j)
        uc_ad(npx-1, j) = 0.0_FVPRC
      END DO
    ELSE IF (branch .NE. 1) THEN
      GOTO 100
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      DO j=je+1,js-1,-1
        CALL POPREALARRAY(ut(2, j))
        temp_ad = gridstruct%rsin_u(2, j)*ut_ad(2, j)
        uc_ad(2, j) = uc_ad(2, j) + temp_ad
        v_ad(2, j) = v_ad(2, j) - gridstruct%cosa_u(2, j)*temp_ad
        ut_ad(2, j) = 0.0_FVPRC
        CALL POPREALARRAY(ut(0, j))
        temp_ad0 = gridstruct%rsin_u(0, j)*ut_ad(0, j)
        uc_ad(0, j) = uc_ad(0, j) + temp_ad0
        v_ad(0, j) = v_ad(0, j) - gridstruct%cosa_u(0, j)*temp_ad0
        ut_ad(0, j) = 0.0_FVPRC
        utmp_ad(3, j) = utmp_ad(3, j) + c1*uc_ad(2, j)
        utmp_ad(2, j) = utmp_ad(2, j) + c2*uc_ad(2, j)
        utmp_ad(1, j) = utmp_ad(1, j) + c3*uc_ad(2, j)
        uc_ad(2, j) = 0.0_FVPRC
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          ut_ad(1, j) = ut_ad(1, j) + gridstruct%sin_sg(0, j, 3)*uc_ad(1&
&           , j)
          uc_ad(1, j) = 0.0_FVPRC
        ELSE
          ut_ad(1, j) = ut_ad(1, j) + gridstruct%sin_sg(1, j, 1)*uc_ad(1&
&           , j)
          uc_ad(1, j) = 0.0_FVPRC
        END IF
        CALL EDGE_INTERPOLATE4_BWD(ua(-1:2, j), ua_ad(-1:2, j), &
&                            gridstruct%dxa(-1:2, j), ut_ad(1, j))
        ut_ad(1, j) = 0.0_FVPRC
        CALL POPREALARRAY(ut(1, j))
        utmp_ad(-2, j) = utmp_ad(-2, j) + c1*uc_ad(0, j)
        utmp_ad(-1, j) = utmp_ad(-1, j) + c2*uc_ad(0, j)
        utmp_ad(0, j) = utmp_ad(0, j) + c3*uc_ad(0, j)
        uc_ad(0, j) = 0.0_FVPRC
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(ua(0, npy))
      va_ad(0, npy-1) = va_ad(0, npy-1) + ua_ad(0, npy)
      ua_ad(0, npy) = 0.0_FVPRC
      CALL POPREALARRAY(ua(-1, npy))
      va_ad(0, npy-2) = va_ad(0, npy-2) + ua_ad(-1, npy)
      ua_ad(-1, npy) = 0.0_FVPRC
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(ua(npx+1, npy))
      va_ad(npx, npy-2) = va_ad(npx, npy-2) - ua_ad(npx+1, npy)
      ua_ad(npx+1, npy) = 0.0_FVPRC
      CALL POPREALARRAY(ua(npx, npy))
      va_ad(npx, npy-1) = va_ad(npx, npy-1) - ua_ad(npx, npy)
      ua_ad(npx, npy) = 0.0_FVPRC
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(ua(npx+1, 0))
      va_ad(npx, 2) = va_ad(npx, 2) + ua_ad(npx+1, 0)
      ua_ad(npx+1, 0) = 0.0_FVPRC
      CALL POPREALARRAY(ua(npx, 0))
      va_ad(npx, 1) = va_ad(npx, 1) + ua_ad(npx, 0)
      ua_ad(npx, 0) = 0.0_FVPRC
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(ua(0, 0))
      va_ad(0, 1) = va_ad(0, 1) - ua_ad(0, 0)
      ua_ad(0, 0) = 0.0_FVPRC
      CALL POPREALARRAY(ua(-1, 0))
      va_ad(0, 2) = va_ad(0, 2) - ua_ad(-1, 0)
      ua_ad(-1, 0) = 0.0_FVPRC
    END IF
 100 CALL POPREALARRAY(ut, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8)
    DO j=js-1,je+1
      DO i=ilast,ifirst,-1
        temp_ad12 = gridstruct%rsin_u(i, j)*ut_ad(i, j)
        uc_ad(i, j) = uc_ad(i, j) + temp_ad12
        v_ad(i, j) = v_ad(i, j) - gridstruct%cosa_u(i, j)*temp_ad12
        ut_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    DO j=je+1,js-1,-1
      DO i=ilast,ifirst,-1
        utmp_ad(i-1, j) = utmp_ad(i-1, j) + a1*uc_ad(i, j)
        utmp_ad(i, j) = utmp_ad(i, j) + a1*uc_ad(i, j)
        utmp_ad(i-2, j) = utmp_ad(i-2, j) + a2*uc_ad(i, j)
        utmp_ad(i+1, j) = utmp_ad(i+1, j) + a2*uc_ad(i, j)
        uc_ad(i, j) = 0.0_FVPRC
      END DO
    END DO
    CALL POPCONTROL1B_FV(branch)
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      DO i=0,-2,-1
        vtmp_ad(0, je+i) = vtmp_ad(0, je+i) + utmp_ad(i, npy)
        utmp_ad(i, npy) = 0.0_FVPRC
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      DO i=2,0,-1
        vtmp_ad(npx, je-i) = vtmp_ad(npx, je-i) - utmp_ad(npx+i, npy)
        utmp_ad(npx+i, npy) = 0.0_FVPRC
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      DO i=2,0,-1
        vtmp_ad(npx, i+1) = vtmp_ad(npx, i+1) + utmp_ad(npx+i, 0)
        utmp_ad(npx+i, 0) = 0.0_FVPRC
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      DO i=0,-2,-1
        vtmp_ad(0, 1-i) = vtmp_ad(0, 1-i) - utmp_ad(i, 0)
        utmp_ad(i, 0) = 0.0_FVPRC
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(va, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8&
&                 )
      CALL POPREALARRAY(ua, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8&
&                 )
      DO j=jsd,jed
        DO i=ied,isd,-1
          temp_ad9 = gridstruct%rsin2(i, j)*ua_ad(i, j)
          temp_ad8 = gridstruct%rsin2(i, j)*va_ad(i, j)
          vtmp_ad(i, j) = vtmp_ad(i, j) + temp_ad8 - gridstruct%cosa_s(i&
&           , j)*temp_ad9
          utmp_ad(i, j) = utmp_ad(i, j) + temp_ad9 - gridstruct%cosa_s(i&
&           , j)*temp_ad8
          va_ad(i, j) = 0.0_FVPRC
          ua_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      DO j=jed,jsd,-1
        v_ad(ied, j) = v_ad(ied, j) + 0.5*vtmp_ad(ied, j)
        v_ad(ied+1, j) = v_ad(ied+1, j) + 0.5*vtmp_ad(ied, j)
        vtmp_ad(ied, j) = 0.0_FVPRC
        v_ad(isd, j) = v_ad(isd, j) + 0.5*vtmp_ad(isd, j)
        v_ad(isd+1, j) = v_ad(isd+1, j) + 0.5*vtmp_ad(isd, j)
        vtmp_ad(isd, j) = 0.0_FVPRC
        DO i=ied-1,isd+1,-1
          v_ad(i-1, j) = v_ad(i-1, j) + a2*vtmp_ad(i, j)
          v_ad(i+2, j) = v_ad(i+2, j) + a2*vtmp_ad(i, j)
          v_ad(i, j) = v_ad(i, j) + a1*vtmp_ad(i, j)
          v_ad(i+1, j) = v_ad(i+1, j) + a1*vtmp_ad(i, j)
          vtmp_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      DO i=ied,isd,-1
        jj = jed
        u_ad(i, jj) = u_ad(i, jj) + 0.5*utmp_ad(i, jj)
        u_ad(i, jj+1) = u_ad(i, jj+1) + 0.5*utmp_ad(i, jj)
        utmp_ad(i, jj) = 0.0_FVPRC
        jj = jsd
        u_ad(i, jj) = u_ad(i, jj) + 0.5*utmp_ad(i, jj)
        u_ad(i, jj+1) = u_ad(i, jj+1) + 0.5*utmp_ad(i, jj)
        utmp_ad(i, jj) = 0.0_FVPRC
      END DO
      DO j=jed-1,jsd+1,-1
        DO i=ied,isd,-1
          u_ad(i, j-1) = u_ad(i, j-1) + a2*utmp_ad(i, j)
          u_ad(i, j+2) = u_ad(i, j+2) + a2*utmp_ad(i, j)
          u_ad(i, j) = u_ad(i, j) + a1*utmp_ad(i, j)
          u_ad(i, j+1) = u_ad(i, j+1) + a1*utmp_ad(i, j)
          utmp_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
    ELSE
      CALL POPINTEGER(is)
      CALL POPINTEGER(ie)
      CALL POPINTEGER(id)
      CALL POPREALARRAY(va, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8&
&                 )
      CALL POPREALARRAY(ua, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8&
&                 )
      DO j=js-1-id,je+1+id
        DO i=ie+id+1,is-1-id,-1
          temp_ad11 = gridstruct%rsin2(i, j)*ua_ad(i, j)
          temp_ad10 = gridstruct%rsin2(i, j)*va_ad(i, j)
          vtmp_ad(i, j) = vtmp_ad(i, j) + temp_ad10 - gridstruct%cosa_s(&
&           i, j)*temp_ad11
          utmp_ad(i, j) = utmp_ad(i, j) + temp_ad11 - gridstruct%cosa_s(&
&           i, j)*temp_ad10
          va_ad(i, j) = 0.0_FVPRC
          ua_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      CALL POPCONTROL2B_FV(branch)
      IF (branch .NE. 0) THEN
        IF (branch .NE. 1) THEN
          DO j=min6,max6,-1
            DO i=ied,npx-npt+1,-1
              v_ad(i, j) = v_ad(i, j) + 0.5*vtmp_ad(i, j)
              v_ad(i+1, j) = v_ad(i+1, j) + 0.5*vtmp_ad(i, j)
              vtmp_ad(i, j) = 0.0_FVPRC
              u_ad(i, j) = u_ad(i, j) + 0.5*utmp_ad(i, j)
              u_ad(i, j+1) = u_ad(i, j+1) + 0.5*utmp_ad(i, j)
              utmp_ad(i, j) = 0.0_FVPRC
            END DO
          END DO
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) jed = bd%jed
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) jsd = bd%jsd
        END IF
        isd = bd%isd
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          DO j=min5,max5,-1
            DO i=npt-1,isd,-1
              v_ad(i, j) = v_ad(i, j) + 0.5*vtmp_ad(i, j)
              v_ad(i+1, j) = v_ad(i+1, j) + 0.5*vtmp_ad(i, j)
              vtmp_ad(i, j) = 0.0_FVPRC
              u_ad(i, j) = u_ad(i, j) + 0.5*utmp_ad(i, j)
              u_ad(i, j+1) = u_ad(i, j+1) + 0.5*utmp_ad(i, j)
              utmp_ad(i, j) = 0.0_FVPRC
            END DO
          END DO
        END IF
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          DO j=jed,npy-npt+1,-1
            DO i=ied,isd,-1
              v_ad(i, j) = v_ad(i, j) + 0.5*vtmp_ad(i, j)
              v_ad(i+1, j) = v_ad(i+1, j) + 0.5*vtmp_ad(i, j)
              vtmp_ad(i, j) = 0.0_FVPRC
              u_ad(i, j) = u_ad(i, j) + 0.5*utmp_ad(i, j)
              u_ad(i, j+1) = u_ad(i, j+1) + 0.5*utmp_ad(i, j)
              utmp_ad(i, j) = 0.0_FVPRC
            END DO
          END DO
        END IF
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          DO j=npt-1,jsd,-1
            DO i=ied,isd,-1
              v_ad(i, j) = v_ad(i, j) + 0.5*vtmp_ad(i, j)
              v_ad(i+1, j) = v_ad(i+1, j) + 0.5*vtmp_ad(i, j)
              vtmp_ad(i, j) = 0.0_FVPRC
              u_ad(i, j) = u_ad(i, j) + 0.5*utmp_ad(i, j)
              u_ad(i, j+1) = u_ad(i, j+1) + 0.5*utmp_ad(i, j)
              utmp_ad(i, j) = 0.0_FVPRC
            END DO
          END DO
        END IF
      END IF
      DO j=min3,max3,-1
        CALL POPINTEGER(ad_from0)
        CALL POPINTEGER(ad_to0)
        DO i=ad_to0,ad_from0,-1
          v_ad(i-1, j) = v_ad(i-1, j) + a2*vtmp_ad(i, j)
          v_ad(i+2, j) = v_ad(i+2, j) + a2*vtmp_ad(i, j)
          v_ad(i, j) = v_ad(i, j) + a1*vtmp_ad(i, j)
          v_ad(i+1, j) = v_ad(i+1, j) + a1*vtmp_ad(i, j)
          vtmp_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      DO j=min1,max1,-1
        CALL POPINTEGER(ad_from)
        CALL POPINTEGER(ad_to)
        DO i=ad_to,ad_from,-1
          u_ad(i, j-1) = u_ad(i, j-1) + a2*utmp_ad(i, j)
          u_ad(i, j+2) = u_ad(i, j+2) + a2*utmp_ad(i, j)
          u_ad(i, j) = u_ad(i, j) + a1*utmp_ad(i, j)
          u_ad(i, j+1) = u_ad(i, j+1) + a1*utmp_ad(i, j)
          utmp_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
    END IF
  END SUBROUTINE D2A2C_VECT_BWD
!There is a limit to how far this routine can fill uc and vc in the
! halo, and so either mpp_update_domains or some sort of boundary
!  routine (extrapolation, outflow, interpolation from a nested grid)
!   is needed after c_sw is completed if these variables are needed
!    in the halo
  SUBROUTINE D2A2C_VECT(u, v, ua, va, uc, vc, ut, vt, dord4, gridstruct&
&   , bd, npx, npy, nested, grid_type)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    LOGICAL, INTENT(IN) :: dord4
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed), INTENT(OUT) &
&   :: uc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1), INTENT(OUT) &
&   :: vc
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed), INTENT(OUT) ::&
&   ua, va, ut, vt
    INTEGER, INTENT(IN) :: npx, npy, grid_type
    LOGICAL, INTENT(IN) :: nested
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
! Local 
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: utmp, vtmp
    INTEGER :: npt, i, j, ii, jj, ifirst, ilast, id
!  real(FVPRC), pointer, dimension(:,:,:) :: sin_sg
!  real(FVPRC), pointer, dimension(:,:)   :: cosa_u, cosa_v, cosa_s
!  real(FVPRC), pointer, dimension(:,:)   :: rsin_u, rsin_v, rsin2
!  real(FVPRC), pointer, dimension(:,:)   ::  dxa,dya
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: max5
    INTEGER :: max6
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    INTEGER :: min5
    INTEGER :: min6
    sw_corner = gridstruct%sw_corner
    se_corner = gridstruct%se_corner
    nw_corner = gridstruct%nw_corner
    ne_corner = gridstruct%ne_corner
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
!      sin_sg    => gridstruct%sin_sg  
!      cosa_u    => gridstruct%cosa_u  
!      cosa_v    => gridstruct%cosa_v  
!      cosa_s    => gridstruct%cosa_s  
!      rsin_u    => gridstruct%rsin_u  
!      rsin_v    => gridstruct%rsin_v  
!      rsin2     => gridstruct%rsin2   
!      dxa       => gridstruct%dxa     
!      dya       => gridstruct%dya     
    IF (dord4) THEN
      id = 1
    ELSE
      id = 0
    END IF
    IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
      npt = 4
    ELSE
      npt = -2
    END IF
! Initialize the non-existing corner regions
    utmp = big_number
    vtmp = big_number
    IF (nested) THEN
      DO j=jsd+1,jed-1
        DO i=isd,ied
          utmp(i, j) = a2*(u(i, j-1)+u(i, j+2)) + a1*(u(i, j)+u(i, j+1))
        END DO
      END DO
      DO i=isd,ied
        jj = jsd
        utmp(i, jj) = 0.5*(u(i, jj)+u(i, jj+1))
        jj = jed
        utmp(i, jj) = 0.5*(u(i, jj)+u(i, jj+1))
      END DO
      DO j=jsd,jed
        DO i=isd+1,ied-1
          vtmp(i, j) = a2*(v(i-1, j)+v(i+2, j)) + a1*(v(i, j)+v(i+1, j))
        END DO
!i = isd
        vtmp(isd, j) = 0.5*(v(isd, j)+v(isd+1, j))
!i = ied
        vtmp(ied, j) = 0.5*(v(ied, j)+v(ied+1, j))
      END DO
      DO j=jsd,jed
        DO i=isd,ied
          ua(i, j) = (utmp(i, j)-vtmp(i, j)*gridstruct%cosa_s(i, j))*&
&           gridstruct%rsin2(i, j)
          va(i, j) = (vtmp(i, j)-utmp(i, j)*gridstruct%cosa_s(i, j))*&
&           gridstruct%rsin2(i, j)
        END DO
      END DO
    ELSE
      IF (npt .LT. js - 1) THEN
        max1 = js - 1
      ELSE
        max1 = npt
      END IF
      IF (npy - npt .GT. je + 1) THEN
        min1 = je + 1
      ELSE
        min1 = npy - npt
      END IF
!----------
! Interior:
!----------
      DO j=max1,min1
        IF (npt .LT. isd) THEN
          max2 = isd
        ELSE
          max2 = npt
        END IF
        IF (npx - npt .GT. ied) THEN
          min2 = ied
        ELSE
          min2 = npx - npt
        END IF
        DO i=max2,min2
          utmp(i, j) = a2*(u(i, j-1)+u(i, j+2)) + a1*(u(i, j)+u(i, j+1))
        END DO
      END DO
      IF (npt .LT. jsd) THEN
        max3 = jsd
      ELSE
        max3 = npt
      END IF
      IF (npy - npt .GT. jed) THEN
        min3 = jed
      ELSE
        min3 = npy - npt
      END IF
      DO j=max3,min3
        IF (npt .LT. is - 1) THEN
          max4 = is - 1
        ELSE
          max4 = npt
        END IF
        IF (npx - npt .GT. ie + 1) THEN
          min4 = ie + 1
        ELSE
          min4 = npx - npt
        END IF
        DO i=max4,min4
          vtmp(i, j) = a2*(v(i-1, j)+v(i+2, j)) + a1*(v(i, j)+v(i+1, j))
        END DO
      END DO
!#ifdef EDGE_TEST
!                                                     call timing_on('COMM_TOTAL')
!  call mpp_update_domains(utmp, vtmp, domain)
!                                                     call timing_off('COMM_TOTAL')
!#else
!----------
! edges:
!----------
      IF (grid_type .LT. 3) THEN
        IF (js .EQ. 1 .OR. jsd .LT. npt) THEN
          DO j=jsd,npt-1
            DO i=isd,ied
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
        END IF
        IF (je + 1 .EQ. npy .OR. jed .GE. npy - npt) THEN
          DO j=npy-npt+1,jed
            DO i=isd,ied
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
        END IF
        IF (is .EQ. 1 .OR. isd .LT. npt) THEN
          IF (npt .LT. jsd) THEN
            max5 = jsd
          ELSE
            max5 = npt
          END IF
          IF (npy - npt .GT. jed) THEN
            min5 = jed
          ELSE
            min5 = npy - npt
          END IF
          DO j=max5,min5
            DO i=isd,npt-1
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
        END IF
        IF (ie + 1 .EQ. npx .OR. ied .GE. npx - npt) THEN
          IF (npt .LT. jsd) THEN
            max6 = jsd
          ELSE
            max6 = npt
          END IF
          IF (npy - npt .GT. jed) THEN
            min6 = jed
          ELSE
            min6 = npy - npt
          END IF
          DO j=max6,min6
            DO i=npx-npt+1,ied
              utmp(i, j) = 0.5*(u(i, j)+u(i, j+1))
              vtmp(i, j) = 0.5*(v(i, j)+v(i+1, j))
            END DO
          END DO
        END IF
      END IF
!#endif
      DO j=js-1-id,je+1+id
        DO i=is-1-id,ie+1+id
          ua(i, j) = (utmp(i, j)-vtmp(i, j)*gridstruct%cosa_s(i, j))*&
&           gridstruct%rsin2(i, j)
          va(i, j) = (vtmp(i, j)-utmp(i, j)*gridstruct%cosa_s(i, j))*&
&           gridstruct%rsin2(i, j)
        END DO
      END DO
    END IF
! A -> C
!--------------
! Fix the edges
!--------------
! Xdir:
    IF (sw_corner) THEN
      DO i=-2,0
        utmp(i, 0) = -vtmp(0, 1-i)
      END DO
    END IF
    IF (se_corner) THEN
      DO i=0,2
        utmp(npx+i, 0) = vtmp(npx, i+1)
      END DO
    END IF
    IF (ne_corner) THEN
      DO i=0,2
        utmp(npx+i, npy) = -vtmp(npx, je-i)
      END DO
    END IF
    IF (nw_corner) THEN
      DO i=-2,0
        utmp(i, npy) = vtmp(0, je+i)
      END DO
    END IF
    IF (grid_type .LT. 3 .AND. (.NOT.nested)) THEN
      IF (3 .LT. is - 1) THEN
        ifirst = is - 1
      ELSE
        ifirst = 3
      END IF
      IF (npx - 2 .GT. ie + 2) THEN
        ilast = ie + 2
      ELSE
        ilast = npx - 2
      END IF
    ELSE
      ifirst = is - 1
      ilast = ie + 2
    END IF
!---------------------------------------------
! 4th order interpolation for interior points:
!---------------------------------------------
    DO j=js-1,je+1
      DO i=ifirst,ilast
        uc(i, j) = a1*(utmp(i-1, j)+utmp(i, j)) + a2*(utmp(i-2, j)+utmp(&
&         i+1, j))
      END DO
    END DO
    DO j=js-1,je+1
      DO i=ifirst,ilast
        ut(i, j) = (uc(i, j)-v(i, j)*gridstruct%cosa_u(i, j))*gridstruct&
&         %rsin_u(i, j)
      END DO
    END DO
    IF (grid_type .LT. 3) THEN
!#ifndef TEST_NEW
! Xdir:
      IF (sw_corner) THEN
        ua(-1, 0) = -va(0, 2)
        ua(0, 0) = -va(0, 1)
      END IF
      IF (se_corner) THEN
        ua(npx, 0) = va(npx, 1)
        ua(npx+1, 0) = va(npx, 2)
      END IF
      IF (ne_corner) THEN
        ua(npx, npy) = -va(npx, npy-1)
        ua(npx+1, npy) = -va(npx, npy-2)
      END IF
      IF (nw_corner) THEN
        ua(-1, npy) = va(0, npy-2)
        ua(0, npy) = va(0, npy-1)
      END IF
!#endif
      IF (is .EQ. 1 .AND. (.NOT.nested)) THEN
        DO j=js-1,je+1
          uc(0, j) = c1*utmp(-2, j) + c2*utmp(-1, j) + c3*utmp(0, j)
!#ifndef TEST_NEW
!ut(1,j) = 0.25*(-ua(-1,j) + 3.*(ua(0,j)+ua(1,j)) - ua(2,j))
!           uc(1,j) = 0.25*(-utmp(-1,j) + 3.*(utmp(0,j)+utmp(1,j)) - utmp(2,j))
          ut(1, j) = EDGE_INTERPOLATE4(ua(-1:2, j), gridstruct%dxa(-1:2&
&           , j))
!Want to use the UPSTREAM value
!#ifdef UPSTREAM_FIXED
!           if (ut(1,j) > 0.) then
!#else
          IF (ut(1, j) .LT. 0.) THEN
!#endif
            uc(1, j) = ut(1, j)*gridstruct%sin_sg(0, j, 3)
          ELSE
            uc(1, j) = ut(1, j)*gridstruct%sin_sg(1, j, 1)
          END IF
!#else
!! 3-pt extrapolation: grid symmetry assumed --------------------------------
!           uc(1,j) = ( t14*(utmp( 0,j)+utmp(1,j))    &
!                     + t12*(utmp(-1,j)+utmp(2,j))    &
!                     + t15*(utmp(-2,j)+utmp(3,j)) )*gridstruct%rsin_u(1,j)
!           ut(1,j) =  uc(1,j) * gridstruct%rsin_u(1,j)
!! 3-pt extrapolation: grid symmetry assumed --------------------------------
!#endif
          uc(2, j) = c1*utmp(3, j) + c2*utmp(2, j) + c3*utmp(1, j)
          ut(0, j) = (uc(0, j)-v(0, j)*gridstruct%cosa_u(0, j))*&
&           gridstruct%rsin_u(0, j)
          ut(2, j) = (uc(2, j)-v(2, j)*gridstruct%cosa_u(2, j))*&
&           gridstruct%rsin_u(2, j)
        END DO
      END IF
      IF (ie + 1 .EQ. npx .AND. (.NOT.nested)) THEN
        DO j=js-1,je+1
          uc(npx-1, j) = c1*utmp(npx-3, j) + c2*utmp(npx-2, j) + c3*utmp&
&           (npx-1, j)
!#ifndef TEST_NEW
          ii = npx
          ut(ii, j) = 0.25*(-ua(ii-2, j)+3.*(ua(ii-1, j)+ua(ii, j))-ua(&
&           ii+1, j))
          ut(ii, j) = EDGE_INTERPOLATE4(ua(ii-2:ii+1, j), gridstruct%dxa&
&           (ii-2:ii+1, j))
!#ifdef UPSTREAM_FIXED
!        if (ut(ii,j) > 0.) then
!#else
          IF (ut(ii, j) .LT. 0.) THEN
!#endif
            uc(ii, j) = ut(ii, j)*gridstruct%sin_sg(ii-1, j, 3)
          ELSE
            uc(ii, j) = ut(ii, j)*gridstruct%sin_sg(ii, j, 1)
          END IF
!#else
!! 3-pt extrapolation --------------------------------------------------------
!           uc(npx,j) = (t14*(utmp(npx-1,j)+utmp(npx,j))+      &
!                        t12*(utmp(npx-2,j)+utmp(npx+1,j))     &
!                      + t15*(utmp(npx-3,j)+utmp(npx+2,j)))*gridstruct%rsin_u(npx,j)
!           ut(npx,  j) =  uc(npx,j) * gridstruct%rsin_u(npx,j)
!! 3-pt extrapolation --------------------------------------------------------
!#endif
          uc(npx+1, j) = c3*utmp(npx, j) + c2*utmp(npx+1, j) + c1*utmp(&
&           npx+2, j)
          ut(npx-1, j) = (uc(npx-1, j)-v(npx-1, j)*gridstruct%cosa_u(npx&
&           -1, j))*gridstruct%rsin_u(npx-1, j)
          ut(npx+1, j) = (uc(npx+1, j)-v(npx+1, j)*gridstruct%cosa_u(npx&
&           +1, j))*gridstruct%rsin_u(npx+1, j)
        END DO
      END IF
    END IF
!------
! Ydir:
!------
    IF (sw_corner) THEN
      DO j=-2,0
        vtmp(0, j) = -utmp(1-j, 0)
      END DO
    END IF
    IF (nw_corner) THEN
      DO j=0,2
        vtmp(0, npy+j) = utmp(j+1, npy)
      END DO
    END IF
    IF (se_corner) THEN
      DO j=-2,0
        vtmp(npx, j) = utmp(ie+j, 0)
      END DO
    END IF
    IF (ne_corner) THEN
      DO j=0,2
        vtmp(npx, npy+j) = -utmp(ie-j, npy)
      END DO
    END IF
!#ifndef TEST_NEW
    IF (sw_corner) THEN
      va(0, -1) = -ua(2, 0)
      va(0, 0) = -ua(1, 0)
    END IF
    IF (se_corner) THEN
      va(npx, 0) = ua(npx-1, 0)
      va(npx, -1) = ua(npx-2, 0)
    END IF
    IF (ne_corner) THEN
      va(npx, npy) = -ua(npx-1, npy)
      va(npx, npy+1) = -ua(npx-2, npy)
    END IF
    IF (nw_corner) THEN
      va(0, npy) = ua(1, npy)
      va(0, npy+1) = ua(2, npy)
    END IF
!#endif
    IF (grid_type .LT. 3) THEN
      DO j=js-1,je+2
        IF (j .EQ. 1 .AND. (.NOT.nested)) THEN
          DO i=is-1,ie+1
!#ifndef TEST_NEW
!vt(i,j) = 0.25*(-va(i,j-2) + 3.*(va(i,j-1)+va(i,j)) - va(i,j+1))
!           vc(i,j) = 0.25*(-vtmp(i,j-2) + 3.*(vtmp(i,j-1)+vtmp(i,j)) - vtmp(i,j+1))
            vt(i, j) = EDGE_INTERPOLATE4(va(i, -1:2), gridstruct%dya(i, &
&             -1:2))
!#ifdef UPSTREAM_FIXED
!           if (vt(i,j) > 0.) then
!#else
            IF (vt(i, j) .LT. 0.) THEN
!#endif
              vc(i, j) = vt(i, j)*gridstruct%sin_sg(i, j-1, 4)
            ELSE
              vc(i, j) = vt(i, j)*gridstruct%sin_sg(i, j, 2)
            END IF
          END DO
        ELSE IF (j .EQ. 0 .OR. (j .EQ. npy - 1 .AND. (.NOT.nested))) &
&       THEN
!#else
!! 3-pt extrapolation -----------------------------------------
!           vc(i,1) = (t14*(vtmp(i, 0)+vtmp(i,1))    &
!                    + t12*(vtmp(i,-1)+vtmp(i,2))    &
!                    + t15*(vtmp(i,-2)+vtmp(i,3)))*gridstruct%rsin_v(i,1)
!           vt(i,1) = vc(i,1) * gridstruct%rsin_v(i,1)
!! 3-pt extrapolation -----------------------------------------
!#endif
          DO i=is-1,ie+1
            vc(i, j) = c1*vtmp(i, j-2) + c2*vtmp(i, j-1) + c3*vtmp(i, j)
            vt(i, j) = (vc(i, j)-u(i, j)*gridstruct%cosa_v(i, j))*&
&             gridstruct%rsin_v(i, j)
          END DO
        ELSE IF (j .EQ. 2 .OR. (j .EQ. npy + 1 .AND. (.NOT.nested))) &
&       THEN
          DO i=is-1,ie+1
            vc(i, j) = c1*vtmp(i, j+1) + c2*vtmp(i, j) + c3*vtmp(i, j-1)
            vt(i, j) = (vc(i, j)-u(i, j)*gridstruct%cosa_v(i, j))*&
&             gridstruct%rsin_v(i, j)
          END DO
        ELSE IF (j .EQ. npy .AND. (.NOT.nested)) THEN
          DO i=is-1,ie+1
!#ifndef TEST_NEW
            vt(i, j) = 0.25*(-va(i, j-2)+3.*(va(i, j-1)+va(i, j))-va(i, &
&             j+1))
!           vc(i,j) = 0.25*(-vtmp(i,j-2) + 3.*(vtmp(i,j-1)+vtmp(i,j)) - vtmp(i,j+1))
            vt(i, j) = EDGE_INTERPOLATE4(va(i, j-2:j+1), gridstruct%dya(&
&             i, j-2:j+1))
!#ifdef UPSTREAM_FIXED
!           if (vt(i,j) > 0.) then
!#else
            IF (vt(i, j) .LT. 0.) THEN
!#endif
              vc(i, j) = vt(i, j)*gridstruct%sin_sg(i, j-1, 4)
            ELSE
              vc(i, j) = vt(i, j)*gridstruct%sin_sg(i, j, 2)
            END IF
          END DO
        ELSE
!#else
!! 3-pt extrapolation --------------------------------------------------------
!           vc(i,npy) = (t14*(vtmp(i,npy-1)+vtmp(i,npy))    &
!                      + t12*(vtmp(i,npy-2)+vtmp(i,npy+1))  &
!                      + t15*(vtmp(i,npy-3)+vtmp(i,npy+2)))*gridstruct%rsin_v(i,npy)
!           vt(i,npy) = vc(i,npy) * gridstruct%rsin_v(i,npy)
!! 3-pt extrapolation -----------------------------------------
!#endif
! 4th order interpolation for interior points:
          DO i=is-1,ie+1
            vc(i, j) = a2*(vtmp(i, j-2)+vtmp(i, j+1)) + a1*(vtmp(i, j-1)&
&             +vtmp(i, j))
            vt(i, j) = (vc(i, j)-u(i, j)*gridstruct%cosa_v(i, j))*&
&             gridstruct%rsin_v(i, j)
          END DO
        END IF
      END DO
    ELSE
! 4th order interpolation:
      DO j=js-1,je+2
        DO i=is-1,ie+1
          vc(i, j) = a2*(vtmp(i, j-2)+vtmp(i, j+1)) + a1*(vtmp(i, j-1)+&
&           vtmp(i, j))
        END DO
      END DO
      DO j=js-1,je+2
        DO i=is-1,ie+1
          vt(i, j) = vc(i, j)
        END DO
      END DO
    END IF
  END SUBROUTINE D2A2C_VECT
!  Differentiation of edge_interpolate4 in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b
!_edge_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_
!mod.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p d
!yn_core_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamic
!s_mod.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod
!.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_to
!tal_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer 
!fv_mapz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.
!steepz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.ri
!em_solver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solve
!r nh_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.di
!vergence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners s
!w_core_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d t
!p_core_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm 
!tp_core_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: ua edge_interpolate4
!   with respect to varying inputs: ua
  REAL(fvprc) FUNCTION EDGE_INTERPOLATE4_FWD(ua, dxa)
    IMPLICIT NONE
!This is the original edge-interpolation code, which makes
! a relatively small increase in the error in unstretched case 2.
!   edge_interpolate4 = 0.25*( 3*(ua(2)+ua(3)) - (ua(1)+ua(4))  )
    REAL(fvprc), INTENT(IN) :: ua(4)
    REAL(fvprc), INTENT(IN) :: dxa(4)
    REAL(fvprc) :: u0l, u0r
    REAL(fvprc) :: edge_interpolate4
    u0l = 0.5*((2.*dxa(2)+dxa(1))*ua(2)-dxa(2)*ua(1))/(dxa(1)+dxa(2))
    u0r = 0.5*((2.*dxa(3)+dxa(4))*ua(3)-dxa(3)*ua(4))/(dxa(3)+dxa(4))
    edge_interpolate4 = u0l + u0r
    edge_interpolate4_fwd = edge_interpolate4
  END FUNCTION EDGE_INTERPOLATE4_FWD
!  Differentiation of edge_interpolate4 in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2
!b_edge_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core
!_mod.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p 
!dyn_core_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynami
!cs_mod.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mo
!d.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_t
!otal_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer
! fv_mapz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod
!.steepz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.r
!iem_solver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solv
!er nh_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.d
!ivergence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners 
!sw_core_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d 
!tp_core_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm
! tp_core_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: ua edge_interpolate4
!   with respect to varying inputs: ua
  SUBROUTINE EDGE_INTERPOLATE4_BWD(ua, ua_ad, dxa, edge_interpolate4_ad)
    IMPLICIT NONE
!This is the original edge-interpolation code, which makes
! a relatively small increase in the error in unstretched case 2.
!   edge_interpolate4 = 0.25*( 3*(ua(2)+ua(3)) - (ua(1)+ua(4))  )
    REAL(fvprc), INTENT(IN) :: ua(4)
    REAL(fvprc) :: ua_ad(4)
    REAL(fvprc), INTENT(IN) :: dxa(4)
    REAL(fvprc) :: u0l, u0r
    REAL(fvprc) :: u0l_ad, u0r_ad
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: edge_interpolate4_ad
    REAL(fvprc) :: edge_interpolate4
    u0l_ad = edge_interpolate4_ad
    u0r_ad = edge_interpolate4_ad
    temp_ad = 0.5*u0r_ad/(dxa(3)+dxa(4))
    ua_ad(3) = ua_ad(3) + (dxa(3)*2.+dxa(4))*temp_ad
    ua_ad(4) = ua_ad(4) - dxa(3)*temp_ad
    temp_ad0 = 0.5*u0l_ad/(dxa(1)+dxa(2))
    ua_ad(2) = ua_ad(2) + (dxa(2)*2.+dxa(1))*temp_ad0
    ua_ad(1) = ua_ad(1) - dxa(2)*temp_ad0
  END SUBROUTINE EDGE_INTERPOLATE4_BWD
  REAL(fvprc) FUNCTION EDGE_INTERPOLATE4(ua, dxa)
    IMPLICIT NONE
!This is the original edge-interpolation code, which makes
! a relatively small increase in the error in unstretched case 2.
!   edge_interpolate4 = 0.25*( 3*(ua(2)+ua(3)) - (ua(1)+ua(4))  )
    REAL(fvprc), INTENT(IN) :: ua(4)
    REAL(fvprc), INTENT(IN) :: dxa(4)
    REAL(fvprc) :: u0l, u0r
    u0l = 0.5*((2.*dxa(2)+dxa(1))*ua(2)-dxa(2)*ua(1))/(dxa(1)+dxa(2))
    u0r = 0.5*((2.*dxa(3)+dxa(4))*ua(3)-dxa(3)*ua(4))/(dxa(3)+dxa(4))
    edge_interpolate4 = u0l + u0r
  END FUNCTION EDGE_INTERPOLATE4
!Subroutines d2a2c and d2a2c_vect_v? have been deleted. Look at older code versions if you are interested.
  SUBROUTINE FILL3_4CORNERS(q1, q2, q3, dir, bd, npx, npy, sw_corner, &
&   se_corner, ne_corner, nw_corner)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! This routine fill the 4 corners of the scalar fileds only as needed by c_core
! 1: x-dir; 2: y-dir
    INTEGER, INTENT(IN) :: dir
    REAL(fvprc), INTENT(INOUT) :: q1(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: q2(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: q3(bd%isd:bd%ied, bd%jsd:bd%jed)
    LOGICAL, INTENT(IN) :: sw_corner, se_corner, ne_corner, nw_corner
    INTEGER, INTENT(IN) :: npx, npy
    INTEGER :: i, j
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    SELECT CASE  (dir) 
    CASE (1) 
      IF (sw_corner) THEN
        q1(-1, 0) = q1(0, 2)
        q1(0, 0) = q1(0, 1)
        q1(0, -1) = q1(-1, 1)
        q2(-1, 0) = q2(0, 2)
        q2(0, 0) = q2(0, 1)
        q2(0, -1) = q2(-1, 1)
        q3(-1, 0) = q3(0, 2)
        q3(0, 0) = q3(0, 1)
        q3(0, -1) = q3(-1, 1)
      END IF
      IF (se_corner) THEN
        q1(npx+1, 0) = q1(npx, 2)
        q1(npx, 0) = q1(npx, 1)
        q1(npx, -1) = q1(npx+1, 1)
        q2(npx+1, 0) = q2(npx, 2)
        q2(npx, 0) = q2(npx, 1)
        q2(npx, -1) = q2(npx+1, 1)
        q3(npx+1, 0) = q3(npx, 2)
        q3(npx, 0) = q3(npx, 1)
        q3(npx, -1) = q3(npx+1, 1)
      END IF
      IF (ne_corner) THEN
        q1(npx, npy) = q1(npx, npy-1)
        q1(npx+1, npy) = q1(npx, npy-2)
        q1(npx, npy+1) = q1(npx+1, npy-1)
        q2(npx, npy) = q2(npx, npy-1)
        q2(npx+1, npy) = q2(npx, npy-2)
        q2(npx, npy+1) = q2(npx+1, npy-1)
        q3(npx, npy) = q3(npx, npy-1)
        q3(npx+1, npy) = q3(npx, npy-2)
        q3(npx, npy+1) = q3(npx+1, npy-1)
      END IF
      IF (nw_corner) THEN
        q1(0, npy) = q1(0, npy-1)
        q1(-1, npy) = q1(0, npy-2)
        q1(0, npy+1) = q1(-1, npy-1)
        q2(0, npy) = q2(0, npy-1)
        q2(-1, npy) = q2(0, npy-2)
        q2(0, npy+1) = q2(-1, npy-1)
        q3(0, npy) = q3(0, npy-1)
        q3(-1, npy) = q3(0, npy-2)
        q3(0, npy+1) = q3(-1, npy-1)
      END IF
    CASE (2) 
      IF (sw_corner) THEN
        q1(0, 0) = q1(1, 0)
        q1(0, -1) = q1(2, 0)
        q1(-1, 0) = q1(1, -1)
        q2(0, 0) = q2(1, 0)
        q2(0, -1) = q2(2, 0)
        q2(-1, 0) = q2(1, -1)
        q3(0, 0) = q3(1, 0)
        q3(0, -1) = q3(2, 0)
        q3(-1, 0) = q3(1, -1)
      END IF
      IF (se_corner) THEN
        q1(npx, 0) = q1(npx-1, 0)
        q1(npx, -1) = q1(npx-2, 0)
        q1(npx+1, 0) = q1(npx-1, -1)
        q2(npx, 0) = q2(npx-1, 0)
        q2(npx, -1) = q2(npx-2, 0)
        q2(npx+1, 0) = q2(npx-1, -1)
        q3(npx, 0) = q3(npx-1, 0)
        q3(npx, -1) = q3(npx-2, 0)
        q3(npx+1, 0) = q3(npx-1, -1)
      END IF
      IF (ne_corner) THEN
        q1(npx, npy) = q1(npx-1, npy)
        q1(npx, npy+1) = q1(npx-2, npy)
        q1(npx+1, npy) = q1(npx-1, npy+1)
        q2(npx, npy) = q2(npx-1, npy)
        q2(npx, npy+1) = q2(npx-2, npy)
        q2(npx+1, npy) = q2(npx-1, npy+1)
        q3(npx, npy) = q3(npx-1, npy)
        q3(npx, npy+1) = q3(npx-2, npy)
        q3(npx+1, npy) = q3(npx-1, npy+1)
      END IF
      IF (nw_corner) THEN
        q1(0, npy) = q1(1, npy)
        q1(0, npy+1) = q1(2, npy)
        q1(-1, npy) = q1(1, npy+1)
        q2(0, npy) = q2(1, npy)
        q2(0, npy+1) = q2(2, npy)
        q2(-1, npy) = q2(1, npy+1)
        q3(0, npy) = q3(1, npy)
        q3(0, npy+1) = q3(2, npy)
        q3(-1, npy) = q3(1, npy+1)
      END IF
    END SELECT
  END SUBROUTINE FILL3_4CORNERS
!  Differentiation of fill2_4corners in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_ed
!ge_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod
!.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_
!core_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_m
!od.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cu
!bed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total
!_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_
!mapz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.ste
!epz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_
!solver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver n
!h_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.diver
!gence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_c
!ore_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_c
!ore_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_
!core_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: q1 q2
!   with respect to varying inputs: q1 q2
  SUBROUTINE FILL2_4CORNERS_FWD(q1, q2, dir, bd, npx, npy, sw_corner, &
&   se_corner, ne_corner, nw_corner)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! This routine fill the 4 corners of the scalar fileds only as needed by c_core
! 1: x-dir; 2: y-dir
    INTEGER, INTENT(IN) :: dir
    REAL(fvprc), INTENT(INOUT) :: q1(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: q2(bd%isd:bd%ied, bd%jsd:bd%jed)
    LOGICAL, INTENT(IN) :: sw_corner, se_corner, ne_corner, nw_corner
    INTEGER, INTENT(IN) :: npx, npy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    SELECT CASE  (dir) 
    CASE (1) 
      IF (sw_corner) THEN
        CALL PUSHREALARRAY(q1(-1, 0))
        q1(-1, 0) = q1(0, 2)
        CALL PUSHREALARRAY(q1(0, 0))
        q1(0, 0) = q1(0, 1)
        CALL PUSHREALARRAY(q2(-1, 0))
        q2(-1, 0) = q2(0, 2)
        CALL PUSHREALARRAY(q2(0, 0))
        q2(0, 0) = q2(0, 1)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (se_corner) THEN
        CALL PUSHREALARRAY(q1(npx+1, 0))
        q1(npx+1, 0) = q1(npx, 2)
        CALL PUSHREALARRAY(q1(npx, 0))
        q1(npx, 0) = q1(npx, 1)
        CALL PUSHREALARRAY(q2(npx+1, 0))
        q2(npx+1, 0) = q2(npx, 2)
        CALL PUSHREALARRAY(q2(npx, 0))
        q2(npx, 0) = q2(npx, 1)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (nw_corner) THEN
        CALL PUSHREALARRAY(q1(0, npy))
        q1(0, npy) = q1(0, npy-1)
        CALL PUSHREALARRAY(q1(-1, npy))
        q1(-1, npy) = q1(0, npy-2)
        CALL PUSHREALARRAY(q2(0, npy))
        q2(0, npy) = q2(0, npy-1)
        CALL PUSHREALARRAY(q2(-1, npy))
        q2(-1, npy) = q2(0, npy-2)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (ne_corner) THEN
        CALL PUSHREALARRAY(q1(npx, npy))
        q1(npx, npy) = q1(npx, npy-1)
        CALL PUSHREALARRAY(q1(npx+1, npy))
        q1(npx+1, npy) = q1(npx, npy-2)
        CALL PUSHREALARRAY(q2(npx, npy))
        q2(npx, npy) = q2(npx, npy-1)
        CALL PUSHREALARRAY(q2(npx+1, npy))
        q2(npx+1, npy) = q2(npx, npy-2)
        CALL PUSHCONTROL3B_FV(2)
      ELSE
        CALL PUSHCONTROL3B_FV(1)
      END IF
    CASE (2) 
      IF (sw_corner) THEN
        CALL PUSHREALARRAY(q1(0, 0))
        q1(0, 0) = q1(1, 0)
        CALL PUSHREALARRAY(q1(0, -1))
        q1(0, -1) = q1(2, 0)
        CALL PUSHREALARRAY(q2(0, 0))
        q2(0, 0) = q2(1, 0)
        CALL PUSHREALARRAY(q2(0, -1))
        q2(0, -1) = q2(2, 0)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (se_corner) THEN
        CALL PUSHREALARRAY(q1(npx, 0))
        q1(npx, 0) = q1(npx-1, 0)
        CALL PUSHREALARRAY(q1(npx, -1))
        q1(npx, -1) = q1(npx-2, 0)
        CALL PUSHREALARRAY(q2(npx, 0))
        q2(npx, 0) = q2(npx-1, 0)
        CALL PUSHREALARRAY(q2(npx, -1))
        q2(npx, -1) = q2(npx-2, 0)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (nw_corner) THEN
        CALL PUSHREALARRAY(q1(0, npy))
        q1(0, npy) = q1(1, npy)
        CALL PUSHREALARRAY(q1(0, npy+1))
        q1(0, npy+1) = q1(2, npy)
        CALL PUSHREALARRAY(q2(0, npy))
        q2(0, npy) = q2(1, npy)
        CALL PUSHREALARRAY(q2(0, npy+1))
        q2(0, npy+1) = q2(2, npy)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (ne_corner) THEN
        CALL PUSHREALARRAY(q1(npx, npy))
        q1(npx, npy) = q1(npx-1, npy)
        CALL PUSHREALARRAY(q1(npx, npy+1))
        q1(npx, npy+1) = q1(npx-2, npy)
        CALL PUSHREALARRAY(q2(npx, npy))
        q2(npx, npy) = q2(npx-1, npy)
        CALL PUSHREALARRAY(q2(npx, npy+1))
        q2(npx, npy+1) = q2(npx-2, npy)
        CALL PUSHCONTROL3B_FV(4)
      ELSE
        CALL PUSHCONTROL3B_FV(3)
      END IF
    CASE DEFAULT
      CALL PUSHCONTROL3B_FV(0)
    END SELECT
  END SUBROUTINE FILL2_4CORNERS_FWD
!  Differentiation of fill2_4corners in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_e
!dge_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mo
!d.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn
!_core_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_
!mod.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.c
!ubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_tota
!l_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv
!_mapz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.st
!eepz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem
!_solver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver 
!nh_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.dive
!rgence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_
!core_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_
!core_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp
!_core_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: q1 q2
!   with respect to varying inputs: q1 q2
  SUBROUTINE FILL2_4CORNERS_BWD(q1, q1_ad, q2, q2_ad, dir, bd, npx, npy&
&   , sw_corner, se_corner, ne_corner, nw_corner)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: dir
    REAL(fvprc), INTENT(INOUT) :: q1(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: q1_ad(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: q2(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: q2_ad(bd%isd:bd%ied, bd%jsd:bd%jed)
    LOGICAL, INTENT(IN) :: sw_corner, se_corner, ne_corner, nw_corner
    INTEGER, INTENT(IN) :: npx, npy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTEGER :: branch
    CALL POPCONTROL3B_FV(branch)
    IF (branch .LT. 2) THEN
      IF (branch .EQ. 0) GOTO 100
    ELSE IF (branch .EQ. 2) THEN
      CALL POPREALARRAY(q2(npx+1, npy))
      q2_ad(npx, npy-2) = q2_ad(npx, npy-2) + q2_ad(npx+1, npy)
      q2_ad(npx+1, npy) = 0.0_FVPRC
      CALL POPREALARRAY(q2(npx, npy))
      q2_ad(npx, npy-1) = q2_ad(npx, npy-1) + q2_ad(npx, npy)
      q2_ad(npx, npy) = 0.0_FVPRC
      CALL POPREALARRAY(q1(npx+1, npy))
      q1_ad(npx, npy-2) = q1_ad(npx, npy-2) + q1_ad(npx+1, npy)
      q1_ad(npx+1, npy) = 0.0_FVPRC
      CALL POPREALARRAY(q1(npx, npy))
      q1_ad(npx, npy-1) = q1_ad(npx, npy-1) + q1_ad(npx, npy)
      q1_ad(npx, npy) = 0.0_FVPRC
    ELSE
      IF (branch .NE. 3) THEN
        CALL POPREALARRAY(q2(npx, npy+1))
        q2_ad(npx-2, npy) = q2_ad(npx-2, npy) + q2_ad(npx, npy+1)
        q2_ad(npx, npy+1) = 0.0_FVPRC
        CALL POPREALARRAY(q2(npx, npy))
        q2_ad(npx-1, npy) = q2_ad(npx-1, npy) + q2_ad(npx, npy)
        q2_ad(npx, npy) = 0.0_FVPRC
        CALL POPREALARRAY(q1(npx, npy+1))
        q1_ad(npx-2, npy) = q1_ad(npx-2, npy) + q1_ad(npx, npy+1)
        q1_ad(npx, npy+1) = 0.0_FVPRC
        CALL POPREALARRAY(q1(npx, npy))
        q1_ad(npx-1, npy) = q1_ad(npx-1, npy) + q1_ad(npx, npy)
        q1_ad(npx, npy) = 0.0_FVPRC
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREALARRAY(q2(0, npy+1))
        q2_ad(2, npy) = q2_ad(2, npy) + q2_ad(0, npy+1)
        q2_ad(0, npy+1) = 0.0_FVPRC
        CALL POPREALARRAY(q2(0, npy))
        q2_ad(1, npy) = q2_ad(1, npy) + q2_ad(0, npy)
        q2_ad(0, npy) = 0.0_FVPRC
        CALL POPREALARRAY(q1(0, npy+1))
        q1_ad(2, npy) = q1_ad(2, npy) + q1_ad(0, npy+1)
        q1_ad(0, npy+1) = 0.0_FVPRC
        CALL POPREALARRAY(q1(0, npy))
        q1_ad(1, npy) = q1_ad(1, npy) + q1_ad(0, npy)
        q1_ad(0, npy) = 0.0_FVPRC
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREALARRAY(q2(npx, -1))
        q2_ad(npx-2, 0) = q2_ad(npx-2, 0) + q2_ad(npx, -1)
        q2_ad(npx, -1) = 0.0_FVPRC
        CALL POPREALARRAY(q2(npx, 0))
        q2_ad(npx-1, 0) = q2_ad(npx-1, 0) + q2_ad(npx, 0)
        q2_ad(npx, 0) = 0.0_FVPRC
        CALL POPREALARRAY(q1(npx, -1))
        q1_ad(npx-2, 0) = q1_ad(npx-2, 0) + q1_ad(npx, -1)
        q1_ad(npx, -1) = 0.0_FVPRC
        CALL POPREALARRAY(q1(npx, 0))
        q1_ad(npx-1, 0) = q1_ad(npx-1, 0) + q1_ad(npx, 0)
        q1_ad(npx, 0) = 0.0_FVPRC
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREALARRAY(q2(0, -1))
        q2_ad(2, 0) = q2_ad(2, 0) + q2_ad(0, -1)
        q2_ad(0, -1) = 0.0_FVPRC
        CALL POPREALARRAY(q2(0, 0))
        q2_ad(1, 0) = q2_ad(1, 0) + q2_ad(0, 0)
        q2_ad(0, 0) = 0.0_FVPRC
        CALL POPREALARRAY(q1(0, -1))
        q1_ad(2, 0) = q1_ad(2, 0) + q1_ad(0, -1)
        q1_ad(0, -1) = 0.0_FVPRC
        CALL POPREALARRAY(q1(0, 0))
        q1_ad(1, 0) = q1_ad(1, 0) + q1_ad(0, 0)
        q1_ad(0, 0) = 0.0_FVPRC
      END IF
      GOTO 100
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(q2(-1, npy))
      q2_ad(0, npy-2) = q2_ad(0, npy-2) + q2_ad(-1, npy)
      q2_ad(-1, npy) = 0.0_FVPRC
      CALL POPREALARRAY(q2(0, npy))
      q2_ad(0, npy-1) = q2_ad(0, npy-1) + q2_ad(0, npy)
      q2_ad(0, npy) = 0.0_FVPRC
      CALL POPREALARRAY(q1(-1, npy))
      q1_ad(0, npy-2) = q1_ad(0, npy-2) + q1_ad(-1, npy)
      q1_ad(-1, npy) = 0.0_FVPRC
      CALL POPREALARRAY(q1(0, npy))
      q1_ad(0, npy-1) = q1_ad(0, npy-1) + q1_ad(0, npy)
      q1_ad(0, npy) = 0.0_FVPRC
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(q2(npx, 0))
      q2_ad(npx, 1) = q2_ad(npx, 1) + q2_ad(npx, 0)
      q2_ad(npx, 0) = 0.0_FVPRC
      CALL POPREALARRAY(q2(npx+1, 0))
      q2_ad(npx, 2) = q2_ad(npx, 2) + q2_ad(npx+1, 0)
      q2_ad(npx+1, 0) = 0.0_FVPRC
      CALL POPREALARRAY(q1(npx, 0))
      q1_ad(npx, 1) = q1_ad(npx, 1) + q1_ad(npx, 0)
      q1_ad(npx, 0) = 0.0_FVPRC
      CALL POPREALARRAY(q1(npx+1, 0))
      q1_ad(npx, 2) = q1_ad(npx, 2) + q1_ad(npx+1, 0)
      q1_ad(npx+1, 0) = 0.0_FVPRC
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(q2(0, 0))
      q2_ad(0, 1) = q2_ad(0, 1) + q2_ad(0, 0)
      q2_ad(0, 0) = 0.0_FVPRC
      CALL POPREALARRAY(q2(-1, 0))
      q2_ad(0, 2) = q2_ad(0, 2) + q2_ad(-1, 0)
      q2_ad(-1, 0) = 0.0_FVPRC
      CALL POPREALARRAY(q1(0, 0))
      q1_ad(0, 1) = q1_ad(0, 1) + q1_ad(0, 0)
      q1_ad(0, 0) = 0.0_FVPRC
      CALL POPREALARRAY(q1(-1, 0))
      q1_ad(0, 2) = q1_ad(0, 2) + q1_ad(-1, 0)
      q1_ad(-1, 0) = 0.0_FVPRC
    END IF
 100 CONTINUE
  END SUBROUTINE FILL2_4CORNERS_BWD
  SUBROUTINE FILL2_4CORNERS(q1, q2, dir, bd, npx, npy, sw_corner, &
&   se_corner, ne_corner, nw_corner)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! This routine fill the 4 corners of the scalar fileds only as needed by c_core
! 1: x-dir; 2: y-dir
    INTEGER, INTENT(IN) :: dir
    REAL(fvprc), INTENT(INOUT) :: q1(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: q2(bd%isd:bd%ied, bd%jsd:bd%jed)
    LOGICAL, INTENT(IN) :: sw_corner, se_corner, ne_corner, nw_corner
    INTEGER, INTENT(IN) :: npx, npy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    SELECT CASE  (dir) 
    CASE (1) 
      IF (sw_corner) THEN
        q1(-1, 0) = q1(0, 2)
        q1(0, 0) = q1(0, 1)
        q2(-1, 0) = q2(0, 2)
        q2(0, 0) = q2(0, 1)
      END IF
      IF (se_corner) THEN
        q1(npx+1, 0) = q1(npx, 2)
        q1(npx, 0) = q1(npx, 1)
        q2(npx+1, 0) = q2(npx, 2)
        q2(npx, 0) = q2(npx, 1)
      END IF
      IF (nw_corner) THEN
        q1(0, npy) = q1(0, npy-1)
        q1(-1, npy) = q1(0, npy-2)
        q2(0, npy) = q2(0, npy-1)
        q2(-1, npy) = q2(0, npy-2)
      END IF
      IF (ne_corner) THEN
        q1(npx, npy) = q1(npx, npy-1)
        q1(npx+1, npy) = q1(npx, npy-2)
        q2(npx, npy) = q2(npx, npy-1)
        q2(npx+1, npy) = q2(npx, npy-2)
      END IF
    CASE (2) 
      IF (sw_corner) THEN
        q1(0, 0) = q1(1, 0)
        q1(0, -1) = q1(2, 0)
        q2(0, 0) = q2(1, 0)
        q2(0, -1) = q2(2, 0)
      END IF
      IF (se_corner) THEN
        q1(npx, 0) = q1(npx-1, 0)
        q1(npx, -1) = q1(npx-2, 0)
        q2(npx, 0) = q2(npx-1, 0)
        q2(npx, -1) = q2(npx-2, 0)
      END IF
      IF (nw_corner) THEN
        q1(0, npy) = q1(1, npy)
        q1(0, npy+1) = q1(2, npy)
        q2(0, npy) = q2(1, npy)
        q2(0, npy+1) = q2(2, npy)
      END IF
      IF (ne_corner) THEN
        q1(npx, npy) = q1(npx-1, npy)
        q1(npx, npy+1) = q1(npx-2, npy)
        q2(npx, npy) = q2(npx-1, npy)
        q2(npx, npy+1) = q2(npx-2, npy)
      END IF
    END SELECT
  END SUBROUTINE FILL2_4CORNERS
!  Differentiation of fill_4corners in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edg
!e_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.
!pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_c
!ore_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mo
!d.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cub
!ed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_
!energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_m
!apz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.stee
!pz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_s
!olver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh
!_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.diverg
!ence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_co
!re_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_co
!re_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_c
!ore_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: q
!   with respect to varying inputs: q
  SUBROUTINE FILL_4CORNERS_FWD(q, dir, bd, npx, npy, sw_corner, &
&   se_corner, ne_corner, nw_corner)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! This routine fill the 4 corners of the scalar fileds only as needed by c_core
! 1: x-dir; 2: y-dir
    INTEGER, INTENT(IN) :: dir
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed)
    LOGICAL, INTENT(IN) :: sw_corner, se_corner, ne_corner, nw_corner
    INTEGER, INTENT(IN) :: npx, npy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    SELECT CASE  (dir) 
    CASE (1) 
      IF (sw_corner) THEN
        CALL PUSHREALARRAY(q(-1, 0))
        q(-1, 0) = q(0, 2)
        CALL PUSHREALARRAY(q(0, 0))
        q(0, 0) = q(0, 1)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (se_corner) THEN
        CALL PUSHREALARRAY(q(npx+1, 0))
        q(npx+1, 0) = q(npx, 2)
        CALL PUSHREALARRAY(q(npx, 0))
        q(npx, 0) = q(npx, 1)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (nw_corner) THEN
        CALL PUSHREALARRAY(q(0, npy))
        q(0, npy) = q(0, npy-1)
        CALL PUSHREALARRAY(q(-1, npy))
        q(-1, npy) = q(0, npy-2)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (ne_corner) THEN
        CALL PUSHREALARRAY(q(npx, npy))
        q(npx, npy) = q(npx, npy-1)
        CALL PUSHREALARRAY(q(npx+1, npy))
        q(npx+1, npy) = q(npx, npy-2)
        CALL PUSHCONTROL3B_FV(2)
      ELSE
        CALL PUSHCONTROL3B_FV(1)
      END IF
    CASE (2) 
      IF (sw_corner) THEN
        CALL PUSHREALARRAY(q(0, 0))
        q(0, 0) = q(1, 0)
        CALL PUSHREALARRAY(q(0, -1))
        q(0, -1) = q(2, 0)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (se_corner) THEN
        CALL PUSHREALARRAY(q(npx, 0))
        q(npx, 0) = q(npx-1, 0)
        CALL PUSHREALARRAY(q(npx, -1))
        q(npx, -1) = q(npx-2, 0)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (nw_corner) THEN
        CALL PUSHREALARRAY(q(0, npy))
        q(0, npy) = q(1, npy)
        CALL PUSHREALARRAY(q(0, npy+1))
        q(0, npy+1) = q(2, npy)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (ne_corner) THEN
        CALL PUSHREALARRAY(q(npx, npy))
        q(npx, npy) = q(npx-1, npy)
        CALL PUSHREALARRAY(q(npx, npy+1))
        q(npx, npy+1) = q(npx-2, npy)
        CALL PUSHCONTROL3B_FV(4)
      ELSE
        CALL PUSHCONTROL3B_FV(3)
      END IF
    CASE DEFAULT
      CALL PUSHCONTROL3B_FV(0)
    END SELECT
  END SUBROUTINE FILL_4CORNERS_FWD
!  Differentiation of fill_4corners in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_ed
!ge_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod
!.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_
!core_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_m
!od.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cu
!bed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total
!_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_
!mapz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.ste
!epz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_
!solver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver n
!h_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.diver
!gence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_c
!ore_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_c
!ore_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_
!core_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: q
!   with respect to varying inputs: q
  SUBROUTINE FILL_4CORNERS_BWD(q, q_ad, dir, bd, npx, npy, sw_corner, &
&   se_corner, ne_corner, nw_corner)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: dir
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: q_ad(bd%isd:bd%ied, bd%jsd:bd%jed)
    LOGICAL, INTENT(IN) :: sw_corner, se_corner, ne_corner, nw_corner
    INTEGER, INTENT(IN) :: npx, npy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTEGER :: branch
    CALL POPCONTROL3B_FV(branch)
    IF (branch .LT. 2) THEN
      IF (branch .EQ. 0) GOTO 100
    ELSE IF (branch .EQ. 2) THEN
      CALL POPREALARRAY(q(npx+1, npy))
      q_ad(npx, npy-2) = q_ad(npx, npy-2) + q_ad(npx+1, npy)
      q_ad(npx+1, npy) = 0.0_FVPRC
      CALL POPREALARRAY(q(npx, npy))
      q_ad(npx, npy-1) = q_ad(npx, npy-1) + q_ad(npx, npy)
      q_ad(npx, npy) = 0.0_FVPRC
    ELSE
      IF (branch .NE. 3) THEN
        CALL POPREALARRAY(q(npx, npy+1))
        q_ad(npx-2, npy) = q_ad(npx-2, npy) + q_ad(npx, npy+1)
        q_ad(npx, npy+1) = 0.0_FVPRC
        CALL POPREALARRAY(q(npx, npy))
        q_ad(npx-1, npy) = q_ad(npx-1, npy) + q_ad(npx, npy)
        q_ad(npx, npy) = 0.0_FVPRC
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREALARRAY(q(0, npy+1))
        q_ad(2, npy) = q_ad(2, npy) + q_ad(0, npy+1)
        q_ad(0, npy+1) = 0.0_FVPRC
        CALL POPREALARRAY(q(0, npy))
        q_ad(1, npy) = q_ad(1, npy) + q_ad(0, npy)
        q_ad(0, npy) = 0.0_FVPRC
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREALARRAY(q(npx, -1))
        q_ad(npx-2, 0) = q_ad(npx-2, 0) + q_ad(npx, -1)
        q_ad(npx, -1) = 0.0_FVPRC
        CALL POPREALARRAY(q(npx, 0))
        q_ad(npx-1, 0) = q_ad(npx-1, 0) + q_ad(npx, 0)
        q_ad(npx, 0) = 0.0_FVPRC
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREALARRAY(q(0, -1))
        q_ad(2, 0) = q_ad(2, 0) + q_ad(0, -1)
        q_ad(0, -1) = 0.0_FVPRC
        CALL POPREALARRAY(q(0, 0))
        q_ad(1, 0) = q_ad(1, 0) + q_ad(0, 0)
        q_ad(0, 0) = 0.0_FVPRC
      END IF
      GOTO 100
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(q(-1, npy))
      q_ad(0, npy-2) = q_ad(0, npy-2) + q_ad(-1, npy)
      q_ad(-1, npy) = 0.0_FVPRC
      CALL POPREALARRAY(q(0, npy))
      q_ad(0, npy-1) = q_ad(0, npy-1) + q_ad(0, npy)
      q_ad(0, npy) = 0.0_FVPRC
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(q(npx, 0))
      q_ad(npx, 1) = q_ad(npx, 1) + q_ad(npx, 0)
      q_ad(npx, 0) = 0.0_FVPRC
      CALL POPREALARRAY(q(npx+1, 0))
      q_ad(npx, 2) = q_ad(npx, 2) + q_ad(npx+1, 0)
      q_ad(npx+1, 0) = 0.0_FVPRC
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(q(0, 0))
      q_ad(0, 1) = q_ad(0, 1) + q_ad(0, 0)
      q_ad(0, 0) = 0.0_FVPRC
      CALL POPREALARRAY(q(-1, 0))
      q_ad(0, 2) = q_ad(0, 2) + q_ad(-1, 0)
      q_ad(-1, 0) = 0.0_FVPRC
    END IF
 100 CONTINUE
  END SUBROUTINE FILL_4CORNERS_BWD
  SUBROUTINE FILL_4CORNERS(q, dir, bd, npx, npy, sw_corner, se_corner, &
&   ne_corner, nw_corner)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! This routine fill the 4 corners of the scalar fileds only as needed by c_core
! 1: x-dir; 2: y-dir
    INTEGER, INTENT(IN) :: dir
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed)
    LOGICAL, INTENT(IN) :: sw_corner, se_corner, ne_corner, nw_corner
    INTEGER, INTENT(IN) :: npx, npy
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    SELECT CASE  (dir) 
    CASE (1) 
      IF (sw_corner) THEN
        q(-1, 0) = q(0, 2)
        q(0, 0) = q(0, 1)
      END IF
      IF (se_corner) THEN
        q(npx+1, 0) = q(npx, 2)
        q(npx, 0) = q(npx, 1)
      END IF
      IF (nw_corner) THEN
        q(0, npy) = q(0, npy-1)
        q(-1, npy) = q(0, npy-2)
      END IF
      IF (ne_corner) THEN
        q(npx, npy) = q(npx, npy-1)
        q(npx+1, npy) = q(npx, npy-2)
      END IF
    CASE (2) 
      IF (sw_corner) THEN
        q(0, 0) = q(1, 0)
        q(0, -1) = q(2, 0)
      END IF
      IF (se_corner) THEN
        q(npx, 0) = q(npx-1, 0)
        q(npx, -1) = q(npx-2, 0)
      END IF
      IF (nw_corner) THEN
        q(0, npy) = q(1, npy)
        q(0, npy+1) = q(2, npy)
      END IF
      IF (ne_corner) THEN
        q(npx, npy) = q(npx-1, npy)
        q(npx, npy+1) = q(npx-2, npy)
      END IF
    END SELECT
  END SUBROUTINE FILL_4CORNERS
END MODULE SW_CORE_MOD_B
