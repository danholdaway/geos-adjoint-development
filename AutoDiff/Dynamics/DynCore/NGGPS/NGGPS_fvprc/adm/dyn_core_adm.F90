!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
MODULE DYN_CORE_MOD_B
  USE FV_ARRAYS_MOD_B, ONLY : real4, real8, 8, fv_timing_onoff
  USE CONSTANTS_MOD, ONLY : rdgas, radius
  USE MPP_MOD_B, ONLY : mpp_pe
  USE MPP_DOMAINS_MOD_B, ONLY : cgrid_ne, dgrid_ne, mpp_get_boundary, &
& mpp_get_boundary_adm, mpp_update_domains, mpp_update_domains_adm, &
& domain2d
  USE MPP_PARAMETER_MOD, ONLY : corner
  USE FV_MP_MOD_B, ONLY : is_master
  USE FV_MP_MOD_B, ONLY : start_group_halo_update, &
& start_group_halo_update_adm, complete_group_halo_update
  USE FV_MP_MOD_B, ONLY : group_halo_update_type
  USE SW_CORE_MOD_B, ONLY : c_sw, c_sw_adm, d_sw, d_sw_adm
  USE A2B_EDGE_MOD_B, ONLY : a2b_ord2, a2b_ord2_adm, a2b_ord4, &
& a2b_ord4_adm
  USE NH_CORE_MOD_B, ONLY : riem_solver3, riem_solver3_adm, &
& riem_solver_c, riem_solver_c_adm, update_dz_c, update_dz_c_adm, &
& update_dz_d, update_dz_d_adm, geopk_halo_nh
  USE TP_CORE_MOD_B, ONLY : copy_corners, copy_corners_adm
  USE FV_TIMING_MOD, ONLY : timing_on, timing_off
!  use fv_diagnostics_mod, only: prt_maxmin, fv_time, prt_mxm
!#ifdef ROT3
!  use fv_update_phys_mod, only: update_dwinds_phys
!#endif
!#if defined (ADA_NUDGE)
!  use fv_ada_nudge_mod,   only: breed_slp_inline_ada
!#else
!  use fv_nwp_nudge_mod,   only: breed_slp_inline
!#endif
!  use diag_manager_mod,   only: send_data
  USE FV_ARRAYS_MOD_B, ONLY : fv_grid_type, fv_flags_type, fv_nest_type,&
& fv_diag_type, fv_grid_bounds_type
  USE FV_ARRAYS_MOD_B, ONLY : r_grid
  IMPLICIT NONE
  PRIVATE 
  PUBLIC dyn_core, del2_cubed
  PUBLIC dyn_core_fwd, dyn_core_bwd, del2_cubed_fwd, del2_cubed_bwd
  REAL(fvprc) :: ptk, peln1, rgrav
  REAL(fvprc) :: d3_damp
!  real(FVPRC), allocatable, dimension(:,:,:) ::  ut, vt, crx, cry, xfx, yfx, divgd, &
!                                          zh, du, dv, pkc, delpc, pk3, ptc, gz
  REAL(kind=r_grid), PARAMETER :: cnst_0p20=0.20d0
  EXTERNAL DEL2_CUBED_ADM
  EXTERNAL DYN_CORE_ADM

CONTAINS
!---- version number -----
!  character(len=128) :: version = '$Id: dyn_core.F90,v 1.2.2.1.2.1.30.1.4.1.22.5.48.6.2.2.2.1.4.1 2017/02/16 03:47:47 aoloso Exp
! $'
!  character(len=128) :: tagname = '$Name: Heracles-UNSTABLE_ncepdyn_Feb222017 $'
!-----------------------------------------------------------------------
!     dyn_core :: FV Lagrangian dynamics driver
!-----------------------------------------------------------------------
  SUBROUTINE DYN_CORE(npx, npy, npz, ng, sphum, nq, bdt, n_split, zvir, &
&   cp, akap, cappa, grav, hydrostatic, u, v, w, delz, pt, q, delp, pe, &
&   pk, phis, ws, omga, ptop, pfull, ua, va, uc, vc, mfx, mfy, cx, cy, &
&   pkz, peln, q_con, ak, bk, ks, gridstruct, flagstruct, neststruct, &
&   idiag, bd, domain, init_step, i_pack, end_step, gz, pkc, ptc, crx, &
&   xfx, cry, yfx, divgd, delpc, ut, vt, zh, pk3, du, dv, time_total)
    IMPLICIT NONE
!deallocate( heat_source )    
!if (allocated(heat_source)) deallocate( heat_source ) !If ncon == 0 but d_con > 1.e-5, this would not be deallocated in earlier 
!versions of the code
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
    INTEGER, INTENT(IN) :: ng, nq, sphum
    INTEGER, INTENT(IN) :: n_split
    REAL(fvprc), INTENT(IN) :: bdt
    REAL(fvprc), INTENT(IN) :: zvir, cp, akap, grav
    REAL(fvprc), INTENT(IN) :: ptop
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: init_step, end_step
    REAL(fvprc), INTENT(IN) :: pfull(npz)
    REAL(fvprc), DIMENSION(npz+1), INTENT(IN) :: ak, bk
    INTEGER, INTENT(IN) :: ks
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: i_pack(*)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! D grid zonal wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz), INTENT(&
&   INOUT) :: u
! D grid meridional wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: v
! vertical vel. (m/s)
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! delta-height (m)
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! moist kappa
    REAL(fvprc), INTENT(INOUT) :: cappa(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
! temperature (K)
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! pressure thickness (pascal)
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! 
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, &
&   nq)
! total time (seconds) since start
    REAL(fvprc), INTENT(IN), OPTIONAL :: time_total
!-----------------------------------------------------------------------
! Auxilliary pressure arrays:    
! The 5 vars below can be re-computed from delp and ptop.
!-----------------------------------------------------------------------
! dyn_aux:
! Surface geopotential (g*Z_surf)
    REAL(fvprc), INTENT(INOUT) :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
! edge pressure (pascal)
    REAL(fvprc), INTENT(INOUT) :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%&
&   je+1)
! ln(pe)
    REAL(fvprc), INTENT(INOUT) :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
! pe**kappa
    REAL(fvprc), INTENT(INOUT) :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
!-----------------------------------------------------------------------
! Others:
    REAL(fvprc), PARAMETER :: near0=1.e-8
    REAL(fvprc), PARAMETER :: huge_r=1.e20
! [m**2/sec] for T ~ 260 K
    REAL(fvprc), PARAMETER :: air_viscosity=1.e-5
!-----------------------------------------------------------------------
! w at surface
    REAL(fvprc), INTENT(OUT) :: ws(bd%is:bd%ie, bd%js:bd%je)
! Vertical pressure velocity (pa/s)
    REAL(fvprc), INTENT(INOUT) :: omga(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! (uc, vc) are mostly used as the C grid winds
    REAL(fvprc), INTENT(INOUT) :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: ua, va
    REAL(fvprc), INTENT(INOUT) :: q_con(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
! The Flux capacitors: accumulated Mass flux arrays
    REAL(fvprc), INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL(fvprc), INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
! Accumulated Courant number arrays
    REAL(fvprc), INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc), DIMENSION(bd%is:bd%ie, bd%js:bd%je, npz), INTENT(INOUT)&
&   :: pkz
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
    TYPE(FV_NEST_TYPE), INTENT(INOUT) :: neststruct
    TYPE(FV_DIAG_TYPE), INTENT(IN) :: idiag
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    REAL(fvprc) :: pem(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1), &
&   heat_source(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! Auto 1D & 2D arrays:
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ws3, z_rat
    REAL(fvprc) :: dp_ref(npz)
! surface height (m)
    REAL(fvprc) :: zs(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: p1d(bd%is:bd%ie)
    REAL(fvprc) :: om2d(bd%is:bd%ie, npz)
    REAL(fvprc) :: wbuffer(npy+2, npz)
    REAL(fvprc) :: ebuffer(npy+2, npz)
    REAL(fvprc) :: nbuffer(npx+2, npz)
    REAL(fvprc) :: sbuffer(npx+2, npz)
! ----   For external mode:
    REAL(fvprc) :: divg2(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: wk(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: fz(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: heat_s(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: damp_vt(npz+1)
    REAL(fvprc) :: damp_vt_pert(npz+1)
    INTEGER :: nord_v(npz+1)
    INTEGER :: nord_v_pert(npz+1)
!-------------------------------------
    INTEGER :: hord_m, hord_v, hord_t, hord_p
    INTEGER :: hord_m_pert, hord_v_pert, hord_t_pert, hord_p_pert
    INTEGER :: nord_k, nord_w, nord_t
    INTEGER :: nord_k_pert, nord_w_pert, nord_t_pert
    INTEGER :: ms
!---------------------------------------
    INTEGER :: i, j, k, it, iq, n_con
    INTEGER :: iep1, jep1
    REAL(fvprc) :: beta, beta_d, damp_k, damp_w, damp_t, d_con_k
    REAL(fvprc) :: damp_k_pert, damp_w_pert, damp_t_pert, d_con_k_pert
    REAL(fvprc) :: dt, dt2, rdt
    REAL(fvprc) :: d2_divg, d3_divg
    REAL(fvprc) :: d2_divg_pert
    REAL(fvprc) :: k1k, kapag, tmcp, cpm
    LOGICAL :: last_step, remap_step
    LOGICAL :: used
    REAL(fvprc) :: split_timestep_bc, split
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: pkc(bd%isd:bd%ied, bd%jsd:bd%jed, npz+&
&   1)
    REAL(fvprc), INTENT(INOUT) :: ptc(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: crx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: xfx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: cry(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc), INTENT(INOUT) :: yfx(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc), INTENT(INOUT) :: divgd(bd%isd:bd%ied+1, bd%jsd:bd%jed+1&
&   , npz)
    REAL(fvprc), INTENT(INOUT) :: delpc(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: ut(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: vt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: zh(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: pk3(bd%isd:bd%ied, bd%jsd:bd%jed, npz+&
&   1)
    REAL(fvprc), INTENT(INOUT) :: du(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: dv(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc) :: vt_tj(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    INTRINSIC LOG
    INTRINSIC REAL
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC TANH
    INTRINSIC EXP
    INTEGER :: arg1
    LOGICAL :: arg10
    REAL(kind=r_grid) :: arg11
    REAL(fvprc) :: y2
    REAL(fvprc) :: y1
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    damp_vt = 0
    damp_vt_pert = 0
    peln1 = LOG(ptop)
    ptk = ptop**akap
    dt = bdt/REAL(n_split)
    dt2 = 0.5*dt
    rdt = 1.0/dt
    IF (1 .LT. flagstruct%m_split/2) THEN
      ms = flagstruct%m_split/2
    ELSE
      ms = 1
    END IF
    beta = flagstruct%beta
    split = REAL(n_split*flagstruct%k_split)
! Indexes:
    iep1 = ie + 1
    jep1 = je + 1
    IF (.NOT.hydrostatic) THEN
      rgrav = 1.0/grav
! rg/Cv=0.4
      k1k = akap/(1.-akap)
      kapag = -(akap/grav)
!$OMP parallel do default(none) shared(npz,dp_ref,ak,bk)
      DO k=1,npz
        dp_ref(k) = ak(k+1) - ak(k) + (bk(k+1)-bk(k))*1.e5
      END DO
!$OMP parallel do default(none) shared(isd,ied,jsd,jed,zs,phis,rgrav)
      DO j=jsd,jed
        DO i=isd,ied
          zs(i, j) = phis(i, j)*rgrav
        END DO
      END DO
    END IF
! end init_step
    IF (init_step) THEN
! Start of the big dynamic time stepping
!allocate(    gz(isd:ied, jsd:jed ,npz+1) )
      arg1 = npz + 1
      CALL INIT_IJK_MEM(isd, ied, jsd, jed, arg1, gz, huge_r)
!allocate(   pkc(isd:ied, jsd:jed ,npz+1) )
!allocate(   ptc(isd:ied, jsd:jed ,npz ) )
!allocate( crx(is :ie+1, jsd:jed,  npz) )
!allocate( xfx(is :ie+1, jsd:jed,  npz) )
!allocate( cry(isd:ied,  js :je+1, npz) )
!allocate( yfx(isd:ied,  js :je+1, npz) )
!allocate( divgd(isd:ied+1,jsd:jed+1,npz) )
!allocate( delpc(isd:ied, jsd:jed  ,npz  ) )
!                    call init_ijk_mem(isd,ied, jsd,jed, npz, delpc, 0._FVPRC)
!allocate( ut(isd:ied, jsd:jed, npz) )
!                    call init_ijk_mem(isd,ied, jsd,jed, npz, ut, 0._FVPRC)
!allocate( vt(isd:ied, jsd:jed, npz) )
!                    call init_ijk_mem(isd,ied, jsd,jed, npz, vt, 0._FVPRC)
      IF (.NOT.hydrostatic) THEN
!allocate( zh(isd:ied, jsd:jed, npz+1) )
!              call init_ijk_mem(isd,ied, jsd,jed, npz+1, zh, huge_r )
!allocate ( pk3(isd:ied,jsd:jed,npz+1) )
        arg1 = npz + 1
        CALL INIT_IJK_MEM(isd, ied, jsd, jed, arg1, pk3, huge_r)
      END IF
      IF (beta .GT. near0) THEN
!allocate( du(isd:ied,  jsd:jed+1,npz) )
        arg1 = jed + 1
        CALL INIT_IJK_MEM(isd, ied, jsd, arg1, npz, du, 0._FVPRC)
!allocate( dv(isd:ied+1,jsd:jed,  npz) )
        arg1 = ied + 1
        CALL INIT_IJK_MEM(isd, arg1, jsd, jed, npz, dv, 0._FVPRC)
      END IF
    END IF
! Empty the "flux capacitors"
    arg1 = ie + 1
    CALL INIT_IJK_MEM(is, arg1, js, je, npz, mfx, 0._FVPRC)
    arg1 = je + 1
    CALL INIT_IJK_MEM(is, ie, js, arg1, npz, mfy, 0._FVPRC)
    arg1 = ie + 1
    CALL INIT_IJK_MEM(is, arg1, jsd, jed, npz, cx, 0._FVPRC)
    arg1 = je + 1
    CALL INIT_IJK_MEM(isd, ied, js, arg1, npz, cy, 0._FVPRC)
    IF (flagstruct%d_con .GT. 1.0e-5) THEN
!allocate( heat_source(isd:ied, jsd:jed, npz) )
      heat_source = 0.0
      CALL INIT_IJK_MEM(isd, ied, jsd, jed, npz, heat_source, 0._FVPRC)
    END IF
    IF (flagstruct%convert_ke .OR. flagstruct%vtdm4 .GT. 1.e-3) THEN
      n_con = npz
    ELSE IF (flagstruct%d2_bg_k1 .LT. 1.e-3) THEN
      n_con = 0
    ELSE IF (flagstruct%d2_bg_k2 .LT. 1.e-3) THEN
      n_con = 1
    ELSE
      n_con = 2
    END IF
    IF (gridstruct%nested) split_timestep_bc = REAL(n_split*flagstruct%&
&       k_split + neststruct%nest_timestep)
!-----------------------------------------------------
    DO it=1,n_split
!-----------------------------------------------------
!#ifdef ROT3
!     call start_group_halo_update(i_pack(8), i_pack(8+12), u, v, domain, gridtype=DGRID_NE)
!#endif
      IF (flagstruct%breed_vortex_inline .OR. it .EQ. n_split) THEN
        remap_step = .true.
      ELSE
        remap_step = .false.
      END IF
!     if ( flagstruct%fv_debug ) then
!          if(is_master()) write(*,*) 'n_split loop, it=', it
!          if ( .not. flagstruct%hydrostatic )    &
!          call prt_mxm('delz',  delz, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!     endif
      IF (nq .GT. 0) THEN
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
!if (fv_timing_onoff) call timing_on('COMM_TRACER')
        IF (flagstruct%inline_q) THEN
          CALL START_GROUP_HALO_UPDATE(i_pack(10), i_pack(10+12), q, &
&                                domain)
        ELSE IF (it .EQ. n_split) THEN
          CALL START_GROUP_HALO_UPDATE(i_pack(10), i_pack(10+12), q, &
&                                domain)
        END IF
      END IF
!if (fv_timing_onoff) call timing_off('COMM_TRACER')
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
      IF (.NOT.hydrostatic) THEN
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
        CALL START_GROUP_HALO_UPDATE(i_pack(7), i_pack(7+12), w, domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
        IF (it .EQ. 1) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,gz,zs,delz)
          DO j=js,je
            DO i=is,ie
              gz(i, j, npz+1) = zs(i, j)
            END DO
            DO k=npz,1,-1
              DO i=is,ie
                gz(i, j, k) = gz(i, j, k+1) - delz(i, j, k)
              END DO
            END DO
          END DO
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
          CALL START_GROUP_HALO_UPDATE(i_pack(5), i_pack(5+12), gz, &
&                                domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
        END IF
      END IF
!#ifdef SW_DYNAMICS
!     if (test_case>1) then
!     if (test_case==9) call case9_forcing1(phis, time_total)
!#endif
      IF (it .EQ. 1) THEN
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
        CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(1), i_pack(1+12), domain)
        CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(2), i_pack(2+12), domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
        beta_d = 0.
      ELSE
        beta_d = beta
      END IF
      IF (it .EQ. n_split .AND. end_step) THEN
        IF (flagstruct%use_old_omega) THEN
!allocate ( pem(is-1:ie+1,npz+1,js-1:je+1) )
          pem = 0.0
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pem,delp,ptop)
          DO j=js-1,je+1
            DO i=is-1,ie+1
              pem(i, 1, j) = ptop
            END DO
            DO k=1,npz
              DO i=is-1,ie+1
                pem(i, k+1, j) = pem(i, k, j) + delp(i, j, k)
              END DO
            END DO
          END DO
        END IF
        last_step = .true.
      ELSE
        last_step = .false.
      END IF
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
      CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(8), i_pack(8+12), domain)
      IF (.NOT.hydrostatic) CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(7), &
&                                                     i_pack(7+12), &
&                                                     domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!if (fv_timing_onoff) call timing_on('  c_sw')
!$OMP parallel do default(none) shared(npz,isd,jsd,delpc,delp,ptc,pt,u,v,w,uc,vc,ua,va, &
!$OMP                                  omga,ut,vt,divgd,flagstruct,dt2,hydrostatic,bd,  &
!$OMP                                  gridstruct)
      DO k=1,npz
        CALL C_SW(delpc(isd:ied, jsd:jed, k), delp(isd:ied, jsd:jed, k)&
&           , ptc(isd:ied, jsd:jed, k), pt(isd:ied, jsd:jed, k), u(isd:&
&           ied, jsd:jed+1, k), v(isd:ied+1, jsd:jed, k), w(isd:ied, jsd&
&           :jed, k), uc(isd:ied+1, jsd:jed, k), vc(isd:ied, jsd:jed+1, &
&           k), ua(isd:ied, jsd:jed, k), va(isd:ied, jsd:jed, k), omga(&
&           isd:ied, jsd:jed, k), ut(isd:ied, jsd:jed, k), vt(isd:ied, &
&           jsd:jed, k), divgd(isd:ied+1, jsd:jed+1, k), flagstruct%nord&
&           , dt2, hydrostatic, .true., bd, gridstruct, flagstruct)
      END DO
!if (fv_timing_onoff) call timing_off('  c_sw')
      IF (flagstruct%nord .GT. 0) CALL START_GROUP_HALO_UPDATE(i_pack(3)&
&                                                        , i_pack(3+12)&
&                                                        , divgd, domain&
&                                                        , position=&
&                                                        corner)
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
! end hydro check
      IF (hydrostatic) THEN
        CALL GEOPK(ptop, pe, peln, delpc, pkc, gz, phis, ptc, q_con, pkz&
&            , npz, akap, .true., gridstruct%nested, .false., npx, npy, &
&            flagstruct%a2b_ord, bd)
      ELSE
        IF (it .EQ. 1) THEN
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
          CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(5), i_pack(5+12), &
&                                   domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!$OMP parallel do default(none) shared(isd,ied,jsd,jed,npz,zh,gz)
          DO k=1,npz+1
            DO j=jsd,jed
              DO i=isd,ied
! Save edge heights for update_dz_d
                zh(i, j, k) = gz(i, j, k)
              END DO
            END DO
          END DO
        ELSE
!$OMP parallel do default(none) shared(isd,ied,jsd,jed,npz,zh,gz)
          DO k=1,npz+1
            DO j=jsd,jed
              DO i=isd,ied
                gz(i, j, k) = zh(i, j, k)
              END DO
            END DO
          END DO
        END IF
!if (fv_timing_onoff) call timing_on('  UPDATE_DZ_C')
        CALL UPDATE_DZ_C(is, ie, js, je, npz, ng, dt2, dp_ref, zs, &
&                  gridstruct%area, ut, vt, gz, ws3, npx, npy, &
&                  gridstruct%sw_corner, gridstruct%se_corner, &
&                  gridstruct%ne_corner, gridstruct%nw_corner, bd, &
&                  gridstruct%grid_type)
!if (fv_timing_onoff) call timing_off('  UPDATE_DZ_C')
!if (fv_timing_onoff) call timing_on('  Riem_Solver')
        CALL RIEM_SOLVER_C(ms, dt2, is, ie, js, je, npz, ng, akap, cappa&
&                    , cp, ptop, phis, omga, ptc, q_con, delpc, gz, pkc&
&                    , ws3, flagstruct%p_fac, flagstruct%a_imp, &
&                    flagstruct%scale_z)
!if (fv_timing_onoff) call timing_off('  Riem_Solver')
!#ifndef SW_DYNAMICS
!           if (gridstruct%nested) then
!                 call nested_grid_BC_apply_intT(delpc, &
!                      0, 0, npx, npy, npz, bd, split_timestep_BC+0.5, split, &
!                      var_east_t0=neststruct%delp_BC%east_t0, &
!                      var_west_t0=neststruct%delp_BC%west_t0, &
!                      var_north_t0=neststruct%delp_BC%north_t0, &
!                      var_south_t0=neststruct%delp_BC%south_t0, &
!                      var_east_t1=neststruct%delp_BC%east_t1, &
!                      var_west_t1=neststruct%delp_BC%west_t1, &
!                      var_north_t1=neststruct%delp_BC%north_t1, &
!                      var_south_t1=neststruct%delp_BC%south_t1, &
!                      bctype=neststruct%nestbctype, &
!                      nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!                 call nested_grid_BC_apply_intT(ptc, &
!                      0, 0, npx, npy, npz, bd, split_timestep_BC+0.5, split, &
!                      var_east_t0=neststruct%pt_BC%east_t0, &
!                      var_west_t0=neststruct%pt_BC%west_t0, &
!                      var_north_t0=neststruct%pt_BC%north_t0, &
!                      var_south_t0=neststruct%pt_BC%south_t0, &
!                      var_east_t1=neststruct%pt_BC%east_t1, &
!                      var_west_t1=neststruct%pt_BC%west_t1, &
!                      var_north_t1=neststruct%pt_BC%north_t1, &
!                      var_south_t1=neststruct%pt_BC%south_t1, &
!                      bctype=neststruct%nestbctype, &
!                      nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!                 call nested_grid_BC_apply_intT(delz, &
!                      0, 0, npx, npy, npz, bd, split_timestep_BC+0.5, split, &
!                      var_east_t0=neststruct%delz_BC%east_t0, &
!                      var_west_t0=neststruct%delz_BC%west_t0, &
!                      var_north_t0=neststruct%delz_BC%north_t0, &
!                      var_south_t0=neststruct%delz_BC%south_t0, &
!                      var_east_t1=neststruct%delz_BC%east_t1, &
!                      var_west_t1=neststruct%delz_BC%west_t1, &
!                      var_north_t1=neststruct%delz_BC%north_t1, &
!                      var_south_t1=neststruct%delz_BC%south_t1, &
!                      bctype=neststruct%nestbctype, &
!                      nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!!!$         do k=1,npz
!!!$            call extrapolation_BC( delz(:,:,k), 0, 0, npx, npy, bd)
!!!$            call extrapolation_BC(delpc(:,:,k), 0, 0, npx, npy, bd)
!!!$            call extrapolation_BC(  ptc(:,:,k), 0, 0, npx, npy, bd)
!!!$         end do
!
!
!              !Compute gz/pkc
!              !NOTE: nominally only need to compute quantities one out in the halo for p_grad_c
!              !(instead of entire halo)
!              call geopk_halo_nh(ptop, grav, akap, cp, delpc, delz, ptc, phis, pkc, gz, pk3, &
!                   npx, npy, npz, gridstruct%nested, .false., .false., .false., bd)
!
!           endif
!#endif
      END IF
      CALL P_GRAD_C(dt2, npz, delpc, pkc, gz, uc, vc, bd, gridstruct%&
&             rdxc, gridstruct%rdyc, hydrostatic)
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
      CALL START_GROUP_HALO_UPDATE(i_pack(9), i_pack(9+12), uc, vc, &
&                            domain, gridtype=cgrid_ne)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!#ifdef SW_DYNAMICS
!      if (test_case==9) call case9_forcing2(phis)
!      endif !test_case>1
!#endif
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
      IF (flagstruct%inline_q .AND. nq .GT. 0) CALL &
&       COMPLETE_GROUP_HALO_UPDATE(i_pack(10), i_pack(10+12), domain)
      IF (flagstruct%nord .GT. 0) CALL COMPLETE_GROUP_HALO_UPDATE(i_pack&
&                                                           (3), i_pack(&
&                                                           3+12), &
&                                                           domain)
      CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(9), i_pack(9+12), domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!      if (gridstruct%nested) then
!         !On a nested grid we have to do SOMETHING with uc and vc in
!         ! the boundary halo, particularly at the corners of the
!         ! domain and of each processor element. We must either
!         ! apply an interpolated BC, or extrapolate into the
!         ! boundary halo
!         ! NOTE: 
!         !The update_domains calls for uc and vc need to go BEFORE the BCs to ensure cross-restart
!         !bitwise-consistent solutions when doing the spatial extrapolation; should not make a
!         !difference for interpolated BCs from the coarse grid.
!
!
!!!$         do k=1,npz
!!!$            call extrapolation_BC(uc(:,:,k), 1, 0, npx, npy, bd)
!!!$            call extrapolation_BC(vc(:,:,k), 0, 1, npx, npy, bd)
!!!$         end do
!!!$
!
!
!         !vc
!            call nested_grid_BC_apply_intT(vc, &
!                 0, 1, npx, npy, npz, bd, split_timestep_bc+0.5, split, & 
!                 var_east_t0=neststruct%vc_BC%east_t0, &
!                 var_west_t0=neststruct%vc_BC%west_t0, &
!                 var_north_t0=neststruct%vc_BC%north_t0, &
!                 var_south_t0=neststruct%vc_BC%south_t0, &
!                 var_east_t1=neststruct%vc_BC%east_t1, &
!                 var_west_t1=neststruct%vc_BC%west_t1, &
!                 var_north_t1=neststruct%vc_BC%north_t1, &
!                 var_south_t1=neststruct%vc_BC%south_t1, &
!                 bctype=neststruct%nestbctype, &
!                 nsponge=neststruct%nsponge, s_weight=neststruct%s_weight  )
!
!            !uc
!            call nested_grid_BC_apply_intT(uc, &
!                 1, 0, npx, npy, npz, bd, split_timestep_bc+0.5, split, &
!                 var_east_t0=neststruct%uc_BC%east_t0, &
!                 var_west_t0=neststruct%uc_BC%west_t0, &
!                 var_north_t0=neststruct%uc_BC%north_t0, &
!                 var_south_t0=neststruct%uc_BC%south_t0, &
!                 var_east_t1=neststruct%uc_BC%east_t1, &
!                 var_west_t1=neststruct%uc_BC%west_t1, &
!                 var_north_t1=neststruct%uc_BC%north_t1, &
!                 var_south_t1=neststruct%uc_BC%south_t1, &
!                 bctype=neststruct%nestbctype, &
!                 nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!      end if
!    if ( flagstruct%inline_q ) then
!         if (gridstruct%nested) then
!            do iq=1,nq
!                  call nested_grid_BC_apply_intT(q(isd:ied,jsd:jed,:,iq), &
!                       0, 0, npx, npy, npz, bd, split_timestep_BC+1, split, &
!                       var_east_t0=neststruct%q_BC(iq)%east_t0, &
!                       var_west_t0=neststruct%q_BC(iq)%west_t0, &
!                       var_north_t0=neststruct%q_BC(iq)%north_t0, &
!                       var_south_t0=neststruct%q_BC(iq)%south_t0, &
!                       var_east_t1=neststruct%q_BC(iq)%east_t1, &
!                       var_west_t1=neststruct%q_BC(iq)%west_t1, &
!                       var_north_t1=neststruct%q_BC(iq)%north_t1, &
!                       var_south_t1=neststruct%q_BC(iq)%south_t1, &
!                       bctype=neststruct%nestbctype, &
!                       nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!            end do
!         end if
!      endif
!if (fv_timing_onoff) call timing_on('  d_sw')
!$OMP parallel do default(none) shared(npz,flagstruct,nord_v,pfull,damp_vt,hydrostatic,last_step, &
!$OMP                                  is,ie,js,je,isd,ied,jsd,jed,omga,delp,gridstruct,npx,npy,  &
!$OMP                                  ng,zh,vt,ptc,pt,u,v,w,uc,vc,ua,va,divgd,mfx,mfy,cx,cy,     &
!$OMP                                  crx,cry,xfx,yfx,q_con,zvir,sphum,nq,q,dt,bd,rdt,iep1,jep1, &
!$OMP                                  heat_source)                                               &
!$OMP                          private(nord_k, nord_w, nord_t, damp_k, damp_w, damp_t, d2_divg,   &
!$OMP                                  hord_m, hord_v, hord_t, hord_p, wk, heat_s, d_con_k, z_rat)
      DO k=1,npz
        hord_m = flagstruct%hord_mt
        hord_t = flagstruct%hord_tm
        hord_v = flagstruct%hord_vt
        hord_p = flagstruct%hord_dp
        hord_m_pert = flagstruct%hord_mt_pert
        hord_t_pert = flagstruct%hord_tm_pert
        hord_v_pert = flagstruct%hord_vt_pert
        hord_p_pert = flagstruct%hord_dp_pert
        nord_k = flagstruct%nord
        nord_k_pert = flagstruct%nord_pert
        IF (2 .GT. flagstruct%nord) THEN
          nord_v(k) = flagstruct%nord
        ELSE
          nord_v(k) = 2
        END IF
        IF (2 .GT. flagstruct%nord_pert) THEN
          nord_v_pert(k) = flagstruct%nord_pert
        ELSE
          nord_v_pert(k) = 2
        END IF
        damp_k = flagstruct%dddmp
        damp_k_pert = flagstruct%dddmp_pert
        y1 = flagstruct%d2_bg*(1.-3.*TANH(0.1*LOG(pfull(k)/pfull(npz))))
        IF (0.20 .GT. y1) THEN
          d2_divg = y1
        ELSE
          d2_divg = 0.20
        END IF
        y2 = flagstruct%d2_bg_pert*(1.-3.*TANH(0.1*LOG(pfull(k)/pfull(&
&         npz))))
        IF (0.20 .GT. y2) THEN
          d2_divg_pert = y2
        ELSE
          d2_divg_pert = 0.20
        END IF
        d_con_k = flagstruct%d_con
        d_con_k_pert = flagstruct%d_con_pert
        IF (flagstruct%do_vort_damp) THEN
! for delp, delz, and vorticity
          damp_vt(k) = flagstruct%vtdm4
        ELSE
          damp_vt(k) = 0.
        END IF
        IF (flagstruct%do_vort_damp_pert) THEN
! for delp, delz, and vorticity
          damp_vt_pert(k) = flagstruct%vtdm4_pert
        ELSE
          damp_vt_pert(k) = 0.
        END IF
        nord_w = nord_v(k)
        nord_w_pert = nord_v_pert(k)
        nord_t = nord_v(k)
        nord_t_pert = nord_v_pert(k)
        damp_w = damp_vt(k)
        damp_w_pert = damp_vt_pert(k)
        damp_t = damp_vt(k)
        damp_t_pert = damp_vt_pert(k)
        IF (npz .EQ. 1 .OR. flagstruct%n_sponge .LT. 0) THEN
          d2_divg = flagstruct%d2_bg
          d2_divg_pert = flagstruct%d2_bg_pert
        ELSE IF (flagstruct%n_sponge .EQ. 0) THEN
! New Del-2 Sponge layer: formulation
! Sponge layers with del-2 damping on divergence, vorticity, w, z, and air mass (delp).
! (no damping of potential temperature in sponge layers)
          IF (k .EQ. 1) THEN
            damp_k = 0.
            damp_k_pert = 0.
            nord_k = 0
            nord_k_pert = 0
            IF (flagstruct%d2_bg .LT. flagstruct%d2_bg_k1) THEN
              d2_divg = flagstruct%d2_bg_k1
            ELSE
              d2_divg = flagstruct%d2_bg
            END IF
            IF (flagstruct%d2_bg_pert .LT. flagstruct%d2_bg_k1) THEN
              d2_divg_pert = flagstruct%d2_bg_k1
            ELSE
              d2_divg_pert = flagstruct%d2_bg_pert
            END IF
! for delp, delz, and vorticity, sponger layers
            nord_v(k) = 0
! for delp, delz, and vorticity, sponger layers
            nord_v_pert(k) = 0
!#ifndef HIWPP
            damp_vt(k) = d2_divg
            damp_vt_pert(k) = d2_divg_pert
!#endif
            nord_w = 0
            nord_w_pert = 0
            damp_w = d2_divg
            damp_w_pert = d2_divg_pert
          ELSE IF (k .EQ. 2) THEN
            damp_k = 0.
            damp_k_pert = 0.
            nord_k = 0
            nord_k_pert = 0
            IF (flagstruct%d2_bg .LT. flagstruct%d2_bg_k2) THEN
              d2_divg = flagstruct%d2_bg_k2
            ELSE
              d2_divg = flagstruct%d2_bg
            END IF
            IF (flagstruct%d2_bg_pert .LT. flagstruct%d2_bg_k2) THEN
              d2_divg_pert = flagstruct%d2_bg_k2
            ELSE
              d2_divg_pert = flagstruct%d2_bg_pert
            END IF
            nord_v(k) = 0
            nord_v_pert(k) = 0
!#ifndef HIWPP
            damp_vt(k) = d2_divg
            damp_vt_pert(k) = d2_divg_pert
!#endif
            nord_w = 0
            nord_w_pert = 0
            damp_w = d2_divg
            damp_w_pert = d2_divg_pert
          ELSE IF (k .EQ. 3 .AND. flagstruct%d2_bg_k2 .GT. 0.05) THEN
            damp_k = 0.
            damp_k_pert = 0.
            nord_k = 0
            nord_k_pert = 0
            IF (flagstruct%d2_bg .LT. 0.2*flagstruct%d2_bg_k2) THEN
              d2_divg = 0.2*flagstruct%d2_bg_k2
            ELSE
              d2_divg = flagstruct%d2_bg
            END IF
            IF (flagstruct%d2_bg_pert .LT. 0.2*flagstruct%d2_bg_k2) THEN
              d2_divg_pert = 0.2*flagstruct%d2_bg_k2
            ELSE
              d2_divg_pert = flagstruct%d2_bg_pert
            END IF
            nord_v(k) = 0
            nord_v_pert(k) = 0
!#ifndef HIWPP
            damp_vt(k) = d2_divg
            damp_vt_pert(k) = d2_divg_pert
!#endif
            nord_w = 0
            nord_w_pert = 0
            damp_w = d2_divg
            damp_w_pert = d2_divg_pert
          END IF
          IF (damp_vt(k) .LT. 0.01 .AND. nord_k .GT. 0) d_con_k = 0.
          IF (damp_vt_pert(k) .LT. 0.01 .AND. nord_k_pert .GT. 0) &
&           d_con_k_pert = 0.
        ELSE IF (k .LE. flagstruct%n_sponge .AND. npz .GT. 16) THEN
! Apply first order scheme for damping the sponge layer
          hord_m = 1
          hord_m_pert = 1
          hord_v = 1
          hord_v_pert = 1
          hord_t = 1
          hord_t_pert = 1
          hord_p = 1
          hord_p_pert = 1
          nord_k = 0
          nord_k_pert = 0
          damp_k = flagstruct%damp_k_k1
          damp_k_pert = flagstruct%damp_k_k1
          IF (0.20 .GT. flagstruct%d2_bg_k1*flagstruct%d2_bg) THEN
            d2_divg = flagstruct%d2_bg_k1*flagstruct%d2_bg
          ELSE
            d2_divg = 0.20
          END IF
          IF (0.20 .GT. flagstruct%d2_bg_k1*flagstruct%d2_bg_pert) THEN
            d2_divg_pert = flagstruct%d2_bg_k1*flagstruct%d2_bg_pert
          ELSE
            d2_divg_pert = 0.20
          END IF
          IF (flagstruct%d2_divg_max_k1 .LT. d2_divg) THEN
            d2_divg = d2_divg
          ELSE
            d2_divg = flagstruct%d2_divg_max_k1
          END IF
          IF (flagstruct%d2_divg_max_k1 .LT. d2_divg_pert) THEN
            d2_divg_pert = d2_divg_pert
          ELSE
            d2_divg_pert = flagstruct%d2_divg_max_k1
          END IF
        ELSE IF (k .EQ. flagstruct%n_sponge + 1 .AND. npz .GT. 24) THEN
          hord_v = 2
          hord_v_pert = 1
          hord_t = 2
          hord_t_pert = 1
          hord_p = 2
          hord_p_pert = 1
          IF (0 .LT. flagstruct%nord - 1) THEN
            nord_k = flagstruct%nord - 1
          ELSE
            nord_k = 0
          END IF
          IF (0 .LT. flagstruct%nord_pert - 1) THEN
            nord_k_pert = flagstruct%nord_pert - 1
          ELSE
            nord_k_pert = 0
          END IF
          IF (0.20 .GT. flagstruct%d2_bg_k2*flagstruct%d2_bg) THEN
            d2_divg = flagstruct%d2_bg_k2*flagstruct%d2_bg
          ELSE
            d2_divg = 0.20
          END IF
          IF (0.20 .GT. flagstruct%d2_bg_k2*flagstruct%d2_bg_pert) THEN
            d2_divg_pert = flagstruct%d2_bg_k2*flagstruct%d2_bg_pert
          ELSE
            d2_divg_pert = 0.20
          END IF
          IF (flagstruct%d2_divg_max_k2 .LT. d2_divg) THEN
            d2_divg = d2_divg
          ELSE
            d2_divg = flagstruct%d2_divg_max_k2
          END IF
          IF (flagstruct%d2_divg_max_k2 .LT. d2_divg_pert) THEN
            d2_divg_pert = d2_divg_pert
          ELSE
            d2_divg_pert = flagstruct%d2_divg_max_k2
          END IF
          IF (flagstruct%nord .GT. 1) THEN
            damp_k = 0.
          ELSE
            damp_k = flagstruct%damp_k_k2
          END IF
          IF (flagstruct%nord_pert .GT. 1) THEN
            damp_k_pert = 0.
          ELSE
            damp_k_pert = flagstruct%damp_k_k2
          END IF
        END IF
        IF (damp_k .LT. flagstruct%dddmp) THEN
          damp_k = flagstruct%dddmp
        ELSE
          damp_k = damp_k
        END IF
        IF (damp_k_pert .LT. flagstruct%dddmp_pert) THEN
          damp_k_pert = flagstruct%dddmp_pert
        ELSE
          damp_k_pert = damp_k_pert
        END IF
        IF (hydrostatic .AND. (.NOT.flagstruct%use_old_omega)) THEN
          IF (last_step) THEN
! Average horizontal "convergence" to cell center
            DO j=js,je
              DO i=is,ie
                omga(i, j, k) = delp(i, j, k)
              END DO
            END DO
          END IF
        END IF
!--- external mode divergence damping ---
        IF (flagstruct%d_ext .GT. 0.) CALL A2B_ORD2(delp(isd, jsd, k), &
&                                             wk, gridstruct, npx, npy, &
&                                             is, ie, js, je, ng, &
&                                             .false.)
        IF (.NOT.hydrostatic .AND. flagstruct%do_f3d) THEN
! Correction factor for 3D Coriolis force
          DO j=jsd,jed
            DO i=isd,ied
              z_rat(i, j) = 1. + (zh(i, j, k)+zh(i, j, k+1))/radius
            END DO
          END DO
        END IF
        CALL D_SW(vt(isd:ied, jsd:jed, k), vt_tj(isd:ied, jsd:jed, k), &
&           delp(isd:ied, jsd:jed, k), ptc(isd:ied, jsd:jed, k), pt(isd:&
&           ied, jsd:jed, k), u(isd:ied, jsd:jed+1, k), v(isd:ied+1, jsd&
&           :jed, k), w(isd:ied, jsd:jed, k), uc(isd:ied+1, jsd:jed, k)&
&           , vc(isd:ied, jsd:jed+1, k), ua(isd:ied, jsd:jed, k), va(isd&
&           :ied, jsd:jed, k), divgd(isd:ied+1, jsd:jed+1, k), mfx(is:ie&
&           +1, js:je, k), mfy(is:ie, js:je+1, k), cx(is:ie+1, jsd:jed, &
&           k), cy(isd:ied, js:je+1, k), crx(is:ie+1, jsd:jed, k), cry(&
&           isd:ied, js:je+1, k), xfx(is:ie+1, jsd:jed, k), yfx(isd:ied&
&           , js:je+1, k), q_con(isd:isd, jsd:jsd, 1), z_rat(isd:ied, &
&           jsd:jed), heat_s, zvir, sphum, nq, q, k, npz, flagstruct%&
&           inline_q, dt, flagstruct%hord_tr, hord_m, hord_v, hord_t, &
&           hord_p, flagstruct%hord_tr_pert, hord_m_pert, hord_v_pert, &
&           hord_t_pert, hord_p_pert, nord_k, nord_v(k), nord_w, nord_t&
&           , damp_k, d2_divg, flagstruct%d4_bg, damp_vt(k), damp_w, &
&           damp_t, d_con_k, flagstruct%split_damp, nord_k_pert, &
&           nord_v_pert(k), nord_w_pert, nord_t_pert, damp_k_pert, &
&           d2_divg_pert, flagstruct%d4_bg_pert, damp_vt_pert(k), &
&           damp_w_pert, damp_t_pert, d_con_k_pert, hydrostatic, &
&           gridstruct, flagstruct, bd)
        IF (hydrostatic .AND. (.NOT.flagstruct%use_old_omega)) THEN
          IF (last_step) THEN
! Average horizontal "convergence" to cell center
            DO j=js,je
              DO i=is,ie
                omga(i, j, k) = omga(i, j, k)*(xfx(i, j, k)-xfx(i+1, j, &
&                 k)+yfx(i, j, k)-yfx(i, j+1, k))*gridstruct%rarea(i, j)&
&                 *rdt
              END DO
            END DO
          END IF
        END IF
        IF (flagstruct%d_ext .GT. 0.) THEN
          DO j=js,jep1
            DO i=is,iep1
! delp at cell corners
              ptc(i, j, k) = wk(i, j)
            END DO
          END DO
        END IF
        IF (d_con_k .GT. 1.0e-5) THEN
! Average horizontal "convergence" to cell center
          DO j=js,je
            DO i=is,ie
              heat_source(i, j, k) = heat_source(i, j, k) + heat_s(i, j)
            END DO
          END DO
        END IF
      END DO
! end openMP k-loop
!if (fv_timing_onoff) call timing_off('  d_sw')
      IF (flagstruct%fill_dp) CALL MIX_DP(hydrostatic, w, delp, pt, npz&
&                                   , ak, bk, .false., flagstruct%&
&                                   fv_debug, bd)
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
      CALL START_GROUP_HALO_UPDATE(i_pack(1), i_pack(1+12), delp, domain&
&                           )
      CALL START_GROUP_HALO_UPDATE(i_pack(2), i_pack(2+12), pt, domain)
!#ifdef USE_COND
!    call start_group_halo_update(i_pack(11), i_pack(11+12), q_con, domain)
!#endif
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
      IF (flagstruct%d_ext .GT. 0.) THEN
        d2_divg = flagstruct%d_ext*gridstruct%da_min_c
!$OMP parallel do default(none) shared(is,iep1,js,jep1,npz,wk,ptc,divg2,vt,d2_divg)
        DO j=js,jep1
          DO i=is,iep1
            wk(i, j) = ptc(i, j, 1)
            divg2(i, j) = wk(i, j)*vt(i, j, 1)
          END DO
          DO k=2,npz
            DO i=is,iep1
              wk(i, j) = wk(i, j) + ptc(i, j, k)
              divg2(i, j) = divg2(i, j) + ptc(i, j, k)*vt(i, j, k)
            END DO
          END DO
          DO i=is,iep1
            divg2(i, j) = d2_divg*divg2(i, j)/wk(i, j)
          END DO
        END DO
      ELSE
        divg2(:, :) = 0.
      END IF
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
      CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(1), i_pack(1+12), domain)
      CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(2), i_pack(2+12), domain)
! end hydro check
!#ifdef USE_COND
!     call complete_group_halo_update(i_pack(11), i_pack(11+12), domain)
!#endif
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!    if ( flagstruct%fv_debug ) then
!         if ( .not. flagstruct%hydrostatic )    &
!         call prt_mxm('delz',  delz, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!    endif
      IF (hydrostatic) THEN
        CALL GEOPK(ptop, pe, peln, delp, pkc, gz, phis, pt, q_con, pkz, &
&            npz, akap, .false., gridstruct%nested, .true., npx, npy, &
&            flagstruct%a2b_ord, bd)
!Want to move this block into the hydro/nonhydro branch above and merge the two if structures
!          if (gridstruct%nested) then
!
!             call nested_grid_BC_apply_intT(delp, &
!                  0, 0, npx, npy, npz, bd, split_timestep_BC+1, split, &
!                  var_east_t0=neststruct%delp_BC%east_t0, &
!                  var_west_t0=neststruct%delp_BC%west_t0, &
!                  var_north_t0=neststruct%delp_BC%north_t0, &
!                  var_south_t0=neststruct%delp_BC%south_t0, &
!                  var_east_t1=neststruct%delp_BC%east_t1, &
!                  var_west_t1=neststruct%delp_BC%west_t1, &
!                  var_north_t1=neststruct%delp_BC%north_t1, &
!                  var_south_t1=neststruct%delp_BC%south_t1, &
!                  bctype=neststruct%nestbctype, &
!                  nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!!#ifndef SW_DYNAMICS
!
!             call nested_grid_BC_apply_intT(pt, &
!                  0, 0, npx, npy, npz, bd, split_timestep_BC+1, split, &
!                  var_east_t0=neststruct%pt_BC%east_t0, &
!                  var_west_t0=neststruct%pt_BC%west_t0, &
!                  var_north_t0=neststruct%pt_BC%north_t0, &
!                  var_south_t0=neststruct%pt_BC%south_t0, &
!                  var_east_t1=neststruct%pt_BC%east_t1, &
!                  var_west_t1=neststruct%pt_BC%west_t1, &
!                  var_north_t1=neststruct%pt_BC%north_t1, &
!                  var_south_t1=neststruct%pt_BC%south_t1, &
!                  bctype=neststruct%nestbctype, &
!                  nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!!#endif
!          end if
      ELSE
!if (fv_timing_onoff) call timing_on('  UPDATE_DZ')
        CALL UPDATE_DZ_D(nord_v, damp_vt, flagstruct%hord_tm, flagstruct&
&                  %hord_tm_pert, is, ie, js, je, npz, ng, npx, npy, &
&                  gridstruct%area, gridstruct%rarea, dp_ref, zs, zh, &
&                  crx, cry, xfx, yfx, ws, rdt, gridstruct, bd)
!if (fv_timing_onoff) call timing_off('  UPDATE_DZ')
!    if ( flagstruct%fv_debug ) then
!         if ( .not. flagstruct%hydrostatic )    &
!         call prt_mxm('delz updated',  delz, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!    endif
!        if (idiag%id_ws>0 .and. last_step) then
!           call prt_maxmin('WS', ws, is, ie, js, je, 0, 1, 1._FVPRC, master)
!            used=send_data(idiag%id_ws, ws, fv_time)
!        endif
!Want to move this block into the hydro/nonhydro branch above and merge the two if structures
!        if (gridstruct%nested) then
!
!           call nested_grid_BC_apply_intT(delp, &
!                0, 0, npx, npy, npz, bd, split_timestep_BC+1, split, &
!                var_east_t0=neststruct%delp_BC%east_t0, &
!                var_west_t0=neststruct%delp_BC%west_t0, &
!                var_north_t0=neststruct%delp_BC%north_t0, &
!                var_south_t0=neststruct%delp_BC%south_t0, &
!                var_east_t1=neststruct%delp_BC%east_t1, &
!                var_west_t1=neststruct%delp_BC%west_t1, &
!                var_north_t1=neststruct%delp_BC%north_t1, &
!                var_south_t1=neststruct%delp_BC%south_t1, &
!                bctype=neststruct%nestbctype, &
!                nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!!#ifndef SW_DYNAMICS
!
!           call nested_grid_BC_apply_intT(pt, &
!                0, 0, npx, npy, npz, bd, split_timestep_BC+1, split, &
!                var_east_t0=neststruct%pt_BC%east_t0, &
!                var_west_t0=neststruct%pt_BC%west_t0, &
!                var_north_t0=neststruct%pt_BC%north_t0, &
!                var_south_t0=neststruct%pt_BC%south_t0, &
!                var_east_t1=neststruct%pt_BC%east_t1, &
!                var_west_t1=neststruct%pt_BC%west_t1, &
!                var_north_t1=neststruct%pt_BC%north_t1, &
!                var_south_t1=neststruct%pt_BC%south_t1, &
!                bctype=neststruct%nestbctype, &
!                nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!!#endif
!
!        end if
!if (fv_timing_onoff) call timing_on('  Riem_Solver')
        arg10 = beta .LT. -0.1
        CALL RIEM_SOLVER3(flagstruct%m_split, dt, is, ie, js, je, npz, &
&                   ng, isd, ied, jsd, jed, akap, cappa, cp, ptop, zs, &
&                   q_con, w, delz, pt, delp, zh, pe, pkc, pk3, pk, peln&
&                   , ws, flagstruct%scale_z, flagstruct%p_fac, &
&                   flagstruct%a_imp, flagstruct%use_logp, remap_step, &
&                   arg10)
!if (fv_timing_onoff) call timing_off('  Riem_Solver')
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
        CALL START_GROUP_HALO_UPDATE(i_pack(4), i_pack(4+12), zh, domain&
&                             )
        IF (gridstruct%square_domain) THEN
          CALL START_GROUP_HALO_UPDATE(i_pack(6), i_pack(6+12), pkc, &
&                                domain, whalo=2, ehalo=2, shalo=2, &
&                                nhalo=2)
        ELSE
          CALL START_GROUP_HALO_UPDATE(i_pack(6), i_pack(6+12), pkc, &
&                                domain)
        END IF
        IF (remap_step) CALL PE_HALO(is, ie, js, je, isd, ied, jsd, jed&
&                              , npz, ptop, pe, delp)
        IF (flagstruct%use_logp) THEN
          CALL PLN_HALO(is, ie, js, je, isd, ied, jsd, jed, npz, ptop, &
&                 pk3, delp)
        ELSE
          CALL PK3_HALO(is, ie, js, je, isd, ied, jsd, jed, npz, ptop, &
&                 akap, pk3, delp)
        END IF
        CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(4), i_pack(4+12), domain)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,gz,zh,grav)
        DO k=1,npz+1
          DO j=js-2,je+2
            DO i=is-2,ie+2
              gz(i, j, k) = zh(i, j, k)*grav
            END DO
          END DO
        END DO
        CALL COMPLETE_GROUP_HALO_UPDATE(i_pack(6), i_pack(6+12), domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
      END IF
!#ifdef SW_DYNAMICS
!      if (test_case > 1) then
!#else
      IF (hydrostatic) THEN
        IF (remap_step) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pk,pkc)
          DO k=1,npz+1
            DO j=js,je
              DO i=is,ie
                pk(i, j, k) = pkc(i, j, k)
              END DO
            END DO
          END DO
        END IF
      END IF
!#endif
!----------------------------
! Compute pressure gradient:
!----------------------------
!if (fv_timing_onoff) call timing_on('  PG_D')
      IF (hydrostatic) THEN
        IF (beta .GT. 0.) THEN
          CALL GRAD1_P_UPDATE(divg2, u, v, du, dv, pkc, gz, dt, ng, &
&                       gridstruct, bd, npx, npy, npz, ptop, beta_d, &
&                       flagstruct%a2b_ord)
        ELSE
          CALL ONE_GRAD_P(u, v, pkc, gz, divg2, delp, dt, ng, gridstruct&
&                   , bd, npx, npy, npz, ptop, hydrostatic, flagstruct%&
&                   a2b_ord, flagstruct%d_ext)
        END IF
      ELSE IF (beta .GT. 0.) THEN
!#ifndef SW_DYNAMICS
!       if (gridstruct%nested) then
!           call nested_grid_BC_apply_intT(delz, &
!                    0, 0, npx, npy, npz, bd, split_timestep_BC+1., split, &
!                    var_east_t0=neststruct%delz_BC%east_t0, &
!                    var_west_t0=neststruct%delz_BC%west_t0, &
!                    var_north_t0=neststruct%delz_BC%north_t0, &
!                    var_south_t0=neststruct%delz_BC%south_t0, &
!                    var_east_t1=neststruct%delz_BC%east_t1, &
!                    var_west_t1=neststruct%delz_BC%west_t1, &
!                    var_north_t1=neststruct%delz_BC%north_t1, &
!                    var_south_t1=neststruct%delz_BC%south_t1, &
!                    bctype=neststruct%nestbctype, &
!                    nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!            !Compute gz/pkc/pk3; note that now pkc should be nonhydro pert'n pressure
!            call geopk_halo_nh(ptop, grav, akap, cp, delp, delz, pt, phis, pkc, &
!                               gz, pk3, npx, npy, npz, gridstruct%nested, .true., .true., .true., bd)
!
!       endif
!#endif
        CALL SPLIT_P_GRAD(u, v, du, dv, pkc, gz, delp, pk3, beta_d, dt, &
&                   ng, gridstruct, bd, npx, npy, npz, flagstruct%&
&                   use_logp)
      ELSE IF (beta .LT. -0.1) THEN
        CALL ONE_GRAD_P(u, v, pkc, gz, divg2, delp, dt, ng, gridstruct, &
&                 bd, npx, npy, npz, ptop, hydrostatic, flagstruct%&
&                 a2b_ord, flagstruct%d_ext)
      ELSE
        CALL NH_P_GRAD(u, v, pkc, gz, delp, pk3, dt, ng, gridstruct, bd&
&                , npx, npy, npz, flagstruct%use_logp)
      END IF
!#ifdef ROT3
!       if ( flagstruct%do_f3d ) then
!!$OMP parallel do default(none) shared(is,ie,js,je,npz,ua,gridstruct,w,va,isd,ied,jsd,jed)
!           do k=1,npz
!              do j=js,je
!                 do i=is,ie
!                    ua(i,j,k) = -gridstruct%w00(i,j)*w(i,j,k)
!                 enddo
!              enddo
!              do j=jsd,jed
!                 do i=isd,ied
!                    va(i,j,k) = 0.
!                 enddo
!              enddo
!           enddo
!           call mpp_update_domains(ua, domain, complete=.true.)
!           call update_dwinds_phys(is, ie, js, je, isd, ied, jsd, jed, dt, ua, va, u, v, gridstruct, npx, npy, npz, domain)
!       endif
!#endif
!if (fv_timing_onoff) call timing_off('  PG_D')
!-------------------------------------------------------------------------------------------------------
      IF (flagstruct%breed_vortex_inline) THEN
        IF (.NOT.hydrostatic) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pkz,cappa,kapag,delp,delz,pt,k1k)
          DO k=1,npz
            DO j=js,je
              DO i=is,ie
! Note: pt at this stage is cp*Theta_m
!#ifdef MOIST_CAPPA
!                    pkz(i,j,k) = exp(cappa(i,j,k)/(1.-cappa(i,j,k))*log(kapag*delp(i,j,k)/delz(i,j,k)*pt(i,j,k)) )
!#else
                pkz(i, j, k) = EXP(k1k*LOG(kapag*delp(i, j, k)/delz(i, j&
&                 , k)*pt(i, j, k)))
              END DO
            END DO
          END DO
        END IF
      END IF
!#endif
!#if defined (ADA_NUDGE)
!         call breed_slp_inline_ada( it, dt, npz, ak, bk, phis, pe, pk, peln, pkz,     &
!                                delp, u, v, pt, q, flagstruct%nwat, zvir, gridstruct, ks, domain, bd )
!#else
!call breed_slp_inline( it, dt, npz, ak, bk, phis, pe, pk, peln, pkz, delp, u, v, pt, q,    &
!                       flagstruct%nwat, zvir, gridstruct, ks, domain, bd, hydrostatic )
!#endif
!-------------------------------------------------------------------------------------------------------
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
      IF (gridstruct%grid_type .LT. 4 .AND. (.NOT.gridstruct%nested)) &
&     THEN
        IF (it .EQ. n_split) THEN
! Prevent accumulation of rounding errors at overlapped domain edges:
          CALL MPP_GET_BOUNDARY(u, v, domain, wbuffery=wbuffer, ebuffery&
&                         =ebuffer, sbufferx=sbuffer, nbufferx=nbuffer, &
&                         gridtype=dgrid_ne)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,u,nbuffer,v,ebuffer)
          DO k=1,npz
            DO i=is,ie
              u(i, je+1, k) = nbuffer(i-is+1, k)
            END DO
            DO j=js,je
              v(ie+1, j, k) = ebuffer(j-js+1, k)
            END DO
          END DO
        END IF
      END IF
!#ifndef ROT3
      IF (it .NE. n_split) THEN
        CALL START_GROUP_HALO_UPDATE(i_pack(8), i_pack(8+12), u, v, &
&                              domain, gridtype=dgrid_ne)
      END IF
!#endif
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!#ifdef SW_DYNAMICS
!    endif
!#endif
      IF (gridstruct%nested) neststruct%nest_timestep = neststruct%&
&         nest_timestep + 1
!#ifdef SW_DYNAMICS
!#else
      IF (last_step .AND. hydrostatic) THEN
        IF (flagstruct%use_old_omega) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,omga,pe,pem,rdt)
          DO k=1,npz
            DO j=js,je
              DO i=is,ie
                omga(i, j, k) = (pe(i, k+1, j)-pem(i, k+1, j))*rdt
              END DO
            END DO
          END DO
!------------------------------
! Compute the "advective term"
!------------------------------
          CALL ADV_PE(ua, va, pem, omga, gridstruct, bd, npx, npy, npz, &
&               ng)
        ELSE
!$OMP parallel do default(none) shared(is,ie,js,je,npz,omga) private(om2d)
          DO j=js,je
            DO k=1,npz
              DO i=is,ie
                om2d(i, k) = omga(i, j, k)
              END DO
            END DO
            DO k=2,npz
              DO i=is,ie
                om2d(i, k) = om2d(i, k-1) + omga(i, j, k)
              END DO
            END DO
            DO k=2,npz
              DO i=is,ie
                omga(i, j, k) = om2d(i, k)
              END DO
            END DO
          END DO
        END IF
      END IF
    END DO
!      if (idiag%id_ws>0 .and. hydrostatic) then
!$OMP parallel do default(none) shared(is,ie,js,je,npz,ws,delz,delp,omga)
!           do j=js,je
!             do i=is,ie
!                ws(i,j) = delz(i,j,npz)/delp(i,j,npz) * omga(i,j,npz)
!             enddo
!          enddo
!          used=send_data(idiag%id_ws, ws, fv_time)
!      endif
!#endif
!    if (gridstruct%nested) then
!!#ifdef SW_DYNAMICS
!!#else
!
!
!
!         if (.not. hydrostatic) then
!               call nested_grid_BC_apply_intT(w, &
!                    0, 0, npx, npy, npz, bd, split_timestep_BC, split, &
!                    var_east_t0=neststruct%w_BC%east_t0, &
!                    var_west_t0=neststruct%w_BC%west_t0, &
!                    var_north_t0=neststruct%w_BC%north_t0, &
!                    var_south_t0=neststruct%w_BC%south_t0, &
!                    var_east_t1=neststruct%w_BC%east_t1, &
!                    var_west_t1=neststruct%w_BC%west_t1, &
!                    var_north_t1=neststruct%w_BC%north_t1, &
!                    var_south_t1=neststruct%w_BC%south_t1, &
!                    bctype=neststruct%nestbctype, &
!                    nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!         end if
!!#endif
!         
!         
!            call nested_grid_BC_apply_intT(u, &
!                 0, 1, npx, npy, npz, bd, split_timestep_BC, split, &
!                 var_east_t0=neststruct%u_BC%east_t0, &
!                 var_west_t0=neststruct%u_BC%west_t0, &
!                 var_north_t0=neststruct%u_BC%north_t0, &
!                 var_south_t0=neststruct%u_BC%south_t0, &
!                 var_east_t1=neststruct%u_BC%east_t1, &
!                 var_west_t1=neststruct%u_BC%west_t1, &
!                 var_north_t1=neststruct%u_BC%north_t1, &
!                 var_south_t1=neststruct%u_BC%south_t1, &
!                 bctype=neststruct%nestbctype, &
!                 nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!         !v
!            call nested_grid_BC_apply_intT(v, &
!                 1, 0, npx, npy, npz, bd, split_timestep_BC, split, &
!                 var_east_t0=neststruct%v_BC%east_t0, &
!                 var_west_t0=neststruct%v_BC%west_t0, &
!                 var_north_t0=neststruct%v_BC%north_t0, &
!                 var_south_t0=neststruct%v_BC%south_t0, &
!                 var_east_t1=neststruct%v_BC%east_t1, &
!                 var_west_t1=neststruct%v_BC%west_t1, &
!                 var_north_t1=neststruct%v_BC%north_t1, &
!                 var_south_t1=neststruct%v_BC%south_t1, &
!                 bctype=neststruct%nestbctype, &
!                 nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!      end if
!-----------------------------------------------------
! time split loop
!-----------------------------------------------------
!  if ( flagstruct%fv_debug ) then
!       if(is_master()) write(*,*) 'End of n_split loop'
!  endif
    IF (n_con .NE. 0 .AND. flagstruct%d_con .GT. 1.e-5) THEN
      arg11 = cnst_0p20*gridstruct%da_min
      CALL DEL2_CUBED(heat_source, arg11, gridstruct, domain, npx, npy, &
&               npz, 3, bd)
! Note: pt here is cp*(Virtual_Temperature/pkz)
      IF (hydrostatic) THEN
!
! del(Cp*T) = - del(KE)
!
!$OMP parallel do default(none) shared(is,ie,js,je,n_con,pt,heat_source,delp,pkz)
        DO j=js,je
          DO k=1,n_con
            DO i=is,ie
              pt(i, j, k) = pt(i, j, k) + heat_source(i, j, k)/(delp(i, &
&               j, k)*pkz(i, j, k))
            END DO
          END DO
        END DO
      ELSE
!$OMP parallel do default(none) shared(is,ie,js,je,n_con,pkz,cappa,kapag,delp,delz,pt, &
!$OMP                                  heat_source,k1k) &
!$OMP                          private(cpm, tmcp)
        DO j=js,je
! n_con is usually less than 3; not good as outer openMP loop
          DO k=1,n_con
            DO i=is,ie
!#ifdef MOIST_CAPPA
!                pkz(i,j,k) = exp(cappa(i,j,k)/(1.-cappa(i,j,k))*log(kapag*delp(i,j,k)/delz(i,j,k)*pt(i,j,k)) )
!#else
              pkz(i, j, k) = EXP(k1k*LOG(kapag*delp(i, j, k)/delz(i, j, &
&               k)*pt(i, j, k)))
!#endif
! tmcp = termperature_v * cp
              tmcp = pt(i, j, k)*pkz(i, j, k)
              delz(i, j, k) = delz(i, j, k)/tmcp
              tmcp = tmcp + heat_source(i, j, k)/delp(i, j, k)
              pt(i, j, k) = tmcp/pkz(i, j, k)
              delz(i, j, k) = delz(i, j, k)*tmcp
            END DO
          END DO
        END DO
      END IF
    END IF
!deallocate(    gz )
!deallocate(   ptc )
!deallocate(   crx )
!deallocate(   xfx )
!deallocate(   cry )
!deallocate(   yfx )
!deallocate( divgd )
!deallocate(   pkc )
!deallocate( delpc )
!if( allocated(ut))   deallocate( ut )
!if( allocated(vt))   deallocate( vt )
!if ( allocated (du) ) deallocate( du )
!if ( allocated (dv) ) deallocate( dv )
!if ( .not. hydrostatic ) then
!     deallocate( zh )
!     deallocate( pk3 )
!endif
!if( allocated(pem) )   deallocate ( pem )
!if ( flagstruct%fv_debug ) then
!   if(is_master()) write(*,*) 'End of dyn_core'
!endif
  END SUBROUTINE DYN_CORE
!  Differentiation of dyn_core in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod
!.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_ha
!lo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_m
!od.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.ray
!leigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to
!_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energ
!y fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_m
!od.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv
!_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver
!_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core
!_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_
!corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mo
!d.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mo
!d.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_m
!od.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: pk3 xfx ws peln q gz du u dv
!                v w delp ua uc ptc mfx delz mfy omga ut divgd
!                pkc delpc va vc yfx pkz pe vt pk zh pt cx cy crx
!                cry
!   with respect to varying inputs: pk3 xfx ws peln q gz du u dv
!                v w delp ua uc ptc mfx delz mfy omga ut divgd
!                pkc delpc va vc yfx pkz pe vt pk zh pt cx cy crx
!                cry
!---- version number -----
!  character(len=128) :: version = '$Id: dyn_core.F90,v 1.2.2.1.2.1.30.1.4.1.22.5.48.6.2.2.2.1.4.1 2017/02/16 03:47:47 aoloso Exp
! $'
!  character(len=128) :: tagname = '$Name: Heracles-UNSTABLE_ncepdyn_Feb222017 $'
!-----------------------------------------------------------------------
!     dyn_core :: FV Lagrangian dynamics driver
!-----------------------------------------------------------------------
  SUBROUTINE DYN_CORE_FWD(npx, npy, npz, ng, sphum, nq, bdt, n_split, &
&   zvir, cp, akap, cappa, grav, hydrostatic, u, v, w, delz, pt, q, delp&
&   , pe, pk, phis, ws, omga, ptop, pfull, ua, va, uc, vc, mfx, mfy, cx&
&   , cy, pkz, peln, q_con, ak, bk, ks, gridstruct, flagstruct, &
&   neststruct, idiag, bd, domain, init_step, i_pack, end_step, gz, pkc&
&   , ptc, crx, xfx, cry, yfx, divgd, delpc, ut, vt, zh, pk3, du, dv, &
&   time_total)
    IMPLICIT NONE
!deallocate( heat_source )    
!if (allocated(heat_source)) deallocate( heat_source ) !If ncon == 0 but d_con > 1.e-5, this would not be deallocated in earlier 
!versions of the code
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
    INTEGER, INTENT(IN) :: ng, nq, sphum
    INTEGER, INTENT(IN) :: n_split
    REAL(fvprc), INTENT(IN) :: bdt
    REAL(fvprc), INTENT(IN) :: zvir, cp, akap, grav
    REAL(fvprc), INTENT(IN) :: ptop
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: init_step, end_step
    REAL(fvprc), INTENT(IN) :: pfull(npz)
    REAL(fvprc), DIMENSION(npz+1), INTENT(IN) :: ak, bk
    INTEGER, INTENT(IN) :: ks
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: i_pack(*)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! D grid zonal wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz), INTENT(&
&   INOUT) :: u
! D grid meridional wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: v
! vertical vel. (m/s)
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! delta-height (m)
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! moist kappa
    REAL(fvprc), INTENT(INOUT) :: cappa(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
! temperature (K)
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! pressure thickness (pascal)
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! 
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, &
&   nq)
! total time (seconds) since start
    REAL(fvprc), INTENT(IN), OPTIONAL :: time_total
!-----------------------------------------------------------------------
! Auxilliary pressure arrays:    
! The 5 vars below can be re-computed from delp and ptop.
!-----------------------------------------------------------------------
! dyn_aux:
! Surface geopotential (g*Z_surf)
    REAL(fvprc), INTENT(INOUT) :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
! edge pressure (pascal)
    REAL(fvprc), INTENT(INOUT) :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%&
&   je+1)
! ln(pe)
    REAL(fvprc), INTENT(INOUT) :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
! pe**kappa
    REAL(fvprc), INTENT(INOUT) :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
!-----------------------------------------------------------------------
! Others:
    REAL(fvprc), PARAMETER :: near0=1.e-8
    REAL(fvprc), PARAMETER :: huge_r=1.e20
! [m**2/sec] for T ~ 260 K
    REAL(fvprc), PARAMETER :: air_viscosity=1.e-5
!-----------------------------------------------------------------------
! w at surface
    REAL(fvprc) :: ws(bd%is:bd%ie, bd%js:bd%je)
! Vertical pressure velocity (pa/s)
    REAL(fvprc), INTENT(INOUT) :: omga(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! (uc, vc) are mostly used as the C grid winds
    REAL(fvprc), INTENT(INOUT) :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: ua, va
    REAL(fvprc), INTENT(INOUT) :: q_con(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
! The Flux capacitors: accumulated Mass flux arrays
    REAL(fvprc), INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL(fvprc), INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
! Accumulated Courant number arrays
    REAL(fvprc), INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc), DIMENSION(bd%is:bd%ie, bd%js:bd%je, npz), INTENT(INOUT)&
&   :: pkz
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
    TYPE(FV_NEST_TYPE), INTENT(INOUT) :: neststruct
    TYPE(FV_DIAG_TYPE), INTENT(IN) :: idiag
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    REAL(fvprc) :: pem(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1), &
&   heat_source(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! Auto 1D & 2D arrays:
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ws3, z_rat
    REAL(fvprc) :: dp_ref(npz)
! surface height (m)
    REAL(fvprc) :: zs(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: p1d(bd%is:bd%ie)
    REAL(fvprc) :: om2d(bd%is:bd%ie, npz)
    REAL(fvprc) :: wbuffer(npy+2, npz)
    REAL(fvprc) :: ebuffer(npy+2, npz)
    REAL(fvprc) :: nbuffer(npx+2, npz)
    REAL(fvprc) :: sbuffer(npx+2, npz)
! ----   For external mode:
    REAL(fvprc) :: divg2(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: wk(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: fz(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: heat_s(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: damp_vt(npz+1)
    REAL(fvprc) :: damp_vt_pert(npz+1)
    INTEGER :: nord_v(npz+1)
    INTEGER :: nord_v_pert(npz+1)
!-------------------------------------
    INTEGER :: hord_m, hord_v, hord_t, hord_p
    INTEGER :: hord_m_pert, hord_v_pert, hord_t_pert, hord_p_pert
    INTEGER :: nord_k, nord_w, nord_t
    INTEGER :: nord_k_pert, nord_w_pert, nord_t_pert
    INTEGER :: ms
!---------------------------------------
    INTEGER :: i, j, k, it, iq, n_con
    INTEGER :: iep1, jep1
    REAL(fvprc) :: beta, beta_d, damp_k, damp_w, damp_t, d_con_k
    REAL(fvprc) :: damp_k_pert, damp_w_pert, damp_t_pert, d_con_k_pert
    REAL(fvprc) :: dt, dt2, rdt
    REAL(fvprc) :: d2_divg, d3_divg
    REAL(fvprc) :: d2_divg_pert
    REAL(fvprc) :: k1k, kapag, tmcp, cpm
    LOGICAL :: last_step, remap_step
    LOGICAL :: used
    REAL(fvprc) :: split_timestep_bc, split
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: pkc(bd%isd:bd%ied, bd%jsd:bd%jed, npz+&
&   1)
    REAL(fvprc), INTENT(INOUT) :: ptc(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: crx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: xfx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: cry(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc), INTENT(INOUT) :: yfx(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc), INTENT(INOUT) :: divgd(bd%isd:bd%ied+1, bd%jsd:bd%jed+1&
&   , npz)
    REAL(fvprc), INTENT(INOUT) :: delpc(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: ut(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: vt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: zh(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: pk3(bd%isd:bd%ied, bd%jsd:bd%jed, npz+&
&   1)
    REAL(fvprc), INTENT(INOUT) :: du(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: dv(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc) :: vt_tj(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    INTRINSIC LOG
    INTRINSIC REAL
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC TANH
    INTRINSIC EXP
    INTEGER :: arg1
    LOGICAL :: arg10
    REAL(kind=r_grid) :: arg11
    REAL(fvprc) :: y2
    REAL(fvprc) :: y1
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    damp_vt = 0
    damp_vt_pert = 0
    peln1 = LOG(ptop)
    ptk = ptop**akap
    dt = bdt/REAL(n_split)
    dt2 = 0.5*dt
    rdt = 1.0/dt
    IF (1 .LT. flagstruct%m_split/2) THEN
      ms = flagstruct%m_split/2
    ELSE
      ms = 1
    END IF
    beta = flagstruct%beta
! Indexes:
    iep1 = ie + 1
    jep1 = je + 1
    IF (.NOT.hydrostatic) THEN
      rgrav = 1.0/grav
! rg/Cv=0.4
      k1k = akap/(1.-akap)
      kapag = -(akap/grav)
!$OMP parallel do default(none) shared(npz,dp_ref,ak,bk)
      DO k=1,npz
        dp_ref(k) = ak(k+1) - ak(k) + (bk(k+1)-bk(k))*1.e5
      END DO
!$OMP parallel do default(none) shared(isd,ied,jsd,jed,zs,phis,rgrav)
      DO j=jsd,jed
        DO i=isd,ied
          zs(i, j) = phis(i, j)*rgrav
        END DO
      END DO
    END IF
! end init_step
    IF (init_step) THEN
! Start of the big dynamic time stepping
!allocate(    gz(isd:ied, jsd:jed ,npz+1) )
      arg1 = npz + 1
      CALL PUSHREALARRAY(gz, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                   (npz+1)/8)
      CALL INIT_IJK_MEM(isd, ied, jsd, jed, arg1, gz, huge_r)
!allocate(   pkc(isd:ied, jsd:jed ,npz+1) )
!allocate(   ptc(isd:ied, jsd:jed ,npz ) )
!allocate( crx(is :ie+1, jsd:jed,  npz) )
!allocate( xfx(is :ie+1, jsd:jed,  npz) )
!allocate( cry(isd:ied,  js :je+1, npz) )
!allocate( yfx(isd:ied,  js :je+1, npz) )
!allocate( divgd(isd:ied+1,jsd:jed+1,npz) )
!allocate( delpc(isd:ied, jsd:jed  ,npz  ) )
!                    call init_ijk_mem(isd,ied, jsd,jed, npz, delpc, 0._FVPRC)
!allocate( ut(isd:ied, jsd:jed, npz) )
!                    call init_ijk_mem(isd,ied, jsd,jed, npz, ut, 0._FVPRC)
!allocate( vt(isd:ied, jsd:jed, npz) )
!                    call init_ijk_mem(isd,ied, jsd,jed, npz, vt, 0._FVPRC)
      IF (.NOT.hydrostatic) THEN
!allocate( zh(isd:ied, jsd:jed, npz+1) )
!              call init_ijk_mem(isd,ied, jsd,jed, npz+1, zh, huge_r )
!allocate ( pk3(isd:ied,jsd:jed,npz+1) )
        arg1 = npz + 1
        CALL PUSHREALARRAY(pk3, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+&
&                     1)*(npz+1)/8)
        CALL INIT_IJK_MEM(isd, ied, jsd, jed, arg1, pk3, huge_r)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (beta .GT. near0) THEN
!allocate( du(isd:ied,  jsd:jed+1,npz) )
        arg1 = jed + 1
        CALL INIT_IJK_MEM(isd, ied, jsd, arg1, npz, du, 0._FVPRC)
!allocate( dv(isd:ied+1,jsd:jed,  npz) )
        arg1 = ied + 1
        CALL INIT_IJK_MEM(isd, arg1, jsd, jed, npz, dv, 0._FVPRC)
        CALL PUSHCONTROL2B_FV(0)
      ELSE
        CALL PUSHCONTROL2B_FV(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B_FV(2)
    END IF
! Empty the "flux capacitors"
    arg1 = ie + 1
    CALL PUSHREALARRAY(mfx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)*npz/8&
&                )
    CALL INIT_IJK_MEM(is, arg1, js, je, npz, mfx, 0._FVPRC)
    arg1 = je + 1
    CALL PUSHREALARRAY(mfy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)*npz/8&
&                )
    CALL INIT_IJK_MEM(is, ie, js, arg1, npz, mfy, 0._FVPRC)
    arg1 = ie + 1
    CALL PUSHREALARRAY(cx, 8*(bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*npz/&
&                 8)
    CALL INIT_IJK_MEM(is, arg1, jsd, jed, npz, cx, 0._FVPRC)
    arg1 = je + 1
    CALL PUSHREALARRAY(cy, 8*(bd%ied-bd%isd+1)*(bd%je-bd%js+2)*npz/&
&                 8)
    CALL INIT_IJK_MEM(isd, ied, js, arg1, npz, cy, 0._FVPRC)
    IF (flagstruct%d_con .GT. 1.0e-5) THEN
!allocate( heat_source(isd:ied, jsd:jed, npz) )
      heat_source = 0.0
      CALL INIT_IJK_MEM(isd, ied, jsd, jed, npz, heat_source, 0._FVPRC)
    END IF
    IF (flagstruct%convert_ke .OR. flagstruct%vtdm4 .GT. 1.e-3) THEN
      CALL PUSHCONTROL2B_FV(0)
      n_con = npz
    ELSE IF (flagstruct%d2_bg_k1 .LT. 1.e-3) THEN
      CALL PUSHCONTROL2B_FV(1)
      n_con = 0
    ELSE IF (flagstruct%d2_bg_k2 .LT. 1.e-3) THEN
      CALL PUSHCONTROL2B_FV(2)
      n_con = 1
    ELSE
      CALL PUSHCONTROL2B_FV(2)
      n_con = 2
    END IF
!-----------------------------------------------------
    DO it=1,n_split
!-----------------------------------------------------
!#ifdef ROT3
!     call start_group_halo_update(i_pack(8), i_pack(8+12), u, v, domain, gridtype=DGRID_NE)
!#endif
      IF (flagstruct%breed_vortex_inline .OR. it .EQ. n_split) THEN
        remap_step = .true.
      ELSE
        remap_step = .false.
      END IF
!     if ( flagstruct%fv_debug ) then
!          if(is_master()) write(*,*) 'n_split loop, it=', it
!          if ( .not. flagstruct%hydrostatic )    &
!          call prt_mxm('delz',  delz, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!     endif
      IF (nq .GT. 0) THEN
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
!if (fv_timing_onoff) call timing_on('COMM_TRACER')
        IF (flagstruct%inline_q) THEN
          CALL PUSHREALARRAY(q, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+&
&                       1)*npz*nq/8)
          CALL START_GROUP_HALO_UPDATE(i_pack(10), i_pack(10+12), q, &
&                                domain)
          CALL PUSHCONTROL2B_FV(0)
        ELSE IF (it .EQ. n_split) THEN
          CALL PUSHREALARRAY(q, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+&
&                       1)*npz*nq/8)
          CALL START_GROUP_HALO_UPDATE(i_pack(10), i_pack(10+12), q, &
&                                domain)
          CALL PUSHCONTROL2B_FV(1)
        ELSE
          CALL PUSHREALARRAY(q, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+&
&                       1)*npz*nq/8)
          CALL PUSHCONTROL2B_FV(2)
        END IF
      ELSE
        CALL PUSHCONTROL2B_FV(3)
      END IF
!if (fv_timing_onoff) call timing_off('COMM_TRACER')
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
      IF (.NOT.hydrostatic) THEN
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
        CALL PUSHREALARRAY(w, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                     *npz/8)
        CALL START_GROUP_HALO_UPDATE(i_pack(7), i_pack(7+12), w, domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
        IF (it .EQ. 1) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,gz,zs,delz)
          DO j=js,je
            DO i=is,ie
              CALL PUSHREALARRAY(gz(i, j, npz+1))
              gz(i, j, npz+1) = zs(i, j)
            END DO
            DO k=npz,1,-1
              DO i=is,ie
                CALL PUSHREALARRAY(gz(i, j, k))
                gz(i, j, k) = gz(i, j, k+1) - delz(i, j, k)
              END DO
            END DO
          END DO
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
          CALL PUSHREALARRAY(gz, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd&
&                       +1)*(npz+1)/8)
          CALL START_GROUP_HALO_UPDATE(i_pack(5), i_pack(5+12), gz, &
&                                domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
          CALL PUSHCONTROL2B_FV(0)
        ELSE
!$OMP parallel do default(none) shared(is,ie,js,je,npz,gz,zs,delz)
          DO j=js,je
            DO i=is,ie
              CALL PUSHREALARRAY(gz(i, j, npz+1))
            END DO
            DO k=npz,1,-1
              DO i=is,ie
                CALL PUSHREALARRAY(gz(i, j, k))
              END DO
            END DO
          END DO
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
          CALL PUSHREALARRAY(gz, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd&
&                       +1)*(npz+1)/8)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
          CALL PUSHCONTROL2B_FV(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B_FV(2)
      END IF
!#ifdef SW_DYNAMICS
!     if (test_case>1) then
!     if (test_case==9) call case9_forcing1(phis, time_total)
!#endif
      IF (it .EQ. 1) THEN
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
        CALL PUSHREALARRAY(beta_d)
        beta_d = 0.
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHREALARRAY(beta_d)
        beta_d = beta
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (it .EQ. n_split .AND. end_step) THEN
        IF (flagstruct%use_old_omega) THEN
!allocate ( pem(is-1:ie+1,npz+1,js-1:je+1) )
          pem = 0.0
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pem,delp,ptop)
          DO j=js-1,je+1
            DO i=is-1,ie+1
              pem(i, 1, j) = ptop
            END DO
            DO k=1,npz
              DO i=is-1,ie+1
                pem(i, k+1, j) = pem(i, k, j) + delp(i, j, k)
              END DO
            END DO
          END DO
          CALL PUSHCONTROL2B_FV(0)
        ELSE
          CALL PUSHCONTROL2B_FV(1)
        END IF
        last_step = .true.
      ELSE
        IF (flagstruct%use_old_omega) THEN
          CALL PUSHCONTROL2B_FV(2)
        ELSE
          CALL PUSHCONTROL2B_FV(3)
        END IF
        last_step = .false.
      END IF
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!if (fv_timing_onoff) call timing_on('  c_sw')
!$OMP parallel do default(none) shared(npz,isd,jsd,delpc,delp,ptc,pt,u,v,w,uc,vc,ua,va, &
!$OMP                                  omga,ut,vt,divgd,flagstruct,dt2,hydrostatic,bd,  &
!$OMP                                  gridstruct)
      DO k=1,npz
        CALL C_SW_FWD(delpc(isd:ied, jsd:jed, k), delp(isd:ied, jsd:jed&
&               , k), ptc(isd:ied, jsd:jed, k), pt(isd:ied, jsd:jed, k)&
&               , u(isd:ied, jsd:jed+1, k), v(isd:ied+1, jsd:jed, k), w(&
&               isd:ied, jsd:jed, k), uc(isd:ied+1, jsd:jed, k), vc(isd:&
&               ied, jsd:jed+1, k), ua(isd:ied, jsd:jed, k), va(isd:ied&
&               , jsd:jed, k), omga(isd:ied, jsd:jed, k), ut(isd:ied, &
&               jsd:jed, k), vt(isd:ied, jsd:jed, k), divgd(isd:ied+1, &
&               jsd:jed+1, k), flagstruct%nord, dt2, hydrostatic, .true.&
&               , bd, gridstruct, flagstruct)
      END DO
!if (fv_timing_onoff) call timing_off('  c_sw')
      IF (flagstruct%nord .GT. 0) THEN
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
        CALL START_GROUP_HALO_UPDATE(i_pack(3), i_pack(3+12), divgd, &
&                              domain, position=corner)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
! end hydro check
      IF (hydrostatic) THEN
        CALL GEOPK_FWD(ptop, pe, peln, delpc, pkc, gz, phis, ptc, q_con&
&                , pkz, npz, akap, .true., gridstruct%nested, .false., &
&                npx, npy, flagstruct%a2b_ord, bd)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        IF (it .EQ. 1) THEN
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!$OMP parallel do default(none) shared(isd,ied,jsd,jed,npz,zh,gz)
          DO k=1,npz+1
            DO j=jsd,jed
              DO i=isd,ied
! Save edge heights for update_dz_d
                zh(i, j, k) = gz(i, j, k)
              END DO
            END DO
          END DO
          DO k=1,npz+1
            DO j=jsd,jed
              DO i=isd,ied
                CALL PUSHREALARRAY(gz(i, j, k))
              END DO
            END DO
          END DO
          CALL PUSHCONTROL1B_FV(0)
        ELSE
!$OMP parallel do default(none) shared(isd,ied,jsd,jed,npz,zh,gz)
          DO k=1,npz+1
            DO j=jsd,jed
              DO i=isd,ied
                CALL PUSHREALARRAY(gz(i, j, k))
                gz(i, j, k) = zh(i, j, k)
              END DO
            END DO
          END DO
          CALL PUSHCONTROL1B_FV(1)
        END IF
!if (fv_timing_onoff) call timing_on('  UPDATE_DZ_C')
        CALL UPDATE_DZ_C_FWD(is, ie, js, je, npz, ng, dt2, dp_ref, zs, &
&                      gridstruct%area, ut, vt, gz, ws3, npx, npy, &
&                      gridstruct%sw_corner, gridstruct%se_corner, &
&                      gridstruct%ne_corner, gridstruct%nw_corner, bd, &
&                      gridstruct%grid_type)
!if (fv_timing_onoff) call timing_off('  UPDATE_DZ_C')
!if (fv_timing_onoff) call timing_on('  Riem_Solver')
        CALL RIEM_SOLVER_C_FWD(ms, dt2, is, ie, js, je, npz, ng, akap, &
&                        cappa, cp, ptop, phis, omga, ptc, q_con, delpc&
&                        , gz, pkc, ws3, flagstruct%p_fac, flagstruct%&
&                        a_imp, flagstruct%scale_z)
!if (fv_timing_onoff) call timing_off('  Riem_Solver')
!#ifndef SW_DYNAMICS
!           if (gridstruct%nested) then
!                 call nested_grid_BC_apply_intT(delpc, &
!                      0, 0, npx, npy, npz, bd, split_timestep_BC+0.5, split, &
!                      var_east_t0=neststruct%delp_BC%east_t0, &
!                      var_west_t0=neststruct%delp_BC%west_t0, &
!                      var_north_t0=neststruct%delp_BC%north_t0, &
!                      var_south_t0=neststruct%delp_BC%south_t0, &
!                      var_east_t1=neststruct%delp_BC%east_t1, &
!                      var_west_t1=neststruct%delp_BC%west_t1, &
!                      var_north_t1=neststruct%delp_BC%north_t1, &
!                      var_south_t1=neststruct%delp_BC%south_t1, &
!                      bctype=neststruct%nestbctype, &
!                      nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!                 call nested_grid_BC_apply_intT(ptc, &
!                      0, 0, npx, npy, npz, bd, split_timestep_BC+0.5, split, &
!                      var_east_t0=neststruct%pt_BC%east_t0, &
!                      var_west_t0=neststruct%pt_BC%west_t0, &
!                      var_north_t0=neststruct%pt_BC%north_t0, &
!                      var_south_t0=neststruct%pt_BC%south_t0, &
!                      var_east_t1=neststruct%pt_BC%east_t1, &
!                      var_west_t1=neststruct%pt_BC%west_t1, &
!                      var_north_t1=neststruct%pt_BC%north_t1, &
!                      var_south_t1=neststruct%pt_BC%south_t1, &
!                      bctype=neststruct%nestbctype, &
!                      nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!                 call nested_grid_BC_apply_intT(delz, &
!                      0, 0, npx, npy, npz, bd, split_timestep_BC+0.5, split, &
!                      var_east_t0=neststruct%delz_BC%east_t0, &
!                      var_west_t0=neststruct%delz_BC%west_t0, &
!                      var_north_t0=neststruct%delz_BC%north_t0, &
!                      var_south_t0=neststruct%delz_BC%south_t0, &
!                      var_east_t1=neststruct%delz_BC%east_t1, &
!                      var_west_t1=neststruct%delz_BC%west_t1, &
!                      var_north_t1=neststruct%delz_BC%north_t1, &
!                      var_south_t1=neststruct%delz_BC%south_t1, &
!                      bctype=neststruct%nestbctype, &
!                      nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!!!$         do k=1,npz
!!!$            call extrapolation_BC( delz(:,:,k), 0, 0, npx, npy, bd)
!!!$            call extrapolation_BC(delpc(:,:,k), 0, 0, npx, npy, bd)
!!!$            call extrapolation_BC(  ptc(:,:,k), 0, 0, npx, npy, bd)
!!!$         end do
!
!
!              !Compute gz/pkc
!              !NOTE: nominally only need to compute quantities one out in the halo for p_grad_c
!              !(instead of entire halo)
!              call geopk_halo_nh(ptop, grav, akap, cp, delpc, delz, ptc, phis, pkc, gz, pk3, &
!                   npx, npy, npz, gridstruct%nested, .false., .false., .false., bd)
!
!           endif
!#endif
        CALL PUSHCONTROL1B_FV(1)
      END IF
      CALL P_GRAD_C_FWD(dt2, npz, delpc, pkc, gz, uc, vc, bd, gridstruct&
&                 %rdxc, gridstruct%rdyc, hydrostatic)
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
      CALL START_GROUP_HALO_UPDATE(i_pack(9), i_pack(9+12), uc, vc, &
&                            domain, gridtype=cgrid_ne)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!#ifdef SW_DYNAMICS
!      if (test_case==9) call case9_forcing2(phis)
!      endif !test_case>1
!#endif
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!      if (gridstruct%nested) then
!         !On a nested grid we have to do SOMETHING with uc and vc in
!         ! the boundary halo, particularly at the corners of the
!         ! domain and of each processor element. We must either
!         ! apply an interpolated BC, or extrapolate into the
!         ! boundary halo
!         ! NOTE: 
!         !The update_domains calls for uc and vc need to go BEFORE the BCs to ensure cross-restart
!         !bitwise-consistent solutions when doing the spatial extrapolation; should not make a
!         !difference for interpolated BCs from the coarse grid.
!
!
!!!$         do k=1,npz
!!!$            call extrapolation_BC(uc(:,:,k), 1, 0, npx, npy, bd)
!!!$            call extrapolation_BC(vc(:,:,k), 0, 1, npx, npy, bd)
!!!$         end do
!!!$
!
!
!         !vc
!            call nested_grid_BC_apply_intT(vc, &
!                 0, 1, npx, npy, npz, bd, split_timestep_bc+0.5, split, & 
!                 var_east_t0=neststruct%vc_BC%east_t0, &
!                 var_west_t0=neststruct%vc_BC%west_t0, &
!                 var_north_t0=neststruct%vc_BC%north_t0, &
!                 var_south_t0=neststruct%vc_BC%south_t0, &
!                 var_east_t1=neststruct%vc_BC%east_t1, &
!                 var_west_t1=neststruct%vc_BC%west_t1, &
!                 var_north_t1=neststruct%vc_BC%north_t1, &
!                 var_south_t1=neststruct%vc_BC%south_t1, &
!                 bctype=neststruct%nestbctype, &
!                 nsponge=neststruct%nsponge, s_weight=neststruct%s_weight  )
!
!            !uc
!            call nested_grid_BC_apply_intT(uc, &
!                 1, 0, npx, npy, npz, bd, split_timestep_bc+0.5, split, &
!                 var_east_t0=neststruct%uc_BC%east_t0, &
!                 var_west_t0=neststruct%uc_BC%west_t0, &
!                 var_north_t0=neststruct%uc_BC%north_t0, &
!                 var_south_t0=neststruct%uc_BC%south_t0, &
!                 var_east_t1=neststruct%uc_BC%east_t1, &
!                 var_west_t1=neststruct%uc_BC%west_t1, &
!                 var_north_t1=neststruct%uc_BC%north_t1, &
!                 var_south_t1=neststruct%uc_BC%south_t1, &
!                 bctype=neststruct%nestbctype, &
!                 nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!      end if
!    if ( flagstruct%inline_q ) then
!         if (gridstruct%nested) then
!            do iq=1,nq
!                  call nested_grid_BC_apply_intT(q(isd:ied,jsd:jed,:,iq), &
!                       0, 0, npx, npy, npz, bd, split_timestep_BC+1, split, &
!                       var_east_t0=neststruct%q_BC(iq)%east_t0, &
!                       var_west_t0=neststruct%q_BC(iq)%west_t0, &
!                       var_north_t0=neststruct%q_BC(iq)%north_t0, &
!                       var_south_t0=neststruct%q_BC(iq)%south_t0, &
!                       var_east_t1=neststruct%q_BC(iq)%east_t1, &
!                       var_west_t1=neststruct%q_BC(iq)%west_t1, &
!                       var_north_t1=neststruct%q_BC(iq)%north_t1, &
!                       var_south_t1=neststruct%q_BC(iq)%south_t1, &
!                       bctype=neststruct%nestbctype, &
!                       nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!            end do
!         end if
!      endif
!if (fv_timing_onoff) call timing_on('  d_sw')
!$OMP parallel do default(none) shared(npz,flagstruct,nord_v,pfull,damp_vt,hydrostatic,last_step, &
!$OMP                                  is,ie,js,je,isd,ied,jsd,jed,omga,delp,gridstruct,npx,npy,  &
!$OMP                                  ng,zh,vt,ptc,pt,u,v,w,uc,vc,ua,va,divgd,mfx,mfy,cx,cy,     &
!$OMP                                  crx,cry,xfx,yfx,q_con,zvir,sphum,nq,q,dt,bd,rdt,iep1,jep1, &
!$OMP                                  heat_source)                                               &
!$OMP                          private(nord_k, nord_w, nord_t, damp_k, damp_w, damp_t, d2_divg,   &
!$OMP                                  hord_m, hord_v, hord_t, hord_p, wk, heat_s, d_con_k, z_rat)
      DO k=1,npz
        hord_m = flagstruct%hord_mt
        hord_t = flagstruct%hord_tm
        hord_v = flagstruct%hord_vt
        hord_p = flagstruct%hord_dp
        CALL PUSHINTEGER(hord_m_pert)
        hord_m_pert = flagstruct%hord_mt_pert
        CALL PUSHINTEGER(hord_t_pert)
        hord_t_pert = flagstruct%hord_tm_pert
        CALL PUSHINTEGER(hord_v_pert)
        hord_v_pert = flagstruct%hord_vt_pert
        CALL PUSHINTEGER(hord_p_pert)
        hord_p_pert = flagstruct%hord_dp_pert
        CALL PUSHINTEGER(nord_k)
        nord_k = flagstruct%nord
        CALL PUSHINTEGER(nord_k_pert)
        nord_k_pert = flagstruct%nord_pert
        IF (2 .GT. flagstruct%nord) THEN
          CALL PUSHINTEGER(nord_v(k))
          nord_v(k) = flagstruct%nord
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHINTEGER(nord_v(k))
          nord_v(k) = 2
          CALL PUSHCONTROL1B_FV(1)
        END IF
        IF (2 .GT. flagstruct%nord_pert) THEN
          CALL PUSHINTEGER(nord_v_pert(k))
          nord_v_pert(k) = flagstruct%nord_pert
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHINTEGER(nord_v_pert(k))
          nord_v_pert(k) = 2
          CALL PUSHCONTROL1B_FV(1)
        END IF
        CALL PUSHREALARRAY(damp_k)
        damp_k = flagstruct%dddmp
        CALL PUSHREALARRAY(damp_k_pert)
        damp_k_pert = flagstruct%dddmp_pert
        y1 = flagstruct%d2_bg*(1.-3.*TANH(0.1*LOG(pfull(k)/pfull(npz))))
        IF (0.20 .GT. y1) THEN
          CALL PUSHREALARRAY(d2_divg)
          d2_divg = y1
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHREALARRAY(d2_divg)
          d2_divg = 0.20
          CALL PUSHCONTROL1B_FV(1)
        END IF
        y2 = flagstruct%d2_bg_pert*(1.-3.*TANH(0.1*LOG(pfull(k)/pfull(&
&         npz))))
        IF (0.20 .GT. y2) THEN
          CALL PUSHREALARRAY(d2_divg_pert)
          d2_divg_pert = y2
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHREALARRAY(d2_divg_pert)
          d2_divg_pert = 0.20
          CALL PUSHCONTROL1B_FV(1)
        END IF
        d_con_k = flagstruct%d_con
        IF (flagstruct%do_vort_damp) THEN
! for delp, delz, and vorticity
          CALL PUSHREALARRAY(damp_vt(k))
          damp_vt(k) = flagstruct%vtdm4
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHREALARRAY(damp_vt(k))
          damp_vt(k) = 0.
          CALL PUSHCONTROL1B_FV(1)
        END IF
        IF (flagstruct%do_vort_damp_pert) THEN
! for delp, delz, and vorticity
          CALL PUSHREALARRAY(damp_vt_pert(k))
          damp_vt_pert(k) = flagstruct%vtdm4_pert
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHREALARRAY(damp_vt_pert(k))
          damp_vt_pert(k) = 0.
          CALL PUSHCONTROL1B_FV(1)
        END IF
        CALL PUSHINTEGER(nord_w)
        nord_w = nord_v(k)
        CALL PUSHINTEGER(nord_t)
        nord_t = nord_v(k)
        CALL PUSHINTEGER(nord_t_pert)
        nord_t_pert = nord_v_pert(k)
        damp_w = damp_vt(k)
        damp_t = damp_vt(k)
        CALL PUSHREALARRAY(damp_t_pert)
        damp_t_pert = damp_vt_pert(k)
        IF (npz .EQ. 1 .OR. flagstruct%n_sponge .LT. 0) THEN
          CALL PUSHCONTROL3B_FV(3)
          d2_divg = flagstruct%d2_bg
          d2_divg_pert = flagstruct%d2_bg_pert
        ELSE IF (flagstruct%n_sponge .EQ. 0) THEN
! New Del-2 Sponge layer: formulation
! Sponge layers with del-2 damping on divergence, vorticity, w, z, and air mass (delp).
! (no damping of potential temperature in sponge layers)
          IF (k .EQ. 1) THEN
            damp_k = 0.
            damp_k_pert = 0.
            nord_k = 0
            nord_k_pert = 0
            IF (flagstruct%d2_bg .LT. flagstruct%d2_bg_k1) THEN
              d2_divg = flagstruct%d2_bg_k1
            ELSE
              d2_divg = flagstruct%d2_bg
            END IF
            IF (flagstruct%d2_bg_pert .LT. flagstruct%d2_bg_k1) THEN
              d2_divg_pert = flagstruct%d2_bg_k1
            ELSE
              d2_divg_pert = flagstruct%d2_bg_pert
            END IF
! for delp, delz, and vorticity, sponger layers
            CALL PUSHINTEGER(nord_v(k))
            nord_v(k) = 0
! for delp, delz, and vorticity, sponger layers
            CALL PUSHINTEGER(nord_v_pert(k))
            nord_v_pert(k) = 0
!#ifndef HIWPP
            CALL PUSHREALARRAY(damp_vt(k))
            damp_vt(k) = d2_divg
            CALL PUSHREALARRAY(damp_vt_pert(k))
            damp_vt_pert(k) = d2_divg_pert
!#endif
            nord_w = 0
            damp_w = d2_divg
            CALL PUSHCONTROL2B_FV(0)
          ELSE IF (k .EQ. 2) THEN
            damp_k = 0.
            damp_k_pert = 0.
            nord_k = 0
            nord_k_pert = 0
            IF (flagstruct%d2_bg .LT. flagstruct%d2_bg_k2) THEN
              d2_divg = flagstruct%d2_bg_k2
            ELSE
              d2_divg = flagstruct%d2_bg
            END IF
            IF (flagstruct%d2_bg_pert .LT. flagstruct%d2_bg_k2) THEN
              d2_divg_pert = flagstruct%d2_bg_k2
            ELSE
              d2_divg_pert = flagstruct%d2_bg_pert
            END IF
            CALL PUSHINTEGER(nord_v(k))
            nord_v(k) = 0
            CALL PUSHINTEGER(nord_v_pert(k))
            nord_v_pert(k) = 0
!#ifndef HIWPP
            CALL PUSHREALARRAY(damp_vt(k))
            damp_vt(k) = d2_divg
            CALL PUSHREALARRAY(damp_vt_pert(k))
            damp_vt_pert(k) = d2_divg_pert
!#endif
            nord_w = 0
            damp_w = d2_divg
            CALL PUSHCONTROL2B_FV(1)
          ELSE IF (k .EQ. 3 .AND. flagstruct%d2_bg_k2 .GT. 0.05) THEN
            damp_k = 0.
            damp_k_pert = 0.
            nord_k = 0
            nord_k_pert = 0
            IF (flagstruct%d2_bg .LT. 0.2*flagstruct%d2_bg_k2) THEN
              d2_divg = 0.2*flagstruct%d2_bg_k2
            ELSE
              d2_divg = flagstruct%d2_bg
            END IF
            IF (flagstruct%d2_bg_pert .LT. 0.2*flagstruct%d2_bg_k2) THEN
              d2_divg_pert = 0.2*flagstruct%d2_bg_k2
            ELSE
              d2_divg_pert = flagstruct%d2_bg_pert
            END IF
            CALL PUSHINTEGER(nord_v(k))
            nord_v(k) = 0
            CALL PUSHINTEGER(nord_v_pert(k))
            nord_v_pert(k) = 0
!#ifndef HIWPP
            CALL PUSHREALARRAY(damp_vt(k))
            damp_vt(k) = d2_divg
            CALL PUSHREALARRAY(damp_vt_pert(k))
            damp_vt_pert(k) = d2_divg_pert
!#endif
            nord_w = 0
            damp_w = d2_divg
            CALL PUSHCONTROL2B_FV(2)
          ELSE
            CALL PUSHCONTROL2B_FV(3)
          END IF
          IF (damp_vt(k) .LT. 0.01 .AND. nord_k .GT. 0) THEN
            CALL PUSHCONTROL3B_FV(2)
            d_con_k = 0.
          ELSE
            CALL PUSHCONTROL3B_FV(2)
          END IF
        ELSE IF (k .LE. flagstruct%n_sponge .AND. npz .GT. 16) THEN
! Apply first order scheme for damping the sponge layer
          hord_m = 1
          hord_m_pert = 1
          hord_v = 1
          hord_v_pert = 1
          hord_t = 1
          hord_t_pert = 1
          hord_p = 1
          hord_p_pert = 1
          nord_k = 0
          nord_k_pert = 0
          damp_k = flagstruct%damp_k_k1
          damp_k_pert = flagstruct%damp_k_k1
          IF (0.20 .GT. flagstruct%d2_bg_k1*flagstruct%d2_bg) THEN
            d2_divg = flagstruct%d2_bg_k1*flagstruct%d2_bg
          ELSE
            d2_divg = 0.20
          END IF
          IF (0.20 .GT. flagstruct%d2_bg_k1*flagstruct%d2_bg_pert) THEN
            d2_divg_pert = flagstruct%d2_bg_k1*flagstruct%d2_bg_pert
          ELSE
            d2_divg_pert = 0.20
          END IF
          IF (flagstruct%d2_divg_max_k1 .LT. d2_divg) THEN
            d2_divg = d2_divg
          ELSE
            d2_divg = flagstruct%d2_divg_max_k1
          END IF
          IF (flagstruct%d2_divg_max_k1 .LT. d2_divg_pert) THEN
            CALL PUSHCONTROL3B_FV(4)
            d2_divg_pert = d2_divg_pert
          ELSE
            CALL PUSHCONTROL3B_FV(4)
            d2_divg_pert = flagstruct%d2_divg_max_k1
          END IF
        ELSE IF (k .EQ. flagstruct%n_sponge + 1 .AND. npz .GT. 24) THEN
          hord_v = 2
          hord_v_pert = 1
          hord_t = 2
          hord_t_pert = 1
          hord_p = 2
          hord_p_pert = 1
          IF (0 .LT. flagstruct%nord - 1) THEN
            nord_k = flagstruct%nord - 1
          ELSE
            nord_k = 0
          END IF
          IF (0 .LT. flagstruct%nord_pert - 1) THEN
            nord_k_pert = flagstruct%nord_pert - 1
          ELSE
            nord_k_pert = 0
          END IF
          IF (0.20 .GT. flagstruct%d2_bg_k2*flagstruct%d2_bg) THEN
            d2_divg = flagstruct%d2_bg_k2*flagstruct%d2_bg
          ELSE
            d2_divg = 0.20
          END IF
          IF (0.20 .GT. flagstruct%d2_bg_k2*flagstruct%d2_bg_pert) THEN
            d2_divg_pert = flagstruct%d2_bg_k2*flagstruct%d2_bg_pert
          ELSE
            d2_divg_pert = 0.20
          END IF
          IF (flagstruct%d2_divg_max_k2 .LT. d2_divg) THEN
            d2_divg = d2_divg
          ELSE
            d2_divg = flagstruct%d2_divg_max_k2
          END IF
          IF (flagstruct%d2_divg_max_k2 .LT. d2_divg_pert) THEN
            d2_divg_pert = d2_divg_pert
          ELSE
            d2_divg_pert = flagstruct%d2_divg_max_k2
          END IF
          IF (flagstruct%nord .GT. 1) THEN
            damp_k = 0.
          ELSE
            damp_k = flagstruct%damp_k_k2
          END IF
          IF (flagstruct%nord_pert .GT. 1) THEN
            CALL PUSHCONTROL3B_FV(1)
            damp_k_pert = 0.
          ELSE
            CALL PUSHCONTROL3B_FV(1)
            damp_k_pert = flagstruct%damp_k_k2
          END IF
        ELSE
          CALL PUSHCONTROL3B_FV(0)
        END IF
        IF (damp_k .LT. flagstruct%dddmp) THEN
          damp_k = flagstruct%dddmp
        ELSE
          damp_k = damp_k
        END IF
        IF (damp_k_pert .LT. flagstruct%dddmp_pert) THEN
          damp_k_pert = flagstruct%dddmp_pert
        ELSE
          damp_k_pert = damp_k_pert
        END IF
        IF (hydrostatic .AND. (.NOT.flagstruct%use_old_omega)) THEN
          IF (last_step) THEN
! Average horizontal "convergence" to cell center
            DO j=js,je
              DO i=is,ie
                CALL PUSHREALARRAY(omga(i, j, k))
                omga(i, j, k) = delp(i, j, k)
              END DO
            END DO
            CALL PUSHCONTROL2B_FV(0)
          ELSE IF (.NOT.last_step .AND. end_step) THEN
            DO j=js,je
              DO i=is,ie
                CALL PUSHREALARRAY(omga(i, j, k))
              END DO
            END DO
            CALL PUSHCONTROL2B_FV(1)
          ELSE
            CALL PUSHCONTROL2B_FV(2)
          END IF
        ELSE
          CALL PUSHCONTROL2B_FV(3)
        END IF
!--- external mode divergence damping ---
        IF (flagstruct%d_ext .GT. 0.) THEN
          CALL A2B_ORD2_FWD(delp(isd, jsd, k), wk, gridstruct, npx, npy&
&                     , is, ie, js, je, ng, .false.)
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
        IF (.NOT.hydrostatic .AND. flagstruct%do_f3d) THEN
! Correction factor for 3D Coriolis force
          DO j=jsd,jed
            DO i=isd,ied
              z_rat(i, j) = 1. + (zh(i, j, k)+zh(i, j, k+1))/radius
            END DO
          END DO
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
        CALL D_SW_FWD(vt(isd:ied, jsd:jed, k), vt_tj(isd:ied, jsd:jed, k&
&               ), delp(isd:ied, jsd:jed, k), ptc(isd:ied, jsd:jed, k), &
&               pt(isd:ied, jsd:jed, k), u(isd:ied, jsd:jed+1, k), v(isd&
&               :ied+1, jsd:jed, k), w(isd:ied, jsd:jed, k), uc(isd:ied+&
&               1, jsd:jed, k), vc(isd:ied, jsd:jed+1, k), ua(isd:ied, &
&               jsd:jed, k), va(isd:ied, jsd:jed, k), divgd(isd:ied+1, &
&               jsd:jed+1, k), mfx(is:ie+1, js:je, k), mfy(is:ie, js:je+&
&               1, k), cx(is:ie+1, jsd:jed, k), cy(isd:ied, js:je+1, k)&
&               , crx(is:ie+1, jsd:jed, k), cry(isd:ied, js:je+1, k), &
&               xfx(is:ie+1, jsd:jed, k), yfx(isd:ied, js:je+1, k), &
&               q_con(isd:isd, jsd:jsd, 1), z_rat(isd:ied, jsd:jed), &
&               heat_s, zvir, sphum, nq, q, k, npz, flagstruct%inline_q&
&               , dt, flagstruct%hord_tr, hord_m, hord_v, hord_t, hord_p&
&               , flagstruct%hord_tr_pert, hord_m_pert, hord_v_pert, &
&               hord_t_pert, hord_p_pert, nord_k, nord_v(k), nord_w, &
&               nord_t, damp_k, d2_divg, flagstruct%d4_bg, damp_vt(k), &
&               damp_w, damp_t, d_con_k, flagstruct%split_damp, &
&               nord_k_pert, nord_v_pert(k), nord_w_pert, nord_t_pert, &
&               damp_k_pert, d2_divg_pert, flagstruct%d4_bg_pert, &
&               damp_vt_pert(k), damp_w_pert, damp_t_pert, d_con_k_pert&
&               , hydrostatic, gridstruct, flagstruct, bd)
        IF (hydrostatic .AND. (.NOT.flagstruct%use_old_omega)) THEN
          IF (last_step) THEN
! Average horizontal "convergence" to cell center
            DO j=js,je
              DO i=is,ie
                CALL PUSHREALARRAY(omga(i, j, k))
                omga(i, j, k) = omga(i, j, k)*(xfx(i, j, k)-xfx(i+1, j, &
&                 k)+yfx(i, j, k)-yfx(i, j+1, k))*gridstruct%rarea(i, j)&
&                 *rdt
              END DO
            END DO
            CALL PUSHCONTROL2B_FV(0)
          ELSE IF (.NOT.last_step .AND. end_step) THEN
! Average horizontal "convergence" to cell center
            DO j=js,je
              DO i=is,ie
                CALL PUSHREALARRAY(omga(i, j, k))
              END DO
            END DO
            CALL PUSHCONTROL2B_FV(1)
          ELSE
            CALL PUSHCONTROL2B_FV(2)
          END IF
        ELSE
          CALL PUSHCONTROL2B_FV(3)
        END IF
        IF (flagstruct%d_ext .GT. 0.) THEN
          DO j=js,jep1
            DO i=is,iep1
! delp at cell corners
              CALL PUSHREALARRAY(ptc(i, j, k))
              ptc(i, j, k) = wk(i, j)
            END DO
          END DO
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
        IF (d_con_k .GT. 1.0e-5) THEN
! Average horizontal "convergence" to cell center
          DO j=js,je
            DO i=is,ie
              heat_source(i, j, k) = heat_source(i, j, k) + heat_s(i, j)
            END DO
          END DO
          CALL PUSHCONTROL1B_FV(1)
        ELSE
          CALL PUSHCONTROL1B_FV(0)
        END IF
      END DO
! end openMP k-loop
!if (fv_timing_onoff) call timing_off('  d_sw')
      IF (flagstruct%fill_dp) THEN
        CALL MIX_DP_FWD(hydrostatic, w, delp, pt, npz, ak, bk, .false., &
&                 flagstruct%fv_debug, bd)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
      CALL PUSHREALARRAY(delp, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                   )*npz/8)
      CALL START_GROUP_HALO_UPDATE(i_pack(1), i_pack(1+12), delp, domain&
&                           )
      CALL PUSHREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                   npz/8)
      CALL START_GROUP_HALO_UPDATE(i_pack(2), i_pack(2+12), pt, domain)
!#ifdef USE_COND
!    call start_group_halo_update(i_pack(11), i_pack(11+12), q_con, domain)
!#endif
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
      IF (flagstruct%d_ext .GT. 0.) THEN
        CALL PUSHREALARRAY(d2_divg)
        d2_divg = flagstruct%d_ext*gridstruct%da_min_c
!$OMP parallel do default(none) shared(is,iep1,js,jep1,npz,wk,ptc,divg2,vt,d2_divg)
        DO j=js,jep1
          DO i=is,iep1
            CALL PUSHREALARRAY(wk(i, j))
            wk(i, j) = ptc(i, j, 1)
            divg2(i, j) = wk(i, j)*vt(i, j, 1)
          END DO
          DO k=2,npz
            DO i=is,iep1
              CALL PUSHREALARRAY(wk(i, j))
              wk(i, j) = wk(i, j) + ptc(i, j, k)
              divg2(i, j) = divg2(i, j) + ptc(i, j, k)*vt(i, j, k)
            END DO
          END DO
          DO i=is,iep1
            CALL PUSHREALARRAY(divg2(i, j))
            divg2(i, j) = d2_divg*divg2(i, j)/wk(i, j)
          END DO
        END DO
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        divg2(:, :) = 0.
        CALL PUSHCONTROL1B_FV(1)
      END IF
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
! end hydro check
!#ifdef USE_COND
!     call complete_group_halo_update(i_pack(11), i_pack(11+12), domain)
!#endif
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!    if ( flagstruct%fv_debug ) then
!         if ( .not. flagstruct%hydrostatic )    &
!         call prt_mxm('delz',  delz, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!    endif
      IF (hydrostatic) THEN
        CALL GEOPK_FWD(ptop, pe, peln, delp, pkc, gz, phis, pt, q_con, &
&                pkz, npz, akap, .false., gridstruct%nested, .true., npx&
&                , npy, flagstruct%a2b_ord, bd)
!Want to move this block into the hydro/nonhydro branch above and merge the two if structures
!          if (gridstruct%nested) then
!
!             call nested_grid_BC_apply_intT(delp, &
!                  0, 0, npx, npy, npz, bd, split_timestep_BC+1, split, &
!                  var_east_t0=neststruct%delp_BC%east_t0, &
!                  var_west_t0=neststruct%delp_BC%west_t0, &
!                  var_north_t0=neststruct%delp_BC%north_t0, &
!                  var_south_t0=neststruct%delp_BC%south_t0, &
!                  var_east_t1=neststruct%delp_BC%east_t1, &
!                  var_west_t1=neststruct%delp_BC%west_t1, &
!                  var_north_t1=neststruct%delp_BC%north_t1, &
!                  var_south_t1=neststruct%delp_BC%south_t1, &
!                  bctype=neststruct%nestbctype, &
!                  nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!!#ifndef SW_DYNAMICS
!
!             call nested_grid_BC_apply_intT(pt, &
!                  0, 0, npx, npy, npz, bd, split_timestep_BC+1, split, &
!                  var_east_t0=neststruct%pt_BC%east_t0, &
!                  var_west_t0=neststruct%pt_BC%west_t0, &
!                  var_north_t0=neststruct%pt_BC%north_t0, &
!                  var_south_t0=neststruct%pt_BC%south_t0, &
!                  var_east_t1=neststruct%pt_BC%east_t1, &
!                  var_west_t1=neststruct%pt_BC%west_t1, &
!                  var_north_t1=neststruct%pt_BC%north_t1, &
!                  var_south_t1=neststruct%pt_BC%south_t1, &
!                  bctype=neststruct%nestbctype, &
!                  nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!!#endif
!          end if
        CALL PUSHCONTROL1B_FV(0)
      ELSE
!if (fv_timing_onoff) call timing_on('  UPDATE_DZ')
        CALL UPDATE_DZ_D_FWD(nord_v, damp_vt, flagstruct%hord_tm, &
&                      flagstruct%hord_tm_pert, is, ie, js, je, npz, ng&
&                      , npx, npy, gridstruct%area, gridstruct%rarea, &
&                      dp_ref, zs, zh, crx, cry, xfx, yfx, ws, rdt, &
&                      gridstruct, bd)
!if (fv_timing_onoff) call timing_off('  UPDATE_DZ')
!    if ( flagstruct%fv_debug ) then
!         if ( .not. flagstruct%hydrostatic )    &
!         call prt_mxm('delz updated',  delz, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!    endif
!        if (idiag%id_ws>0 .and. last_step) then
!           call prt_maxmin('WS', ws, is, ie, js, je, 0, 1, 1._FVPRC, master)
!            used=send_data(idiag%id_ws, ws, fv_time)
!        endif
!Want to move this block into the hydro/nonhydro branch above and merge the two if structures
!        if (gridstruct%nested) then
!
!           call nested_grid_BC_apply_intT(delp, &
!                0, 0, npx, npy, npz, bd, split_timestep_BC+1, split, &
!                var_east_t0=neststruct%delp_BC%east_t0, &
!                var_west_t0=neststruct%delp_BC%west_t0, &
!                var_north_t0=neststruct%delp_BC%north_t0, &
!                var_south_t0=neststruct%delp_BC%south_t0, &
!                var_east_t1=neststruct%delp_BC%east_t1, &
!                var_west_t1=neststruct%delp_BC%west_t1, &
!                var_north_t1=neststruct%delp_BC%north_t1, &
!                var_south_t1=neststruct%delp_BC%south_t1, &
!                bctype=neststruct%nestbctype, &
!                nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!!#ifndef SW_DYNAMICS
!
!           call nested_grid_BC_apply_intT(pt, &
!                0, 0, npx, npy, npz, bd, split_timestep_BC+1, split, &
!                var_east_t0=neststruct%pt_BC%east_t0, &
!                var_west_t0=neststruct%pt_BC%west_t0, &
!                var_north_t0=neststruct%pt_BC%north_t0, &
!                var_south_t0=neststruct%pt_BC%south_t0, &
!                var_east_t1=neststruct%pt_BC%east_t1, &
!                var_west_t1=neststruct%pt_BC%west_t1, &
!                var_north_t1=neststruct%pt_BC%north_t1, &
!                var_south_t1=neststruct%pt_BC%south_t1, &
!                bctype=neststruct%nestbctype, &
!                nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!!#endif
!
!        end if
!if (fv_timing_onoff) call timing_on('  Riem_Solver')
        arg10 = beta .LT. -0.1
        CALL RIEM_SOLVER3_FWD(flagstruct%m_split, dt, is, ie, js, je, &
&                       npz, ng, isd, ied, jsd, jed, akap, cappa, cp, &
&                       ptop, zs, q_con, w, delz, pt, delp, zh, pe, pkc&
&                       , pk3, pk, peln, ws, flagstruct%scale_z, &
&                       flagstruct%p_fac, flagstruct%a_imp, flagstruct%&
&                       use_logp, remap_step, arg10)
!if (fv_timing_onoff) call timing_off('  Riem_Solver')
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
        CALL PUSHREALARRAY(zh, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                     )*(npz+1)/8)
        CALL START_GROUP_HALO_UPDATE(i_pack(4), i_pack(4+12), zh, domain&
&                             )
        IF (gridstruct%square_domain) THEN
          CALL PUSHREALARRAY(pkc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%&
&                       jsd+1)*(npz+1)/8)
          CALL START_GROUP_HALO_UPDATE(i_pack(6), i_pack(6+12), pkc, &
&                                domain, whalo=2, ehalo=2, shalo=2, &
&                                nhalo=2)
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHREALARRAY(pkc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%&
&                       jsd+1)*(npz+1)/8)
          CALL START_GROUP_HALO_UPDATE(i_pack(6), i_pack(6+12), pkc, &
&                                domain)
          CALL PUSHCONTROL1B_FV(1)
        END IF
        IF (remap_step) THEN
          CALL PE_HALO_FWD(is, ie, js, je, isd, ied, jsd, jed, npz, ptop&
&                    , pe, delp)
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
        IF (flagstruct%use_logp) THEN
          CALL PLN_HALO_FWD(is, ie, js, je, isd, ied, jsd, jed, npz, &
&                     ptop, pk3, delp)
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PK3_HALO_FWD(is, ie, js, je, isd, ied, jsd, jed, npz, &
&                     ptop, akap, pk3, delp)
          CALL PUSHCONTROL1B_FV(1)
        END IF
!$OMP parallel do default(none) shared(is,ie,js,je,npz,gz,zh,grav)
        DO k=1,npz+1
          DO j=js-2,je+2
            DO i=is-2,ie+2
              CALL PUSHREALARRAY(gz(i, j, k))
              gz(i, j, k) = zh(i, j, k)*grav
            END DO
          END DO
        END DO
        CALL PUSHCONTROL1B_FV(1)
      END IF
!#ifdef SW_DYNAMICS
!      if (test_case > 1) then
!#else
      IF (hydrostatic) THEN
        IF (remap_step) THEN
          CALL PUSHREALARRAY(pk, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)*&
&                       (npz+1)/8)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pk,pkc)
          DO k=1,npz+1
            DO j=js,je
              DO i=is,ie
                pk(i, j, k) = pkc(i, j, k)
              END DO
            END DO
          END DO
          CALL PUSHCONTROL2B_FV(0)
        ELSE
          CALL PUSHREALARRAY(pk, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)*&
&                       (npz+1)/8)
          CALL PUSHCONTROL2B_FV(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B_FV(2)
      END IF
!#endif
!----------------------------
! Compute pressure gradient:
!----------------------------
!if (fv_timing_onoff) call timing_on('  PG_D')
      IF (hydrostatic) THEN
        IF (beta .GT. 0.) THEN
          CALL GRAD1_P_UPDATE_FWD(divg2, u, v, du, dv, pkc, gz, dt, ng, &
&                           gridstruct, bd, npx, npy, npz, ptop, beta_d&
&                           , flagstruct%a2b_ord)
          CALL PUSHCONTROL3B_FV(0)
        ELSE
          CALL ONE_GRAD_P_FWD(u, v, pkc, gz, divg2, delp, dt, ng, &
&                       gridstruct, bd, npx, npy, npz, ptop, hydrostatic&
&                       , flagstruct%a2b_ord, flagstruct%d_ext)
          CALL PUSHCONTROL3B_FV(1)
        END IF
      ELSE IF (beta .GT. 0.) THEN
!#ifndef SW_DYNAMICS
!       if (gridstruct%nested) then
!           call nested_grid_BC_apply_intT(delz, &
!                    0, 0, npx, npy, npz, bd, split_timestep_BC+1., split, &
!                    var_east_t0=neststruct%delz_BC%east_t0, &
!                    var_west_t0=neststruct%delz_BC%west_t0, &
!                    var_north_t0=neststruct%delz_BC%north_t0, &
!                    var_south_t0=neststruct%delz_BC%south_t0, &
!                    var_east_t1=neststruct%delz_BC%east_t1, &
!                    var_west_t1=neststruct%delz_BC%west_t1, &
!                    var_north_t1=neststruct%delz_BC%north_t1, &
!                    var_south_t1=neststruct%delz_BC%south_t1, &
!                    bctype=neststruct%nestbctype, &
!                    nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!            !Compute gz/pkc/pk3; note that now pkc should be nonhydro pert'n pressure
!            call geopk_halo_nh(ptop, grav, akap, cp, delp, delz, pt, phis, pkc, &
!                               gz, pk3, npx, npy, npz, gridstruct%nested, .true., .true., .true., bd)
!
!       endif
!#endif
        CALL SPLIT_P_GRAD_FWD(u, v, du, dv, pkc, gz, delp, pk3, beta_d, &
&                       dt, ng, gridstruct, bd, npx, npy, npz, &
&                       flagstruct%use_logp)
        CALL PUSHCONTROL3B_FV(2)
      ELSE IF (beta .LT. -0.1) THEN
        CALL ONE_GRAD_P_FWD(u, v, pkc, gz, divg2, delp, dt, ng, &
&                     gridstruct, bd, npx, npy, npz, ptop, hydrostatic, &
&                     flagstruct%a2b_ord, flagstruct%d_ext)
        CALL PUSHCONTROL3B_FV(3)
      ELSE
        CALL NH_P_GRAD_FWD(u, v, pkc, gz, delp, pk3, dt, ng, gridstruct&
&                    , bd, npx, npy, npz, flagstruct%use_logp)
        CALL PUSHCONTROL3B_FV(4)
      END IF
!#ifdef ROT3
!       if ( flagstruct%do_f3d ) then
!!$OMP parallel do default(none) shared(is,ie,js,je,npz,ua,gridstruct,w,va,isd,ied,jsd,jed)
!           do k=1,npz
!              do j=js,je
!                 do i=is,ie
!                    ua(i,j,k) = -gridstruct%w00(i,j)*w(i,j,k)
!                 enddo
!              enddo
!              do j=jsd,jed
!                 do i=isd,ied
!                    va(i,j,k) = 0.
!                 enddo
!              enddo
!           enddo
!           call mpp_update_domains(ua, domain, complete=.true.)
!           call update_dwinds_phys(is, ie, js, je, isd, ied, jsd, jed, dt, ua, va, u, v, gridstruct, npx, npy, npz, domain)
!       endif
!#endif
!if (fv_timing_onoff) call timing_off('  PG_D')
!-------------------------------------------------------------------------------------------------------
      IF (flagstruct%breed_vortex_inline) THEN
        IF (.NOT.hydrostatic) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pkz,cappa,kapag,delp,delz,pt,k1k)
          DO k=1,npz
            DO j=js,je
              DO i=is,ie
! Note: pt at this stage is cp*Theta_m
!#ifdef MOIST_CAPPA
!                    pkz(i,j,k) = exp(cappa(i,j,k)/(1.-cappa(i,j,k))*log(kapag*delp(i,j,k)/delz(i,j,k)*pt(i,j,k)) )
!#else
                CALL PUSHREALARRAY(pkz(i, j, k))
                pkz(i, j, k) = EXP(k1k*LOG(kapag*delp(i, j, k)/delz(i, j&
&                 , k)*pt(i, j, k)))
              END DO
            END DO
          END DO
          CALL PUSHCONTROL2B_FV(0)
        ELSE
          CALL PUSHCONTROL2B_FV(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B_FV(2)
      END IF
!#endif
!#if defined (ADA_NUDGE)
!         call breed_slp_inline_ada( it, dt, npz, ak, bk, phis, pe, pk, peln, pkz,     &
!                                delp, u, v, pt, q, flagstruct%nwat, zvir, gridstruct, ks, domain, bd )
!#else
!call breed_slp_inline( it, dt, npz, ak, bk, phis, pe, pk, peln, pkz, delp, u, v, pt, q,    &
!                       flagstruct%nwat, zvir, gridstruct, ks, domain, bd, hydrostatic )
!#endif
!-------------------------------------------------------------------------------------------------------
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
      IF (gridstruct%grid_type .LT. 4 .AND. (.NOT.gridstruct%nested)) &
&     THEN
        IF (it .EQ. n_split) THEN
! Prevent accumulation of rounding errors at overlapped domain edges:
          CALL PUSHREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+&
&                       1)*npz/8)
          CALL PUSHREALARRAY(u, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+&
&                       2)*npz/8)
          CALL MPP_GET_BOUNDARY(u, v, domain, wbuffery=wbuffer, ebuffery&
&                         =ebuffer, sbufferx=sbuffer, nbufferx=nbuffer, &
&                         gridtype=dgrid_ne)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,u,nbuffer,v,ebuffer)
          DO k=1,npz
            DO i=is,ie
              u(i, je+1, k) = nbuffer(i-is+1, k)
            END DO
            DO j=js,je
              v(ie+1, j, k) = ebuffer(j-js+1, k)
            END DO
          END DO
          CALL PUSHCONTROL2B_FV(0)
        ELSE
! Prevent accumulation of rounding errors at overlapped domain edges:
          CALL PUSHREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+&
&                       1)*npz/8)
          CALL PUSHREALARRAY(u, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+&
&                       2)*npz/8)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,u,nbuffer,v,ebuffer)
          CALL PUSHCONTROL2B_FV(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B_FV(2)
      END IF
!#ifndef ROT3
      IF (it .NE. n_split) THEN
        CALL PUSHREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)&
&                     *npz/8)
        CALL PUSHREALARRAY(u, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)&
&                     *npz/8)
        CALL START_GROUP_HALO_UPDATE(i_pack(8), i_pack(8+12), u, v, &
&                              domain, gridtype=dgrid_ne)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)&
&                     *npz/8)
        CALL PUSHREALARRAY(u, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)&
&                     *npz/8)
        CALL PUSHCONTROL1B_FV(1)
      END IF
!#ifdef SW_DYNAMICS
!#else
      IF (last_step .AND. hydrostatic) THEN
        IF (flagstruct%use_old_omega) THEN
          CALL PUSHREALARRAY(omga, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%&
&                       jsd+1)*npz/8)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,omga,pe,pem,rdt)
          DO k=1,npz
            DO j=js,je
              DO i=is,ie
                omga(i, j, k) = (pe(i, k+1, j)-pem(i, k+1, j))*rdt
              END DO
            END DO
          END DO
!------------------------------
! Compute the "advective term"
!------------------------------
          CALL ADV_PE_FWD(ua, va, pem, omga, gridstruct, bd, npx, npy, &
&                   npz, ng)
          CALL PUSHCONTROL3B_FV(4)
        ELSE
!$OMP parallel do default(none) shared(is,ie,js,je,npz,omga) private(om2d)
          DO j=js,je
            DO k=1,npz
              DO i=is,ie
                om2d(i, k) = omga(i, j, k)
              END DO
            END DO
            DO k=2,npz
              DO i=is,ie
                om2d(i, k) = om2d(i, k-1) + omga(i, j, k)
              END DO
            END DO
            DO k=2,npz
              DO i=is,ie
                CALL PUSHREALARRAY(omga(i, j, k))
                omga(i, j, k) = om2d(i, k)
              END DO
            END DO
          END DO
          CALL PUSHCONTROL3B_FV(3)
        END IF
      ELSE IF (.NOT.last_step .AND. end_step .AND. hydrostatic) THEN
!      if (idiag%id_ws>0 .and. hydrostatic) then
!$OMP parallel do default(none) shared(is,ie,js,je,npz,ws,delz,delp,omga)
!           do j=js,je
!             do i=is,ie
!                ws(i,j) = delz(i,j,npz)/delp(i,j,npz) * omga(i,j,npz)
!             enddo
!          enddo
!          used=send_data(idiag%id_ws, ws, fv_time)
!      endif
!not last step
        IF (flagstruct%use_old_omega) THEN
          CALL PUSHREALARRAY(omga, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%&
&                       jsd+1)*npz/8)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,omga,pe,pem,rdt)
!------------------------------
! Compute the "advective term"
!------------------------------
          CALL ADV_PE_FWD_NOCALC(ua, va, pem, omga, gridstruct, bd, npx, npy, &
&                   npz, ng)
          CALL PUSHCONTROL3B_FV(2)
        ELSE
!$OMP parallel do default(none) shared(is,ie,js,je,npz,omga) private(om2d)
          DO j=js,je
            DO k=2,npz
              DO i=is,ie
                CALL PUSHREALARRAY(omga(i, j, k))
              END DO
            END DO
          END DO
          CALL PUSHCONTROL3B_FV(1)
        END IF
      ELSE
        CALL PUSHCONTROL3B_FV(0)
      END IF
    END DO
!      if (idiag%id_ws>0 .and. hydrostatic) then
!$OMP parallel do default(none) shared(is,ie,js,je,npz,ws,delz,delp,omga)
!           do j=js,je
!             do i=is,ie
!                ws(i,j) = delz(i,j,npz)/delp(i,j,npz) * omga(i,j,npz)
!             enddo
!          enddo
!          used=send_data(idiag%id_ws, ws, fv_time)
!      endif
!#endif
!    if (gridstruct%nested) then
!!#ifdef SW_DYNAMICS
!!#else
!
!
!
!         if (.not. hydrostatic) then
!               call nested_grid_BC_apply_intT(w, &
!                    0, 0, npx, npy, npz, bd, split_timestep_BC, split, &
!                    var_east_t0=neststruct%w_BC%east_t0, &
!                    var_west_t0=neststruct%w_BC%west_t0, &
!                    var_north_t0=neststruct%w_BC%north_t0, &
!                    var_south_t0=neststruct%w_BC%south_t0, &
!                    var_east_t1=neststruct%w_BC%east_t1, &
!                    var_west_t1=neststruct%w_BC%west_t1, &
!                    var_north_t1=neststruct%w_BC%north_t1, &
!                    var_south_t1=neststruct%w_BC%south_t1, &
!                    bctype=neststruct%nestbctype, &
!                    nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!         end if
!!#endif
!         
!         
!            call nested_grid_BC_apply_intT(u, &
!                 0, 1, npx, npy, npz, bd, split_timestep_BC, split, &
!                 var_east_t0=neststruct%u_BC%east_t0, &
!                 var_west_t0=neststruct%u_BC%west_t0, &
!                 var_north_t0=neststruct%u_BC%north_t0, &
!                 var_south_t0=neststruct%u_BC%south_t0, &
!                 var_east_t1=neststruct%u_BC%east_t1, &
!                 var_west_t1=neststruct%u_BC%west_t1, &
!                 var_north_t1=neststruct%u_BC%north_t1, &
!                 var_south_t1=neststruct%u_BC%south_t1, &
!                 bctype=neststruct%nestbctype, &
!                 nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!         !v
!            call nested_grid_BC_apply_intT(v, &
!                 1, 0, npx, npy, npz, bd, split_timestep_BC, split, &
!                 var_east_t0=neststruct%v_BC%east_t0, &
!                 var_west_t0=neststruct%v_BC%west_t0, &
!                 var_north_t0=neststruct%v_BC%north_t0, &
!                 var_south_t0=neststruct%v_BC%south_t0, &
!                 var_east_t1=neststruct%v_BC%east_t1, &
!                 var_west_t1=neststruct%v_BC%west_t1, &
!                 var_north_t1=neststruct%v_BC%north_t1, &
!                 var_south_t1=neststruct%v_BC%south_t1, &
!                 bctype=neststruct%nestbctype, &
!                 nsponge=neststruct%nsponge, s_weight=neststruct%s_weight   )
!
!      end if
!-----------------------------------------------------
! time split loop
!-----------------------------------------------------
!  if ( flagstruct%fv_debug ) then
!       if(is_master()) write(*,*) 'End of n_split loop'
!  endif
    IF (n_con .NE. 0 .AND. flagstruct%d_con .GT. 1.e-5) THEN
      arg11 = cnst_0p20*gridstruct%da_min
      CALL DEL2_CUBED_FWD(heat_source, arg11, gridstruct, domain, npx, &
&                   npy, npz, 3, bd)
! Note: pt here is cp*(Virtual_Temperature/pkz)
      IF (hydrostatic) THEN
        CALL PUSHREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                     )*npz/8)
        CALL PUSHINTEGER(n_con)
        CALL PUSHREALARRAY(heat_source, 8*(bd%ied-bd%isd+1)*(bd%jed&
&                     -bd%jsd+1)*npz/8)
!
! del(Cp*T) = - del(KE)
!
!$OMP parallel do default(none) shared(is,ie,js,je,n_con,pt,heat_source,delp,pkz)
        DO j=js,je
          DO k=1,n_con
            DO i=is,ie
              pt(i, j, k) = pt(i, j, k) + heat_source(i, j, k)/(delp(i, &
&               j, k)*pkz(i, j, k))
            END DO
          END DO
        END DO
        CALL PUSHCONTROL2B_FV(0)
      ELSE
!$OMP parallel do default(none) shared(is,ie,js,je,n_con,pkz,cappa,kapag,delp,delz,pt, &
!$OMP                                  heat_source,k1k) &
!$OMP                          private(cpm, tmcp)
        DO j=js,je
! n_con is usually less than 3; not good as outer openMP loop
          DO k=1,n_con
            DO i=is,ie
!#ifdef MOIST_CAPPA
!                pkz(i,j,k) = exp(cappa(i,j,k)/(1.-cappa(i,j,k))*log(kapag*delp(i,j,k)/delz(i,j,k)*pt(i,j,k)) )
!#else
              CALL PUSHREALARRAY(pkz(i, j, k))
              pkz(i, j, k) = EXP(k1k*LOG(kapag*delp(i, j, k)/delz(i, j, &
&               k)*pt(i, j, k)))
!#endif
! tmcp = termperature_v * cp
              CALL PUSHREALARRAY(tmcp)
              tmcp = pt(i, j, k)*pkz(i, j, k)
              CALL PUSHREALARRAY(delz(i, j, k))
              delz(i, j, k) = delz(i, j, k)/tmcp
              CALL PUSHREALARRAY(tmcp)
              tmcp = tmcp + heat_source(i, j, k)/delp(i, j, k)
              CALL PUSHREALARRAY(pt(i, j, k))
              pt(i, j, k) = tmcp/pkz(i, j, k)
              CALL PUSHREALARRAY(delz(i, j, k))
              delz(i, j, k) = delz(i, j, k)*tmcp
            END DO
          END DO
        END DO
        CALL PUSHCONTROL2B_FV(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B_FV(2)
    END IF
!deallocate(    gz )
!deallocate(   ptc )
!deallocate(   crx )
!deallocate(   xfx )
!deallocate(   cry )
!deallocate(   yfx )
!deallocate( divgd )
!deallocate(   pkc )
!deallocate( delpc )
!if( allocated(ut))   deallocate( ut )
!if( allocated(vt))   deallocate( vt )
!if ( allocated (du) ) deallocate( du )
!if ( allocated (dv) ) deallocate( dv )
!if ( .not. hydrostatic ) then
!     deallocate( zh )
!     deallocate( pk3 )
!endif
!if( allocated(pem) )   deallocate ( pem )
!if ( flagstruct%fv_debug ) then
!   if(is_master()) write(*,*) 'End of dyn_core'
!endif
    CALL PUSHREALARRAY(damp_k_pert)
    CALL PUSHREALARRAY(kapag)
    CALL PUSHREALARRAY(dt)
    CALL PUSHINTEGER(nord_t_pert)
    CALL PUSHINTEGER(nord_v_pert, npz + 1)
    CALL PUSHINTEGER(hord_m_pert)
    CALL PUSHREALARRAY(beta_d)
    CALL PUSHREALARRAY(damp_k)
    CALL PUSHINTEGER(n_con)
    CALL PUSHREALARRAY(dt2)
    CALL PUSHREALARRAY(k1k)
    CALL PUSHREALARRAY(damp_vt_pert, 8*(npz+1)/8)
    CALL PUSHREALARRAY(rdt)
    CALL PUSHREALARRAY(d2_divg_pert)
    CALL PUSHINTEGER(nord_k_pert)
    CALL PUSHINTEGER(nord_k)
    CALL PUSHREALARRAY(damp_t_pert)
    CALL PUSHREALARRAY(ws3, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8&
&                )
    CALL PUSHINTEGER(nord_t)
    CALL PUSHREALARRAY(damp_vt, 8*(npz+1)/8)
    CALL PUSHINTEGER(nord_v, npz + 1)
    CALL PUSHINTEGER(nord_w)
    CALL PUSHREALARRAY(tmcp)
    CALL PUSHREALARRAY(heat_source, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%&
&                 jsd+1)*npz/8)
    CALL PUSHINTEGER(hord_p_pert)
    CALL PUSHREALARRAY(dp_ref, 8*npz/8)
    CALL PUSHINTEGER(hord_t_pert)
    CALL PUSHINTEGER(ms)
    CALL PUSHINTEGER(hord_v_pert)
    CALL PUSHREALARRAY(d2_divg)
    CALL PUSHREALARRAY(wk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8)
  END SUBROUTINE DYN_CORE_FWD
!  Differentiation of dyn_core in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mo
!d.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_h
!alo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_
!mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.ra
!yleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_t
!o_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_ener
!gy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_
!mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz f
!v_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solve
!r_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_cor
!e_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence
!_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_m
!od.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_m
!od.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_
!mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: pk3 xfx ws peln q gz du u dv
!                v w delp ua uc ptc mfx delz mfy omga ut divgd
!                pkc delpc va vc yfx pkz pe vt pk zh pt cx cy crx
!                cry
!   with respect to varying inputs: pk3 xfx ws peln q gz du u dv
!                v w delp ua uc ptc mfx delz mfy omga ut divgd
!                pkc delpc va vc yfx pkz pe vt pk zh pt cx cy crx
!                cry
!---- version number -----
!  character(len=128) :: version = '$Id: dyn_core.F90,v 1.2.2.1.2.1.30.1.4.1.22.5.48.6.2.2.2.1.4.1 2017/02/16 03:47:47 aoloso Exp
! $'
!  character(len=128) :: tagname = '$Name: Heracles-UNSTABLE_ncepdyn_Feb222017 $'
!-----------------------------------------------------------------------
!     dyn_core :: FV Lagrangian dynamics driver
!-----------------------------------------------------------------------
  SUBROUTINE DYN_CORE_BWD(npx, npy, npz, ng, sphum, nq, bdt, n_split, &
&   zvir, cp, akap, cappa, grav, hydrostatic, u, u_ad, v, v_ad, w, w_ad&
&   , delz, delz_ad, pt, pt_ad, q, q_ad, delp, delp_ad, pe, pe_ad, pk, &
&   pk_ad, phis, ws, ws_ad, omga, omga_ad, ptop, pfull, ua, ua_ad, va, &
&   va_ad, uc, uc_ad, vc, vc_ad, mfx, mfx_ad, mfy, mfy_ad, cx, cx_ad, cy&
&   , cy_ad, pkz, pkz_ad, peln, peln_ad, q_con, ak, bk, ks, gridstruct, &
&   flagstruct, neststruct, idiag, bd, domain, init_step, i_pack, &
&   end_step, gz, gz_ad, pkc, pkc_ad, ptc, ptc_ad, crx, crx_ad, xfx, &
&   xfx_ad, cry, cry_ad, yfx, yfx_ad, divgd, divgd_ad, delpc, delpc_ad, &
&   ut, ut_ad, vt, vt_ad, zh, zh_ad, pk3, pk3_ad, du, du_ad, dv, dv_ad, &
&   time_total)
    IMPLICIT NONE
!deallocate( heat_source )    
!if (allocated(heat_source)) deallocate( heat_source ) !If ncon == 0 but d_con > 1.e-5, this would not be deallocated in earlier 
!versions of the code
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
    INTEGER, INTENT(IN) :: ng, nq, sphum
    INTEGER, INTENT(IN) :: n_split
    REAL(fvprc), INTENT(IN) :: bdt
    REAL(fvprc), INTENT(IN) :: zvir, cp, akap, grav
    REAL(fvprc), INTENT(IN) :: ptop
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: init_step, end_step
    REAL(fvprc), INTENT(IN) :: pfull(npz)
    REAL(fvprc), DIMENSION(npz+1), INTENT(IN) :: ak, bk
    INTEGER, INTENT(IN) :: ks
    TYPE(GROUP_HALO_UPDATE_TYPE), INTENT(INOUT) :: i_pack(*)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz), INTENT(&
&   INOUT) :: u
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz), INTENT(&
&   INOUT) :: u_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: v
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: v_ad
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: w_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: delz_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: cappa(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: pt_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: delp_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, &
&   nq)
    REAL(fvprc), INTENT(INOUT) :: q_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   , nq)
    REAL(fvprc), INTENT(IN), OPTIONAL :: time_total
    REAL(fvprc), INTENT(INOUT) :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%&
&   je+1)
    REAL(fvprc), INTENT(INOUT) :: pe_ad(bd%is-1:bd%ie+1, npz+1, bd%js-1:&
&   bd%je+1)
    REAL(fvprc), INTENT(INOUT) :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL(fvprc), INTENT(INOUT) :: peln_ad(bd%is:bd%ie, npz+1, bd%js:bd%&
&   je)
    REAL(fvprc), INTENT(INOUT) :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL(fvprc), INTENT(INOUT) :: pk_ad(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL(fvprc), PARAMETER :: near0=1.e-8
    REAL(fvprc), PARAMETER :: huge_r=1.e20
    REAL(fvprc), PARAMETER :: air_viscosity=1.e-5
    REAL(fvprc) :: ws(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: ws_ad(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc), INTENT(INOUT) :: omga(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: omga_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: uc_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: vc_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: ua_ad, va_ad
    REAL(fvprc), INTENT(INOUT) :: q_con(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
    REAL(fvprc), INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL(fvprc), INTENT(INOUT) :: mfx_ad(bd%is:bd%ie+1, bd%js:bd%je, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
    REAL(fvprc), INTENT(INOUT) :: mfy_ad(bd%is:bd%ie, bd%js:bd%je+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: cx_ad(bd%is:bd%ie+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc), INTENT(INOUT) :: cy_ad(bd%isd:bd%ied, bd%js:bd%je+1, &
&   npz)
    REAL(fvprc), DIMENSION(bd%is:bd%ie, bd%js:bd%je, npz), INTENT(INOUT)&
&   :: pkz
    REAL(fvprc), DIMENSION(bd%is:bd%ie, bd%js:bd%je, npz), INTENT(INOUT)&
&   :: pkz_ad
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(IN), TARGET :: flagstruct
    TYPE(FV_NEST_TYPE), INTENT(INOUT) :: neststruct
    TYPE(FV_DIAG_TYPE), INTENT(IN) :: idiag
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    REAL(fvprc) :: pem(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1), &
&   heat_source(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: pem_ad(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1), &
&   heat_source_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ws3, z_rat
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed) :: ws3_ad, &
&   z_rat_ad
    REAL(fvprc) :: dp_ref(npz)
    REAL(fvprc) :: zs(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: p1d(bd%is:bd%ie)
    REAL(fvprc) :: om2d(bd%is:bd%ie, npz)
    REAL(fvprc) :: om2d_ad(bd%is:bd%ie, npz)
    REAL(fvprc) :: wbuffer(npy+2, npz)
    REAL(fvprc) :: ebuffer(npy+2, npz)
    REAL(fvprc) :: ebuffer_ad(npy+2, npz)
    REAL(fvprc) :: nbuffer(npx+2, npz)
    REAL(fvprc) :: nbuffer_ad(npx+2, npz)
    REAL(fvprc) :: sbuffer(npx+2, npz)
    REAL(fvprc) :: divg2(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: divg2_ad(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: wk(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk_ad(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: fz(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: heat_s(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: heat_s_ad(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: damp_vt(npz+1)
    REAL(fvprc) :: damp_vt_pert(npz+1)
    INTEGER :: nord_v(npz+1)
    INTEGER :: nord_v_pert(npz+1)
    INTEGER :: hord_m, hord_v, hord_t, hord_p
    INTEGER :: hord_m_pert, hord_v_pert, hord_t_pert, hord_p_pert
    INTEGER :: nord_k, nord_w, nord_t
    INTEGER :: nord_k_pert, nord_w_pert, nord_t_pert
    INTEGER :: ms
    INTEGER :: i, j, k, it, iq, n_con
    INTEGER :: iep1, jep1
    REAL(fvprc) :: beta, beta_d, damp_k, damp_w, damp_t, d_con_k
    REAL(fvprc) :: damp_k_pert, damp_w_pert, damp_t_pert, d_con_k_pert
    REAL(fvprc) :: dt, dt2, rdt
    REAL(fvprc) :: d2_divg, d3_divg
    REAL(fvprc) :: d2_divg_pert
    REAL(fvprc) :: k1k, kapag, tmcp, cpm
    REAL(fvprc) :: tmcp_ad
    LOGICAL :: last_step, remap_step
    LOGICAL :: used
    REAL(fvprc) :: split_timestep_bc, split
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: gz_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: pkc(bd%isd:bd%ied, bd%jsd:bd%jed, npz+&
&   1)
    REAL(fvprc), INTENT(INOUT) :: pkc_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: ptc(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: ptc_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: crx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: crx_ad(bd%is:bd%ie+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: xfx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: xfx_ad(bd%is:bd%ie+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: cry(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc), INTENT(INOUT) :: cry_ad(bd%isd:bd%ied, bd%js:bd%je+1, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: yfx(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc), INTENT(INOUT) :: yfx_ad(bd%isd:bd%ied, bd%js:bd%je+1, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: divgd(bd%isd:bd%ied+1, bd%jsd:bd%jed+1&
&   , npz)
    REAL(fvprc), INTENT(INOUT) :: divgd_ad(bd%isd:bd%ied+1, bd%jsd:bd%&
&   jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: delpc(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: delpc_ad(bd%isd:bd%ied, bd%jsd:bd%jed&
&   , npz)
    REAL(fvprc), INTENT(INOUT) :: ut(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: ut_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: vt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: vt_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: zh(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: zh_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: pk3(bd%isd:bd%ied, bd%jsd:bd%jed, npz+&
&   1)
    REAL(fvprc), INTENT(INOUT) :: pk3_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: du(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: du_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: dv(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: dv_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc) :: vt_tj(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    INTRINSIC LOG
    INTRINSIC REAL
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC TANH
    INTRINSIC EXP
    INTEGER :: arg1
    LOGICAL :: arg10
    REAL(kind=r_grid) :: arg11
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp_ad4
    REAL(fvprc) :: temp_ad5
    REAL(fvprc) :: temp
    REAL(fvprc) :: temp0
    REAL(fvprc) :: temp1
    REAL(fvprc) :: temp_ad6
    REAL(fvprc) :: temp2
    REAL(fvprc) :: temp3
    REAL(fvprc) :: temp4
    REAL(fvprc) :: temp_ad7
    REAL(fvprc) :: temp_ad8
    REAL(fvprc) :: temp_ad9
    INTEGER :: branch
    REAL(fvprc) :: temp5
    REAL(fvprc) :: temp_ad10
    REAL(fvprc) :: y2
    REAL(fvprc) :: y1
    CALL POPREALARRAY(wk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8)
    CALL POPREALARRAY(d2_divg)
    CALL POPINTEGER(hord_v_pert)
    CALL POPINTEGER(ms)
    CALL POPINTEGER(hord_t_pert)
    CALL POPREALARRAY(dp_ref, 8*npz/8)
    CALL POPINTEGER(hord_p_pert)
    CALL POPREALARRAY(heat_source, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%&
&                jsd+1)*npz/8)
    CALL POPREALARRAY(tmcp)
    CALL POPINTEGER(nord_w)
    CALL POPINTEGER(nord_v, npz + 1)
    CALL POPREALARRAY(damp_vt, 8*(npz+1)/8)
    CALL POPINTEGER(nord_t)
    CALL POPREALARRAY(ws3, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8)
    CALL POPREALARRAY(damp_t_pert)
    CALL POPINTEGER(nord_k)
    CALL POPINTEGER(nord_k_pert)
    CALL POPREALARRAY(d2_divg_pert)
    CALL POPREALARRAY(rdt)
    CALL POPREALARRAY(damp_vt_pert, 8*(npz+1)/8)
    CALL POPREALARRAY(k1k)
    CALL POPREALARRAY(dt2)
    CALL POPINTEGER(n_con)
    CALL POPREALARRAY(damp_k)
    CALL POPREALARRAY(beta_d)
    CALL POPINTEGER(hord_m_pert)
    CALL POPINTEGER(nord_v_pert, npz + 1)
    CALL POPINTEGER(nord_t_pert)
    CALL POPREALARRAY(dt)
    CALL POPREALARRAY(kapag)
    CALL POPREALARRAY(damp_k_pert)
    js = bd%js
    is = bd%is
    ie = bd%ie
    je = bd%je
    CALL POPCONTROL2B_FV(branch)
    IF (branch .EQ. 0) THEN
      heat_source_ad = 0.0_FVPRC
      CALL POPREALARRAY(heat_source, 8*(bd%ied-bd%isd+1)*(bd%jed-bd&
&                  %jsd+1)*npz/8)
      CALL POPINTEGER(n_con)
      CALL POPREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                  npz/8)
      DO j=js,je
        DO k=n_con,1,-1
          DO i=ie,is,-1
            temp5 = delp(i, j, k)*pkz(i, j, k)
            temp_ad10 = -(heat_source(i, j, k)*pt_ad(i, j, k)/temp5**2)
            heat_source_ad(i, j, k) = heat_source_ad(i, j, k) + pt_ad(i&
&             , j, k)/temp5
            delp_ad(i, j, k) = delp_ad(i, j, k) + pkz(i, j, k)*temp_ad10
            pkz_ad(i, j, k) = pkz_ad(i, j, k) + delp(i, j, k)*temp_ad10
          END DO
        END DO
      END DO
    ELSE IF (branch .EQ. 1) THEN
      heat_source_ad = 0.0_FVPRC
      DO j=je,js,-1
        DO k=n_con,1,-1
          DO i=ie,is,-1
            temp_ad7 = pt_ad(i, j, k)/pkz(i, j, k)
            CALL POPREALARRAY(delz(i, j, k))
            tmcp_ad = temp_ad7 + delz(i, j, k)*delz_ad(i, j, k)
            delz_ad(i, j, k) = tmcp*delz_ad(i, j, k)
            CALL POPREALARRAY(pt(i, j, k))
            pkz_ad(i, j, k) = pkz_ad(i, j, k) - tmcp*temp_ad7/pkz(i, j, &
&             k)
            CALL POPREALARRAY(tmcp)
            temp_ad9 = tmcp_ad/delp(i, j, k)
            heat_source_ad(i, j, k) = heat_source_ad(i, j, k) + temp_ad9
            CALL POPREALARRAY(delz(i, j, k))
            tmcp_ad = tmcp_ad - delz(i, j, k)*delz_ad(i, j, k)/tmcp**2
            pkz_ad(i, j, k) = pkz_ad(i, j, k) + pt(i, j, k)*tmcp_ad
            temp4 = delz(i, j, k)
            temp3 = delp(i, j, k)*pt(i, j, k)
            temp2 = temp3/temp4
            temp_ad8 = k1k*EXP(k1k*LOG(kapag*temp2))*pkz_ad(i, j, k)/(&
&             temp2*temp4)
            pt_ad(i, j, k) = pkz(i, j, k)*tmcp_ad + delp(i, j, k)*&
&             temp_ad8
            delp_ad(i, j, k) = delp_ad(i, j, k) + pt(i, j, k)*temp_ad8 -&
&             heat_source(i, j, k)*temp_ad9/delp(i, j, k)
            delz_ad(i, j, k) = delz_ad(i, j, k)/tmcp - temp2*temp_ad8
            CALL POPREALARRAY(tmcp)
            CALL POPREALARRAY(pkz(i, j, k))
            pkz_ad(i, j, k) = 0.0_FVPRC
          END DO
        END DO
      END DO
    ELSE
      heat_source_ad = 0.0_FVPRC
      GOTO 100
    END IF
    arg11 = cnst_0p20*gridstruct%da_min
    CALL DEL2_CUBED_BWD(heat_source, heat_source_ad, arg11, gridstruct, &
&                 domain, npx, npy, npz, 3, bd)
 100 jep1 = je + 1
    jsd = bd%jsd
    ied = bd%ied
    iep1 = ie + 1
    isd = bd%isd
    jed = bd%jed
    om2d_ad = 0.0_FVPRC
    pem_ad = 0.0_FVPRC
    ws3_ad = 0.0_FVPRC
    z_rat_ad = 0.0_FVPRC
    heat_s_ad = 0.0_FVPRC
    wk_ad = 0.0_FVPRC
    divg2_ad = 0.0_FVPRC
    DO it=n_split,1,-1
      CALL POPCONTROL3B_FV(branch)
      IF (branch .LT. 2) THEN
        IF (branch .NE. 0) THEN
          DO j=je,js,-1
            DO k=npz,2,-1
              DO i=ie,is,-1
                CALL POPREALARRAY(omga(i, j, k))
                omga_ad(i, j, k) = 0.0_FVPRC
              END DO
            END DO
          END DO
        END IF
      ELSE IF (branch .EQ. 2) THEN
        CALL ADV_PE_BWD_NOCALC(ua, ua_ad, va, va_ad, pem, pem_ad, omga, omga_ad&
&                 , gridstruct, bd, npx, npy, npz, ng)
        CALL POPREALARRAY(omga, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+&
&                    1)*npz/8)
      ELSE IF (branch .EQ. 3) THEN
        DO j=je,js,-1
          DO k=npz,2,-1
            DO i=ie,is,-1
              CALL POPREALARRAY(omga(i, j, k))
              om2d_ad(i, k) = om2d_ad(i, k) + omga_ad(i, j, k)
              omga_ad(i, j, k) = 0.0_FVPRC
            END DO
          END DO
          DO k=npz,2,-1
            DO i=ie,is,-1
              om2d_ad(i, k-1) = om2d_ad(i, k-1) + om2d_ad(i, k)
              omga_ad(i, j, k) = omga_ad(i, j, k) + om2d_ad(i, k)
              om2d_ad(i, k) = 0.0_FVPRC
            END DO
          END DO
          DO k=npz,1,-1
            DO i=ie,is,-1
              omga_ad(i, j, k) = omga_ad(i, j, k) + om2d_ad(i, k)
              om2d_ad(i, k) = 0.0_FVPRC
            END DO
          END DO
        END DO
      ELSE
        CALL ADV_PE_BWD(ua, ua_ad, va, va_ad, pem, pem_ad, omga, omga_ad&
&                 , gridstruct, bd, npx, npy, npz, ng)
        CALL POPREALARRAY(omga, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+&
&                    1)*npz/8)
        DO k=1,npz
          DO j=je,js,-1
            DO i=ie,is,-1
              pe_ad(i, k+1, j) = pe_ad(i, k+1, j) + rdt*omga_ad(i, j, k)
              pem_ad(i, k+1, j) = pem_ad(i, k+1, j) - rdt*omga_ad(i, j, &
&               k)
              omga_ad(i, j, k) = 0.0_FVPRC
            END DO
          END DO
        END DO
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREALARRAY(u, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)*&
&                    npz/8)
        CALL POPREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)*&
&                    npz/8)
        CALL START_GROUP_HALO_UPDATE_ADM(i_pack(8), i_pack(8+12), u, &
&                                  u_ad, v, v_ad, domain, gridtype=&
&                                  dgrid_ne)
      ELSE
        CALL POPREALARRAY(u, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)*&
&                    npz/8)
        CALL POPREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)*&
&                    npz/8)
      END IF
      CALL POPCONTROL2B_FV(branch)
      IF (branch .EQ. 0) THEN
        nbuffer_ad = 0.0_FVPRC
        ebuffer_ad = 0.0_FVPRC
        DO k=npz,1,-1
          DO j=je,js,-1
            ebuffer_ad(j-js+1, k) = ebuffer_ad(j-js+1, k) + v_ad(ie+1, j&
&             , k)
            v_ad(ie+1, j, k) = 0.0_FVPRC
          END DO
          DO i=ie,is,-1
            nbuffer_ad(i-is+1, k) = nbuffer_ad(i-is+1, k) + u_ad(i, je+1&
&             , k)
            u_ad(i, je+1, k) = 0.0_FVPRC
          END DO
        END DO
        CALL POPREALARRAY(u, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)*&
&                    npz/8)
        CALL POPREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)*&
&                    npz/8)
        CALL MPP_GET_BOUNDARY_ADM(u, u_ad, v, v_ad, domain, wbuffery=&
&                           wbuffer, ebuffery=ebuffer, ebuffery_ad=&
&                           ebuffer_ad, sbufferx=sbuffer, nbufferx=&
&                           nbuffer, nbufferx_ad=nbuffer_ad, gridtype=&
&                           dgrid_ne)
      ELSE IF (branch .EQ. 1) THEN
        CALL POPREALARRAY(u, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)*&
&                    npz/8)
        CALL POPREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)*&
&                    npz/8)
      END IF
      CALL POPCONTROL2B_FV(branch)
      IF (branch .EQ. 0) THEN
        DO k=npz,1,-1
          DO j=je,js,-1
            DO i=ie,is,-1
              CALL POPREALARRAY(pkz(i, j, k))
              temp1 = delz(i, j, k)
              temp0 = delp(i, j, k)*pt(i, j, k)
              temp = temp0/temp1
              temp_ad6 = k1k*EXP(k1k*LOG(kapag*temp))*pkz_ad(i, j, k)/(&
&               temp*temp1)
              delp_ad(i, j, k) = delp_ad(i, j, k) + pt(i, j, k)*temp_ad6
              pt_ad(i, j, k) = pt_ad(i, j, k) + delp(i, j, k)*temp_ad6
              delz_ad(i, j, k) = delz_ad(i, j, k) - temp*temp_ad6
              pkz_ad(i, j, k) = 0.0_FVPRC
            END DO
          END DO
        END DO
      END IF
      CALL POPCONTROL3B_FV(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          CALL GRAD1_P_UPDATE_BWD(divg2, divg2_ad, u, u_ad, v, v_ad, du&
&                           , du_ad, dv, dv_ad, pkc, pkc_ad, gz, gz_ad, &
&                           dt, ng, gridstruct, bd, npx, npy, npz, ptop&
&                           , beta_d, flagstruct%a2b_ord)
        ELSE
          CALL ONE_GRAD_P_BWD(u, u_ad, v, v_ad, pkc, pkc_ad, gz, gz_ad, &
&                       divg2, divg2_ad, delp, delp_ad, dt, ng, &
&                       gridstruct, bd, npx, npy, npz, ptop, hydrostatic&
&                       , flagstruct%a2b_ord, flagstruct%d_ext)
        END IF
      ELSE IF (branch .EQ. 2) THEN
        CALL SPLIT_P_GRAD_BWD(u, u_ad, v, v_ad, du, du_ad, dv, dv_ad, &
&                       pkc, pkc_ad, gz, gz_ad, delp, delp_ad, pk3, &
&                       pk3_ad, beta_d, dt, ng, gridstruct, bd, npx, npy&
&                       , npz, flagstruct%use_logp)
      ELSE IF (branch .EQ. 3) THEN
        CALL ONE_GRAD_P_BWD(u, u_ad, v, v_ad, pkc, pkc_ad, gz, gz_ad, &
&                     divg2, divg2_ad, delp, delp_ad, dt, ng, gridstruct&
&                     , bd, npx, npy, npz, ptop, hydrostatic, flagstruct&
&                     %a2b_ord, flagstruct%d_ext)
      ELSE
        CALL NH_P_GRAD_BWD(u, u_ad, v, v_ad, pkc, pkc_ad, gz, gz_ad, &
&                    delp, delp_ad, pk3, pk3_ad, dt, ng, gridstruct, bd&
&                    , npx, npy, npz, flagstruct%use_logp)
      END IF
      CALL POPCONTROL2B_FV(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREALARRAY(pk, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)*(&
&                    npz+1)/8)
        DO k=1,npz+1
          DO j=je,js,-1
            DO i=ie,is,-1
              pkc_ad(i, j, k) = pkc_ad(i, j, k) + pk_ad(i, j, k)
              pk_ad(i, j, k) = 0.0_FVPRC
            END DO
          END DO
        END DO
      ELSE IF (branch .EQ. 1) THEN
        CALL POPREALARRAY(pk, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)*(&
&                    npz+1)/8)
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        CALL GEOPK_BWD(ptop, pe, pe_ad, peln, peln_ad, delp, delp_ad, &
&                pkc, pkc_ad, gz, gz_ad, phis, pt, pt_ad, q_con, pkz, &
&                pkz_ad, npz, akap, .false., gridstruct%nested, .true., &
&                npx, npy, flagstruct%a2b_ord, bd)
      ELSE
        DO k=npz+1,1,-1
          DO j=je+2,js-2,-1
            DO i=ie+2,is-2,-1
              CALL POPREALARRAY(gz(i, j, k))
              zh_ad(i, j, k) = zh_ad(i, j, k) + grav*gz_ad(i, j, k)
              gz_ad(i, j, k) = 0.0_FVPRC
            END DO
          END DO
        END DO
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          CALL PLN_HALO_BWD(is, ie, js, je, isd, ied, jsd, jed, npz, &
&                     ptop, pk3, pk3_ad, delp, delp_ad)
        ELSE
          CALL PK3_HALO_BWD(is, ie, js, je, isd, ied, jsd, jed, npz, &
&                     ptop, akap, pk3, pk3_ad, delp, delp_ad)
        END IF
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) CALL PE_HALO_BWD(is, ie, js, je, isd, ied, &
&                                     jsd, jed, npz, ptop, pe, pe_ad, &
&                                     delp, delp_ad)
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREALARRAY(pkc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd&
&                      +1)*(npz+1)/8)
          CALL START_GROUP_HALO_UPDATE_ADM(i_pack(6), i_pack(6+12), pkc&
&                                    , pkc_ad, domain, whalo=2, ehalo=2&
&                                    , shalo=2, nhalo=2)
        ELSE
          CALL POPREALARRAY(pkc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd&
&                      +1)*(npz+1)/8)
          CALL START_GROUP_HALO_UPDATE_ADM(i_pack(6), i_pack(6+12), pkc&
&                                    , pkc_ad, domain)
        END IF
        CALL POPREALARRAY(zh, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                    *(npz+1)/8)
        CALL START_GROUP_HALO_UPDATE_ADM(i_pack(4), i_pack(4+12), zh, &
&                                  zh_ad, domain)
        CALL RIEM_SOLVER3_BWD(flagstruct%m_split, dt, is, ie, js, je, &
&                       npz, ng, isd, ied, jsd, jed, akap, cappa, cp, &
&                       ptop, zs, q_con, w, w_ad, delz, delz_ad, pt, &
&                       pt_ad, delp, delp_ad, zh, zh_ad, pe, pe_ad, pkc&
&                       , pkc_ad, pk3, pk3_ad, pk, pk_ad, peln, peln_ad&
&                       , ws, ws_ad, flagstruct%scale_z, flagstruct%&
&                       p_fac, flagstruct%a_imp, flagstruct%use_logp, &
&                       remap_step, arg10)
        CALL UPDATE_DZ_D_BWD(nord_v, damp_vt, flagstruct%hord_tm, &
&                      flagstruct%hord_tm_pert, is, ie, js, je, npz, ng&
&                      , npx, npy, gridstruct%area, gridstruct%rarea, &
&                      dp_ref, zs, zh, zh_ad, crx, crx_ad, cry, cry_ad, &
&                      xfx, xfx_ad, yfx, yfx_ad, ws, ws_ad, rdt, &
&                      gridstruct, bd)
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        DO j=jep1,js,-1
          DO i=iep1,is,-1
            CALL POPREALARRAY(divg2(i, j))
            temp_ad5 = d2_divg*divg2_ad(i, j)/wk(i, j)
            wk_ad(i, j) = wk_ad(i, j) - divg2(i, j)*temp_ad5/wk(i, j)
            divg2_ad(i, j) = temp_ad5
          END DO
          DO k=npz,2,-1
            DO i=iep1,is,-1
              ptc_ad(i, j, k) = ptc_ad(i, j, k) + wk_ad(i, j) + vt(i, j&
&               , k)*divg2_ad(i, j)
              vt_ad(i, j, k) = vt_ad(i, j, k) + ptc(i, j, k)*divg2_ad(i&
&               , j)
              CALL POPREALARRAY(wk(i, j))
            END DO
          END DO
          DO i=iep1,is,-1
            wk_ad(i, j) = wk_ad(i, j) + vt(i, j, 1)*divg2_ad(i, j)
            vt_ad(i, j, 1) = vt_ad(i, j, 1) + wk(i, j)*divg2_ad(i, j)
            divg2_ad(i, j) = 0.0_FVPRC
            CALL POPREALARRAY(wk(i, j))
            ptc_ad(i, j, 1) = ptc_ad(i, j, 1) + wk_ad(i, j)
            wk_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
        CALL POPREALARRAY(d2_divg)
      ELSE
        divg2_ad = 0.0_FVPRC
      END IF
      CALL POPREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                  npz/8)
      CALL START_GROUP_HALO_UPDATE_ADM(i_pack(2), i_pack(2+12), pt, &
&                                pt_ad, domain)
      CALL POPREALARRAY(delp, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                  *npz/8)
      CALL START_GROUP_HALO_UPDATE_ADM(i_pack(1), i_pack(1+12), delp, &
&                                delp_ad, domain)
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) CALL MIX_DP_BWD(hydrostatic, w, w_ad, delp, &
&                                  delp_ad, pt, pt_ad, npz, ak, bk, &
&                                  .false., flagstruct%fv_debug, bd)
      DO k=npz,1,-1
        CALL POPCONTROL1B_FV(branch)
        IF (branch .NE. 0) THEN
          DO j=je,js,-1
            DO i=ie,is,-1
              heat_s_ad(i, j) = heat_s_ad(i, j) + heat_source_ad(i, j, k&
&               )
            END DO
          END DO
        END IF
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          DO j=jep1,js,-1
            DO i=iep1,is,-1
              CALL POPREALARRAY(ptc(i, j, k))
              wk_ad(i, j) = wk_ad(i, j) + ptc_ad(i, j, k)
              ptc_ad(i, j, k) = 0.0_FVPRC
            END DO
          END DO
        END IF
        CALL POPCONTROL2B_FV(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) THEN
            DO j=je,js,-1
              DO i=ie,is,-1
                CALL POPREALARRAY(omga(i, j, k))
                temp_ad = gridstruct%rarea(i, j)*rdt*omga_ad(i, j, k)
                temp_ad0 = omga(i, j, k)*temp_ad
                xfx_ad(i, j, k) = xfx_ad(i, j, k) + temp_ad0
                xfx_ad(i+1, j, k) = xfx_ad(i+1, j, k) - temp_ad0
                yfx_ad(i, j, k) = yfx_ad(i, j, k) + temp_ad0
                yfx_ad(i, j+1, k) = yfx_ad(i, j+1, k) - temp_ad0
                omga_ad(i, j, k) = (xfx(i, j, k)-xfx(i+1, j, k)+yfx(i, j&
&                 , k)-yfx(i, j+1, k))*temp_ad
              END DO
            END DO
          ELSE
            DO j=je,js,-1
              DO i=ie,is,-1
                CALL POPREALARRAY(omga(i, j, k))
              END DO
            END DO
          END IF
        END IF
        CALL D_SW_BWD(vt(isd:ied, jsd:jed, k), vt_ad(isd:ied, jsd:jed, k&
&               ), vt_tj(isd:ied, jsd:jed, k), delp(isd:ied, jsd:jed, k)&
&               , delp_ad(isd:ied, jsd:jed, k), ptc(isd:ied, jsd:jed, k)&
&               , ptc_ad(isd:ied, jsd:jed, k), pt(isd:ied, jsd:jed, k), &
&               pt_ad(isd:ied, jsd:jed, k), u(isd:ied, jsd:jed+1, k), &
&               u_ad(isd:ied, jsd:jed+1, k), v(isd:ied+1, jsd:jed, k), &
&               v_ad(isd:ied+1, jsd:jed, k), w(isd:ied, jsd:jed, k), &
&               w_ad(isd:ied, jsd:jed, k), uc(isd:ied+1, jsd:jed, k), &
&               uc_ad(isd:ied+1, jsd:jed, k), vc(isd:ied, jsd:jed+1, k)&
&               , vc_ad(isd:ied, jsd:jed+1, k), ua(isd:ied, jsd:jed, k)&
&               , ua_ad(isd:ied, jsd:jed, k), va(isd:ied, jsd:jed, k), &
&               va_ad(isd:ied, jsd:jed, k), divgd(isd:ied+1, jsd:jed+1, &
&               k), divgd_ad(isd:ied+1, jsd:jed+1, k), mfx(is:ie+1, js:&
&               je, k), mfx_ad(is:ie+1, js:je, k), mfy(is:ie, js:je+1, k&
&               ), mfy_ad(is:ie, js:je+1, k), cx(is:ie+1, jsd:jed, k), &
&               cx_ad(is:ie+1, jsd:jed, k), cy(isd:ied, js:je+1, k), &
&               cy_ad(isd:ied, js:je+1, k), crx(is:ie+1, jsd:jed, k), &
&               crx_ad(is:ie+1, jsd:jed, k), cry(isd:ied, js:je+1, k), &
&               cry_ad(isd:ied, js:je+1, k), xfx(is:ie+1, jsd:jed, k), &
&               xfx_ad(is:ie+1, jsd:jed, k), yfx(isd:ied, js:je+1, k), &
&               yfx_ad(isd:ied, js:je+1, k), q_con(isd:isd, jsd:jsd, 1)&
&               , z_rat(isd:ied, jsd:jed), z_rat_ad(isd:ied, jsd:jed), &
&               heat_s, heat_s_ad, zvir, sphum, nq, q, q_ad, k, npz, &
&               flagstruct%inline_q, dt, flagstruct%hord_tr, hord_m, &
&               hord_v, hord_t, hord_p, flagstruct%hord_tr_pert, &
&               hord_m_pert, hord_v_pert, hord_t_pert, hord_p_pert, &
&               nord_k, nord_v(k), nord_w, nord_t, damp_k, d2_divg, &
&               flagstruct%d4_bg, damp_vt(k), damp_w, damp_t, d_con_k, &
&               flagstruct%split_damp, nord_k_pert, nord_v_pert(k), &
&               nord_w_pert, nord_t_pert, damp_k_pert, d2_divg_pert, &
&               flagstruct%d4_bg_pert, damp_vt_pert(k), damp_w_pert, &
&               damp_t_pert, d_con_k_pert, hydrostatic, gridstruct, &
&               flagstruct, bd)
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          DO j=jed,jsd,-1
            DO i=ied,isd,-1
              zh_ad(i, j, k) = zh_ad(i, j, k) + z_rat_ad(i, j)/radius
              zh_ad(i, j, k+1) = zh_ad(i, j, k+1) + z_rat_ad(i, j)/&
&               radius
              z_rat_ad(i, j) = 0.0_FVPRC
            END DO
          END DO
        END IF
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) CALL A2B_ORD2_BWD(delp(isd, jsd, k), delp_ad(&
&                                      isd, jsd, k), wk, wk_ad, &
&                                      gridstruct, npx, npy, is, ie, js&
&                                      , je, ng, .false.)
        CALL POPCONTROL2B_FV(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) THEN
            DO j=je,js,-1
              DO i=ie,is,-1
                CALL POPREALARRAY(omga(i, j, k))
                delp_ad(i, j, k) = delp_ad(i, j, k) + omga_ad(i, j, k)
                omga_ad(i, j, k) = 0.0_FVPRC
              END DO
            END DO
          ELSE
            DO j=je,js,-1
              DO i=ie,is,-1
                CALL POPREALARRAY(omga(i, j, k))
              END DO
            END DO
          END IF
        END IF
        CALL POPCONTROL3B_FV(branch)
        IF (branch .GE. 2) THEN
          IF (branch .EQ. 2) THEN
            CALL POPCONTROL2B_FV(branch)
            IF (branch .LT. 2) THEN
              IF (branch .EQ. 0) THEN
                CALL POPREALARRAY(damp_vt_pert(k))
                CALL POPREALARRAY(damp_vt(k))
                CALL POPINTEGER(nord_v_pert(k))
                CALL POPINTEGER(nord_v(k))
              ELSE
                CALL POPREALARRAY(damp_vt_pert(k))
                CALL POPREALARRAY(damp_vt(k))
                CALL POPINTEGER(nord_v_pert(k))
                CALL POPINTEGER(nord_v(k))
              END IF
            ELSE IF (branch .EQ. 2) THEN
              CALL POPREALARRAY(damp_vt_pert(k))
              CALL POPREALARRAY(damp_vt(k))
              CALL POPINTEGER(nord_v_pert(k))
              CALL POPINTEGER(nord_v(k))
            END IF
          END IF
        END IF
        CALL POPREALARRAY(damp_t_pert)
        CALL POPINTEGER(nord_t_pert)
        CALL POPINTEGER(nord_t)
        CALL POPINTEGER(nord_w)
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREALARRAY(damp_vt_pert(k))
        ELSE
          CALL POPREALARRAY(damp_vt_pert(k))
        END IF
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREALARRAY(damp_vt(k))
        ELSE
          CALL POPREALARRAY(damp_vt(k))
        END IF
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREALARRAY(d2_divg_pert)
        ELSE
          CALL POPREALARRAY(d2_divg_pert)
        END IF
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREALARRAY(d2_divg)
        ELSE
          CALL POPREALARRAY(d2_divg)
        END IF
        CALL POPREALARRAY(damp_k_pert)
        CALL POPREALARRAY(damp_k)
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          CALL POPINTEGER(nord_v_pert(k))
        ELSE
          CALL POPINTEGER(nord_v_pert(k))
        END IF
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          CALL POPINTEGER(nord_v(k))
        ELSE
          CALL POPINTEGER(nord_v(k))
        END IF
        CALL POPINTEGER(nord_k_pert)
        CALL POPINTEGER(nord_k)
        CALL POPINTEGER(hord_p_pert)
        CALL POPINTEGER(hord_v_pert)
        CALL POPINTEGER(hord_t_pert)
        CALL POPINTEGER(hord_m_pert)
      END DO
      CALL START_GROUP_HALO_UPDATE_ADM(i_pack(9), i_pack(9+12), uc, &
&                                uc_ad, vc, vc_ad, domain, gridtype=&
&                                cgrid_ne)
      CALL P_GRAD_C_BWD(dt2, npz, delpc, delpc_ad, pkc, pkc_ad, gz, &
&                 gz_ad, uc, uc_ad, vc, vc_ad, bd, gridstruct%rdxc, &
&                 gridstruct%rdyc, hydrostatic)
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        CALL GEOPK_BWD(ptop, pe, pe_ad, peln, peln_ad, delpc, delpc_ad, &
&                pkc, pkc_ad, gz, gz_ad, phis, ptc, ptc_ad, q_con, pkz, &
&                pkz_ad, npz, akap, .true., gridstruct%nested, .false., &
&                npx, npy, flagstruct%a2b_ord, bd)
      ELSE
        CALL RIEM_SOLVER_C_BWD(ms, dt2, is, ie, js, je, npz, ng, akap, &
&                        cappa, cp, ptop, phis, omga, omga_ad, ptc, &
&                        ptc_ad, q_con, delpc, delpc_ad, gz, gz_ad, pkc&
&                        , pkc_ad, ws3, ws3_ad, flagstruct%p_fac, &
&                        flagstruct%a_imp, flagstruct%scale_z)
        CALL UPDATE_DZ_C_BWD(is, ie, js, je, npz, ng, dt2, dp_ref, zs, &
&                      gridstruct%area, ut, ut_ad, vt, vt_ad, gz, gz_ad&
&                      , ws3, ws3_ad, npx, npy, gridstruct%sw_corner, &
&                      gridstruct%se_corner, gridstruct%ne_corner, &
&                      gridstruct%nw_corner, bd, gridstruct%grid_type)
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          DO k=npz+1,1,-1
            DO j=jed,jsd,-1
              DO i=ied,isd,-1
                CALL POPREALARRAY(gz(i, j, k))
              END DO
            END DO
          END DO
          DO k=npz+1,1,-1
            DO j=jed,jsd,-1
              DO i=ied,isd,-1
                gz_ad(i, j, k) = gz_ad(i, j, k) + zh_ad(i, j, k)
                zh_ad(i, j, k) = 0.0_FVPRC
              END DO
            END DO
          END DO
        ELSE
          DO k=npz+1,1,-1
            DO j=jed,jsd,-1
              DO i=ied,isd,-1
                CALL POPREALARRAY(gz(i, j, k))
                zh_ad(i, j, k) = zh_ad(i, j, k) + gz_ad(i, j, k)
                gz_ad(i, j, k) = 0.0_FVPRC
              END DO
            END DO
          END DO
        END IF
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) CALL START_GROUP_HALO_UPDATE_ADM(i_pack(3), &
&                                                   i_pack(3+12), divgd&
&                                                   , divgd_ad, domain, &
&                                                   position=corner)
      DO k=npz,1,-1
        CALL C_SW_BWD(delpc(isd:ied, jsd:jed, k), delpc_ad(isd:ied, jsd:&
&               jed, k), delp(isd:ied, jsd:jed, k), delp_ad(isd:ied, jsd&
&               :jed, k), ptc(isd:ied, jsd:jed, k), ptc_ad(isd:ied, jsd:&
&               jed, k), pt(isd:ied, jsd:jed, k), pt_ad(isd:ied, jsd:jed&
&               , k), u(isd:ied, jsd:jed+1, k), u_ad(isd:ied, jsd:jed+1&
&               , k), v(isd:ied+1, jsd:jed, k), v_ad(isd:ied+1, jsd:jed&
&               , k), w(isd:ied, jsd:jed, k), w_ad(isd:ied, jsd:jed, k)&
&               , uc(isd:ied+1, jsd:jed, k), uc_ad(isd:ied+1, jsd:jed, k&
&               ), vc(isd:ied, jsd:jed+1, k), vc_ad(isd:ied, jsd:jed+1, &
&               k), ua(isd:ied, jsd:jed, k), ua_ad(isd:ied, jsd:jed, k)&
&               , va(isd:ied, jsd:jed, k), va_ad(isd:ied, jsd:jed, k), &
&               omga(isd:ied, jsd:jed, k), omga_ad(isd:ied, jsd:jed, k)&
&               , ut(isd:ied, jsd:jed, k), ut_ad(isd:ied, jsd:jed, k), &
&               vt(isd:ied, jsd:jed, k), vt_ad(isd:ied, jsd:jed, k), &
&               divgd(isd:ied+1, jsd:jed+1, k), divgd_ad(isd:ied+1, jsd:&
&               jed+1, k), flagstruct%nord, dt2, hydrostatic, .true., bd&
&               , gridstruct, flagstruct)
      END DO
      CALL POPCONTROL2B_FV(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          DO j=je+1,js-1,-1
            DO k=npz,1,-1
              DO i=ie+1,is-1,-1
                pem_ad(i, k, j) = pem_ad(i, k, j) + pem_ad(i, k+1, j)
                delp_ad(i, j, k) = delp_ad(i, j, k) + pem_ad(i, k+1, j)
                pem_ad(i, k+1, j) = 0.0_FVPRC
              END DO
            END DO
            DO i=ie+1,is-1,-1
              pem_ad(i, 1, j) = 0.0_FVPRC
            END DO
          END DO
          pem_ad = 0.0_FVPRC
        END IF
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREALARRAY(beta_d)
      ELSE
        CALL POPREALARRAY(beta_d)
      END IF
      CALL POPCONTROL2B_FV(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREALARRAY(gz, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                    *(npz+1)/8)
        CALL START_GROUP_HALO_UPDATE_ADM(i_pack(5), i_pack(5+12), gz, &
&                                  gz_ad, domain)
        DO j=je,js,-1
          DO k=1,npz,1
            DO i=ie,is,-1
              CALL POPREALARRAY(gz(i, j, k))
              gz_ad(i, j, k+1) = gz_ad(i, j, k+1) + gz_ad(i, j, k)
              delz_ad(i, j, k) = delz_ad(i, j, k) - gz_ad(i, j, k)
              gz_ad(i, j, k) = 0.0_FVPRC
            END DO
          END DO
          DO i=ie,is,-1
            CALL POPREALARRAY(gz(i, j, npz+1))
            gz_ad(i, j, npz+1) = 0.0_FVPRC
          END DO
        END DO
      ELSE IF (branch .EQ. 1) THEN
        CALL POPREALARRAY(gz, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                    *(npz+1)/8)
        DO j=je,js,-1
          DO k=1,npz,1
            DO i=ie,is,-1
              CALL POPREALARRAY(gz(i, j, k))
            END DO
          END DO
          DO i=ie,is,-1
            CALL POPREALARRAY(gz(i, j, npz+1))
          END DO
        END DO
      ELSE
        GOTO 110
      END IF
      CALL POPREALARRAY(w, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                  npz/8)
      CALL START_GROUP_HALO_UPDATE_ADM(i_pack(7), i_pack(7+12), w, w_ad&
&                                , domain)
 110  CALL POPCONTROL2B_FV(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          CALL POPREALARRAY(q, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                      )*npz*nq/8)
          CALL START_GROUP_HALO_UPDATE_ADM(i_pack(10), i_pack(10+12), q&
&                                    , q_ad, domain)
        ELSE
          CALL POPREALARRAY(q, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                      )*npz*nq/8)
          CALL START_GROUP_HALO_UPDATE_ADM(i_pack(10), i_pack(10+12), q&
&                                    , q_ad, domain)
        END IF
      ELSE IF (branch .EQ. 2) THEN
        CALL POPREALARRAY(q, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                    npz*nq/8)
      END IF
    END DO
    CALL POPCONTROL2B_FV(branch)
    arg1 = je + 1
    CALL POPREALARRAY(cy, 8*(bd%ied-bd%isd+1)*(bd%je-bd%js+2)*npz/8&
&               )
    CALL INIT_IJK_MEM_ADM(isd, ied, js, arg1, npz, cy, cy_ad, 0._FVPRC)
    arg1 = ie + 1
    CALL POPREALARRAY(cx, 8*(bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*npz/8&
&               )
    CALL INIT_IJK_MEM_ADM(is, arg1, jsd, jed, npz, cx, cx_ad, 0._FVPRC)
    arg1 = je + 1
    CALL POPREALARRAY(mfy, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+2)*npz/8)
    CALL INIT_IJK_MEM_ADM(is, ie, js, arg1, npz, mfy, mfy_ad, 0._FVPRC)
    arg1 = ie + 1
    CALL POPREALARRAY(mfx, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+1)*npz/8)
    CALL INIT_IJK_MEM_ADM(is, arg1, js, je, npz, mfx, mfx_ad, 0._FVPRC)
    CALL POPCONTROL2B_FV(branch)
    IF (branch .EQ. 0) THEN
      arg1 = ied + 1
      CALL INIT_IJK_MEM_ADM(isd, arg1, jsd, jed, npz, dv, dv_ad, &
&                     0._FVPRC)
      arg1 = jed + 1
      CALL INIT_IJK_MEM_ADM(isd, ied, jsd, arg1, npz, du, du_ad, &
&                     0._FVPRC)
    ELSE IF (branch .NE. 1) THEN
      GOTO 120
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      arg1 = npz + 1
      CALL POPREALARRAY(pk3, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                  (npz+1)/8)
      CALL INIT_IJK_MEM_ADM(isd, ied, jsd, jed, arg1, pk3, pk3_ad, &
&                     huge_r)
    END IF
    arg1 = npz + 1
    CALL POPREALARRAY(gz, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*(&
&                npz+1)/8)
    CALL INIT_IJK_MEM_ADM(isd, ied, jsd, jed, arg1, gz, gz_ad, huge_r)
 120 q_ad = q_ad
  END SUBROUTINE DYN_CORE_BWD
!  Differentiation of pk3_halo in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod
!.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_ha
!lo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_m
!od.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.ray
!leigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to
!_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energ
!y fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_m
!od.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv
!_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver
!_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core
!_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_
!corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mo
!d.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mo
!d.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_m
!od.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: pk3 delp
!   with respect to varying inputs: pk3 delp
  SUBROUTINE PK3_HALO_FWD(is, ie, js, je, isd, ied, jsd, jed, npz, ptop&
&   , akap, pk3, delp)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, npz
    REAL(fvprc), INTENT(IN) :: ptop, akap
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(IN) :: delp
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz+1), INTENT(INOUT) :: &
&   pk3
! Local:
    REAL(fvprc) :: pei(isd:ied)
    REAL(fvprc) :: pej(jsd:jed)
    INTEGER :: i, j, k
    INTRINSIC LOG
    INTRINSIC EXP
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,npz,ptop,delp,pk3,akap) &
!$OMP                          private(pei)
    DO j=js,je
      CALL PUSHREALARRAY(pei(is-2))
      pei(is-2) = ptop
      CALL PUSHREALARRAY(pei(is-1))
      pei(is-1) = ptop
      DO k=1,npz
        CALL PUSHREALARRAY(pei(is-2))
        pei(is-2) = pei(is-2) + delp(is-2, j, k)
        CALL PUSHREALARRAY(pei(is-1))
        pei(is-1) = pei(is-1) + delp(is-1, j, k)
        CALL PUSHREALARRAY(pk3(is-2, j, k+1))
        pk3(is-2, j, k+1) = EXP(akap*LOG(pei(is-2)))
        CALL PUSHREALARRAY(pk3(is-1, j, k+1))
        pk3(is-1, j, k+1) = EXP(akap*LOG(pei(is-1)))
      END DO
      CALL PUSHREALARRAY(pei(ie+1))
      pei(ie+1) = ptop
      CALL PUSHREALARRAY(pei(ie+2))
      pei(ie+2) = ptop
      DO k=1,npz
        CALL PUSHREALARRAY(pei(ie+1))
        pei(ie+1) = pei(ie+1) + delp(ie+1, j, k)
        CALL PUSHREALARRAY(pei(ie+2))
        pei(ie+2) = pei(ie+2) + delp(ie+2, j, k)
        CALL PUSHREALARRAY(pk3(ie+1, j, k+1))
        pk3(ie+1, j, k+1) = EXP(akap*LOG(pei(ie+1)))
        CALL PUSHREALARRAY(pk3(ie+2, j, k+1))
        pk3(ie+2, j, k+1) = EXP(akap*LOG(pei(ie+2)))
      END DO
    END DO
!$OMP parallel do default(none) shared(is,ie,js,je,npz,ptop,delp,pk3,akap) &
!$OMP                          private(pej)
    DO i=is-2,ie+2
      CALL PUSHREALARRAY(pej(js-2))
      pej(js-2) = ptop
      CALL PUSHREALARRAY(pej(js-1))
      pej(js-1) = ptop
      DO k=1,npz
        CALL PUSHREALARRAY(pej(js-2))
        pej(js-2) = pej(js-2) + delp(i, js-2, k)
        CALL PUSHREALARRAY(pej(js-1))
        pej(js-1) = pej(js-1) + delp(i, js-1, k)
        CALL PUSHREALARRAY(pk3(i, js-2, k+1))
        pk3(i, js-2, k+1) = EXP(akap*LOG(pej(js-2)))
        CALL PUSHREALARRAY(pk3(i, js-1, k+1))
        pk3(i, js-1, k+1) = EXP(akap*LOG(pej(js-1)))
      END DO
      CALL PUSHREALARRAY(pej(je+1))
      pej(je+1) = ptop
      CALL PUSHREALARRAY(pej(je+2))
      pej(je+2) = ptop
      DO k=1,npz
        CALL PUSHREALARRAY(pej(je+1))
        pej(je+1) = pej(je+1) + delp(i, je+1, k)
        CALL PUSHREALARRAY(pej(je+2))
        pej(je+2) = pej(je+2) + delp(i, je+2, k)
        CALL PUSHREALARRAY(pk3(i, je+1, k+1))
        pk3(i, je+1, k+1) = EXP(akap*LOG(pej(je+1)))
        CALL PUSHREALARRAY(pk3(i, je+2, k+1))
        pk3(i, je+2, k+1) = EXP(akap*LOG(pej(je+2)))
      END DO
    END DO
    CALL PUSHREALARRAY(pei, 8*(ied-isd+1)/8)
    CALL PUSHREALARRAY(pej, 8*(jed-jsd+1)/8)
  END SUBROUTINE PK3_HALO_FWD
!  Differentiation of pk3_halo in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mo
!d.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_h
!alo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_
!mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.ra
!yleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_t
!o_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_ener
!gy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_
!mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz f
!v_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solve
!r_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_cor
!e_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence
!_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_m
!od.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_m
!od.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_
!mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: pk3 delp
!   with respect to varying inputs: pk3 delp
  SUBROUTINE PK3_HALO_BWD(is, ie, js, je, isd, ied, jsd, jed, npz, ptop&
&   , akap, pk3, pk3_ad, delp, delp_ad)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, npz
    REAL(fvprc), INTENT(IN) :: ptop, akap
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(IN) :: delp
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz) :: delp_ad
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz+1), INTENT(INOUT) :: &
&   pk3
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz+1), INTENT(INOUT) :: &
&   pk3_ad
    REAL(fvprc) :: pei(isd:ied)
    REAL(fvprc) :: pei_ad(isd:ied)
    REAL(fvprc) :: pej(jsd:jed)
    REAL(fvprc) :: pej_ad(jsd:jed)
    INTEGER :: i, j, k
    INTRINSIC LOG
    INTRINSIC EXP
    CALL POPREALARRAY(pej, 8*(jed-jsd+1)/8)
    CALL POPREALARRAY(pei, 8*(ied-isd+1)/8)
    pej_ad = 0.0_FVPRC
    DO i=ie+2,is-2,-1
      DO k=npz,1,-1
        CALL POPREALARRAY(pk3(i, je+2, k+1))
        pej_ad(je+2) = pej_ad(je+2) + akap*EXP(akap*LOG(pej(je+2)))*&
&         pk3_ad(i, je+2, k+1)/pej(je+2)
        pk3_ad(i, je+2, k+1) = 0.0_FVPRC
        CALL POPREALARRAY(pk3(i, je+1, k+1))
        pej_ad(je+1) = pej_ad(je+1) + akap*EXP(akap*LOG(pej(je+1)))*&
&         pk3_ad(i, je+1, k+1)/pej(je+1)
        pk3_ad(i, je+1, k+1) = 0.0_FVPRC
        CALL POPREALARRAY(pej(je+2))
        delp_ad(i, je+2, k) = delp_ad(i, je+2, k) + pej_ad(je+2)
        CALL POPREALARRAY(pej(je+1))
        delp_ad(i, je+1, k) = delp_ad(i, je+1, k) + pej_ad(je+1)
      END DO
      CALL POPREALARRAY(pej(je+2))
      pej_ad(je+2) = 0.0_FVPRC
      CALL POPREALARRAY(pej(je+1))
      pej_ad(je+1) = 0.0_FVPRC
      DO k=npz,1,-1
        CALL POPREALARRAY(pk3(i, js-1, k+1))
        pej_ad(js-1) = pej_ad(js-1) + akap*EXP(akap*LOG(pej(js-1)))*&
&         pk3_ad(i, js-1, k+1)/pej(js-1)
        pk3_ad(i, js-1, k+1) = 0.0_FVPRC
        CALL POPREALARRAY(pk3(i, js-2, k+1))
        pej_ad(js-2) = pej_ad(js-2) + akap*EXP(akap*LOG(pej(js-2)))*&
&         pk3_ad(i, js-2, k+1)/pej(js-2)
        pk3_ad(i, js-2, k+1) = 0.0_FVPRC
        CALL POPREALARRAY(pej(js-1))
        delp_ad(i, js-1, k) = delp_ad(i, js-1, k) + pej_ad(js-1)
        CALL POPREALARRAY(pej(js-2))
        delp_ad(i, js-2, k) = delp_ad(i, js-2, k) + pej_ad(js-2)
      END DO
      CALL POPREALARRAY(pej(js-1))
      pej_ad(js-1) = 0.0_FVPRC
      CALL POPREALARRAY(pej(js-2))
      pej_ad(js-2) = 0.0_FVPRC
    END DO
    pei_ad = 0.0_FVPRC
    DO j=je,js,-1
      DO k=npz,1,-1
        CALL POPREALARRAY(pk3(ie+2, j, k+1))
        pei_ad(ie+2) = pei_ad(ie+2) + akap*EXP(akap*LOG(pei(ie+2)))*&
&         pk3_ad(ie+2, j, k+1)/pei(ie+2)
        pk3_ad(ie+2, j, k+1) = 0.0_FVPRC
        CALL POPREALARRAY(pk3(ie+1, j, k+1))
        pei_ad(ie+1) = pei_ad(ie+1) + akap*EXP(akap*LOG(pei(ie+1)))*&
&         pk3_ad(ie+1, j, k+1)/pei(ie+1)
        pk3_ad(ie+1, j, k+1) = 0.0_FVPRC
        CALL POPREALARRAY(pei(ie+2))
        delp_ad(ie+2, j, k) = delp_ad(ie+2, j, k) + pei_ad(ie+2)
        CALL POPREALARRAY(pei(ie+1))
        delp_ad(ie+1, j, k) = delp_ad(ie+1, j, k) + pei_ad(ie+1)
      END DO
      CALL POPREALARRAY(pei(ie+2))
      pei_ad(ie+2) = 0.0_FVPRC
      CALL POPREALARRAY(pei(ie+1))
      pei_ad(ie+1) = 0.0_FVPRC
      DO k=npz,1,-1
        CALL POPREALARRAY(pk3(is-1, j, k+1))
        pei_ad(is-1) = pei_ad(is-1) + akap*EXP(akap*LOG(pei(is-1)))*&
&         pk3_ad(is-1, j, k+1)/pei(is-1)
        pk3_ad(is-1, j, k+1) = 0.0_FVPRC
        CALL POPREALARRAY(pk3(is-2, j, k+1))
        pei_ad(is-2) = pei_ad(is-2) + akap*EXP(akap*LOG(pei(is-2)))*&
&         pk3_ad(is-2, j, k+1)/pei(is-2)
        pk3_ad(is-2, j, k+1) = 0.0_FVPRC
        CALL POPREALARRAY(pei(is-1))
        delp_ad(is-1, j, k) = delp_ad(is-1, j, k) + pei_ad(is-1)
        CALL POPREALARRAY(pei(is-2))
        delp_ad(is-2, j, k) = delp_ad(is-2, j, k) + pei_ad(is-2)
      END DO
      CALL POPREALARRAY(pei(is-1))
      pei_ad(is-1) = 0.0_FVPRC
      CALL POPREALARRAY(pei(is-2))
      pei_ad(is-2) = 0.0_FVPRC
    END DO
  END SUBROUTINE PK3_HALO_BWD
  SUBROUTINE PK3_HALO(is, ie, js, je, isd, ied, jsd, jed, npz, ptop, &
&   akap, pk3, delp)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, npz
    REAL(fvprc), INTENT(IN) :: ptop, akap
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(IN) :: delp
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz+1), INTENT(INOUT) :: &
&   pk3
! Local:
    REAL(fvprc) :: pei(isd:ied)
    REAL(fvprc) :: pej(jsd:jed)
    INTEGER :: i, j, k
    INTRINSIC LOG
    INTRINSIC EXP
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,npz,ptop,delp,pk3,akap) &
!$OMP                          private(pei)
    DO j=js,je
      pei(is-2) = ptop
      pei(is-1) = ptop
      DO k=1,npz
        pei(is-2) = pei(is-2) + delp(is-2, j, k)
        pei(is-1) = pei(is-1) + delp(is-1, j, k)
        pk3(is-2, j, k+1) = EXP(akap*LOG(pei(is-2)))
        pk3(is-1, j, k+1) = EXP(akap*LOG(pei(is-1)))
      END DO
      pei(ie+1) = ptop
      pei(ie+2) = ptop
      DO k=1,npz
        pei(ie+1) = pei(ie+1) + delp(ie+1, j, k)
        pei(ie+2) = pei(ie+2) + delp(ie+2, j, k)
        pk3(ie+1, j, k+1) = EXP(akap*LOG(pei(ie+1)))
        pk3(ie+2, j, k+1) = EXP(akap*LOG(pei(ie+2)))
      END DO
    END DO
!$OMP parallel do default(none) shared(is,ie,js,je,npz,ptop,delp,pk3,akap) &
!$OMP                          private(pej)
    DO i=is-2,ie+2
      pej(js-2) = ptop
      pej(js-1) = ptop
      DO k=1,npz
        pej(js-2) = pej(js-2) + delp(i, js-2, k)
        pej(js-1) = pej(js-1) + delp(i, js-1, k)
        pk3(i, js-2, k+1) = EXP(akap*LOG(pej(js-2)))
        pk3(i, js-1, k+1) = EXP(akap*LOG(pej(js-1)))
      END DO
      pej(je+1) = ptop
      pej(je+2) = ptop
      DO k=1,npz
        pej(je+1) = pej(je+1) + delp(i, je+1, k)
        pej(je+2) = pej(je+2) + delp(i, je+2, k)
        pk3(i, je+1, k+1) = EXP(akap*LOG(pej(je+1)))
        pk3(i, je+2, k+1) = EXP(akap*LOG(pej(je+2)))
      END DO
    END DO
  END SUBROUTINE PK3_HALO
!  Differentiation of pln_halo in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod
!.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_ha
!lo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_m
!od.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.ray
!leigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to
!_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energ
!y fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_m
!od.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv
!_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver
!_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core
!_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_
!corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mo
!d.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mo
!d.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_m
!od.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: pk3 delp
!   with respect to varying inputs: pk3 delp
  SUBROUTINE PLN_HALO_FWD(is, ie, js, je, isd, ied, jsd, jed, npz, ptop&
&   , pk3, delp)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, npz
    REAL(fvprc), INTENT(IN) :: ptop
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(IN) :: delp
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz+1), INTENT(INOUT) :: &
&   pk3
! Local:
    REAL(fvprc) :: pet
    INTEGER :: i, j, k
    INTRINSIC LOG
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,npz,ptop,delp,pk3) &
!$OMP                          private(pet)
    DO j=js,je
      DO i=is-2,is-1
        CALL PUSHREALARRAY(pet)
        pet = ptop
        DO k=1,npz
          CALL PUSHREALARRAY(pet)
          pet = pet + delp(i, j, k)
          CALL PUSHREALARRAY(pk3(i, j, k+1))
          pk3(i, j, k+1) = LOG(pet)
        END DO
      END DO
      DO i=ie+1,ie+2
        CALL PUSHREALARRAY(pet)
        pet = ptop
        DO k=1,npz
          CALL PUSHREALARRAY(pet)
          pet = pet + delp(i, j, k)
          CALL PUSHREALARRAY(pk3(i, j, k+1))
          pk3(i, j, k+1) = LOG(pet)
        END DO
      END DO
    END DO
!$OMP parallel do default(none) shared(is,ie,js,je,npz,ptop,delp,pk3) &
!$OMP                          private(pet)
    DO i=is-2,ie+2
      DO j=js-2,js-1
        CALL PUSHREALARRAY(pet)
        pet = ptop
        DO k=1,npz
          CALL PUSHREALARRAY(pet)
          pet = pet + delp(i, j, k)
          CALL PUSHREALARRAY(pk3(i, j, k+1))
          pk3(i, j, k+1) = LOG(pet)
        END DO
      END DO
      DO j=je+1,je+2
        CALL PUSHREALARRAY(pet)
        pet = ptop
        DO k=1,npz
          CALL PUSHREALARRAY(pet)
          pet = pet + delp(i, j, k)
          CALL PUSHREALARRAY(pk3(i, j, k+1))
          pk3(i, j, k+1) = LOG(pet)
        END DO
      END DO
    END DO
    CALL PUSHREALARRAY(pet)
  END SUBROUTINE PLN_HALO_FWD
!  Differentiation of pln_halo in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mo
!d.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_h
!alo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_
!mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.ra
!yleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_t
!o_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_ener
!gy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_
!mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz f
!v_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solve
!r_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_cor
!e_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence
!_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_m
!od.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_m
!od.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_
!mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: pk3 delp
!   with respect to varying inputs: pk3 delp
  SUBROUTINE PLN_HALO_BWD(is, ie, js, je, isd, ied, jsd, jed, npz, ptop&
&   , pk3, pk3_ad, delp, delp_ad)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, npz
    REAL(fvprc), INTENT(IN) :: ptop
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(IN) :: delp
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz) :: delp_ad
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz+1), INTENT(INOUT) :: &
&   pk3
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz+1), INTENT(INOUT) :: &
&   pk3_ad
    REAL(fvprc) :: pet
    REAL(fvprc) :: pet_ad
    INTEGER :: i, j, k
    INTRINSIC LOG
    CALL POPREALARRAY(pet)
    DO i=ie+2,is-2,-1
      DO j=je+2,je+1,-1
        pet_ad = 0.0_FVPRC
        DO k=npz,1,-1
          CALL POPREALARRAY(pk3(i, j, k+1))
          pet_ad = pet_ad + pk3_ad(i, j, k+1)/pet
          pk3_ad(i, j, k+1) = 0.0_FVPRC
          CALL POPREALARRAY(pet)
          delp_ad(i, j, k) = delp_ad(i, j, k) + pet_ad
        END DO
        CALL POPREALARRAY(pet)
      END DO
      DO j=js-1,js-2,-1
        pet_ad = 0.0_FVPRC
        DO k=npz,1,-1
          CALL POPREALARRAY(pk3(i, j, k+1))
          pet_ad = pet_ad + pk3_ad(i, j, k+1)/pet
          pk3_ad(i, j, k+1) = 0.0_FVPRC
          CALL POPREALARRAY(pet)
          delp_ad(i, j, k) = delp_ad(i, j, k) + pet_ad
        END DO
        CALL POPREALARRAY(pet)
      END DO
    END DO
    DO j=je,js,-1
      DO i=ie+2,ie+1,-1
        pet_ad = 0.0_FVPRC
        DO k=npz,1,-1
          CALL POPREALARRAY(pk3(i, j, k+1))
          pet_ad = pet_ad + pk3_ad(i, j, k+1)/pet
          pk3_ad(i, j, k+1) = 0.0_FVPRC
          CALL POPREALARRAY(pet)
          delp_ad(i, j, k) = delp_ad(i, j, k) + pet_ad
        END DO
        CALL POPREALARRAY(pet)
      END DO
      DO i=is-1,is-2,-1
        pet_ad = 0.0_FVPRC
        DO k=npz,1,-1
          CALL POPREALARRAY(pk3(i, j, k+1))
          pet_ad = pet_ad + pk3_ad(i, j, k+1)/pet
          pk3_ad(i, j, k+1) = 0.0_FVPRC
          CALL POPREALARRAY(pet)
          delp_ad(i, j, k) = delp_ad(i, j, k) + pet_ad
        END DO
        CALL POPREALARRAY(pet)
      END DO
    END DO
  END SUBROUTINE PLN_HALO_BWD
  SUBROUTINE PLN_HALO(is, ie, js, je, isd, ied, jsd, jed, npz, ptop, pk3&
&   , delp)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, npz
    REAL(fvprc), INTENT(IN) :: ptop
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(IN) :: delp
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz+1), INTENT(INOUT) :: &
&   pk3
! Local:
    REAL(fvprc) :: pet
    INTEGER :: i, j, k
    INTRINSIC LOG
!$OMP parallel do default(none) shared(is,ie,js,je,isd,ied,npz,ptop,delp,pk3) &
!$OMP                          private(pet)
    DO j=js,je
      DO i=is-2,is-1
        pet = ptop
        DO k=1,npz
          pet = pet + delp(i, j, k)
          pk3(i, j, k+1) = LOG(pet)
        END DO
      END DO
      DO i=ie+1,ie+2
        pet = ptop
        DO k=1,npz
          pet = pet + delp(i, j, k)
          pk3(i, j, k+1) = LOG(pet)
        END DO
      END DO
    END DO
!$OMP parallel do default(none) shared(is,ie,js,je,npz,ptop,delp,pk3) &
!$OMP                          private(pet)
    DO i=is-2,ie+2
      DO j=js-2,js-1
        pet = ptop
        DO k=1,npz
          pet = pet + delp(i, j, k)
          pk3(i, j, k+1) = LOG(pet)
        END DO
      END DO
      DO j=je+1,je+2
        pet = ptop
        DO k=1,npz
          pet = pet + delp(i, j, k)
          pk3(i, j, k+1) = LOG(pet)
        END DO
      END DO
    END DO
  END SUBROUTINE PLN_HALO
!  Differentiation of pe_halo in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod.
!a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_hal
!o dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mo
!d.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.rayl
!eigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to_
!latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energy
! fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mo
!d.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv_
!tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver_
!c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core_
!mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_c
!orner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod
!.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mod
!.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_mo
!d.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: delp pe
!   with respect to varying inputs: delp pe
  SUBROUTINE PE_HALO_FWD(is, ie, js, je, isd, ied, jsd, jed, npz, ptop, &
&   pe, delp)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, npz
    REAL(fvprc), INTENT(IN) :: ptop
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(IN) :: delp
    REAL(fvprc), DIMENSION(is-1:ie+1, npz+1, js-1:je+1), INTENT(INOUT) &
&   :: pe
! Local:
    INTEGER :: i, j, k
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pe,delp,ptop)
    DO j=js,je
      CALL PUSHREALARRAY(pe(is-1, 1, j))
      pe(is-1, 1, j) = ptop
      CALL PUSHREALARRAY(pe(ie+1, 1, j))
      pe(ie+1, 1, j) = ptop
      DO k=1,npz
        CALL PUSHREALARRAY(pe(is-1, k+1, j))
        pe(is-1, k+1, j) = pe(is-1, k, j) + delp(is-1, j, k)
        CALL PUSHREALARRAY(pe(ie+1, k+1, j))
        pe(ie+1, k+1, j) = pe(ie+1, k, j) + delp(ie+1, j, k)
      END DO
    END DO
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pe,delp,ptop)
    DO i=is-1,ie+1
      CALL PUSHREALARRAY(pe(i, 1, js-1))
      pe(i, 1, js-1) = ptop
      CALL PUSHREALARRAY(pe(i, 1, je+1))
      pe(i, 1, je+1) = ptop
      DO k=1,npz
        CALL PUSHREALARRAY(pe(i, k+1, js-1))
        pe(i, k+1, js-1) = pe(i, k, js-1) + delp(i, js-1, k)
        CALL PUSHREALARRAY(pe(i, k+1, je+1))
        pe(i, k+1, je+1) = pe(i, k, je+1) + delp(i, je+1, k)
      END DO
    END DO
  END SUBROUTINE PE_HALO_FWD
!  Differentiation of pe_halo in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod
!.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_ha
!lo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_m
!od.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.ray
!leigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to
!_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energ
!y fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_m
!od.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv
!_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver
!_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core
!_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_
!corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mo
!d.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mo
!d.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_m
!od.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: delp pe
!   with respect to varying inputs: delp pe
  SUBROUTINE PE_HALO_BWD(is, ie, js, je, isd, ied, jsd, jed, npz, ptop, &
&   pe, pe_ad, delp, delp_ad)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, npz
    REAL(fvprc), INTENT(IN) :: ptop
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(IN) :: delp
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz) :: delp_ad
    REAL(fvprc), DIMENSION(is-1:ie+1, npz+1, js-1:je+1), INTENT(INOUT) &
&   :: pe
    REAL(fvprc), DIMENSION(is-1:ie+1, npz+1, js-1:je+1), INTENT(INOUT) &
&   :: pe_ad
    INTEGER :: i, j, k
    DO i=ie+1,is-1,-1
      DO k=npz,1,-1
        CALL POPREALARRAY(pe(i, k+1, je+1))
        pe_ad(i, k, je+1) = pe_ad(i, k, je+1) + pe_ad(i, k+1, je+1)
        delp_ad(i, je+1, k) = delp_ad(i, je+1, k) + pe_ad(i, k+1, je+1)
        pe_ad(i, k+1, je+1) = 0.0_FVPRC
        CALL POPREALARRAY(pe(i, k+1, js-1))
        pe_ad(i, k, js-1) = pe_ad(i, k, js-1) + pe_ad(i, k+1, js-1)
        delp_ad(i, js-1, k) = delp_ad(i, js-1, k) + pe_ad(i, k+1, js-1)
        pe_ad(i, k+1, js-1) = 0.0_FVPRC
      END DO
      CALL POPREALARRAY(pe(i, 1, je+1))
      pe_ad(i, 1, je+1) = 0.0_FVPRC
      CALL POPREALARRAY(pe(i, 1, js-1))
      pe_ad(i, 1, js-1) = 0.0_FVPRC
    END DO
    DO j=je,js,-1
      DO k=npz,1,-1
        CALL POPREALARRAY(pe(ie+1, k+1, j))
        pe_ad(ie+1, k, j) = pe_ad(ie+1, k, j) + pe_ad(ie+1, k+1, j)
        delp_ad(ie+1, j, k) = delp_ad(ie+1, j, k) + pe_ad(ie+1, k+1, j)
        pe_ad(ie+1, k+1, j) = 0.0_FVPRC
        CALL POPREALARRAY(pe(is-1, k+1, j))
        pe_ad(is-1, k, j) = pe_ad(is-1, k, j) + pe_ad(is-1, k+1, j)
        delp_ad(is-1, j, k) = delp_ad(is-1, j, k) + pe_ad(is-1, k+1, j)
        pe_ad(is-1, k+1, j) = 0.0_FVPRC
      END DO
      CALL POPREALARRAY(pe(ie+1, 1, j))
      pe_ad(ie+1, 1, j) = 0.0_FVPRC
      CALL POPREALARRAY(pe(is-1, 1, j))
      pe_ad(is-1, 1, j) = 0.0_FVPRC
    END DO
  END SUBROUTINE PE_HALO_BWD
  SUBROUTINE PE_HALO(is, ie, js, je, isd, ied, jsd, jed, npz, ptop, pe, &
&   delp)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, npz
    REAL(fvprc), INTENT(IN) :: ptop
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(IN) :: delp
    REAL(fvprc), DIMENSION(is-1:ie+1, npz+1, js-1:je+1), INTENT(INOUT) &
&   :: pe
! Local:
    INTEGER :: i, j, k
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pe,delp,ptop)
    DO j=js,je
      pe(is-1, 1, j) = ptop
      pe(ie+1, 1, j) = ptop
      DO k=1,npz
        pe(is-1, k+1, j) = pe(is-1, k, j) + delp(is-1, j, k)
        pe(ie+1, k+1, j) = pe(ie+1, k, j) + delp(ie+1, j, k)
      END DO
    END DO
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pe,delp,ptop)
    DO i=is-1,ie+1
      pe(i, 1, js-1) = ptop
      pe(i, 1, je+1) = ptop
      DO k=1,npz
        pe(i, k+1, js-1) = pe(i, k, js-1) + delp(i, js-1, k)
        pe(i, k+1, je+1) = pe(i, k, je+1) + delp(i, je+1, k)
      END DO
    END DO
  END SUBROUTINE PE_HALO
!  Differentiation of adv_pe in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod.a
!2b_ord4_fb a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo
! dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod
!.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.rayle
!igh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to_l
!atlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energy 
!fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mod
!.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv_t
!racer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver_c
! nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core_m
!od.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_co
!rner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.
!compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mod.
!copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_mod
!.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: ua om va pem
!   with respect to varying inputs: ua om va pem
  SUBROUTINE ADV_PE_FWD(ua, va, pem, om, gridstruct, bd, npx, npy, npz, &
&   ng)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, npz, ng
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! Contra-variant wind components:
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(IN&
&   ) :: ua, va
! Pressure at edges:
    REAL(fvprc), INTENT(IN) :: pem(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je&
&   +1)
    REAL(fvprc), INTENT(INOUT) :: om(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
! Local:
    REAL(fvprc), DIMENSION(bd%is:bd%ie, bd%js:bd%je) :: up, vp
    REAL(fvprc) :: v3(3, bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: pin(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: pb(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: grad(3, bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: pdx(3, bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: pdy(3, bd%is:bd%ie+1, bd%js:bd%je)
    INTEGER :: i, j, k, n
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
!$OMP parallel do default(none) shared(is,ie,js,je,npz,ua,va,gridstruct,pem,npx,npy,ng,om) &
!$OMP                          private(n, pdx, pdy, pin, pb, up, vp, grad, v3)
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    DO k=1,npz
      IF (k .EQ. npz) THEN
        DO j=js,je
          DO i=is,ie
            up(i, j) = ua(i, j, npz)
            vp(i, j) = va(i, j, npz)
          END DO
        END DO
        CALL PUSHCONTROL1B_FV(1)
      ELSE
        DO j=js,je
          DO i=is,ie
            up(i, j) = 0.5*(ua(i, j, k)+ua(i, j, k+1))
            vp(i, j) = 0.5*(va(i, j, k)+va(i, j, k+1))
          END DO
        END DO
        CALL PUSHCONTROL1B_FV(0)
      END IF
      CALL PUSHREALARRAY(v3, 8*3*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8)
! Compute Vect wind:
      DO j=js,je
        DO i=is,ie
          DO n=1,3
            v3(n, i, j) = up(i, j)*gridstruct%ec1(n, i, j) + vp(i, j)*&
&             gridstruct%ec2(n, i, j)
          END DO
        END DO
      END DO
      DO j=js-1,je+1
        DO i=is-1,ie+1
          pin(i, j) = pem(i, k+1, j)
        END DO
      END DO
! Compute pe at 4 cell corners:
      CALL A2B_ORD2_FWD(pin, pb, gridstruct, npx, npy, is, ie, js, je, &
&                 ng)
      DO j=js,je+1
        DO i=is,ie
          DO n=1,3
            pdx(n, i, j) = (pb(i, j)+pb(i+1, j))*gridstruct%dx(i, j)*&
&             gridstruct%en1(n, i, j)
          END DO
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          DO n=1,3
            pdy(n, i, j) = (pb(i, j)+pb(i, j+1))*gridstruct%dy(i, j)*&
&             gridstruct%en2(n, i, j)
          END DO
        END DO
      END DO
      CALL PUSHREALARRAY(grad, 8*3*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/&
&                   8)
! Compute grad (pe) by Green's theorem
      DO j=js,je
        DO i=is,ie
          DO n=1,3
            grad(n, i, j) = pdx(n, i, j+1) - pdx(n, i, j) - pdy(n, i, j)&
&             + pdy(n, i+1, j)
          END DO
        END DO
      END DO
! Compute inner product: V3 * grad (pe)
      DO j=js,je
        DO i=is,ie
          CALL PUSHREALARRAY(om(i, j, k))
          om(i, j, k) = om(i, j, k) + 0.5*gridstruct%rarea(i, j)*(v3(1, &
&           i, j)*grad(1, i, j)+v3(2, i, j)*grad(2, i, j)+v3(3, i, j)*&
&           grad(3, i, j))
        END DO
      END DO
    END DO
    CALL PUSHINTEGER(js)
    CALL PUSHREALARRAY(v3, 8*3*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8)
    CALL PUSHREALARRAY(grad, 8*3*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8)
    CALL PUSHINTEGER(ie)
    CALL PUSHINTEGER(is)
    CALL PUSHINTEGER(je)
  END SUBROUTINE ADV_PE_FWD
!  Differentiation of adv_pe in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod.
!a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_hal
!o dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mo
!d.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.rayl
!eigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to_
!latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energy
! fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mo
!d.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv_
!tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver_
!c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core_
!mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_c
!orner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod
!.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mod
!.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_mo
!d.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: ua om va pem
!   with respect to varying inputs: ua om va pem
  SUBROUTINE ADV_PE_BWD(ua, ua_ad, va, va_ad, pem, pem_ad, om, om_ad, &
&   gridstruct, bd, npx, npy, npz, ng)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, npz, ng
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(IN&
&   ) :: ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz) :: ua_ad, &
&   va_ad
    REAL(fvprc), INTENT(IN) :: pem(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je&
&   +1)
    REAL(fvprc) :: pem_ad(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1)
    REAL(fvprc), INTENT(INOUT) :: om(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: om_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    REAL(fvprc), DIMENSION(bd%is:bd%ie, bd%js:bd%je) :: up, vp
    REAL(fvprc), DIMENSION(bd%is:bd%ie, bd%js:bd%je) :: up_ad, vp_ad
    REAL(fvprc) :: v3(3, bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: v3_ad(3, bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: pin(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: pin_ad(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: pb(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: pb_ad(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: grad(3, bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: grad_ad(3, bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: pdx(3, bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: pdx_ad(3, bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: pdy(3, bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: pdy_ad(3, bd%is:bd%ie+1, bd%js:bd%je)
    INTEGER :: i, j, k, n
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    INTEGER :: branch
    CALL POPINTEGER(je)
    CALL POPINTEGER(is)
    CALL POPINTEGER(ie)
    CALL POPREALARRAY(grad, 8*3*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8)
    CALL POPREALARRAY(v3, 8*3*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8)
    CALL POPINTEGER(js)
    v3_ad = 0.0_FVPRC
    grad_ad = 0.0_FVPRC
    up_ad = 0.0_FVPRC
    pdx_ad = 0.0_FVPRC
    pdy_ad = 0.0_FVPRC
    pb_ad = 0.0_FVPRC
    vp_ad = 0.0_FVPRC
    pin_ad = 0.0_FVPRC
    DO k=npz,1,-1
      DO j=je,js,-1
        DO i=ie,is,-1
          CALL POPREALARRAY(om(i, j, k))
          temp_ad1 = gridstruct%rarea(i, j)*0.5*om_ad(i, j, k)
          v3_ad(1, i, j) = v3_ad(1, i, j) + grad(1, i, j)*temp_ad1
          grad_ad(1, i, j) = grad_ad(1, i, j) + v3(1, i, j)*temp_ad1
          v3_ad(2, i, j) = v3_ad(2, i, j) + grad(2, i, j)*temp_ad1
          grad_ad(2, i, j) = grad_ad(2, i, j) + v3(2, i, j)*temp_ad1
          v3_ad(3, i, j) = v3_ad(3, i, j) + grad(3, i, j)*temp_ad1
          grad_ad(3, i, j) = grad_ad(3, i, j) + v3(3, i, j)*temp_ad1
        END DO
      END DO
      CALL POPREALARRAY(grad, 8*3*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8&
&                 )
      DO j=js,je
        DO i=ie,is,-1
          DO n=3,1,-1
            pdx_ad(n, i, j+1) = pdx_ad(n, i, j+1) + grad_ad(n, i, j)
            pdx_ad(n, i, j) = pdx_ad(n, i, j) - grad_ad(n, i, j)
            pdy_ad(n, i+1, j) = pdy_ad(n, i+1, j) + grad_ad(n, i, j)
            pdy_ad(n, i, j) = pdy_ad(n, i, j) - grad_ad(n, i, j)
            grad_ad(n, i, j) = 0.0_FVPRC
          END DO
        END DO
      END DO
      DO j=je,js,-1
        DO i=ie+1,is,-1
          DO n=3,1,-1
            temp_ad0 = gridstruct%dy(i, j)*gridstruct%en2(n, i, j)*&
&             pdy_ad(n, i, j)
            pb_ad(i, j) = pb_ad(i, j) + temp_ad0
            pb_ad(i, j+1) = pb_ad(i, j+1) + temp_ad0
            pdy_ad(n, i, j) = 0.0_FVPRC
          END DO
        END DO
      END DO
      DO j=je+1,js,-1
        DO i=ie,is,-1
          DO n=3,1,-1
            temp_ad = gridstruct%dx(i, j)*gridstruct%en1(n, i, j)*pdx_ad&
&             (n, i, j)
            pb_ad(i, j) = pb_ad(i, j) + temp_ad
            pb_ad(i+1, j) = pb_ad(i+1, j) + temp_ad
            pdx_ad(n, i, j) = 0.0_FVPRC
          END DO
        END DO
      END DO
      CALL A2B_ORD2_BWD(pin, pin_ad, pb, pb_ad, gridstruct, npx, npy, is&
&                 , ie, js, je, ng)
      DO j=je+1,js-1,-1
        DO i=ie+1,is-1,-1
          pem_ad(i, k+1, j) = pem_ad(i, k+1, j) + pin_ad(i, j)
          pin_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      CALL POPREALARRAY(v3, 8*3*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8)
      DO j=js,je
        DO i=ie,is,-1
          DO n=3,1,-1
            up_ad(i, j) = up_ad(i, j) + gridstruct%ec1(n, i, j)*v3_ad(n&
&             , i, j)
            vp_ad(i, j) = vp_ad(i, j) + gridstruct%ec2(n, i, j)*v3_ad(n&
&             , i, j)
            v3_ad(n, i, j) = 0.0_FVPRC
          END DO
        END DO
      END DO
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        DO j=je,js,-1
          DO i=ie,is,-1
            va_ad(i, j, k) = va_ad(i, j, k) + 0.5*vp_ad(i, j)
            va_ad(i, j, k+1) = va_ad(i, j, k+1) + 0.5*vp_ad(i, j)
            vp_ad(i, j) = 0.0_FVPRC
            ua_ad(i, j, k) = ua_ad(i, j, k) + 0.5*up_ad(i, j)
            ua_ad(i, j, k+1) = ua_ad(i, j, k+1) + 0.5*up_ad(i, j)
            up_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
      ELSE
        DO j=je,js,-1
          DO i=ie,is,-1
            va_ad(i, j, npz) = va_ad(i, j, npz) + vp_ad(i, j)
            vp_ad(i, j) = 0.0_FVPRC
            ua_ad(i, j, npz) = ua_ad(i, j, npz) + up_ad(i, j)
            up_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
      END IF
    END DO
  END SUBROUTINE ADV_PE_BWD
  SUBROUTINE ADV_PE(ua, va, pem, om, gridstruct, bd, npx, npy, npz, ng)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, npz, ng
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! Contra-variant wind components:
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(IN&
&   ) :: ua, va
! Pressure at edges:
    REAL(fvprc), INTENT(IN) :: pem(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je&
&   +1)
    REAL(fvprc), INTENT(INOUT) :: om(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
! Local:
    REAL(fvprc), DIMENSION(bd%is:bd%ie, bd%js:bd%je) :: up, vp
    REAL(fvprc) :: v3(3, bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: pin(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: pb(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: grad(3, bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: pdx(3, bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: pdy(3, bd%is:bd%ie+1, bd%js:bd%je)
    INTEGER :: i, j, k, n
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
!$OMP parallel do default(none) shared(is,ie,js,je,npz,ua,va,gridstruct,pem,npx,npy,ng,om) &
!$OMP                          private(n, pdx, pdy, pin, pb, up, vp, grad, v3)
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    DO k=1,npz
      IF (k .EQ. npz) THEN
        DO j=js,je
          DO i=is,ie
            up(i, j) = ua(i, j, npz)
            vp(i, j) = va(i, j, npz)
          END DO
        END DO
      ELSE
        DO j=js,je
          DO i=is,ie
            up(i, j) = 0.5*(ua(i, j, k)+ua(i, j, k+1))
            vp(i, j) = 0.5*(va(i, j, k)+va(i, j, k+1))
          END DO
        END DO
      END IF
! Compute Vect wind:
      DO j=js,je
        DO i=is,ie
          DO n=1,3
            v3(n, i, j) = up(i, j)*gridstruct%ec1(n, i, j) + vp(i, j)*&
&             gridstruct%ec2(n, i, j)
          END DO
        END DO
      END DO
      DO j=js-1,je+1
        DO i=is-1,ie+1
          pin(i, j) = pem(i, k+1, j)
        END DO
      END DO
! Compute pe at 4 cell corners:
      CALL A2B_ORD2(pin, pb, gridstruct, npx, npy, is, ie, js, je, ng)
      DO j=js,je+1
        DO i=is,ie
          DO n=1,3
            pdx(n, i, j) = (pb(i, j)+pb(i+1, j))*gridstruct%dx(i, j)*&
&             gridstruct%en1(n, i, j)
          END DO
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          DO n=1,3
            pdy(n, i, j) = (pb(i, j)+pb(i, j+1))*gridstruct%dy(i, j)*&
&             gridstruct%en2(n, i, j)
          END DO
        END DO
      END DO
! Compute grad (pe) by Green's theorem
      DO j=js,je
        DO i=is,ie
          DO n=1,3
            grad(n, i, j) = pdx(n, i, j+1) - pdx(n, i, j) - pdy(n, i, j)&
&             + pdy(n, i+1, j)
          END DO
        END DO
      END DO
! Compute inner product: V3 * grad (pe)
      DO j=js,je
        DO i=is,ie
          om(i, j, k) = om(i, j, k) + 0.5*gridstruct%rarea(i, j)*(v3(1, &
&           i, j)*grad(1, i, j)+v3(2, i, j)*grad(2, i, j)+v3(3, i, j)*&
&           grad(3, i, j))
        END DO
      END DO
    END DO
  END SUBROUTINE ADV_PE
!  Differentiation of p_grad_c in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod
!.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_ha
!lo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_m
!od.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.ray
!leigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to
!_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energ
!y fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_m
!od.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv
!_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver
!_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core
!_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_
!corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mo
!d.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mo
!d.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_m
!od.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: gz uc pkc delpc vc
!   with respect to varying inputs: gz uc pkc delpc vc
  SUBROUTINE P_GRAD_C_FWD(dt2, npz, delpc, pkc, gz, uc, vc, bd, rdxc, &
&   rdyc, hydrostatic)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npz
    REAL(fvprc), INTENT(IN) :: dt2
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:, bd%jsd:, :), INTENT(IN) :: delpc
! pkc is pe**cappa     if hydrostatic
! pkc is full pressure if non-hydrostatic
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1), INTENT(&
&   IN) :: pkc, gz
    REAL(fvprc), INTENT(INOUT) :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(IN) :: rdxc(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: rdyc(bd%isd:bd%ied, bd%jsd:bd%jed)
    LOGICAL, INTENT(IN) :: hydrostatic
! Local:
    REAL(fvprc) :: wk(bd%is-1:bd%ie+1, bd%js-1:bd%je+1, npz)
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
!$OMP parallel do default(none) shared(is,ie,js,je,npz,hydrostatic,pkc,delpc,uc,dt2,rdxc,gz,vc,rdyc) &
!$OMP                          private(wk)
!do k=1,npz
    IF (hydrostatic) THEN
      CALL PUSHINTEGER(js)
      CALL PUSHINTEGER(ie)
      CALL PUSHINTEGER(is)
      CALL PUSHINTEGER(je)
      DO k=1,npz
        DO j=js-1,je+1
          DO i=is-1,ie+1
            wk(i, j, k) = pkc(i, j, k+1) - pkc(i, j, k)
          END DO
        END DO
      END DO
      CALL PUSHCONTROL1B_FV(1)
    ELSE
      CALL PUSHINTEGER(js)
      CALL PUSHINTEGER(ie)
      CALL PUSHINTEGER(is)
      CALL PUSHINTEGER(je)
      DO k=1,npz
        DO j=js-1,je+1
          DO i=is-1,ie+1
            wk(i, j, k) = delpc(i, j, k)
          END DO
        END DO
      END DO
      CALL PUSHCONTROL1B_FV(0)
    END IF
    DO k=1,npz
      DO j=js,je
        DO i=is,ie+1
          uc(i, j, k) = uc(i, j, k) + dt2*rdxc(i, j)/(wk(i-1, j, k)+wk(i&
&           , j, k))*((gz(i-1, j, k+1)-gz(i, j, k))*(pkc(i, j, k+1)-pkc(&
&           i-1, j, k))+(gz(i-1, j, k)-gz(i, j, k+1))*(pkc(i-1, j, k+1)-&
&           pkc(i, j, k)))
        END DO
      END DO
    END DO
    DO k=1,npz
      DO j=js,je+1
        DO i=is,ie
          vc(i, j, k) = vc(i, j, k) + dt2*rdyc(i, j)/(wk(i, j-1, k)+wk(i&
&           , j, k))*((gz(i, j-1, k+1)-gz(i, j, k))*(pkc(i, j, k+1)-pkc(&
&           i, j-1, k))+(gz(i, j-1, k)-gz(i, j, k+1))*(pkc(i, j-1, k+1)-&
&           pkc(i, j, k)))
        END DO
      END DO
    END DO
    CALL PUSHINTEGER(js)
    CALL PUSHINTEGER(ie)
    CALL PUSHINTEGER(is)
    CALL PUSHINTEGER(je)
    CALL PUSHREALARRAY(wk, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+3)*npz/8)
  END SUBROUTINE P_GRAD_C_FWD
!  Differentiation of p_grad_c in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mo
!d.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_h
!alo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_
!mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.ra
!yleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_t
!o_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_ener
!gy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_
!mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz f
!v_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solve
!r_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_cor
!e_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence
!_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_m
!od.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_m
!od.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_
!mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: gz uc pkc delpc vc
!   with respect to varying inputs: gz uc pkc delpc vc
  SUBROUTINE P_GRAD_C_BWD(dt2, npz, delpc, delpc_ad, pkc, pkc_ad, gz, &
&   gz_ad, uc, uc_ad, vc, vc_ad, bd, rdxc, rdyc, hydrostatic)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npz
    REAL(fvprc), INTENT(IN) :: dt2
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:, bd%jsd:, :), INTENT(IN) :: delpc
    REAL(fvprc), DIMENSION(bd%isd:, bd%jsd:, :) :: delpc_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1), INTENT(&
&   IN) :: pkc, gz
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1) :: &
&   pkc_ad, gz_ad
    REAL(fvprc), INTENT(INOUT) :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: uc_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: vc_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), INTENT(IN) :: rdxc(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: rdyc(bd%isd:bd%ied, bd%jsd:bd%jed)
    LOGICAL, INTENT(IN) :: hydrostatic
    REAL(fvprc) :: wk(bd%is-1:bd%ie+1, bd%js-1:bd%je+1, npz)
    REAL(fvprc) :: wk_ad(bd%is-1:bd%ie+1, bd%js-1:bd%je+1, npz)
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    REAL(fvprc) :: temp
    REAL(fvprc) :: temp0
    REAL(fvprc) :: temp1
    REAL(fvprc) :: temp2
    REAL(fvprc) :: temp3
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp4
    REAL(fvprc) :: temp5
    REAL(fvprc) :: temp6
    REAL(fvprc) :: temp7
    REAL(fvprc) :: temp8
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    INTEGER :: branch
    CALL POPREALARRAY(wk, 8*(bd%ie-bd%is+3)*(bd%je-bd%js+3)*npz/8)
    CALL POPINTEGER(je)
    CALL POPINTEGER(is)
    CALL POPINTEGER(ie)
    CALL POPINTEGER(js)
    wk_ad = 0.0_FVPRC
    DO k=npz,1,-1
      DO j=je+1,js,-1
        DO i=ie,is,-1
          temp4 = wk(i, j-1, k) + wk(i, j, k)
          temp8 = pkc(i, j-1, k+1) - pkc(i, j, k)
          temp7 = gz(i, j-1, k) - gz(i, j, k+1)
          temp6 = pkc(i, j, k+1) - pkc(i, j-1, k)
          temp5 = gz(i, j-1, k+1) - gz(i, j, k)
          temp_ad1 = dt2*rdyc(i, j)*vc_ad(i, j, k)/temp4
          temp_ad2 = -((temp5*temp6+temp7*temp8)*temp_ad1/temp4)
          gz_ad(i, j-1, k+1) = gz_ad(i, j-1, k+1) + temp6*temp_ad1
          gz_ad(i, j, k) = gz_ad(i, j, k) - temp6*temp_ad1
          pkc_ad(i, j, k+1) = pkc_ad(i, j, k+1) + temp5*temp_ad1
          pkc_ad(i, j-1, k) = pkc_ad(i, j-1, k) - temp5*temp_ad1
          gz_ad(i, j-1, k) = gz_ad(i, j-1, k) + temp8*temp_ad1
          gz_ad(i, j, k+1) = gz_ad(i, j, k+1) - temp8*temp_ad1
          pkc_ad(i, j-1, k+1) = pkc_ad(i, j-1, k+1) + temp7*temp_ad1
          pkc_ad(i, j, k) = pkc_ad(i, j, k) - temp7*temp_ad1
          wk_ad(i, j-1, k) = wk_ad(i, j-1, k) + temp_ad2
          wk_ad(i, j, k) = wk_ad(i, j, k) + temp_ad2
        END DO
      END DO
    END DO
    DO k=npz,1,-1
      DO j=je,js,-1
        DO i=ie+1,is,-1
          temp = wk(i-1, j, k) + wk(i, j, k)
          temp3 = pkc(i-1, j, k+1) - pkc(i, j, k)
          temp2 = gz(i-1, j, k) - gz(i, j, k+1)
          temp1 = pkc(i, j, k+1) - pkc(i-1, j, k)
          temp0 = gz(i-1, j, k+1) - gz(i, j, k)
          temp_ad = dt2*rdxc(i, j)*uc_ad(i, j, k)/temp
          temp_ad0 = -((temp0*temp1+temp2*temp3)*temp_ad/temp)
          gz_ad(i-1, j, k+1) = gz_ad(i-1, j, k+1) + temp1*temp_ad
          gz_ad(i, j, k) = gz_ad(i, j, k) - temp1*temp_ad
          pkc_ad(i, j, k+1) = pkc_ad(i, j, k+1) + temp0*temp_ad
          pkc_ad(i-1, j, k) = pkc_ad(i-1, j, k) - temp0*temp_ad
          gz_ad(i-1, j, k) = gz_ad(i-1, j, k) + temp3*temp_ad
          gz_ad(i, j, k+1) = gz_ad(i, j, k+1) - temp3*temp_ad
          pkc_ad(i-1, j, k+1) = pkc_ad(i-1, j, k+1) + temp2*temp_ad
          pkc_ad(i, j, k) = pkc_ad(i, j, k) - temp2*temp_ad
          wk_ad(i-1, j, k) = wk_ad(i-1, j, k) + temp_ad0
          wk_ad(i, j, k) = wk_ad(i, j, k) + temp_ad0
        END DO
      END DO
    END DO
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPINTEGER(je)
      CALL POPINTEGER(is)
      CALL POPINTEGER(ie)
      CALL POPINTEGER(js)
      DO k=1,npz
        DO j=je+1,js-1,-1
          DO i=ie+1,is-1,-1
            delpc_ad(i, j, k) = delpc_ad(i, j, k) + wk_ad(i, j, k)
            wk_ad(i, j, k) = 0.0_FVPRC
          END DO
        END DO
      END DO
    ELSE
      CALL POPINTEGER(je)
      CALL POPINTEGER(is)
      CALL POPINTEGER(ie)
      CALL POPINTEGER(js)
      DO k=1,npz
        DO j=je+1,js-1,-1
          DO i=ie+1,is-1,-1
            pkc_ad(i, j, k+1) = pkc_ad(i, j, k+1) + wk_ad(i, j, k)
            pkc_ad(i, j, k) = pkc_ad(i, j, k) - wk_ad(i, j, k)
            wk_ad(i, j, k) = 0.0_FVPRC
          END DO
        END DO
      END DO
    END IF
  END SUBROUTINE P_GRAD_C_BWD
  SUBROUTINE P_GRAD_C(dt2, npz, delpc, pkc, gz, uc, vc, bd, rdxc, rdyc, &
&   hydrostatic)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npz
    REAL(fvprc), INTENT(IN) :: dt2
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:, bd%jsd:, :), INTENT(IN) :: delpc
! pkc is pe**cappa     if hydrostatic
! pkc is full pressure if non-hydrostatic
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1), INTENT(&
&   IN) :: pkc, gz
    REAL(fvprc), INTENT(INOUT) :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(IN) :: rdxc(bd%isd:bd%ied+1, bd%jsd:bd%jed+1)
    REAL(fvprc), INTENT(IN) :: rdyc(bd%isd:bd%ied, bd%jsd:bd%jed)
    LOGICAL, INTENT(IN) :: hydrostatic
! Local:
    REAL(fvprc) :: wk(bd%is-1:bd%ie+1, bd%js-1:bd%je+1, npz)
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
!$OMP parallel do default(none) shared(is,ie,js,je,npz,hydrostatic,pkc,delpc,uc,dt2,rdxc,gz,vc,rdyc) &
!$OMP                          private(wk)
!do k=1,npz
    IF (hydrostatic) THEN
      DO k=1,npz
        DO j=js-1,je+1
          DO i=is-1,ie+1
            wk(i, j, k) = pkc(i, j, k+1) - pkc(i, j, k)
          END DO
        END DO
      END DO
    ELSE
      DO k=1,npz
        DO j=js-1,je+1
          DO i=is-1,ie+1
            wk(i, j, k) = delpc(i, j, k)
          END DO
        END DO
      END DO
    END IF
    DO k=1,npz
      DO j=js,je
        DO i=is,ie+1
          uc(i, j, k) = uc(i, j, k) + dt2*rdxc(i, j)/(wk(i-1, j, k)+wk(i&
&           , j, k))*((gz(i-1, j, k+1)-gz(i, j, k))*(pkc(i, j, k+1)-pkc(&
&           i-1, j, k))+(gz(i-1, j, k)-gz(i, j, k+1))*(pkc(i-1, j, k+1)-&
&           pkc(i, j, k)))
        END DO
      END DO
    END DO
    DO k=1,npz
      DO j=js,je+1
        DO i=is,ie
          vc(i, j, k) = vc(i, j, k) + dt2*rdyc(i, j)/(wk(i, j-1, k)+wk(i&
&           , j, k))*((gz(i, j-1, k+1)-gz(i, j, k))*(pkc(i, j, k+1)-pkc(&
&           i, j-1, k))+(gz(i, j-1, k)-gz(i, j, k+1))*(pkc(i, j-1, k+1)-&
&           pkc(i, j, k)))
        END DO
      END DO
    END DO
  END SUBROUTINE P_GRAD_C
!  Differentiation of nh_p_grad in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mo
!d.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_h
!alo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_
!mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.ra
!yleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_t
!o_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_ener
!gy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_
!mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz f
!v_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solve
!r_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_cor
!e_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence
!_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_m
!od.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_m
!od.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_
!mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: gz u v delp pk pp
!   with respect to varying inputs: gz u v delp pk pp
  SUBROUTINE NH_P_GRAD_FWD(u, v, pp, gz, delp, pk, dt, ng, gridstruct, &
&   bd, npx, npy, npz, use_logp)
    IMPLICIT NONE
! end k-loop
    INTEGER, INTENT(IN) :: ng, npx, npy, npz
    REAL(fvprc), INTENT(IN) :: dt
    LOGICAL, INTENT(IN) :: use_logp
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! perturbation pressure
    REAL(fvprc), INTENT(INOUT) :: pp(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
! p**kappa
    REAL(fvprc), INTENT(INOUT) :: pk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
! g * h
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
! Local:
    REAL(fvprc) :: wk1(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: du1, dv1, top_value
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    IF (use_logp) THEN
      top_value = peln1
    ELSE
      top_value = ptk
    END IF
!Remember that not all compilers set pp to zero by default
!$OMP parallel do default(none) shared(is,ie,js,je,pp,pk,top_value)
    DO j=js,je+1
      DO i=is,ie+1
        CALL PUSHREALARRAY(pp(i, j, 1))
        pp(i, j, 1) = 0.
        CALL PUSHREALARRAY(pk(i, j, 1))
        pk(i, j, 1) = top_value
      END DO
    END DO
!$OMP parallel do default(none) shared(isd,jsd,npz,pp,gridstruct,npx,npy,is,ie,js,je,ng,pk,gz) &
!$OMP                          private(wk1)
    DO k=1,npz+1
      IF (k .NE. 1) THEN
        CALL A2B_ORD4_FWD(pp(isd:ied, jsd:jed, k), wk1, gridstruct, &
&                      npx, npy, is, ie, js, je, ng, .true.)
        CALL A2B_ORD4_FWD(pk(isd:ied, jsd:jed, k), wk1, gridstruct, &
&                      npx, npy, is, ie, js, je, ng, .true.)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      CALL A2B_ORD4_FWD(gz(isd:ied, jsd:jed, k), wk1, gridstruct, npx&
&                    , npy, is, ie, js, je, ng, .true.)
    END DO
!$OMP parallel do default(none) shared(is,ie,js,je,npz,delp,gridstruct,npx,npy,ng,isd,jsd, &
!$OMP                                  pk,dt,gz,u,pp,v) &
!$OMP                          private(wk1, wk, du1, dv1)
    DO k=1,npz
      CALL A2B_ORD4_FWD(delp(isd:ied, jsd:jed, k), wk1, gridstruct, &
&                    npx, npy, is, ie, js, je, ng)
      DO j=js,je+1
        DO i=is,ie+1
          CALL PUSHREALARRAY(wk(i, j))
          wk(i, j) = pk(i, j, k+1) - pk(i, j, k)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
! hydrostatic contributions from past time-step already added in the "beta" part
! Current gradient from "hydrostatic" components:
          du1 = dt/(wk(i, j)+wk(i+1, j))*((gz(i, j, k+1)-gz(i+1, j, k))*&
&           (pk(i+1, j, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i+1, j, k+1))*&
&           (pk(i, j, k+1)-pk(i+1, j, k)))
! Non-hydrostatic contribution
          CALL PUSHREALARRAY(u(i, j, k))
          u(i, j, k) = (u(i, j, k)+du1+dt/(wk1(i, j)+wk1(i+1, j))*((gz(i&
&           , j, k+1)-gz(i+1, j, k))*(pp(i+1, j, k+1)-pp(i, j, k))+(gz(i&
&           , j, k)-gz(i+1, j, k+1))*(pp(i, j, k+1)-pp(i+1, j, k))))*&
&           gridstruct%rdx(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
! Current gradient from "hydrostatic" components:
          dv1 = dt/(wk(i, j)+wk(i, j+1))*((gz(i, j, k+1)-gz(i, j+1, k))*&
&           (pk(i, j+1, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i, j+1, k+1))*&
&           (pk(i, j, k+1)-pk(i, j+1, k)))
! Non-hydrostatic contribution
          CALL PUSHREALARRAY(v(i, j, k))
          v(i, j, k) = (v(i, j, k)+dv1+dt/(wk1(i, j)+wk1(i, j+1))*((gz(i&
&           , j, k+1)-gz(i, j+1, k))*(pp(i, j+1, k+1)-pp(i, j, k))+(gz(i&
&           , j, k)-gz(i, j+1, k+1))*(pp(i, j, k+1)-pp(i, j+1, k))))*&
&           gridstruct%rdy(i, j)
        END DO
      END DO
    END DO
    CALL PUSHINTEGER(js)
    CALL PUSHREALARRAY(wk1, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8&
&                )
    CALL PUSHINTEGER(jsd)
    CALL PUSHINTEGER(ied)
    CALL PUSHINTEGER(ie)
    CALL PUSHINTEGER(isd)
    CALL PUSHINTEGER(is)
    CALL PUSHINTEGER(je)
    CALL PUSHREALARRAY(wk, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
    CALL PUSHINTEGER(jed)
  END SUBROUTINE NH_P_GRAD_FWD
!  Differentiation of nh_p_grad in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_m
!od.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_
!halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core
!_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.r
!ayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_
!to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_ene
!rgy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz
!_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz 
!fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solv
!er_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_co
!re_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergenc
!e_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_
!mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_
!mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core
!_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: gz u v delp pk pp
!   with respect to varying inputs: gz u v delp pk pp
  SUBROUTINE NH_P_GRAD_BWD(u, u_ad, v, v_ad, pp, pp_ad, gz, gz_ad, delp&
&   , delp_ad, pk, pk_ad, dt, ng, gridstruct, bd, npx, npy, npz, &
&   use_logp)
    IMPLICIT NONE
! end k-loop
    INTEGER, INTENT(IN) :: ng, npx, npy, npz
    REAL(fvprc), INTENT(IN) :: dt
    LOGICAL, INTENT(IN) :: use_logp
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: delp_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: pp(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: pp_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: pk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: pk_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: gz_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: u_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: v_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    REAL(fvprc) :: wk1(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk1_ad(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: wk_ad(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: du1, dv1, top_value
    REAL(fvprc) :: du1_ad, dv1_ad
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    REAL(fvprc) :: temp
    REAL(fvprc) :: temp0
    REAL(fvprc) :: temp1
    REAL(fvprc) :: temp2
    REAL(fvprc) :: temp3
    REAL(fvprc) :: temp4
    REAL(fvprc) :: temp5
    REAL(fvprc) :: temp6
    REAL(fvprc) :: temp7
    REAL(fvprc) :: temp8
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp9
    REAL(fvprc) :: temp10
    REAL(fvprc) :: temp11
    REAL(fvprc) :: temp12
    REAL(fvprc) :: temp13
    REAL(fvprc) :: temp14
    REAL(fvprc) :: temp15
    REAL(fvprc) :: temp16
    REAL(fvprc) :: temp17
    REAL(fvprc) :: temp18
    REAL(fvprc) :: temp_ad4
    REAL(fvprc) :: temp_ad5
    REAL(fvprc) :: temp_ad6
    REAL(fvprc) :: temp_ad7
    REAL(fvprc) :: temp_ad8
    INTEGER :: branch
    CALL POPINTEGER(jed)
    CALL POPREALARRAY(wk, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
    CALL POPINTEGER(je)
    CALL POPINTEGER(is)
    CALL POPINTEGER(isd)
    CALL POPINTEGER(ie)
    CALL POPINTEGER(ied)
    CALL POPINTEGER(jsd)
    CALL POPREALARRAY(wk1, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8)
    CALL POPINTEGER(js)
    wk1_ad = 0.0_FVPRC
    wk_ad = 0.0_FVPRC
    DO k=npz,1,-1
      DO j=je,js,-1
        DO i=ie+1,is,-1
          CALL POPREALARRAY(v(i, j, k))
          temp14 = wk1(i, j) + wk1(i, j+1)
          temp18 = pp(i, j, k+1) - pp(i, j+1, k)
          temp17 = gz(i, j, k) - gz(i, j+1, k+1)
          temp16 = pp(i, j+1, k+1) - pp(i, j, k)
          temp15 = gz(i, j, k+1) - gz(i, j+1, k)
          temp_ad4 = gridstruct%rdy(i, j)*v_ad(i, j, k)
          temp_ad5 = dt*temp_ad4/temp14
          temp_ad6 = -((temp15*temp16+temp17*temp18)*temp_ad5/temp14)
          dv1_ad = temp_ad4
          gz_ad(i, j, k+1) = gz_ad(i, j, k+1) + temp16*temp_ad5
          gz_ad(i, j+1, k) = gz_ad(i, j+1, k) - temp16*temp_ad5
          pp_ad(i, j+1, k+1) = pp_ad(i, j+1, k+1) + temp15*temp_ad5
          pp_ad(i, j, k) = pp_ad(i, j, k) - temp15*temp_ad5
          gz_ad(i, j, k) = gz_ad(i, j, k) + temp18*temp_ad5
          gz_ad(i, j+1, k+1) = gz_ad(i, j+1, k+1) - temp18*temp_ad5
          pp_ad(i, j, k+1) = pp_ad(i, j, k+1) + temp17*temp_ad5
          pp_ad(i, j+1, k) = pp_ad(i, j+1, k) - temp17*temp_ad5
          wk1_ad(i, j) = wk1_ad(i, j) + temp_ad6
          wk1_ad(i, j+1) = wk1_ad(i, j+1) + temp_ad6
          v_ad(i, j, k) = temp_ad4
          temp9 = wk(i, j) + wk(i, j+1)
          temp13 = pk(i, j, k+1) - pk(i, j+1, k)
          temp12 = gz(i, j, k) - gz(i, j+1, k+1)
          temp11 = pk(i, j+1, k+1) - pk(i, j, k)
          temp10 = gz(i, j, k+1) - gz(i, j+1, k)
          temp_ad7 = dt*dv1_ad/temp9
          temp_ad8 = -((temp10*temp11+temp12*temp13)*temp_ad7/temp9)
          gz_ad(i, j, k+1) = gz_ad(i, j, k+1) + temp11*temp_ad7
          gz_ad(i, j+1, k) = gz_ad(i, j+1, k) - temp11*temp_ad7
          pk_ad(i, j+1, k+1) = pk_ad(i, j+1, k+1) + temp10*temp_ad7
          pk_ad(i, j, k) = pk_ad(i, j, k) - temp10*temp_ad7
          gz_ad(i, j, k) = gz_ad(i, j, k) + temp13*temp_ad7
          gz_ad(i, j+1, k+1) = gz_ad(i, j+1, k+1) - temp13*temp_ad7
          pk_ad(i, j, k+1) = pk_ad(i, j, k+1) + temp12*temp_ad7
          pk_ad(i, j+1, k) = pk_ad(i, j+1, k) - temp12*temp_ad7
          wk_ad(i, j) = wk_ad(i, j) + temp_ad8
          wk_ad(i, j+1) = wk_ad(i, j+1) + temp_ad8
        END DO
      END DO
      DO j=je+1,js,-1
        DO i=ie,is,-1
          CALL POPREALARRAY(u(i, j, k))
          temp4 = wk1(i, j) + wk1(i+1, j)
          temp8 = pp(i, j, k+1) - pp(i+1, j, k)
          temp7 = gz(i, j, k) - gz(i+1, j, k+1)
          temp6 = pp(i+1, j, k+1) - pp(i, j, k)
          temp5 = gz(i, j, k+1) - gz(i+1, j, k)
          temp_ad = gridstruct%rdx(i, j)*u_ad(i, j, k)
          temp_ad0 = dt*temp_ad/temp4
          temp_ad1 = -((temp5*temp6+temp7*temp8)*temp_ad0/temp4)
          du1_ad = temp_ad
          gz_ad(i, j, k+1) = gz_ad(i, j, k+1) + temp6*temp_ad0
          gz_ad(i+1, j, k) = gz_ad(i+1, j, k) - temp6*temp_ad0
          pp_ad(i+1, j, k+1) = pp_ad(i+1, j, k+1) + temp5*temp_ad0
          pp_ad(i, j, k) = pp_ad(i, j, k) - temp5*temp_ad0
          gz_ad(i, j, k) = gz_ad(i, j, k) + temp8*temp_ad0
          gz_ad(i+1, j, k+1) = gz_ad(i+1, j, k+1) - temp8*temp_ad0
          pp_ad(i, j, k+1) = pp_ad(i, j, k+1) + temp7*temp_ad0
          pp_ad(i+1, j, k) = pp_ad(i+1, j, k) - temp7*temp_ad0
          wk1_ad(i, j) = wk1_ad(i, j) + temp_ad1
          wk1_ad(i+1, j) = wk1_ad(i+1, j) + temp_ad1
          u_ad(i, j, k) = temp_ad
          temp = wk(i, j) + wk(i+1, j)
          temp3 = pk(i, j, k+1) - pk(i+1, j, k)
          temp2 = gz(i, j, k) - gz(i+1, j, k+1)
          temp1 = pk(i+1, j, k+1) - pk(i, j, k)
          temp0 = gz(i, j, k+1) - gz(i+1, j, k)
          temp_ad2 = dt*du1_ad/temp
          temp_ad3 = -((temp0*temp1+temp2*temp3)*temp_ad2/temp)
          gz_ad(i, j, k+1) = gz_ad(i, j, k+1) + temp1*temp_ad2
          gz_ad(i+1, j, k) = gz_ad(i+1, j, k) - temp1*temp_ad2
          pk_ad(i+1, j, k+1) = pk_ad(i+1, j, k+1) + temp0*temp_ad2
          pk_ad(i, j, k) = pk_ad(i, j, k) - temp0*temp_ad2
          gz_ad(i, j, k) = gz_ad(i, j, k) + temp3*temp_ad2
          gz_ad(i+1, j, k+1) = gz_ad(i+1, j, k+1) - temp3*temp_ad2
          pk_ad(i, j, k+1) = pk_ad(i, j, k+1) + temp2*temp_ad2
          pk_ad(i+1, j, k) = pk_ad(i+1, j, k) - temp2*temp_ad2
          wk_ad(i, j) = wk_ad(i, j) + temp_ad3
          wk_ad(i+1, j) = wk_ad(i+1, j) + temp_ad3
        END DO
      END DO
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          CALL POPREALARRAY(wk(i, j))
          pk_ad(i, j, k+1) = pk_ad(i, j, k+1) + wk_ad(i, j)
          pk_ad(i, j, k) = pk_ad(i, j, k) - wk_ad(i, j)
          wk_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      CALL A2B_ORD4_BWD(delp(isd:ied, jsd:jed, k), delp_ad(isd:ied, &
&                    jsd:jed, k), wk1, wk1_ad, gridstruct, npx, npy, is&
&                    , ie, js, je, ng)
    END DO
    DO k=npz+1,1,-1
      CALL A2B_ORD4_BWD(gz(isd:ied, jsd:jed, k), gz_ad(isd:ied, jsd:&
&                    jed, k), wk1, wk1_ad, gridstruct, npx, npy, is, ie&
&                    , js, je, ng, .true.)
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        CALL A2B_ORD4_BWD(pk(isd:ied, jsd:jed, k), pk_ad(isd:ied, jsd&
&                      :jed, k), wk1, wk1_ad, gridstruct, npx, npy, is, &
&                      ie, js, je, ng, .true.)
        CALL A2B_ORD4_BWD(pp(isd:ied, jsd:jed, k), pp_ad(isd:ied, jsd&
&                      :jed, k), wk1, wk1_ad, gridstruct, npx, npy, is, &
&                      ie, js, je, ng, .true.)
      END IF
    END DO
    DO j=je+1,js,-1
      DO i=ie+1,is,-1
        CALL POPREALARRAY(pk(i, j, 1))
        pk_ad(i, j, 1) = 0.0_FVPRC
        CALL POPREALARRAY(pp(i, j, 1))
        pp_ad(i, j, 1) = 0.0_FVPRC
      END DO
    END DO
  END SUBROUTINE NH_P_GRAD_BWD
  SUBROUTINE NH_P_GRAD(u, v, pp, gz, delp, pk, dt, ng, gridstruct, bd, &
&   npx, npy, npz, use_logp)
    IMPLICIT NONE
! end k-loop
    INTEGER, INTENT(IN) :: ng, npx, npy, npz
    REAL(fvprc), INTENT(IN) :: dt
    LOGICAL, INTENT(IN) :: use_logp
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! perturbation pressure
    REAL(fvprc), INTENT(INOUT) :: pp(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
! p**kappa
    REAL(fvprc), INTENT(INOUT) :: pk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
! g * h
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
! Local:
    REAL(fvprc) :: wk1(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: du1, dv1, top_value
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    IF (use_logp) THEN
      top_value = peln1
    ELSE
      top_value = ptk
    END IF
!Remember that not all compilers set pp to zero by default
!$OMP parallel do default(none) shared(is,ie,js,je,pp,pk,top_value)
    DO j=js,je+1
      DO i=is,ie+1
        pp(i, j, 1) = 0.
        pk(i, j, 1) = top_value
      END DO
    END DO
!$OMP parallel do default(none) shared(isd,jsd,npz,pp,gridstruct,npx,npy,is,ie,js,je,ng,pk,gz) &
!$OMP                          private(wk1)
    DO k=1,npz+1
      IF (k .NE. 1) THEN
        CALL A2B_ORD4(pp(isd:ied, jsd:jed, k), wk1, gridstruct, npx, &
&                  npy, is, ie, js, je, ng, .true.)
        CALL A2B_ORD4(pk(isd:ied, jsd:jed, k), wk1, gridstruct, npx, &
&                  npy, is, ie, js, je, ng, .true.)
      END IF
      CALL A2B_ORD4(gz(isd:ied, jsd:jed, k), wk1, gridstruct, npx, &
&                npy, is, ie, js, je, ng, .true.)
    END DO
!$OMP parallel do default(none) shared(is,ie,js,je,npz,delp,gridstruct,npx,npy,ng,isd,jsd, &
!$OMP                                  pk,dt,gz,u,pp,v) &
!$OMP                          private(wk1, wk, du1, dv1)
    DO k=1,npz
      CALL A2B_ORD4(delp(isd:ied, jsd:jed, k), wk1, gridstruct, npx, &
&                npy, is, ie, js, je, ng)
      DO j=js,je+1
        DO i=is,ie+1
          wk(i, j) = pk(i, j, k+1) - pk(i, j, k)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
! hydrostatic contributions from past time-step already added in the "beta" part
! Current gradient from "hydrostatic" components:
          du1 = dt/(wk(i, j)+wk(i+1, j))*((gz(i, j, k+1)-gz(i+1, j, k))*&
&           (pk(i+1, j, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i+1, j, k+1))*&
&           (pk(i, j, k+1)-pk(i+1, j, k)))
! Non-hydrostatic contribution
          u(i, j, k) = (u(i, j, k)+du1+dt/(wk1(i, j)+wk1(i+1, j))*((gz(i&
&           , j, k+1)-gz(i+1, j, k))*(pp(i+1, j, k+1)-pp(i, j, k))+(gz(i&
&           , j, k)-gz(i+1, j, k+1))*(pp(i, j, k+1)-pp(i+1, j, k))))*&
&           gridstruct%rdx(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
! Current gradient from "hydrostatic" components:
          dv1 = dt/(wk(i, j)+wk(i, j+1))*((gz(i, j, k+1)-gz(i, j+1, k))*&
&           (pk(i, j+1, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i, j+1, k+1))*&
&           (pk(i, j, k+1)-pk(i, j+1, k)))
! Non-hydrostatic contribution
          v(i, j, k) = (v(i, j, k)+dv1+dt/(wk1(i, j)+wk1(i, j+1))*((gz(i&
&           , j, k+1)-gz(i, j+1, k))*(pp(i, j+1, k+1)-pp(i, j, k))+(gz(i&
&           , j, k)-gz(i, j+1, k+1))*(pp(i, j, k+1)-pp(i, j+1, k))))*&
&           gridstruct%rdy(i, j)
        END DO
      END DO
    END DO
  END SUBROUTINE NH_P_GRAD
!  Differentiation of split_p_grad in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge
!_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.p
!e_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_co
!re_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod
!.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cube
!d_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_e
!nergy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_ma
!pz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steep
!z fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_so
!lver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_
!core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.diverge
!nce_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_cor
!e_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_cor
!e_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_co
!re_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: gz du u dv v delp pk pp
!   with respect to varying inputs: gz du u dv v delp pk pp
  SUBROUTINE SPLIT_P_GRAD_FWD(u, v, du, dv, pp, gz, delp, pk, beta, dt, &
&   ng, gridstruct, bd, npx, npy, npz, use_logp)
    IMPLICIT NONE
! end k-loop
    INTEGER, INTENT(IN) :: ng, npx, npy, npz
    REAL(fvprc), INTENT(IN) :: beta, dt
    LOGICAL, INTENT(IN) :: use_logp
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! perturbation pressure
    REAL(fvprc), INTENT(INOUT) :: pp(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
! p**kappa
    REAL(fvprc), INTENT(INOUT) :: pk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
! g * h
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: du(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: dv(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
! Local:
    REAL(fvprc) :: wk1(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: alpha, top_value
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    IF (use_logp) THEN
      top_value = peln1
    ELSE
      top_value = ptk
    END IF
    alpha = 1. - beta
    CALL PUSHREALARRAY(pk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*(&
&                 npz+1)/8)
    CALL PUSHREALARRAY(pp, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*(&
&                 npz+1)/8)
    CALL PUSHINTEGER(ie)
    CALL PUSHINTEGER(is)
!$OMP parallel do default(none) shared(is,ie,js,je,pp,pk,top_value)
    DO j=js,je+1
      DO i=is,ie+1
        pp(i, j, 1) = 0.
        pk(i, j, 1) = top_value
      END DO
    END DO
!$OMP parallel do default(none) shared(isd,jsd,npz,pp,gridstruct,npx,npy,is,ie,js,je,ng,pk,gz) &
!$OMP                          private(wk1)
    DO k=1,npz+1
      IF (k .NE. 1) THEN
        CALL A2B_ORD4_FWD(pp(isd:ied, jsd:jed, k), wk1, gridstruct, &
&                      npx, npy, is, ie, js, je, ng, .true.)
        CALL A2B_ORD4_FWD(pk(isd:ied, jsd:jed, k), wk1, gridstruct, &
&                      npx, npy, is, ie, js, je, ng, .true.)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      CALL A2B_ORD4_FWD(gz(isd:ied, jsd:jed, k), wk1, gridstruct, npx&
&                    , npy, is, ie, js, je, ng, .true.)
    END DO
!$OMP parallel do default(none) shared(is,ie,js,je,isd,jsd,npz,delp,gridstruct,npx,npy,ng, &
!$OMP                                  pk,u,beta,du,dt,gz,alpha,pp,v,dv) &
!$OMP                          private(wk1, wk)
    DO k=1,npz
      CALL A2B_ORD4_FWD(delp(isd:ied, jsd:jed, k), wk1, gridstruct, &
&                    npx, npy, is, ie, js, je, ng)
      CALL PUSHREALARRAY(wk, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      DO j=js,je+1
        DO i=is,ie+1
          wk(i, j) = pk(i, j, k+1) - pk(i, j, k)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          CALL PUSHREALARRAY(u(i, j, k))
          u(i, j, k) = u(i, j, k) + beta*du(i, j, k)
! hydrostatic contributions from past time-step already added in the "beta" part
! Current gradient from "hydrostatic" components:
!---------------------------------------------------------------------------------
          du(i, j, k) = dt/(wk(i, j)+wk(i+1, j))*((gz(i, j, k+1)-gz(i+1&
&           , j, k))*(pk(i+1, j, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i+1, &
&           j, k+1))*(pk(i, j, k+1)-pk(i+1, j, k)))
!---------------------------------------------------------------------------------
! Non-hydrostatic contribution
          u(i, j, k) = (u(i, j, k)+alpha*du(i, j, k)+dt/(wk1(i, j)+wk1(i&
&           +1, j))*((gz(i, j, k+1)-gz(i+1, j, k))*(pp(i+1, j, k+1)-pp(i&
&           , j, k))+(gz(i, j, k)-gz(i+1, j, k+1))*(pp(i, j, k+1)-pp(i+1&
&           , j, k))))*gridstruct%rdx(i, j)
        END DO
      END DO
      CALL PUSHREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)*&
&                   npz/8)
      DO j=js,je
        DO i=is,ie+1
          v(i, j, k) = v(i, j, k) + beta*dv(i, j, k)
! Current gradient from "hydrostatic" components:
!---------------------------------------------------------------------------------
          dv(i, j, k) = dt/(wk(i, j)+wk(i, j+1))*((gz(i, j, k+1)-gz(i, j&
&           +1, k))*(pk(i, j+1, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i, j+1&
&           , k+1))*(pk(i, j, k+1)-pk(i, j+1, k)))
!---------------------------------------------------------------------------------
! Non-hydrostatic contribution
          v(i, j, k) = (v(i, j, k)+alpha*dv(i, j, k)+dt/(wk1(i, j)+wk1(i&
&           , j+1))*((gz(i, j, k+1)-gz(i, j+1, k))*(pp(i, j+1, k+1)-pp(i&
&           , j, k))+(gz(i, j, k)-gz(i, j+1, k+1))*(pp(i, j, k+1)-pp(i, &
&           j+1, k))))*gridstruct%rdy(i, j)
        END DO
      END DO
    END DO
    CALL PUSHINTEGER(js)
    CALL PUSHREALARRAY(alpha)
    CALL PUSHREALARRAY(wk1, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8&
&                )
    CALL PUSHINTEGER(jsd)
    CALL PUSHINTEGER(ied)
    CALL PUSHINTEGER(ie)
    CALL PUSHINTEGER(isd)
    CALL PUSHINTEGER(is)
    CALL PUSHINTEGER(je)
    CALL PUSHREALARRAY(wk, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
    CALL PUSHINTEGER(jed)
  END SUBROUTINE SPLIT_P_GRAD_FWD
!  Differentiation of split_p_grad in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edg
!e_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.
!pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_c
!ore_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mo
!d.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cub
!ed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_
!energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_m
!apz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.stee
!pz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_s
!olver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh
!_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.diverg
!ence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_co
!re_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_co
!re_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_c
!ore_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: gz du u dv v delp pk pp
!   with respect to varying inputs: gz du u dv v delp pk pp
  SUBROUTINE SPLIT_P_GRAD_BWD(u, u_ad, v, v_ad, du, du_ad, dv, dv_ad, pp&
&   , pp_ad, gz, gz_ad, delp, delp_ad, pk, pk_ad, beta, dt, ng, &
&   gridstruct, bd, npx, npy, npz, use_logp)
    IMPLICIT NONE
! end k-loop
    INTEGER, INTENT(IN) :: ng, npx, npy, npz
    REAL(fvprc), INTENT(IN) :: beta, dt
    LOGICAL, INTENT(IN) :: use_logp
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: delp_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: pp(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: pp_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: pk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: pk_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: gz_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: du(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: du_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: dv(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: dv_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: u_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: v_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    REAL(fvprc) :: wk1(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk1_ad(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: wk_ad(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: alpha, top_value
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    REAL(fvprc) :: temp
    REAL(fvprc) :: temp0
    REAL(fvprc) :: temp1
    REAL(fvprc) :: temp2
    REAL(fvprc) :: temp3
    REAL(fvprc) :: temp4
    REAL(fvprc) :: temp5
    REAL(fvprc) :: temp6
    REAL(fvprc) :: temp7
    REAL(fvprc) :: temp8
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    INTEGER :: branch
    REAL(fvprc) :: temp9
    REAL(fvprc) :: temp10
    REAL(fvprc) :: temp11
    REAL(fvprc) :: temp12
    REAL(fvprc) :: temp13
    REAL(fvprc) :: temp14
    REAL(fvprc) :: temp15
    REAL(fvprc) :: temp16
    REAL(fvprc) :: temp17
    REAL(fvprc) :: temp18
    REAL(fvprc) :: temp_ad4
    REAL(fvprc) :: temp_ad5
    REAL(fvprc) :: temp_ad6
    REAL(fvprc) :: temp_ad7
    REAL(fvprc) :: temp_ad8
    CALL POPINTEGER(jed)
    CALL POPREALARRAY(wk, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
    CALL POPINTEGER(je)
    CALL POPINTEGER(is)
    CALL POPINTEGER(isd)
    CALL POPINTEGER(ie)
    CALL POPINTEGER(ied)
    CALL POPINTEGER(jsd)
    CALL POPREALARRAY(wk1, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)/8)
    CALL POPREALARRAY(alpha)
    CALL POPINTEGER(js)
    wk1_ad = 0.0_FVPRC
    wk_ad = 0.0_FVPRC
    DO k=npz,1,-1
      CALL POPREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)*&
&                  npz/8)
      DO j=js,je
        DO i=ie+1,is,-1
          temp14 = wk1(i, j) + wk1(i, j+1)
          temp18 = pp(i, j, k+1) - pp(i, j+1, k)
          temp17 = gz(i, j, k) - gz(i, j+1, k+1)
          temp16 = pp(i, j+1, k+1) - pp(i, j, k)
          temp15 = gz(i, j, k+1) - gz(i, j+1, k)
          temp_ad4 = gridstruct%rdy(i, j)*v_ad(i, j, k)
          temp_ad5 = dt*temp_ad4/temp14
          temp_ad6 = -((temp15*temp16+temp17*temp18)*temp_ad5/temp14)
          dv_ad(i, j, k) = dv_ad(i, j, k) + alpha*temp_ad4
          gz_ad(i, j, k+1) = gz_ad(i, j, k+1) + temp16*temp_ad5
          gz_ad(i, j+1, k) = gz_ad(i, j+1, k) - temp16*temp_ad5
          pp_ad(i, j+1, k+1) = pp_ad(i, j+1, k+1) + temp15*temp_ad5
          pp_ad(i, j, k) = pp_ad(i, j, k) - temp15*temp_ad5
          gz_ad(i, j, k) = gz_ad(i, j, k) + temp18*temp_ad5
          gz_ad(i, j+1, k+1) = gz_ad(i, j+1, k+1) - temp18*temp_ad5
          pp_ad(i, j, k+1) = pp_ad(i, j, k+1) + temp17*temp_ad5
          pp_ad(i, j+1, k) = pp_ad(i, j+1, k) - temp17*temp_ad5
          wk1_ad(i, j) = wk1_ad(i, j) + temp_ad6
          wk1_ad(i, j+1) = wk1_ad(i, j+1) + temp_ad6
          v_ad(i, j, k) = temp_ad4
          temp9 = wk(i, j) + wk(i, j+1)
          temp13 = pk(i, j, k+1) - pk(i, j+1, k)
          temp12 = gz(i, j, k) - gz(i, j+1, k+1)
          temp11 = pk(i, j+1, k+1) - pk(i, j, k)
          temp10 = gz(i, j, k+1) - gz(i, j+1, k)
          temp_ad7 = dt*dv_ad(i, j, k)/temp9
          temp_ad8 = -((temp10*temp11+temp12*temp13)*temp_ad7/temp9)
          gz_ad(i, j, k+1) = gz_ad(i, j, k+1) + temp11*temp_ad7
          gz_ad(i, j+1, k) = gz_ad(i, j+1, k) - temp11*temp_ad7
          pk_ad(i, j+1, k+1) = pk_ad(i, j+1, k+1) + temp10*temp_ad7
          pk_ad(i, j, k) = pk_ad(i, j, k) - temp10*temp_ad7
          gz_ad(i, j, k) = gz_ad(i, j, k) + temp13*temp_ad7
          gz_ad(i, j+1, k+1) = gz_ad(i, j+1, k+1) - temp13*temp_ad7
          pk_ad(i, j, k+1) = pk_ad(i, j, k+1) + temp12*temp_ad7
          pk_ad(i, j+1, k) = pk_ad(i, j+1, k) - temp12*temp_ad7
          wk_ad(i, j) = wk_ad(i, j) + temp_ad8
          wk_ad(i, j+1) = wk_ad(i, j+1) + temp_ad8
          dv_ad(i, j, k) = beta*v_ad(i, j, k)
        END DO
      END DO
      DO j=je+1,js,-1
        DO i=ie,is,-1
          temp4 = wk1(i, j) + wk1(i+1, j)
          temp8 = pp(i, j, k+1) - pp(i+1, j, k)
          temp7 = gz(i, j, k) - gz(i+1, j, k+1)
          temp6 = pp(i+1, j, k+1) - pp(i, j, k)
          temp5 = gz(i, j, k+1) - gz(i+1, j, k)
          temp_ad = gridstruct%rdx(i, j)*u_ad(i, j, k)
          temp_ad0 = dt*temp_ad/temp4
          temp_ad1 = -((temp5*temp6+temp7*temp8)*temp_ad0/temp4)
          du_ad(i, j, k) = du_ad(i, j, k) + alpha*temp_ad
          gz_ad(i, j, k+1) = gz_ad(i, j, k+1) + temp6*temp_ad0
          gz_ad(i+1, j, k) = gz_ad(i+1, j, k) - temp6*temp_ad0
          pp_ad(i+1, j, k+1) = pp_ad(i+1, j, k+1) + temp5*temp_ad0
          pp_ad(i, j, k) = pp_ad(i, j, k) - temp5*temp_ad0
          gz_ad(i, j, k) = gz_ad(i, j, k) + temp8*temp_ad0
          gz_ad(i+1, j, k+1) = gz_ad(i+1, j, k+1) - temp8*temp_ad0
          pp_ad(i, j, k+1) = pp_ad(i, j, k+1) + temp7*temp_ad0
          pp_ad(i+1, j, k) = pp_ad(i+1, j, k) - temp7*temp_ad0
          wk1_ad(i, j) = wk1_ad(i, j) + temp_ad1
          wk1_ad(i+1, j) = wk1_ad(i+1, j) + temp_ad1
          u_ad(i, j, k) = temp_ad
          temp = wk(i, j) + wk(i+1, j)
          temp3 = pk(i, j, k+1) - pk(i+1, j, k)
          temp2 = gz(i, j, k) - gz(i+1, j, k+1)
          temp1 = pk(i+1, j, k+1) - pk(i, j, k)
          temp0 = gz(i, j, k+1) - gz(i+1, j, k)
          temp_ad2 = dt*du_ad(i, j, k)/temp
          temp_ad3 = -((temp0*temp1+temp2*temp3)*temp_ad2/temp)
          gz_ad(i, j, k+1) = gz_ad(i, j, k+1) + temp1*temp_ad2
          gz_ad(i+1, j, k) = gz_ad(i+1, j, k) - temp1*temp_ad2
          pk_ad(i+1, j, k+1) = pk_ad(i+1, j, k+1) + temp0*temp_ad2
          pk_ad(i, j, k) = pk_ad(i, j, k) - temp0*temp_ad2
          gz_ad(i, j, k) = gz_ad(i, j, k) + temp3*temp_ad2
          gz_ad(i+1, j, k+1) = gz_ad(i+1, j, k+1) - temp3*temp_ad2
          pk_ad(i, j, k+1) = pk_ad(i, j, k+1) + temp2*temp_ad2
          pk_ad(i+1, j, k) = pk_ad(i+1, j, k) - temp2*temp_ad2
          wk_ad(i, j) = wk_ad(i, j) + temp_ad3
          wk_ad(i+1, j) = wk_ad(i+1, j) + temp_ad3
          du_ad(i, j, k) = beta*u_ad(i, j, k)
          CALL POPREALARRAY(u(i, j, k))
        END DO
      END DO
      CALL POPREALARRAY(wk, 8*(bd%ie-bd%is+2)*(bd%je-bd%js+2)/8)
      DO j=js,je+1
        DO i=ie+1,is,-1
          pk_ad(i, j, k+1) = pk_ad(i, j, k+1) + wk_ad(i, j)
          pk_ad(i, j, k) = pk_ad(i, j, k) - wk_ad(i, j)
          wk_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      CALL A2B_ORD4_BWD(delp(isd:ied, jsd:jed, k), delp_ad(isd:ied, &
&                    jsd:jed, k), wk1, wk1_ad, gridstruct, npx, npy, is&
&                    , ie, js, je, ng)
    END DO
    DO k=npz+1,1,-1
      CALL A2B_ORD4_BWD(gz(isd:ied, jsd:jed, k), gz_ad(isd:ied, jsd:&
&                    jed, k), wk1, wk1_ad, gridstruct, npx, npy, is, ie&
&                    , js, je, ng, .true.)
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        CALL A2B_ORD4_BWD(pk(isd:ied, jsd:jed, k), pk_ad(isd:ied, jsd&
&                      :jed, k), wk1, wk1_ad, gridstruct, npx, npy, is, &
&                      ie, js, je, ng, .true.)
        CALL A2B_ORD4_BWD(pp(isd:ied, jsd:jed, k), pp_ad(isd:ied, jsd&
&                      :jed, k), wk1, wk1_ad, gridstruct, npx, npy, is, &
&                      ie, js, je, ng, .true.)
      END IF
    END DO
    CALL POPINTEGER(is)
    CALL POPINTEGER(ie)
    CALL POPREALARRAY(pp, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*(&
&                npz+1)/8)
    CALL POPREALARRAY(pk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*(&
&                npz+1)/8)
    DO j=js,je+1
      DO i=ie+1,is,-1
        pk_ad(i, j, 1) = 0.0_FVPRC
        pp_ad(i, j, 1) = 0.0_FVPRC
      END DO
    END DO
  END SUBROUTINE SPLIT_P_GRAD_BWD
  SUBROUTINE SPLIT_P_GRAD(u, v, du, dv, pp, gz, delp, pk, beta, dt, ng, &
&   gridstruct, bd, npx, npy, npz, use_logp)
    IMPLICIT NONE
! end k-loop
    INTEGER, INTENT(IN) :: ng, npx, npy, npz
    REAL(fvprc), INTENT(IN) :: beta, dt
    LOGICAL, INTENT(IN) :: use_logp
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! perturbation pressure
    REAL(fvprc), INTENT(INOUT) :: pp(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
! p**kappa
    REAL(fvprc), INTENT(INOUT) :: pk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
! g * h
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: du(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: dv(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
! Local:
    REAL(fvprc) :: wk1(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: wk(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: alpha, top_value
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    IF (use_logp) THEN
      top_value = peln1
    ELSE
      top_value = ptk
    END IF
    alpha = 1. - beta
!$OMP parallel do default(none) shared(is,ie,js,je,pp,pk,top_value)
    DO j=js,je+1
      DO i=is,ie+1
        pp(i, j, 1) = 0.
        pk(i, j, 1) = top_value
      END DO
    END DO
!$OMP parallel do default(none) shared(isd,jsd,npz,pp,gridstruct,npx,npy,is,ie,js,je,ng,pk,gz) &
!$OMP                          private(wk1)
    DO k=1,npz+1
      IF (k .NE. 1) THEN
        CALL A2B_ORD4(pp(isd:ied, jsd:jed, k), wk1, gridstruct, npx, &
&                  npy, is, ie, js, je, ng, .true.)
        CALL A2B_ORD4(pk(isd:ied, jsd:jed, k), wk1, gridstruct, npx, &
&                  npy, is, ie, js, je, ng, .true.)
      END IF
      CALL A2B_ORD4(gz(isd:ied, jsd:jed, k), wk1, gridstruct, npx, &
&                npy, is, ie, js, je, ng, .true.)
    END DO
!$OMP parallel do default(none) shared(is,ie,js,je,isd,jsd,npz,delp,gridstruct,npx,npy,ng, &
!$OMP                                  pk,u,beta,du,dt,gz,alpha,pp,v,dv) &
!$OMP                          private(wk1, wk)
    DO k=1,npz
      CALL A2B_ORD4(delp(isd:ied, jsd:jed, k), wk1, gridstruct, npx, &
&                npy, is, ie, js, je, ng)
      DO j=js,je+1
        DO i=is,ie+1
          wk(i, j) = pk(i, j, k+1) - pk(i, j, k)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          u(i, j, k) = u(i, j, k) + beta*du(i, j, k)
! hydrostatic contributions from past time-step already added in the "beta" part
! Current gradient from "hydrostatic" components:
!---------------------------------------------------------------------------------
          du(i, j, k) = dt/(wk(i, j)+wk(i+1, j))*((gz(i, j, k+1)-gz(i+1&
&           , j, k))*(pk(i+1, j, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i+1, &
&           j, k+1))*(pk(i, j, k+1)-pk(i+1, j, k)))
!---------------------------------------------------------------------------------
! Non-hydrostatic contribution
          u(i, j, k) = (u(i, j, k)+alpha*du(i, j, k)+dt/(wk1(i, j)+wk1(i&
&           +1, j))*((gz(i, j, k+1)-gz(i+1, j, k))*(pp(i+1, j, k+1)-pp(i&
&           , j, k))+(gz(i, j, k)-gz(i+1, j, k+1))*(pp(i, j, k+1)-pp(i+1&
&           , j, k))))*gridstruct%rdx(i, j)
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          v(i, j, k) = v(i, j, k) + beta*dv(i, j, k)
! Current gradient from "hydrostatic" components:
!---------------------------------------------------------------------------------
          dv(i, j, k) = dt/(wk(i, j)+wk(i, j+1))*((gz(i, j, k+1)-gz(i, j&
&           +1, k))*(pk(i, j+1, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i, j+1&
&           , k+1))*(pk(i, j, k+1)-pk(i, j+1, k)))
!---------------------------------------------------------------------------------
! Non-hydrostatic contribution
          v(i, j, k) = (v(i, j, k)+alpha*dv(i, j, k)+dt/(wk1(i, j)+wk1(i&
&           , j+1))*((gz(i, j, k+1)-gz(i, j+1, k))*(pp(i, j+1, k+1)-pp(i&
&           , j, k))+(gz(i, j, k)-gz(i, j+1, k+1))*(pp(i, j, k+1)-pp(i, &
&           j+1, k))))*gridstruct%rdy(i, j)
        END DO
      END DO
    END DO
  END SUBROUTINE SPLIT_P_GRAD
!  Differentiation of one_grad_p in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_m
!od.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_
!halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core
!_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.r
!ayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_
!to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_ene
!rgy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz
!_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz 
!fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solv
!er_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_co
!re_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergenc
!e_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_
!mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_
!mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core
!_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: gz u v delp pk divg2
!   with respect to varying inputs: gz u v delp pk divg2
  SUBROUTINE ONE_GRAD_P_FWD(u, v, pk, gz, divg2, delp, dt, ng, &
&   gridstruct, bd, npx, npy, npz, ptop, hydrostatic, a2b_ord, d_ext)
    IMPLICIT NONE
! end k-loop
    INTEGER, INTENT(IN) :: ng, npx, npy, npz, a2b_ord
    REAL(fvprc), INTENT(IN) :: dt, ptop, d_ext
    LOGICAL, INTENT(IN) :: hydrostatic
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: divg2(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(INOUT) :: pk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
! Local:
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1) :: wk
    REAL(fvprc) :: wk1(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: wk2(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: top_value
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    IF (hydrostatic) THEN
! pk is pe**kappa if hydrostatic
      top_value = ptk
    ELSE
! pk is full pressure if non-hydrostatic
      top_value = ptop
    END IF
!$OMP parallel do default(none) shared(is,ie,js,je,pk,top_value)
    DO j=js,je+1
      DO i=is,ie+1
        CALL PUSHREALARRAY(pk(i, j, 1))
        pk(i, j, 1) = top_value
      END DO
    END DO
!$OMP parallel do default(none) shared(npz,isd,jsd,pk,gridstruct,npx,npy,is,ie,js,je,ng,a2b_ord) &
!$OMP                          private(wk)
!do k=2,npz+1
    IF (a2b_ord .EQ. 4) THEN
      DO k=2,npz+1
        CALL A2B_ORD4_FWD(pk(isd:ied, jsd:jed, k), wk(:, :, k), &
&                      gridstruct, npx, npy, is, ie, js, je, ng, .true.)
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      DO k=2,npz+1
        CALL A2B_ORD2_FWD(pk(isd:ied, jsd:jed, k), wk(:, :, k), &
&                   gridstruct, npx, npy, is, ie, js, je, ng, .true.)
      END DO
      CALL PUSHCONTROL1B_FV(1)
    END IF
!enddo
!$OMP parallel do default(none) shared(npz,isd,jsd,gz,gridstruct,npx,npy,is,ie,js,je,ng,a2b_ord) &
!$OMP                          private(wk)
!do k=1,npz+1
    IF (a2b_ord .EQ. 4) THEN
      DO k=1,npz+1
        CALL A2B_ORD4_FWD(gz(isd:ied, jsd:jed, k), wk(:, :, k), &
&                      gridstruct, npx, npy, is, ie, js, je, ng, .true.)
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      DO k=1,npz+1
        CALL A2B_ORD2_FWD(gz(isd:ied, jsd:jed, k), wk(:, :, k), &
&                   gridstruct, npx, npy, is, ie, js, je, ng, .true.)
      END DO
      CALL PUSHCONTROL1B_FV(1)
    END IF
!enddo
    IF (d_ext .GT. 0.) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,wk2,divg2)
      DO j=js,je+1
        DO i=is,ie
          wk2(i, j) = divg2(i, j) - divg2(i+1, j)
        END DO
      END DO
!$OMP parallel do default(none) shared(is,ie,js,je,wk1,divg2)
      DO j=js,je
        DO i=is,ie+1
          wk1(i, j) = divg2(i, j) - divg2(i, j+1)
        END DO
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
!$OMP parallel do default(none) shared(is,ie,js,je,wk1,wk2)
      DO j=js,je+1
        DO i=is,ie
          wk2(i, j) = 0.
        END DO
        DO i=is,ie+1
          wk1(i, j) = 0.
        END DO
      END DO
    END IF
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pk,delp,hydrostatic,a2b_ord,gridstruct, &
!$OMP                                  npx,npy,isd,jsd,ng,u,v,wk2,dt,gz,wk1) &
!$OMP                          private(wk)
!do k=1,npz
    wk = 0.0_FVPRC
    IF (hydrostatic) THEN
      DO k=1,npz
        DO j=js,je+1
          DO i=is,ie+1
            wk(i, j, k) = pk(i, j, k+1) - pk(i, j, k)
          END DO
        END DO
      END DO
      CALL PUSHCONTROL2B_FV(2)
    ELSE IF (a2b_ord .EQ. 4) THEN
!do k=1,npz
      DO k=1,npz
        CALL A2B_ORD4_FWD(delp(isd:ied, jsd:jed, k), wk(:, :, k), &
&                      gridstruct, npx, npy, is, ie, js, je, ng)
      END DO
      CALL PUSHCONTROL2B_FV(1)
    ELSE
      DO k=1,npz
        CALL A2B_ORD2_FWD(delp(isd:ied, jsd:jed, k), wk(:, :, k), &
&                   gridstruct, npx, npy, is, ie, js, je, ng)
      END DO
      CALL PUSHCONTROL2B_FV(0)
    END IF
    CALL PUSHREALARRAY(u, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)*npz&
&                 /8)
    CALL PUSHREALARRAY(wk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*(&
&                 npz+1)/8)
!      enddo
    DO k=1,npz
      DO j=js,je+1
        DO i=is,ie
          u(i, j, k) = gridstruct%rdx(i, j)*(wk2(i, j)+u(i, j, k)+dt/(wk&
&           (i, j, k)+wk(i+1, j, k))*((gz(i, j, k+1)-gz(i+1, j, k))*(pk(&
&           i+1, j, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i+1, j, k+1))*(pk(&
&           i, j, k+1)-pk(i+1, j, k))))
        END DO
      END DO
    END DO
    CALL PUSHREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)*npz&
&                 /8)
! end k-loop
    DO k=1,npz
      DO j=js,je
        DO i=is,ie+1
          v(i, j, k) = gridstruct%rdy(i, j)*(wk1(i, j)+v(i, j, k)+dt/(wk&
&           (i, j, k)+wk(i, j+1, k))*((gz(i, j, k+1)-gz(i, j+1, k))*(pk(&
&           i, j+1, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i, j+1, k+1))*(pk(&
&           i, j, k+1)-pk(i, j+1, k))))
        END DO
      END DO
    END DO
    CALL PUSHINTEGER(js)
    CALL PUSHINTEGER(jsd)
    CALL PUSHINTEGER(ied)
    CALL PUSHINTEGER(ie)
    CALL PUSHINTEGER(isd)
    CALL PUSHINTEGER(is)
    CALL PUSHINTEGER(je)
    CALL PUSHREALARRAY(wk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*(&
&                 npz+1)/8)
    CALL PUSHINTEGER(jed)
  END SUBROUTINE ONE_GRAD_P_FWD
!  Differentiation of one_grad_p in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_
!mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe
!_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_cor
!e_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.
!rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed
!_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_en
!ergy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_map
!z_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz
! fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_sol
!ver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_c
!ore_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergen
!ce_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core
!_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core
!_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_cor
!e_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: gz u v delp pk divg2
!   with respect to varying inputs: gz u v delp pk divg2
  SUBROUTINE ONE_GRAD_P_BWD(u, u_ad, v, v_ad, pk, pk_ad, gz, gz_ad, &
&   divg2, divg2_ad, delp, delp_ad, dt, ng, gridstruct, bd, npx, npy, &
&   npz, ptop, hydrostatic, a2b_ord, d_ext)
    IMPLICIT NONE
! end k-loop
    INTEGER, INTENT(IN) :: ng, npx, npy, npz, a2b_ord
    REAL(fvprc), INTENT(IN) :: dt, ptop, d_ext
    LOGICAL, INTENT(IN) :: hydrostatic
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: divg2(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: divg2_ad(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(INOUT) :: pk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: pk_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: gz_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: delp_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: u_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: v_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1) :: wk
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1) :: wk_ad
    REAL(fvprc) :: wk1(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: wk1_ad(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: wk2(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: wk2_ad(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: top_value
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    REAL(fvprc) :: temp
    REAL(fvprc) :: temp0
    REAL(fvprc) :: temp1
    REAL(fvprc) :: temp2
    REAL(fvprc) :: temp3
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp4
    REAL(fvprc) :: temp5
    REAL(fvprc) :: temp6
    REAL(fvprc) :: temp7
    REAL(fvprc) :: temp8
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp_ad4
    INTEGER :: branch
    CALL POPINTEGER(jed)
    CALL POPREALARRAY(wk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*(&
&                npz+1)/8)
    CALL POPINTEGER(je)
    CALL POPINTEGER(is)
    CALL POPINTEGER(isd)
    CALL POPINTEGER(ie)
    CALL POPINTEGER(ied)
    CALL POPINTEGER(jsd)
    CALL POPINTEGER(js)
    wk1_ad = 0.0_FVPRC
    wk_ad = 0.0_FVPRC
    CALL POPREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)*npz/&
&                8)
    DO k=1,npz
      DO j=je,js,-1
        DO i=ie+1,is,-1
          temp4 = wk(i, j, k) + wk(i, j+1, k)
          temp8 = pk(i, j, k+1) - pk(i, j+1, k)
          temp7 = gz(i, j, k) - gz(i, j+1, k+1)
          temp6 = pk(i, j+1, k+1) - pk(i, j, k)
          temp5 = gz(i, j, k+1) - gz(i, j+1, k)
          temp_ad2 = gridstruct%rdy(i, j)*v_ad(i, j, k)
          temp_ad3 = dt*temp_ad2/temp4
          temp_ad4 = -((temp5*temp6+temp7*temp8)*temp_ad3/temp4)
          wk1_ad(i, j) = wk1_ad(i, j) + temp_ad2
          gz_ad(i, j, k+1) = gz_ad(i, j, k+1) + temp6*temp_ad3
          gz_ad(i, j+1, k) = gz_ad(i, j+1, k) - temp6*temp_ad3
          pk_ad(i, j+1, k+1) = pk_ad(i, j+1, k+1) + temp5*temp_ad3
          pk_ad(i, j, k) = pk_ad(i, j, k) - temp5*temp_ad3
          gz_ad(i, j, k) = gz_ad(i, j, k) + temp8*temp_ad3
          gz_ad(i, j+1, k+1) = gz_ad(i, j+1, k+1) - temp8*temp_ad3
          pk_ad(i, j, k+1) = pk_ad(i, j, k+1) + temp7*temp_ad3
          pk_ad(i, j+1, k) = pk_ad(i, j+1, k) - temp7*temp_ad3
          wk_ad(i, j, k) = wk_ad(i, j, k) + temp_ad4
          wk_ad(i, j+1, k) = wk_ad(i, j+1, k) + temp_ad4
          v_ad(i, j, k) = temp_ad2
        END DO
      END DO
    END DO
    wk2_ad = 0.0_FVPRC
    CALL POPREALARRAY(wk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*(&
&                npz+1)/8)
    CALL POPREALARRAY(u, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)*npz/&
&                8)
    DO k=1,npz
      DO j=je+1,js,-1
        DO i=ie,is,-1
          temp = wk(i, j, k) + wk(i+1, j, k)
          temp3 = pk(i, j, k+1) - pk(i+1, j, k)
          temp2 = gz(i, j, k) - gz(i+1, j, k+1)
          temp1 = pk(i+1, j, k+1) - pk(i, j, k)
          temp0 = gz(i, j, k+1) - gz(i+1, j, k)
          temp_ad = gridstruct%rdx(i, j)*u_ad(i, j, k)
          temp_ad0 = dt*temp_ad/temp
          temp_ad1 = -((temp0*temp1+temp2*temp3)*temp_ad0/temp)
          wk2_ad(i, j) = wk2_ad(i, j) + temp_ad
          gz_ad(i, j, k+1) = gz_ad(i, j, k+1) + temp1*temp_ad0
          gz_ad(i+1, j, k) = gz_ad(i+1, j, k) - temp1*temp_ad0
          pk_ad(i+1, j, k+1) = pk_ad(i+1, j, k+1) + temp0*temp_ad0
          pk_ad(i, j, k) = pk_ad(i, j, k) - temp0*temp_ad0
          gz_ad(i, j, k) = gz_ad(i, j, k) + temp3*temp_ad0
          gz_ad(i+1, j, k+1) = gz_ad(i+1, j, k+1) - temp3*temp_ad0
          pk_ad(i, j, k+1) = pk_ad(i, j, k+1) + temp2*temp_ad0
          pk_ad(i+1, j, k) = pk_ad(i+1, j, k) - temp2*temp_ad0
          wk_ad(i, j, k) = wk_ad(i, j, k) + temp_ad1
          wk_ad(i+1, j, k) = wk_ad(i+1, j, k) + temp_ad1
          u_ad(i, j, k) = temp_ad
        END DO
      END DO
    END DO
    CALL POPCONTROL2B_FV(branch)
    IF (branch .EQ. 0) THEN
      DO k=npz,1,-1
        CALL A2B_ORD2_BWD(delp(isd:ied, jsd:jed, k), delp_ad(isd:ied, &
&                   jsd:jed, k), wk(:, :, k), wk_ad(:, :, k), gridstruct&
&                   , npx, npy, is, ie, js, je, ng)
      END DO
    ELSE IF (branch .EQ. 1) THEN
      DO k=npz,1,-1
        CALL A2B_ORD4_BWD(delp(isd:ied, jsd:jed, k), delp_ad(isd:ied&
&                      , jsd:jed, k), wk(:, :, k), wk_ad(:, :, k), &
&                      gridstruct, npx, npy, is, ie, js, je, ng)
      END DO
    ELSE
      DO k=1,npz
        DO j=je+1,js,-1
          DO i=ie+1,is,-1
            pk_ad(i, j, k+1) = pk_ad(i, j, k+1) + wk_ad(i, j, k)
            pk_ad(i, j, k) = pk_ad(i, j, k) - wk_ad(i, j, k)
            wk_ad(i, j, k) = 0.0_FVPRC
          END DO
        END DO
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      DO j=je,js,-1
        DO i=ie+1,is,-1
          divg2_ad(i, j) = divg2_ad(i, j) + wk1_ad(i, j)
          divg2_ad(i, j+1) = divg2_ad(i, j+1) - wk1_ad(i, j)
          wk1_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
      DO j=je+1,js,-1
        DO i=ie,is,-1
          divg2_ad(i, j) = divg2_ad(i, j) + wk2_ad(i, j)
          divg2_ad(i+1, j) = divg2_ad(i+1, j) - wk2_ad(i, j)
          wk2_ad(i, j) = 0.0_FVPRC
        END DO
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      wk_ad = 0.0_FVPRC
      DO k=npz+1,1,-1
        CALL A2B_ORD4_BWD(gz(isd:ied, jsd:jed, k), gz_ad(isd:ied, jsd&
&                      :jed, k), wk(:, :, k), wk_ad(:, :, k), gridstruct&
&                      , npx, npy, is, ie, js, je, ng, .true.)
      END DO
    ELSE
      wk_ad = 0.0_FVPRC
      DO k=npz+1,1,-1
        CALL A2B_ORD2_BWD(gz(isd:ied, jsd:jed, k), gz_ad(isd:ied, jsd:&
&                   jed, k), wk(:, :, k), wk_ad(:, :, k), gridstruct, &
&                   npx, npy, is, ie, js, je, ng, .true.)
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      DO k=npz+1,2,-1
        CALL A2B_ORD4_BWD(pk(isd:ied, jsd:jed, k), pk_ad(isd:ied, jsd&
&                      :jed, k), wk(:, :, k), wk_ad(:, :, k), gridstruct&
&                      , npx, npy, is, ie, js, je, ng, .true.)
      END DO
    ELSE
      DO k=npz+1,2,-1
        CALL A2B_ORD2_BWD(pk(isd:ied, jsd:jed, k), pk_ad(isd:ied, jsd:&
&                   jed, k), wk(:, :, k), wk_ad(:, :, k), gridstruct, &
&                   npx, npy, is, ie, js, je, ng, .true.)
      END DO
    END IF
    DO j=je+1,js,-1
      DO i=ie+1,is,-1
        CALL POPREALARRAY(pk(i, j, 1))
        pk_ad(i, j, 1) = 0.0_FVPRC
      END DO
    END DO
  END SUBROUTINE ONE_GRAD_P_BWD
  SUBROUTINE ONE_GRAD_P(u, v, pk, gz, divg2, delp, dt, ng, gridstruct, &
&   bd, npx, npy, npz, ptop, hydrostatic, a2b_ord, d_ext)
    IMPLICIT NONE
! end k-loop
    INTEGER, INTENT(IN) :: ng, npx, npy, npz, a2b_ord
    REAL(fvprc), INTENT(IN) :: dt, ptop, d_ext
    LOGICAL, INTENT(IN) :: hydrostatic
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: divg2(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(INOUT) :: pk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
! Local:
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1) :: wk
    REAL(fvprc) :: wk1(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: wk2(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: top_value
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    IF (hydrostatic) THEN
! pk is pe**kappa if hydrostatic
      top_value = ptk
    ELSE
! pk is full pressure if non-hydrostatic
      top_value = ptop
    END IF
!$OMP parallel do default(none) shared(is,ie,js,je,pk,top_value)
    DO j=js,je+1
      DO i=is,ie+1
        pk(i, j, 1) = top_value
      END DO
    END DO
!$OMP parallel do default(none) shared(npz,isd,jsd,pk,gridstruct,npx,npy,is,ie,js,je,ng,a2b_ord) &
!$OMP                          private(wk)
!do k=2,npz+1
    IF (a2b_ord .EQ. 4) THEN
      DO k=2,npz+1
        CALL A2B_ORD4(pk(isd:ied, jsd:jed, k), wk(:, :, k), &
&                  gridstruct, npx, npy, is, ie, js, je, ng, .true.)
      END DO
    ELSE
      DO k=2,npz+1
        CALL A2B_ORD2(pk(isd:ied, jsd:jed, k), wk(:, :, k), gridstruct, &
&               npx, npy, is, ie, js, je, ng, .true.)
      END DO
    END IF
!enddo
!$OMP parallel do default(none) shared(npz,isd,jsd,gz,gridstruct,npx,npy,is,ie,js,je,ng,a2b_ord) &
!$OMP                          private(wk)
!do k=1,npz+1
    IF (a2b_ord .EQ. 4) THEN
      DO k=1,npz+1
        CALL A2B_ORD4(gz(isd:ied, jsd:jed, k), wk(:, :, k), &
&                  gridstruct, npx, npy, is, ie, js, je, ng, .true.)
      END DO
    ELSE
      DO k=1,npz+1
        CALL A2B_ORD2(gz(isd:ied, jsd:jed, k), wk(:, :, k), gridstruct, &
&               npx, npy, is, ie, js, je, ng, .true.)
      END DO
    END IF
!enddo
    IF (d_ext .GT. 0.) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,wk2,divg2)
      DO j=js,je+1
        DO i=is,ie
          wk2(i, j) = divg2(i, j) - divg2(i+1, j)
        END DO
      END DO
!$OMP parallel do default(none) shared(is,ie,js,je,wk1,divg2)
      DO j=js,je
        DO i=is,ie+1
          wk1(i, j) = divg2(i, j) - divg2(i, j+1)
        END DO
      END DO
    ELSE
!$OMP parallel do default(none) shared(is,ie,js,je,wk1,wk2)
      DO j=js,je+1
        DO i=is,ie
          wk2(i, j) = 0.
        END DO
        DO i=is,ie+1
          wk1(i, j) = 0.
        END DO
      END DO
    END IF
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pk,delp,hydrostatic,a2b_ord,gridstruct, &
!$OMP                                  npx,npy,isd,jsd,ng,u,v,wk2,dt,gz,wk1) &
!$OMP                          private(wk)
!do k=1,npz
    wk = 0.0_FVPRC
    IF (hydrostatic) THEN
      DO k=1,npz
        DO j=js,je+1
          DO i=is,ie+1
            wk(i, j, k) = pk(i, j, k+1) - pk(i, j, k)
          END DO
        END DO
      END DO
    ELSE IF (a2b_ord .EQ. 4) THEN
!do k=1,npz
      DO k=1,npz
        CALL A2B_ORD4(delp(isd:ied, jsd:jed, k), wk(:, :, k), &
&                  gridstruct, npx, npy, is, ie, js, je, ng)
      END DO
    ELSE
      DO k=1,npz
        CALL A2B_ORD2(delp(isd:ied, jsd:jed, k), wk(:, :, k), gridstruct&
&               , npx, npy, is, ie, js, je, ng)
      END DO
    END IF
!      enddo
    DO k=1,npz
      DO j=js,je+1
        DO i=is,ie
          u(i, j, k) = gridstruct%rdx(i, j)*(wk2(i, j)+u(i, j, k)+dt/(wk&
&           (i, j, k)+wk(i+1, j, k))*((gz(i, j, k+1)-gz(i+1, j, k))*(pk(&
&           i+1, j, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i+1, j, k+1))*(pk(&
&           i, j, k+1)-pk(i+1, j, k))))
        END DO
      END DO
    END DO
! end k-loop
    DO k=1,npz
      DO j=js,je
        DO i=is,ie+1
          v(i, j, k) = gridstruct%rdy(i, j)*(wk1(i, j)+v(i, j, k)+dt/(wk&
&           (i, j, k)+wk(i, j+1, k))*((gz(i, j, k+1)-gz(i, j+1, k))*(pk(&
&           i, j+1, k+1)-pk(i, j, k))+(gz(i, j, k)-gz(i, j+1, k+1))*(pk(&
&           i, j, k+1)-pk(i, j+1, k))))
        END DO
      END DO
    END DO
  END SUBROUTINE ONE_GRAD_P
!  Differentiation of grad1_p_update in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_ed
!ge_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod
!.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_
!core_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_m
!od.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cu
!bed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total
!_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_
!mapz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.ste
!epz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_
!solver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver n
!h_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.diver
!gence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_c
!ore_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_c
!ore_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_
!core_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: gz du u dv v pk divg2
!   with respect to varying inputs: gz du u dv v pk divg2
  SUBROUTINE GRAD1_P_UPDATE_FWD(divg2, u, v, du, dv, pk, gz, dt, ng, &
&   gridstruct, bd, npx, npy, npz, ptop, beta, a2b_ord)
    IMPLICIT NONE
! end k-loop
    INTEGER, INTENT(IN) :: ng, npx, npy, npz, a2b_ord
    REAL(fvprc), INTENT(IN) :: dt, ptop, beta
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: divg2(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(INOUT) :: pk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    REAL(fvprc), INTENT(INOUT) :: du(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: dv(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
! Local:
    REAL(fvprc) :: wk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: top_value, alpha
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    alpha = 1. - beta
! pk is pe**kappa if hydrostatic
    top_value = ptk
    CALL PUSHREALARRAY(pk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*(&
&                 npz+1)/8)
    CALL PUSHINTEGER(ie)
    CALL PUSHINTEGER(is)
!$OMP parallel do default(none) shared(is,ie,js,je,pk,top_value)
    DO j=js,je+1
      DO i=is,ie+1
        pk(i, j, 1) = top_value
      END DO
    END DO
!$OMP parallel do default(none) shared(npz,isd,jsd,pk,gridstruct,npx,npy,is,ie,js,je,ng,a2b_ord) &
!$OMP                          private(wk)
!do k=2,npz+1
    IF (a2b_ord .EQ. 4) THEN
      DO k=2,npz+1
        CALL A2B_ORD4_FWD(pk(isd:ied, jsd:jed, k), wk(:, :, k), &
&                      gridstruct, npx, npy, is, ie, js, je, ng, .true.)
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      DO k=2,npz+1
        CALL A2B_ORD2_FWD(pk(isd:ied, jsd:jed, k), wk(:, :, k), &
&                   gridstruct, npx, npy, is, ie, js, je, ng, .true.)
      END DO
      CALL PUSHCONTROL1B_FV(1)
    END IF
!enddo
!$OMP parallel do default(none) shared(npz,isd,jsd,gz,gridstruct,npx,npy,is,ie,js,je,ng,a2b_ord) &
!$OMP                          private(wk)
!do k=1,npz+1
    IF (a2b_ord .EQ. 4) THEN
      DO k=1,npz+1
        CALL A2B_ORD4_FWD(gz(isd:ied, jsd:jed, k), wk(:, :, k), &
&                      gridstruct, npx, npy, is, ie, js, je, ng, .true.)
      END DO
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      DO k=1,npz+1
        CALL A2B_ORD2_FWD(gz(isd:ied, jsd:jed, k), wk(:, :, k), &
&                   gridstruct, npx, npy, is, ie, js, je, ng, .true.)
      END DO
      CALL PUSHCONTROL1B_FV(1)
    END IF
!enddo
!$OMP parallel do default(none) shared(npz,is,ie,js,je,pk,u,beta,gz,divg2,alpha, &
!$OMP                                  gridstruct,v,dt,du,dv) &          
!$OMP                          private(wk)
    wk = 0.0_FVPRC
    CALL PUSHINTEGER(ie)
    CALL PUSHINTEGER(je)
    DO k=1,npz
      DO j=js,je+1
        DO i=is,ie+1
          wk(i, j, k) = pk(i, j, k+1) - pk(i, j, k)
        END DO
      END DO
    END DO
    CALL PUSHREALARRAY(u, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)*npz&
&                 /8)
    CALL PUSHREALARRAY(alpha)
    CALL PUSHINTEGER(ie)
    CALL PUSHINTEGER(je)
    CALL PUSHREALARRAY(wk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*(&
&                 npz+1)/8)
! end k-loop
    DO k=1,npz
      DO j=js,je+1
        DO i=is,ie
          u(i, j, k) = u(i, j, k) + beta*du(i, j, k)
          du(i, j, k) = dt/(wk(i, j, k)+wk(i+1, j, k))*((gz(i, j, k+1)-&
&           gz(i+1, j, k))*(pk(i+1, j, k+1)-pk(i, j, k))+(gz(i, j, k)-gz&
&           (i+1, j, k+1))*(pk(i, j, k+1)-pk(i+1, j, k)))
          u(i, j, k) = (u(i, j, k)+divg2(i, j)-divg2(i+1, j)+alpha*du(i&
&           , j, k))*gridstruct%rdx(i, j)
        END DO
      END DO
    END DO
    CALL PUSHREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)*npz&
&                 /8)
! end k-loop
    DO k=1,npz
      DO j=js,je
        DO i=is,ie+1
          v(i, j, k) = v(i, j, k) + beta*dv(i, j, k)
          dv(i, j, k) = dt/(wk(i, j, k)+wk(i, j+1, k))*((gz(i, j, k+1)-&
&           gz(i, j+1, k))*(pk(i, j+1, k+1)-pk(i, j, k))+(gz(i, j, k)-gz&
&           (i, j+1, k+1))*(pk(i, j, k+1)-pk(i, j+1, k)))
          v(i, j, k) = (v(i, j, k)+divg2(i, j)-divg2(i, j+1)+alpha*dv(i&
&           , j, k))*gridstruct%rdy(i, j)
        END DO
      END DO
    END DO
    CALL PUSHINTEGER(js)
    CALL PUSHREALARRAY(alpha)
    CALL PUSHINTEGER(ie)
    CALL PUSHINTEGER(is)
    CALL PUSHINTEGER(je)
    CALL PUSHREALARRAY(wk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*(&
&                 npz+1)/8)
  END SUBROUTINE GRAD1_P_UPDATE_FWD
!  Differentiation of grad1_p_update in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_e
!dge_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mo
!d.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn
!_core_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_
!mod.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.c
!ubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_tota
!l_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv
!_mapz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.st
!eepz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem
!_solver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver 
!nh_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.dive
!rgence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_
!core_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_
!core_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp
!_core_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: gz du u dv v pk divg2
!   with respect to varying inputs: gz du u dv v pk divg2
  SUBROUTINE GRAD1_P_UPDATE_BWD(divg2, divg2_ad, u, u_ad, v, v_ad, du, &
&   du_ad, dv, dv_ad, pk, pk_ad, gz, gz_ad, dt, ng, gridstruct, bd, npx&
&   , npy, npz, ptop, beta, a2b_ord)
    IMPLICIT NONE
! end k-loop
    INTEGER, INTENT(IN) :: ng, npx, npy, npz, a2b_ord
    REAL(fvprc), INTENT(IN) :: dt, ptop, beta
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: divg2(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc) :: divg2_ad(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(INOUT) :: pk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: pk_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: gz_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz+1)
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: u_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: v_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    REAL(fvprc), INTENT(INOUT) :: du(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: du_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: dv(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: dv_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc) :: wk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: wk_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: top_value, alpha
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    REAL(fvprc) :: temp
    REAL(fvprc) :: temp0
    REAL(fvprc) :: temp1
    REAL(fvprc) :: temp2
    REAL(fvprc) :: temp3
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp4
    REAL(fvprc) :: temp5
    REAL(fvprc) :: temp6
    REAL(fvprc) :: temp7
    REAL(fvprc) :: temp8
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp_ad4
    INTEGER :: branch
    CALL POPREALARRAY(wk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*(&
&                npz+1)/8)
    CALL POPINTEGER(je)
    CALL POPINTEGER(is)
    CALL POPINTEGER(ie)
    CALL POPREALARRAY(alpha)
    CALL POPINTEGER(js)
    wk_ad = 0.0_FVPRC
    CALL POPREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)*npz/&
&                8)
    DO k=1,npz
      DO j=je,js,-1
        DO i=ie+1,is,-1
          temp_ad2 = gridstruct%rdy(i, j)*v_ad(i, j, k)
          divg2_ad(i, j) = divg2_ad(i, j) + temp_ad2
          dv_ad(i, j, k) = dv_ad(i, j, k) + alpha*temp_ad2
          divg2_ad(i, j+1) = divg2_ad(i, j+1) - temp_ad2
          v_ad(i, j, k) = temp_ad2
          temp4 = wk(i, j, k) + wk(i, j+1, k)
          temp8 = pk(i, j, k+1) - pk(i, j+1, k)
          temp7 = gz(i, j, k) - gz(i, j+1, k+1)
          temp6 = pk(i, j+1, k+1) - pk(i, j, k)
          temp5 = gz(i, j, k+1) - gz(i, j+1, k)
          temp_ad3 = dt*dv_ad(i, j, k)/temp4
          temp_ad4 = -((temp5*temp6+temp7*temp8)*temp_ad3/temp4)
          gz_ad(i, j, k+1) = gz_ad(i, j, k+1) + temp6*temp_ad3
          gz_ad(i, j+1, k) = gz_ad(i, j+1, k) - temp6*temp_ad3
          pk_ad(i, j+1, k+1) = pk_ad(i, j+1, k+1) + temp5*temp_ad3
          pk_ad(i, j, k) = pk_ad(i, j, k) - temp5*temp_ad3
          gz_ad(i, j, k) = gz_ad(i, j, k) + temp8*temp_ad3
          gz_ad(i, j+1, k+1) = gz_ad(i, j+1, k+1) - temp8*temp_ad3
          pk_ad(i, j, k+1) = pk_ad(i, j, k+1) + temp7*temp_ad3
          pk_ad(i, j+1, k) = pk_ad(i, j+1, k) - temp7*temp_ad3
          wk_ad(i, j, k) = wk_ad(i, j, k) + temp_ad4
          wk_ad(i, j+1, k) = wk_ad(i, j+1, k) + temp_ad4
          dv_ad(i, j, k) = beta*v_ad(i, j, k)
        END DO
      END DO
    END DO
    CALL POPREALARRAY(wk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*(&
&                npz+1)/8)
    CALL POPINTEGER(je)
    CALL POPINTEGER(ie)
    CALL POPREALARRAY(alpha)
    CALL POPREALARRAY(u, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)*npz/&
&                8)
    DO k=1,npz
      DO j=je+1,js,-1
        DO i=ie,is,-1
          temp_ad = gridstruct%rdx(i, j)*u_ad(i, j, k)
          divg2_ad(i, j) = divg2_ad(i, j) + temp_ad
          du_ad(i, j, k) = du_ad(i, j, k) + alpha*temp_ad
          divg2_ad(i+1, j) = divg2_ad(i+1, j) - temp_ad
          u_ad(i, j, k) = temp_ad
          temp = wk(i, j, k) + wk(i+1, j, k)
          temp3 = pk(i, j, k+1) - pk(i+1, j, k)
          temp2 = gz(i, j, k) - gz(i+1, j, k+1)
          temp1 = pk(i+1, j, k+1) - pk(i, j, k)
          temp0 = gz(i, j, k+1) - gz(i+1, j, k)
          temp_ad0 = dt*du_ad(i, j, k)/temp
          temp_ad1 = -((temp0*temp1+temp2*temp3)*temp_ad0/temp)
          gz_ad(i, j, k+1) = gz_ad(i, j, k+1) + temp1*temp_ad0
          gz_ad(i+1, j, k) = gz_ad(i+1, j, k) - temp1*temp_ad0
          pk_ad(i+1, j, k+1) = pk_ad(i+1, j, k+1) + temp0*temp_ad0
          pk_ad(i, j, k) = pk_ad(i, j, k) - temp0*temp_ad0
          gz_ad(i, j, k) = gz_ad(i, j, k) + temp3*temp_ad0
          gz_ad(i+1, j, k+1) = gz_ad(i+1, j, k+1) - temp3*temp_ad0
          pk_ad(i, j, k+1) = pk_ad(i, j, k+1) + temp2*temp_ad0
          pk_ad(i+1, j, k) = pk_ad(i+1, j, k) - temp2*temp_ad0
          wk_ad(i, j, k) = wk_ad(i, j, k) + temp_ad1
          wk_ad(i+1, j, k) = wk_ad(i+1, j, k) + temp_ad1
          du_ad(i, j, k) = beta*u_ad(i, j, k)
        END DO
      END DO
    END DO
    CALL POPINTEGER(je)
    CALL POPINTEGER(ie)
    DO k=1,npz
      DO j=je+1,js,-1
        DO i=ie+1,is,-1
          pk_ad(i, j, k+1) = pk_ad(i, j, k+1) + wk_ad(i, j, k)
          pk_ad(i, j, k) = pk_ad(i, j, k) - wk_ad(i, j, k)
          wk_ad(i, j, k) = 0.0_FVPRC
        END DO
      END DO
    END DO
    jsd = bd%jsd
    ied = bd%ied
    isd = bd%isd
    jed = bd%jed
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      wk_ad = 0.0_FVPRC
      DO k=npz+1,1,-1
        CALL A2B_ORD4_BWD(gz(isd:ied, jsd:jed, k), gz_ad(isd:ied, jsd&
&                      :jed, k), wk(:, :, k), wk_ad(:, :, k), gridstruct&
&                      , npx, npy, is, ie, js, je, ng, .true.)
      END DO
    ELSE
      wk_ad = 0.0_FVPRC
      DO k=npz+1,1,-1
        CALL A2B_ORD2_BWD(gz(isd:ied, jsd:jed, k), gz_ad(isd:ied, jsd:&
&                   jed, k), wk(:, :, k), wk_ad(:, :, k), gridstruct, &
&                   npx, npy, is, ie, js, je, ng, .true.)
      END DO
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      DO k=npz+1,2,-1
        CALL A2B_ORD4_BWD(pk(isd:ied, jsd:jed, k), pk_ad(isd:ied, jsd&
&                      :jed, k), wk(:, :, k), wk_ad(:, :, k), gridstruct&
&                      , npx, npy, is, ie, js, je, ng, .true.)
      END DO
    ELSE
      DO k=npz+1,2,-1
        CALL A2B_ORD2_BWD(pk(isd:ied, jsd:jed, k), pk_ad(isd:ied, jsd:&
&                   jed, k), wk(:, :, k), wk_ad(:, :, k), gridstruct, &
&                   npx, npy, is, ie, js, je, ng, .true.)
      END DO
    END IF
    CALL POPINTEGER(is)
    CALL POPINTEGER(ie)
    CALL POPREALARRAY(pk, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*(&
&                npz+1)/8)
    DO j=js,je+1
      DO i=ie+1,is,-1
        pk_ad(i, j, 1) = 0.0_FVPRC
      END DO
    END DO
  END SUBROUTINE GRAD1_P_UPDATE_BWD
  SUBROUTINE GRAD1_P_UPDATE(divg2, u, v, du, dv, pk, gz, dt, ng, &
&   gridstruct, bd, npx, npy, npz, ptop, beta, a2b_ord)
    IMPLICIT NONE
! end k-loop
    INTEGER, INTENT(IN) :: ng, npx, npy, npz, a2b_ord
    REAL(fvprc), INTENT(IN) :: dt, ptop, beta
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: divg2(bd%is:bd%ie+1, bd%js:bd%je+1)
    REAL(fvprc), INTENT(INOUT) :: pk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    REAL(fvprc), INTENT(INOUT) :: du(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: dv(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
! Local:
    REAL(fvprc) :: wk(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: top_value, alpha
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    alpha = 1. - beta
! pk is pe**kappa if hydrostatic
    top_value = ptk
!$OMP parallel do default(none) shared(is,ie,js,je,pk,top_value)
    DO j=js,je+1
      DO i=is,ie+1
        pk(i, j, 1) = top_value
      END DO
    END DO
!$OMP parallel do default(none) shared(npz,isd,jsd,pk,gridstruct,npx,npy,is,ie,js,je,ng,a2b_ord) &
!$OMP                          private(wk)
!do k=2,npz+1
    IF (a2b_ord .EQ. 4) THEN
      DO k=2,npz+1
        CALL A2B_ORD4(pk(isd:ied, jsd:jed, k), wk(:, :, k), &
&                  gridstruct, npx, npy, is, ie, js, je, ng, .true.)
      END DO
    ELSE
      DO k=2,npz+1
        CALL A2B_ORD2(pk(isd:ied, jsd:jed, k), wk(:, :, k), gridstruct, &
&               npx, npy, is, ie, js, je, ng, .true.)
      END DO
    END IF
!enddo
!$OMP parallel do default(none) shared(npz,isd,jsd,gz,gridstruct,npx,npy,is,ie,js,je,ng,a2b_ord) &
!$OMP                          private(wk)
!do k=1,npz+1
    IF (a2b_ord .EQ. 4) THEN
      DO k=1,npz+1
        CALL A2B_ORD4(gz(isd:ied, jsd:jed, k), wk(:, :, k), &
&                  gridstruct, npx, npy, is, ie, js, je, ng, .true.)
      END DO
    ELSE
      DO k=1,npz+1
        CALL A2B_ORD2(gz(isd:ied, jsd:jed, k), wk(:, :, k), gridstruct, &
&               npx, npy, is, ie, js, je, ng, .true.)
      END DO
    END IF
!enddo
!$OMP parallel do default(none) shared(npz,is,ie,js,je,pk,u,beta,gz,divg2,alpha, &
!$OMP                                  gridstruct,v,dt,du,dv) &          
!$OMP                          private(wk)
    wk = 0.0_FVPRC
    DO k=1,npz
      DO j=js,je+1
        DO i=is,ie+1
          wk(i, j, k) = pk(i, j, k+1) - pk(i, j, k)
        END DO
      END DO
    END DO
! end k-loop
    DO k=1,npz
      DO j=js,je+1
        DO i=is,ie
          u(i, j, k) = u(i, j, k) + beta*du(i, j, k)
          du(i, j, k) = dt/(wk(i, j, k)+wk(i+1, j, k))*((gz(i, j, k+1)-&
&           gz(i+1, j, k))*(pk(i+1, j, k+1)-pk(i, j, k))+(gz(i, j, k)-gz&
&           (i+1, j, k+1))*(pk(i, j, k+1)-pk(i+1, j, k)))
          u(i, j, k) = (u(i, j, k)+divg2(i, j)-divg2(i+1, j)+alpha*du(i&
&           , j, k))*gridstruct%rdx(i, j)
        END DO
      END DO
    END DO
! end k-loop
    DO k=1,npz
      DO j=js,je
        DO i=is,ie+1
          v(i, j, k) = v(i, j, k) + beta*dv(i, j, k)
          dv(i, j, k) = dt/(wk(i, j, k)+wk(i, j+1, k))*((gz(i, j, k+1)-&
&           gz(i, j+1, k))*(pk(i, j+1, k+1)-pk(i, j, k))+(gz(i, j, k)-gz&
&           (i, j+1, k+1))*(pk(i, j, k+1)-pk(i, j+1, k)))
          v(i, j, k) = (v(i, j, k)+divg2(i, j)-divg2(i, j+1)+alpha*dv(i&
&           , j, k))*gridstruct%rdy(i, j)
        END DO
      END DO
    END DO
  END SUBROUTINE GRAD1_P_UPDATE
!  Differentiation of mix_dp in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod.a
!2b_ord4_fb a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo
! dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod
!.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.rayle
!igh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to_l
!atlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energy 
!fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mod
!.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv_t
!racer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver_c
! nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core_m
!od.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_co
!rner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.
!compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mod.
!copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_mod
!.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: w delp pt
!   with respect to varying inputs: w delp pt
  SUBROUTINE MIX_DP_FWD(hydrostatic, w, delp, pt, km, ak, bk, cg, &
&   fv_debug, bd)
    IMPLICIT NONE
!if ( fv_debug .and. ip/=0 ) write(*,*) 'Warning: Mix_dp', mpp_pe, j, ip 
!     if ( ip/=0 ) write(*,*) 'Warning: Mix_dp', mpp_pe, j, ip 
    INTEGER, INTENT(IN) :: km
    REAL(fvprc), INTENT(IN) :: ak(km+1), bk(km+1)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, km), INTENT(&
&   INOUT) :: pt, delp
    REAL(fvprc), DIMENSION(bd%isd:, bd%jsd:, :), INTENT(INOUT) :: w
    LOGICAL, INTENT(IN) :: hydrostatic, cg, fv_debug
! Local:
    REAL(fvprc) :: dp, dpmin
    INTEGER :: i, j, k, ip
    INTEGER :: ifirst, ilast
    INTEGER :: jfirst, jlast
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    IF (cg) THEN
      ifirst = is - 1
      ilast = ie + 1
      jfirst = js - 1
      jlast = je + 1
    ELSE
      ifirst = is
      ilast = ie
      jfirst = js
      jlast = je
    END IF
!$OMP parallel do default(none) shared(jfirst,jlast,km,ifirst,ilast,delp,ak,bk,pt, &
!$OMP                                  hydrostatic,w,fv_debug) &
!$OMP                          private(ip, dpmin, dp)
    DO j=jfirst,jlast
      DO k=1,km-1
        CALL PUSHREALARRAY(dpmin)
        dpmin = 0.01*(ak(k+1)-ak(k)+(bk(k+1)-bk(k))*1.e5)
        DO i=ifirst,ilast
          IF (delp(i, j, k) .LT. dpmin) THEN
! Remap from below and mix pt
            CALL PUSHREALARRAY(dp)
            dp = dpmin - delp(i, j, k)
            CALL PUSHREALARRAY(pt(i, j, k))
            pt(i, j, k) = (pt(i, j, k)*delp(i, j, k)+pt(i, j, k+1)*dp)/&
&             dpmin
            IF (.NOT.hydrostatic) THEN
              CALL PUSHREALARRAY(w(i, j, k))
              w(i, j, k) = (w(i, j, k)*delp(i, j, k)+w(i, j, k+1)*dp)/&
&               dpmin
              CALL PUSHCONTROL1B_FV(0)
            ELSE
              CALL PUSHCONTROL1B_FV(1)
            END IF
            CALL PUSHREALARRAY(delp(i, j, k))
            delp(i, j, k) = dpmin
            CALL PUSHREALARRAY(delp(i, j, k+1))
            delp(i, j, k+1) = delp(i, j, k+1) - dp
            CALL PUSHCONTROL1B_FV(1)
          ELSE
            CALL PUSHCONTROL1B_FV(0)
          END IF
        END DO
      END DO
! Bottom (k=km):
      CALL PUSHREALARRAY(dpmin)
      dpmin = 0.01*(ak(km+1)-ak(km)+(bk(km+1)-bk(km))*1.e5)
      DO i=ifirst,ilast
        IF (delp(i, j, km) .LT. dpmin) THEN
! Remap from above and mix pt
          CALL PUSHREALARRAY(dp)
          dp = dpmin - delp(i, j, km)
          CALL PUSHREALARRAY(pt(i, j, km))
          pt(i, j, km) = (pt(i, j, km)*delp(i, j, km)+pt(i, j, km-1)*dp)&
&           /dpmin
          IF (.NOT.hydrostatic) THEN
            CALL PUSHREALARRAY(w(i, j, km))
            w(i, j, km) = (w(i, j, km)*delp(i, j, km)+w(i, j, km-1)*dp)/&
&             dpmin
            CALL PUSHCONTROL1B_FV(0)
          ELSE
            CALL PUSHCONTROL1B_FV(1)
          END IF
          CALL PUSHREALARRAY(delp(i, j, km))
          delp(i, j, km) = dpmin
          CALL PUSHREALARRAY(delp(i, j, km-1))
          delp(i, j, km-1) = delp(i, j, km-1) - dp
          CALL PUSHCONTROL1B_FV(1)
        ELSE
          CALL PUSHCONTROL1B_FV(0)
        END IF
      END DO
    END DO
    CALL PUSHREALARRAY(dp)
    CALL PUSHINTEGER(ilast)
    CALL PUSHINTEGER(jfirst)
    CALL PUSHINTEGER(jlast)
    CALL PUSHINTEGER(ifirst)
  END SUBROUTINE MIX_DP_FWD
!  Differentiation of mix_dp in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod.
!a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_hal
!o dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mo
!d.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.rayl
!eigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to_
!latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energy
! fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mo
!d.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv_
!tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver_
!c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core_
!mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_c
!orner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod
!.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mod
!.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_mo
!d.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: w delp pt
!   with respect to varying inputs: w delp pt
  SUBROUTINE MIX_DP_BWD(hydrostatic, w, w_ad, delp, delp_ad, pt, pt_ad, &
&   km, ak, bk, cg, fv_debug, bd)
    IMPLICIT NONE
!if ( fv_debug .and. ip/=0 ) write(*,*) 'Warning: Mix_dp', mpp_pe, j, ip 
!     if ( ip/=0 ) write(*,*) 'Warning: Mix_dp', mpp_pe, j, ip 
    INTEGER, INTENT(IN) :: km
    REAL(fvprc), INTENT(IN) :: ak(km+1), bk(km+1)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, km), INTENT(&
&   INOUT) :: pt, delp
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, km), INTENT(&
&   INOUT) :: pt_ad, delp_ad
    REAL(fvprc), DIMENSION(bd%isd:, bd%jsd:, :), INTENT(INOUT) :: w
    REAL(fvprc), DIMENSION(bd%isd:, bd%jsd:, :), INTENT(INOUT) :: w_ad
    LOGICAL, INTENT(IN) :: hydrostatic, cg, fv_debug
    REAL(fvprc) :: dp, dpmin
    REAL(fvprc) :: dp_ad
    INTEGER :: i, j, k, ip
    INTEGER :: ifirst, ilast
    INTEGER :: jfirst, jlast
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    INTEGER :: branch
    CALL POPINTEGER(ifirst)
    CALL POPINTEGER(jlast)
    CALL POPINTEGER(jfirst)
    CALL POPINTEGER(ilast)
    CALL POPREALARRAY(dp)
    DO j=jlast,jfirst,-1
      dpmin = 0.01*(ak(km+1)-ak(km)+(bk(km+1)-bk(km))*1.e5)
      DO i=ilast,ifirst,-1
        CALL POPCONTROL1B_FV(branch)
        IF (branch .NE. 0) THEN
          CALL POPREALARRAY(delp(i, j, km-1))
          dp_ad = -delp_ad(i, j, km-1)
          CALL POPREALARRAY(delp(i, j, km))
          delp_ad(i, j, km) = 0.0_FVPRC
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREALARRAY(w(i, j, km))
            temp_ad2 = w_ad(i, j, km)/dpmin
            delp_ad(i, j, km) = delp_ad(i, j, km) + w(i, j, km)*temp_ad2
            w_ad(i, j, km-1) = w_ad(i, j, km-1) + dp*temp_ad2
            dp_ad = dp_ad + w(i, j, km-1)*temp_ad2
            w_ad(i, j, km) = delp(i, j, km)*temp_ad2
          END IF
          CALL POPREALARRAY(pt(i, j, km))
          temp_ad1 = pt_ad(i, j, km)/dpmin
          pt_ad(i, j, km-1) = pt_ad(i, j, km-1) + dp*temp_ad1
          dp_ad = dp_ad + pt(i, j, km-1)*temp_ad1
          delp_ad(i, j, km) = delp_ad(i, j, km) + pt(i, j, km)*temp_ad1 &
&           - dp_ad
          pt_ad(i, j, km) = delp(i, j, km)*temp_ad1
          CALL POPREALARRAY(dp)
        END IF
      END DO
      CALL POPREALARRAY(dpmin)
      DO k=km-1,1,-1
        DO i=ilast,ifirst,-1
          CALL POPCONTROL1B_FV(branch)
          IF (branch .NE. 0) THEN
            CALL POPREALARRAY(delp(i, j, k+1))
            dp_ad = -delp_ad(i, j, k+1)
            CALL POPREALARRAY(delp(i, j, k))
            delp_ad(i, j, k) = 0.0_FVPRC
            CALL POPCONTROL1B_FV(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREALARRAY(w(i, j, k))
              temp_ad0 = w_ad(i, j, k)/dpmin
              delp_ad(i, j, k) = delp_ad(i, j, k) + w(i, j, k)*temp_ad0
              w_ad(i, j, k+1) = w_ad(i, j, k+1) + dp*temp_ad0
              dp_ad = dp_ad + w(i, j, k+1)*temp_ad0
              w_ad(i, j, k) = delp(i, j, k)*temp_ad0
            END IF
            CALL POPREALARRAY(pt(i, j, k))
            temp_ad = pt_ad(i, j, k)/dpmin
            pt_ad(i, j, k+1) = pt_ad(i, j, k+1) + dp*temp_ad
            dp_ad = dp_ad + pt(i, j, k+1)*temp_ad
            delp_ad(i, j, k) = delp_ad(i, j, k) + pt(i, j, k)*temp_ad - &
&             dp_ad
            pt_ad(i, j, k) = delp(i, j, k)*temp_ad
            CALL POPREALARRAY(dp)
          END IF
        END DO
        CALL POPREALARRAY(dpmin)
      END DO
    END DO
  END SUBROUTINE MIX_DP_BWD
  SUBROUTINE MIX_DP(hydrostatic, w, delp, pt, km, ak, bk, cg, fv_debug, &
&   bd)
    IMPLICIT NONE
!if ( fv_debug .and. ip/=0 ) write(*,*) 'Warning: Mix_dp', mpp_pe, j, ip 
!     if ( ip/=0 ) write(*,*) 'Warning: Mix_dp', mpp_pe, j, ip 
    INTEGER, INTENT(IN) :: km
    REAL(fvprc), INTENT(IN) :: ak(km+1), bk(km+1)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, km), INTENT(&
&   INOUT) :: pt, delp
    REAL(fvprc), DIMENSION(bd%isd:, bd%jsd:, :), INTENT(INOUT) :: w
    LOGICAL, INTENT(IN) :: hydrostatic, cg, fv_debug
! Local:
    REAL(fvprc) :: dp, dpmin
    INTEGER :: i, j, k, ip
    INTEGER :: ifirst, ilast
    INTEGER :: jfirst, jlast
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    IF (cg) THEN
      ifirst = is - 1
      ilast = ie + 1
      jfirst = js - 1
      jlast = je + 1
    ELSE
      ifirst = is
      ilast = ie
      jfirst = js
      jlast = je
    END IF
!$OMP parallel do default(none) shared(jfirst,jlast,km,ifirst,ilast,delp,ak,bk,pt, &
!$OMP                                  hydrostatic,w,fv_debug) &
!$OMP                          private(ip, dpmin, dp)
    DO j=jfirst,jlast
      ip = 0
      DO k=1,km-1
        dpmin = 0.01*(ak(k+1)-ak(k)+(bk(k+1)-bk(k))*1.e5)
        DO i=ifirst,ilast
          IF (delp(i, j, k) .LT. dpmin) THEN
! Remap from below and mix pt
            dp = dpmin - delp(i, j, k)
            pt(i, j, k) = (pt(i, j, k)*delp(i, j, k)+pt(i, j, k+1)*dp)/&
&             dpmin
            IF (.NOT.hydrostatic) w(i, j, k) = (w(i, j, k)*delp(i, j, k)&
&               +w(i, j, k+1)*dp)/dpmin
            delp(i, j, k) = dpmin
            delp(i, j, k+1) = delp(i, j, k+1) - dp
            ip = ip + 1
          END IF
        END DO
      END DO
! Bottom (k=km):
      dpmin = 0.01*(ak(km+1)-ak(km)+(bk(km+1)-bk(km))*1.e5)
      DO i=ifirst,ilast
        IF (delp(i, j, km) .LT. dpmin) THEN
! Remap from above and mix pt
          dp = dpmin - delp(i, j, km)
          pt(i, j, km) = (pt(i, j, km)*delp(i, j, km)+pt(i, j, km-1)*dp)&
&           /dpmin
          IF (.NOT.hydrostatic) w(i, j, km) = (w(i, j, km)*delp(i, j, km&
&             )+w(i, j, km-1)*dp)/dpmin
          delp(i, j, km) = dpmin
          delp(i, j, km-1) = delp(i, j, km-1) - dp
          ip = ip + 1
        END IF
      END DO
    END DO
  END SUBROUTINE MIX_DP
!  Differentiation of geopk in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod.a2
!b_ord4_fb a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo 
!dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.
!grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.raylei
!gh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to_la
!tlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energy f
!v_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mod.
!map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv_tr
!acer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver_c 
!nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core_mo
!d.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_cor
!ner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.c
!ompute_div_damping_fb sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mod.c
!opy_corners_fb tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_mod.
!fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: peln gz delp pkz pe pk pt
!   with respect to varying inputs: peln gz delp pkz pe pk pt
  SUBROUTINE GEOPK_FWD(ptop, pe, peln, delp, pk, gz, hs, pt, q_con, pkz&
&   , km, akap, cg, nested, computehalo, npx, npy, a2b_ord, bd)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: km, npx, npy, a2b_ord
    REAL(fvprc), INTENT(IN) :: akap, ptop
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: hs(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, km), INTENT(IN)&
&   :: pt, delp
    REAL(fvprc), DIMENSION(bd%isd:bd%isd, bd%jsd:bd%jsd, 1), INTENT(IN) &
&   :: q_con
    LOGICAL, INTENT(IN) :: cg, nested, computehalo
! !OUTPUT PARAMETERS
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, km+1) :: gz, pk
    REAL(fvprc) :: pe(bd%is-1:bd%ie+1, km+1, bd%js-1:bd%je+1)
! ln(pe)
    REAL(fvprc) :: peln(bd%is:bd%ie, km+1, bd%js:bd%je)
    REAL(fvprc) :: pkz(bd%is:bd%ie, bd%js:bd%je, km)
! !DESCRIPTION:
!    Calculates geopotential and pressure to the kappa.
! Local:
    REAL(fvprc) :: peg(bd%isd:bd%ied, km+1)
    REAL(fvprc) :: pkg(bd%isd:bd%ied, km+1)
    REAL(fvprc) :: p1d(bd%isd:bd%ied)
    REAL(fvprc) :: logp(bd%isd:bd%ied)
    INTEGER :: i, j, k
    INTEGER :: ifirst, ilast
    INTEGER :: jfirst, jlast
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC LOG
    INTRINSIC EXP
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: ad_from
    INTEGER :: ad_from0
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    IF ((.NOT.cg .AND. a2b_ord .EQ. 4) .OR. (nested .AND. (.NOT.cg))) &
&   THEN
! D-Grid
      ifirst = is - 2
      ilast = ie + 2
      jfirst = js - 2
      jlast = je + 2
    ELSE
      ifirst = is - 1
      ilast = ie + 1
      jfirst = js - 1
      jlast = je + 1
    END IF
    IF (nested .AND. computehalo) THEN
      IF (is .EQ. 1) ifirst = isd
      IF (ie .EQ. npx - 1) ilast = ied
      IF (js .EQ. 1) jfirst = jsd
      IF (je .EQ. npy - 1) THEN
        CALL PUSHCONTROL1B_FV(1)
        jlast = jed
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
    ELSE
      CALL PUSHCONTROL1B_FV(0)
    END IF
!$OMP parallel do default(none) shared(jfirst,jlast,ifirst,ilast,pk,km,gz,hs,ptop,ptk, &
!$OMP                                  js,je,is,ie,peln,peln1,pe,delp,akap,pt,CG,pkz) &
!$OMP                          private(peg, pkg, p1d, logp)
    DO j=jfirst,jlast
      DO i=ifirst,ilast
        CALL PUSHREALARRAY(p1d(i))
        p1d(i) = ptop
        CALL PUSHREALARRAY(pk(i, j, 1))
        pk(i, j, 1) = ptk
        CALL PUSHREALARRAY(gz(i, j, km+1))
        gz(i, j, km+1) = hs(i, j)
      END DO
!#ifdef USE_COND
!         peg(i,1) = ptop
!         pkg(i,1) = ptk
!#endif
!#ifndef SW_DYNAMICS
      IF (j .GE. js .AND. j .LE. je) THEN
        DO i=is,ie
          CALL PUSHREALARRAY(peln(i, 1, j))
          peln(i, 1, j) = peln1
        END DO
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
!#endif
      IF (j .GT. js - 2 .AND. j .LT. je + 2) THEN
        IF (ifirst .LT. is - 1) THEN
          max1 = is - 1
        ELSE
          max1 = ifirst
        END IF
        IF (ilast .GT. ie + 1) THEN
          min1 = ie + 1
        ELSE
          min1 = ilast
        END IF
        ad_from = max1
        DO i=ad_from,min1
          CALL PUSHREALARRAY(pe(i, 1, j))
          pe(i, 1, j) = ptop
        END DO
        CALL PUSHINTEGER(i - 1)
        CALL PUSHINTEGER(ad_from)
        CALL PUSHCONTROL1B_FV(1)
      ELSE
        CALL PUSHCONTROL1B_FV(0)
      END IF
! Top down
      DO k=2,km+1
        DO i=ifirst,ilast
          CALL PUSHREALARRAY(p1d(i))
          p1d(i) = p1d(i) + delp(i, j, k-1)
          CALL PUSHREALARRAY(logp(i))
          logp(i) = LOG(p1d(i))
          CALL PUSHREALARRAY(pk(i, j, k))
          pk(i, j, k) = EXP(akap*logp(i))
        END DO
!#ifdef USE_COND
!            peg(i,k) = peg(i,k-1) + delp(i,j,k-1)*(1.-q_con(i,j,k-1))
!            pkg(i,k) = exp( akap*log(peg(i,k)) )
!#endif
        IF (j .GT. js - 2 .AND. j .LT. je + 2) THEN
          IF (ifirst .LT. is - 1) THEN
            max2 = is - 1
          ELSE
            max2 = ifirst
          END IF
          IF (ilast .GT. ie + 1) THEN
            min2 = ie + 1
          ELSE
            min2 = ilast
          END IF
          ad_from0 = max2
          DO i=ad_from0,min2
            CALL PUSHREALARRAY(pe(i, k, j))
            pe(i, k, j) = p1d(i)
          END DO
          CALL PUSHINTEGER(i - 1)
          CALL PUSHINTEGER(ad_from0)
          IF (j .GE. js .AND. j .LE. je) THEN
            DO i=is,ie
              CALL PUSHREALARRAY(peln(i, k, j))
              peln(i, k, j) = logp(i)
            END DO
            CALL PUSHCONTROL2B_FV(2)
          ELSE
            CALL PUSHCONTROL2B_FV(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B_FV(0)
        END IF
      END DO
! Bottom up
      DO k=km,1,-1
        DO i=ifirst,ilast
!#ifdef USE_COND
!            gz(i,j,k) = gz(i,j,k+1) + pt(i,j,k)*(pkg(i,k+1)-pkg(i,k))
!#else
          CALL PUSHREALARRAY(gz(i, j, k))
          gz(i, j, k) = gz(i, j, k+1) + pt(i, j, k)*(pk(i, j, k+1)-pk(i&
&           , j, k))
        END DO
      END DO
!#endif
      IF (.NOT.cg .AND. j .GE. js .AND. j .LE. je) THEN
        DO k=1,km
          DO i=is,ie
            CALL PUSHREALARRAY(pkz(i, j, k))
            pkz(i, j, k) = (pk(i, j, k+1)-pk(i, j, k))/(akap*(peln(i, k+&
&             1, j)-peln(i, k, j)))
          END DO
        END DO
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
    END DO
    CALL PUSHREALARRAY(logp, 8*(bd%ied-bd%isd+1)/8)
    CALL PUSHINTEGER(ilast)
    CALL PUSHINTEGER(jfirst)
    CALL PUSHREALARRAY(p1d, 8*(bd%ied-bd%isd+1)/8)
    CALL PUSHINTEGER(jlast)
    CALL PUSHINTEGER(ie)
    CALL PUSHINTEGER(is)
    CALL PUSHINTEGER(ifirst)
  END SUBROUTINE GEOPK_FWD
!  Differentiation of geopk in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod.a
!2b_ord4_fb a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo
! dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod
!.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.rayle
!igh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to_l
!atlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energy 
!fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mod
!.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv_t
!racer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver_c
! nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core_m
!od.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_co
!rner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.
!compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mod.
!copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_mod
!.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: peln gz delp pkz pe pk pt
!   with respect to varying inputs: peln gz delp pkz pe pk pt
  SUBROUTINE GEOPK_BWD(ptop, pe, pe_ad, peln, peln_ad, delp, delp_ad, pk&
&   , pk_ad, gz, gz_ad, hs, pt, pt_ad, q_con, pkz, pkz_ad, km, akap, cg&
&   , nested, computehalo, npx, npy, a2b_ord, bd)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: km, npx, npy, a2b_ord
    REAL(fvprc), INTENT(IN) :: akap, ptop
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: hs(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, km), INTENT(IN)&
&   :: pt, delp
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, km) :: pt_ad, &
&   delp_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%isd, bd%jsd:bd%jsd, 1), INTENT(IN) &
&   :: q_con
    LOGICAL, INTENT(IN) :: cg, nested, computehalo
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, km+1) :: gz, pk
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, km+1) :: gz_ad&
&   , pk_ad
    REAL(fvprc) :: pe(bd%is-1:bd%ie+1, km+1, bd%js-1:bd%je+1)
    REAL(fvprc) :: pe_ad(bd%is-1:bd%ie+1, km+1, bd%js-1:bd%je+1)
    REAL(fvprc) :: peln(bd%is:bd%ie, km+1, bd%js:bd%je)
    REAL(fvprc) :: peln_ad(bd%is:bd%ie, km+1, bd%js:bd%je)
    REAL(fvprc) :: pkz(bd%is:bd%ie, bd%js:bd%je, km)
    REAL(fvprc) :: pkz_ad(bd%is:bd%ie, bd%js:bd%je, km)
    REAL(fvprc) :: peg(bd%isd:bd%ied, km+1)
    REAL(fvprc) :: pkg(bd%isd:bd%ied, km+1)
    REAL(fvprc) :: p1d(bd%isd:bd%ied)
    REAL(fvprc) :: p1d_ad(bd%isd:bd%ied)
    REAL(fvprc) :: logp(bd%isd:bd%ied)
    REAL(fvprc) :: logp_ad(bd%isd:bd%ied)
    INTEGER :: i, j, k
    INTEGER :: ifirst, ilast
    INTEGER :: jfirst, jlast
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC LOG
    INTRINSIC EXP
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: min1
    INTEGER :: min2
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    INTEGER :: ad_from
    INTEGER :: ad_to
    INTEGER :: ad_from0
    INTEGER :: ad_to0
    INTEGER :: branch
    CALL POPINTEGER(ifirst)
    CALL POPINTEGER(is)
    CALL POPINTEGER(ie)
    CALL POPINTEGER(jlast)
    CALL POPREALARRAY(p1d, 8*(bd%ied-bd%isd+1)/8)
    CALL POPINTEGER(jfirst)
    CALL POPINTEGER(ilast)
    CALL POPREALARRAY(logp, 8*(bd%ied-bd%isd+1)/8)
    logp_ad = 0.0_FVPRC
    p1d_ad = 0.0_FVPRC
    DO j=jlast,jfirst,-1
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        DO k=km,1,-1
          DO i=ie,is,-1
            CALL POPREALARRAY(pkz(i, j, k))
            temp = akap*(peln(i, k+1, j)-peln(i, k, j))
            temp_ad0 = pkz_ad(i, j, k)/temp
            temp_ad1 = -((pk(i, j, k+1)-pk(i, j, k))*akap*temp_ad0/temp)
            pk_ad(i, j, k+1) = pk_ad(i, j, k+1) + temp_ad0
            pk_ad(i, j, k) = pk_ad(i, j, k) - temp_ad0
            peln_ad(i, k+1, j) = peln_ad(i, k+1, j) + temp_ad1
            peln_ad(i, k, j) = peln_ad(i, k, j) - temp_ad1
            pkz_ad(i, j, k) = 0.0_FVPRC
          END DO
        END DO
      END IF
      DO k=1,km,1
        DO i=ilast,ifirst,-1
          CALL POPREALARRAY(gz(i, j, k))
          temp_ad = pt(i, j, k)*gz_ad(i, j, k)
          gz_ad(i, j, k+1) = gz_ad(i, j, k+1) + gz_ad(i, j, k)
          pt_ad(i, j, k) = pt_ad(i, j, k) + (pk(i, j, k+1)-pk(i, j, k))*&
&           gz_ad(i, j, k)
          pk_ad(i, j, k+1) = pk_ad(i, j, k+1) + temp_ad
          pk_ad(i, j, k) = pk_ad(i, j, k) - temp_ad
          gz_ad(i, j, k) = 0.0_FVPRC
        END DO
      END DO
      DO k=km+1,2,-1
        CALL POPCONTROL2B_FV(branch)
        IF (branch .NE. 0) THEN
          IF (branch .NE. 1) THEN
            DO i=ie,is,-1
              CALL POPREALARRAY(peln(i, k, j))
              logp_ad(i) = logp_ad(i) + peln_ad(i, k, j)
              peln_ad(i, k, j) = 0.0_FVPRC
            END DO
          END IF
          CALL POPINTEGER(ad_from0)
          CALL POPINTEGER(ad_to0)
          DO i=ad_to0,ad_from0,-1
            CALL POPREALARRAY(pe(i, k, j))
            p1d_ad(i) = p1d_ad(i) + pe_ad(i, k, j)
            pe_ad(i, k, j) = 0.0_FVPRC
          END DO
        END IF
        DO i=ilast,ifirst,-1
          CALL POPREALARRAY(pk(i, j, k))
          logp_ad(i) = logp_ad(i) + EXP(akap*logp(i))*akap*pk_ad(i, j, k&
&           )
          pk_ad(i, j, k) = 0.0_FVPRC
          CALL POPREALARRAY(logp(i))
          p1d_ad(i) = p1d_ad(i) + logp_ad(i)/p1d(i)
          logp_ad(i) = 0.0_FVPRC
          CALL POPREALARRAY(p1d(i))
          delp_ad(i, j, k-1) = delp_ad(i, j, k-1) + p1d_ad(i)
        END DO
      END DO
      CALL POPCONTROL1B_FV(branch)
      IF (branch .NE. 0) THEN
        CALL POPINTEGER(ad_from)
        CALL POPINTEGER(ad_to)
        DO i=ad_to,ad_from,-1
          CALL POPREALARRAY(pe(i, 1, j))
          pe_ad(i, 1, j) = 0.0_FVPRC
        END DO
      END IF
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        DO i=ie,is,-1
          CALL POPREALARRAY(peln(i, 1, j))
          peln_ad(i, 1, j) = 0.0_FVPRC
        END DO
      END IF
      DO i=ilast,ifirst,-1
        CALL POPREALARRAY(gz(i, j, km+1))
        gz_ad(i, j, km+1) = 0.0_FVPRC
        CALL POPREALARRAY(pk(i, j, 1))
        pk_ad(i, j, 1) = 0.0_FVPRC
        CALL POPREALARRAY(p1d(i))
        p1d_ad(i) = 0.0_FVPRC
      END DO
    END DO
    CALL POPCONTROL1B_FV(branch)
  END SUBROUTINE GEOPK_BWD
  SUBROUTINE GEOPK(ptop, pe, peln, delp, pk, gz, hs, pt, q_con, pkz, km&
&   , akap, cg, nested, computehalo, npx, npy, a2b_ord, bd)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: km, npx, npy, a2b_ord
    REAL(fvprc), INTENT(IN) :: akap, ptop
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(IN) :: hs(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, km), INTENT(IN)&
&   :: pt, delp
    REAL(fvprc), DIMENSION(bd%isd:bd%isd, bd%jsd:bd%jsd, 1), INTENT(IN) &
&   :: q_con
    LOGICAL, INTENT(IN) :: cg, nested, computehalo
! !OUTPUT PARAMETERS
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, km+1), INTENT(&
&   OUT) :: gz, pk
    REAL(fvprc), INTENT(OUT) :: pe(bd%is-1:bd%ie+1, km+1, bd%js-1:bd%je+&
&   1)
! ln(pe)
    REAL(fvprc), INTENT(OUT) :: peln(bd%is:bd%ie, km+1, bd%js:bd%je)
    REAL(fvprc), INTENT(OUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, km)
! !DESCRIPTION:
!    Calculates geopotential and pressure to the kappa.
! Local:
    REAL(fvprc) :: peg(bd%isd:bd%ied, km+1)
    REAL(fvprc) :: pkg(bd%isd:bd%ied, km+1)
    REAL(fvprc) :: p1d(bd%isd:bd%ied)
    REAL(fvprc) :: logp(bd%isd:bd%ied)
    INTEGER :: i, j, k
    INTEGER :: ifirst, ilast
    INTEGER :: jfirst, jlast
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC LOG
    INTRINSIC EXP
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: min1
    INTEGER :: min2
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    IF ((.NOT.cg .AND. a2b_ord .EQ. 4) .OR. (nested .AND. (.NOT.cg))) &
&   THEN
! D-Grid
      ifirst = is - 2
      ilast = ie + 2
      jfirst = js - 2
      jlast = je + 2
    ELSE
      ifirst = is - 1
      ilast = ie + 1
      jfirst = js - 1
      jlast = je + 1
    END IF
    IF (nested .AND. computehalo) THEN
      IF (is .EQ. 1) ifirst = isd
      IF (ie .EQ. npx - 1) ilast = ied
      IF (js .EQ. 1) jfirst = jsd
      IF (je .EQ. npy - 1) jlast = jed
    END IF
!$OMP parallel do default(none) shared(jfirst,jlast,ifirst,ilast,pk,km,gz,hs,ptop,ptk, &
!$OMP                                  js,je,is,ie,peln,peln1,pe,delp,akap,pt,CG,pkz) &
!$OMP                          private(peg, pkg, p1d, logp)
    DO j=jfirst,jlast
      DO i=ifirst,ilast
        p1d(i) = ptop
        pk(i, j, 1) = ptk
        gz(i, j, km+1) = hs(i, j)
      END DO
!#ifdef USE_COND
!         peg(i,1) = ptop
!         pkg(i,1) = ptk
!#endif
!#ifndef SW_DYNAMICS
      IF (j .GE. js .AND. j .LE. je) THEN
        DO i=is,ie
          peln(i, 1, j) = peln1
        END DO
      END IF
!#endif
      IF (j .GT. js - 2 .AND. j .LT. je + 2) THEN
        IF (ifirst .LT. is - 1) THEN
          max1 = is - 1
        ELSE
          max1 = ifirst
        END IF
        IF (ilast .GT. ie + 1) THEN
          min1 = ie + 1
        ELSE
          min1 = ilast
        END IF
        DO i=max1,min1
          pe(i, 1, j) = ptop
        END DO
      END IF
! Top down
      DO k=2,km+1
        DO i=ifirst,ilast
          p1d(i) = p1d(i) + delp(i, j, k-1)
          logp(i) = LOG(p1d(i))
          pk(i, j, k) = EXP(akap*logp(i))
        END DO
!#ifdef USE_COND
!            peg(i,k) = peg(i,k-1) + delp(i,j,k-1)*(1.-q_con(i,j,k-1))
!            pkg(i,k) = exp( akap*log(peg(i,k)) )
!#endif
        IF (j .GT. js - 2 .AND. j .LT. je + 2) THEN
          IF (ifirst .LT. is - 1) THEN
            max2 = is - 1
          ELSE
            max2 = ifirst
          END IF
          IF (ilast .GT. ie + 1) THEN
            min2 = ie + 1
          ELSE
            min2 = ilast
          END IF
          DO i=max2,min2
            pe(i, k, j) = p1d(i)
          END DO
          IF (j .GE. js .AND. j .LE. je) THEN
            DO i=is,ie
              peln(i, k, j) = logp(i)
            END DO
          END IF
        END IF
      END DO
! Bottom up
      DO k=km,1,-1
        DO i=ifirst,ilast
!#ifdef USE_COND
!            gz(i,j,k) = gz(i,j,k+1) + pt(i,j,k)*(pkg(i,k+1)-pkg(i,k))
!#else
          gz(i, j, k) = gz(i, j, k+1) + pt(i, j, k)*(pk(i, j, k+1)-pk(i&
&           , j, k))
        END DO
      END DO
!#endif
      IF (.NOT.cg .AND. j .GE. js .AND. j .LE. je) THEN
        DO k=1,km
          DO i=is,ie
            pkz(i, j, k) = (pk(i, j, k+1)-pk(i, j, k))/(akap*(peln(i, k+&
&             1, j)-peln(i, k, j)))
          END DO
        END DO
      END IF
    END DO
  END SUBROUTINE GEOPK
!  Differentiation of del2_cubed in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_m
!od.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_
!halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core
!_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.r
!ayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_
!to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_ene
!rgy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz
!_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz 
!fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solv
!er_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_co
!re_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergenc
!e_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_
!mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_
!mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core
!_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: q
!   with respect to varying inputs: q
  SUBROUTINE DEL2_CUBED_FWD(q, cd, gridstruct, domain, npx, npy, km, &
&   nmax, bd)
    IMPLICIT NONE
!---------------------------------------------------------------
! This routine is for filtering the omega field for the physics
!---------------------------------------------------------------
    INTEGER, INTENT(IN) :: npx, npy, km, nmax
! cd = K * da_min;   0 < K < 0.25
    REAL(kind=r_grid), INTENT(IN) :: cd
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    REAL(fvprc), PARAMETER :: r3=1./3.
    REAL(fvprc) :: fx(bd%isd:bd%ied+1, bd%jsd:bd%jed), fy(bd%isd:bd%ied&
&   , bd%jsd:bd%jed+1)
    REAL(fvprc) :: q2(bd%isd:bd%ied, bd%jsd:bd%jed)
    INTEGER :: i, j, k, n, nt, ntimes
    LOGICAL, SAVE :: do_nullify=.false.
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    INTRINSIC MIN
    INTEGER :: ad_from
    INTEGER :: ad_from0
    INTEGER :: ad_from1
    INTEGER :: ad_from2
    INTEGER :: ad_from3
    INTEGER :: ad_from4
    REAL(fvprc) :: tmp
    REAL(fvprc) :: tmp0
    REAL(fvprc) :: tmp1
    REAL(fvprc) :: tmp2
    REAL(fvprc) :: tmp3
    REAL(fvprc) :: tmp4
    REAL(fvprc) :: tmp5
!Local routine pointers
!      real(FVPRC), pointer, dimension(:,:) :: rarea
!      real(FVPRC), pointer, dimension(:,:) :: sina_u, sina_v
!      real(FVPRC), pointer, dimension(:,:) :: rdxc, rdyc, dy
!      logical, pointer :: sw_corner, se_corner, ne_corner, nw_corner
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    IF (3 .GT. nmax) THEN
      ntimes = nmax
    ELSE
      ntimes = 3
    END IF
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
    CALL PUSHREALARRAY(q, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*km/&
&                 8)
    CALL MPP_UPDATE_DOMAINS(q, domain, complete=.true.)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
    DO n=1,ntimes
      nt = ntimes - n
!$OMP parallel do default(none) shared(km,sw_corner,q,se_corner,is,ie,js,je,npx,npy, &
!$OMP                                  nw_corner,ne_corner,nt,isd,jsd,gridstruct,bd, &
!$OMP                                  dy,sina_u,rdxc,sina_v,rdyc,cd,rarea         ) &
!$OMP                          private(fx, fy)
      DO k=1,km
        IF (gridstruct%sw_corner) THEN
          q(1, 1, k) = (q(1, 1, k)+q(0, 1, k)+q(1, 0, k))*r3
          q(0, 1, k) = q(1, 1, k)
          q(1, 0, k) = q(1, 1, k)
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
        IF (gridstruct%se_corner) THEN
          tmp0 = (q(ie, 1, k)+q(npx, 1, k)+q(ie, 0, k))*r3
          q(ie, 1, k) = tmp0
          tmp = q(ie, 1, k)
          q(npx, 1, k) = tmp
          q(ie, 0, k) = q(ie, 1, k)
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
        IF (gridstruct%ne_corner) THEN
          tmp3 = (q(ie, je, k)+q(npx, je, k)+q(ie, npy, k))*r3
          q(ie, je, k) = tmp3
          tmp2 = q(ie, je, k)
          q(npx, je, k) = tmp2
          tmp1 = q(ie, je, k)
          q(ie, npy, k) = tmp1
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
        IF (gridstruct%nw_corner) THEN
          tmp5 = (q(1, je, k)+q(0, je, k)+q(1, npy, k))*r3
          q(1, je, k) = tmp5
          q(0, je, k) = q(1, je, k)
          tmp4 = q(1, je, k)
          q(1, npy, k) = tmp4
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
        IF (nt .GT. 0) THEN
          CALL COPY_CORNERS(q(isd:ied, jsd:jed, k), npx, npy, 1, &
&                     gridstruct%nested, bd, gridstruct%sw_corner, &
&                     gridstruct%se_corner, gridstruct%nw_corner, &
&                     gridstruct%ne_corner)
          CALL PUSHCONTROL1B_FV(1)
        ELSE
          CALL PUSHCONTROL1B_FV(0)
        END IF
        ad_from0 = js - nt
        DO j=ad_from0,je+nt
          ad_from = is - nt
          DO i=ad_from,ie+1+nt
            fx(i, j) = gridstruct%dy(i, j)*gridstruct%sina_u(i, j)*(q(i-&
&             1, j, k)-q(i, j, k))*gridstruct%rdxc(i, j)
          END DO
          CALL PUSHINTEGER(i - 1)
          CALL PUSHINTEGER(ad_from)
        END DO
        CALL PUSHINTEGER(j - 1)
        CALL PUSHINTEGER(ad_from0)
        IF (nt .GT. 0) THEN
          CALL COPY_CORNERS(q(isd:ied, jsd:jed, k), npx, npy, 2, &
&                     gridstruct%nested, bd, gridstruct%sw_corner, &
&                     gridstruct%se_corner, gridstruct%nw_corner, &
&                     gridstruct%ne_corner)
          CALL PUSHCONTROL1B_FV(1)
        ELSE
          CALL PUSHCONTROL1B_FV(0)
        END IF
        ad_from2 = js - nt
        DO j=ad_from2,je+1+nt
          ad_from1 = is - nt
          DO i=ad_from1,ie+nt
            fy(i, j) = gridstruct%dx(i, j)*gridstruct%sina_v(i, j)*(q(i&
&             , j-1, k)-q(i, j, k))*gridstruct%rdyc(i, j)
          END DO
          CALL PUSHINTEGER(i - 1)
          CALL PUSHINTEGER(ad_from1)
        END DO
        CALL PUSHINTEGER(j - 1)
        CALL PUSHINTEGER(ad_from2)
        ad_from4 = js - nt
        DO j=ad_from4,je+nt
          ad_from3 = is - nt
          DO i=ad_from3,ie+nt
            q(i, j, k) = q(i, j, k) + cd*gridstruct%rarea(i, j)*(fx(i, j&
&             )-fx(i+1, j)+fy(i, j)-fy(i, j+1))
          END DO
          CALL PUSHINTEGER(i - 1)
          CALL PUSHINTEGER(ad_from3)
        END DO
        CALL PUSHINTEGER(j - 1)
        CALL PUSHINTEGER(ad_from4)
      END DO
    END DO
    CALL PUSHINTEGER(ntimes)
    CALL PUSHINTEGER(jsd)
    CALL PUSHINTEGER(ied)
    CALL PUSHINTEGER(ie)
    CALL PUSHINTEGER(isd)
    CALL PUSHINTEGER(je)
    CALL PUSHINTEGER(jed)
  END SUBROUTINE DEL2_CUBED_FWD
!  Differentiation of del2_cubed in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_
!mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe
!_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_cor
!e_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.
!rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed
!_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_en
!ergy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_map
!z_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz
! fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_sol
!ver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_c
!ore_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergen
!ce_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core
!_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core
!_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_cor
!e_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: q
!   with respect to varying inputs: q
  SUBROUTINE DEL2_CUBED_BWD(q, q_ad, cd, gridstruct, domain, npx, npy, &
&   km, nmax, bd)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, km, nmax
    REAL(kind=r_grid), INTENT(IN) :: cd
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(INOUT) :: q_ad(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    REAL(fvprc), PARAMETER :: r3=1./3.
    REAL(fvprc) :: fx(bd%isd:bd%ied+1, bd%jsd:bd%jed), fy(bd%isd:bd%ied&
&   , bd%jsd:bd%jed+1)
    REAL(fvprc) :: fx_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed), fy_ad(bd%isd:&
&   bd%ied, bd%jsd:bd%jed+1)
    REAL(fvprc) :: q2(bd%isd:bd%ied, bd%jsd:bd%jed)
    INTEGER :: i, j, k, n, nt, ntimes
    LOGICAL, SAVE :: do_nullify=.false.
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    INTRINSIC MIN
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: tmp_ad
    REAL(fvprc) :: tmp_ad0
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: tmp_ad1
    REAL(fvprc) :: tmp_ad2
    REAL(fvprc) :: tmp_ad3
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: tmp_ad4
    REAL(fvprc) :: tmp_ad5
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp_ad4
    REAL(fvprc) :: temp_ad5
    INTEGER :: ad_from
    INTEGER :: ad_to
    INTEGER :: ad_from0
    INTEGER :: ad_to0
    INTEGER :: ad_from1
    INTEGER :: ad_to1
    INTEGER :: ad_from2
    INTEGER :: ad_to2
    INTEGER :: ad_from3
    INTEGER :: ad_to3
    INTEGER :: ad_from4
    INTEGER :: ad_to4
    INTEGER :: branch
    CALL POPINTEGER(jed)
    CALL POPINTEGER(je)
    CALL POPINTEGER(isd)
    CALL POPINTEGER(ie)
    CALL POPINTEGER(ied)
    CALL POPINTEGER(jsd)
    CALL POPINTEGER(ntimes)
    fx_ad = 0.0_FVPRC
    fy_ad = 0.0_FVPRC
    DO n=ntimes,1,-1
      DO k=km,1,-1
        CALL POPINTEGER(ad_from4)
        CALL POPINTEGER(ad_to4)
        DO j=ad_to4,ad_from4,-1
          CALL POPINTEGER(ad_from3)
          CALL POPINTEGER(ad_to3)
          DO i=ad_to3,ad_from3,-1
            temp_ad5 = cd*gridstruct%rarea(i, j)*q_ad(i, j, k)
            fx_ad(i, j) = fx_ad(i, j) + temp_ad5
            fx_ad(i+1, j) = fx_ad(i+1, j) - temp_ad5
            fy_ad(i, j) = fy_ad(i, j) + temp_ad5
            fy_ad(i, j+1) = fy_ad(i, j+1) - temp_ad5
          END DO
        END DO
        CALL POPINTEGER(ad_from2)
        CALL POPINTEGER(ad_to2)
        DO j=ad_to2,ad_from2,-1
          CALL POPINTEGER(ad_from1)
          CALL POPINTEGER(ad_to1)
          DO i=ad_to1,ad_from1,-1
            temp_ad4 = gridstruct%dx(i, j)*gridstruct%sina_v(i, j)*&
&             gridstruct%rdyc(i, j)*fy_ad(i, j)
            q_ad(i, j-1, k) = q_ad(i, j-1, k) + temp_ad4
            q_ad(i, j, k) = q_ad(i, j, k) - temp_ad4
            fy_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
        CALL POPCONTROL1B_FV(branch)
        IF (branch .NE. 0) CALL COPY_CORNERS_ADM(q(isd:ied, jsd:jed, k)&
&                                          , q_ad(isd:ied, jsd:jed, k), &
&                                          npx, npy, 2, gridstruct%&
&                                          nested, bd, gridstruct%&
&                                          sw_corner, gridstruct%&
&                                          se_corner, gridstruct%&
&                                          nw_corner, gridstruct%&
&                                          ne_corner)
        CALL POPINTEGER(ad_from0)
        CALL POPINTEGER(ad_to0)
        DO j=ad_to0,ad_from0,-1
          CALL POPINTEGER(ad_from)
          CALL POPINTEGER(ad_to)
          DO i=ad_to,ad_from,-1
            temp_ad3 = gridstruct%dy(i, j)*gridstruct%sina_u(i, j)*&
&             gridstruct%rdxc(i, j)*fx_ad(i, j)
            q_ad(i-1, j, k) = q_ad(i-1, j, k) + temp_ad3
            q_ad(i, j, k) = q_ad(i, j, k) - temp_ad3
            fx_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
        CALL POPCONTROL1B_FV(branch)
        IF (branch .NE. 0) CALL COPY_CORNERS_ADM(q(isd:ied, jsd:jed, k)&
&                                          , q_ad(isd:ied, jsd:jed, k), &
&                                          npx, npy, 1, gridstruct%&
&                                          nested, bd, gridstruct%&
&                                          sw_corner, gridstruct%&
&                                          se_corner, gridstruct%&
&                                          nw_corner, gridstruct%&
&                                          ne_corner)
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          tmp_ad4 = q_ad(1, npy, k)
          q_ad(1, npy, k) = 0.0_FVPRC
          q_ad(1, je, k) = q_ad(1, je, k) + q_ad(0, je, k) + tmp_ad4
          q_ad(0, je, k) = 0.0_FVPRC
          tmp_ad5 = q_ad(1, je, k)
          temp_ad2 = r3*tmp_ad5
          q_ad(1, je, k) = temp_ad2
          q_ad(0, je, k) = q_ad(0, je, k) + temp_ad2
          q_ad(1, npy, k) = q_ad(1, npy, k) + temp_ad2
        END IF
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          tmp_ad1 = q_ad(ie, npy, k)
          q_ad(ie, npy, k) = 0.0_FVPRC
          q_ad(ie, je, k) = q_ad(ie, je, k) + tmp_ad1
          tmp_ad2 = q_ad(npx, je, k)
          q_ad(npx, je, k) = 0.0_FVPRC
          q_ad(ie, je, k) = q_ad(ie, je, k) + tmp_ad2
          tmp_ad3 = q_ad(ie, je, k)
          temp_ad1 = r3*tmp_ad3
          q_ad(ie, je, k) = temp_ad1
          q_ad(npx, je, k) = q_ad(npx, je, k) + temp_ad1
          q_ad(ie, npy, k) = q_ad(ie, npy, k) + temp_ad1
        END IF
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          q_ad(ie, 1, k) = q_ad(ie, 1, k) + q_ad(ie, 0, k)
          q_ad(ie, 0, k) = 0.0_FVPRC
          tmp_ad = q_ad(npx, 1, k)
          q_ad(npx, 1, k) = 0.0_FVPRC
          q_ad(ie, 1, k) = q_ad(ie, 1, k) + tmp_ad
          tmp_ad0 = q_ad(ie, 1, k)
          temp_ad0 = r3*tmp_ad0
          q_ad(ie, 1, k) = temp_ad0
          q_ad(npx, 1, k) = q_ad(npx, 1, k) + temp_ad0
          q_ad(ie, 0, k) = q_ad(ie, 0, k) + temp_ad0
        END IF
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          q_ad(1, 1, k) = q_ad(1, 1, k) + q_ad(1, 0, k)
          q_ad(1, 0, k) = 0.0_FVPRC
          q_ad(1, 1, k) = q_ad(1, 1, k) + q_ad(0, 1, k)
          q_ad(0, 1, k) = 0.0_FVPRC
          temp_ad = r3*q_ad(1, 1, k)
          q_ad(0, 1, k) = q_ad(0, 1, k) + temp_ad
          q_ad(1, 0, k) = q_ad(1, 0, k) + temp_ad
          q_ad(1, 1, k) = temp_ad
        END IF
      END DO
    END DO
    CALL POPREALARRAY(q, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*km/8&
&               )
    CALL MPP_UPDATE_DOMAINS_ADM(q, q_ad, domain, complete=.true.)
  END SUBROUTINE DEL2_CUBED_BWD
  SUBROUTINE DEL2_CUBED(q, cd, gridstruct, domain, npx, npy, km, nmax, &
&   bd)
    IMPLICIT NONE
!---------------------------------------------------------------
! This routine is for filtering the omega field for the physics
!---------------------------------------------------------------
    INTEGER, INTENT(IN) :: npx, npy, km, nmax
! cd = K * da_min;   0 < K < 0.25
    REAL(kind=r_grid), INTENT(IN) :: cd
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    REAL(fvprc), PARAMETER :: r3=1./3.
    REAL(fvprc) :: fx(bd%isd:bd%ied+1, bd%jsd:bd%jed), fy(bd%isd:bd%ied&
&   , bd%jsd:bd%jed+1)
    REAL(fvprc) :: q2(bd%isd:bd%ied, bd%jsd:bd%jed)
    INTEGER :: i, j, k, n, nt, ntimes
    LOGICAL, SAVE :: do_nullify=.false.
    INTEGER :: is, ie, js, je, isd, ied, jsd, jed
    INTRINSIC MIN
!Local routine pointers
!      real(FVPRC), pointer, dimension(:,:) :: rarea
!      real(FVPRC), pointer, dimension(:,:) :: sina_u, sina_v
!      real(FVPRC), pointer, dimension(:,:) :: rdxc, rdyc, dy
!      logical, pointer :: sw_corner, se_corner, ne_corner, nw_corner
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    IF (3 .GT. nmax) THEN
      ntimes = nmax
    ELSE
      ntimes = 3
    END IF
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
    CALL MPP_UPDATE_DOMAINS(q, domain, complete=.true.)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
    DO n=1,ntimes
      nt = ntimes - n
!$OMP parallel do default(none) shared(km,sw_corner,q,se_corner,is,ie,js,je,npx,npy, &
!$OMP                                  nw_corner,ne_corner,nt,isd,jsd,gridstruct,bd, &
!$OMP                                  dy,sina_u,rdxc,sina_v,rdyc,cd,rarea         ) &
!$OMP                          private(fx, fy)
      DO k=1,km
        IF (gridstruct%sw_corner) THEN
          q(1, 1, k) = (q(1, 1, k)+q(0, 1, k)+q(1, 0, k))*r3
          q(0, 1, k) = q(1, 1, k)
          q(1, 0, k) = q(1, 1, k)
        END IF
        IF (gridstruct%se_corner) THEN
          q(ie, 1, k) = (q(ie, 1, k)+q(npx, 1, k)+q(ie, 0, k))*r3
          q(npx, 1, k) = q(ie, 1, k)
          q(ie, 0, k) = q(ie, 1, k)
        END IF
        IF (gridstruct%ne_corner) THEN
          q(ie, je, k) = (q(ie, je, k)+q(npx, je, k)+q(ie, npy, k))*r3
          q(npx, je, k) = q(ie, je, k)
          q(ie, npy, k) = q(ie, je, k)
        END IF
        IF (gridstruct%nw_corner) THEN
          q(1, je, k) = (q(1, je, k)+q(0, je, k)+q(1, npy, k))*r3
          q(0, je, k) = q(1, je, k)
          q(1, npy, k) = q(1, je, k)
        END IF
        IF (nt .GT. 0) CALL COPY_CORNERS(q(isd:ied, jsd:jed, k), npx, &
&                                  npy, 1, gridstruct%nested, bd, &
&                                  gridstruct%sw_corner, gridstruct%&
&                                  se_corner, gridstruct%nw_corner, &
&                                  gridstruct%ne_corner)
        DO j=js-nt,je+nt
          DO i=is-nt,ie+1+nt
            fx(i, j) = gridstruct%dy(i, j)*gridstruct%sina_u(i, j)*(q(i-&
&             1, j, k)-q(i, j, k))*gridstruct%rdxc(i, j)
          END DO
        END DO
        IF (nt .GT. 0) CALL COPY_CORNERS(q(isd:ied, jsd:jed, k), npx, &
&                                  npy, 2, gridstruct%nested, bd, &
&                                  gridstruct%sw_corner, gridstruct%&
&                                  se_corner, gridstruct%nw_corner, &
&                                  gridstruct%ne_corner)
        DO j=js-nt,je+1+nt
          DO i=is-nt,ie+nt
            fy(i, j) = gridstruct%dx(i, j)*gridstruct%sina_v(i, j)*(q(i&
&             , j-1, k)-q(i, j, k))*gridstruct%rdyc(i, j)
          END DO
        END DO
        DO j=js-nt,je+nt
          DO i=is-nt,ie+nt
            q(i, j, k) = q(i, j, k) + cd*gridstruct%rarea(i, j)*(fx(i, j&
&             )-fx(i+1, j)+fy(i, j)-fy(i, j+1))
          END DO
        END DO
      END DO
    END DO
  END SUBROUTINE DEL2_CUBED
!  Differentiation of init_ijk_mem in reverse (adjoint) mode (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod.a2b_ord4_f
!b a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core
!_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_
!update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.rayleigh_super
! fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to_latlon fv_
!grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energy fv_mapz_m
!od.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mod.map1_q2_
!fb fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv_tracer2d_m
!od.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver_c nh_core_
!mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core_mod.sim_so
!lver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest
! sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.compute_d
!iv_damping_fb sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mod.copy_corn
!ers_fb tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_mod.fyppm
! tp_core_mod.deln_flux)):
!   gradient     of useful results: array
!   with respect to varying inputs: array
  SUBROUTINE INIT_IJK_MEM_ADM(i1, i2, j1, j2, km, array, array_ad, var)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: i1, i2, j1, j2, km
    REAL(fvprc), INTENT(INOUT) :: array(i1:i2, j1:j2, km)
    REAL(fvprc), INTENT(INOUT) :: array_ad(i1:i2, j1:j2, km)
    REAL(fvprc), INTENT(IN) :: var
    INTEGER :: i, j, k
    DO k=km,1,-1
      DO j=j2,j1,-1
        DO i=i2,i1,-1
          array_ad(i, j, k) = 0.0_FVPRC
        END DO
      END DO
    END DO
  END SUBROUTINE INIT_IJK_MEM_ADM
  SUBROUTINE INIT_IJK_MEM(i1, i2, j1, j2, km, array, var)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: i1, i2, j1, j2, km
    REAL(fvprc), INTENT(INOUT) :: array(i1:i2, j1:j2, km)
    REAL(fvprc), INTENT(IN) :: var
    INTEGER :: i, j, k
!$OMP parallel do default(none) shared(i1,i2,j1,j2,km,array,var)
    DO k=1,km
      DO j=j1,j2
        DO i=i1,i2
          array(i, j, k) = var
        END DO
      END DO
    END DO
  END SUBROUTINE INIT_IJK_MEM
END MODULE DYN_CORE_MOD_B
