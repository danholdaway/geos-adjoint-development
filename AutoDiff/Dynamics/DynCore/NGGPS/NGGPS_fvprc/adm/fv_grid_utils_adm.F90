!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
MODULE FV_GRID_UTILS_MOD_B
  USE FV_ARRAYS_MOD_B, ONLY : real4, real8, 8
  USE FV_ARRAYS_MOD_B, ONLY : fv_grid_type, fv_grid_bounds_type, r_grid
  USE MPP_DOMAINS_MOD_B, ONLY : domain2d, dgrid_ne, mpp_update_domains, &
& mpp_update_domains_adm
  USE MPP_DOMAINS_MOD_B, ONLY : mpp_global_sum, mpp_global_sum_adm, &
& bitwise_exact_sum
  USE FV_MP_MOD_B, ONLY : mp_reduce_sum
  USE FV_TIMING_MOD, ONLY : timing_on, timing_off
  IMPLICIT NONE
! real(FVPRC) function g_sum(domain, p, ifirst, ilast, jfirst, jlast, ngc, area, mode, reproduce)
!! Fast version of globalsum 
!      integer, intent(IN) :: ifirst, ilast
!      integer, intent(IN) :: jfirst, jlast, ngc
!      integer, intent(IN) :: mode  ! if ==1 divided by area
!      logical, intent(in), optional :: reproduce
!      real(FVPRC), intent(IN) :: p(ifirst:ilast,jfirst:jlast)      ! field to be summed
!      real(kind=R_GRID), intent(IN) :: area(ifirst-ngc:ilast+ngc,jfirst-ngc:jlast+ngc)
!      type(domain2d), intent(IN) :: domain
!      integer :: i,j
!      real(FVPRC) gsum
!      !logical, SAVE :: g_sum_initialized = .false.
!      real(kind=R_GRID) :: global_area
!        
!      global_area = 1.0 !Not acutally needed
!
!      gsum = 0.
!      do j=jfirst,jlast
!         do i=ifirst,ilast
!            gsum = gsum + p(i,j)*area(i,j)
!         enddo
!      enddo
!
!      if ( mode==1 ) then
!           g_sum = gsum / global_area
!      else
!           g_sum = gsum
!      endif
!
! end function g_sum
  PRIVATE 
  REAL(fvprc), PARAMETER :: big_number=1.e8
  REAL(fvprc), PARAMETER :: ptop_min=1.e-8
  INTEGER, PARAMETER :: f_p=SELECTED_REAL_KIND(20)
  PUBLIC f_p, big_number, ptop_min
  PUBLIC great_circle_dist
  PUBLIC cubed_to_latlon
  PUBLIC cubed_to_latlon_fwd, cubed_to_latlon_bwd
  PUBLIC c2l_ord2
  PUBLIC c2l_ord2_fwd, c2l_ord2_bwd
  PUBLIC c2l_ord4
  PUBLIC c2l_ord4_fwd, c2l_ord4_bwd
  PUBLIC g_sum
  PUBLIC g_sum_adm
  EXTERNAL C2L_ORD2_ADM
  EXTERNAL CUBED_TO_LATLON_ADM

CONTAINS
!  Differentiation of cubed_to_latlon in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_e
!dge_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mo
!d.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn
!_core_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_
!mod.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.c
!ubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_tota
!l_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv
!_mapz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.st
!eepz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem
!_solver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver 
!nh_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.dive
!rgence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_
!core_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_
!core_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp
!_core_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: u v
!   with respect to varying inputs: u v
  SUBROUTINE CUBED_TO_LATLON_FWD(u, v, ua, va, gridstruct, npx, npy, km&
&   , mode, grid_type, domain, nested, c2l_ord, bd)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: km, npx, npy, grid_type, c2l_ord
! update if present
    INTEGER, INTENT(IN) :: mode
    TYPE(FV_GRID_TYPE), INTENT(IN) :: gridstruct
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, km)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(OUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(OUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    LOGICAL, INTENT(IN) :: nested
    IF (c2l_ord .EQ. 2) THEN
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL C2L_ORD4_FWD(u, v, ua, va, gridstruct, npx, npy, km, &
&                 grid_type, domain, nested, mode, bd)
      CALL PUSHCONTROL1B_FV(1)
    END IF
  END SUBROUTINE CUBED_TO_LATLON_FWD
!  Differentiation of cubed_to_latlon in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_
!edge_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_m
!od.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dy
!n_core_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics
!_mod.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.
!cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_tot
!al_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer f
!v_mapz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.s
!teepz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.rie
!m_solver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver
! nh_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.div
!ergence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw
!_core_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp
!_core_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm t
!p_core_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: u v
!   with respect to varying inputs: u v
  SUBROUTINE CUBED_TO_LATLON_BWD(u, u_ad, v, v_ad, ua, va, gridstruct, &
&   npx, npy, km, mode, grid_type, domain, nested, c2l_ord, bd)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: km, npx, npy, grid_type, c2l_ord
    INTEGER, INTENT(IN) :: mode
    TYPE(FV_GRID_TYPE), INTENT(IN) :: gridstruct
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, km)
    REAL(fvprc), INTENT(INOUT) :: u_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   km)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(INOUT) :: v_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   km)
    REAL(fvprc), INTENT(OUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(OUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    LOGICAL, INTENT(IN) :: nested
    INTEGER :: branch
    CALL POPCONTROL1B_FV(branch)
    IF (branch .NE. 0) CALL C2L_ORD4_BWD(u, u_ad, v, v_ad, ua, va, &
&                                  gridstruct, npx, npy, km, grid_type, &
&                                  domain, nested, mode, bd)
  END SUBROUTINE CUBED_TO_LATLON_BWD
  SUBROUTINE CUBED_TO_LATLON(u, v, ua, va, gridstruct, npx, npy, km, &
&   mode, grid_type, domain, nested, c2l_ord, bd)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: km, npx, npy, grid_type, c2l_ord
! update if present
    INTEGER, INTENT(IN) :: mode
    TYPE(FV_GRID_TYPE), INTENT(IN) :: gridstruct
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, km)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(OUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(OUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    LOGICAL, INTENT(IN) :: nested
    IF (c2l_ord .EQ. 2) THEN
      CALL C2L_ORD2(u, v, ua, va, gridstruct, km, grid_type, bd)
    ELSE
      CALL C2L_ORD4(u, v, ua, va, gridstruct, npx, npy, km, grid_type, &
&             domain, nested, mode, bd)
    END IF
  END SUBROUTINE CUBED_TO_LATLON
!  Differentiation of c2l_ord4 in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod
!.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_ha
!lo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_m
!od.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.ray
!leigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to
!_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energ
!y fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_m
!od.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv
!_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver
!_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core
!_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_
!corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mo
!d.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mo
!d.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_m
!od.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: u v
!   with respect to varying inputs: u v
  SUBROUTINE C2L_ORD4_FWD(u, v, ua, va, gridstruct, npx, npy, km, &
&   grid_type, domain, nested, mode, bd)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: km, npx, npy, grid_type
! update if present
    INTEGER, INTENT(IN) :: mode
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, km)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(OUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(OUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    LOGICAL, INTENT(IN) :: nested
! Local 
! 4-pt Lagrange interpolation
    REAL(fvprc), SAVE :: a1=0.5625
    REAL(fvprc), SAVE :: a2=-0.0625
    REAL(fvprc), SAVE :: c1=1.125
    REAL(fvprc), SAVE :: c2=-0.125
    REAL(fvprc) :: utmp(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: vtmp(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: wu(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: wv(bd%is:bd%ie+1, bd%js:bd%je)
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    IF (mode .GT. 0) THEN
      CALL PUSHCONTROL1B_FV(1)
    ELSE
      CALL PUSHCONTROL1B_FV(0)
    END IF
  END SUBROUTINE C2L_ORD4_FWD
!  Differentiation of c2l_ord4 in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mo
!d.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_h
!alo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_
!mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.ra
!yleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_t
!o_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_ener
!gy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_
!mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz f
!v_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solve
!r_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_cor
!e_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence
!_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_m
!od.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_m
!od.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_
!mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: u v
!   with respect to varying inputs: u v
  SUBROUTINE C2L_ORD4_BWD(u, u_ad, v, v_ad, ua, va, gridstruct, npx, npy&
&   , km, grid_type, domain, nested, mode, bd)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: km, npx, npy, grid_type
    INTEGER, INTENT(IN) :: mode
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, km)
    REAL(fvprc), INTENT(INOUT) :: u_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   km)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(INOUT) :: v_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   km)
    REAL(fvprc), INTENT(OUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(OUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    LOGICAL, INTENT(IN) :: nested
    REAL(fvprc), SAVE :: a1=0.5625
    REAL(fvprc), SAVE :: a2=-0.0625
    REAL(fvprc), SAVE :: c1=1.125
    REAL(fvprc), SAVE :: c2=-0.125
    REAL(fvprc) :: utmp(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: vtmp(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: wu(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: wv(bd%is:bd%ie+1, bd%js:bd%je)
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    INTEGER :: branch
    CALL POPCONTROL1B_FV(branch)
    IF (branch .NE. 0) CALL MPP_UPDATE_DOMAINS_ADM(u, u_ad, v, v_ad, &
&                                            domain, gridtype=dgrid_ne)
  END SUBROUTINE C2L_ORD4_BWD
  SUBROUTINE C2L_ORD4(u, v, ua, va, gridstruct, npx, npy, km, grid_type&
&   , domain, nested, mode, bd)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: km, npx, npy, grid_type
! update if present
    INTEGER, INTENT(IN) :: mode
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, km)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(OUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(OUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    LOGICAL, INTENT(IN) :: nested
! Local 
! 4-pt Lagrange interpolation
    REAL(fvprc), SAVE :: a1=0.5625
    REAL(fvprc), SAVE :: a2=-0.0625
    REAL(fvprc), SAVE :: c1=1.125
    REAL(fvprc), SAVE :: c2=-0.125
    REAL(fvprc) :: utmp(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: vtmp(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: wu(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: wv(bd%is:bd%ie+1, bd%js:bd%je)
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    IF (mode .GT. 0) CALL MPP_UPDATE_DOMAINS(u, v, domain, gridtype=&
&                                      dgrid_ne)
!call timing_on('COMM_TOTAL')
!call timing_off('COMM_TOTAL')
!$OMP parallel do default(none) shared(is,ie,js,je,km,npx,npy,grid_type,nested,c2,c1, &
!$OMP                                  u,v,gridstruct,ua,va,a1,a2)         &
!$OMP                          private(utmp, vtmp, wu, wv)
    DO k=1,km
      IF (grid_type .LT. 4) THEN
!nested
        IF (nested) THEN
          IF (1 .LT. js) THEN
            max1 = js
          ELSE
            max1 = 1
          END IF
          IF (npy - 1 .GT. je) THEN
            min1 = je
          ELSE
            min1 = npy - 1
          END IF
          DO j=max1,min1
            IF (1 .LT. is) THEN
              max2 = is
            ELSE
              max2 = 1
            END IF
            IF (npx - 1 .GT. ie) THEN
              min2 = ie
            ELSE
              min2 = npx - 1
            END IF
            DO i=max2,min2
              utmp(i, j) = c2*(u(i, j-1, k)+u(i, j+2, k)) + c1*(u(i, j, &
&               k)+u(i, j+1, k))
              vtmp(i, j) = c2*(v(i-1, j, k)+v(i+2, j, k)) + c1*(v(i, j, &
&               k)+v(i+1, j, k))
            END DO
          END DO
        ELSE
          IF (2 .LT. js) THEN
            max3 = js
          ELSE
            max3 = 2
          END IF
          IF (npy - 2 .GT. je) THEN
            min3 = je
          ELSE
            min3 = npy - 2
          END IF
          DO j=max3,min3
            IF (2 .LT. is) THEN
              max4 = is
            ELSE
              max4 = 2
            END IF
            IF (npx - 2 .GT. ie) THEN
              min4 = ie
            ELSE
              min4 = npx - 2
            END IF
            DO i=max4,min4
              utmp(i, j) = c2*(u(i, j-1, k)+u(i, j+2, k)) + c1*(u(i, j, &
&               k)+u(i, j+1, k))
              vtmp(i, j) = c2*(v(i-1, j, k)+v(i+2, j, k)) + c1*(v(i, j, &
&               k)+v(i+1, j, k))
            END DO
          END DO
          IF (js .EQ. 1) THEN
            DO i=is,ie+1
              wv(i, 1) = v(i, 1, k)*gridstruct%dy(i, 1)
            END DO
            DO i=is,ie
              vtmp(i, 1) = 2.*(wv(i, 1)+wv(i+1, 1))/(gridstruct%dy(i, 1)&
&               +gridstruct%dy(i+1, 1))
              utmp(i, 1) = 2.*(u(i, 1, k)*gridstruct%dx(i, 1)+u(i, 2, k)&
&               *gridstruct%dx(i, 2))/(gridstruct%dx(i, 1)+gridstruct%dx&
&               (i, 2))
            END DO
          END IF
!!!         vtmp(i,1) = (wv(i,1) + wv(i+1,1)) * gridstruct%rdya(i,1)
!!!         utmp(i,1) = (u(i,1,k)*gridstruct%dx(i,1) + u(i,2,k)*gridstruct%dx(i,2)) * gridstruct%rdxa(i,1)
          IF (je + 1 .EQ. npy) THEN
            j = npy - 1
            DO i=is,ie+1
              wv(i, j) = v(i, j, k)*gridstruct%dy(i, j)
            END DO
            DO i=is,ie
              vtmp(i, j) = 2.*(wv(i, j)+wv(i+1, j))/(gridstruct%dy(i, j)&
&               +gridstruct%dy(i+1, j))
              utmp(i, j) = 2.*(u(i, j, k)*gridstruct%dx(i, j)+u(i, j+1, &
&               k)*gridstruct%dx(i, j+1))/(gridstruct%dx(i, j)+&
&               gridstruct%dx(i, j+1))
            END DO
          END IF
!!!         vtmp(i,j) = (wv(i,j) + wv(i+1,j)) * gridstruct%rdya(i,j)
!!!         utmp(i,j) = (u(i,j,k)*gridstruct%dx(i,j) + u(i,j+1,k)*gridstruct%dx(i,j+1)) * gridstruct%rdxa(i,j)
          IF (is .EQ. 1) THEN
            i = 1
            DO j=js,je
              wv(1, j) = v(1, j, k)*gridstruct%dy(1, j)
              wv(2, j) = v(2, j, k)*gridstruct%dy(2, j)
            END DO
            DO j=js,je+1
              wu(i, j) = u(i, j, k)*gridstruct%dx(i, j)
            END DO
            DO j=js,je
              utmp(i, j) = 2.*(wu(i, j)+wu(i, j+1))/(gridstruct%dx(i, j)&
&               +gridstruct%dx(i, j+1))
              vtmp(i, j) = 2.*(wv(1, j)+wv(2, j))/(gridstruct%dy(1, j)+&
&               gridstruct%dy(2, j))
            END DO
          END IF
!!!      utmp(i,j) = (wu(i,j) + wu(i,  j+1)) * gridstruct%rdxa(i,j)
!!!      vtmp(i,j) = (wv(i,j) + wv(i+1,j  )) * gridstruct%rdya(i,j)
          IF (ie + 1 .EQ. npx) THEN
            i = npx - 1
            DO j=js,je
              wv(i, j) = v(i, j, k)*gridstruct%dy(i, j)
              wv(i+1, j) = v(i+1, j, k)*gridstruct%dy(i+1, j)
            END DO
            DO j=js,je+1
              wu(i, j) = u(i, j, k)*gridstruct%dx(i, j)
            END DO
            DO j=js,je
              utmp(i, j) = 2.*(wu(i, j)+wu(i, j+1))/(gridstruct%dx(i, j)&
&               +gridstruct%dx(i, j+1))
              vtmp(i, j) = 2.*(wv(i, j)+wv(i+1, j))/(gridstruct%dy(i, j)&
&               +gridstruct%dy(i+1, j))
            END DO
          END IF
        END IF
!!!      utmp(i,j) = (wu(i,j) + wu(i,  j+1)) * gridstruct%rdxa(i,j)
!!!      vtmp(i,j) = (wv(i,j) + wv(i+1,j  )) * gridstruct%rdya(i,j)
!Transform local a-grid winds into latitude-longitude coordinates
        DO j=js,je
          DO i=is,ie
            ua(i, j, k) = gridstruct%a11(i, j)*utmp(i, j) + gridstruct%&
&             a12(i, j)*vtmp(i, j)
            va(i, j, k) = gridstruct%a21(i, j)*utmp(i, j) + gridstruct%&
&             a22(i, j)*vtmp(i, j)
          END DO
        END DO
      ELSE
! Simple Cartesian Geometry:
        DO j=js,je
          DO i=is,ie
            ua(i, j, k) = a2*(u(i, j-1, k)+u(i, j+2, k)) + a1*(u(i, j, k&
&             )+u(i, j+1, k))
            va(i, j, k) = a2*(v(i-1, j, k)+v(i+2, j, k)) + a1*(v(i, j, k&
&             )+v(i+1, j, k))
          END DO
        END DO
      END IF
    END DO
  END SUBROUTINE C2L_ORD4
!  Differentiation of c2l_ord2 in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod
!.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_ha
!lo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_m
!od.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.ray
!leigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to
!_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energ
!y fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_m
!od.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv
!_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver
!_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core
!_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_
!corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mo
!d.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mo
!d.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_m
!od.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: u v ua va
!   with respect to varying inputs: u v ua va
  SUBROUTINE C2L_ORD2_FWD(u, v, ua, va, gridstruct, km, grid_type, bd)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: km, grid_type
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, km)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, km)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
!
    REAL(fvprc) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, km)
!--------------------------------------------------------------
! Local 
    REAL(fvprc) :: wu(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: wv(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: u1(bd%is:bd%ie), v1(bd%is:bd%ie)
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
!  real(FVPRC), dimension(:,:), pointer :: a11, a12, a21, a22
!  real(FVPRC), dimension(:,:), pointer :: dx, dy, rdxa, rdya
!  a11 => gridstruct%a11
!  a12 => gridstruct%a12
!  a21 => gridstruct%a21
!  a22 => gridstruct%a22
!  dx   => gridstruct%dx
!  dy   => gridstruct%dy
!  rdxa => gridstruct%rdxa
!  rdya => gridstruct%rdya
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
!$OMP parallel do default(none) shared(is,ie,js,je,km,grid_type,u,dx,v,dy,ua,va,a11,a12,a21,a22) &
!$OMP                          private(u1, v1, wu, wv)
    DO k=1,km
      IF (grid_type .LT. 4) THEN
        DO j=js,je+1
          DO i=is,ie
            wu(i, j) = u(i, j, k)*gridstruct%dx(i, j)
          END DO
        END DO
        DO j=js,je
          DO i=is,ie+1
            wv(i, j) = v(i, j, k)*gridstruct%dy(i, j)
          END DO
        END DO
        DO j=js,je
          DO i=is,ie
! Co-variant to Co-variant "vorticity-conserving" interpolation
            u1(i) = 2.*(wu(i, j)+wu(i, j+1))/(gridstruct%dx(i, j)+&
&             gridstruct%dx(i, j+1))
            v1(i) = 2.*(wv(i, j)+wv(i+1, j))/(gridstruct%dy(i, j)+&
&             gridstruct%dy(i+1, j))
!!!          u1(i) = (wu(i,j) + wu(i,j+1)) * gridstruct%rdxa(i,j)
!!!          v1(i) = (wv(i,j) + wv(i+1,j)) * gridstruct%rdya(i,j)
! Cubed (cell center co-variant winds) to lat-lon:
            CALL PUSHREALARRAY(ua(i, j, k))
            ua(i, j, k) = gridstruct%a11(i, j)*u1(i) + gridstruct%a12(i&
&             , j)*v1(i)
            CALL PUSHREALARRAY(va(i, j, k))
            va(i, j, k) = gridstruct%a21(i, j)*u1(i) + gridstruct%a22(i&
&             , j)*v1(i)
          END DO
        END DO
        CALL PUSHCONTROL1B_FV(1)
      ELSE
! 2nd order:
        DO j=js,je
          DO i=is,ie
            CALL PUSHREALARRAY(ua(i, j, k))
            ua(i, j, k) = 0.5*(u(i, j, k)+u(i, j+1, k))
            CALL PUSHREALARRAY(va(i, j, k))
            va(i, j, k) = 0.5*(v(i, j, k)+v(i+1, j, k))
          END DO
        END DO
        CALL PUSHCONTROL1B_FV(0)
      END IF
    END DO
    CALL PUSHINTEGER(js)
    CALL PUSHINTEGER(ie)
    CALL PUSHINTEGER(is)
    CALL PUSHINTEGER(je)
  END SUBROUTINE C2L_ORD2_FWD
!  Differentiation of c2l_ord2 in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mo
!d.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_h
!alo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_
!mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.ra
!yleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_t
!o_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_ener
!gy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_
!mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz f
!v_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solve
!r_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_cor
!e_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence
!_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_m
!od.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_m
!od.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_
!mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: u v ua va
!   with respect to varying inputs: u v ua va
  SUBROUTINE C2L_ORD2_BWD(u, u_ad, v, v_ad, ua, ua_ad, va, va_ad, &
&   gridstruct, km, grid_type, bd)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: km, grid_type
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, km)
    REAL(fvprc) :: u_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1, km)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, km)
    REAL(fvprc) :: v_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed, km)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
    REAL(fvprc) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc) :: ua_ad(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc) :: va_ad(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc) :: wu(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: wu_ad(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: wv(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: wv_ad(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: u1(bd%is:bd%ie), v1(bd%is:bd%ie)
    REAL(fvprc) :: u1_ad(bd%is:bd%ie), v1_ad(bd%is:bd%ie)
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    INTEGER :: branch
    CALL POPINTEGER(je)
    CALL POPINTEGER(is)
    CALL POPINTEGER(ie)
    CALL POPINTEGER(js)
    wu_ad = 0.0_FVPRC
    v1_ad = 0.0_FVPRC
    wv_ad = 0.0_FVPRC
    u1_ad = 0.0_FVPRC
    DO k=km,1,-1
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        DO j=je,js,-1
          DO i=ie,is,-1
            CALL POPREALARRAY(va(i, j, k))
            v_ad(i, j, k) = v_ad(i, j, k) + 0.5*va_ad(i, j, k)
            v_ad(i+1, j, k) = v_ad(i+1, j, k) + 0.5*va_ad(i, j, k)
            va_ad(i, j, k) = 0.0_FVPRC
            CALL POPREALARRAY(ua(i, j, k))
            u_ad(i, j, k) = u_ad(i, j, k) + 0.5*ua_ad(i, j, k)
            u_ad(i, j+1, k) = u_ad(i, j+1, k) + 0.5*ua_ad(i, j, k)
            ua_ad(i, j, k) = 0.0_FVPRC
          END DO
        END DO
      ELSE
        DO j=je,js,-1
          DO i=ie,is,-1
            CALL POPREALARRAY(va(i, j, k))
            u1_ad(i) = u1_ad(i) + gridstruct%a11(i, j)*ua_ad(i, j, k) + &
&             gridstruct%a21(i, j)*va_ad(i, j, k)
            v1_ad(i) = v1_ad(i) + gridstruct%a12(i, j)*ua_ad(i, j, k) + &
&             gridstruct%a22(i, j)*va_ad(i, j, k)
            va_ad(i, j, k) = 0.0_FVPRC
            CALL POPREALARRAY(ua(i, j, k))
            ua_ad(i, j, k) = 0.0_FVPRC
            temp_ad = 2.*v1_ad(i)/(gridstruct%dy(i, j)+gridstruct%dy(i+1&
&             , j))
            wv_ad(i, j) = wv_ad(i, j) + temp_ad
            wv_ad(i+1, j) = wv_ad(i+1, j) + temp_ad
            v1_ad(i) = 0.0_FVPRC
            temp_ad0 = 2.*u1_ad(i)/(gridstruct%dx(i, j)+gridstruct%dx(i&
&             , j+1))
            wu_ad(i, j) = wu_ad(i, j) + temp_ad0
            wu_ad(i, j+1) = wu_ad(i, j+1) + temp_ad0
            u1_ad(i) = 0.0_FVPRC
          END DO
        END DO
        DO j=je,js,-1
          DO i=ie+1,is,-1
            v_ad(i, j, k) = v_ad(i, j, k) + gridstruct%dy(i, j)*wv_ad(i&
&             , j)
            wv_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
        DO j=je+1,js,-1
          DO i=ie,is,-1
            u_ad(i, j, k) = u_ad(i, j, k) + gridstruct%dx(i, j)*wu_ad(i&
&             , j)
            wu_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
      END IF
    END DO
  END SUBROUTINE C2L_ORD2_BWD
  SUBROUTINE C2L_ORD2(u, v, ua, va, gridstruct, km, grid_type, bd)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: km, grid_type
    REAL(fvprc), INTENT(IN) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, km)
    REAL(fvprc), INTENT(IN) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, km)
    TYPE(FV_GRID_TYPE), INTENT(IN), TARGET :: gridstruct
!
    REAL(fvprc), INTENT(OUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, km)
    REAL(fvprc), INTENT(OUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, km)
!--------------------------------------------------------------
! Local 
    REAL(fvprc) :: wu(bd%is:bd%ie, bd%js:bd%je+1)
    REAL(fvprc) :: wv(bd%is:bd%ie+1, bd%js:bd%je)
    REAL(fvprc) :: u1(bd%is:bd%ie), v1(bd%is:bd%ie)
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
!  real(FVPRC), dimension(:,:), pointer :: a11, a12, a21, a22
!  real(FVPRC), dimension(:,:), pointer :: dx, dy, rdxa, rdya
!  a11 => gridstruct%a11
!  a12 => gridstruct%a12
!  a21 => gridstruct%a21
!  a22 => gridstruct%a22
!  dx   => gridstruct%dx
!  dy   => gridstruct%dy
!  rdxa => gridstruct%rdxa
!  rdya => gridstruct%rdya
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
!$OMP parallel do default(none) shared(is,ie,js,je,km,grid_type,u,dx,v,dy,ua,va,a11,a12,a21,a22) &
!$OMP                          private(u1, v1, wu, wv)
    DO k=1,km
      IF (grid_type .LT. 4) THEN
        DO j=js,je+1
          DO i=is,ie
            wu(i, j) = u(i, j, k)*gridstruct%dx(i, j)
          END DO
        END DO
        DO j=js,je
          DO i=is,ie+1
            wv(i, j) = v(i, j, k)*gridstruct%dy(i, j)
          END DO
        END DO
        DO j=js,je
          DO i=is,ie
! Co-variant to Co-variant "vorticity-conserving" interpolation
            u1(i) = 2.*(wu(i, j)+wu(i, j+1))/(gridstruct%dx(i, j)+&
&             gridstruct%dx(i, j+1))
            v1(i) = 2.*(wv(i, j)+wv(i+1, j))/(gridstruct%dy(i, j)+&
&             gridstruct%dy(i+1, j))
!!!          u1(i) = (wu(i,j) + wu(i,j+1)) * gridstruct%rdxa(i,j)
!!!          v1(i) = (wv(i,j) + wv(i+1,j)) * gridstruct%rdya(i,j)
! Cubed (cell center co-variant winds) to lat-lon:
            ua(i, j, k) = gridstruct%a11(i, j)*u1(i) + gridstruct%a12(i&
&             , j)*v1(i)
            va(i, j, k) = gridstruct%a21(i, j)*u1(i) + gridstruct%a22(i&
&             , j)*v1(i)
          END DO
        END DO
      ELSE
! 2nd order:
        DO j=js,je
          DO i=is,ie
            ua(i, j, k) = 0.5*(u(i, j, k)+u(i, j+1, k))
            va(i, j, k) = 0.5*(v(i, j, k)+v(i+1, j, k))
          END DO
        END DO
      END IF
    END DO
  END SUBROUTINE C2L_ORD2
  REAL(fvprc) FUNCTION GREAT_CIRCLE_DIST(q1, q2, radius)
    IMPLICIT NONE
    REAL(kind=r_grid), INTENT(IN) :: q1(2), q2(2)
    REAL(kind=r_grid), INTENT(IN), OPTIONAL :: radius
    REAL(f_p) :: p1(2), p2(2)
    REAL(f_p) :: beta
    INTEGER :: n
    INTRINSIC SIN
    INTRINSIC COS
    INTRINSIC SQRT
    INTRINSIC ASIN
    INTRINSIC PRESENT
    DO n=1,2
      p1(n) = q1(n)
      p2(n) = q2(n)
    END DO
    beta = ASIN(SQRT(SIN((p1(2)-p2(2))/2.)**2+COS(p1(2))*COS(p2(2))*SIN(&
&     (p1(1)-p2(1))/2.)**2))*2.
    IF (PRESENT(radius)) THEN
      great_circle_dist = radius*beta
    ELSE
! Returns the angle
      great_circle_dist = beta
    END IF
  END FUNCTION GREAT_CIRCLE_DIST
!  Differentiation of g_sum in reverse (adjoint) mode (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod.a2b_ord4 a2b_e
!dge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.ad
!v_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update 
!dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.rayleigh_super fv_dyn
!amics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to_latlon fv_grid_ut
!ils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energy fv_mapz_mod.pkez
! fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mod.map1_q2 fv_m
!apz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv_tracer2d_mod.trac
!er_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver_c nh_core_mod.rie
!m_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core_mod.sim_solver nh
!_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_cor
!e_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.compute_div_damp
!ing_fb sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mod.copy_corners 
!tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_mod.fyppm tp_cor
!e_mod.deln_flux)):
!   gradient     of useful results: p g_sum
!   with respect to varying inputs: p
  SUBROUTINE G_SUM_ADM(domain, p, p_ad, ifirst, ilast, jfirst, jlast, &
&   ngc, area, mode, reproduce, g_sum_ad)
    IMPLICIT NONE
! Fast version of globalsum 
    INTEGER, INTENT(IN) :: ifirst, ilast
    INTEGER, INTENT(IN) :: jfirst, jlast, ngc
! if ==1 divided by area
    INTEGER, INTENT(IN) :: mode
    LOGICAL, INTENT(IN), OPTIONAL :: reproduce
! field to be summed
    REAL(fvprc), INTENT(IN) :: p(ifirst:ilast, jfirst:jlast)
    REAL(fvprc) :: p_ad(ifirst:ilast, jfirst:jlast)
    REAL(kind=r_grid), INTENT(IN) :: area(ifirst-ngc:ilast+ngc, jfirst-&
&   ngc:jlast+ngc)
    TYPE(DOMAIN2D), INTENT(IN) :: domain
    INTEGER :: i, j
    REAL(fvprc) :: gsum
    REAL(fvprc) :: gsum_ad
! field to be summed
    REAL(fvprc) :: gsuma(ifirst:ilast, jfirst:jlast)
    REAL(fvprc) :: gsuma_ad(ifirst:ilast, jfirst:jlast)
    LOGICAL, SAVE :: g_sum_initialized=.false.
    REAL(kind=r_grid) :: global_area
    INTRINSIC PRESENT
    REAL*8, DIMENSION(ilast-ifirst+1, jlast-jfirst+1) :: arg1
    REAL*8, DIMENSION(ilast-ifirst+1, jlast-jfirst+1) :: arg1_ad
    INTEGER :: branch
    REAL(fvprc) :: g_sum
    REAL(fvprc) :: g_sum_ad
!if ( .not. g_sum_initialized ) then
!   global_area = mpp_global_sum(domain, area, flags=BITWISE_EXACT_SUM)
!   !if ( is_master() ) write(*,*) 'Global Area=',global_area
!   g_sum_initialized = .true.
!end if
    global_area = 10.e8
!-------------------------
! FMS global sum algorithm:
!-------------------------
    IF (PRESENT(reproduce)) THEN
      IF (reproduce) THEN
        arg1(:, :) = p(:, :)*area(ifirst:ilast, jfirst:jlast)
        CALL PUSHCONTROL2B(0)
      ELSE
        arg1(:, :) = p(:, :)*area(ifirst:ilast, jfirst:jlast)
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
!-------------------------
! Quick local sum algorithm
!-------------------------
      gsuma = 0.
      DO j=jfirst,jlast
        DO i=ifirst,ilast
          gsuma(i, j) = gsuma(i, j) + p(i, j)*area(i, j)
        END DO
      END DO
      CALL PUSHCONTROL2B(2)
    END IF
    IF (mode .EQ. 1) THEN
      gsum_ad = g_sum_ad/global_area
    ELSE
      gsum_ad = g_sum_ad
    END IF
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      CALL MPP_GLOBAL_SUM_ADM(domain, arg1(:, :), arg1_ad(:, :), flags=&
&                       bitwise_exact_sum, mpp_global_sum_2d_ad=gsum_ad)
      p_ad = p_ad + area(ifirst:ilast, jfirst:jlast)*arg1_ad
    ELSE IF (branch .EQ. 1) THEN
      CALL MPP_GLOBAL_SUM_ADM(domain, arg1(:, :), arg1_ad(:, :), &
&                       mpp_global_sum_2d_ad=gsum_ad)
      p_ad = p_ad + area(ifirst:ilast, jfirst:jlast)*arg1_ad
    ELSE
      CALL MPP_GLOBAL_SUM_ADM(domain, gsuma, gsuma_ad, &
&                       mpp_global_sum_2d_ad=gsum_ad)
      DO j=jlast,jfirst,-1
        DO i=ilast,ifirst,-1
          p_ad(i, j) = p_ad(i, j) + area(i, j)*gsuma_ad(i, j)
        END DO
      END DO
    END IF
  END SUBROUTINE G_SUM_ADM
  REAL(fvprc) FUNCTION G_SUM(domain, p, ifirst, ilast, jfirst, jlast, &
&   ngc, area, mode, reproduce)
    IMPLICIT NONE
! Fast version of globalsum 
    INTEGER, INTENT(IN) :: ifirst, ilast
    INTEGER, INTENT(IN) :: jfirst, jlast, ngc
! if ==1 divided by area
    INTEGER, INTENT(IN) :: mode
    LOGICAL, INTENT(IN), OPTIONAL :: reproduce
! field to be summed
    REAL(fvprc), INTENT(IN) :: p(ifirst:ilast, jfirst:jlast)
    REAL(kind=r_grid), INTENT(IN) :: area(ifirst-ngc:ilast+ngc, jfirst-&
&   ngc:jlast+ngc)
    TYPE(DOMAIN2D), INTENT(IN) :: domain
    INTEGER :: i, j
    REAL(fvprc) :: gsum
! field to be summed
    REAL(fvprc) :: gsuma(ifirst:ilast, jfirst:jlast)
    LOGICAL, SAVE :: g_sum_initialized=.false.
    REAL(kind=r_grid) :: global_area
    INTRINSIC PRESENT
    REAL*8, DIMENSION(ilast-ifirst+1, jlast-jfirst+1) :: arg1
!if ( .not. g_sum_initialized ) then
!   global_area = mpp_global_sum(domain, area, flags=BITWISE_EXACT_SUM)
!   !if ( is_master() ) write(*,*) 'Global Area=',global_area
!   g_sum_initialized = .true.
!end if
    global_area = 10.e8
!-------------------------
! FMS global sum algorithm:
!-------------------------
    IF (PRESENT(reproduce)) THEN
      IF (reproduce) THEN
        arg1(:, :) = p(:, :)*area(ifirst:ilast, jfirst:jlast)
        gsum = MPP_GLOBAL_SUM(domain, arg1(:, :), flags=&
&         bitwise_exact_sum)
      ELSE
        arg1(:, :) = p(:, :)*area(ifirst:ilast, jfirst:jlast)
        gsum = MPP_GLOBAL_SUM(domain, arg1(:, :))
      END IF
    ELSE
!-------------------------
! Quick local sum algorithm
!-------------------------
      gsuma = 0.
      DO j=jfirst,jlast
        DO i=ifirst,ilast
          gsuma(i, j) = gsuma(i, j) + p(i, j)*area(i, j)
        END DO
      END DO
      gsum = MPP_GLOBAL_SUM(domain, gsuma)
    END IF
    IF (mode .EQ. 1) THEN
      g_sum = gsum/global_area
    ELSE
      g_sum = gsum
    END IF
  END FUNCTION G_SUM
END MODULE FV_GRID_UTILS_MOD_B
