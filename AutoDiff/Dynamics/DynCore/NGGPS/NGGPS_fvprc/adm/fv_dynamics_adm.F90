!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
MODULE FV_DYNAMICS_MOD_B
!#ifndef MAPL_MODE
!   use constants_mod,       only: grav, pi, radius, hlv, rdgas, omega, rvgas, cp_vapor
!#else
  USE MAPL_MOD
!#endif
  USE FV_ARRAYS_MOD_B, ONLY : real4, real8, 8, r_grid, tiny_number, &
& fv_timing_onoff
  USE DYN_CORE_MOD_B, ONLY : dyn_core, dyn_core_adm, del2_cubed, &
& del2_cubed_adm
  USE FV_MAPZ_MOD_B, ONLY : compute_total_energy, &
& compute_total_energy_adm, lagrangian_to_eulerian, &
& lagrangian_to_eulerian_adm
  USE FV_TRACER2D_MOD_B, ONLY : tracer_2d, tracer_2d_adm, tracer_2d_1l, &
& tracer_2d_nested, tracer_2d_nested_adm
  USE FV_GRID_UTILS_MOD_B, ONLY : cubed_to_latlon, cubed_to_latlon_adm, &
& c2l_ord2, c2l_ord2_adm, g_sum, g_sum_adm
  USE FV_MP_MOD_B, ONLY : is_master
  USE FV_MP_MOD_B, ONLY : group_halo_update_type
  USE FV_MP_MOD_B, ONLY : start_group_halo_update, &
& start_group_halo_update_adm, complete_group_halo_update
  USE FV_TIMING_MOD, ONLY : timing_on, timing_off
!   use diag_manager_mod,    only: send_data
  USE FV_DIAGNOSTICS_MOD, ONLY : fv_time, prt_mxm, range_check, &
& prt_minmax
  USE MPP_DOMAINS_MOD_B, ONLY : dgrid_ne, cgrid_ne, mpp_update_domains, &
& mpp_update_domains_adm, domain2d
  USE FIELD_MANAGER_MOD, ONLY : model_atmos
  USE TRACER_MANAGER_MOD, ONLY : get_tracer_index
!   use fv_sg_mod,           only: neg_adj3
!   use fv_nesting_mod,      only: setup_nested_grid_BCs
  USE FV_ARRAYS_MOD_B, ONLY : fv_grid_type, fv_flags_type, fv_atmos_type&
& , fv_nest_type, fv_diag_type, fv_grid_bounds_type
  USE FV_NWP_NUDGE_MOD, ONLY : do_adiabatic_init
  IMPLICIT NONE
!#ifdef MAPL_MODE
! Include the MPI library definitons:
!  include 'mpif.h'
!#endif
  LOGICAL :: rf_initialized=.false.
  LOGICAL :: bad_range
!   real(FVPRC), allocatable ::  rf(:)
  INTEGER :: kmax=1
  REAL(fvprc) :: agrav
!#ifdef HIWPP
!   real(FVPRC), allocatable:: u00(:,:,:), v00(:,:,:)
!#endif
  PRIVATE 
  PUBLIC fv_dynamics
  PUBLIC fv_dynamics_fwd, fv_dynamics_bwd
!---- version number -----
!   character(len=128) :: version = '$Id: fv_dynamics.F90,v 1.2.2.2.2.2.30.1.4.1.2.1.20.2.46.4.4.2.2.3.2.1.6.1.2.1 2017/02/16 03:
!47:47 aoloso Exp $'
!   character(len=128) :: tagname = '$Name: Heracles-UNSTABLE_ncepdyn_Feb222017 $'
!#ifdef MAPL_MODE
  REAL(fvprc), PARAMETER :: radius=mapl_radius
  REAL(fvprc), PARAMETER :: pi=mapl_pi_r8
  REAL(fvprc), PARAMETER :: rdgas=mapl_rgas
  REAL(fvprc), PARAMETER :: grav=mapl_grav
  REAL(fvprc), PARAMETER :: hlv=mapl_alhl
  REAL(fvprc), PARAMETER :: cp_vapor=mapl_cp
  REAL(fvprc), PARAMETER :: rvgas=mapl_rvap
  REAL(fvprc), PARAMETER :: omega=mapl_omega
!#endif
  LOGICAL, SAVE :: idealtest=.false.

CONTAINS
!  Differentiation of fv_dynamics_dummy in reverse (adjoint) mode (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod.a2b_o
!rd4_fb a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn
!_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.gra
!d1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.rayleigh_
!super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to_latlo
!n fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energy fv_m
!apz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mod.map
!1_q2_fb fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv_trace
!r2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver_c nh_
!core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core_mod.s
!im_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_corner
!_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.comp
!ute_div_damping_fb sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mod.copy
!_corners_fb tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_mod.fyp
!pm_fb tp_core_mod.deln_flux)):
!   gradient     of useful results: q u v w delp delz pt
!   with respect to varying inputs: q u v w delp delz pt
!   RW status of diff variables: peln:(loc) q:in-out u:in-out v:in-out
!                w:in-out ze0:(loc) delp:in-out ua:(loc) uc:(loc)
!                mfx:(loc) delz:in-out mfy:(loc) omga:(loc) va:(loc)
!                vc:(loc) pkz:(loc) pe:(loc) pk:(loc) ps:(loc)
!                pt:in-out cx:(loc) cy:(loc)
!-----------------------------------------------------------------------
!     fv_dynamics :: FV dynamical core driver
!-----------------------------------------------------------------------
  SUBROUTINE FV_DYNAMICS_DUMMY_ADM(npx, npy, npz, nq_tot, ng, bdt, &
&   consv_te, fill, reproduce_sum, kappa, cp_air, zvir, ptop, ks, ncnst&
&   , n_split, q_split, u, u_ad, v, v_ad, w, w_ad, delz, delz_ad, &
&   hydrostatic, pt, pt_ad, delp, delp_ad, q, q_ad, ps, ps_ad, pe, pe_ad&
&   , pk, pk_ad, peln, peln_ad, pkz, pkz_ad, phis, q_con, omga, omga_ad&
&   , ua, ua_ad, va, va_ad, uc, uc_ad, vc, vc_ad, ak, bk, mfx, mfx_ad, &
&   mfy, mfy_ad, cx, cx_ad, cy, cy_ad, ze0, ze0_ad, hybrid_z, gridstruct&
&   , flagstruct, neststruct, idiag, bd, parent_grid, domain, time_total&
& )
    IMPLICIT NONE
! Large time-step
    REAL(fvprc), INTENT(IN) :: bdt
    REAL(fvprc), INTENT(IN) :: consv_te
    REAL(fvprc), INTENT(IN) :: kappa, cp_air
    REAL(fvprc), INTENT(IN) :: zvir, ptop
    REAL(fvprc), INTENT(IN), OPTIONAL :: time_total
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
! transported tracers
    INTEGER, INTENT(IN) :: nq_tot
    INTEGER, INTENT(IN) :: ng
    INTEGER, INTENT(IN) :: ks
    INTEGER, INTENT(IN) :: ncnst
! small-step horizontal dynamics
    INTEGER, INTENT(IN) :: n_split
! tracer
    INTEGER, INTENT(IN) :: q_split
    LOGICAL, INTENT(IN) :: fill
    LOGICAL, INTENT(IN) :: reproduce_sum
    LOGICAL, INTENT(IN) :: hydrostatic
! Using hybrid_z for remapping
    LOGICAL, INTENT(IN) :: hybrid_z
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! D grid zonal wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz), INTENT(&
&   INOUT) :: u
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz), INTENT(&
&   INOUT) :: u_ad
! D grid meridional wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: v
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: v_ad
!real(FVPRC), intent(inout) :: w( bd%isd:,bd%jsd:,1:)  !  W (m/s)
!  W (m/s) ! replaced previous line bma
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: w_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! temperature (K)
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: pt_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
! pressure thickness (pascal)
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: delp_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
! specific humidity and constituents
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, &
&   ncnst)
    REAL(fvprc), INTENT(INOUT) :: q_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   , ncnst)
!real(FVPRC), intent(inout) :: delz(bd%isd:,bd%jsd:,1:)   ! delta-height (m); non-hydrostatic only
! replace previous line bma
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: delz_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
! height at edges (m); non-hydrostatic
    REAL(fvprc), INTENT(INOUT) :: ze0(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL(fvprc), INTENT(INOUT) :: ze0_ad(bd%is:bd%ie, bd%js:bd%je, npz+1&
&   )
!-----------------------------------------------------------------------
! Auxilliary pressure arrays:    
! The 5 vars below can be re-computed from delp and ptop.
!-----------------------------------------------------------------------
! dyn_aux:
! Surface pressure (pascal)
    REAL(fvprc), INTENT(INOUT) :: ps(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: ps_ad(bd%isd:bd%ied, bd%jsd:bd%jed)
! edge pressure (pascal)
    REAL(fvprc), INTENT(INOUT) :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%&
&   je+1)
    REAL(fvprc), INTENT(INOUT) :: pe_ad(bd%is-1:bd%ie+1, npz+1, bd%js-1:&
&   bd%je+1)
! pe**kappa
    REAL(fvprc), INTENT(INOUT) :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL(fvprc), INTENT(INOUT) :: pk_ad(bd%is:bd%ie, bd%js:bd%je, npz+1)
! ln(pe)
    REAL(fvprc), INTENT(INOUT) :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL(fvprc), INTENT(INOUT) :: peln_ad(bd%is:bd%ie, npz+1, bd%js:bd%&
&   je)
! finite-volume mean pk
    REAL(fvprc), INTENT(INOUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
    REAL(fvprc), INTENT(INOUT) :: pkz_ad(bd%is:bd%ie, bd%js:bd%je, npz)
!real(FVPRC), intent(inout):: q_con(bd%isd:, bd%jsd:, 1:)
!bma replaced previous line
    REAL(fvprc), INTENT(INOUT) :: q_con(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
!-----------------------------------------------------------------------
! Others:
!-----------------------------------------------------------------------
! Surface geopotential (g*Z_surf)
    REAL(fvprc), INTENT(INOUT) :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
! Vertical pressure velocity (pa/s)
    REAL(fvprc), INTENT(INOUT) :: omga(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: omga_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
! (uc,vc) mostly used as the C grid winds
    REAL(fvprc), INTENT(INOUT) :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: uc_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: vc_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: ua_ad, va_ad
    REAL(fvprc), DIMENSION(npz+1), INTENT(IN) :: ak, bk
! Accumulated Mass flux arrays: the "Flux Capacitor"
    REAL(fvprc), INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL(fvprc), INTENT(INOUT) :: mfx_ad(bd%is:bd%ie+1, bd%js:bd%je, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
    REAL(fvprc), INTENT(INOUT) :: mfy_ad(bd%is:bd%ie, bd%js:bd%je+1, npz&
&   )
! Accumulated Courant number arrays
    REAL(fvprc), INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: cx_ad(bd%is:bd%ie+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc), INTENT(INOUT) :: cy_ad(bd%isd:bd%ied, bd%js:bd%je+1, &
&   npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(INOUT) :: flagstruct
    TYPE(FV_NEST_TYPE), INTENT(INOUT) :: neststruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    TYPE(FV_ATMOS_TYPE), INTENT(INOUT) :: parent_grid
    TYPE(FV_DIAG_TYPE), INTENT(IN) :: idiag
    CALL FV_DYNAMICS_FWD(npx, npy, npz, nq_tot, ng, bdt, consv_te, fill&
&                  , reproduce_sum, kappa, cp_air, zvir, ptop, ks, ncnst&
&                  , n_split, q_split, u, v, w, delz, hydrostatic, pt, &
&                  delp, q, ps, pe, pk, peln, pkz, phis, q_con, omga, ua&
&                  , va, uc, vc, ak, bk, mfx, mfy, cx, cy, ze0, hybrid_z&
&                  , gridstruct, flagstruct, neststruct, idiag, bd, &
&                  parent_grid, domain, time_total)
    CALL FV_DYNAMICS_BWD(npx, npy, npz, nq_tot, ng, bdt, consv_te, fill&
&                  , reproduce_sum, kappa, cp_air, zvir, ptop, ks, ncnst&
&                  , n_split, q_split, u, u_ad, v, v_ad, w, w_ad, delz, &
&                  delz_ad, hydrostatic, pt, pt_ad, delp, delp_ad, q, &
&                  q_ad, ps, ps_ad, pe, pe_ad, pk, pk_ad, peln, peln_ad&
&                  , pkz, pkz_ad, phis, q_con, omga, omga_ad, ua, ua_ad&
&                  , va, va_ad, uc, uc_ad, vc, vc_ad, ak, bk, mfx, &
&                  mfx_ad, mfy, mfy_ad, cx, cx_ad, cy, cy_ad, ze0, &
&                  ze0_ad, hybrid_z, gridstruct, flagstruct, neststruct&
&                  , idiag, bd, parent_grid, domain, time_total)
  END SUBROUTINE FV_DYNAMICS_DUMMY_ADM
!-----------------------------------------------------------------------
!     fv_dynamics :: FV dynamical core driver
!-----------------------------------------------------------------------
  SUBROUTINE FV_DYNAMICS_DUMMY(npx, npy, npz, nq_tot, ng, bdt, consv_te&
&   , fill, reproduce_sum, kappa, cp_air, zvir, ptop, ks, ncnst, n_split&
&   , q_split, u, v, w, delz, hydrostatic, pt, delp, q, ps, pe, pk, peln&
&   , pkz, phis, q_con, omga, ua, va, uc, vc, ak, bk, mfx, mfy, cx, cy, &
&   ze0, hybrid_z, gridstruct, flagstruct, neststruct, idiag, bd, &
&   parent_grid, domain, time_total)
    IMPLICIT NONE
! Large time-step
    REAL(fvprc), INTENT(IN) :: bdt
    REAL(fvprc), INTENT(IN) :: consv_te
    REAL(fvprc), INTENT(IN) :: kappa, cp_air
    REAL(fvprc), INTENT(IN) :: zvir, ptop
    REAL(fvprc), INTENT(IN), OPTIONAL :: time_total
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
! transported tracers
    INTEGER, INTENT(IN) :: nq_tot
    INTEGER, INTENT(IN) :: ng
    INTEGER, INTENT(IN) :: ks
    INTEGER, INTENT(IN) :: ncnst
! small-step horizontal dynamics
    INTEGER, INTENT(IN) :: n_split
! tracer
    INTEGER, INTENT(IN) :: q_split
    LOGICAL, INTENT(IN) :: fill
    LOGICAL, INTENT(IN) :: reproduce_sum
    LOGICAL, INTENT(IN) :: hydrostatic
! Using hybrid_z for remapping
    LOGICAL, INTENT(IN) :: hybrid_z
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! D grid zonal wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz), INTENT(&
&   INOUT) :: u
! D grid meridional wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: v
!real(FVPRC), intent(inout) :: w( bd%isd:,bd%jsd:,1:)  !  W (m/s)
!  W (m/s) ! replaced previous line bma
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! temperature (K)
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! pressure thickness (pascal)
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! specific humidity and constituents
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, &
&   ncnst)
!real(FVPRC), intent(inout) :: delz(bd%isd:,bd%jsd:,1:)   ! delta-height (m); non-hydrostatic only
! replace previous line bma
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! height at edges (m); non-hydrostatic
    REAL(fvprc), INTENT(INOUT) :: ze0(bd%is:bd%ie, bd%js:bd%je, npz+1)
!-----------------------------------------------------------------------
! Auxilliary pressure arrays:    
! The 5 vars below can be re-computed from delp and ptop.
!-----------------------------------------------------------------------
! dyn_aux:
! Surface pressure (pascal)
    REAL(fvprc), INTENT(INOUT) :: ps(bd%isd:bd%ied, bd%jsd:bd%jed)
! edge pressure (pascal)
    REAL(fvprc), INTENT(INOUT) :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%&
&   je+1)
! pe**kappa
    REAL(fvprc), INTENT(INOUT) :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
! ln(pe)
    REAL(fvprc), INTENT(INOUT) :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
! finite-volume mean pk
    REAL(fvprc), INTENT(INOUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
!real(FVPRC), intent(inout):: q_con(bd%isd:, bd%jsd:, 1:)
!bma replaced previous line
    REAL(fvprc), INTENT(INOUT) :: q_con(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
!-----------------------------------------------------------------------
! Others:
!-----------------------------------------------------------------------
! Surface geopotential (g*Z_surf)
    REAL(fvprc), INTENT(INOUT) :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
! Vertical pressure velocity (pa/s)
    REAL(fvprc), INTENT(INOUT) :: omga(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! (uc,vc) mostly used as the C grid winds
    REAL(fvprc), INTENT(INOUT) :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: ua, va
    REAL(fvprc), DIMENSION(npz+1), INTENT(IN) :: ak, bk
! Accumulated Mass flux arrays: the "Flux Capacitor"
    REAL(fvprc), INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL(fvprc), INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
! Accumulated Courant number arrays
    REAL(fvprc), INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(INOUT) :: flagstruct
    TYPE(FV_NEST_TYPE), INTENT(INOUT) :: neststruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    TYPE(FV_ATMOS_TYPE), INTENT(INOUT) :: parent_grid
    TYPE(FV_DIAG_TYPE), INTENT(IN) :: idiag
    CALL FV_DYNAMICS(npx, npy, npz, nq_tot, ng, bdt, consv_te, fill, &
&              reproduce_sum, kappa, cp_air, zvir, ptop, ks, ncnst, &
&              n_split, q_split, u, v, w, delz, hydrostatic, pt, delp, q&
&              , ps, pe, pk, peln, pkz, phis, q_con, omga, ua, va, uc, &
&              vc, ak, bk, mfx, mfy, cx, cy, ze0, hybrid_z, gridstruct, &
&              flagstruct, neststruct, idiag, bd, parent_grid, domain, &
&              time_total)
  END SUBROUTINE FV_DYNAMICS_DUMMY
!  Differentiation of fv_dynamics in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_
!mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe
!_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_cor
!e_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.
!rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed
!_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_en
!ergy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_map
!z_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz
! fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_sol
!ver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_c
!ore_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergen
!ce_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core
!_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core
!_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_cor
!e_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: q u v w delp delz pt
!   with respect to varying inputs: q u v w delp delz pt
  SUBROUTINE FV_DYNAMICS_FWD(npx, npy, npz, nq_tot, ng, bdt, consv_te, &
&   fill, reproduce_sum, kappa, cp_air, zvir, ptop, ks, ncnst, n_split, &
&   q_split, u, v, w, delz, hydrostatic, pt, delp, q, ps, pe, pk, peln, &
&   pkz, phis, q_con, omga, ua, va, uc, vc, ak, bk, mfx, mfy, cx, cy, &
&   ze0, hybrid_z, gridstruct, flagstruct, neststruct, idiag, bd, &
&   parent_grid, domain, time_total)
    IMPLICIT NONE
!#ifdef MAPL_MODE
!  t2 = MPI_Wtime(status)
!  dyn_timer = dyn_timer + (t2-t1)
!#endif
! Large time-step
    REAL(fvprc), INTENT(IN) :: bdt
    REAL(fvprc), INTENT(IN) :: consv_te
    REAL(fvprc), INTENT(IN) :: kappa, cp_air
    REAL(fvprc), INTENT(IN) :: zvir, ptop
    REAL(fvprc), INTENT(IN), OPTIONAL :: time_total
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
! transported tracers
    INTEGER, INTENT(IN) :: nq_tot
    INTEGER, INTENT(IN) :: ng
    INTEGER, INTENT(IN) :: ks
    INTEGER, INTENT(IN) :: ncnst
! small-step horizontal dynamics
    INTEGER, INTENT(IN) :: n_split
! tracer
    INTEGER, INTENT(IN) :: q_split
    LOGICAL, INTENT(IN) :: fill
    LOGICAL, INTENT(IN) :: reproduce_sum
    LOGICAL, INTENT(IN) :: hydrostatic
! Using hybrid_z for remapping
    LOGICAL, INTENT(IN) :: hybrid_z
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! D grid zonal wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz), INTENT(&
&   INOUT) :: u
! D grid meridional wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: v
!real(FVPRC), intent(inout) :: w( bd%isd:,bd%jsd:,1:)  !  W (m/s)
!  W (m/s) ! replaced previous line bma
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! temperature (K)
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! pressure thickness (pascal)
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! specific humidity and constituents
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, &
&   ncnst)
!real(FVPRC), intent(inout) :: delz(bd%isd:,bd%jsd:,1:)   ! delta-height (m); non-hydrostatic only
! replace previous line bma
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! height at edges (m); non-hydrostatic
    REAL(fvprc), INTENT(INOUT) :: ze0(bd%is:bd%ie, bd%js:bd%je, npz+1)
!-----------------------------------------------------------------------
! Auxilliary pressure arrays:    
! The 5 vars below can be re-computed from delp and ptop.
!-----------------------------------------------------------------------
! dyn_aux:
! Surface pressure (pascal)
    REAL(fvprc), INTENT(INOUT) :: ps(bd%isd:bd%ied, bd%jsd:bd%jed)
! edge pressure (pascal)
    REAL(fvprc), INTENT(INOUT) :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%&
&   je+1)
! pe**kappa
    REAL(fvprc), INTENT(INOUT) :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
! ln(pe)
    REAL(fvprc), INTENT(INOUT) :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
! finite-volume mean pk
    REAL(fvprc), INTENT(INOUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
!real(FVPRC), intent(inout):: q_con(bd%isd:, bd%jsd:, 1:)
!bma replaced previous line
    REAL(fvprc), INTENT(INOUT) :: q_con(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
!-----------------------------------------------------------------------
! Others:
!-----------------------------------------------------------------------
! Surface geopotential (g*Z_surf)
    REAL(fvprc), INTENT(INOUT) :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
! Vertical pressure velocity (pa/s)
    REAL(fvprc), INTENT(INOUT) :: omga(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! (uc,vc) mostly used as the C grid winds
    REAL(fvprc), INTENT(INOUT) :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: ua, va
    REAL(fvprc), DIMENSION(npz+1), INTENT(IN) :: ak, bk
! Accumulated Mass flux arrays: the "Flux Capacitor"
    REAL(fvprc), INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL(fvprc), INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
! Accumulated Courant number arrays
    REAL(fvprc), INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(INOUT) :: flagstruct
    TYPE(FV_NEST_TYPE), INTENT(INOUT) :: neststruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    TYPE(FV_ATMOS_TYPE), INTENT(INOUT) :: parent_grid
    TYPE(FV_DIAG_TYPE), INTENT(IN) :: idiag
! heat capacity of water at 0C
    REAL(fvprc), PARAMETER :: c_liq=4190.
! heat capacity of ice at 0C: c=c_ice+7.3*(T-Tice) 
    REAL(fvprc), PARAMETER :: c_ice=2106.
! 1384.5
    REAL(fvprc), PARAMETER :: cv_vap=cp_vapor-rvgas
! Local Arrays
    REAL(fvprc) :: ws(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: te_2d(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: teq(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: ps2(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: m_fac(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: pfull(npz)
!real(FVPRC):: gz(bd%is:bd%ie)
    REAL(fvprc) :: dp1(bd%is:bd%ie, bd%js:bd%je, npz), dtdt_m(bd%is:bd%&
&   ie, bd%js:bd%je, npz), cappa(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
    REAL(fvprc) :: akap, rg, rdg, ph1, ph2, mdt, gam, amdt, u0
    INTEGER :: i, j, k, n, iq, n_map, nq, nwat, k_split
! GFDL physics
    INTEGER :: sphum, liq_wat, ice_wat
    INTEGER :: rainwat, snowwat, graupel, cld_amt
    LOGICAL :: used, last_step, consv_am, do_omega
    INTEGER, PARAMETER :: max_packs=24
    TYPE(GROUP_HALO_UPDATE_TYPE), SAVE :: i_pack(max_packs)
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    REAL(fvprc) :: rcv, dt2, consv_fac, q_liq, q_sol, cvm
    REAL(fvprc) :: cv_air
    REAL(kind=8) :: t1, t2
    INTEGER :: status
    REAL(fvprc) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: pkc(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: ptc(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: crx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: xfx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: cry(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc) :: yfx(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc) :: divgd(bd%isd:bd%ied+1, bd%jsd:bd%jed+1, npz)
    REAL(fvprc) :: delpc(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: ut(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: vt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: zh(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: pk3(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: du(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc) :: dv(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    INTEGER :: hord_tr, hord_tr_pert
    INTEGER :: kord_mt, kord_wz, kord_tr(ncnst), kord_tm
    INTEGER :: kord_mt_pert, kord_wz_pert, kord_tr_pert(ncnst), &
&   kord_tm_pert
    INTRINSIC LOG
    INTRINSIC EXP
    INTRINSIC ABS
    INTRINSIC REAL
    INTRINSIC ANY
    INTRINSIC COS
    REAL(fvprc) :: abs0
    REAL(fvprc) :: abs1
    LOGICAL :: arg1
    REAL(kind=r_grid) :: arg10
    REAL(fvprc) :: result1
    gz = 0.0
    pkc = 0.0
    ptc = 0.0
    crx = 0.0
    xfx = 0.0
    cry = 0.0
    yfx = 0.0
    divgd = 0.0
    delpc = 0.0
    ut = 0.0
    vt = 0.0
    zh = 0.0
    pk3 = 0.0
    du = 0.0
    dv = 0.0
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
!Compute the FV variables internally, for checkpointing purposes
    IF (hydrostatic .AND. (.NOT.idealtest)) THEN
      CALL GEOS_TO_FV3_FWD(bd, npz, kappa, ptop, delp, pe, pk, pkz, peln&
&                    , pt)
      CALL PUSHCONTROL1B_FV(0)
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
!      dyn_timer = 0
!      comm_timer = 0
    agrav = 1./grav
    dt2 = 0.5*bdt
    consv_am = flagstruct%consv_am
    k_split = flagstruct%k_split
    nwat = flagstruct%nwat
    nq = nq_tot - flagstruct%dnats
    IF (flagstruct%no_dycore) THEN
      CALL PUSHCONTROL2B_FV(0)
    ELSE
!#ifdef MAPL_MODE
!! Begin Dynamics timer for GEOS history processing
!      t1 = MPI_Wtime(status)
!#endif
!allocate ( dp1(is:ie, js:je, 1:npz) )
!#ifdef MOIST_CAPPA
!      allocate ( cappa(isd:ied,jsd:jed,npz) )
!#else
!      allocate ( cappa(isd:isd,jsd:jsd,1) )
!#endif
!#ifdef SW_DYNAMICS
!      akap  = 1.
!      pfull(1) = 0.5*flagstruct%p_ref
!#ifdef TEST_TRACER
!      sphum = get_tracer_index (MODEL_ATMOS, 'sphum')
!#endif
!#else
      IF (nwat .GE. 3) THEN
        sphum = GET_TRACER_INDEX(model_atmos, 'sphum')
        cld_amt = GET_TRACER_INDEX(model_atmos, 'cld_amt')
      END IF
      IF (nwat .NE. 6) THEN
        sphum = 1
! to cause trouble if (mis)used
        cld_amt = -1
      END IF
      akap = kappa
      rg = kappa*cp_air
      rcv = 1./(cp_air-rg)
!$OMP parallel do default(none) shared(npz,ak,bk,flagstruct,pfull) &
!$OMP                          private(ph1, ph2)
      DO k=1,npz
        ph1 = ak(k) + bk(k)*flagstruct%p_ref
        ph2 = ak(k+1) + bk(k+1)*flagstruct%p_ref
        pfull(k) = (ph2-ph1)/LOG(ph2/ph1)
      END DO
      IF (hydrostatic) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,dp1,zvir,q,q_con,sphum,liq_wat, &
!$OMP                                  rainwat,ice_wat,snowwat,graupel )
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              dp1(i, j, k) = zvir*q(i, j, k, sphum)
            END DO
          END DO
        END DO
        CALL PUSHCONTROL1B_FV(0)
      ELSE
!#ifdef USE_COND
!!#ifdef USE_NWAT3
!!               q_con(i,j,k) = q(i,j,k,liq_wat) + q(i,j,k,ice_wat)
!!#else
!               q_con(i,j,k) = q(i,j,k,liq_wat) + q(i,j,k,rainwat) + q(i,j,k,ice_wat)  &
!                            + q(i,j,k,snowwat) + q(i,j,k,graupel)
!!#endif
!#endif
        rdg = -(rdgas*agrav)
        CALL PUSHREALARRAY(q, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                     *npz*ncnst/8)
        CALL PUSHREALARRAY(delp, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd&
&                     +1)*npz/8)
        CALL PUSHREALARRAY(delz, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd&
&                     +1)*npz/8)
        CALL PUSHREALARRAY(pkz, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)*&
&                     npz/8)
        CALL PUSHINTEGER(js)
        CALL PUSHINTEGER(ie)
        CALL PUSHREALARRAY(rdg)
        CALL PUSHINTEGER(is)
        CALL PUSHINTEGER(je)
        CALL PUSHINTEGER(sphum)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,dp1,zvir,q,q_con,sphum,liq_wat, &
!$OMP                                  rainwat,ice_wat,snowwat,graupel,pkz,cv_air,     & 
!$OMP                                  cappa,kappa,rdg,delp,pt,delz)                         &
!$OMP                          private(cvm, q_liq, q_sol)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              dp1(i, j, k) = zvir*q(i, j, k, sphum)
!#ifdef USE_COND
!!#ifdef USE_NWAT3
!!               q_liq = q(i,j,k,liq_wat)
!!               q_sol = q(i,j,k,ice_wat)
!!#else
!               q_liq = q(i,j,k,liq_wat) + q(i,j,k,rainwat)
!               q_sol = q(i,j,k,ice_wat) + q(i,j,k,snowwat) + q(i,j,k,graupel)
!!#endif
!               q_con(i,j,k) = q_liq + q_Sol
!!#ifdef MOIST_CAPPA
!!!-------Simplified form ---------------------------------------------------------------------------------------
!!!              cappa(i,j,k) = rdgas/(rdgas+((1.-q(i,j,k,sphum)-q_con(i,j,k))*cv_air + q(i,j,k,sphum)*cv_vap + &
!!!                                               q_liq*c_liq + q_sol*c_ice )/(1.+dp1(i,j,k)))
!!!-------Simplified form ---------------------------------------------------------------------------------------
!!               cvm = (1.-(q(i,j,k,sphum)+q_Con(i,j,k)))*cv_air+q(i,j,k,sphum)*cv_vap+q_liq*c_liq+q_sol*c_ice
!!               cappa(i,j,k) = rdgas/(rdgas + cvm*(1.-q_con(i,j,k))/(1.+zvir*q(i,j,k,sphum)-q_con(i,j,k)))
!!               pkz(i,j,k) = exp(cappa(i,j,k)*log(rdg*delp(i,j,k)*pt(i,j,k)*    &
!!                            (1.+dp1(i,j,k)-q_con(i,j,k))/delz(i,j,k)) )
!!#else
!               pkz(i,j,k) = exp( kappa*log(rdg*delp(i,j,k)*pt(i,j,k)*    &
!                            (1.+dp1(i,j,k)-q_con(i,j,k))/delz(i,j,k)) )
!!#endif
!
!#else
              pkz(i, j, k) = EXP(kappa*LOG(rdg*delp(i, j, k)*pt(i, j, k)&
&               *(1.+dp1(i, j, k))/delz(i, j, k)))
            END DO
          END DO
        END DO
        CALL PUSHCONTROL1B_FV(1)
      END IF
!#endif
!      if ( flagstruct%fv_debug ) then
!!#ifdef MOIST_CAPPA
!!         call prt_mxm('cappa', cappa, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!!#endif
!         call prt_mxm('PS',        ps, is, ie, js, je, ng,   1, 0.01_FVPRC, gridstruct%area_64, domain)
!         call prt_mxm('T_dyn_b',   pt, is, ie, js, je, ng, npz, 1._FVPRC,   gridstruct%area_64, domain)
!         call prt_mxm('delz',    delz, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!         call prt_mxm('delp_b ', delp, is, ie, js, je, ng, npz, 0.01_FVPRC, gridstruct%area_64, domain)
!         call prt_mxm('pk_b',    pk, is, ie, js, je, 0, npz+1, 1._FVPRC,gridstruct%area_64, domain)
!         call prt_mxm('pkz_b',   pkz,is, ie, js, je, 0, npz,   1._FVPRC,gridstruct%area_64, domain)
!      endif
!---------------------
! Compute Total Energy
!---------------------
      IF (consv_te .GT. 0. .AND. (.NOT.do_adiabatic_init)) THEN
        CALL COMPUTE_TOTAL_ENERGY_FWD(is, ie, js, je, isd, ied, jsd, jed&
&                               , npz, u, v, w, delz, pt, delp, q, dp1, &
&                               pe, peln, phis, gridstruct%rsin2, &
&                               gridstruct%cosa_s, zvir, cp_air, rg, hlv&
&                               , te_2d, ua, va, teq, flagstruct%&
&                               moist_phys, sphum, liq_wat, rainwat, &
&                               ice_wat, snowwat, graupel, hydrostatic, &
&                               idiag%id_te)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
!used = send_data(idiag%id_te, teq, fv_time)
!              te_den=1.E-9*g_sum(teq, is, ie, js, je, ng, area, 0)/(grav*4.*pi*radius**2)
!              if(is_master())  write(*,*) 'Total Energy Density (Giga J/m**2)=',te_den
      IF ((consv_am .OR. idiag%id_amdt .GT. 0) .AND. (.NOT.&
&         do_adiabatic_init)) THEN
        CALL COMPUTE_AAM_FWD(npz, is, ie, js, je, isd, ied, jsd, jed, &
&                      gridstruct, bd, ptop, ua, va, u, v, delp, teq, &
&                      ps2, m_fac)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (flagstruct%tau .GT. 0.) THEN
        IF (gridstruct%grid_type .LT. 4) THEN
          IF (bdt .GE. 0.) THEN
            abs0 = bdt
          ELSE
            abs0 = -bdt
          END IF
          CALL RAYLEIGH_SUPER_FWD(abs0, npx, npy, npz, ks, pfull, phis, &
&                           flagstruct%tau, u, v, w, pt, ua, va, delz, &
&                           gridstruct%agrid, cp_air, rg, ptop, &
&                           hydrostatic, .true., flagstruct%rf_cutoff, &
&                           gridstruct, domain, bd)
          CALL PUSHCONTROL2B_FV(0)
        ELSE
          IF (bdt .GE. 0.) THEN
            abs1 = bdt
          ELSE
            abs1 = -bdt
          END IF
          CALL RAYLEIGH_FRICTION_FWD(abs1, npx, npy, npz, ks, pfull, &
&                              flagstruct%tau, u, v, w, pt, ua, va, delz&
&                              , cp_air, rg, ptop, hydrostatic, .true., &
&                              flagstruct%rf_cutoff, gridstruct, domain&
&                              , bd)
          CALL PUSHCONTROL2B_FV(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B_FV(2)
      END IF
!#endif
!We call this BEFORE converting pt to virtual potential temperature, 
!since we interpolate on (regular) temperature rather than theta.
!      if (gridstruct%nested .or. ANY(neststruct%child_grids)) then
!                                           if (fv_timing_onoff) call timing_on('NEST_BCs')
!         call setup_nested_grid_BCs(npx, npy, npz, cp_air, zvir, ncnst, sphum,     &
!              u, v, w, pt, delp, delz, q, uc, vc, pkz, &
!              neststruct%nested, flagstruct%inline_q, flagstruct%make_nh, ng, &
!              gridstruct, flagstruct, neststruct, &
!              neststruct%nest_timestep, neststruct%tracer_nest_timestep, domain, bd)
!                                           if (fv_timing_onoff) call timing_off('NEST_BCs')
!      endif
!#ifndef SW_DYNAMICS
! Convert pt to virtual potential temperature * CP
      IF (hydrostatic) THEN
        CALL PUSHREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                     )*npz/8)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pt,cp_air,dp1,pkz)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              pt(i, j, k) = cp_air*pt(i, j, k)*(1.+dp1(i, j, k))/pkz(i, &
&               j, k)
            END DO
          END DO
        END DO
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                     )*npz/8)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pt,cp_air,dp1,pkz,q_con)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
!#ifdef USE_COND
!           pt(i,j,k) = cp_air*pt(i,j,k)*(1.+dp1(i,j,k)-q_con(i,j,k))/pkz(i,j,k)
!#else
              pt(i, j, k) = cp_air*pt(i, j, k)*(1.+dp1(i, j, k))/pkz(i, &
&               j, k)
            END DO
          END DO
        END DO
        CALL PUSHCONTROL1B_FV(1)
      END IF
!#endif
!#endif
      last_step = .false.
      mdt = bdt/REAL(k_split)
!if (fv_timing_onoff) call timing_on('  FV_DYN_LOOP')
! first level of time-split
      DO n_map=1,k_split
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
!#ifdef USE_COND
!      call start_group_halo_update(i_pack(11), i_pack(11+12), q_con, domain)
!!#ifdef MOIST_CAPPA
!!      call start_group_halo_update(i_pack(12), i_pack(12+12), cappa, domain)
!!#endif
!#endif
        CALL PUSHREALARRAY(delp, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd&
&                     +1)*npz/8)
        CALL START_GROUP_HALO_UPDATE(i_pack(1), i_pack(1+12), delp, &
&                              domain)
        CALL PUSHREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                     )*npz/8)
        CALL START_GROUP_HALO_UPDATE(i_pack(2), i_pack(2+12), pt, domain&
&                             )
!#ifndef ROT3
        CALL PUSHREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)&
&                     *npz/8)
        CALL PUSHREALARRAY(u, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)&
&                     *npz/8)
        CALL START_GROUP_HALO_UPDATE(i_pack(8), i_pack(8+12), u, v, &
&                              domain, gridtype=dgrid_ne)
        CALL PUSHREALARRAY(dp1, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)*&
&                     npz/8)
!#endif
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!$OMP parallel do default(none) shared(is,ie,js,je,npz,dp1,delp)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              dp1(i, j, k) = delp(i, j, k)
            END DO
          END DO
        END DO
        IF (n_map .EQ. k_split) last_step = .true.
        arg1 = n_map .EQ. 1
        CALL DYN_CORE_FWD(npx, npy, npz, ng, sphum, nq, mdt, n_split, &
&                   zvir, cp_air, akap, cappa, grav, hydrostatic, u, v, &
&                   w, delz, pt, q, delp, pe, pk, phis, ws, omga, ptop, &
&                   pfull, ua, va, uc, vc, mfx, mfy, cx, cy, pkz, peln, &
&                   q_con, ak, bk, ks, gridstruct, flagstruct, &
&                   neststruct, idiag, bd, domain, arg1, i_pack, &
&                   last_step, gz, pkc, ptc, crx, xfx, cry, yfx, divgd, &
&                   delpc, ut, vt, zh, pk3, du, dv, time_total)
!  if ( flagstruct%fv_debug ) then
!       call prt_mxm('delp_a1',  delp, is, ie, js, je, ng, npz, 0.01_FVPRC, gridstruct%area_64, domain)
!       call prt_mxm('PT_dyn_a1',  pt, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!       call prt_mxm('pk_a1',   pk, is, ie, js, je, 0, npz+1, 1._FVPRC, gridstruct%area_64, domain)
!  endif
!#ifdef SW_DYNAMICS
!!$OMP parallel do default(none) shared(is,ie,js,je,delp,agrav)
!      do j=js,je
!         do i=is,ie
!            ps(i,j) = delp(i,j,1) * agrav
!         enddo
!      enddo
!#else
        IF (.NOT.flagstruct%inline_q .AND. nq .NE. 0) THEN
          hord_tr = flagstruct%hord_tr
          hord_tr_pert = flagstruct%hord_tr_pert
          IF (last_step) hord_tr = hord_tr_pert
!!! CLEANUP: merge these two calls?
          IF (gridstruct%nested .OR. ANY(neststruct%child_grids)) THEN
            CALL TRACER_2D_NESTED_FWD(q, dp1, mfx, mfy, cx, cy, &
&                               gridstruct, bd, domain, npx, npy, npz, &
&                               nq, hord_tr, hord_tr_pert, q_split, mdt&
&                               , idiag%id_divg, i_pack(10), i_pack(10+&
&                               12), flagstruct%z_tracer, k_split, &
&                               neststruct, parent_grid)
            CALL PUSHCONTROL2B_FV(1)
          ELSE
            CALL TRACER_2D_FWD(q, dp1, mfx, mfy, cx, cy, gridstruct, bd&
&                        , domain, npx, npy, npz, 1, nq, hord_tr, &
&                        hord_tr_pert, q_split, mdt, idiag%id_divg, &
&                        i_pack(10), i_pack(10+12), flagstruct%z_tracer&
&                        , k_split)
            CALL PUSHCONTROL2B_FV(2)
          END IF
        ELSE
          CALL PUSHCONTROL2B_FV(0)
        END IF
!used = send_data(idiag%id_divg, dp1, fv_time) 
!             if(flagstruct%fv_debug) call prt_mxm('divg',  dp1, is, ie, js, je, 0, npz, 1._FVPRC,gridstruct%area_64, domain)
        IF (npz .GT. 4) THEN
!------------------------------------------------------------------------
! Peroform vertical remapping from Lagrangian control-volume to
! the Eulerian coordinate as specified by the routine set_eta.
! Note that this finite-volume dycore is otherwise independent of the vertical
! Eulerian coordinate.
!------------------------------------------------------------------------
          DO iq=1,nq
            kord_tr(iq) = flagstruct%kord_tr
            CALL PUSHINTEGER(kord_tr_pert(iq))
            kord_tr_pert(iq) = flagstruct%kord_tr_pert
! monotonic
            IF (iq .EQ. cld_amt) kord_tr(iq) = 9
            IF (iq .EQ. cld_amt) THEN
              CALL PUSHCONTROL1B_FV(1)
              kord_tr_pert(iq) = 111
            ELSE
              CALL PUSHCONTROL1B_FV(0)
            END IF
          END DO
          kord_mt = flagstruct%kord_mt
          kord_wz = flagstruct%kord_wz
          kord_tm = flagstruct%kord_tm
          kord_mt_pert = flagstruct%kord_mt_pert
          kord_wz_pert = flagstruct%kord_wz_pert
          kord_tm_pert = flagstruct%kord_tm_pert
          IF ((kord_tm .LT. 0 .AND. kord_tm_pert .GE. 0) .OR. (kord_tm &
&             .GE. 0 .AND. kord_tm_pert .LT. 0)) kord_tm = kord_tm_pert
!This would result in different anticipated paths through the code
          IF (last_step) THEN
!Does not matter how trajectory is remapped as it is about to be overwritten
            kord_mt = kord_mt_pert
            kord_wz = kord_wz_pert
            kord_tr = kord_tr_pert
            kord_tm = kord_tm_pert
          END IF
          do_omega = hydrostatic .AND. last_step
          CALL LAGRANGIAN_TO_EULERIAN_FWD(last_step, consv_te, ps, pe, &
&                                   delp, pkz, pk, mdt, bdt, npz, is, ie&
&                                   , js, je, isd, ied, jsd, jed, nq, &
&                                   nwat, sphum, q_con, u, v, w, delz, &
&                                   pt, q, phis, zvir, cp_air, akap, &
&                                   cappa, kord_mt, kord_wz, kord_tr, &
&                                   kord_tm, kord_mt_pert, kord_wz_pert&
&                                   , kord_tr_pert, kord_tm_pert, peln, &
&                                   te_2d, ng, ua, va, omga, dp1, ws, &
&                                   fill, reproduce_sum, arg1, dtdt_m, &
&                                   ptop, ak, bk, gridstruct, domain, &
&                                   ze0, flagstruct%gmao_cubic, &
&                                   flagstruct%remap_t, flagstruct%&
&                                   do_sat_adj, hydrostatic, hybrid_z, &
&                                   do_omega, do_adiabatic_init)
          IF (last_step) THEN
            IF (hydrostatic) THEN
!--------------------------
! Filter omega for physics:
!--------------------------
              IF (flagstruct%nf_omega .GT. 0) THEN
                arg10 = 0.20*gridstruct%da_min
                CALL DEL2_CUBED_FWD(omga, arg10, gridstruct, domain, npx&
&                             , npy, npz, flagstruct%nf_omega, bd)
                CALL PUSHCONTROL2B_FV(0)
              ELSE
                CALL PUSHCONTROL2B_FV(1)
              END IF
            ELSE
              CALL PUSHREALARRAY(omga, 8*(bd%ied-bd%isd+1)*(bd%jed-&
&                           bd%jsd+1)*npz/8)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,omga,delp,delz,w)
              DO k=1,npz
                DO j=js,je
                  DO i=is,ie
                    omga(i, j, k) = delp(i, j, k)/delz(i, j, k)*w(i, j, &
&                     k)
                  END DO
                END DO
              END DO
              CALL PUSHCONTROL2B_FV(2)
            END IF
! Convert back to temperature
            IF (.NOT.flagstruct%remap_t) THEN
              IF (hydrostatic) THEN
                CALL PUSHREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-&
&                             bd%jsd+1)*npz/8)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pt,pkz,cp_air,zvir,q,sphum)
                DO k=1,npz
                  DO j=js,je
                    DO i=is,ie
                      pt(i, j, k) = pt(i, j, k)*pkz(i, j, k)/(cp_air*(1.&
&                       +zvir*q(i, j, k, sphum)))
                    END DO
                  END DO
                END DO
                CALL PUSHCONTROL3B_FV(4)
              ELSE
                CALL PUSHREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-&
&                             bd%jsd+1)*npz/8)
!$OMP parallel do default(none)  shared(is,ie,js,je,npz,pt,pkz,cp_air,zvir,q,sphum,q_con)
                DO k=1,npz
                  DO j=js,je
                    DO i=is,ie
!#ifdef USE_COND
!                     pt(i,j,k) = pt(i,j,k)*pkz(i,j,k)/(cp_air*(1.+zvir*q(i,j,k,sphum)-q_con(i,j,k)))
!#else
                      pt(i, j, k) = pt(i, j, k)*pkz(i, j, k)/(cp_air*(1.&
&                       +zvir*q(i, j, k, sphum)))
                    END DO
                  END DO
                END DO
                CALL PUSHCONTROL3B_FV(3)
              END IF
            ELSE
              CALL PUSHCONTROL3B_FV(2)
            END IF
          ELSE
            CALL PUSHCONTROL3B_FV(1)
          END IF
        ELSE
          CALL PUSHCONTROL3B_FV(0)
        END IF
      END DO
!used = send_data(idiag%id_mdt, dtdt_m, fv_time)
!deallocate ( dtdt_m )
!  if( nwat==6 ) then
!      call neg_adj3(is, ie, js, je, ng, npz,        &
!                    flagstruct%hydrostatic,         &
!                    peln, delz,                     &
!                    pt, delp, q(isd,jsd,1,sphum),   &
!                              q(isd,jsd,1,liq_wat), &
!                              q(isd,jsd,1,rainwat), &
!                              q(isd,jsd,1,ice_wat), &
!                              q(isd,jsd,1,snowwat), &
!                              q(isd,jsd,1,graupel), &
!                              q(isd,jsd,1,cld_amt), flagstruct%check_negative)
!!     if ( flagstruct%fv_debug ) then
!!       call prt_mxm('T_dyn_a3',    pt, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!!       call prt_mxm('SPHUM_dyn',   q(isd,jsd,1,sphum  ), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!       call prt_mxm('liq_wat_dyn', q(isd,jsd,1,liq_wat), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!       call prt_mxm('rainwat_dyn', q(isd,jsd,1,rainwat), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!       call prt_mxm('ice_wat_dyn', q(isd,jsd,1,ice_wat), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!       call prt_mxm('snowwat_dyn', q(isd,jsd,1,snowwat), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!       call prt_mxm('graupel_dyn', q(isd,jsd,1,graupel), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!     endif
!  endif
      IF ((consv_am .OR. idiag%id_amdt .GT. 0) .OR. (idiag%id_aam .GT. 0&
&         .AND. (.NOT.do_adiabatic_init))) THEN
        CALL COMPUTE_AAM_FWD(npz, is, ie, js, je, isd, ied, jsd, jed, &
&                      gridstruct, bd, ptop, ua, va, u, v, delp, te_2d, &
&                      ps, m_fac)
        CALL PUSHCONTROL1B_FV(0)
      ELSE
        CALL PUSHCONTROL1B_FV(1)
      END IF
      IF (consv_am .OR. (idiag%id_amdt .GT. 0 .AND. (.NOT.&
&         do_adiabatic_init))) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,te_2d,teq,dt2,ps2,ps,idiag) 
        DO j=js,je
          DO i=is,ie
! Note: the mountain torque computation contains also numerical error
! The numerical error is mostly from the zonal gradient of the terrain (zxg)
            te_2d(i, j) = te_2d(i, j) - teq(i, j) + dt2*(ps2(i, j)+ps(i&
&             , j))*idiag%zxg(i, j)
          END DO
        END DO
!if( idiag%id_amdt>0 ) used = send_data(idiag%id_amdt, te_2d/bdt, fv_time)
        IF (consv_am .OR. prt_minmax) THEN
          amdt = G_SUM(domain, te_2d, is, ie, js, je, ng, gridstruct%&
&           area_64, 0)
          result1 = G_SUM(domain, m_fac, is, ie, js, je, ng, gridstruct%&
&           area_64, 0)
          u0 = -(radius*amdt/result1)
! truncate to enforce reproducibility
          u0 = REAL(u0, 4)
!if(is_master() .and. prt_minmax)         &
!        write(6,*) 'Dynamic AM tendency =', amdt/(bdt*1.e18), 'del-u (per yr)=', u0*365.*86400./bdt
!         write(6,*) 'Dynamic Angular Momentum tendency (Hadleys)=', amdt/(bdt*1.e18)
          CALL PUSHCONTROL1B_FV(0)
        ELSE
          CALL PUSHCONTROL1B_FV(1)
        END IF
!  consv_am
        IF (consv_am) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,m_fac,u0,gridstruct)
          DO j=js,je
            DO i=is,ie
              CALL PUSHREALARRAY(m_fac(i, j))
              m_fac(i, j) = u0*COS(gridstruct%agrid(i, j, 2))
            END DO
          END DO
!$OMP parallel do default(none) shared(is,ie,js,je,npz,hydrostatic,pt,m_fac,ua,cp_air, &
!$OMP                                  rcv,u,u0,gridstruct,v )
          IF (hydrostatic) THEN
            CALL PUSHREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%&
&                         jsd+1)*npz/8)
            DO k=1,npz
              DO j=js,je
                DO i=is,ie
                  pt(i, j, k) = pt(i, j, k) - m_fac(i, j)*(0.5*m_fac(i, &
&                   j)+ua(i, j, k))/cp_air
                END DO
              END DO
            END DO
            CALL PUSHCONTROL1B_FV(1)
          ELSE
            CALL PUSHREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%&
&                         jsd+1)*npz/8)
            CALL PUSHREALARRAY(rcv)
            DO k=1,npz
              DO j=js,je
                DO i=is,ie
                  pt(i, j, k) = pt(i, j, k) - m_fac(i, j)*(0.5*m_fac(i, &
&                   j)+ua(i, j, k))*rcv
                END DO
              END DO
            END DO
            CALL PUSHCONTROL1B_FV(0)
          END IF
          CALL PUSHCONTROL2B_FV(1)
        ELSE
          CALL PUSHCONTROL2B_FV(2)
        END IF
      ELSE
        CALL PUSHCONTROL2B_FV(3)
      END IF
    END IF
    CALL CUBED_TO_LATLON_FWD(u, v, ua, va, gridstruct, npx, npy, npz, 1&
&                      , gridstruct%grid_type, domain, gridstruct%nested&
&                      , flagstruct%c2l_ord, bd)
!     if ( flagstruct%fv_debug ) then
!       call prt_mxm('UA', ua, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!       call prt_mxm('VA', va, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!       call prt_mxm('TA', pt, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!     endif
!  if ( flagstruct%range_warn ) then
!       call range_check('UA_dyn', ua, is, ie, js, je, ng, npz, gridstruct%agrid,   &
!                         -220._FVPRC, 260._FVPRC, bad_range)
!       call range_check('VA_dyn', ua, is, ie, js, je, ng, npz, gridstruct%agrid,   &
!                         -220._FVPRC, 220._FVPRC, bad_range)
!!#ifndef SW_DYNAMICS
!       call range_check('TA_dyn', pt, is, ie, js, je, ng, npz, gridstruct%agrid,   &
!                         160._FVPRC, 330._FVPRC, bad_range)
!       if ( .not. hydrostatic ) &
!       call range_check('W_dyn', w, is, ie, js, je, ng, npz, gridstruct%agrid,   &
!                         -20._FVPRC, 20._FVPRC, bad_range)
!!#endif
!
!  endif
!deallocate ( dp1 )
!deallocate ( cappa )
!Convert back to potential temperature
    IF (hydrostatic .AND. (.NOT.idealtest)) THEN
      CALL PUSHREALARRAY(pk3, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                   *(npz+1)/8)
      CALL PUSHREALARRAY(xfx, 8*(bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*&
&                   npz/8)
      CALL PUSHREALARRAY(ws, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8)
      CALL PUSHREALARRAY(gz, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                   (npz+1)/8)
      CALL PUSHREALARRAY(dp1, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)*npz&
&                   /8)
      CALL PUSHREALARRAY(ptc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                   *npz/8)
      CALL PUSHREALARRAY(pfull, 8*npz/8)
      CALL PUSHINTEGER(jsd)
      CALL PUSHINTEGER(ied)
      CALL PUSHREALARRAY(rg)
      CALL PUSHINTEGER(kord_tr_pert, ncnst)
      CALL PUSHREALARRAY(rcv)
      CALL PUSHREALARRAY(ut, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                   npz/8)
      CALL PUSHREALARRAY(pkc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                   *(npz+1)/8)
      CALL PUSHREALARRAY(delpc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+&
&                   1)*npz/8)
      CALL PUSHREALARRAY(rdg)
      CALL PUSHREALARRAY(m_fac, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8&
&                  )
      CALL PUSHREALARRAY(yfx, 8*(bd%ied-bd%isd+1)*(bd%je-bd%js+2)*&
&                   npz/8)
      CALL PUSHINTEGER(isd)
      CALL PUSHREALARRAY(te_2d, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8&
&                  )
      CALL PUSHREALARRAY(vt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                   npz/8)
      CALL PUSHREALARRAY(result1)
      CALL PUSHINTEGER(sphum)
      CALL PUSHREALARRAY(amdt)
      CALL PUSHREALARRAY(crx, 8*(bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*&
&                   npz/8)
      CALL PUSHREALARRAY(cry, 8*(bd%ied-bd%isd+1)*(bd%je-bd%js+2)*&
&                   npz/8)
      CALL PUSHINTEGER(jed)
      CALL PUSHCONTROL1B_FV(1)
    ELSE
      CALL PUSHREALARRAY(pk3, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                   *(npz+1)/8)
      CALL PUSHREALARRAY(xfx, 8*(bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*&
&                   npz/8)
      CALL PUSHREALARRAY(ws, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8)
      CALL PUSHREALARRAY(gz, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                   (npz+1)/8)
      CALL PUSHREALARRAY(dp1, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)*npz&
&                   /8)
      CALL PUSHREALARRAY(ptc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                   *npz/8)
      CALL PUSHREALARRAY(pfull, 8*npz/8)
      CALL PUSHINTEGER(jsd)
      CALL PUSHINTEGER(ied)
      CALL PUSHREALARRAY(rg)
      CALL PUSHINTEGER(kord_tr_pert, ncnst)
      CALL PUSHREALARRAY(rcv)
      CALL PUSHREALARRAY(ut, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                   npz/8)
      CALL PUSHREALARRAY(pkc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                   *(npz+1)/8)
      CALL PUSHREALARRAY(delpc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+&
&                   1)*npz/8)
      CALL PUSHREALARRAY(rdg)
      CALL PUSHREALARRAY(m_fac, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8&
&                  )
      CALL PUSHREALARRAY(yfx, 8*(bd%ied-bd%isd+1)*(bd%je-bd%js+2)*&
&                   npz/8)
      CALL PUSHINTEGER(isd)
      CALL PUSHREALARRAY(te_2d, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8&
&                  )
      CALL PUSHREALARRAY(vt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                   npz/8)
      CALL PUSHREALARRAY(result1)
      CALL PUSHINTEGER(sphum)
      CALL PUSHREALARRAY(amdt)
      CALL PUSHREALARRAY(crx, 8*(bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*&
&                   npz/8)
      CALL PUSHREALARRAY(cry, 8*(bd%ied-bd%isd+1)*(bd%je-bd%js+2)*&
&                   npz/8)
      CALL PUSHINTEGER(jed)
      CALL PUSHCONTROL1B_FV(0)
    END IF
  END SUBROUTINE FV_DYNAMICS_FWD
!  Differentiation of fv_dynamics in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge
!_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.p
!e_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_co
!re_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod
!.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cube
!d_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_e
!nergy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_ma
!pz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steep
!z fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_so
!lver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_
!core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.diverge
!nce_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_cor
!e_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_cor
!e_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_co
!re_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: q u v w delp delz pt
!   with respect to varying inputs: q u v w delp delz pt
  SUBROUTINE FV_DYNAMICS_BWD(npx, npy, npz, nq_tot, ng, bdt, consv_te, &
&   fill, reproduce_sum, kappa, cp_air, zvir, ptop, ks, ncnst, n_split, &
&   q_split, u, u_ad, v, v_ad, w, w_ad, delz, delz_ad, hydrostatic, pt, &
&   pt_ad, delp, delp_ad, q, q_ad, ps, ps_ad, pe, pe_ad, pk, pk_ad, peln&
&   , peln_ad, pkz, pkz_ad, phis, q_con, omga, omga_ad, ua, ua_ad, va, &
&   va_ad, uc, uc_ad, vc, vc_ad, ak, bk, mfx, mfx_ad, mfy, mfy_ad, cx, &
&   cx_ad, cy, cy_ad, ze0, ze0_ad, hybrid_z, gridstruct, flagstruct, &
&   neststruct, idiag, bd, parent_grid, domain, time_total)
    IMPLICIT NONE
!#ifdef MAPL_MODE
!  t2 = MPI_Wtime(status)
!  dyn_timer = dyn_timer + (t2-t1)
!#endif
    REAL(fvprc), INTENT(IN) :: bdt
    REAL(fvprc), INTENT(IN) :: consv_te
    REAL(fvprc), INTENT(IN) :: kappa, cp_air
    REAL(fvprc), INTENT(IN) :: zvir, ptop
    REAL(fvprc), INTENT(IN), OPTIONAL :: time_total
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
    INTEGER, INTENT(IN) :: nq_tot
    INTEGER, INTENT(IN) :: ng
    INTEGER, INTENT(IN) :: ks
    INTEGER, INTENT(IN) :: ncnst
    INTEGER, INTENT(IN) :: n_split
    INTEGER, INTENT(IN) :: q_split
    LOGICAL, INTENT(IN) :: fill
    LOGICAL, INTENT(IN) :: reproduce_sum
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: hybrid_z
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz), INTENT(&
&   INOUT) :: u
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz), INTENT(&
&   INOUT) :: u_ad
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: v
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: v_ad
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: w_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: pt_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: delp_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, &
&   ncnst)
    REAL(fvprc), INTENT(INOUT) :: q_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   , ncnst)
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: delz_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: ze0(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL(fvprc), INTENT(INOUT) :: ze0_ad(bd%is:bd%ie, bd%js:bd%je, npz+1&
&   )
    REAL(fvprc), INTENT(INOUT) :: ps(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: ps_ad(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%&
&   je+1)
    REAL(fvprc), INTENT(INOUT) :: pe_ad(bd%is-1:bd%ie+1, npz+1, bd%js-1:&
&   bd%je+1)
    REAL(fvprc), INTENT(INOUT) :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL(fvprc), INTENT(INOUT) :: pk_ad(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL(fvprc), INTENT(INOUT) :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL(fvprc), INTENT(INOUT) :: peln_ad(bd%is:bd%ie, npz+1, bd%js:bd%&
&   je)
    REAL(fvprc), INTENT(INOUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
    REAL(fvprc), INTENT(INOUT) :: pkz_ad(bd%is:bd%ie, bd%js:bd%je, npz)
    REAL(fvprc), INTENT(INOUT) :: q_con(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
    REAL(fvprc), INTENT(INOUT) :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc), INTENT(INOUT) :: omga(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: omga_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: uc_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: vc_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: ua, va
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: ua_ad, va_ad
    REAL(fvprc), DIMENSION(npz+1), INTENT(IN) :: ak, bk
    REAL(fvprc), INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL(fvprc), INTENT(INOUT) :: mfx_ad(bd%is:bd%ie+1, bd%js:bd%je, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
    REAL(fvprc), INTENT(INOUT) :: mfy_ad(bd%is:bd%ie, bd%js:bd%je+1, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: cx_ad(bd%is:bd%ie+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc), INTENT(INOUT) :: cy_ad(bd%isd:bd%ied, bd%js:bd%je+1, &
&   npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(INOUT) :: flagstruct
    TYPE(FV_NEST_TYPE), INTENT(INOUT) :: neststruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    TYPE(FV_ATMOS_TYPE), INTENT(INOUT) :: parent_grid
    TYPE(FV_DIAG_TYPE), INTENT(IN) :: idiag
    REAL(fvprc), PARAMETER :: c_liq=4190.
    REAL(fvprc), PARAMETER :: c_ice=2106.
    REAL(fvprc), PARAMETER :: cv_vap=cp_vapor-rvgas
    REAL(fvprc) :: ws(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: ws_ad(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: te_2d(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: te_2d_ad(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: teq(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: teq_ad(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: ps2(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: ps2_ad(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: m_fac(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: m_fac_ad(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: pfull(npz)
    REAL(fvprc) :: dp1(bd%is:bd%ie, bd%js:bd%je, npz), dtdt_m(bd%is:bd%&
&   ie, bd%js:bd%je, npz), cappa(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
    REAL(fvprc) :: dp1_ad(bd%is:bd%ie, bd%js:bd%je, npz)
    REAL(fvprc) :: akap, rg, rdg, ph1, ph2, mdt, gam, amdt, u0
    REAL(fvprc) :: amdt_ad, u0_ad
    INTEGER :: i, j, k, n, iq, n_map, nq, nwat, k_split
    INTEGER :: sphum, liq_wat, ice_wat
    INTEGER :: rainwat, snowwat, graupel, cld_amt
    LOGICAL :: used, last_step, consv_am, do_omega
    INTEGER, PARAMETER :: max_packs=24
    TYPE(GROUP_HALO_UPDATE_TYPE), SAVE :: i_pack(max_packs)
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    REAL(fvprc) :: rcv, dt2, consv_fac, q_liq, q_sol, cvm
    REAL(fvprc) :: cv_air
    REAL(kind=8) :: t1, t2
    INTEGER :: status
    REAL(fvprc) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: gz_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: pkc(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: pkc_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: ptc(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: ptc_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: crx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: crx_ad(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: xfx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: xfx_ad(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: cry(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc) :: cry_ad(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc) :: yfx(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc) :: yfx_ad(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc) :: divgd(bd%isd:bd%ied+1, bd%jsd:bd%jed+1, npz)
    REAL(fvprc) :: divgd_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed+1, npz)
    REAL(fvprc) :: delpc(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: delpc_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: ut(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: ut_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: vt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: vt_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: zh(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: zh_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: pk3(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: pk3_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: du(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc) :: du_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc) :: dv(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: dv_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    INTEGER :: hord_tr, hord_tr_pert
    INTEGER :: kord_mt, kord_wz, kord_tr(ncnst), kord_tm
    INTEGER :: kord_mt_pert, kord_wz_pert, kord_tr_pert(ncnst), &
&   kord_tm_pert
    INTRINSIC LOG
    INTRINSIC EXP
    INTRINSIC ABS
    INTRINSIC REAL
    INTRINSIC ANY
    INTRINSIC COS
    REAL(fvprc) :: abs0
    REAL(fvprc) :: abs1
    LOGICAL :: arg1
    REAL(kind=r_grid) :: arg10
    REAL(fvprc) :: result1
    REAL(fvprc) :: result1_ad
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp
    REAL(fvprc) :: temp0
    REAL(fvprc) :: temp1
    REAL(fvprc) :: temp2
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp3
    REAL(fvprc) :: temp4
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp5
    REAL(fvprc) :: temp6
    REAL(fvprc) :: temp_ad4
    INTEGER :: branch
    REAL(fvprc) :: temp_ad5
    REAL(fvprc) :: temp7
    REAL(fvprc) :: temp_ad6
    REAL(fvprc) :: temp8
    REAL(fvprc) :: temp_ad7
    REAL(fvprc) :: temp_ad8
    REAL(fvprc) :: temp_ad9
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPINTEGER(jed)
      CALL POPREALARRAY(cry, 8*(bd%ied-bd%isd+1)*(bd%je-bd%js+2)*&
&                  npz/8)
      CALL POPREALARRAY(crx, 8*(bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*&
&                  npz/8)
      CALL POPREALARRAY(amdt)
      CALL POPINTEGER(sphum)
      CALL POPREALARRAY(result1)
      CALL POPREALARRAY(vt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                  npz/8)
      CALL POPREALARRAY(te_2d, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8)
      CALL POPINTEGER(isd)
      CALL POPREALARRAY(yfx, 8*(bd%ied-bd%isd+1)*(bd%je-bd%js+2)*&
&                  npz/8)
      CALL POPREALARRAY(m_fac, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8)
      CALL POPREALARRAY(rdg)
      CALL POPREALARRAY(delpc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                  )*npz/8)
      CALL POPREALARRAY(pkc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                  (npz+1)/8)
      CALL POPREALARRAY(ut, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                  npz/8)
      CALL POPREALARRAY(rcv)
      CALL POPINTEGER(kord_tr_pert, ncnst)
      CALL POPREALARRAY(rg)
      CALL POPINTEGER(ied)
      CALL POPINTEGER(jsd)
      CALL POPREALARRAY(pfull, 8*npz/8)
      CALL POPREALARRAY(ptc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                  npz/8)
      CALL POPREALARRAY(dp1, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)*npz/&
&                  8)
      CALL POPREALARRAY(gz, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*(&
&                  npz+1)/8)
      CALL POPREALARRAY(ws, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8)
      CALL POPREALARRAY(xfx, 8*(bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*&
&                  npz/8)
      CALL POPREALARRAY(pk3, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                  (npz+1)/8)
      pkz_ad = 0.0_FVPRC
    ELSE
      CALL POPINTEGER(jed)
      CALL POPREALARRAY(cry, 8*(bd%ied-bd%isd+1)*(bd%je-bd%js+2)*&
&                  npz/8)
      CALL POPREALARRAY(crx, 8*(bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*&
&                  npz/8)
      CALL POPREALARRAY(amdt)
      CALL POPINTEGER(sphum)
      CALL POPREALARRAY(result1)
      CALL POPREALARRAY(vt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                  npz/8)
      CALL POPREALARRAY(te_2d, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8)
      CALL POPINTEGER(isd)
      CALL POPREALARRAY(yfx, 8*(bd%ied-bd%isd+1)*(bd%je-bd%js+2)*&
&                  npz/8)
      CALL POPREALARRAY(m_fac, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8)
      CALL POPREALARRAY(rdg)
      CALL POPREALARRAY(delpc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1&
&                  )*npz/8)
      CALL POPREALARRAY(pkc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                  (npz+1)/8)
      CALL POPREALARRAY(ut, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                  npz/8)
      CALL POPREALARRAY(rcv)
      CALL POPINTEGER(kord_tr_pert, ncnst)
      CALL POPREALARRAY(rg)
      CALL POPINTEGER(ied)
      CALL POPINTEGER(jsd)
      CALL POPREALARRAY(pfull, 8*npz/8)
      CALL POPREALARRAY(ptc, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                  npz/8)
      CALL POPREALARRAY(dp1, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)*npz/&
&                  8)
      CALL POPREALARRAY(gz, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*(&
&                  npz+1)/8)
      CALL POPREALARRAY(ws, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)/8)
      CALL POPREALARRAY(xfx, 8*(bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*&
&                  npz/8)
      CALL POPREALARRAY(pk3, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                  (npz+1)/8)
      CALL FV3_TO_GEOS_ADM(bd, npz, pkz, pkz_ad, pt, pt_ad)
    END IF
    CALL CUBED_TO_LATLON_BWD(u, u_ad, v, v_ad, ua, va, gridstruct, npx, &
&                      npy, npz, 1, gridstruct%grid_type, domain, &
&                      gridstruct%nested, flagstruct%c2l_ord, bd)
    js = bd%js
    ie = bd%ie
    is = bd%is
    je = bd%je
    CALL POPCONTROL2B_FV(branch)
    IF (branch .LT. 2) THEN
      IF (branch .EQ. 0) THEN
        peln_ad = 0.0_FVPRC
        pe_ad = 0.0_FVPRC
        pk_ad = 0.0_FVPRC
        GOTO 120
      ELSE
        u0_ad = 0.0_FVPRC
        DO k=npz,1,-1
          DO j=je,js,-1
            DO i=ie+1,is,-1
              u0_ad = u0_ad + gridstruct%l2c_v(i, j)*v_ad(i, j, k)
            END DO
          END DO
          DO j=je+1,js,-1
            DO i=ie,is,-1
              u0_ad = u0_ad + gridstruct%l2c_u(i, j)*u_ad(i, j, k)
            END DO
          END DO
        END DO
        CALL POPCONTROL1B_FV(branch)
        IF (branch .EQ. 0) THEN
          ua_ad = 0.0_FVPRC
          m_fac_ad = 0.0_FVPRC
          CALL POPREALARRAY(rcv)
          CALL POPREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+&
&                      1)*npz/8)
          DO k=1,npz
            DO j=je,js,-1
              DO i=ie,is,-1
                temp_ad9 = -(rcv*m_fac(i, j)*pt_ad(i, j, k))
                m_fac_ad(i, j) = m_fac_ad(i, j) + 0.5*temp_ad9 - rcv*(&
&                 0.5*m_fac(i, j)+ua(i, j, k))*pt_ad(i, j, k)
                ua_ad(i, j, k) = ua_ad(i, j, k) + temp_ad9
              END DO
            END DO
          END DO
        ELSE
          ua_ad = 0.0_FVPRC
          m_fac_ad = 0.0_FVPRC
          CALL POPREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+&
&                      1)*npz/8)
          DO k=1,npz
            DO j=je,js,-1
              DO i=ie,is,-1
                temp_ad8 = -(m_fac(i, j)*pt_ad(i, j, k)/cp_air)
                m_fac_ad(i, j) = m_fac_ad(i, j) + 0.5*temp_ad8 - (0.5*&
&                 m_fac(i, j)+ua(i, j, k))*pt_ad(i, j, k)/cp_air
                ua_ad(i, j, k) = ua_ad(i, j, k) + temp_ad8
              END DO
            END DO
          END DO
        END IF
        DO j=je,js,-1
          DO i=ie,is,-1
            CALL POPREALARRAY(m_fac(i, j))
            u0_ad = u0_ad + COS(gridstruct%agrid(i, j, 2))*m_fac_ad(i, j&
&             )
            m_fac_ad(i, j) = 0.0_FVPRC
          END DO
        END DO
      END IF
    ELSE IF (branch .EQ. 2) THEN
      ua_ad = 0.0_FVPRC
      m_fac_ad = 0.0_FVPRC
      u0_ad = 0.0_FVPRC
    ELSE
      ua_ad = 0.0_FVPRC
      ps_ad = 0.0_FVPRC
      teq_ad = 0.0_FVPRC
      ps2_ad = 0.0_FVPRC
      m_fac_ad = 0.0_FVPRC
      te_2d_ad = 0.0_FVPRC
      GOTO 100
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      temp_ad0 = -(radius*u0_ad/result1)
      amdt_ad = temp_ad0
      result1_ad = -(amdt*temp_ad0/result1)
      CALL G_SUM_ADM(domain, m_fac, m_fac_ad, is, ie, js, je, ng, &
&              gridstruct%area_64, 0, g_sum_ad=result1_ad)
      te_2d_ad = 0.0_FVPRC
      CALL G_SUM_ADM(domain, te_2d, te_2d_ad, is, ie, js, je, ng, &
&              gridstruct%area_64, 0, g_sum_ad=amdt_ad)
    ELSE
      te_2d_ad = 0.0_FVPRC
    END IF
    dt2 = 0.5*bdt
    ps_ad = 0.0_FVPRC
    teq_ad = 0.0_FVPRC
    ps2_ad = 0.0_FVPRC
    DO j=je,js,-1
      DO i=ie,is,-1
        temp_ad = dt2*idiag%zxg(i, j)*te_2d_ad(i, j)
        teq_ad(i, j) = teq_ad(i, j) - te_2d_ad(i, j)
        ps2_ad(i, j) = ps2_ad(i, j) + temp_ad
        ps_ad(i, j) = ps_ad(i, j) + temp_ad
      END DO
    END DO
 100 CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      jsd = bd%jsd
      ied = bd%ied
      isd = bd%isd
      jed = bd%jed
      va_ad = 0.0_FVPRC
      CALL COMPUTE_AAM_BWD(npz, is, ie, js, je, isd, ied, jsd, jed, &
&                    gridstruct, bd, ptop, ua, ua_ad, va, va_ad, u, u_ad&
&                    , v, v_ad, delp, delp_ad, te_2d, te_2d_ad, ps, &
&                    ps_ad, m_fac, m_fac_ad)
    END IF
    nq = nq_tot - flagstruct%dnats
    k_split = flagstruct%k_split
    akap = kappa
    peln_ad = 0.0_FVPRC
    ze0_ad = 0.0_FVPRC
    uc_ad = 0.0_FVPRC
    mfx_ad = 0.0_FVPRC
    mfy_ad = 0.0_FVPRC
    omga_ad = 0.0_FVPRC
    va_ad = 0.0_FVPRC
    vc_ad = 0.0_FVPRC
    pe_ad = 0.0_FVPRC
    pk_ad = 0.0_FVPRC
    cx_ad = 0.0_FVPRC
    cy_ad = 0.0_FVPRC
    pk3_ad = 0.0_FVPRC
    xfx_ad = 0.0_FVPRC
    ws_ad = 0.0_FVPRC
    gz_ad = 0.0_FVPRC
    du_ad = 0.0_FVPRC
    dv_ad = 0.0_FVPRC
    dp1_ad = 0.0_FVPRC
    ptc_ad = 0.0_FVPRC
    ut_ad = 0.0_FVPRC
    divgd_ad = 0.0_FVPRC
    pkc_ad = 0.0_FVPRC
    delpc_ad = 0.0_FVPRC
    yfx_ad = 0.0_FVPRC
    vt_ad = 0.0_FVPRC
    zh_ad = 0.0_FVPRC
    crx_ad = 0.0_FVPRC
    cry_ad = 0.0_FVPRC
    DO n_map=k_split,1,-1
      CALL POPCONTROL3B_FV(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) GOTO 110
      ELSE
        IF (branch .NE. 2) THEN
          IF (branch .EQ. 3) THEN
            CALL POPREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%&
&                        jsd+1)*npz/8)
            DO k=1,npz
              DO j=je,js,-1
                DO i=ie,is,-1
                  temp8 = cp_air*(zvir*q(i, j, k, sphum)+1.)
                  temp_ad7 = pt_ad(i, j, k)/temp8
                  pkz_ad(i, j, k) = pkz_ad(i, j, k) + pt(i, j, k)*&
&                   temp_ad7
                  q_ad(i, j, k, sphum) = q_ad(i, j, k, sphum) - cp_air*&
&                   pt(i, j, k)*pkz(i, j, k)*zvir*temp_ad7/temp8
                  pt_ad(i, j, k) = pkz(i, j, k)*temp_ad7
                END DO
              END DO
            END DO
          ELSE
            CALL POPREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%&
&                        jsd+1)*npz/8)
            DO k=1,npz
              DO j=je,js,-1
                DO i=ie,is,-1
                  temp7 = cp_air*(zvir*q(i, j, k, sphum)+1.)
                  temp_ad6 = pt_ad(i, j, k)/temp7
                  pkz_ad(i, j, k) = pkz_ad(i, j, k) + pt(i, j, k)*&
&                   temp_ad6
                  q_ad(i, j, k, sphum) = q_ad(i, j, k, sphum) - cp_air*&
&                   pt(i, j, k)*pkz(i, j, k)*zvir*temp_ad6/temp7
                  pt_ad(i, j, k) = pkz(i, j, k)*temp_ad6
                END DO
              END DO
            END DO
          END IF
        END IF
        CALL POPCONTROL2B_FV(branch)
        IF (branch .EQ. 0) THEN
          arg10 = 0.20*gridstruct%da_min
          CALL DEL2_CUBED_BWD(omga, omga_ad, arg10, gridstruct, domain, &
&                       npx, npy, npz, flagstruct%nf_omega, bd)
        ELSE IF (branch .NE. 1) THEN
          CALL POPREALARRAY(omga, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%&
&                      jsd+1)*npz/8)
          DO k=1,npz
            DO j=je,js,-1
              DO i=ie,is,-1
                temp_ad5 = omga_ad(i, j, k)/delz(i, j, k)
                delp_ad(i, j, k) = delp_ad(i, j, k) + w(i, j, k)*&
&                 temp_ad5
                w_ad(i, j, k) = w_ad(i, j, k) + delp(i, j, k)*temp_ad5
                delz_ad(i, j, k) = delz_ad(i, j, k) - delp(i, j, k)*w(i&
&                 , j, k)*temp_ad5/delz(i, j, k)
                omga_ad(i, j, k) = 0.0_FVPRC
              END DO
            END DO
          END DO
        END IF
      END IF
      kord_mt_pert = flagstruct%kord_mt_pert
      kord_tm_pert = flagstruct%kord_tm_pert
      kord_wz_pert = flagstruct%kord_wz_pert
      CALL LAGRANGIAN_TO_EULERIAN_BWD(last_step, consv_te, ps, ps_ad, pe&
&                               , pe_ad, delp, delp_ad, pkz, pkz_ad, pk&
&                               , pk_ad, mdt, bdt, npz, is, ie, js, je, &
&                               isd, ied, jsd, jed, nq, nwat, sphum, &
&                               q_con, u, u_ad, v, v_ad, w, w_ad, delz, &
&                               delz_ad, pt, pt_ad, q, q_ad, phis, zvir&
&                               , cp_air, akap, cappa, kord_mt, kord_wz&
&                               , kord_tr, kord_tm, kord_mt_pert, &
&                               kord_wz_pert, kord_tr_pert, kord_tm_pert&
&                               , peln, peln_ad, te_2d, te_2d_ad, ng, ua&
&                               , ua_ad, va, omga, omga_ad, dp1, dp1_ad&
&                               , ws, ws_ad, fill, reproduce_sum, arg1, &
&                               dtdt_m, ptop, ak, bk, gridstruct, domain&
&                               , ze0, ze0_ad, flagstruct%gmao_cubic, &
&                               flagstruct%remap_t, flagstruct%&
&                               do_sat_adj, hydrostatic, hybrid_z, &
&                               do_omega, do_adiabatic_init)
      DO iq=nq,1,-1
        CALL POPCONTROL1B_FV(branch)
        CALL POPINTEGER(kord_tr_pert(iq))
      END DO
 110  CALL POPCONTROL2B_FV(branch)
      IF (branch .NE. 0) THEN
        IF (branch .EQ. 1) THEN
          hord_tr_pert = flagstruct%hord_tr_pert
          CALL TRACER_2D_NESTED_BWD(q, q_ad, dp1, dp1_ad, mfx, mfx_ad, &
&                             mfy, mfy_ad, cx, cx_ad, cy, cy_ad, &
&                             gridstruct, bd, domain, npx, npy, npz, nq&
&                             , hord_tr, hord_tr_pert, q_split, mdt, &
&                             idiag%id_divg, i_pack(10), i_pack(10+12), &
&                             flagstruct%z_tracer, k_split, neststruct, &
&                             parent_grid)
        ELSE
          hord_tr_pert = flagstruct%hord_tr_pert
          CALL TRACER_2D_BWD(q, q_ad, dp1, dp1_ad, mfx, mfx_ad, mfy, &
&                      mfy_ad, cx, cx_ad, cy, cy_ad, gridstruct, bd, &
&                      domain, npx, npy, npz, 1, nq, hord_tr, &
&                      hord_tr_pert, q_split, mdt, idiag%id_divg, i_pack&
&                      (10), i_pack(10+12), flagstruct%z_tracer, k_split&
&                     )
        END IF
      END IF
      CALL DYN_CORE_BWD(npx, npy, npz, ng, sphum, nq, mdt, n_split, zvir&
&                 , cp_air, akap, cappa, grav, hydrostatic, u, u_ad, v, &
&                 v_ad, w, w_ad, delz, delz_ad, pt, pt_ad, q, q_ad, delp&
&                 , delp_ad, pe, pe_ad, pk, pk_ad, phis, ws, ws_ad, omga&
&                 , omga_ad, ptop, pfull, ua, ua_ad, va, va_ad, uc, &
&                 uc_ad, vc, vc_ad, mfx, mfx_ad, mfy, mfy_ad, cx, cx_ad&
&                 , cy, cy_ad, pkz, pkz_ad, peln, peln_ad, q_con, ak, bk&
&                 , ks, gridstruct, flagstruct, neststruct, idiag, bd, &
&                 domain, arg1, i_pack, last_step, gz, gz_ad, pkc, &
&                 pkc_ad, ptc, ptc_ad, crx, crx_ad, xfx, xfx_ad, cry, &
&                 cry_ad, yfx, yfx_ad, divgd, divgd_ad, delpc, delpc_ad&
&                 , ut, ut_ad, vt, vt_ad, zh, zh_ad, pk3, pk3_ad, du, &
&                 du_ad, dv, dv_ad, time_total)
      CALL POPREALARRAY(dp1, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)*npz/&
&                  8)
      DO k=1,npz
        DO j=je,js,-1
          DO i=ie,is,-1
            delp_ad(i, j, k) = delp_ad(i, j, k) + dp1_ad(i, j, k)
            dp1_ad(i, j, k) = 0.0_FVPRC
          END DO
        END DO
      END DO
      CALL POPREALARRAY(u, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+2)*&
&                  npz/8)
      CALL POPREALARRAY(v, 8*(bd%ied-bd%isd+2)*(bd%jed-bd%jsd+1)*&
&                  npz/8)
      CALL START_GROUP_HALO_UPDATE_ADM(i_pack(8), i_pack(8+12), u, u_ad&
&                                , v, v_ad, domain, gridtype=dgrid_ne)
      CALL POPREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                  npz/8)
      CALL START_GROUP_HALO_UPDATE_ADM(i_pack(2), i_pack(2+12), pt, &
&                                pt_ad, domain)
      CALL POPREALARRAY(delp, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                  *npz/8)
      CALL START_GROUP_HALO_UPDATE_ADM(i_pack(1), i_pack(1+12), delp, &
&                                delp_ad, domain)
    END DO
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                  npz/8)
      DO k=1,npz
        DO j=je,js,-1
          DO i=ie,is,-1
            temp4 = pkz(i, j, k)
            temp3 = pt(i, j, k)/temp4
            temp_ad3 = (dp1(i, j, k)+1.)*cp_air*pt_ad(i, j, k)/temp4
            dp1_ad(i, j, k) = dp1_ad(i, j, k) + cp_air*temp3*pt_ad(i, j&
&             , k)
            pkz_ad(i, j, k) = pkz_ad(i, j, k) - temp3*temp_ad3
            pt_ad(i, j, k) = temp_ad3
          END DO
        END DO
      END DO
    ELSE
      CALL POPREALARRAY(pt, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                  npz/8)
      DO k=1,npz
        DO j=je,js,-1
          DO i=ie,is,-1
            temp6 = pkz(i, j, k)
            temp5 = pt(i, j, k)/temp6
            temp_ad4 = (dp1(i, j, k)+1.)*cp_air*pt_ad(i, j, k)/temp6
            dp1_ad(i, j, k) = dp1_ad(i, j, k) + cp_air*temp5*pt_ad(i, j&
&             , k)
            pkz_ad(i, j, k) = pkz_ad(i, j, k) - temp5*temp_ad4
            pt_ad(i, j, k) = temp_ad4
          END DO
        END DO
      END DO
    END IF
    CALL POPCONTROL2B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL RAYLEIGH_SUPER_BWD(abs0, npx, npy, npz, ks, pfull, phis, &
&                       flagstruct%tau, u, u_ad, v, v_ad, w, w_ad, pt, &
&                       pt_ad, ua, ua_ad, va, va_ad, delz, gridstruct%&
&                       agrid, cp_air, rg, ptop, hydrostatic, .true., &
&                       flagstruct%rf_cutoff, gridstruct, domain, bd)
    ELSE IF (branch .EQ. 1) THEN
      CALL RAYLEIGH_FRICTION_BWD(abs1, npx, npy, npz, ks, pfull, &
&                          flagstruct%tau, u, u_ad, v, v_ad, w, w_ad, pt&
&                          , pt_ad, ua, ua_ad, va, va_ad, delz, delz_ad&
&                          , cp_air, rg, ptop, hydrostatic, .true., &
&                          flagstruct%rf_cutoff, gridstruct, domain, bd)
    END IF
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) CALL COMPUTE_AAM_BWD(npz, is, ie, js, je, isd, &
&                                     ied, jsd, jed, gridstruct, bd, &
&                                     ptop, ua, ua_ad, va, va_ad, u, &
&                                     u_ad, v, v_ad, delp, delp_ad, teq&
&                                     , teq_ad, ps2, ps2_ad, m_fac, &
&                                     m_fac_ad)
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) CALL COMPUTE_TOTAL_ENERGY_BWD(is, ie, js, je, isd&
&                                              , ied, jsd, jed, npz, u, &
&                                              u_ad, v, v_ad, w, w_ad, &
&                                              delz, delz_ad, pt, pt_ad&
&                                              , delp, delp_ad, q, q_ad&
&                                              , dp1, dp1_ad, pe, pe_ad&
&                                              , peln, peln_ad, phis, &
&                                              gridstruct%rsin2, &
&                                              gridstruct%cosa_s, zvir, &
&                                              cp_air, rg, hlv, te_2d, &
&                                              te_2d_ad, ua, va, teq, &
&                                              teq_ad, flagstruct%&
&                                              moist_phys, sphum, &
&                                              liq_wat, rainwat, ice_wat&
&                                              , snowwat, graupel, &
&                                              hydrostatic, idiag%id_te)
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      DO k=npz,1,-1
        DO j=je,js,-1
          DO i=ie,is,-1
            q_ad(i, j, k, sphum) = q_ad(i, j, k, sphum) + zvir*dp1_ad(i&
&             , j, k)
            dp1_ad(i, j, k) = 0.0_FVPRC
          END DO
        END DO
      END DO
    ELSE
      CALL POPINTEGER(sphum)
      CALL POPINTEGER(je)
      CALL POPINTEGER(is)
      CALL POPREALARRAY(rdg)
      CALL POPINTEGER(ie)
      CALL POPINTEGER(js)
      CALL POPREALARRAY(pkz, 8*(bd%ie-bd%is+1)*(bd%je-bd%js+1)*npz/&
&                  8)
      CALL POPREALARRAY(delz, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                  *npz/8)
      CALL POPREALARRAY(delp, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)&
&                  *npz/8)
      CALL POPREALARRAY(q, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                  npz*ncnst/8)
      DO k=1,npz
        DO j=js,je
          DO i=is,ie
            dp1(i, j, k) = zvir*q(i, j, k, sphum)
!#ifdef USE_COND
!!#ifdef USE_NWAT3
!!               q_liq = q(i,j,k,liq_wat)
!!               q_sol = q(i,j,k,ice_wat)
!!#else
!               q_liq = q(i,j,k,liq_wat) + q(i,j,k,rainwat)
!               q_sol = q(i,j,k,ice_wat) + q(i,j,k,snowwat) + q(i,j,k,graupel)
!!#endif
!               q_con(i,j,k) = q_liq + q_Sol
!!#ifdef MOIST_CAPPA
!!!-------Simplified form ---------------------------------------------------------------------------------------
!!!              cappa(i,j,k) = rdgas/(rdgas+((1.-q(i,j,k,sphum)-q_con(i,j,k))*cv_air + q(i,j,k,sphum)*cv_vap + &
!!!                                               q_liq*c_liq + q_sol*c_ice )/(1.+dp1(i,j,k)))
!!!-------Simplified form ---------------------------------------------------------------------------------------
!!               cvm = (1.-(q(i,j,k,sphum)+q_Con(i,j,k)))*cv_air+q(i,j,k,sphum)*cv_vap+q_liq*c_liq+q_sol*c_ice
!!               cappa(i,j,k) = rdgas/(rdgas + cvm*(1.-q_con(i,j,k))/(1.+zvir*q(i,j,k,sphum)-q_con(i,j,k)))
!!               pkz(i,j,k) = exp(cappa(i,j,k)*log(rdg*delp(i,j,k)*pt(i,j,k)*    &
!!                            (1.+dp1(i,j,k)-q_con(i,j,k))/delz(i,j,k)) )
!!#else
!               pkz(i,j,k) = exp( kappa*log(rdg*delp(i,j,k)*pt(i,j,k)*    &
!                            (1.+dp1(i,j,k)-q_con(i,j,k))/delz(i,j,k)) )
!!#endif
!
!#else
          END DO
        END DO
        DO j=je,js,-1
          DO i=ie,is,-1
            temp2 = delz(i, j, k)
            temp = (dp1(i, j, k)+1.)/temp2
            temp1 = delp(i, j, k)*pt(i, j, k)
            temp0 = rdg*temp1*temp
            temp_ad1 = kappa*EXP(kappa*LOG(temp0))*rdg*pkz_ad(i, j, k)/&
&             temp0
            temp_ad2 = temp1*temp_ad1/temp2
            delp_ad(i, j, k) = delp_ad(i, j, k) + temp*pt(i, j, k)*&
&             temp_ad1
            pt_ad(i, j, k) = pt_ad(i, j, k) + temp*delp(i, j, k)*&
&             temp_ad1
            dp1_ad(i, j, k) = dp1_ad(i, j, k) + temp_ad2
            delz_ad(i, j, k) = delz_ad(i, j, k) - temp*temp_ad2
            pkz_ad(i, j, k) = 0.0_FVPRC
            q_ad(i, j, k, sphum) = q_ad(i, j, k, sphum) + zvir*dp1_ad(i&
&             , j, k)
            dp1_ad(i, j, k) = 0.0_FVPRC
          END DO
        END DO
      END DO
    END IF
 120 CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) CALL GEOS_TO_FV3_BWD(bd, npz, kappa, ptop, delp, &
&                                     delp_ad, pe, pe_ad, pk, pk_ad, pkz&
&                                     , pkz_ad, peln, peln_ad, pt, pt_ad&
&                                    )
  END SUBROUTINE FV_DYNAMICS_BWD
  SUBROUTINE FV_DYNAMICS(npx, npy, npz, nq_tot, ng, bdt, consv_te, fill&
&   , reproduce_sum, kappa, cp_air, zvir, ptop, ks, ncnst, n_split, &
&   q_split, u, v, w, delz, hydrostatic, pt, delp, q, ps, pe, pk, peln, &
&   pkz, phis, q_con, omga, ua, va, uc, vc, ak, bk, mfx, mfy, cx, cy, &
&   ze0, hybrid_z, gridstruct, flagstruct, neststruct, idiag, bd, &
&   parent_grid, domain, time_total)
    IMPLICIT NONE
!#ifdef MAPL_MODE
!  t2 = MPI_Wtime(status)
!  dyn_timer = dyn_timer + (t2-t1)
!#endif
! Large time-step
    REAL(fvprc), INTENT(IN) :: bdt
    REAL(fvprc), INTENT(IN) :: consv_te
    REAL(fvprc), INTENT(IN) :: kappa, cp_air
    REAL(fvprc), INTENT(IN) :: zvir, ptop
    REAL(fvprc), INTENT(IN), OPTIONAL :: time_total
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
! transported tracers
    INTEGER, INTENT(IN) :: nq_tot
    INTEGER, INTENT(IN) :: ng
    INTEGER, INTENT(IN) :: ks
    INTEGER, INTENT(IN) :: ncnst
! small-step horizontal dynamics
    INTEGER, INTENT(IN) :: n_split
! tracer
    INTEGER, INTENT(IN) :: q_split
    LOGICAL, INTENT(IN) :: fill
    LOGICAL, INTENT(IN) :: reproduce_sum
    LOGICAL, INTENT(IN) :: hydrostatic
! Using hybrid_z for remapping
    LOGICAL, INTENT(IN) :: hybrid_z
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! D grid zonal wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz), INTENT(&
&   INOUT) :: u
! D grid meridional wind (m/s)
    REAL(fvprc), DIMENSION(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: v
!real(FVPRC), intent(inout) :: w( bd%isd:,bd%jsd:,1:)  !  W (m/s)
!  W (m/s) ! replaced previous line bma
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! temperature (K)
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! pressure thickness (pascal)
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! specific humidity and constituents
    REAL(fvprc), INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, &
&   ncnst)
!real(FVPRC), intent(inout) :: delz(bd%isd:,bd%jsd:,1:)   ! delta-height (m); non-hydrostatic only
! replace previous line bma
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! height at edges (m); non-hydrostatic
    REAL(fvprc), INTENT(INOUT) :: ze0(bd%is:bd%ie, bd%js:bd%je, npz+1)
!-----------------------------------------------------------------------
! Auxilliary pressure arrays:    
! The 5 vars below can be re-computed from delp and ptop.
!-----------------------------------------------------------------------
! dyn_aux:
! Surface pressure (pascal)
    REAL(fvprc), INTENT(INOUT) :: ps(bd%isd:bd%ied, bd%jsd:bd%jed)
! edge pressure (pascal)
    REAL(fvprc), INTENT(INOUT) :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%&
&   je+1)
! pe**kappa
    REAL(fvprc), INTENT(INOUT) :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
! ln(pe)
    REAL(fvprc), INTENT(INOUT) :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
! finite-volume mean pk
    REAL(fvprc), INTENT(INOUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
!real(FVPRC), intent(inout):: q_con(bd%isd:, bd%jsd:, 1:)
!bma replaced previous line
    REAL(fvprc), INTENT(INOUT) :: q_con(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
!-----------------------------------------------------------------------
! Others:
!-----------------------------------------------------------------------
! Surface geopotential (g*Z_surf)
    REAL(fvprc), INTENT(INOUT) :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
! Vertical pressure velocity (pa/s)
    REAL(fvprc), INTENT(INOUT) :: omga(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
! (uc,vc) mostly used as the C grid winds
    REAL(fvprc), INTENT(INOUT) :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz&
&   )
    REAL(fvprc), DIMENSION(bd%isd:bd%ied, bd%jsd:bd%jed, npz), INTENT(&
&   INOUT) :: ua, va
    REAL(fvprc), DIMENSION(npz+1), INTENT(IN) :: ak, bk
! Accumulated Mass flux arrays: the "Flux Capacitor"
    REAL(fvprc), INTENT(INOUT) :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL(fvprc), INTENT(INOUT) :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
! Accumulated Courant number arrays
    REAL(fvprc), INTENT(INOUT) :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    TYPE(FV_GRID_TYPE), INTENT(INOUT), TARGET :: gridstruct
    TYPE(FV_FLAGS_TYPE), INTENT(INOUT) :: flagstruct
    TYPE(FV_NEST_TYPE), INTENT(INOUT) :: neststruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    TYPE(FV_ATMOS_TYPE), INTENT(INOUT) :: parent_grid
    TYPE(FV_DIAG_TYPE), INTENT(IN) :: idiag
! heat capacity of water at 0C
    REAL(fvprc), PARAMETER :: c_liq=4190.
! heat capacity of ice at 0C: c=c_ice+7.3*(T-Tice) 
    REAL(fvprc), PARAMETER :: c_ice=2106.
! 1384.5
    REAL(fvprc), PARAMETER :: cv_vap=cp_vapor-rvgas
! Local Arrays
    REAL(fvprc) :: ws(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: te_2d(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: teq(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: ps2(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL(fvprc) :: m_fac(bd%is:bd%ie, bd%js:bd%je)
    REAL(fvprc) :: pfull(npz)
!real(FVPRC):: gz(bd%is:bd%ie)
    REAL(fvprc) :: dp1(bd%is:bd%ie, bd%js:bd%je, npz), dtdt_m(bd%is:bd%&
&   ie, bd%js:bd%je, npz), cappa(bd%isd:bd%isd, bd%jsd:bd%jsd, 1)
    REAL(fvprc) :: akap, rg, rdg, ph1, ph2, mdt, gam, amdt, u0
    INTEGER :: i, j, k, n, iq, n_map, nq, nwat, k_split
! GFDL physics
    INTEGER :: sphum, liq_wat, ice_wat
    INTEGER :: rainwat, snowwat, graupel, cld_amt
    LOGICAL :: used, last_step, consv_am, do_omega
    INTEGER, PARAMETER :: max_packs=24
    TYPE(GROUP_HALO_UPDATE_TYPE), SAVE :: i_pack(max_packs)
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    REAL(fvprc) :: rcv, dt2, consv_fac, q_liq, q_sol, cvm
    REAL(fvprc) :: cv_air
    REAL(kind=8) :: t1, t2
    INTEGER :: status
    REAL(fvprc) :: gz(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: pkc(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: ptc(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: crx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: xfx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: cry(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc) :: yfx(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL(fvprc) :: divgd(bd%isd:bd%ied+1, bd%jsd:bd%jed+1, npz)
    REAL(fvprc) :: delpc(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: ut(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: vt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc) :: zh(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: pk3(bd%isd:bd%ied, bd%jsd:bd%jed, npz+1)
    REAL(fvprc) :: du(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc) :: dv(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    INTEGER :: hord_tr, hord_tr_pert
    INTEGER :: kord_mt, kord_wz, kord_tr(ncnst), kord_tm
    INTEGER :: kord_mt_pert, kord_wz_pert, kord_tr_pert(ncnst), &
&   kord_tm_pert
    INTRINSIC LOG
    INTRINSIC EXP
    INTRINSIC ABS
    INTRINSIC REAL
    INTRINSIC ANY
    INTRINSIC COS
    REAL(fvprc) :: abs0
    REAL(fvprc) :: abs1
    LOGICAL :: arg1
    REAL(kind=r_grid) :: arg10
    REAL(fvprc) :: result1
    gz = 0.0
    pkc = 0.0
    ptc = 0.0
    crx = 0.0
    xfx = 0.0
    cry = 0.0
    yfx = 0.0
    divgd = 0.0
    delpc = 0.0
    ut = 0.0
    vt = 0.0
    zh = 0.0
    pk3 = 0.0
    du = 0.0
    dv = 0.0
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
!Compute the FV variables internally, for checkpointing purposes
    IF (hydrostatic .AND. (.NOT.idealtest)) CALL GEOS_TO_FV3(bd, npz, &
&                                                      kappa, ptop, delp&
&                                                      , pe, pk, pkz, &
&                                                      peln, pt)
!      dyn_timer = 0
!      comm_timer = 0
    cv_air = cp_air - rdgas
    agrav = 1./grav
    dt2 = 0.5*bdt
    consv_am = flagstruct%consv_am
    k_split = flagstruct%k_split
    nwat = flagstruct%nwat
    nq = nq_tot - flagstruct%dnats
    IF (.NOT.flagstruct%no_dycore) THEN
!#ifdef MAPL_MODE
!! Begin Dynamics timer for GEOS history processing
!      t1 = MPI_Wtime(status)
!#endif
!allocate ( dp1(is:ie, js:je, 1:npz) )
!#ifdef MOIST_CAPPA
!      allocate ( cappa(isd:ied,jsd:jed,npz) )
!#else
!      allocate ( cappa(isd:isd,jsd:jsd,1) )
!#endif
!#ifdef SW_DYNAMICS
!      akap  = 1.
!      pfull(1) = 0.5*flagstruct%p_ref
!#ifdef TEST_TRACER
!      sphum = get_tracer_index (MODEL_ATMOS, 'sphum')
!#endif
!#else
      IF (nwat .GE. 3) THEN
        sphum = GET_TRACER_INDEX(model_atmos, 'sphum')
        liq_wat = GET_TRACER_INDEX(model_atmos, 'liq_wat')
        ice_wat = GET_TRACER_INDEX(model_atmos, 'ice_wat')
        cld_amt = GET_TRACER_INDEX(model_atmos, 'cld_amt')
      END IF
      IF (nwat .EQ. 6) THEN
        rainwat = GET_TRACER_INDEX(model_atmos, 'rainwat')
        snowwat = GET_TRACER_INDEX(model_atmos, 'snowwat')
        graupel = GET_TRACER_INDEX(model_atmos, 'graupel')
      ELSE
        sphum = 1
! to cause trouble if (mis)used
        cld_amt = -1
      END IF
      akap = kappa
      rg = kappa*cp_air
      rcv = 1./(cp_air-rg)
!$OMP parallel do default(none) shared(npz,ak,bk,flagstruct,pfull) &
!$OMP                          private(ph1, ph2)
      DO k=1,npz
        ph1 = ak(k) + bk(k)*flagstruct%p_ref
        ph2 = ak(k+1) + bk(k+1)*flagstruct%p_ref
        pfull(k) = (ph2-ph1)/LOG(ph2/ph1)
      END DO
      IF (hydrostatic) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,dp1,zvir,q,q_con,sphum,liq_wat, &
!$OMP                                  rainwat,ice_wat,snowwat,graupel )
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              dp1(i, j, k) = zvir*q(i, j, k, sphum)
            END DO
          END DO
        END DO
      ELSE
!#ifdef USE_COND
!!#ifdef USE_NWAT3
!!               q_con(i,j,k) = q(i,j,k,liq_wat) + q(i,j,k,ice_wat)
!!#else
!               q_con(i,j,k) = q(i,j,k,liq_wat) + q(i,j,k,rainwat) + q(i,j,k,ice_wat)  &
!                            + q(i,j,k,snowwat) + q(i,j,k,graupel)
!!#endif
!#endif
        rdg = -(rdgas*agrav)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,dp1,zvir,q,q_con,sphum,liq_wat, &
!$OMP                                  rainwat,ice_wat,snowwat,graupel,pkz,cv_air,     & 
!$OMP                                  cappa,kappa,rdg,delp,pt,delz)                         &
!$OMP                          private(cvm, q_liq, q_sol)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              dp1(i, j, k) = zvir*q(i, j, k, sphum)
!#ifdef USE_COND
!!#ifdef USE_NWAT3
!!               q_liq = q(i,j,k,liq_wat)
!!               q_sol = q(i,j,k,ice_wat)
!!#else
!               q_liq = q(i,j,k,liq_wat) + q(i,j,k,rainwat)
!               q_sol = q(i,j,k,ice_wat) + q(i,j,k,snowwat) + q(i,j,k,graupel)
!!#endif
!               q_con(i,j,k) = q_liq + q_Sol
!!#ifdef MOIST_CAPPA
!!!-------Simplified form ---------------------------------------------------------------------------------------
!!!              cappa(i,j,k) = rdgas/(rdgas+((1.-q(i,j,k,sphum)-q_con(i,j,k))*cv_air + q(i,j,k,sphum)*cv_vap + &
!!!                                               q_liq*c_liq + q_sol*c_ice )/(1.+dp1(i,j,k)))
!!!-------Simplified form ---------------------------------------------------------------------------------------
!!               cvm = (1.-(q(i,j,k,sphum)+q_Con(i,j,k)))*cv_air+q(i,j,k,sphum)*cv_vap+q_liq*c_liq+q_sol*c_ice
!!               cappa(i,j,k) = rdgas/(rdgas + cvm*(1.-q_con(i,j,k))/(1.+zvir*q(i,j,k,sphum)-q_con(i,j,k)))
!!               pkz(i,j,k) = exp(cappa(i,j,k)*log(rdg*delp(i,j,k)*pt(i,j,k)*    &
!!                            (1.+dp1(i,j,k)-q_con(i,j,k))/delz(i,j,k)) )
!!#else
!               pkz(i,j,k) = exp( kappa*log(rdg*delp(i,j,k)*pt(i,j,k)*    &
!                            (1.+dp1(i,j,k)-q_con(i,j,k))/delz(i,j,k)) )
!!#endif
!
!#else
              pkz(i, j, k) = EXP(kappa*LOG(rdg*delp(i, j, k)*pt(i, j, k)&
&               *(1.+dp1(i, j, k))/delz(i, j, k)))
            END DO
          END DO
        END DO
      END IF
!#endif
!      if ( flagstruct%fv_debug ) then
!!#ifdef MOIST_CAPPA
!!         call prt_mxm('cappa', cappa, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!!#endif
!         call prt_mxm('PS',        ps, is, ie, js, je, ng,   1, 0.01_FVPRC, gridstruct%area_64, domain)
!         call prt_mxm('T_dyn_b',   pt, is, ie, js, je, ng, npz, 1._FVPRC,   gridstruct%area_64, domain)
!         call prt_mxm('delz',    delz, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!         call prt_mxm('delp_b ', delp, is, ie, js, je, ng, npz, 0.01_FVPRC, gridstruct%area_64, domain)
!         call prt_mxm('pk_b',    pk, is, ie, js, je, 0, npz+1, 1._FVPRC,gridstruct%area_64, domain)
!         call prt_mxm('pkz_b',   pkz,is, ie, js, je, 0, npz,   1._FVPRC,gridstruct%area_64, domain)
!      endif
!---------------------
! Compute Total Energy
!---------------------
      IF (consv_te .GT. 0. .AND. (.NOT.do_adiabatic_init)) CALL &
&       COMPUTE_TOTAL_ENERGY(is, ie, js, je, isd, ied, jsd, jed, npz, u&
&                      , v, w, delz, pt, delp, q, dp1, pe, peln, phis, &
&                      gridstruct%rsin2, gridstruct%cosa_s, zvir, cp_air&
&                      , rg, hlv, te_2d, ua, va, teq, flagstruct%&
&                      moist_phys, sphum, liq_wat, rainwat, ice_wat, &
&                      snowwat, graupel, hydrostatic, idiag%id_te)
!used = send_data(idiag%id_te, teq, fv_time)
!              te_den=1.E-9*g_sum(teq, is, ie, js, je, ng, area, 0)/(grav*4.*pi*radius**2)
!              if(is_master())  write(*,*) 'Total Energy Density (Giga J/m**2)=',te_den
      IF ((consv_am .OR. idiag%id_amdt .GT. 0) .AND. (.NOT.&
&         do_adiabatic_init)) CALL COMPUTE_AAM(npz, is, ie, js, je, isd&
&                                        , ied, jsd, jed, gridstruct, bd&
&                                        , ptop, ua, va, u, v, delp, teq&
&                                        , ps2, m_fac)
      IF (flagstruct%tau .GT. 0.) THEN
        IF (gridstruct%grid_type .LT. 4) THEN
          IF (bdt .GE. 0.) THEN
            abs0 = bdt
          ELSE
            abs0 = -bdt
          END IF
          CALL RAYLEIGH_SUPER(abs0, npx, npy, npz, ks, pfull, phis, &
&                       flagstruct%tau, u, v, w, pt, ua, va, delz, &
&                       gridstruct%agrid, cp_air, rg, ptop, hydrostatic&
&                       , .true., flagstruct%rf_cutoff, gridstruct, &
&                       domain, bd)
        ELSE
          IF (bdt .GE. 0.) THEN
            abs1 = bdt
          ELSE
            abs1 = -bdt
          END IF
          CALL RAYLEIGH_FRICTION(abs1, npx, npy, npz, ks, pfull, &
&                          flagstruct%tau, u, v, w, pt, ua, va, delz, &
&                          cp_air, rg, ptop, hydrostatic, .true., &
&                          flagstruct%rf_cutoff, gridstruct, domain, bd)
        END IF
      END IF
!#endif
!We call this BEFORE converting pt to virtual potential temperature, 
!since we interpolate on (regular) temperature rather than theta.
!      if (gridstruct%nested .or. ANY(neststruct%child_grids)) then
!                                           if (fv_timing_onoff) call timing_on('NEST_BCs')
!         call setup_nested_grid_BCs(npx, npy, npz, cp_air, zvir, ncnst, sphum,     &
!              u, v, w, pt, delp, delz, q, uc, vc, pkz, &
!              neststruct%nested, flagstruct%inline_q, flagstruct%make_nh, ng, &
!              gridstruct, flagstruct, neststruct, &
!              neststruct%nest_timestep, neststruct%tracer_nest_timestep, domain, bd)
!                                           if (fv_timing_onoff) call timing_off('NEST_BCs')
!      endif
!#ifndef SW_DYNAMICS
! Convert pt to virtual potential temperature * CP
      IF (hydrostatic) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pt,cp_air,dp1,pkz)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              pt(i, j, k) = cp_air*pt(i, j, k)*(1.+dp1(i, j, k))/pkz(i, &
&               j, k)
            END DO
          END DO
        END DO
      ELSE
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pt,cp_air,dp1,pkz,q_con)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
!#ifdef USE_COND
!           pt(i,j,k) = cp_air*pt(i,j,k)*(1.+dp1(i,j,k)-q_con(i,j,k))/pkz(i,j,k)
!#else
              pt(i, j, k) = cp_air*pt(i, j, k)*(1.+dp1(i, j, k))/pkz(i, &
&               j, k)
            END DO
          END DO
        END DO
      END IF
!#endif
!#endif
      last_step = .false.
      mdt = bdt/REAL(k_split)
      IF (idiag%id_mdt .GT. 0) THEN
!allocate ( dtdt_m(is:ie,js:je,npz) )
!$OMP parallel do default(none) shared(is,ie,js,je,npz,dtdt_m)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              dtdt_m(i, j, k) = 0.
            END DO
          END DO
        END DO
      END IF
!if (fv_timing_onoff) call timing_on('  FV_DYN_LOOP')
! first level of time-split
      DO n_map=1,k_split
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
!#ifdef USE_COND
!      call start_group_halo_update(i_pack(11), i_pack(11+12), q_con, domain)
!!#ifdef MOIST_CAPPA
!!      call start_group_halo_update(i_pack(12), i_pack(12+12), cappa, domain)
!!#endif
!#endif
        CALL START_GROUP_HALO_UPDATE(i_pack(1), i_pack(1+12), delp, &
&                              domain)
        CALL START_GROUP_HALO_UPDATE(i_pack(2), i_pack(2+12), pt, domain&
&                             )
!#ifndef ROT3
        CALL START_GROUP_HALO_UPDATE(i_pack(8), i_pack(8+12), u, v, &
&                              domain, gridtype=dgrid_ne)
!#endif
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!$OMP parallel do default(none) shared(is,ie,js,je,npz,dp1,delp)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              dp1(i, j, k) = delp(i, j, k)
            END DO
          END DO
        END DO
        IF (n_map .EQ. k_split) last_step = .true.
!#ifdef USE_COND
!                                           if (fv_timing_onoff) call timing_on('COMM_TOTAL')
!     call complete_group_halo_update(i_pack(11), i_pack(11+12), domain)
!!#ifdef MOIST_CAPPA
!!     call complete_group_halo_update(i_pack(12), i_pack(12+12), domain)
!!#endif
!                                           if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!#endif
        IF (fv_timing_onoff) CALL TIMING_ON('  DYN_CORE')
        arg1 = n_map .EQ. 1
        CALL DYN_CORE(npx, npy, npz, ng, sphum, nq, mdt, n_split, zvir, &
&               cp_air, akap, cappa, grav, hydrostatic, u, v, w, delz, &
&               pt, q, delp, pe, pk, phis, ws, omga, ptop, pfull, ua, va&
&               , uc, vc, mfx, mfy, cx, cy, pkz, peln, q_con, ak, bk, ks&
&               , gridstruct, flagstruct, neststruct, idiag, bd, domain&
&               , arg1, i_pack, last_step, gz, pkc, ptc, crx, xfx, cry, &
&               yfx, divgd, delpc, ut, vt, zh, pk3, du, dv, time_total)
        IF (fv_timing_onoff) CALL TIMING_OFF('  DYN_CORE')
!  if ( flagstruct%fv_debug ) then
!       call prt_mxm('delp_a1',  delp, is, ie, js, je, ng, npz, 0.01_FVPRC, gridstruct%area_64, domain)
!       call prt_mxm('PT_dyn_a1',  pt, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!       call prt_mxm('pk_a1',   pk, is, ie, js, je, 0, npz+1, 1._FVPRC, gridstruct%area_64, domain)
!  endif
!#ifdef SW_DYNAMICS
!!$OMP parallel do default(none) shared(is,ie,js,je,delp,agrav)
!      do j=js,je
!         do i=is,ie
!            ps(i,j) = delp(i,j,1) * agrav
!         enddo
!      enddo
!#else
        IF (.NOT.flagstruct%inline_q .AND. nq .NE. 0) THEN
!--------------------------------------------------------
! Perform large-time-step scalar transport using the accumulated CFL and
! mass fluxes
          IF (fv_timing_onoff) CALL TIMING_ON('  tracer_2d')
          hord_tr = flagstruct%hord_tr
          hord_tr_pert = flagstruct%hord_tr_pert
          IF (last_step) hord_tr = hord_tr_pert
!!! CLEANUP: merge these two calls?
          IF (gridstruct%nested .OR. ANY(neststruct%child_grids)) THEN
            CALL TRACER_2D_NESTED(q, dp1, mfx, mfy, cx, cy, gridstruct, &
&                           bd, domain, npx, npy, npz, nq, hord_tr, &
&                           hord_tr_pert, q_split, mdt, idiag%id_divg, &
&                           i_pack(10), i_pack(10+12), flagstruct%&
&                           z_tracer, k_split, neststruct, parent_grid)
          ELSE
            CALL TRACER_2D(q, dp1, mfx, mfy, cx, cy, gridstruct, bd, &
&                    domain, npx, npy, npz, 1, nq, hord_tr, hord_tr_pert&
&                    , q_split, mdt, idiag%id_divg, i_pack(10), i_pack(&
&                    10+12), flagstruct%z_tracer, k_split)
          END IF
          IF (fv_timing_onoff) CALL TIMING_OFF('  tracer_2d')
        END IF
!used = send_data(idiag%id_divg, dp1, fv_time) 
!             if(flagstruct%fv_debug) call prt_mxm('divg',  dp1, is, ie, js, je, 0, npz, 1._FVPRC,gridstruct%area_64, domain)
        IF (npz .GT. 4) THEN
!------------------------------------------------------------------------
! Peroform vertical remapping from Lagrangian control-volume to
! the Eulerian coordinate as specified by the routine set_eta.
! Note that this finite-volume dycore is otherwise independent of the vertical
! Eulerian coordinate.
!------------------------------------------------------------------------
          DO iq=1,nq
            kord_tr(iq) = flagstruct%kord_tr
            kord_tr_pert(iq) = flagstruct%kord_tr_pert
! monotonic
            IF (iq .EQ. cld_amt) kord_tr(iq) = 9
            IF (iq .EQ. cld_amt) kord_tr_pert(iq) = 111
          END DO
          kord_mt = flagstruct%kord_mt
          kord_wz = flagstruct%kord_wz
          kord_tm = flagstruct%kord_tm
          kord_mt_pert = flagstruct%kord_mt_pert
          kord_wz_pert = flagstruct%kord_wz_pert
          kord_tm_pert = flagstruct%kord_tm_pert
          IF ((kord_tm .LT. 0 .AND. kord_tm_pert .GE. 0) .OR. (kord_tm &
&             .GE. 0 .AND. kord_tm_pert .LT. 0)) kord_tm = kord_tm_pert
!This would result in different anticipated paths through the code
          IF (last_step) THEN
!Does not matter how trajectory is remapped as it is about to be overwritten
            kord_mt = kord_mt_pert
            kord_wz = kord_wz_pert
            kord_tr = kord_tr_pert
            kord_tm = kord_tm_pert
          END IF
          do_omega = hydrostatic .AND. last_step
          IF (fv_timing_onoff) CALL TIMING_ON('  Remapping')
          arg1 = idiag%id_mdt .GT. 0
          CALL LAGRANGIAN_TO_EULERIAN(last_step, consv_te, ps, pe, delp&
&                               , pkz, pk, mdt, bdt, npz, is, ie, js, je&
&                               , isd, ied, jsd, jed, nq, nwat, sphum, &
&                               q_con, u, v, w, delz, pt, q, phis, zvir&
&                               , cp_air, akap, cappa, kord_mt, kord_wz&
&                               , kord_tr, kord_tm, kord_mt_pert, &
&                               kord_wz_pert, kord_tr_pert, kord_tm_pert&
&                               , peln, te_2d, ng, ua, va, omga, dp1, ws&
&                               , fill, reproduce_sum, arg1, dtdt_m, &
&                               ptop, ak, bk, gridstruct, domain, ze0, &
&                               flagstruct%gmao_cubic, flagstruct%&
&                               remap_t, flagstruct%do_sat_adj, &
&                               hydrostatic, hybrid_z, do_omega, &
&                               do_adiabatic_init)
          IF (fv_timing_onoff) CALL TIMING_OFF('  Remapping')
          IF (last_step) THEN
            IF (hydrostatic) THEN
!--------------------------
! Filter omega for physics:
!--------------------------
              IF (flagstruct%nf_omega .GT. 0) THEN
                arg10 = 0.20*gridstruct%da_min
                CALL DEL2_CUBED(omga, arg10, gridstruct, domain, npx, &
&                         npy, npz, flagstruct%nf_omega, bd)
              END IF
            ELSE
!$OMP parallel do default(none) shared(is,ie,js,je,npz,omga,delp,delz,w)
              DO k=1,npz
                DO j=js,je
                  DO i=is,ie
                    omga(i, j, k) = delp(i, j, k)/delz(i, j, k)*w(i, j, &
&                     k)
                  END DO
                END DO
              END DO
            END IF
! Convert back to temperature
            IF (.NOT.flagstruct%remap_t) THEN
              IF (hydrostatic) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,npz,pt,pkz,cp_air,zvir,q,sphum)
                DO k=1,npz
                  DO j=js,je
                    DO i=is,ie
                      pt(i, j, k) = pt(i, j, k)*pkz(i, j, k)/(cp_air*(1.&
&                       +zvir*q(i, j, k, sphum)))
                    END DO
                  END DO
                END DO
              ELSE
!$OMP parallel do default(none)  shared(is,ie,js,je,npz,pt,pkz,cp_air,zvir,q,sphum,q_con)
                DO k=1,npz
                  DO j=js,je
                    DO i=is,ie
!#ifdef USE_COND
!                     pt(i,j,k) = pt(i,j,k)*pkz(i,j,k)/(cp_air*(1.+zvir*q(i,j,k,sphum)-q_con(i,j,k)))
!#else
                      pt(i, j, k) = pt(i, j, k)*pkz(i, j, k)/(cp_air*(1.&
&                       +zvir*q(i, j, k, sphum)))
                    END DO
                  END DO
                END DO
              END IF
            END IF
          END IF
        END IF
      END DO
!#endif
!#endif
! n_map loop
!if (fv_timing_onoff) call timing_off('  FV_DYN_LOOP')
      IF (idiag%id_mdt .GT. 0 .AND. (.NOT.do_adiabatic_init)) THEN
! Output temperature tendency due to inline moist physics:
!$OMP parallel do default(none) shared(is,ie,js,je,npz,dtdt_m,bdt)
        DO k=1,npz
          DO j=js,je
            DO i=is,ie
              dtdt_m(i, j, k) = dtdt_m(i, j, k)/bdt
            END DO
          END DO
        END DO
      END IF
!used = send_data(idiag%id_mdt, dtdt_m, fv_time)
!deallocate ( dtdt_m )
!  if( nwat==6 ) then
!      call neg_adj3(is, ie, js, je, ng, npz,        &
!                    flagstruct%hydrostatic,         &
!                    peln, delz,                     &
!                    pt, delp, q(isd,jsd,1,sphum),   &
!                              q(isd,jsd,1,liq_wat), &
!                              q(isd,jsd,1,rainwat), &
!                              q(isd,jsd,1,ice_wat), &
!                              q(isd,jsd,1,snowwat), &
!                              q(isd,jsd,1,graupel), &
!                              q(isd,jsd,1,cld_amt), flagstruct%check_negative)
!!     if ( flagstruct%fv_debug ) then
!!       call prt_mxm('T_dyn_a3',    pt, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!!       call prt_mxm('SPHUM_dyn',   q(isd,jsd,1,sphum  ), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!       call prt_mxm('liq_wat_dyn', q(isd,jsd,1,liq_wat), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!       call prt_mxm('rainwat_dyn', q(isd,jsd,1,rainwat), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!       call prt_mxm('ice_wat_dyn', q(isd,jsd,1,ice_wat), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!       call prt_mxm('snowwat_dyn', q(isd,jsd,1,snowwat), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!       call prt_mxm('graupel_dyn', q(isd,jsd,1,graupel), is, ie, js, je, ng, npz, 1._FVPRC,gridstruct%area_64, domain)
!!     endif
!  endif
      IF ((consv_am .OR. idiag%id_amdt .GT. 0) .OR. (idiag%id_aam .GT. 0&
&         .AND. (.NOT.do_adiabatic_init))) THEN
        CALL COMPUTE_AAM(npz, is, ie, js, je, isd, ied, jsd, jed, &
&                  gridstruct, bd, ptop, ua, va, u, v, delp, te_2d, ps, &
&                  m_fac)
        IF (idiag%id_aam .GT. 0) THEN
!used = send_data(idiag%id_aam, te_2d, fv_time)
          IF (prt_minmax) gam = G_SUM(domain, te_2d, is, ie, js, je, ng&
&             , gridstruct%area_64, 0)
!if( is_master() ) write(6,*) 'Total AAM =', gam
        END IF
      END IF
      IF (consv_am .OR. (idiag%id_amdt .GT. 0 .AND. (.NOT.&
&         do_adiabatic_init))) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,te_2d,teq,dt2,ps2,ps,idiag) 
        DO j=js,je
          DO i=is,ie
! Note: the mountain torque computation contains also numerical error
! The numerical error is mostly from the zonal gradient of the terrain (zxg)
            te_2d(i, j) = te_2d(i, j) - teq(i, j) + dt2*(ps2(i, j)+ps(i&
&             , j))*idiag%zxg(i, j)
          END DO
        END DO
!if( idiag%id_amdt>0 ) used = send_data(idiag%id_amdt, te_2d/bdt, fv_time)
        IF (consv_am .OR. prt_minmax) THEN
          amdt = G_SUM(domain, te_2d, is, ie, js, je, ng, gridstruct%&
&           area_64, 0)
          result1 = G_SUM(domain, m_fac, is, ie, js, je, ng, gridstruct%&
&           area_64, 0)
          u0 = -(radius*amdt/result1)
! truncate to enforce reproducibility
          u0 = REAL(u0, 4)
!if(is_master() .and. prt_minmax)         &
!        write(6,*) 'Dynamic AM tendency =', amdt/(bdt*1.e18), 'del-u (per yr)=', u0*365.*86400./bdt
!         write(6,*) 'Dynamic Angular Momentum tendency (Hadleys)=', amdt/(bdt*1.e18)
        END IF
!  consv_am
        IF (consv_am) THEN
!$OMP parallel do default(none) shared(is,ie,js,je,m_fac,u0,gridstruct)
          DO j=js,je
            DO i=is,ie
              m_fac(i, j) = u0*COS(gridstruct%agrid(i, j, 2))
            END DO
          END DO
!$OMP parallel do default(none) shared(is,ie,js,je,npz,hydrostatic,pt,m_fac,ua,cp_air, &
!$OMP                                  rcv,u,u0,gridstruct,v )
          IF (hydrostatic) THEN
            DO k=1,npz
              DO j=js,je
                DO i=is,ie
                  pt(i, j, k) = pt(i, j, k) - m_fac(i, j)*(0.5*m_fac(i, &
&                   j)+ua(i, j, k))/cp_air
                END DO
              END DO
            END DO
          ELSE
            DO k=1,npz
              DO j=js,je
                DO i=is,ie
                  pt(i, j, k) = pt(i, j, k) - m_fac(i, j)*(0.5*m_fac(i, &
&                   j)+ua(i, j, k))*rcv
                END DO
              END DO
            END DO
          END IF
          DO k=1,npz
            DO j=js,je+1
              DO i=is,ie
                u(i, j, k) = u(i, j, k) + u0*gridstruct%l2c_u(i, j)
              END DO
            END DO
            DO j=js,je
              DO i=is,ie+1
                v(i, j, k) = v(i, j, k) + u0*gridstruct%l2c_v(i, j)
              END DO
            END DO
          END DO
        END IF
      END IF
    END IF
    CALL CUBED_TO_LATLON(u, v, ua, va, gridstruct, npx, npy, npz, 1, &
&                  gridstruct%grid_type, domain, gridstruct%nested, &
&                  flagstruct%c2l_ord, bd)
!     if ( flagstruct%fv_debug ) then
!       call prt_mxm('UA', ua, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!       call prt_mxm('VA', va, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!       call prt_mxm('TA', pt, is, ie, js, je, ng, npz, 1._FVPRC, gridstruct%area_64, domain)
!     endif
!  if ( flagstruct%range_warn ) then
!       call range_check('UA_dyn', ua, is, ie, js, je, ng, npz, gridstruct%agrid,   &
!                         -220._FVPRC, 260._FVPRC, bad_range)
!       call range_check('VA_dyn', ua, is, ie, js, je, ng, npz, gridstruct%agrid,   &
!                         -220._FVPRC, 220._FVPRC, bad_range)
!!#ifndef SW_DYNAMICS
!       call range_check('TA_dyn', pt, is, ie, js, je, ng, npz, gridstruct%agrid,   &
!                         160._FVPRC, 330._FVPRC, bad_range)
!       if ( .not. hydrostatic ) &
!       call range_check('W_dyn', w, is, ie, js, je, ng, npz, gridstruct%agrid,   &
!                         -20._FVPRC, 20._FVPRC, bad_range)
!!#endif
!
!  endif
!deallocate ( dp1 )
!deallocate ( cappa )
!Convert back to potential temperature
    IF (hydrostatic .AND. (.NOT.idealtest)) CALL FV3_TO_GEOS(bd, npz, &
&                                                      pkz, pt)
  END SUBROUTINE FV_DYNAMICS
!  Differentiation of rayleigh_super in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_ed
!ge_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod
!.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_
!core_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_m
!od.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cu
!bed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total
!_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_
!mapz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.ste
!epz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_
!solver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver n
!h_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.diver
!gence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_c
!ore_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_c
!ore_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_
!core_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: u v w ua va pt
!   with respect to varying inputs: u v w ua va pt
  SUBROUTINE RAYLEIGH_SUPER_FWD(dt, npx, npy, npz, ks, pm, phis, tau, u&
&   , v, w, pt, ua, va, delz, agrid, cp, rg, ptop, hydrostatic, conserve&
&   , rf_cutoff, gridstruct, domain, bd)
    IMPLICIT NONE
!#endif
!deallocate ( u2f )
    REAL(fvprc), INTENT(IN) :: dt
! time scale (days)
    REAL(fvprc), INTENT(IN) :: tau
    REAL(fvprc), INTENT(IN) :: cp, rg, ptop, rf_cutoff
    INTEGER, INTENT(IN) :: npx, npy, npz, ks
    REAL(fvprc), DIMENSION(npz), INTENT(IN) :: pm
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: conserve
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! D grid zonal wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
! D grid meridional wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
! cell center vertical wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%isd, bd%jsd:bd%jsd, npz)
! temp
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! 
    REAL(fvprc), INTENT(INOUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! 
    REAL(fvprc), INTENT(INOUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! delta-height (m); non-hydrostatic only
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(IN) :: agrid(bd%isd:bd%ied, bd%jsd:bd%jed, 2)
! Surface geopotential (g*Z_surf)
    REAL(fvprc), INTENT(IN) :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
    TYPE(FV_GRID_TYPE), INTENT(IN) :: gridstruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
!
    REAL(fvprc) :: u2f(bd%isd:bd%ied, bd%jsd:bd%jed, kmax)
! scaling velocity
    REAL(fvprc), PARAMETER :: u0=60.
    REAL(fvprc), PARAMETER :: sday=86400.
    REAL(fvprc) :: rcv, tau0
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    REAL(fvprc) :: rf(npz)
    INTRINSIC LOG
    INTRINSIC SIN
    INTRINSIC ABS
    INTRINSIC COS
    INTRINSIC SQRT
    REAL(fvprc) :: abs0
    REAL(fvprc) :: abs1
    REAL(fvprc) :: abs2
    INTEGER :: ad_count
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    rcv = 1./(cp-rg)
    IF (.NOT.rf_initialized) THEN
!#ifdef HIWPP
!          allocate ( u00(is:ie,  js:je+1,npz) )
!          allocate ( v00(is:ie+1,js:je  ,npz) )
!!$OMP parallel do default(none) shared(is,ie,js,je,npz,u00,u,v00,v)
!          do k=1,npz
!             do j=js,je+1
!                do i=is,ie
!                   u00(i,j,k) = u(i,j,k)
!                enddo
!             enddo
!             do j=js,je
!                do i=is,ie+1
!                   v00(i,j,k) = v(i,j,k)
!                enddo
!             enddo
!          enddo
!#endif
!#ifdef SMALL_EARTH
!          tau0 = tau
!#else
      tau0 = tau*sday
!#endif
!allocate( rf(npz) )
      rf(:) = 0.
      ad_count = 1
!if( is_master() ) write(6,*) 'Rayleigh friction E-folding time (days):'
      DO k=1,npz
        IF (pm(k) .LT. rf_cutoff) THEN
          rf(k) = dt/tau0*SIN(0.5*pi*LOG(rf_cutoff/pm(k))/LOG(rf_cutoff/&
&           ptop))**2
!if( is_master() ) write(6,*) k, 0.01*pm(k), dt/(rf(k)*sday)
          kmax = k
          ad_count = ad_count + 1
        ELSE
          GOTO 100
        END IF
      END DO
      CALL PUSHCONTROL1B_FV(0)
      CALL PUSHINTEGER(ad_count)
      CALL PUSHCONTROL1B_FV(0)
      GOTO 110
 100  CALL PUSHCONTROL1B_FV(1)
      CALL PUSHINTEGER(ad_count)
      CALL PUSHCONTROL1B_FV(0)
 110  rf_initialized = .true.
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
    CALL C2L_ORD2_FWD(u, v, ua, va, gridstruct, npz, gridstruct%&
&               grid_type, bd)
!allocate( u2f(isd:ied,jsd:jed,kmax) )
!$OMP parallel do default(none) shared(is,ie,js,je,kmax,pm,rf_cutoff,hydrostatic,ua,va,agrid, &
!$OMP                                  u2f,rf,w)
    DO k=1,kmax
! p check
      IF (pm(k) .LT. rf_cutoff) THEN
        DO j=js,je
          IF (hydrostatic) THEN
            DO i=is,ie
              IF (ua(i, j, k) .GE. 0.) THEN
                abs0 = ua(i, j, k)
              ELSE
                abs0 = -ua(i, j, k)
              END IF
              IF (abs0 .GT. 35.*COS(agrid(i, j, 2))) THEN
                u2f(i, j, k) = 1./(1.+rf(k)*SQRT(ua(i, j, k)**2+va(i, j&
&                 , k)**2)/u0)
                CALL PUSHCONTROL1B_FV(1)
              ELSE
                u2f(i, j, k) = 1.
                CALL PUSHCONTROL1B_FV(0)
              END IF
            END DO
            CALL PUSHCONTROL1B_FV(1)
          ELSE
            DO i=is,ie
              IF (ua(i, j, k) .GE. 0.) THEN
                abs1 = ua(i, j, k)
              ELSE
                abs1 = -ua(i, j, k)
              END IF
              IF (w(i, j, k) .GE. 0.) THEN
                abs2 = w(i, j, k)
              ELSE
                abs2 = -w(i, j, k)
              END IF
              IF (abs1 .GT. 35.*COS(agrid(i, j, 2)) .OR. abs2 .GT. 7.5) &
&             THEN
                u2f(i, j, k) = 1./(1.+rf(k)*SQRT(ua(i, j, k)**2+va(i, j&
&                 , k)**2+w(i, j, k)**2)/u0)
                CALL PUSHCONTROL1B_FV(1)
              ELSE
                u2f(i, j, k) = 1.
                CALL PUSHCONTROL1B_FV(0)
              END IF
            END DO
            CALL PUSHCONTROL1B_FV(0)
          END IF
        END DO
        CALL PUSHCONTROL1B_FV(1)
      ELSE
        CALL PUSHCONTROL1B_FV(0)
      END IF
    END DO
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
    CALL MPP_UPDATE_DOMAINS(u2f, domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!$OMP parallel do default(none) shared(is,ie,js,je,kmax,pm,rf_cutoff,w,rf,u,v,u00,v00, &
!$OMP                                  conserve,hydrostatic,pt,ua,va,u2f,cp,rg,ptop,rcv)
    DO k=1,kmax
      IF (pm(k) .LT. rf_cutoff) THEN
!#ifdef HIWPP
!             do j=js,je
!                do i=is,ie
!                   w(i,j,k) = w(i,j,k)/(1.+rf(k))
!                enddo
!             enddo
!             do j=js,je+1
!                do i=is,ie
!                   u(i,j,k) = (u(i,j,k)+rf(k)*u00(i,j,k))/(1.+rf(k))
!                enddo
!             enddo
!             do j=js,je
!                do i=is,ie+1
!                   v(i,j,k) = (v(i,j,k)+rf(k)*v00(i,j,k))/(1.+rf(k))
!                enddo
!             enddo
!#else
! Add heat so as to conserve TE
        IF (conserve) THEN
          IF (hydrostatic) THEN
            DO j=js,je
              DO i=is,ie
                CALL PUSHREALARRAY(pt(i, j, k))
                pt(i, j, k) = pt(i, j, k) + 0.5*(ua(i, j, k)**2+va(i, j&
&                 , k)**2)*(1.-u2f(i, j, k)**2)/(cp-rg*ptop/pm(k))
              END DO
            END DO
            CALL PUSHCONTROL2B_FV(2)
          ELSE
            DO j=js,je
              DO i=is,ie
                CALL PUSHREALARRAY(pt(i, j, k))
                pt(i, j, k) = pt(i, j, k) + 0.5*(ua(i, j, k)**2+va(i, j&
&                 , k)**2+w(i, j, k)**2)*(1.-u2f(i, j, k)**2)*rcv
              END DO
            END DO
            CALL PUSHCONTROL2B_FV(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B_FV(0)
        END IF
        DO j=js,je+1
          DO i=is,ie
            CALL PUSHREALARRAY(u(i, j, k))
            u(i, j, k) = 0.5*(u2f(i, j-1, k)+u2f(i, j, k))*u(i, j, k)
          END DO
        END DO
        DO j=js,je
          DO i=is,ie+1
            CALL PUSHREALARRAY(v(i, j, k))
            v(i, j, k) = 0.5*(u2f(i-1, j, k)+u2f(i, j, k))*v(i, j, k)
          END DO
        END DO
        IF (.NOT.hydrostatic) THEN
          DO j=js,je
            DO i=is,ie
              CALL PUSHREALARRAY(w(i, j, k))
              w(i, j, k) = u2f(i, j, k)*w(i, j, k)
            END DO
          END DO
          CALL PUSHCONTROL2B_FV(2)
        ELSE
          CALL PUSHCONTROL2B_FV(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B_FV(0)
      END IF
    END DO
    CALL PUSHINTEGER(js)
    CALL PUSHREALARRAY(rf, 8*npz/8)
    CALL PUSHREALARRAY(rcv)
    CALL PUSHINTEGER(ie)
    CALL PUSHINTEGER(is)
    CALL PUSHINTEGER(je)
    CALL PUSHREALARRAY(u2f, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                 kmax/8)
  END SUBROUTINE RAYLEIGH_SUPER_FWD
!  Differentiation of rayleigh_super in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_e
!dge_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mo
!d.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn
!_core_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_
!mod.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.c
!ubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_tota
!l_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv
!_mapz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.st
!eepz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem
!_solver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver 
!nh_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.dive
!rgence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_
!core_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_
!core_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp
!_core_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: u v w ua va pt
!   with respect to varying inputs: u v w ua va pt
  SUBROUTINE RAYLEIGH_SUPER_BWD(dt, npx, npy, npz, ks, pm, phis, tau, u&
&   , u_ad, v, v_ad, w, w_ad, pt, pt_ad, ua, ua_ad, va, va_ad, delz, &
&   agrid, cp, rg, ptop, hydrostatic, conserve, rf_cutoff, gridstruct, &
&   domain, bd)
    IMPLICIT NONE
!#endif
!deallocate ( u2f )
    REAL(fvprc), INTENT(IN) :: dt
    REAL(fvprc), INTENT(IN) :: tau
    REAL(fvprc), INTENT(IN) :: cp, rg, ptop, rf_cutoff
    INTEGER, INTENT(IN) :: npx, npy, npz, ks
    REAL(fvprc), DIMENSION(npz), INTENT(IN) :: pm
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: conserve
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: u_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: v_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%isd, bd%jsd:bd%jsd, npz)
    REAL(fvprc), INTENT(INOUT) :: w_ad(bd%isd:bd%isd, bd%jsd:bd%jsd, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: pt_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: ua_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: va_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(IN) :: agrid(bd%isd:bd%ied, bd%jsd:bd%jed, 2)
    REAL(fvprc), INTENT(IN) :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
    TYPE(FV_GRID_TYPE), INTENT(IN) :: gridstruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    REAL(fvprc) :: u2f(bd%isd:bd%ied, bd%jsd:bd%jed, kmax)
    REAL(fvprc) :: u2f_ad(bd%isd:bd%ied, bd%jsd:bd%jed, kmax)
    REAL(fvprc), PARAMETER :: u0=60.
    REAL(fvprc), PARAMETER :: sday=86400.
    REAL(fvprc) :: rcv, tau0
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    REAL(fvprc) :: rf(npz)
    INTRINSIC LOG
    INTRINSIC SIN
    INTRINSIC ABS
    INTRINSIC COS
    INTRINSIC SQRT
    REAL(fvprc) :: abs0
    REAL(fvprc) :: abs1
    REAL(fvprc) :: abs2
    REAL(fvprc) :: temp
    REAL(fvprc) :: temp0
    REAL(fvprc) :: temp1
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp2
    REAL(fvprc) :: temp3
    REAL(fvprc) :: temp4
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp5
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp_ad4
    REAL(fvprc) :: temp_ad5
    INTEGER :: ad_count
    INTEGER :: i0
    INTEGER :: branch
    CALL POPREALARRAY(u2f, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                kmax/8)
    CALL POPINTEGER(je)
    CALL POPINTEGER(is)
    CALL POPINTEGER(ie)
    CALL POPREALARRAY(rcv)
    CALL POPREALARRAY(rf, 8*npz/8)
    CALL POPINTEGER(js)
    u2f_ad = 0.0_FVPRC
    DO k=kmax,1,-1
      CALL POPCONTROL2B_FV(branch)
      IF (branch .NE. 0) THEN
        IF (branch .NE. 1) THEN
          DO j=je,js,-1
            DO i=ie,is,-1
              CALL POPREALARRAY(w(i, j, k))
              u2f_ad(i, j, k) = u2f_ad(i, j, k) + w(i, j, k)*w_ad(i, j, &
&               k)
              w_ad(i, j, k) = u2f(i, j, k)*w_ad(i, j, k)
            END DO
          END DO
        END IF
        DO j=je,js,-1
          DO i=ie+1,is,-1
            CALL POPREALARRAY(v(i, j, k))
            temp_ad5 = 0.5*v(i, j, k)*v_ad(i, j, k)
            u2f_ad(i-1, j, k) = u2f_ad(i-1, j, k) + temp_ad5
            u2f_ad(i, j, k) = u2f_ad(i, j, k) + temp_ad5
            v_ad(i, j, k) = 0.5*(u2f(i-1, j, k)+u2f(i, j, k))*v_ad(i, j&
&             , k)
          END DO
        END DO
        DO j=je+1,js,-1
          DO i=ie,is,-1
            CALL POPREALARRAY(u(i, j, k))
            temp_ad4 = 0.5*u(i, j, k)*u_ad(i, j, k)
            u2f_ad(i, j-1, k) = u2f_ad(i, j-1, k) + temp_ad4
            u2f_ad(i, j, k) = u2f_ad(i, j, k) + temp_ad4
            u_ad(i, j, k) = 0.5*(u2f(i, j-1, k)+u2f(i, j, k))*u_ad(i, j&
&             , k)
          END DO
        END DO
        CALL POPCONTROL2B_FV(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            DO j=je,js,-1
              DO i=ie,is,-1
                CALL POPREALARRAY(pt(i, j, k))
                temp_ad2 = rcv*0.5*pt_ad(i, j, k)
                temp_ad3 = (1.-u2f(i, j, k)**2)*temp_ad2
                ua_ad(i, j, k) = ua_ad(i, j, k) + 2*ua(i, j, k)*temp_ad3
                va_ad(i, j, k) = va_ad(i, j, k) + 2*va(i, j, k)*temp_ad3
                w_ad(i, j, k) = w_ad(i, j, k) + 2*w(i, j, k)*temp_ad3
                u2f_ad(i, j, k) = u2f_ad(i, j, k) - (ua(i, j, k)**2+va(i&
&                 , j, k)**2+w(i, j, k)**2)*2*u2f(i, j, k)*temp_ad2
              END DO
            END DO
          ELSE
            DO j=je,js,-1
              DO i=ie,is,-1
                CALL POPREALARRAY(pt(i, j, k))
                temp5 = cp - rg*ptop/pm(k)
                temp_ad1 = 0.5*(1.-u2f(i, j, k)**2)*pt_ad(i, j, k)/temp5
                ua_ad(i, j, k) = ua_ad(i, j, k) + 2*ua(i, j, k)*temp_ad1
                va_ad(i, j, k) = va_ad(i, j, k) + 2*va(i, j, k)*temp_ad1
                u2f_ad(i, j, k) = u2f_ad(i, j, k) - (ua(i, j, k)**2+va(i&
&                 , j, k)**2)*0.5*2*u2f(i, j, k)*pt_ad(i, j, k)/temp5
              END DO
            END DO
          END IF
        END IF
      END IF
    END DO
    CALL MPP_UPDATE_DOMAINS_ADM(u2f, u2f_ad, domain)
    DO k=kmax,1,-1
      CALL POPCONTROL1B_FV(branch)
      IF (branch .NE. 0) THEN
        DO j=je,js,-1
          CALL POPCONTROL1B_FV(branch)
          IF (branch .EQ. 0) THEN
            DO i=ie,is,-1
              CALL POPCONTROL1B_FV(branch)
              IF (branch .EQ. 0) THEN
                u2f_ad(i, j, k) = 0.0_FVPRC
              ELSE
                temp2 = ua(i, j, k)**2 + va(i, j, k)**2 + w(i, j, k)**2
                temp4 = SQRT(temp2)
                temp3 = rf(k)*temp4/u0 + 1.
                IF (temp2 .EQ. 0.0_FVPRC) THEN
                  temp_ad0 = 0.0
                ELSE
                  temp_ad0 = -(rf(k)*u2f_ad(i, j, k)/(u0*temp3**2*2.0*&
&                   temp4))
                END IF
                ua_ad(i, j, k) = ua_ad(i, j, k) + 2*ua(i, j, k)*temp_ad0
                va_ad(i, j, k) = va_ad(i, j, k) + 2*va(i, j, k)*temp_ad0
                w_ad(i, j, k) = w_ad(i, j, k) + 2*w(i, j, k)*temp_ad0
                u2f_ad(i, j, k) = 0.0_FVPRC
              END IF
            END DO
          ELSE
            DO i=ie,is,-1
              CALL POPCONTROL1B_FV(branch)
              IF (branch .EQ. 0) THEN
                u2f_ad(i, j, k) = 0.0_FVPRC
              ELSE
                temp = ua(i, j, k)**2 + va(i, j, k)**2
                temp1 = SQRT(temp)
                temp0 = rf(k)*temp1/u0 + 1.
                IF (temp .EQ. 0.0_FVPRC) THEN
                  temp_ad = 0.0
                ELSE
                  temp_ad = -(rf(k)*u2f_ad(i, j, k)/(u0*temp0**2*2.0*&
&                   temp1))
                END IF
                ua_ad(i, j, k) = ua_ad(i, j, k) + 2*ua(i, j, k)*temp_ad
                va_ad(i, j, k) = va_ad(i, j, k) + 2*va(i, j, k)*temp_ad
                u2f_ad(i, j, k) = 0.0_FVPRC
              END IF
            END DO
          END IF
        END DO
      END IF
    END DO
    CALL C2L_ORD2_BWD(u, u_ad, v, v_ad, ua, ua_ad, va, va_ad, gridstruct&
&               , npz, gridstruct%grid_type, bd)
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPINTEGER(ad_count)
      DO i0=1,ad_count
        IF (i0 .EQ. 1) CALL POPCONTROL1B_FV(branch)
      END DO
    END IF
  END SUBROUTINE RAYLEIGH_SUPER_BWD
  SUBROUTINE RAYLEIGH_SUPER(dt, npx, npy, npz, ks, pm, phis, tau, u, v, &
&   w, pt, ua, va, delz, agrid, cp, rg, ptop, hydrostatic, conserve, &
&   rf_cutoff, gridstruct, domain, bd)
    IMPLICIT NONE
!#endif
!deallocate ( u2f )
    REAL(fvprc), INTENT(IN) :: dt
! time scale (days)
    REAL(fvprc), INTENT(IN) :: tau
    REAL(fvprc), INTENT(IN) :: cp, rg, ptop, rf_cutoff
    INTEGER, INTENT(IN) :: npx, npy, npz, ks
    REAL(fvprc), DIMENSION(npz), INTENT(IN) :: pm
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: conserve
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! D grid zonal wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
! D grid meridional wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
! cell center vertical wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%isd, bd%jsd:bd%jsd, npz)
! temp
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! 
    REAL(fvprc), INTENT(INOUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! 
    REAL(fvprc), INTENT(INOUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! delta-height (m); non-hydrostatic only
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(IN) :: agrid(bd%isd:bd%ied, bd%jsd:bd%jed, 2)
! Surface geopotential (g*Z_surf)
    REAL(fvprc), INTENT(IN) :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
    TYPE(FV_GRID_TYPE), INTENT(IN) :: gridstruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
!
    REAL(fvprc) :: u2f(bd%isd:bd%ied, bd%jsd:bd%jed, kmax)
! scaling velocity
    REAL(fvprc), PARAMETER :: u0=60.
    REAL(fvprc), PARAMETER :: sday=86400.
    REAL(fvprc) :: rcv, tau0
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    REAL(fvprc) :: rf(npz)
    INTRINSIC LOG
    INTRINSIC SIN
    INTRINSIC ABS
    INTRINSIC COS
    INTRINSIC SQRT
    REAL(fvprc) :: abs0
    REAL(fvprc) :: abs1
    REAL(fvprc) :: abs2
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    rcv = 1./(cp-rg)
    IF (.NOT.rf_initialized) THEN
!#ifdef HIWPP
!          allocate ( u00(is:ie,  js:je+1,npz) )
!          allocate ( v00(is:ie+1,js:je  ,npz) )
!!$OMP parallel do default(none) shared(is,ie,js,je,npz,u00,u,v00,v)
!          do k=1,npz
!             do j=js,je+1
!                do i=is,ie
!                   u00(i,j,k) = u(i,j,k)
!                enddo
!             enddo
!             do j=js,je
!                do i=is,ie+1
!                   v00(i,j,k) = v(i,j,k)
!                enddo
!             enddo
!          enddo
!#endif
!#ifdef SMALL_EARTH
!          tau0 = tau
!#else
      tau0 = tau*sday
!#endif
!allocate( rf(npz) )
      rf(:) = 0.
!if( is_master() ) write(6,*) 'Rayleigh friction E-folding time (days):'
      DO k=1,npz
        IF (pm(k) .LT. rf_cutoff) THEN
          rf(k) = dt/tau0*SIN(0.5*pi*LOG(rf_cutoff/pm(k))/LOG(rf_cutoff/&
&           ptop))**2
!if( is_master() ) write(6,*) k, 0.01*pm(k), dt/(rf(k)*sday)
          kmax = k
        ELSE
          GOTO 100
        END IF
      END DO
 100  rf_initialized = .true.
    END IF
    CALL C2L_ORD2(u, v, ua, va, gridstruct, npz, gridstruct%grid_type, &
&           bd)
!allocate( u2f(isd:ied,jsd:jed,kmax) )
!$OMP parallel do default(none) shared(is,ie,js,je,kmax,pm,rf_cutoff,hydrostatic,ua,va,agrid, &
!$OMP                                  u2f,rf,w)
    DO k=1,kmax
! p check
      IF (pm(k) .LT. rf_cutoff) THEN
        DO j=js,je
          IF (hydrostatic) THEN
            DO i=is,ie
              IF (ua(i, j, k) .GE. 0.) THEN
                abs0 = ua(i, j, k)
              ELSE
                abs0 = -ua(i, j, k)
              END IF
              IF (abs0 .GT. 35.*COS(agrid(i, j, 2))) THEN
                u2f(i, j, k) = 1./(1.+rf(k)*SQRT(ua(i, j, k)**2+va(i, j&
&                 , k)**2)/u0)
              ELSE
                u2f(i, j, k) = 1.
              END IF
            END DO
          ELSE
            DO i=is,ie
              IF (ua(i, j, k) .GE. 0.) THEN
                abs1 = ua(i, j, k)
              ELSE
                abs1 = -ua(i, j, k)
              END IF
              IF (w(i, j, k) .GE. 0.) THEN
                abs2 = w(i, j, k)
              ELSE
                abs2 = -w(i, j, k)
              END IF
              IF (abs1 .GT. 35.*COS(agrid(i, j, 2)) .OR. abs2 .GT. 7.5) &
&             THEN
                u2f(i, j, k) = 1./(1.+rf(k)*SQRT(ua(i, j, k)**2+va(i, j&
&                 , k)**2+w(i, j, k)**2)/u0)
              ELSE
                u2f(i, j, k) = 1.
              END IF
            END DO
          END IF
        END DO
      END IF
    END DO
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
    CALL MPP_UPDATE_DOMAINS(u2f, domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!$OMP parallel do default(none) shared(is,ie,js,je,kmax,pm,rf_cutoff,w,rf,u,v,u00,v00, &
!$OMP                                  conserve,hydrostatic,pt,ua,va,u2f,cp,rg,ptop,rcv)
    DO k=1,kmax
      IF (pm(k) .LT. rf_cutoff) THEN
!#ifdef HIWPP
!             do j=js,je
!                do i=is,ie
!                   w(i,j,k) = w(i,j,k)/(1.+rf(k))
!                enddo
!             enddo
!             do j=js,je+1
!                do i=is,ie
!                   u(i,j,k) = (u(i,j,k)+rf(k)*u00(i,j,k))/(1.+rf(k))
!                enddo
!             enddo
!             do j=js,je
!                do i=is,ie+1
!                   v(i,j,k) = (v(i,j,k)+rf(k)*v00(i,j,k))/(1.+rf(k))
!                enddo
!             enddo
!#else
! Add heat so as to conserve TE
        IF (conserve) THEN
          IF (hydrostatic) THEN
            DO j=js,je
              DO i=is,ie
                pt(i, j, k) = pt(i, j, k) + 0.5*(ua(i, j, k)**2+va(i, j&
&                 , k)**2)*(1.-u2f(i, j, k)**2)/(cp-rg*ptop/pm(k))
              END DO
            END DO
          ELSE
            DO j=js,je
              DO i=is,ie
                pt(i, j, k) = pt(i, j, k) + 0.5*(ua(i, j, k)**2+va(i, j&
&                 , k)**2+w(i, j, k)**2)*(1.-u2f(i, j, k)**2)*rcv
              END DO
            END DO
          END IF
        END IF
        DO j=js,je+1
          DO i=is,ie
            u(i, j, k) = 0.5*(u2f(i, j-1, k)+u2f(i, j, k))*u(i, j, k)
          END DO
        END DO
        DO j=js,je
          DO i=is,ie+1
            v(i, j, k) = 0.5*(u2f(i-1, j, k)+u2f(i, j, k))*v(i, j, k)
          END DO
        END DO
        IF (.NOT.hydrostatic) THEN
          DO j=js,je
            DO i=is,ie
              w(i, j, k) = u2f(i, j, k)*w(i, j, k)
            END DO
          END DO
        END IF
      END IF
    END DO
  END SUBROUTINE RAYLEIGH_SUPER
!  Differentiation of rayleigh_friction in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b
!_edge_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_
!mod.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p d
!yn_core_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamic
!s_mod.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod
!.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_to
!tal_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer 
!fv_mapz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.
!steepz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.ri
!em_solver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solve
!r nh_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.di
!vergence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners s
!w_core_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d t
!p_core_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm 
!tp_core_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: u v w ua delz va pt
!   with respect to varying inputs: u v w ua delz va pt
  SUBROUTINE RAYLEIGH_FRICTION_FWD(dt, npx, npy, npz, ks, pm, tau, u, v&
&   , w, pt, ua, va, delz, cp, rg, ptop, hydrostatic, conserve, &
&   rf_cutoff, gridstruct, domain, bd)
    IMPLICIT NONE
!deallocate ( u2f )
    REAL(fvprc), INTENT(IN) :: dt
! time scale (days)
    REAL(fvprc), INTENT(IN) :: tau
    REAL(fvprc), INTENT(IN) :: cp, rg, ptop, rf_cutoff
    INTEGER, INTENT(IN) :: npx, npy, npz, ks
    REAL(fvprc), DIMENSION(npz), INTENT(IN) :: pm
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: conserve
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! D grid zonal wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
! D grid meridional wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
! cell center vertical wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! temp
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! 
    REAL(fvprc), INTENT(INOUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! 
    REAL(fvprc), INTENT(INOUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! delta-height (m); non-hydrostatic only
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    TYPE(FV_GRID_TYPE), INTENT(IN) :: gridstruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
! local:
    REAL(fvprc) :: u2f(bd%isd:bd%ied, bd%jsd:bd%jed, kmax)
    REAL(fvprc), PARAMETER :: sday=86400.
! scaling velocity  **2
    REAL(fvprc), PARAMETER :: u000=4900.
    REAL(fvprc) :: rcv
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    REAL(fvprc) :: rf(npz)
    INTRINSIC LOG
    INTRINSIC SIN
    INTRINSIC SQRT
    INTEGER :: ad_count
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    rcv = 1./(cp-rg)
    IF (.NOT.rf_initialized) THEN
      ad_count = 1
!allocate( rf(npz) )
!if( is_master() ) write(6,*) 'Rayleigh friction E-folding time (days):'
      DO k=1,npz
        IF (pm(k) .LT. rf_cutoff) THEN
          rf(k) = dt/(tau*sday)*SIN(0.5*pi*LOG(rf_cutoff/pm(k))/LOG(&
&           rf_cutoff/ptop))**2
!if( is_master() ) write(6,*) k, 0.01*pm(k), dt/(rf(k)*sday)
          kmax = k
          ad_count = ad_count + 1
        ELSE
          GOTO 100
        END IF
      END DO
      CALL PUSHCONTROL1B_FV(0)
      CALL PUSHINTEGER(ad_count)
      CALL PUSHCONTROL1B_FV(0)
      GOTO 110
 100  CALL PUSHCONTROL1B_FV(1)
      CALL PUSHINTEGER(ad_count)
      CALL PUSHCONTROL1B_FV(0)
 110  rf_initialized = .true.
    ELSE
      CALL PUSHCONTROL1B_FV(1)
    END IF
!allocate( u2f(isd:ied,jsd:jed,kmax) )
    CALL C2L_ORD2_FWD(u, v, ua, va, gridstruct, npz, gridstruct%&
&               grid_type, bd)
    u2f = 0.
!$OMP parallel do default(none) shared(is,ie,js,je,kmax,u2f,hydrostatic,ua,va,w)
    DO k=1,kmax
      IF (hydrostatic) THEN
        DO j=js,je
          DO i=is,ie
            u2f(i, j, k) = ua(i, j, k)**2 + va(i, j, k)**2
          END DO
        END DO
        CALL PUSHCONTROL1B_FV(1)
      ELSE
        DO j=js,je
          DO i=is,ie
            u2f(i, j, k) = ua(i, j, k)**2 + va(i, j, k)**2 + w(i, j, k)&
&             **2
          END DO
        END DO
        CALL PUSHCONTROL1B_FV(0)
      END IF
    END DO
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
    CALL MPP_UPDATE_DOMAINS(u2f, domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!$OMP parallel do default(none) shared(is,ie,js,je,kmax,conserve,hydrostatic,pt,u2f,cp,rg, &
!$OMP                                  ptop,pm,rf,delz,rcv,u,v,w)
    DO k=1,kmax
      IF (conserve) THEN
        IF (hydrostatic) THEN
          DO j=js,je
            DO i=is,ie
              CALL PUSHREALARRAY(pt(i, j, k))
              pt(i, j, k) = pt(i, j, k) + 0.5*u2f(i, j, k)/(cp-rg*ptop/&
&               pm(k))*(1.-1./(1.+rf(k)*SQRT(u2f(i, j, k)/u000))**2)
            END DO
          END DO
          CALL PUSHCONTROL2B_FV(2)
        ELSE
          DO j=js,je
            DO i=is,ie
              CALL PUSHREALARRAY(delz(i, j, k))
              delz(i, j, k) = delz(i, j, k)/pt(i, j, k)
              CALL PUSHREALARRAY(pt(i, j, k))
              pt(i, j, k) = pt(i, j, k) + 0.5*u2f(i, j, k)*rcv*(1.-1./(&
&               1.+rf(k)*SQRT(u2f(i, j, k)/u000))**2)
              CALL PUSHREALARRAY(delz(i, j, k))
              delz(i, j, k) = delz(i, j, k)*pt(i, j, k)
            END DO
          END DO
          CALL PUSHCONTROL2B_FV(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B_FV(0)
      END IF
      DO j=js-1,je+1
        DO i=is-1,ie+1
          CALL PUSHREALARRAY(u2f(i, j, k))
          u2f(i, j, k) = rf(k)*SQRT(u2f(i, j, k)/u000)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          CALL PUSHREALARRAY(u(i, j, k))
          u(i, j, k) = u(i, j, k)/(1.+0.5*(u2f(i, j-1, k)+u2f(i, j, k)))
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          CALL PUSHREALARRAY(v(i, j, k))
          v(i, j, k) = v(i, j, k)/(1.+0.5*(u2f(i-1, j, k)+u2f(i, j, k)))
        END DO
      END DO
      IF (.NOT.hydrostatic) THEN
        DO j=js,je
          DO i=is,ie
            CALL PUSHREALARRAY(w(i, j, k))
            w(i, j, k) = w(i, j, k)/(1.+u2f(i, j, k))
          END DO
        END DO
        CALL PUSHCONTROL1B_FV(1)
      ELSE
        CALL PUSHCONTROL1B_FV(0)
      END IF
    END DO
    CALL PUSHINTEGER(js)
    CALL PUSHREALARRAY(rf, 8*npz/8)
    CALL PUSHREALARRAY(rcv)
    CALL PUSHINTEGER(ie)
    CALL PUSHINTEGER(is)
    CALL PUSHINTEGER(je)
    CALL PUSHREALARRAY(u2f, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                 kmax/8)
  END SUBROUTINE RAYLEIGH_FRICTION_FWD
!  Differentiation of rayleigh_friction in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2
!b_edge_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core
!_mod.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p 
!dyn_core_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynami
!cs_mod.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mo
!d.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_t
!otal_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer
! fv_mapz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod
!.steepz fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.r
!iem_solver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solv
!er nh_core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.d
!ivergence_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners 
!sw_core_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d 
!tp_core_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm
! tp_core_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: u v w ua delz va pt
!   with respect to varying inputs: u v w ua delz va pt
  SUBROUTINE RAYLEIGH_FRICTION_BWD(dt, npx, npy, npz, ks, pm, tau, u, &
&   u_ad, v, v_ad, w, w_ad, pt, pt_ad, ua, ua_ad, va, va_ad, delz, &
&   delz_ad, cp, rg, ptop, hydrostatic, conserve, rf_cutoff, gridstruct&
&   , domain, bd)
    IMPLICIT NONE
!deallocate ( u2f )
    REAL(fvprc), INTENT(IN) :: dt
    REAL(fvprc), INTENT(IN) :: tau
    REAL(fvprc), INTENT(IN) :: cp, rg, ptop, rf_cutoff
    INTEGER, INTENT(IN) :: npx, npy, npz, ks
    REAL(fvprc), DIMENSION(npz), INTENT(IN) :: pm
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: conserve
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: u_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: v_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: w_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: pt_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: ua_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: va_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: delz_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    TYPE(FV_GRID_TYPE), INTENT(IN) :: gridstruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
    REAL(fvprc) :: u2f(bd%isd:bd%ied, bd%jsd:bd%jed, kmax)
    REAL(fvprc) :: u2f_ad(bd%isd:bd%ied, bd%jsd:bd%jed, kmax)
    REAL(fvprc), PARAMETER :: sday=86400.
    REAL(fvprc), PARAMETER :: u000=4900.
    REAL(fvprc) :: rcv
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    REAL(fvprc) :: rf(npz)
    INTRINSIC LOG
    INTRINSIC SIN
    INTRINSIC SQRT
    REAL(fvprc) :: temp
    REAL(fvprc) :: temp0
    REAL(fvprc) :: temp1
    REAL(fvprc) :: temp2
    REAL(fvprc) :: temp3
    REAL(fvprc) :: temp4
    REAL(fvprc) :: temp5
    REAL(fvprc) :: temp6
    REAL(fvprc) :: temp7
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp8
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp9
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    INTEGER :: ad_count
    INTEGER :: i0
    INTEGER :: branch
    CALL POPREALARRAY(u2f, 8*(bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*&
&                kmax/8)
    CALL POPINTEGER(je)
    CALL POPINTEGER(is)
    CALL POPINTEGER(ie)
    CALL POPREALARRAY(rcv)
    CALL POPREALARRAY(rf, 8*npz/8)
    CALL POPINTEGER(js)
    u2f_ad = 0.0_FVPRC
    DO k=kmax,1,-1
      CALL POPCONTROL1B_FV(branch)
      IF (branch .NE. 0) THEN
        DO j=je,js,-1
          DO i=ie,is,-1
            CALL POPREALARRAY(w(i, j, k))
            temp_ad3 = w_ad(i, j, k)/(u2f(i, j, k)+1.)
            u2f_ad(i, j, k) = u2f_ad(i, j, k) - w(i, j, k)*temp_ad3/(u2f&
&             (i, j, k)+1.)
            w_ad(i, j, k) = temp_ad3
          END DO
        END DO
      END IF
      DO j=je,js,-1
        DO i=ie+1,is,-1
          CALL POPREALARRAY(v(i, j, k))
          temp9 = 0.5*(u2f(i-1, j, k)+u2f(i, j, k)) + 1.
          temp_ad2 = -(v(i, j, k)*0.5*v_ad(i, j, k)/temp9**2)
          u2f_ad(i-1, j, k) = u2f_ad(i-1, j, k) + temp_ad2
          u2f_ad(i, j, k) = u2f_ad(i, j, k) + temp_ad2
          v_ad(i, j, k) = v_ad(i, j, k)/temp9
        END DO
      END DO
      DO j=je+1,js,-1
        DO i=ie,is,-1
          CALL POPREALARRAY(u(i, j, k))
          temp8 = 0.5*(u2f(i, j-1, k)+u2f(i, j, k)) + 1.
          temp_ad1 = -(u(i, j, k)*0.5*u_ad(i, j, k)/temp8**2)
          u2f_ad(i, j-1, k) = u2f_ad(i, j-1, k) + temp_ad1
          u2f_ad(i, j, k) = u2f_ad(i, j, k) + temp_ad1
          u_ad(i, j, k) = u_ad(i, j, k)/temp8
        END DO
      END DO
      DO j=je+1,js-1,-1
        DO i=ie+1,is-1,-1
          CALL POPREALARRAY(u2f(i, j, k))
          IF (u2f(i, j, k)/u000 .EQ. 0.0_FVPRC) THEN
            u2f_ad(i, j, k) = 0.0
          ELSE
            u2f_ad(i, j, k) = rf(k)*u2f_ad(i, j, k)/(2.0*SQRT(u2f(i, j, &
&             k)/u000)*u000)
          END IF
        END DO
      END DO
      CALL POPCONTROL2B_FV(branch)
      IF (branch .NE. 0) THEN
        IF (branch .EQ. 1) THEN
          DO j=je,js,-1
            DO i=ie,is,-1
              CALL POPREALARRAY(delz(i, j, k))
              pt_ad(i, j, k) = pt_ad(i, j, k) + delz(i, j, k)*delz_ad(i&
&               , j, k)
              delz_ad(i, j, k) = pt(i, j, k)*delz_ad(i, j, k)
              CALL POPREALARRAY(pt(i, j, k))
              temp7 = u2f(i, j, k)/u000
              temp6 = SQRT(temp7)
              temp5 = rf(k)*temp6 + 1.
              temp4 = temp5**2
              temp_ad = rcv*0.5*pt_ad(i, j, k)
              IF (temp7 .EQ. 0.0_FVPRC) THEN
                u2f_ad(i, j, k) = u2f_ad(i, j, k) + (1.-1.0/temp4)*&
&                 temp_ad
              ELSE
                u2f_ad(i, j, k) = u2f_ad(i, j, k) + (rf(k)*2*temp5*u2f(i&
&                 , j, k)/(2.0*temp6*temp4**2*u000)-1.0/temp4+1.)*&
&                 temp_ad
              END IF
              CALL POPREALARRAY(delz(i, j, k))
              temp_ad0 = delz_ad(i, j, k)/pt(i, j, k)
              pt_ad(i, j, k) = pt_ad(i, j, k) - delz(i, j, k)*temp_ad0/&
&               pt(i, j, k)
              delz_ad(i, j, k) = temp_ad0
            END DO
          END DO
        ELSE
          DO j=je,js,-1
            DO i=ie,is,-1
              CALL POPREALARRAY(pt(i, j, k))
              temp3 = cp - rg*ptop/pm(k)
              temp2 = u2f(i, j, k)/u000
              temp1 = SQRT(temp2)
              temp0 = rf(k)*temp1 + 1.
              temp = temp0**2
              IF (temp2 .EQ. 0.0_FVPRC) THEN
                u2f_ad(i, j, k) = u2f_ad(i, j, k) + (1.-1.0/temp)*0.5*&
&                 pt_ad(i, j, k)/temp3
              ELSE
                u2f_ad(i, j, k) = u2f_ad(i, j, k) + ((1.-1.0/temp)*0.5/&
&                 temp3+rf(k)*2*temp0*u2f(i, j, k)*0.5/(2.0*temp1*temp**&
&                 2*temp3*u000))*pt_ad(i, j, k)
              END IF
            END DO
          END DO
        END IF
      END IF
    END DO
    CALL MPP_UPDATE_DOMAINS_ADM(u2f, u2f_ad, domain)
    DO k=kmax,1,-1
      CALL POPCONTROL1B_FV(branch)
      IF (branch .EQ. 0) THEN
        DO j=je,js,-1
          DO i=ie,is,-1
            ua_ad(i, j, k) = ua_ad(i, j, k) + 2*ua(i, j, k)*u2f_ad(i, j&
&             , k)
            va_ad(i, j, k) = va_ad(i, j, k) + 2*va(i, j, k)*u2f_ad(i, j&
&             , k)
            w_ad(i, j, k) = w_ad(i, j, k) + 2*w(i, j, k)*u2f_ad(i, j, k)
            u2f_ad(i, j, k) = 0.0_FVPRC
          END DO
        END DO
      ELSE
        DO j=je,js,-1
          DO i=ie,is,-1
            ua_ad(i, j, k) = ua_ad(i, j, k) + 2*ua(i, j, k)*u2f_ad(i, j&
&             , k)
            va_ad(i, j, k) = va_ad(i, j, k) + 2*va(i, j, k)*u2f_ad(i, j&
&             , k)
            u2f_ad(i, j, k) = 0.0_FVPRC
          END DO
        END DO
      END IF
    END DO
    CALL C2L_ORD2_BWD(u, u_ad, v, v_ad, ua, ua_ad, va, va_ad, gridstruct&
&               , npz, gridstruct%grid_type, bd)
    CALL POPCONTROL1B_FV(branch)
    IF (branch .EQ. 0) THEN
      CALL POPINTEGER(ad_count)
      DO i0=1,ad_count
        IF (i0 .EQ. 1) CALL POPCONTROL1B_FV(branch)
      END DO
    END IF
  END SUBROUTINE RAYLEIGH_FRICTION_BWD
  SUBROUTINE RAYLEIGH_FRICTION(dt, npx, npy, npz, ks, pm, tau, u, v, w, &
&   pt, ua, va, delz, cp, rg, ptop, hydrostatic, conserve, rf_cutoff, &
&   gridstruct, domain, bd)
    IMPLICIT NONE
!deallocate ( u2f )
    REAL(fvprc), INTENT(IN) :: dt
! time scale (days)
    REAL(fvprc), INTENT(IN) :: tau
    REAL(fvprc), INTENT(IN) :: cp, rg, ptop, rf_cutoff
    INTEGER, INTENT(IN) :: npx, npy, npz, ks
    REAL(fvprc), DIMENSION(npz), INTENT(IN) :: pm
    LOGICAL, INTENT(IN) :: hydrostatic
    LOGICAL, INTENT(IN) :: conserve
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
! D grid zonal wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
! D grid meridional wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
! cell center vertical wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! temp
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! 
    REAL(fvprc), INTENT(INOUT) :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! 
    REAL(fvprc), INTENT(INOUT) :: va(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
! delta-height (m); non-hydrostatic only
    REAL(fvprc), INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    TYPE(FV_GRID_TYPE), INTENT(IN) :: gridstruct
    TYPE(DOMAIN2D), INTENT(INOUT) :: domain
! local:
    REAL(fvprc) :: u2f(bd%isd:bd%ied, bd%jsd:bd%jed, kmax)
    REAL(fvprc), PARAMETER :: sday=86400.
! scaling velocity  **2
    REAL(fvprc), PARAMETER :: u000=4900.
    REAL(fvprc) :: rcv
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
    INTEGER :: isd, ied, jsd, jed
    REAL(fvprc) :: rf(npz)
    INTRINSIC LOG
    INTRINSIC SIN
    INTRINSIC SQRT
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    isd = bd%isd
    ied = bd%ied
    jsd = bd%jsd
    jed = bd%jed
    rcv = 1./(cp-rg)
    IF (.NOT.rf_initialized) THEN
!allocate( rf(npz) )
!if( is_master() ) write(6,*) 'Rayleigh friction E-folding time (days):'
      DO k=1,npz
        IF (pm(k) .LT. rf_cutoff) THEN
          rf(k) = dt/(tau*sday)*SIN(0.5*pi*LOG(rf_cutoff/pm(k))/LOG(&
&           rf_cutoff/ptop))**2
!if( is_master() ) write(6,*) k, 0.01*pm(k), dt/(rf(k)*sday)
          kmax = k
        ELSE
          GOTO 100
        END IF
      END DO
 100  rf_initialized = .true.
    END IF
!allocate( u2f(isd:ied,jsd:jed,kmax) )
    CALL C2L_ORD2(u, v, ua, va, gridstruct, npz, gridstruct%grid_type, &
&           bd)
    u2f = 0.
!$OMP parallel do default(none) shared(is,ie,js,je,kmax,u2f,hydrostatic,ua,va,w)
    DO k=1,kmax
      IF (hydrostatic) THEN
        DO j=js,je
          DO i=is,ie
            u2f(i, j, k) = ua(i, j, k)**2 + va(i, j, k)**2
          END DO
        END DO
      ELSE
        DO j=js,je
          DO i=is,ie
            u2f(i, j, k) = ua(i, j, k)**2 + va(i, j, k)**2 + w(i, j, k)&
&             **2
          END DO
        END DO
      END IF
    END DO
!if (fv_timing_onoff) call timing_on('COMM_TOTAL')
    CALL MPP_UPDATE_DOMAINS(u2f, domain)
!if (fv_timing_onoff) call timing_off('COMM_TOTAL')
!$OMP parallel do default(none) shared(is,ie,js,je,kmax,conserve,hydrostatic,pt,u2f,cp,rg, &
!$OMP                                  ptop,pm,rf,delz,rcv,u,v,w)
    DO k=1,kmax
      IF (conserve) THEN
        IF (hydrostatic) THEN
          DO j=js,je
            DO i=is,ie
              pt(i, j, k) = pt(i, j, k) + 0.5*u2f(i, j, k)/(cp-rg*ptop/&
&               pm(k))*(1.-1./(1.+rf(k)*SQRT(u2f(i, j, k)/u000))**2)
            END DO
          END DO
        ELSE
          DO j=js,je
            DO i=is,ie
              delz(i, j, k) = delz(i, j, k)/pt(i, j, k)
              pt(i, j, k) = pt(i, j, k) + 0.5*u2f(i, j, k)*rcv*(1.-1./(&
&               1.+rf(k)*SQRT(u2f(i, j, k)/u000))**2)
              delz(i, j, k) = delz(i, j, k)*pt(i, j, k)
            END DO
          END DO
        END IF
      END IF
      DO j=js-1,je+1
        DO i=is-1,ie+1
          u2f(i, j, k) = rf(k)*SQRT(u2f(i, j, k)/u000)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          u(i, j, k) = u(i, j, k)/(1.+0.5*(u2f(i, j-1, k)+u2f(i, j, k)))
        END DO
      END DO
      DO j=js,je
        DO i=is,ie+1
          v(i, j, k) = v(i, j, k)/(1.+0.5*(u2f(i-1, j, k)+u2f(i, j, k)))
        END DO
      END DO
      IF (.NOT.hydrostatic) THEN
        DO j=js,je
          DO i=is,ie
            w(i, j, k) = w(i, j, k)/(1.+u2f(i, j, k))
          END DO
        END DO
      END IF
    END DO
  END SUBROUTINE RAYLEIGH_FRICTION
!  Differentiation of compute_aam in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_
!mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe
!_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_cor
!e_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.
!rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed
!_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_en
!ergy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_map
!z_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz
! fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_sol
!ver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_c
!ore_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergen
!ce_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core
!_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core
!_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_cor
!e_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: u v delp ua aam va m_fac ps
!   with respect to varying inputs: u v delp ua aam m_fac ps
  SUBROUTINE COMPUTE_AAM_FWD(npz, is, ie, js, je, isd, ied, jsd, jed, &
&   gridstruct, bd, ptop, ua, va, u, v, delp, aam, ps, m_fac)
    IMPLICIT NONE
! Compute vertically (mass) integrated Atmospheric Angular Momentum
    INTEGER, INTENT(IN) :: npz
    INTEGER, INTENT(IN) :: is, ie, js, je
    INTEGER, INTENT(IN) :: isd, ied, jsd, jed
    REAL(fvprc), INTENT(IN) :: ptop
! D grid zonal wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: u(isd:ied, jsd:jed+1, npz)
! D grid meridional wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: v(isd:ied+1, jsd:jed, npz)
    REAL(fvprc), INTENT(INOUT) :: delp(isd:ied, jsd:jed, npz)
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(INOUT) :: ua, &
&   va
    REAL(fvprc) :: aam(is:ie, js:je)
    REAL(fvprc) :: m_fac(is:ie, js:je)
    REAL(fvprc) :: ps(isd:ied, jsd:jed)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    TYPE(FV_GRID_TYPE), INTENT(IN) :: gridstruct
! local:
    REAL(fvprc), DIMENSION(is:ie) :: r1, r2, dm
    INTEGER :: i, j, k
    INTRINSIC COS
    CALL C2L_ORD2_FWD(u, v, ua, va, gridstruct, npz, gridstruct%&
&               grid_type, bd)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,gridstruct,aam,m_fac,ps,ptop,delp,agrav,ua) &
!$OMP                          private(r1, r2, dm)
    DO j=js,je
      DO i=is,ie
        CALL PUSHREALARRAY(r1(i))
        r1(i) = radius*COS(gridstruct%agrid(i, j, 2))
        CALL PUSHREALARRAY(r2(i))
        r2(i) = r1(i)*r1(i)
        aam(i, j) = 0.
        m_fac(i, j) = 0.
        ps(i, j) = ptop
      END DO
      DO k=1,npz
        DO i=is,ie
          CALL PUSHREALARRAY(dm(i))
          dm(i) = delp(i, j, k)
          ps(i, j) = ps(i, j) + dm(i)
          dm(i) = dm(i)*agrav
          aam(i, j) = aam(i, j) + (r2(i)*omega+r1(i)*ua(i, j, k))*dm(i)
          m_fac(i, j) = m_fac(i, j) + dm(i)*r2(i)
        END DO
      END DO
    END DO
    CALL PUSHREALARRAY(dm, 8*(ie-is+1)/8)
    CALL PUSHREALARRAY(r1, 8*(ie-is+1)/8)
    CALL PUSHREALARRAY(r2, 8*(ie-is+1)/8)
  END SUBROUTINE COMPUTE_AAM_FWD
!  Differentiation of compute_aam in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge
!_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.p
!e_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_co
!re_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod
!.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cube
!d_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_e
!nergy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_ma
!pz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steep
!z fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_so
!lver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_
!core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.diverge
!nce_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_cor
!e_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_cor
!e_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_co
!re_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: u v delp ua aam va m_fac ps
!   with respect to varying inputs: u v delp ua aam m_fac ps
  SUBROUTINE COMPUTE_AAM_BWD(npz, is, ie, js, je, isd, ied, jsd, jed, &
&   gridstruct, bd, ptop, ua, ua_ad, va, va_ad, u, u_ad, v, v_ad, delp, &
&   delp_ad, aam, aam_ad, ps, ps_ad, m_fac, m_fac_ad)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npz
    INTEGER, INTENT(IN) :: is, ie, js, je
    INTEGER, INTENT(IN) :: isd, ied, jsd, jed
    REAL(fvprc), INTENT(IN) :: ptop
    REAL(fvprc), INTENT(INOUT) :: u(isd:ied, jsd:jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: u_ad(isd:ied, jsd:jed+1, npz)
    REAL(fvprc), INTENT(INOUT) :: v(isd:ied+1, jsd:jed, npz)
    REAL(fvprc), INTENT(INOUT) :: v_ad(isd:ied+1, jsd:jed, npz)
    REAL(fvprc), INTENT(INOUT) :: delp(isd:ied, jsd:jed, npz)
    REAL(fvprc), INTENT(INOUT) :: delp_ad(isd:ied, jsd:jed, npz)
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(INOUT) :: ua, &
&   va
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(INOUT) :: &
&   ua_ad, va_ad
    REAL(fvprc) :: aam(is:ie, js:je)
    REAL(fvprc) :: aam_ad(is:ie, js:je)
    REAL(fvprc) :: m_fac(is:ie, js:je)
    REAL(fvprc) :: m_fac_ad(is:ie, js:je)
    REAL(fvprc) :: ps(isd:ied, jsd:jed)
    REAL(fvprc) :: ps_ad(isd:ied, jsd:jed)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    TYPE(FV_GRID_TYPE), INTENT(IN) :: gridstruct
    REAL(fvprc), DIMENSION(is:ie) :: r1, r2, dm
    REAL(fvprc), DIMENSION(is:ie) :: dm_ad
    INTEGER :: i, j, k
    INTRINSIC COS
    CALL POPREALARRAY(r2, 8*(ie-is+1)/8)
    CALL POPREALARRAY(r1, 8*(ie-is+1)/8)
    CALL POPREALARRAY(dm, 8*(ie-is+1)/8)
    dm_ad = 0.0_FVPRC
    DO j=je,js,-1
      DO k=npz,1,-1
        DO i=ie,is,-1
          dm_ad(i) = dm_ad(i) + (r2(i)*omega+r1(i)*ua(i, j, k))*aam_ad(i&
&           , j) + r2(i)*m_fac_ad(i, j)
          ua_ad(i, j, k) = ua_ad(i, j, k) + dm(i)*r1(i)*aam_ad(i, j)
          dm_ad(i) = ps_ad(i, j) + agrav*dm_ad(i)
          CALL POPREALARRAY(dm(i))
          delp_ad(i, j, k) = delp_ad(i, j, k) + dm_ad(i)
          dm_ad(i) = 0.0_FVPRC
        END DO
      END DO
      DO i=ie,is,-1
        ps_ad(i, j) = 0.0_FVPRC
        m_fac_ad(i, j) = 0.0_FVPRC
        aam_ad(i, j) = 0.0_FVPRC
        CALL POPREALARRAY(r2(i))
        CALL POPREALARRAY(r1(i))
      END DO
    END DO
    CALL C2L_ORD2_BWD(u, u_ad, v, v_ad, ua, ua_ad, va, va_ad, gridstruct&
&               , npz, gridstruct%grid_type, bd)
  END SUBROUTINE COMPUTE_AAM_BWD
  SUBROUTINE COMPUTE_AAM(npz, is, ie, js, je, isd, ied, jsd, jed, &
&   gridstruct, bd, ptop, ua, va, u, v, delp, aam, ps, m_fac)
    IMPLICIT NONE
! Compute vertically (mass) integrated Atmospheric Angular Momentum
    INTEGER, INTENT(IN) :: npz
    INTEGER, INTENT(IN) :: is, ie, js, je
    INTEGER, INTENT(IN) :: isd, ied, jsd, jed
    REAL(fvprc), INTENT(IN) :: ptop
! D grid zonal wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: u(isd:ied, jsd:jed+1, npz)
! D grid meridional wind (m/s)
    REAL(fvprc), INTENT(INOUT) :: v(isd:ied+1, jsd:jed, npz)
    REAL(fvprc), INTENT(INOUT) :: delp(isd:ied, jsd:jed, npz)
    REAL(fvprc), DIMENSION(isd:ied, jsd:jed, npz), INTENT(INOUT) :: ua, &
&   va
    REAL(fvprc), INTENT(OUT) :: aam(is:ie, js:je)
    REAL(fvprc), INTENT(OUT) :: m_fac(is:ie, js:je)
    REAL(fvprc), INTENT(OUT) :: ps(isd:ied, jsd:jed)
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    TYPE(FV_GRID_TYPE), INTENT(IN) :: gridstruct
! local:
    REAL(fvprc), DIMENSION(is:ie) :: r1, r2, dm
    INTEGER :: i, j, k
    INTRINSIC COS
    CALL C2L_ORD2(u, v, ua, va, gridstruct, npz, gridstruct%grid_type, &
&           bd)
!$OMP parallel do default(none) shared(is,ie,js,je,npz,gridstruct,aam,m_fac,ps,ptop,delp,agrav,ua) &
!$OMP                          private(r1, r2, dm)
    DO j=js,je
      DO i=is,ie
        r1(i) = radius*COS(gridstruct%agrid(i, j, 2))
        r2(i) = r1(i)*r1(i)
        aam(i, j) = 0.
        m_fac(i, j) = 0.
        ps(i, j) = ptop
      END DO
      DO k=1,npz
        DO i=is,ie
          dm(i) = delp(i, j, k)
          ps(i, j) = ps(i, j) + dm(i)
          dm(i) = dm(i)*agrav
          aam(i, j) = aam(i, j) + (r2(i)*omega+r1(i)*ua(i, j, k))*dm(i)
          m_fac(i, j) = m_fac(i, j) + dm(i)*r2(i)
        END DO
      END DO
    END DO
  END SUBROUTINE COMPUTE_AAM
!  Differentiation of geos_to_fv3 in reverse (adjoint) mode, forward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_
!mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe
!_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_cor
!e_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.
!rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed
!_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_en
!ergy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_map
!z_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz
! fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_sol
!ver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_c
!ore_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergen
!ce_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core
!_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core
!_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_cor
!e_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: peln delp pkz pe pk pt
!   with respect to varying inputs: delp pt
  SUBROUTINE GEOS_TO_FV3_FWD(bd, npz, kappa, ptop, delp, pe, pk, pkz, &
&   peln, pt)
    IMPLICIT NONE
!Arguments
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npz
    REAL(fvprc), INTENT(IN) :: kappa, ptop
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%&
&   je+1)
    REAL(fvprc), INTENT(INOUT) :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL(fvprc), INTENT(INOUT) :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL(fvprc), INTENT(INOUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
!Locals
    INTEGER :: i, j, k, is, ie, js, je
    INTRINSIC LOG
    INTRINSIC EXP
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    pe(:, :, :) = tiny_number
    pe(:, 1, :) = ptop
    DO k=2,npz+1
      DO j=js,je
        DO i=is,ie
          pe(i, k, j) = pe(i, k-1, j) + delp(i, j, k-1)
        END DO
      END DO
    END DO
    DO k=1,npz+1
      DO j=js,je
        DO i=is,ie
          peln(i, k, j) = LOG(pe(i, k, j))
        END DO
      END DO
    END DO
    DO k=1,npz+1
      DO j=js,je
        DO i=is,ie
          pk(i, j, k) = EXP(kappa*peln(i, k, j))
        END DO
      END DO
    END DO
    DO k=1,npz
      DO j=js,je
        DO i=is,ie
          pkz(i, j, k) = (pk(i, j, k+1)-pk(i, j, k))/(kappa*(peln(i, k+1&
&           , j)-peln(i, k, j)))
        END DO
      END DO
    END DO
    CALL PUSHREALARRAY(pt(is:ie, js:je, :), 8*(ie-is+1)*(je-js+1)*&
&                 npz/8)
    pt(is:ie, js:je, :) = pt(is:ie, js:je, :)*pkz(is:ie, js:je, :)
  END SUBROUTINE GEOS_TO_FV3_FWD
!  Differentiation of geos_to_fv3 in reverse (adjoint) mode, backward sweep (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge
!_mod.a2b_ord4 a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.p
!e_halo dyn_core_mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_co
!re_mod.grad1_p_update dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod
!.rayleigh_super fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cube
!d_to_latlon fv_grid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_e
!nergy fv_mapz_mod.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_ma
!pz_mod.map1_q2 fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steep
!z fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_so
!lver_c nh_core_mod.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_
!core_mod.sim_solver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.diverge
!nce_corner_nest sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_cor
!e_mod.compute_div_damping sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_cor
!e_mod.copy_corners tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_co
!re_mod.fyppm tp_core_mod.deln_flux)):
!   gradient     of useful results: peln delp pkz pe pk pt
!   with respect to varying inputs: delp pt
  SUBROUTINE GEOS_TO_FV3_BWD(bd, npz, kappa, ptop, delp, delp_ad, pe, &
&   pe_ad, pk, pk_ad, pkz, pkz_ad, peln, peln_ad, pt, pt_ad)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npz
    REAL(fvprc), INTENT(IN) :: kappa, ptop
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: pt_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: delp_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%&
&   je+1)
    REAL(fvprc), INTENT(INOUT) :: pe_ad(bd%is-1:bd%ie+1, npz+1, bd%js-1:&
&   bd%je+1)
    REAL(fvprc), INTENT(INOUT) :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL(fvprc), INTENT(INOUT) :: pk_ad(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL(fvprc), INTENT(INOUT) :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL(fvprc), INTENT(INOUT) :: peln_ad(bd%is:bd%ie, npz+1, bd%js:bd%&
&   je)
    REAL(fvprc), INTENT(INOUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
    REAL(fvprc), INTENT(INOUT) :: pkz_ad(bd%is:bd%ie, bd%js:bd%je, npz)
    INTEGER :: i, j, k, is, ie, js, je
    INTRINSIC LOG
    INTRINSIC EXP
    REAL(fvprc) :: temp
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    js = bd%js
    ie = bd%ie
    is = bd%is
    je = bd%je
    CALL POPREALARRAY(pt(is:ie, js:je, :), 8*(ie-is+1)*(je-js+1)*&
&                npz/8)
    pkz_ad(is:ie, js:je, :) = pkz_ad(is:ie, js:je, :) + pt(is:ie, js:je&
&     , :)*pt_ad(is:ie, js:je, :)
    pt_ad(is:ie, js:je, :) = pkz(is:ie, js:je, :)*pt_ad(is:ie, js:je, :)
    DO k=npz,1,-1
      DO j=je,js,-1
        DO i=ie,is,-1
          temp = kappa*(peln(i, k+1, j)-peln(i, k, j))
          temp_ad = pkz_ad(i, j, k)/temp
          temp_ad0 = -((pk(i, j, k+1)-pk(i, j, k))*kappa*temp_ad/temp)
          pk_ad(i, j, k+1) = pk_ad(i, j, k+1) + temp_ad
          pk_ad(i, j, k) = pk_ad(i, j, k) - temp_ad
          peln_ad(i, k+1, j) = peln_ad(i, k+1, j) + temp_ad0
          peln_ad(i, k, j) = peln_ad(i, k, j) - temp_ad0
          pkz_ad(i, j, k) = 0.0_FVPRC
        END DO
      END DO
    END DO
    DO k=npz+1,1,-1
      DO j=je,js,-1
        DO i=ie,is,-1
          peln_ad(i, k, j) = peln_ad(i, k, j) + EXP(kappa*peln(i, k, j))&
&           *kappa*pk_ad(i, j, k)
          pk_ad(i, j, k) = 0.0_FVPRC
        END DO
      END DO
    END DO
    DO k=npz+1,1,-1
      DO j=je,js,-1
        DO i=ie,is,-1
          pe_ad(i, k, j) = pe_ad(i, k, j) + peln_ad(i, k, j)/pe(i, k, j)
          peln_ad(i, k, j) = 0.0_FVPRC
        END DO
      END DO
    END DO
    DO k=npz+1,2,-1
      DO j=je,js,-1
        DO i=ie,is,-1
          pe_ad(i, k-1, j) = pe_ad(i, k-1, j) + pe_ad(i, k, j)
          delp_ad(i, j, k-1) = delp_ad(i, j, k-1) + pe_ad(i, k, j)
          pe_ad(i, k, j) = 0.0_FVPRC
        END DO
      END DO
    END DO
  END SUBROUTINE GEOS_TO_FV3_BWD
  SUBROUTINE GEOS_TO_FV3(bd, npz, kappa, ptop, delp, pe, pk, pkz, peln, &
&   pt)
    IMPLICIT NONE
!Arguments
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npz
    REAL(fvprc), INTENT(IN) :: kappa, ptop
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz&
&   )
    REAL(fvprc), INTENT(INOUT) :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%&
&   je+1)
    REAL(fvprc), INTENT(INOUT) :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL(fvprc), INTENT(INOUT) :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL(fvprc), INTENT(INOUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
!Locals
    INTEGER :: i, j, k, is, ie, js, je
    INTRINSIC LOG
    INTRINSIC EXP
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    pe(:, :, :) = tiny_number
    pe(:, 1, :) = ptop
    DO k=2,npz+1
      DO j=js,je
        DO i=is,ie
          pe(i, k, j) = pe(i, k-1, j) + delp(i, j, k-1)
        END DO
      END DO
    END DO
    DO k=1,npz+1
      DO j=js,je
        DO i=is,ie
          peln(i, k, j) = LOG(pe(i, k, j))
        END DO
      END DO
    END DO
    DO k=1,npz+1
      DO j=js,je
        DO i=is,ie
          pk(i, j, k) = EXP(kappa*peln(i, k, j))
        END DO
      END DO
    END DO
    DO k=1,npz
      DO j=js,je
        DO i=is,ie
          pkz(i, j, k) = (pk(i, j, k+1)-pk(i, j, k))/(kappa*(peln(i, k+1&
&           , j)-peln(i, k, j)))
        END DO
      END DO
    END DO
    pt(is:ie, js:je, :) = pt(is:ie, js:je, :)*pkz(is:ie, js:je, :)
  END SUBROUTINE GEOS_TO_FV3
!  Differentiation of fv3_to_geos in reverse (adjoint) mode (with options r8 split(a2b_edge_mod.a2b_ord2 a2b_edge_mod.a2b_ord4
! a2b_edge_mod.extrap_corner  dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_
!mod.adv_pe dyn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_u
!pdate dyn_core_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed fv_dynamics_mod.fv_dynamics fv_dynamics_mod.rayleigh_super 
!fv_dynamics_mod.rayleigh_friction fv_dynamics_mod.compute_aam fv_dynamics_mod.geos_to_fv3 fv_grid_utils_mod.cubed_to_latlon fv_g
!rid_utils_mod.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.lagrangian_to_eulerian fv_mapz_mod.compute_total_energy fv_mapz_mo
!d.pkez fv_mapz_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mod.map1_q2_f
!b fv_mapz_mod.map1_cubic fv_mapz_mod.scalar_profile_linear fv_mapz_mod.cs_profile_linear fv_mapz_mod.steepz fv_tracer2d_mo
!d.tracer_2d fv_tracer2d_mod.tracer_2d_nested nh_core_mod.update_dz_c nh_core_mod.update_dz_d nh_core_mod.riem_solver_c nh_core_m
!od.riem_solver3 nh_core_mod.rim_2d nh_core_mod.sim3_solver nh_core_mod.sim3p0_solver nh_core_mod.sim1_solver nh_core_mod.sim_sol
!ver nh_core_mod.edge_profile sw_core_mod.c_sw sw_core_mod.d_sw sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest 
!sw_core_mod.d2a2c_vect sw_core_mod.edge_interpolate4 sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.compute_di
!v_damping_fb sw_core_mod.smag_corner sw_core_mod.ytp_v sw_core_mod.xtp_u tp_core_mod.fv_tp_2d tp_core_mod.copy_corne
!rs_fb tp_core_mod.xtp tp_core_mod.ytp tp_core_mod.xppm0 tp_core_mod.yppm0 tp_core_mod.fxppm tp_core_mod.fyppm 
!tp_core_mod.deln_flux)):
!   gradient     of useful results: pt
!   with respect to varying inputs: pkz pt
  SUBROUTINE FV3_TO_GEOS_ADM(bd, npz, pkz, pkz_ad, pt, pt_ad)
    IMPLICIT NONE
!Arguments
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npz
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: pt_ad(bd%isd:bd%ied, bd%jsd:bd%jed, &
&   npz)
    REAL(fvprc), INTENT(INOUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
    REAL(fvprc), INTENT(INOUT) :: pkz_ad(bd%is:bd%ie, bd%js:bd%je, npz)
!Locals
    INTEGER :: i, j, k, is, ie, js, je
    REAL(fvprc) :: temp_ad
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    pkz_ad = 0.0_FVPRC
    DO k=npz,1,-1
      DO j=je,js,-1
        DO i=ie,is,-1
          temp_ad = pt_ad(i, j, k)/pkz(i, j, k)
          pkz_ad(i, j, k) = pkz_ad(i, j, k) - pt(i, j, k)*temp_ad/pkz(i&
&           , j, k)
          pt_ad(i, j, k) = temp_ad
        END DO
      END DO
    END DO
  END SUBROUTINE FV3_TO_GEOS_ADM
  SUBROUTINE FV3_TO_GEOS(bd, npz, pkz, pt)
    IMPLICIT NONE
!Arguments
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npz
    REAL(fvprc), INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL(fvprc), INTENT(INOUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
!Locals
    INTEGER :: i, j, k, is, ie, js, je
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    DO k=1,npz
      DO j=js,je
        DO i=is,ie
          pt(i, j, k) = pt(i, j, k)/pkz(i, j, k)
        END DO
      END DO
    END DO
  END SUBROUTINE FV3_TO_GEOS
END MODULE FV_DYNAMICS_MOD_B
