!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.13 (r6666) - 27 Nov 2017 17:09
!
MODULE MAIN_MOD_DIFF
  USE FV_DYNAMICS_MOD_DIFF, ONLY : fv_dynamics, fv_dynamics_adm
  USE FV_ARRAYS_NLM_MOD, ONLY : fv_atmos_pert_type
  USE FV_ARRAYS_MOD_DIFF, ONLY : fv_grid_type, fv_flags_type, &
& fv_atmos_type, fv_nest_type, fv_diag_type, fv_grid_bounds_type, fvprc
  USE MPP_DOMAINS_MOD_DIFF, ONLY : domain2d
  USE FV_SG_MOD_DIFF, ONLY : fv_subgrid_z, fv_subgrid_z_adm
  IMPLICIT NONE
  PRIVATE 
  PUBLIC run
  PUBLIC run_fwd, run_bwd

CONTAINS
!  Differentiation of run in reverse (adjoint) mode, forward sweep (with options split(a2b_edge_mod.a2b_ord4 a2b_edge_mod.a2b_
!ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_g
!rad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mod.mix_dp d
!yn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayleigh_Super 
!fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_grid_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_gr
!id_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_mapz_mod.compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z f
!v_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz_
!mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_limiters fv_mapz_mod.ppm_profile fv_mapz_mod.ppm_limiters fv_mapz
!_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.moist_cv fv_mapz_mod.moist_cp fv_mapz_mod.map1_cubic fv_restart_
!mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested fv_sg_mod.fv_subgrid_z mai
!n_mod.compute_pressures main_mod.run nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.Rie
!m_Solver_c nh_utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SIM3p
!0_solver nh_utils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nest_h
!alo_nh sw_core_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_vec
!t sw_core_mod.fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v sw_c
!ore_mod.compute_divergence_damping sw_core_mod.smag_corner tp_core_mod.mp_ghost_ew tp_core_mod.fv_tp_2d tp_core_mod.cop
!y_corners_fb tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_corner fv_grid_utils_mod.gr
!eat_circle_dist sw_core_mod.edge_interpolate4)):
!   gradient     of useful results: q u v w delp delz pt
!   with respect to varying inputs: q u v w delp delz pt
  SUBROUTINE RUN_FWD(fv_atm, fv_atmp, bd, npz, ncnst, dt, kappa, cp, &
&   zvir, idealtest, u, v, w, delz, pt, delp, q)
    IMPLICIT NONE
    TYPE(FV_ATMOS_TYPE), INTENT(INOUT) :: fv_atm
    TYPE(FV_ATMOS_PERT_TYPE), INTENT(INOUT) :: fv_atmp
    REAL, INTENT(IN) :: dt, kappa, cp, zvir
    LOGICAL, INTENT(IN) :: idealtest
    INTEGER, INTENT(IN) :: npz, ncnst
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL, INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL, INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, ncnst)
    REAL, INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: ze0(bd%is:bd%is, bd%js:bd%js, 1)
    REAL :: ps(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1)
    REAL :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
    REAL :: q_con(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL :: omga(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: va(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
    REAL :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL :: u_dt(fv_atm%bd%isd:fv_atm%bd%ied, fv_atm%bd%jsd:fv_atm%bd%&
&   jed, fv_atm%npz)
    REAL :: v_dt(fv_atm%bd%isd:fv_atm%bd%ied, fv_atm%bd%jsd:fv_atm%bd%&
&   jed, fv_atm%npz)
    REAL :: t_dt(fv_atm%bd%is:fv_atm%bd%ie, fv_atm%bd%js:fv_atm%bd%je, &
&   fv_atm%npz)
    INTEGER :: is, ie, js, je, i, j, k
    is = fv_atm%bd%is
    ie = fv_atm%bd%ie
    js = fv_atm%bd%js
    je = fv_atm%bd%je
    ps = 0.0
    pe = 0.0
    pk = 0.0
    peln = 0.0
    pkz = 0.0
    phis = 0.0
    omga = 0.0
    uc = 0.0
    vc = 0.0
    ua = 0.0
    va = 0.0
!Compute the FV pressures
    IF (.NOT.idealtest) THEN
      CALL COMPUTE_PRESSURES_FWD(fv_atm%bd, fv_atm%npz, kappa, fv_atm%&
&                          ptop, delp, pe, pk, pkz, peln)
!Convert potential temperature to dry temperature
      DO k=1,fv_atm%npz
        DO j=js,je
          DO i=is,ie
            CALL PUSHREALARRAY(pt(i, j, k))
            pt(i, j, k) = pt(i, j, k)*pkz(i, j, k)
          END DO
        END DO
      END DO
      CALL PUSHCONTROL(1,0)
    ELSE
      CALL PUSHCONTROL(1,1)
    END IF
    CALL FV_DYNAMICS_FWD(fv_atm%npx, fv_atm%npy, fv_atm%npz, fv_atm%&
&                  ncnst, fv_atm%ng, dt, fv_atm%flagstruct%consv_te, &
&                  fv_atm%flagstruct%fill, fv_atm%flagstruct%&
&                  reproduce_sum, kappa, cp, zvir, fv_atm%ptop, fv_atm%&
&                  ks, fv_atm%flagstruct%ncnst, fv_atm%flagstruct%&
&                  n_split, fv_atm%flagstruct%q_split, u, v, w, delz, &
&                  fv_atm%flagstruct%hydrostatic, pt, delp, q, ps, pe, &
&                  pk, peln, pkz, phis, q_con, omga, ua, va, uc, vc, &
&                  fv_atm%ak, fv_atm%bk, mfx, mfy, cx, cy, ze0, fv_atm%&
&                  flagstruct%hybrid_z, fv_atm%gridstruct, fv_atm%&
&                  flagstruct, fv_atmp%flagstruct, fv_atm%neststruct, &
&                  fv_atm%idiag, fv_atm%bd, fv_atm%parent_grid, fv_atm%&
&                  domain)
    IF (fv_atm%flagstruct%fv_sg_adj .GT. 0) THEN
      CALL FV_SUBGRID_Z_FWD(fv_atm%bd%isd, fv_atm%bd%ied, fv_atm%bd%jsd&
&                     , fv_atm%bd%jed, fv_atm%bd%is, fv_atm%bd%ie, &
&                     fv_atm%bd%js, fv_atm%bd%je, fv_atm%npz, fv_atm%&
&                     ncnst, dt, fv_atm%flagstruct%fv_sg_adj, fv_atm%&
&                     flagstruct%nwat, delp, pe, peln, pkz, pt, q, ua, &
&                     va, fv_atm%flagstruct%hydrostatic, w, delz, u_dt, &
&                     v_dt, t_dt, fv_atm%flagstruct%n_zfilter)
      CALL PUSHCONTROL(1,0)
    ELSE
      CALL PUSHCONTROL(1,1)
    END IF
!Convert temperature back
    IF (.NOT.idealtest) THEN
      CALL PUSHREALARRAY(cy, (bd%ied-bd%isd+1)*(bd%je-bd%js+2)*npz)
      CALL PUSHREALARRAY(cx, (bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*npz)
      CALL PUSHINTEGER(je)
      CALL PUSHREALARRAY(pk, (bd%ie-bd%is+1)*(bd%je-bd%js+1)*(npz+1))
      CALL PUSHREALARRAY(pe, (bd%ie-bd%is+3)*(npz+1)*(bd%je-bd%js+3))
      CALL PUSHREALARRAY(pkz, (bd%ie-bd%is+1)*(bd%je-bd%js+1)*npz)
      CALL PUSHINTEGER(is)
      CALL PUSHINTEGER(ie)
      CALL PUSHREALARRAY(va, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*npz)
      CALL PUSHREALARRAY(omga, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*npz)
      CALL PUSHREALARRAY(mfy, (bd%ie-bd%is+1)*(bd%je-bd%js+2)*npz)
      CALL PUSHREALARRAY(mfx, (bd%ie-bd%is+2)*(bd%je-bd%js+1)*npz)
      CALL PUSHREALARRAY(ua, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*npz)
      CALL PUSHREALARRAY(peln, (bd%ie-bd%is+1)*(npz+1)*(bd%je-bd%js+1))
      CALL PUSHREALARRAY(phis, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1))
      CALL PUSHINTEGER(js)
      CALL PUSHCONTROL(1,0)
    ELSE
      CALL PUSHREALARRAY(cy, (bd%ied-bd%isd+1)*(bd%je-bd%js+2)*npz)
      CALL PUSHREALARRAY(cx, (bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*npz)
      CALL PUSHINTEGER(je)
      CALL PUSHREALARRAY(pk, (bd%ie-bd%is+1)*(bd%je-bd%js+1)*(npz+1))
      CALL PUSHREALARRAY(pe, (bd%ie-bd%is+3)*(npz+1)*(bd%je-bd%js+3))
      CALL PUSHREALARRAY(pkz, (bd%ie-bd%is+1)*(bd%je-bd%js+1)*npz)
      CALL PUSHINTEGER(is)
      CALL PUSHINTEGER(ie)
      CALL PUSHREALARRAY(va, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*npz)
      CALL PUSHREALARRAY(omga, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*npz)
      CALL PUSHREALARRAY(mfy, (bd%ie-bd%is+1)*(bd%je-bd%js+2)*npz)
      CALL PUSHREALARRAY(mfx, (bd%ie-bd%is+2)*(bd%je-bd%js+1)*npz)
      CALL PUSHREALARRAY(ua, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*npz)
      CALL PUSHREALARRAY(peln, (bd%ie-bd%is+1)*(npz+1)*(bd%je-bd%js+1))
      CALL PUSHREALARRAY(phis, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1))
      CALL PUSHINTEGER(js)
      CALL PUSHCONTROL(1,1)
    END IF
  END SUBROUTINE RUN_FWD
!  Differentiation of run in reverse (adjoint) mode, backward sweep (with options split(a2b_edge_mod.a2b_ord4 a2b_edge_mod.a2b
!_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dyn_core_mod.p_
!grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_core_mod.mix_dp 
!dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.Rayleigh_Super
! fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_grid_utils_mod.cubed_to_latlon fv_grid_utils_mod.c2l_ord4 fv_g
!rid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_mapz_mod.compute_total_energy fv_mapz_mod.pkez fv_mapz_mod.remap_z 
!fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mod.map1_q2 fv_mapz_mod.remap_2d fv_mapz
!_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_limiters fv_mapz_mod.ppm_profile fv_mapz_mod.ppm_limiters fv_map
!z_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.moist_cv fv_mapz_mod.moist_cp fv_mapz_mod.map1_cubic fv_restart
!_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested fv_sg_mod.fv_subgrid_z ma
!in_mod.compute_pressures main_mod.run nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh_utils_mod.Ri
!em_Solver_c nh_utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_utils_mod.SIM3
!p0_solver nh_utils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_utils_mod.nest_
!halo_nh sw_core_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core_mod.d2a2c_ve
!ct sw_core_mod.fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod.ytp_v sw_
!core_mod.compute_divergence_damping sw_core_mod.smag_corner tp_core_mod.mp_ghost_ew tp_core_mod.fv_tp_2d tp_core_mod.co
!py_corners_fb tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_corner fv_grid_utils_mod.g
!reat_circle_dist sw_core_mod.edge_interpolate4)):
!   gradient     of useful results: q u v w delp delz pt
!   with respect to varying inputs: q u v w delp delz pt
!   RW status of diff variables: q:in-out u:in-out v:in-out w:in-out
!                delp:in-out delz:in-out pt:in-out
  SUBROUTINE RUN_BWD(fv_atm, fv_atmp, bd, npz, ncnst, dt, kappa, cp, &
&   zvir, idealtest, u, u_ad, v, v_ad, w, w_ad, delz, delz_ad, pt, pt_ad&
&   , delp, delp_ad, q, q_ad)
    IMPLICIT NONE
    TYPE(FV_ATMOS_TYPE), INTENT(INOUT) :: fv_atm
    TYPE(FV_ATMOS_PERT_TYPE), INTENT(INOUT) :: fv_atmp
    REAL, INTENT(IN) :: dt, kappa, cp, zvir
    LOGICAL, INTENT(IN) :: idealtest
    INTEGER, INTENT(IN) :: npz, ncnst
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL, INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL, INTENT(INOUT) :: u_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL, INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: v_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: pt_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: delp_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, ncnst)
    REAL, INTENT(INOUT) :: q_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz, ncnst&
&   )
    REAL, INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: delz_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: w_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: ze0(bd%is:bd%is, bd%js:bd%js, 1)
    REAL :: ps(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL :: ps_ad(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1)
    REAL :: pe_ad(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1)
    REAL :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL :: pk_ad(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL :: peln_ad(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
    REAL :: pkz_ad(bd%is:bd%ie, bd%js:bd%je, npz)
    REAL :: q_con(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL :: omga(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: omga_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL :: uc_ad(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL :: vc_ad(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: ua_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: va(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: va_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL :: mfx_ad(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
    REAL :: mfy_ad(bd%is:bd%ie, bd%js:bd%je+1, npz)
    REAL :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL :: cx_ad(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL :: cy_ad(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL :: u_dt(fv_atm%bd%isd:fv_atm%bd%ied, fv_atm%bd%jsd:fv_atm%bd%&
&   jed, fv_atm%npz)
    REAL :: v_dt(fv_atm%bd%isd:fv_atm%bd%ied, fv_atm%bd%jsd:fv_atm%bd%&
&   jed, fv_atm%npz)
    REAL :: t_dt(fv_atm%bd%is:fv_atm%bd%ie, fv_atm%bd%js:fv_atm%bd%je, &
&   fv_atm%npz)
    INTEGER :: is, ie, js, je, i, j, k
    REAL :: temp_ad
    INTEGER :: branch
    CALL POPCONTROL(1,branch)
    IF (branch .EQ. 0) THEN
      CALL POPINTEGER(js)
      CALL POPREALARRAY(phis, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1))
      CALL POPREALARRAY(peln, (bd%ie-bd%is+1)*(npz+1)*(bd%je-bd%js+1))
      CALL POPREALARRAY(ua, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*npz)
      CALL POPREALARRAY(mfx, (bd%ie-bd%is+2)*(bd%je-bd%js+1)*npz)
      CALL POPREALARRAY(mfy, (bd%ie-bd%is+1)*(bd%je-bd%js+2)*npz)
      CALL POPREALARRAY(omga, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*npz)
      CALL POPREALARRAY(va, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*npz)
      CALL POPINTEGER(ie)
      CALL POPINTEGER(is)
      CALL POPREALARRAY(pkz, (bd%ie-bd%is+1)*(bd%je-bd%js+1)*npz)
      CALL POPREALARRAY(pe, (bd%ie-bd%is+3)*(npz+1)*(bd%je-bd%js+3))
      CALL POPREALARRAY(pk, (bd%ie-bd%is+1)*(bd%je-bd%js+1)*(npz+1))
      CALL POPINTEGER(je)
      CALL POPREALARRAY(cx, (bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*npz)
      CALL POPREALARRAY(cy, (bd%ied-bd%isd+1)*(bd%je-bd%js+2)*npz)
      pkz_ad = 0.0
      DO k=fv_atm%npz,1,-1
        DO j=je,js,-1
          DO i=ie,is,-1
            temp_ad = pt_ad(i, j, k)/pkz(i, j, k)
            pkz_ad(i, j, k) = pkz_ad(i, j, k) - pt(i, j, k)*temp_ad/pkz(&
&             i, j, k)
            pt_ad(i, j, k) = temp_ad
          END DO
        END DO
      END DO
    ELSE
      CALL POPINTEGER(js)
      CALL POPREALARRAY(phis, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1))
      CALL POPREALARRAY(peln, (bd%ie-bd%is+1)*(npz+1)*(bd%je-bd%js+1))
      CALL POPREALARRAY(ua, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*npz)
      CALL POPREALARRAY(mfx, (bd%ie-bd%is+2)*(bd%je-bd%js+1)*npz)
      CALL POPREALARRAY(mfy, (bd%ie-bd%is+1)*(bd%je-bd%js+2)*npz)
      CALL POPREALARRAY(omga, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*npz)
      CALL POPREALARRAY(va, (bd%ied-bd%isd+1)*(bd%jed-bd%jsd+1)*npz)
      CALL POPINTEGER(ie)
      CALL POPINTEGER(is)
      CALL POPREALARRAY(pkz, (bd%ie-bd%is+1)*(bd%je-bd%js+1)*npz)
      CALL POPREALARRAY(pe, (bd%ie-bd%is+3)*(npz+1)*(bd%je-bd%js+3))
      CALL POPREALARRAY(pk, (bd%ie-bd%is+1)*(bd%je-bd%js+1)*(npz+1))
      CALL POPINTEGER(je)
      CALL POPREALARRAY(cx, (bd%ie-bd%is+2)*(bd%jed-bd%jsd+1)*npz)
      CALL POPREALARRAY(cy, (bd%ied-bd%isd+1)*(bd%je-bd%js+2)*npz)
      pkz_ad = 0.0
    END IF
    CALL POPCONTROL(1,branch)
    IF (branch .EQ. 0) THEN
      CALL FV_SUBGRID_Z_BWD(fv_atm%bd%isd, fv_atm%bd%ied, fv_atm%bd%jsd&
&                     , fv_atm%bd%jed, fv_atm%bd%is, fv_atm%bd%ie, &
&                     fv_atm%bd%js, fv_atm%bd%je, fv_atm%npz, fv_atm%&
&                     ncnst, dt, fv_atm%flagstruct%fv_sg_adj, fv_atm%&
&                     flagstruct%nwat, delp, delp_ad, pe, pe_ad, peln, &
&                     peln_ad, pkz, pkz_ad, pt, pt_ad, q, q_ad, ua, &
&                     ua_ad, va, va_ad, fv_atm%flagstruct%hydrostatic, w&
&                     , w_ad, delz, delz_ad, u_dt, v_dt, t_dt, fv_atm%&
&                     flagstruct%n_zfilter)
    ELSE
      peln_ad = 0.0
      ua_ad = 0.0
      va_ad = 0.0
      pe_ad = 0.0
    END IF
    CALL FV_DYNAMICS_BWD(fv_atm%npx, fv_atm%npy, fv_atm%npz, fv_atm%&
&                  ncnst, fv_atm%ng, dt, fv_atm%flagstruct%consv_te, &
&                  fv_atm%flagstruct%fill, fv_atm%flagstruct%&
&                  reproduce_sum, kappa, cp, zvir, fv_atm%ptop, fv_atm%&
&                  ks, fv_atm%flagstruct%ncnst, fv_atm%flagstruct%&
&                  n_split, fv_atm%flagstruct%q_split, u, u_ad, v, v_ad&
&                  , w, w_ad, delz, delz_ad, fv_atm%flagstruct%&
&                  hydrostatic, pt, pt_ad, delp, delp_ad, q, q_ad, ps, &
&                  ps_ad, pe, pe_ad, pk, pk_ad, peln, peln_ad, pkz, &
&                  pkz_ad, phis, q_con, omga, omga_ad, ua, ua_ad, va, &
&                  va_ad, uc, uc_ad, vc, vc_ad, fv_atm%ak, fv_atm%bk, &
&                  mfx, mfx_ad, mfy, mfy_ad, cx, cx_ad, cy, cy_ad, ze0, &
&                  fv_atm%flagstruct%hybrid_z, fv_atm%gridstruct, fv_atm&
&                  %flagstruct, fv_atmp%flagstruct, fv_atm%neststruct, &
&                  fv_atm%idiag, fv_atm%bd, fv_atm%parent_grid, fv_atm%&
&                  domain)
    CALL POPCONTROL(1,branch)
    IF (branch .EQ. 0) THEN
      DO k=fv_atm%npz,1,-1
        DO j=je,js,-1
          DO i=ie,is,-1
            CALL POPREALARRAY(pt(i, j, k))
            pkz_ad(i, j, k) = pkz_ad(i, j, k) + pt(i, j, k)*pt_ad(i, j, &
&             k)
            pt_ad(i, j, k) = pkz(i, j, k)*pt_ad(i, j, k)
          END DO
        END DO
      END DO
      CALL COMPUTE_PRESSURES_BWD(fv_atm%bd, fv_atm%npz, kappa, fv_atm%&
&                          ptop, delp, delp_ad, pe, pe_ad, pk, pk_ad, &
&                          pkz, pkz_ad, peln, peln_ad)
    END IF
  END SUBROUTINE RUN_BWD
  SUBROUTINE RUN(fv_atm, fv_atmp, bd, npz, ncnst, dt, kappa, cp, zvir, &
&   idealtest, u, v, w, delz, pt, delp, q)
    IMPLICIT NONE
    TYPE(FV_ATMOS_TYPE), INTENT(INOUT) :: fv_atm
    TYPE(FV_ATMOS_PERT_TYPE), INTENT(INOUT) :: fv_atmp
    REAL, INTENT(IN) :: dt, kappa, cp, zvir
    LOGICAL, INTENT(IN) :: idealtest
    INTEGER, INTENT(IN) :: npz, ncnst
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL, INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL, INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, ncnst)
    REAL, INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: ze0(bd%is:bd%is, bd%js:bd%js, 1)
    REAL :: ps(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1)
    REAL :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
    REAL :: q_con(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL :: omga(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: va(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
    REAL :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL :: u_dt(fv_atm%bd%isd:fv_atm%bd%ied, fv_atm%bd%jsd:fv_atm%bd%&
&   jed, fv_atm%npz)
    REAL :: v_dt(fv_atm%bd%isd:fv_atm%bd%ied, fv_atm%bd%jsd:fv_atm%bd%&
&   jed, fv_atm%npz)
    REAL :: t_dt(fv_atm%bd%is:fv_atm%bd%ie, fv_atm%bd%js:fv_atm%bd%je, &
&   fv_atm%npz)
    INTEGER :: is, ie, js, je, i, j, k
    is = fv_atm%bd%is
    ie = fv_atm%bd%ie
    js = fv_atm%bd%js
    je = fv_atm%bd%je
    ze0 = 0.0
    ps = 0.0
    pe = 0.0
    pk = 0.0
    peln = 0.0
    pkz = 0.0
    q_con = 0.0
    phis = 0.0
    omga = 0.0
    uc = 0.0
    vc = 0.0
    ua = 0.0
    va = 0.0
    mfx = 0.0
    mfy = 0.0
    cx = 0.0
    cy = 0.0
!Compute the FV pressures
    IF (.NOT.idealtest) THEN
      CALL COMPUTE_PRESSURES(fv_atm%bd, fv_atm%npz, kappa, fv_atm%ptop, &
&                      delp, pe, pk, pkz, peln)
!Convert potential temperature to dry temperature
      DO k=1,fv_atm%npz
        DO j=js,je
          DO i=is,ie
            pt(i, j, k) = pt(i, j, k)*pkz(i, j, k)
          END DO
        END DO
      END DO
    END IF
    CALL FV_DYNAMICS(fv_atm%npx, fv_atm%npy, fv_atm%npz, fv_atm%ncnst, &
&              fv_atm%ng, dt, fv_atm%flagstruct%consv_te, fv_atm%&
&              flagstruct%fill, fv_atm%flagstruct%reproduce_sum, kappa, &
&              cp, zvir, fv_atm%ptop, fv_atm%ks, fv_atm%flagstruct%ncnst&
&              , fv_atm%flagstruct%n_split, fv_atm%flagstruct%q_split, u&
&              , v, w, delz, fv_atm%flagstruct%hydrostatic, pt, delp, q&
&              , ps, pe, pk, peln, pkz, phis, q_con, omga, ua, va, uc, &
&              vc, fv_atm%ak, fv_atm%bk, mfx, mfy, cx, cy, ze0, fv_atm%&
&              flagstruct%hybrid_z, fv_atm%gridstruct, fv_atm%flagstruct&
&              , fv_atmp%flagstruct, fv_atm%neststruct, fv_atm%idiag, &
&              fv_atm%bd, fv_atm%parent_grid, fv_atm%domain)
    IF (fv_atm%flagstruct%fv_sg_adj .GT. 0) THEN
      u_dt(:, :, :) = 0.0
      v_dt(:, :, :) = 0.0
      t_dt(:, :, :) = 0.0
      CALL FV_SUBGRID_Z(fv_atm%bd%isd, fv_atm%bd%ied, fv_atm%bd%jsd, &
&                 fv_atm%bd%jed, fv_atm%bd%is, fv_atm%bd%ie, fv_atm%bd%&
&                 js, fv_atm%bd%je, fv_atm%npz, fv_atm%ncnst, dt, fv_atm&
&                 %flagstruct%fv_sg_adj, fv_atm%flagstruct%nwat, delp, &
&                 pe, peln, pkz, pt, q, ua, va, fv_atm%flagstruct%&
&                 hydrostatic, w, delz, u_dt, v_dt, t_dt, fv_atm%&
&                 flagstruct%n_zfilter)
    END IF
!Convert temperature back
    IF (.NOT.idealtest) THEN
      DO k=1,fv_atm%npz
        DO j=js,je
          DO i=is,ie
            pt(i, j, k) = pt(i, j, k)/pkz(i, j, k)
          END DO
        END DO
      END DO
    END IF
    ze0 = 0.0
    ps = 0.0
    pe = 0.0
    pk = 0.0
    peln = 0.0
    pkz = 0.0
    q_con = 0.0
    phis = 0.0
    omga = 0.0
    uc = 0.0
    vc = 0.0
    ua = 0.0
    va = 0.0
    mfx = 0.0
    mfy = 0.0
    cx = 0.0
    cy = 0.0
  END SUBROUTINE RUN
!  Differentiation of compute_pressures in reverse (adjoint) mode, forward sweep (with options split(a2b_edge_mod.a2b_ord4 a2b
!_edge_mod.a2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe dy
!n_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_cor
!e_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.R
!ayleigh_Super fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_grid_utils_mod.cubed_to_latlon fv_grid_utils_mod.
!c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_mapz_mod.compute_total_energy fv_mapz_mod.pkez fv_mapz
!_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mod.map1_q2 fv_mapz_mod.rem
!ap_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_limiters fv_mapz_mod.ppm_profile fv_mapz_mod.ppm_li
!miters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.moist_cv fv_mapz_mod.moist_cp fv_mapz_mod.map1_cub
!ic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested fv_sg_mod.fv
!_subgrid_z main_mod.compute_pressures main_mod.run nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d nh
!_utils_mod.Riem_Solver_c nh_utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_u
!tils_mod.SIM3p0_solver nh_utils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_ut
!ils_mod.nest_halo_nh sw_core_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_core
!_mod.d2a2c_vect sw_core_mod.fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mod
!.ytp_v sw_core_mod.compute_divergence_damping sw_core_mod.smag_corner tp_core_mod.mp_ghost_ew tp_core_mod.fv_tp_2d t
!p_core_mod.copy_corners tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_corner fv_gri
!d_utils_mod.great_circle_dist sw_core_mod.edge_interpolate4)):
!   gradient     of useful results: peln delp pkz pe pk
!   with respect to varying inputs: delp
  SUBROUTINE COMPUTE_PRESSURES_FWD(bd, npz, kappa, ptop, delp, pe, pk, &
&   pkz, peln)
    IMPLICIT NONE
!Arguments
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npz
    REAL, INTENT(IN) :: kappa, ptop
    REAL, INTENT(IN) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1)
    REAL :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
!Locals
    INTEGER :: i, j, k, is, ie, js, je
    INTRINSIC LOG
    INTRINSIC EXP
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    pe(:, :, :) = 0.0
    pe(:, 1, :) = ptop
    DO k=2,npz+1
      DO j=js,je
        DO i=is,ie
          pe(i, k, j) = pe(i, k-1, j) + delp(i, j, k-1)
        END DO
      END DO
    END DO
    DO k=1,npz+1
      DO j=js,je
        DO i=is,ie
          peln(i, k, j) = LOG(pe(i, k, j))
        END DO
      END DO
    END DO
    DO k=1,npz+1
      DO j=js,je
        DO i=is,ie
          pk(i, j, k) = EXP(kappa*peln(i, k, j))
        END DO
      END DO
    END DO
    DO k=1,npz
      DO j=js,je
        DO i=is,ie
          pkz(i, j, k) = (pk(i, j, k+1)-pk(i, j, k))/(kappa*(peln(i, k+1&
&           , j)-peln(i, k, j)))
        END DO
      END DO
    END DO
    CALL PUSHINTEGER(je)
    CALL PUSHINTEGER(is)
    CALL PUSHINTEGER(ie)
    CALL PUSHINTEGER(js)
  END SUBROUTINE COMPUTE_PRESSURES_FWD
!  Differentiation of compute_pressures in reverse (adjoint) mode, backward sweep (with options split(a2b_edge_mod.a2b_ord4 a2
!b_edge_mod.a2b_ord2 dyn_core_mod.dyn_core dyn_core_mod.pk3_halo dyn_core_mod.pln_halo dyn_core_mod.pe_halo dyn_core_mod.adv_pe d
!yn_core_mod.p_grad_c dyn_core_mod.nh_p_grad dyn_core_mod.split_p_grad dyn_core_mod.one_grad_p dyn_core_mod.grad1_p_update dyn_co
!re_mod.mix_dp dyn_core_mod.geopk dyn_core_mod.del2_cubed dyn_core_mod.Rayleigh_fast fv_dynamics_mod.fv_dynamics fv_dynamics_mod.
!Rayleigh_Super fv_dynamics_mod.Rayleigh_Friction fv_dynamics_mod.compute_aam fv_grid_utils_mod.cubed_to_latlon fv_grid_utils_mod
!.c2l_ord4 fv_grid_utils_mod.c2l_ord2 fv_mapz_mod.Lagrangian_to_Eulerian fv_mapz_mod.compute_total_energy fv_mapz_mod.pkez fv_map
!z_mod.remap_z fv_mapz_mod.map_scalar fv_mapz_mod.map1_ppm fv_mapz_mod.mapn_tracer fv_mapz_mod.map1_q2 fv_mapz_mod.re
!map_2d fv_mapz_mod.scalar_profile fv_mapz_mod.cs_profile fv_mapz_mod.cs_limiters fv_mapz_mod.ppm_profile fv_mapz_mod.ppm_l
!imiters fv_mapz_mod.steepz fv_mapz_mod.rst_remap fv_mapz_mod.mappm fv_mapz_mod.moist_cv fv_mapz_mod.moist_cp fv_mapz_mod.map1_cu
!bic fv_restart_mod.d2c_setup fv_tracer2d_mod.tracer_2d_1L fv_tracer2d_mod.tracer_2d fv_tracer2d_mod.tracer_2d_nested fv_sg_mod.f
!v_subgrid_z main_mod.compute_pressures main_mod.run nh_core_mod.Riem_Solver3 nh_utils_mod.update_dz_c nh_utils_mod.update_dz_d n
!h_utils_mod.Riem_Solver_c nh_utils_mod.Riem_Solver3test nh_utils_mod.imp_diff_w nh_utils_mod.RIM_2D nh_utils_mod.SIM3_solver nh_
!utils_mod.SIM3p0_solver nh_utils_mod.SIM1_solver nh_utils_mod.SIM_solver nh_utils_mod.edge_scalar nh_utils_mod.edge_profile nh_u
!tils_mod.nest_halo_nh sw_core_mod.c_sw sw_core_mod.d_sw  sw_core_mod.divergence_corner sw_core_mod.divergence_corner_nest sw_cor
!e_mod.d2a2c_vect sw_core_mod.fill3_4corners sw_core_mod.fill2_4corners sw_core_mod.fill_4corners sw_core_mod.xtp_u sw_core_mo
!d.ytp_v sw_core_mod.compute_divergence_damping sw_core_mod.smag_corner tp_core_mod.mp_ghost_ew tp_core_mod.fv_tp_2d 
!tp_core_mod.copy_corners tp_core_mod.xppm tp_core_mod.yppm tp_core_mod.deln_flux a2b_edge_mod.extrap_corner fv_gr
!id_utils_mod.great_circle_dist sw_core_mod.edge_interpolate4)):
!   gradient     of useful results: peln delp pkz pe pk
!   with respect to varying inputs: delp
  SUBROUTINE COMPUTE_PRESSURES_BWD(bd, npz, kappa, ptop, delp, delp_ad, &
&   pe, pe_ad, pk, pk_ad, pkz, pkz_ad, peln, peln_ad)
    IMPLICIT NONE
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npz
    REAL, INTENT(IN) :: kappa, ptop
    REAL, INTENT(IN) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: delp_ad(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1)
    REAL :: pe_ad(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1)
    REAL :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL :: pk_ad(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL :: peln_ad(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
    REAL :: pkz_ad(bd%is:bd%ie, bd%js:bd%je, npz)
    INTEGER :: i, j, k, is, ie, js, je
    INTRINSIC LOG
    INTRINSIC EXP
    REAL :: temp
    REAL :: temp_ad
    REAL :: temp_ad0
    CALL POPINTEGER(js)
    CALL POPINTEGER(ie)
    CALL POPINTEGER(is)
    CALL POPINTEGER(je)
    DO k=npz,1,-1
      DO j=je,js,-1
        DO i=ie,is,-1
          temp = kappa*(peln(i, k+1, j)-peln(i, k, j))
          temp_ad = pkz_ad(i, j, k)/temp
          temp_ad0 = -((pk(i, j, k+1)-pk(i, j, k))*kappa*temp_ad/temp)
          pk_ad(i, j, k+1) = pk_ad(i, j, k+1) + temp_ad
          pk_ad(i, j, k) = pk_ad(i, j, k) - temp_ad
          peln_ad(i, k+1, j) = peln_ad(i, k+1, j) + temp_ad0
          peln_ad(i, k, j) = peln_ad(i, k, j) - temp_ad0
          pkz_ad(i, j, k) = 0.0
        END DO
      END DO
    END DO
    DO k=npz+1,1,-1
      DO j=je,js,-1
        DO i=ie,is,-1
          peln_ad(i, k, j) = peln_ad(i, k, j) + EXP(kappa*peln(i, k, j))&
&           *kappa*pk_ad(i, j, k)
          pk_ad(i, j, k) = 0.0
        END DO
      END DO
    END DO
    DO k=npz+1,1,-1
      DO j=je,js,-1
        DO i=ie,is,-1
          pe_ad(i, k, j) = pe_ad(i, k, j) + peln_ad(i, k, j)/pe(i, k, j)
          peln_ad(i, k, j) = 0.0
        END DO
      END DO
    END DO
    DO k=npz+1,2,-1
      DO j=je,js,-1
        DO i=ie,is,-1
          pe_ad(i, k-1, j) = pe_ad(i, k-1, j) + pe_ad(i, k, j)
          delp_ad(i, j, k-1) = delp_ad(i, j, k-1) + pe_ad(i, k, j)
          pe_ad(i, k, j) = 0.0
        END DO
      END DO
    END DO
  END SUBROUTINE COMPUTE_PRESSURES_BWD
  SUBROUTINE COMPUTE_PRESSURES(bd, npz, kappa, ptop, delp, pe, pk, pkz, &
&   peln)
    IMPLICIT NONE
!Arguments
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npz
    REAL, INTENT(IN) :: kappa, ptop
    REAL, INTENT(IN) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(OUT) :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1)
    REAL, INTENT(OUT) :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL, INTENT(OUT) :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL, INTENT(OUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
!Locals
    INTEGER :: i, j, k, is, ie, js, je
    INTRINSIC LOG
    INTRINSIC EXP
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    pe(:, :, :) = 0.0
    pe(:, 1, :) = ptop
    DO k=2,npz+1
      DO j=js,je
        DO i=is,ie
          pe(i, k, j) = pe(i, k-1, j) + delp(i, j, k-1)
        END DO
      END DO
    END DO
    DO k=1,npz+1
      DO j=js,je
        DO i=is,ie
          peln(i, k, j) = LOG(pe(i, k, j))
        END DO
      END DO
    END DO
    DO k=1,npz+1
      DO j=js,je
        DO i=is,ie
          pk(i, j, k) = EXP(kappa*peln(i, k, j))
        END DO
      END DO
    END DO
    DO k=1,npz
      DO j=js,je
        DO i=is,ie
          pkz(i, j, k) = (pk(i, j, k+1)-pk(i, j, k))/(kappa*(peln(i, k+1&
&           , j)-peln(i, k, j)))
        END DO
      END DO
    END DO
  END SUBROUTINE COMPUTE_PRESSURES
END MODULE MAIN_MOD_DIFF
