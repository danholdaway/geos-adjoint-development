!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.13 (r6666) - 27 Nov 2017 17:09
!
MODULE MAIN_MOD_DIFF
  USE FV_DYNAMICS_MOD_DIFF, ONLY : fv_dynamics, fv_dynamics_tlm
  USE FV_ARRAYS_NLM_MOD, ONLY : fv_atmos_pert_type
  USE FV_ARRAYS_MOD_DIFF, ONLY : fv_grid_type, fv_flags_type, &
& fv_atmos_type, fv_nest_type, fv_diag_type, fv_grid_bounds_type, fvprc
  USE MPP_DOMAINS_MOD_DIFF, ONLY : domain2d
  USE FV_SG_MOD_DIFF, ONLY : fv_subgrid_z, fv_subgrid_z_tlm
  IMPLICIT NONE
  PRIVATE 
  PUBLIC run
  PUBLIC run_tlm

CONTAINS
!  Differentiation of run in forward (tangent) mode:
!   variations   of useful results: q u v w delp delz pt
!   with respect to varying inputs: q u v w delp delz pt
!   RW status of diff variables: q:in-out u:in-out v:in-out w:in-out
!                delp:in-out delz:in-out pt:in-out
  SUBROUTINE RUN_TLM(fv_atm, fv_atmp, bd, npz, ncnst, dt, kappa, cp, &
&   zvir, u, u_tl, v, v_tl, w, w_tl, delz, delz_tl, pt, pt_tl, delp, &
&   delp_tl, q, q_tl)
    IMPLICIT NONE
    TYPE(FV_ATMOS_TYPE), INTENT(INOUT) :: fv_atm
    TYPE(FV_ATMOS_PERT_TYPE), INTENT(INOUT) :: fv_atmp
    REAL, INTENT(IN) :: dt, kappa, cp, zvir
    INTEGER, INTENT(IN) :: npz, ncnst
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL, INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL, INTENT(INOUT) :: u_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL, INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: v_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: pt_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: delp_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, ncnst)
    REAL, INTENT(INOUT) :: q_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz, ncnst&
&   )
    REAL, INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: delz_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: w_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: ze0(bd%is:bd%is, bd%js:bd%js, 1)
    REAL :: ps(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL :: ps_tl(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1)
    REAL :: pe_tl(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1)
    REAL :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL :: pk_tl(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL :: peln_tl(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
    REAL :: pkz_tl(bd%is:bd%ie, bd%js:bd%je, npz)
    REAL :: q_con(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL :: omga(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: omga_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL :: uc_tl(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL :: vc_tl(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: ua_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: va(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: va_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL :: mfx_tl(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
    REAL :: mfy_tl(bd%is:bd%ie, bd%js:bd%je+1, npz)
    REAL :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL :: cx_tl(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL :: cy_tl(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL :: u_dt(fv_atm%bd%isd:fv_atm%bd%ied, fv_atm%bd%jsd:fv_atm%bd%&
&   jed, fv_atm%npz)
    REAL :: v_dt(fv_atm%bd%isd:fv_atm%bd%ied, fv_atm%bd%jsd:fv_atm%bd%&
&   jed, fv_atm%npz)
    REAL :: t_dt(fv_atm%bd%is:fv_atm%bd%ie, fv_atm%bd%js:fv_atm%bd%je, &
&   fv_atm%npz)
    INTEGER :: is, ie, js, je, i, j, k
    is = fv_atm%bd%is
    ie = fv_atm%bd%ie
    js = fv_atm%bd%js
    je = fv_atm%bd%je
    ze0 = 0.0
    ps = 0.0
    pe = 0.0
    pk = 0.0
    peln = 0.0
    pkz = 0.0
    q_con = 0.0
    phis = 0.0
    omga = 0.0
    uc = 0.0
    vc = 0.0
    ua = 0.0
    va = 0.0
    mfx = 0.0
    mfy = 0.0
    cx = 0.0
    cy = 0.0
!Compute the FV pressures
    CALL COMPUTE_PRESSURES_TLM(fv_atm%bd, fv_atm%npz, kappa, fv_atm%ptop&
&                        , delp, delp_tl, pe, pe_tl, pk, pk_tl, pkz, &
&                        pkz_tl, peln, peln_tl)
!Convert potential temperature to dry temperature
    DO k=1,fv_atm%npz
      DO j=js,je
        DO i=is,ie
          pt_tl(i, j, k) = pt_tl(i, j, k)*pkz(i, j, k) + pt(i, j, k)*&
&           pkz_tl(i, j, k)
          pt(i, j, k) = pt(i, j, k)*pkz(i, j, k)
        END DO
      END DO
    END DO
    CALL FV_DYNAMICS_TLM(fv_atm%npx, fv_atm%npy, fv_atm%npz, fv_atm%&
&                  ncnst, fv_atm%ng, dt, fv_atm%flagstruct%consv_te, &
&                  fv_atm%flagstruct%fill, fv_atm%flagstruct%&
&                  reproduce_sum, kappa, cp, zvir, fv_atm%ptop, fv_atm%&
&                  ks, fv_atm%flagstruct%ncnst, fv_atm%flagstruct%&
&                  n_split, fv_atm%flagstruct%q_split, u, u_tl, v, v_tl&
&                  , w, w_tl, delz, delz_tl, fv_atm%flagstruct%&
&                  hydrostatic, pt, pt_tl, delp, delp_tl, q, q_tl, ps, &
&                  ps_tl, pe, pe_tl, pk, pk_tl, peln, peln_tl, pkz, &
&                  pkz_tl, phis, q_con, omga, omga_tl, ua, ua_tl, va, &
&                  va_tl, uc, uc_tl, vc, vc_tl, fv_atm%ak, fv_atm%bk, &
&                  mfx, mfx_tl, mfy, mfy_tl, cx, cx_tl, cy, cy_tl, ze0, &
&                  fv_atm%flagstruct%hybrid_z, fv_atm%gridstruct, fv_atm&
&                  %flagstruct, fv_atmp%flagstruct, fv_atm%neststruct, &
&                  fv_atm%idiag, fv_atm%bd, fv_atm%parent_grid, fv_atm%&
&                  domain)
    IF (fv_atm%flagstruct%fv_sg_adj .GT. 0) THEN
      u_dt(:, :, :) = 0.0
      v_dt(:, :, :) = 0.0
      t_dt(:, :, :) = 0.0
      CALL FV_SUBGRID_Z_TLM(fv_atm%bd%isd, fv_atm%bd%ied, fv_atm%bd%jsd&
&                     , fv_atm%bd%jed, fv_atm%bd%is, fv_atm%bd%ie, &
&                     fv_atm%bd%js, fv_atm%bd%je, fv_atm%npz, fv_atm%&
&                     ncnst, dt, fv_atm%flagstruct%fv_sg_adj, fv_atm%&
&                     flagstruct%nwat, delp, delp_tl, pe, pe_tl, peln, &
&                     peln_tl, pkz, pkz_tl, pt, pt_tl, q, q_tl, ua, &
&                     ua_tl, va, va_tl, fv_atm%flagstruct%hydrostatic, w&
&                     , w_tl, delz, delz_tl, u_dt, v_dt, t_dt, fv_atm%&
&                     flagstruct%n_zfilter)
    END IF
!Convert temperature back
    DO k=1,fv_atm%npz
      DO j=js,je
        DO i=is,ie
          pt_tl(i, j, k) = (pt_tl(i, j, k)*pkz(i, j, k)-pt(i, j, k)*&
&           pkz_tl(i, j, k))/pkz(i, j, k)**2
          pt(i, j, k) = pt(i, j, k)/pkz(i, j, k)
        END DO
      END DO
    END DO
    ze0 = 0.0
    ps = 0.0
    pe = 0.0
    pk = 0.0
    peln = 0.0
    pkz = 0.0
    q_con = 0.0
    phis = 0.0
    omga = 0.0
    uc = 0.0
    vc = 0.0
    ua = 0.0
    va = 0.0
    mfx = 0.0
    mfy = 0.0
    cx = 0.0
    cy = 0.0
  END SUBROUTINE RUN_TLM
  SUBROUTINE RUN(fv_atm, fv_atmp, bd, npz, ncnst, dt, kappa, cp, zvir, u&
&   , v, w, delz, pt, delp, q)
    IMPLICIT NONE
    TYPE(FV_ATMOS_TYPE), INTENT(INOUT) :: fv_atm
    TYPE(FV_ATMOS_PERT_TYPE), INTENT(INOUT) :: fv_atmp
    REAL, INTENT(IN) :: dt, kappa, cp, zvir
    INTEGER, INTENT(IN) :: npz, ncnst
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    REAL, INTENT(INOUT) :: u(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL, INTENT(INOUT) :: v(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: pt(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: q(bd%isd:bd%ied, bd%jsd:bd%jed, npz, ncnst)
    REAL, INTENT(INOUT) :: delz(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(INOUT) :: w(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: ze0(bd%is:bd%is, bd%js:bd%js, 1)
    REAL :: ps(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1)
    REAL :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
    REAL :: q_con(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: phis(bd%isd:bd%ied, bd%jsd:bd%jed)
    REAL :: omga(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: uc(bd%isd:bd%ied+1, bd%jsd:bd%jed, npz)
    REAL :: vc(bd%isd:bd%ied, bd%jsd:bd%jed+1, npz)
    REAL :: ua(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: va(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL :: mfx(bd%is:bd%ie+1, bd%js:bd%je, npz)
    REAL :: mfy(bd%is:bd%ie, bd%js:bd%je+1, npz)
    REAL :: cx(bd%is:bd%ie+1, bd%jsd:bd%jed, npz)
    REAL :: cy(bd%isd:bd%ied, bd%js:bd%je+1, npz)
    REAL :: u_dt(fv_atm%bd%isd:fv_atm%bd%ied, fv_atm%bd%jsd:fv_atm%bd%&
&   jed, fv_atm%npz)
    REAL :: v_dt(fv_atm%bd%isd:fv_atm%bd%ied, fv_atm%bd%jsd:fv_atm%bd%&
&   jed, fv_atm%npz)
    REAL :: t_dt(fv_atm%bd%is:fv_atm%bd%ie, fv_atm%bd%js:fv_atm%bd%je, &
&   fv_atm%npz)
    INTEGER :: is, ie, js, je, i, j, k
    is = fv_atm%bd%is
    ie = fv_atm%bd%ie
    js = fv_atm%bd%js
    je = fv_atm%bd%je
    ze0 = 0.0
    ps = 0.0
    pe = 0.0
    pk = 0.0
    peln = 0.0
    pkz = 0.0
    q_con = 0.0
    phis = 0.0
    omga = 0.0
    uc = 0.0
    vc = 0.0
    ua = 0.0
    va = 0.0
    mfx = 0.0
    mfy = 0.0
    cx = 0.0
    cy = 0.0
!Compute the FV pressures
    CALL COMPUTE_PRESSURES(fv_atm%bd, fv_atm%npz, kappa, fv_atm%ptop, &
&                    delp, pe, pk, pkz, peln)
!Convert potential temperature to dry temperature
    DO k=1,fv_atm%npz
      DO j=js,je
        DO i=is,ie
          pt(i, j, k) = pt(i, j, k)*pkz(i, j, k)
        END DO
      END DO
    END DO
    CALL FV_DYNAMICS(fv_atm%npx, fv_atm%npy, fv_atm%npz, fv_atm%ncnst, &
&              fv_atm%ng, dt, fv_atm%flagstruct%consv_te, fv_atm%&
&              flagstruct%fill, fv_atm%flagstruct%reproduce_sum, kappa, &
&              cp, zvir, fv_atm%ptop, fv_atm%ks, fv_atm%flagstruct%ncnst&
&              , fv_atm%flagstruct%n_split, fv_atm%flagstruct%q_split, u&
&              , v, w, delz, fv_atm%flagstruct%hydrostatic, pt, delp, q&
&              , ps, pe, pk, peln, pkz, phis, q_con, omga, ua, va, uc, &
&              vc, fv_atm%ak, fv_atm%bk, mfx, mfy, cx, cy, ze0, fv_atm%&
&              flagstruct%hybrid_z, fv_atm%gridstruct, fv_atm%flagstruct&
&              , fv_atmp%flagstruct, fv_atm%neststruct, fv_atm%idiag, &
&              fv_atm%bd, fv_atm%parent_grid, fv_atm%domain)
    IF (fv_atm%flagstruct%fv_sg_adj .GT. 0) THEN
      u_dt(:, :, :) = 0.0
      v_dt(:, :, :) = 0.0
      t_dt(:, :, :) = 0.0
      CALL FV_SUBGRID_Z(fv_atm%bd%isd, fv_atm%bd%ied, fv_atm%bd%jsd, &
&                 fv_atm%bd%jed, fv_atm%bd%is, fv_atm%bd%ie, fv_atm%bd%&
&                 js, fv_atm%bd%je, fv_atm%npz, fv_atm%ncnst, dt, fv_atm&
&                 %flagstruct%fv_sg_adj, fv_atm%flagstruct%nwat, delp, &
&                 pe, peln, pkz, pt, q, ua, va, fv_atm%flagstruct%&
&                 hydrostatic, w, delz, u_dt, v_dt, t_dt, fv_atm%&
&                 flagstruct%n_zfilter)
    END IF
!Convert temperature back
    DO k=1,fv_atm%npz
      DO j=js,je
        DO i=is,ie
          pt(i, j, k) = pt(i, j, k)/pkz(i, j, k)
        END DO
      END DO
    END DO
    ze0 = 0.0
    ps = 0.0
    pe = 0.0
    pk = 0.0
    peln = 0.0
    pkz = 0.0
    q_con = 0.0
    phis = 0.0
    omga = 0.0
    uc = 0.0
    vc = 0.0
    ua = 0.0
    va = 0.0
    mfx = 0.0
    mfy = 0.0
    cx = 0.0
    cy = 0.0
  END SUBROUTINE RUN
!  Differentiation of compute_pressures in forward (tangent) mode:
!   variations   of useful results: peln pkz pe pk
!   with respect to varying inputs: delp
  SUBROUTINE COMPUTE_PRESSURES_TLM(bd, npz, kappa, ptop, delp, delp_tl, &
&   pe, pe_tl, pk, pk_tl, pkz, pkz_tl, peln, peln_tl)
    IMPLICIT NONE
!Arguments
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npz
    REAL, INTENT(IN) :: kappa, ptop
    REAL, INTENT(IN) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(IN) :: delp_tl(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(OUT) :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1)
    REAL, INTENT(OUT) :: pe_tl(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1)
    REAL, INTENT(OUT) :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL, INTENT(OUT) :: pk_tl(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL, INTENT(OUT) :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL, INTENT(OUT) :: peln_tl(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL, INTENT(OUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
    REAL, INTENT(OUT) :: pkz_tl(bd%is:bd%ie, bd%js:bd%je, npz)
!Locals
    INTEGER :: i, j, k, is, ie, js, je
    INTRINSIC LOG
    INTRINSIC EXP
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    pe(:, :, :) = 0.0
    pe(:, 1, :) = ptop
    pe_tl = 0.0
    DO k=2,npz+1
      DO j=js,je
        DO i=is,ie
          pe_tl(i, k, j) = pe_tl(i, k-1, j) + delp_tl(i, j, k-1)
          pe(i, k, j) = pe(i, k-1, j) + delp(i, j, k-1)
        END DO
      END DO
    END DO
    peln_tl = 0.0
    DO k=1,npz+1
      DO j=js,je
        DO i=is,ie
          peln_tl(i, k, j) = pe_tl(i, k, j)/pe(i, k, j)
          peln(i, k, j) = LOG(pe(i, k, j))
        END DO
      END DO
    END DO
    pk_tl = 0.0
    DO k=1,npz+1
      DO j=js,je
        DO i=is,ie
          pk_tl(i, j, k) = kappa*peln_tl(i, k, j)*EXP(kappa*peln(i, k, j&
&           ))
          pk(i, j, k) = EXP(kappa*peln(i, k, j))
        END DO
      END DO
    END DO
    pkz_tl = 0.0
    DO k=1,npz
      DO j=js,je
        DO i=is,ie
          pkz_tl(i, j, k) = ((pk_tl(i, j, k+1)-pk_tl(i, j, k))*kappa*(&
&           peln(i, k+1, j)-peln(i, k, j))-(pk(i, j, k+1)-pk(i, j, k))*&
&           kappa*(peln_tl(i, k+1, j)-peln_tl(i, k, j)))/(kappa*(peln(i&
&           , k+1, j)-peln(i, k, j)))**2
          pkz(i, j, k) = (pk(i, j, k+1)-pk(i, j, k))/(kappa*(peln(i, k+1&
&           , j)-peln(i, k, j)))
        END DO
      END DO
    END DO
  END SUBROUTINE COMPUTE_PRESSURES_TLM
  SUBROUTINE COMPUTE_PRESSURES(bd, npz, kappa, ptop, delp, pe, pk, pkz, &
&   peln)
    IMPLICIT NONE
!Arguments
    TYPE(FV_GRID_BOUNDS_TYPE), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npz
    REAL, INTENT(IN) :: kappa, ptop
    REAL, INTENT(IN) :: delp(bd%isd:bd%ied, bd%jsd:bd%jed, npz)
    REAL, INTENT(OUT) :: pe(bd%is-1:bd%ie+1, npz+1, bd%js-1:bd%je+1)
    REAL, INTENT(OUT) :: pk(bd%is:bd%ie, bd%js:bd%je, npz+1)
    REAL, INTENT(OUT) :: peln(bd%is:bd%ie, npz+1, bd%js:bd%je)
    REAL, INTENT(OUT) :: pkz(bd%is:bd%ie, bd%js:bd%je, npz)
!Locals
    INTEGER :: i, j, k, is, ie, js, je
    INTRINSIC LOG
    INTRINSIC EXP
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    pe(:, :, :) = 0.0
    pe(:, 1, :) = ptop
    DO k=2,npz+1
      DO j=js,je
        DO i=is,ie
          pe(i, k, j) = pe(i, k-1, j) + delp(i, j, k-1)
        END DO
      END DO
    END DO
    DO k=1,npz+1
      DO j=js,je
        DO i=is,ie
          peln(i, k, j) = LOG(pe(i, k, j))
        END DO
      END DO
    END DO
    DO k=1,npz+1
      DO j=js,je
        DO i=is,ie
          pk(i, j, k) = EXP(kappa*peln(i, k, j))
        END DO
      END DO
    END DO
    DO k=1,npz
      DO j=js,je
        DO i=is,ie
          pkz(i, j, k) = (pk(i, j, k+1)-pk(i, j, k))/(kappa*(peln(i, k+1&
&           , j)-peln(i, k, j)))
        END DO
      END DO
    END DO
  END SUBROUTINE COMPUTE_PRESSURES
END MODULE MAIN_MOD_DIFF
