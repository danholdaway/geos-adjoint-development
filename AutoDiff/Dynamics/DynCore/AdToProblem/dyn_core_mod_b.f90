!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
MODULE DYN_CORE_MOD_B
  USE ARRAY_MOD
  IMPLICIT NONE
  PRIVATE 

CONTAINS
!  Differentiation of dyn_core in reverse (adjoint) mode, forward sweep (with options r8 split(dyn_core_mod.dyn_core dyn_core_mod
!.again)):
!   gradient     of useful results: u v
!   with respect to varying inputs: u v
  SUBROUTINE DYN_CORE_FWD(bd, npz, u, v, us, vs)
    IMPLICIT NONE
    TYPE(GRID), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npz
    REAL, INTENT(INOUT) :: u(bd%is:bd%ie, bd%js:bd%ie, npz+1)
    REAL, INTENT(INOUT) :: us(bd%is:bd%ie, bd%js:bd%ie)
    REAL, INTENT(INOUT) :: v(bd%is:bd%ie, bd%js:bd%ie, npz+1)
    REAL, INTENT(INOUT) :: vs(bd%is:bd%ie, bd%js:bd%ie)
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    DO j=js,je
      DO i=is,ie
        u(i, j, npz+1) = us(i, j)
      END DO
      DO k=npz,1,-1
        DO i=is,ie
          CALL PUSHREAL8(u(i, j, k))
          u(i, j, k) = u(i, j, k+1) - u(i, j, k)*v(i, j, k)
        END DO
      END DO
    END DO
    DO j=js,je
      DO i=is,ie
        CALL PUSHREAL8(v(i, j, npz+1))
        v(i, j, npz+1) = vs(i, j)
      END DO
      DO k=npz,1,-1
        DO i=is,ie
          CALL PUSHREAL8(v(i, j, k))
          v(i, j, k) = v(i, j, k+1) - v(i, j, k)*u(i, j, k)
        END DO
      END DO
    END DO
    CALL AGAIN_FWD(is, ie, js, je, npz, u, v, us, vs)
    CALL PUSHINTEGER4(js)
    CALL PUSHINTEGER4(ie)
    CALL PUSHINTEGER4(is)
    CALL PUSHINTEGER4(je)
  END SUBROUTINE DYN_CORE_FWD
!  Differentiation of dyn_core in reverse (adjoint) mode, backward sweep (with options r8 split(dyn_core_mod.dyn_core dyn_core_mo
!d.again)):
!   gradient     of useful results: u v
!   with respect to varying inputs: u v
!   RW status of diff variables: u:in-out v:in-out
  SUBROUTINE DYN_CORE_BWD(bd, npz, u, u_ad, v, v_ad, us, vs)
    IMPLICIT NONE
    TYPE(GRID), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npz
    REAL, INTENT(INOUT) :: u(bd%is:bd%ie, bd%js:bd%ie, npz+1)
    REAL, INTENT(INOUT) :: u_ad(bd%is:bd%ie, bd%js:bd%ie, npz+1)
    REAL, INTENT(INOUT) :: us(bd%is:bd%ie, bd%js:bd%ie)
    REAL, INTENT(INOUT) :: v(bd%is:bd%ie, bd%js:bd%ie, npz+1)
    REAL, INTENT(INOUT) :: v_ad(bd%is:bd%ie, bd%js:bd%ie, npz+1)
    REAL, INTENT(INOUT) :: vs(bd%is:bd%ie, bd%js:bd%ie)
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
    CALL POPINTEGER4(je)
    CALL POPINTEGER4(is)
    CALL POPINTEGER4(ie)
    CALL POPINTEGER4(js)
    CALL AGAIN_BWD(is, ie, js, je, npz, u, u_ad, v, v_ad, us, vs)
    DO j=je,js,-1
      DO k=1,npz,1
        DO i=ie,is,-1
          CALL POPREAL8(v(i, j, k))
          v_ad(i, j, k+1) = v_ad(i, j, k+1) + v_ad(i, j, k)
          u_ad(i, j, k) = u_ad(i, j, k) - v(i, j, k)*v_ad(i, j, k)
          v_ad(i, j, k) = -(u(i, j, k)*v_ad(i, j, k))
        END DO
      END DO
      DO i=ie,is,-1
        CALL POPREAL8(v(i, j, npz+1))
        v_ad(i, j, npz+1) = 0.0_8
      END DO
    END DO
    DO j=je,js,-1
      DO k=1,npz,1
        DO i=ie,is,-1
          CALL POPREAL8(u(i, j, k))
          u_ad(i, j, k+1) = u_ad(i, j, k+1) + u_ad(i, j, k)
          v_ad(i, j, k) = v_ad(i, j, k) - u(i, j, k)*u_ad(i, j, k)
          u_ad(i, j, k) = -(v(i, j, k)*u_ad(i, j, k))
        END DO
      END DO
      DO i=ie,is,-1
        u_ad(i, j, npz+1) = 0.0_8
      END DO
    END DO
  END SUBROUTINE DYN_CORE_BWD
  SUBROUTINE DYN_CORE(bd, npz, u, v, us, vs)
    IMPLICIT NONE
    TYPE(GRID), INTENT(IN) :: bd
    INTEGER, INTENT(IN) :: npz
    REAL, INTENT(INOUT) :: u(bd%is:bd%ie, bd%js:bd%ie, npz+1)
    REAL, INTENT(INOUT) :: us(bd%is:bd%ie, bd%js:bd%ie)
    REAL, INTENT(INOUT) :: v(bd%is:bd%ie, bd%js:bd%ie, npz+1)
    REAL, INTENT(INOUT) :: vs(bd%is:bd%ie, bd%js:bd%ie)
    INTEGER :: i, j, k
    INTEGER :: is, ie, js, je
    is = bd%is
    ie = bd%ie
    js = bd%js
    je = bd%je
    DO j=js,je
      DO i=is,ie
        u(i, j, npz+1) = us(i, j)
      END DO
      DO k=npz,1,-1
        DO i=is,ie
          u(i, j, k) = u(i, j, k+1) - u(i, j, k)*v(i, j, k)
        END DO
      END DO
    END DO
    DO j=js,je
      DO i=is,ie
        v(i, j, npz+1) = vs(i, j)
      END DO
      DO k=npz,1,-1
        DO i=is,ie
          v(i, j, k) = v(i, j, k+1) - v(i, j, k)*u(i, j, k)
        END DO
      END DO
    END DO
    CALL AGAIN(is, ie, js, je, npz, u, v, us, vs)
  END SUBROUTINE DYN_CORE
!  Differentiation of again in reverse (adjoint) mode, forward sweep (with options r8 split(dyn_core_mod.dyn_core dyn_core_mod.ag
!ain)):
!   gradient     of useful results: u v
!   with respect to varying inputs: u v
  SUBROUTINE AGAIN_FWD(is, ie, js, je, npz, u, v, us, vs)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: is, ie, js, je, npz
    REAL, INTENT(INOUT) :: u(is:ie, js:ie, npz+1)
    REAL, INTENT(INOUT) :: us(is:ie, js:ie)
    REAL, INTENT(INOUT) :: v(is:ie, js:ie, npz+1)
    REAL, INTENT(INOUT) :: vs(is:ie, js:ie)
    INTEGER :: i, j, k
    DO j=js,je
      DO i=is,ie
        CALL PUSHREAL8(u(i, j, npz+1))
        u(i, j, npz+1) = us(i, j)
      END DO
      DO k=npz,1,-1
        DO i=is,ie
          CALL PUSHREAL8(u(i, j, k))
          u(i, j, k) = u(i, j, k+1) - u(i, j, k)*v(i, j, k)
        END DO
      END DO
    END DO
    DO j=js,je
      DO i=is,ie
        CALL PUSHREAL8(v(i, j, npz+1))
        v(i, j, npz+1) = vs(i, j)
      END DO
      DO k=npz,1,-1
        DO i=is,ie
          CALL PUSHREAL8(v(i, j, k))
          v(i, j, k) = v(i, j, k+1) - v(i, j, k)*u(i, j, k)
        END DO
      END DO
    END DO
  END SUBROUTINE AGAIN_FWD
!  Differentiation of again in reverse (adjoint) mode, backward sweep (with options r8 split(dyn_core_mod.dyn_core dyn_core_mod.a
!gain)):
!   gradient     of useful results: u v
!   with respect to varying inputs: u v
  SUBROUTINE AGAIN_BWD(is, ie, js, je, npz, u, u_ad, v, v_ad, us, vs)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: is, ie, js, je, npz
    REAL, INTENT(INOUT) :: u(is:ie, js:ie, npz+1)
    REAL, INTENT(INOUT) :: u_ad(is:ie, js:ie, npz+1)
    REAL, INTENT(INOUT) :: us(is:ie, js:ie)
    REAL, INTENT(INOUT) :: v(is:ie, js:ie, npz+1)
    REAL, INTENT(INOUT) :: v_ad(is:ie, js:ie, npz+1)
    REAL, INTENT(INOUT) :: vs(is:ie, js:ie)
    INTEGER :: i, j, k
    DO j=je,js,-1
      DO k=1,npz,1
        DO i=ie,is,-1
          CALL POPREAL8(v(i, j, k))
          v_ad(i, j, k+1) = v_ad(i, j, k+1) + v_ad(i, j, k)
          u_ad(i, j, k) = u_ad(i, j, k) - v(i, j, k)*v_ad(i, j, k)
          v_ad(i, j, k) = -(u(i, j, k)*v_ad(i, j, k))
        END DO
      END DO
      DO i=ie,is,-1
        CALL POPREAL8(v(i, j, npz+1))
        v_ad(i, j, npz+1) = 0.0_8
      END DO
    END DO
    DO j=je,js,-1
      DO k=1,npz,1
        DO i=ie,is,-1
          CALL POPREAL8(u(i, j, k))
          u_ad(i, j, k+1) = u_ad(i, j, k+1) + u_ad(i, j, k)
          v_ad(i, j, k) = v_ad(i, j, k) - u(i, j, k)*u_ad(i, j, k)
          u_ad(i, j, k) = -(v(i, j, k)*u_ad(i, j, k))
        END DO
      END DO
      DO i=ie,is,-1
        CALL POPREAL8(u(i, j, npz+1))
        u_ad(i, j, npz+1) = 0.0_8
      END DO
    END DO
  END SUBROUTINE AGAIN_BWD
  SUBROUTINE AGAIN(is, ie, js, je, npz, u, v, us, vs)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: is, ie, js, je, npz
    REAL, INTENT(INOUT) :: u(is:ie, js:ie, npz+1)
    REAL, INTENT(INOUT) :: us(is:ie, js:ie)
    REAL, INTENT(INOUT) :: v(is:ie, js:ie, npz+1)
    REAL, INTENT(INOUT) :: vs(is:ie, js:ie)
    INTEGER :: i, j, k
    DO j=js,je
      DO i=is,ie
        u(i, j, npz+1) = us(i, j)
      END DO
      DO k=npz,1,-1
        DO i=is,ie
          u(i, j, k) = u(i, j, k+1) - u(i, j, k)*v(i, j, k)
        END DO
      END DO
    END DO
    DO j=js,je
      DO i=is,ie
        v(i, j, npz+1) = vs(i, j)
      END DO
      DO k=npz,1,-1
        DO i=is,ie
          v(i, j, k) = v(i, j, k+1) - v(i, j, k)*u(i, j, k)
        END DO
      END DO
    END DO
  END SUBROUTINE AGAIN
END MODULE DYN_CORE_MOD_B
