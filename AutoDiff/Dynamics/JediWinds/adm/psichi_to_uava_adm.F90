!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.13 (r6666) - 27 Nov 2017 17:09
!
MODULE PSICHI_TO_UAVA_MOD_DIFF
  IMPLICIT NONE
!-----------------
  INTEGER, PARAMETER :: kind_real=8
  PRIVATE 
  PUBLIC psichi_to_uava
  PUBLIC psichi_to_uava_adm
  TYPE DOMAIN2D
      INTEGER :: dummy
  END TYPE DOMAIN2D
!data domain
!compute domain
!x/y/z-dir grid edge points per tile
!Processor layout for computation
!Processor layout for read/write
!Number of halo points, normally 3
!FV3 nml file associated with this geom
!Size of cubed sphere grid (cell center)
!MPP domain
!Tile ID
!Number of tiles, always 6
!Stackmax
!Longitude at cell center
!Latitude at cell center
!Longitude at cell center
!Latitude at cell center
!Grid area
!Model level coefficients
!Pressure at top of domain
  TYPE FV3JEDI_GEOM
      INTEGER :: isd, ied, jsd, jed
      INTEGER :: isc, iec, jsc, jec
      INTEGER :: npx, npy, npz
      INTEGER :: layout(2)
      INTEGER :: io_layout(2)
      INTEGER :: halo
      CHARACTER(len=255) :: nml_file
      INTEGER :: size_cubic_grid
      TYPE(DOMAIN2D) :: domain
      INTEGER :: ntile
      INTEGER :: ntiles=6
      INTEGER :: stackmax
      REAL(kind=kind_real), ALLOCATABLE :: grid_lon(:, :)
      REAL(kind=kind_real), ALLOCATABLE :: grid_lat(:, :)
      REAL(kind=kind_real), ALLOCATABLE :: egrid_lon(:, :)
      REAL(kind=kind_real), ALLOCATABLE :: egrid_lat(:, :)
      REAL(kind=kind_real), ALLOCATABLE :: area(:, :)
      REAL(kind=kind_real), ALLOCATABLE :: ak(:), bk(:)
      REAL(kind=kind_real) :: ptop
      REAL(kind=kind_real), ALLOCATABLE :: sin_sg(:, :, :)
      REAL(kind=kind_real), ALLOCATABLE :: cos_sg(:, :, :)
      REAL(kind=kind_real), ALLOCATABLE :: cosa_u(:, :)
      REAL(kind=kind_real), ALLOCATABLE :: cosa_v(:, :)
      REAL(kind=kind_real), ALLOCATABLE :: cosa_s(:, :)
      REAL(kind=kind_real), ALLOCATABLE :: rsin_u(:, :)
      REAL(kind=kind_real), ALLOCATABLE :: rsin_v(:, :)
      REAL(kind=kind_real), ALLOCATABLE :: rsin2(:, :)
      REAL(kind=kind_real), ALLOCATABLE :: dxa(:, :)
      REAL(kind=kind_real), ALLOCATABLE :: dya(:, :)
      REAL(kind=kind_real), ALLOCATABLE :: dx(:, :)
      REAL(kind=kind_real), ALLOCATABLE :: dy(:, :)
      REAL(kind=kind_real), ALLOCATABLE :: dxc(:, :)
      REAL(kind=kind_real), ALLOCATABLE :: dyc(:, :)
      REAL(kind=kind_real), ALLOCATABLE :: rarea(:, :)
      REAL(kind=kind_real), ALLOCATABLE :: rarea_c(:, :)
      REAL(kind=kind_real), ALLOCATABLE :: edge_w(:)
      REAL(kind=kind_real), ALLOCATABLE :: edge_e(:)
      REAL(kind=kind_real), ALLOCATABLE :: edge_s(:)
      REAL(kind=kind_real), ALLOCATABLE :: edge_n(:)
      REAL(kind=kind_real), ALLOCATABLE :: grid(:, :, :)
      REAL(kind=kind_real), ALLOCATABLE :: agrid(:, :, :)
      LOGICAL :: sw_corner, se_corner, ne_corner, nw_corner
      REAL(kind=kind_real), ALLOCATABLE :: vlon(:, :, :)
      REAL(kind=kind_real), ALLOCATABLE :: vlat(:, :, :)
      REAL(kind=kind_real), ALLOCATABLE :: edge_vect_n(:)
      REAL(kind=kind_real), ALLOCATABLE :: edge_vect_e(:)
      REAL(kind=kind_real), ALLOCATABLE :: edge_vect_s(:)
      REAL(kind=kind_real), ALLOCATABLE :: edge_vect_w(:)
      REAL(kind=kind_real), ALLOCATABLE :: es(:, :, :, :)
      REAL(kind=kind_real), ALLOCATABLE :: ew(:, :, :, :)
  END TYPE FV3JEDI_GEOM

CONTAINS
!  Differentiation of psichi_to_uava in reverse (adjoint) mode:
!   gradient     of useful results: psi ua va chi
!   with respect to varying inputs: psi ua va chi
!   RW status of diff variables: psi:in-out ua:in-out va:in-out
!                chi:in-out
  SUBROUTINE PSICHI_TO_UAVA_ADM(geom, psi, psi_ad, chi, chi_ad, ua, &
&   ua_ad, va, va_ad)
    IMPLICIT NONE
    TYPE(FV3JEDI_GEOM), INTENT(INOUT) :: geom
!Stream function
    REAL(kind=kind_real), INTENT(INOUT) :: psi(geom%isd:geom%ied, geom%&
&   jsd:geom%jed, geom%npz)
    REAL(kind=kind_real), INTENT(INOUT) :: psi_ad(geom%isd:geom%ied, &
&   geom%jsd:geom%jed, geom%npz)
!Velocity potential
    REAL(kind=kind_real), INTENT(INOUT) :: chi(geom%isd:geom%ied, geom%&
&   jsd:geom%jed, geom%npz)
    REAL(kind=kind_real), INTENT(INOUT) :: chi_ad(geom%isd:geom%ied, &
&   geom%jsd:geom%jed, geom%npz)
!Agrid winds (u)
    REAL(kind=kind_real) :: ua(geom%isc:geom%iec, geom%jsc:geom%jec, &
&   geom%npz)
    REAL(kind=kind_real) :: ua_ad(geom%isc:geom%iec, geom%jsc:geom%jec, &
&   geom%npz)
!Agrid winds (v)
    REAL(kind=kind_real) :: va(geom%isc:geom%iec, geom%jsc:geom%jec, &
&   geom%npz)
    REAL(kind=kind_real) :: va_ad(geom%isc:geom%iec, geom%jsc:geom%jec, &
&   geom%npz)
    INTEGER :: i, j, k
    REAL(kind=kind_real) :: temp_ad
    REAL(kind=kind_real) :: temp_ad0
    REAL(kind=kind_real) :: temp_ad1
    REAL(kind=kind_real) :: temp_ad2
    DO k=geom%npz,1,-1
      DO j=geom%jec,geom%jsc,-1
        DO i=geom%iec,geom%isc,-1
          temp_ad = va_ad(i, j, k)/(geom%dyc(i, j)+geom%dyc(i, j+1))
          temp_ad0 = -(va_ad(i, j, k)/(geom%dxc(i, j)+geom%dxc(i+1, j)))
          chi_ad(i, j+1, k) = chi_ad(i, j+1, k) + temp_ad
          chi_ad(i, j-1, k) = chi_ad(i, j-1, k) - temp_ad
          psi_ad(i+1, j, k) = psi_ad(i+1, j, k) + temp_ad0
          psi_ad(i-1, j, k) = psi_ad(i-1, j, k) - temp_ad0
          va_ad(i, j, k) = 0.0_8
          temp_ad1 = ua_ad(i, j, k)/(geom%dyc(i, j)+geom%dyc(i, j+1))
          temp_ad2 = ua_ad(i, j, k)/(geom%dxc(i, j)+geom%dxc(i+1, j))
          psi_ad(i, j+1, k) = psi_ad(i, j+1, k) + temp_ad1
          psi_ad(i, j-1, k) = psi_ad(i, j-1, k) - temp_ad1
          chi_ad(i+1, j, k) = chi_ad(i+1, j, k) + temp_ad2
          chi_ad(i-1, j, k) = chi_ad(i-1, j, k) - temp_ad2
          ua_ad(i, j, k) = 0.0_8
        END DO
      END DO
    END DO
    CALL MPP_UPDATE_DOMAINS_ADM(chi, chi_ad, geom%domain, complete=&
&                         .true.)
    CALL MPP_UPDATE_DOMAINS_ADM(psi, psi_ad, geom%domain, complete=&
&                         .true.)
  END SUBROUTINE PSICHI_TO_UAVA_ADM
  SUBROUTINE PSICHI_TO_UAVA(geom, psi, chi, ua, va)
    IMPLICIT NONE
    TYPE(FV3JEDI_GEOM), INTENT(INOUT) :: geom
!Stream function
    REAL(kind=kind_real), INTENT(INOUT) :: psi(geom%isd:geom%ied, geom%&
&   jsd:geom%jed, geom%npz)
!Velocity potential
    REAL(kind=kind_real), INTENT(INOUT) :: chi(geom%isd:geom%ied, geom%&
&   jsd:geom%jed, geom%npz)
!Agrid winds (u)
    REAL(kind=kind_real), INTENT(OUT) :: ua(geom%isc:geom%iec, geom%jsc:&
&   geom%jec, geom%npz)
!Agrid winds (v)
    REAL(kind=kind_real), INTENT(OUT) :: va(geom%isc:geom%iec, geom%jsc:&
&   geom%jec, geom%npz)
    INTEGER :: i, j, k
    CALL MPP_UPDATE_DOMAINS(psi, geom%domain, .true.)
    CALL MPP_UPDATE_DOMAINS(chi, geom%domain, .true.)
    DO k=1,geom%npz
      DO j=geom%jsc,geom%jec
        DO i=geom%isc,geom%iec
          ua(i, j, k) = (psi(i, j+1, k)-psi(i, j-1, k))/(geom%dyc(i, j)+&
&           geom%dyc(i, j+1)) + (chi(i+1, j, k)-chi(i-1, j, k))/(geom%&
&           dxc(i, j)+geom%dxc(i+1, j))
          va(i, j, k) = -((psi(i+1, j, k)-psi(i-1, j, k))/(geom%dxc(i, j&
&           )+geom%dxc(i+1, j))) + (chi(i, j+1, k)-chi(i, j-1, k))/(geom&
&           %dyc(i, j)+geom%dyc(i, j+1))
        END DO
      END DO
    END DO
  END SUBROUTINE PSICHI_TO_UAVA
!  Differentiation of mpp_update_domains in reverse (adjoint) mode:
!   gradient     of useful results: field
!   with respect to varying inputs: field
!-----------------
  SUBROUTINE MPP_UPDATE_DOMAINS_ADM(field, field_ad, domain, complete)
    IMPLICIT NONE
    REAL(kind=kind_real), INTENT(INOUT) :: field(:, :, :)
    REAL(kind=kind_real), INTENT(INOUT) :: field_ad(:, :, :)
    TYPE(DOMAIN2D), INTENT(IN) :: domain
    LOGICAL, INTENT(IN) :: complete
    IF (complete) field_ad = domain%dummy*2*field*field_ad
  END SUBROUTINE MPP_UPDATE_DOMAINS_ADM
!-----------------
  SUBROUTINE MPP_UPDATE_DOMAINS(field, domain, complete)
    IMPLICIT NONE
    REAL(kind=kind_real), INTENT(INOUT) :: field(:, :, :)
    TYPE(DOMAIN2D), INTENT(IN) :: domain
    LOGICAL, INTENT(IN) :: complete
    IF (complete) field = field*field*domain%dummy
  END SUBROUTINE MPP_UPDATE_DOMAINS
END MODULE PSICHI_TO_UAVA_MOD_DIFF
