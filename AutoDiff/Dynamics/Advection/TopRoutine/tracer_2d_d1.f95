subroutine g_v2_tracer_2d_1l( q, g_q, dp1, g_dp1, mfx, g_mfx, mfy, g_mfy, cx, g_cx, cy, g_cy, npx, npy, npz, nq, hord, q_split, k, &
&q3, g_q3, dt, uniform_ppm, id_divg )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.71  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use g_v2_tp_core_mod, only : g_v2_fv_tp_2d_trc
use g_fv_my_mpp, only : g_mp_reduce_max_dummy, g_mpp_update_domains_dummy4

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
integer, parameter :: nsplt_maxi = 5

!==============================================
! declare arguments
!==============================================
real, intent(inout) :: cx(is:ie+1,jsd:jed)
real, intent(inout) :: cy(isd:ied,js:je+1)
real, intent(inout) :: dp1(is:ie,js:je)
real, intent(in) :: dt
real, intent(inout) :: g_cx(is:ie+1,jsd:jed)
real, intent(inout) :: g_cy(isd:ied,js:je+1)
real, intent(inout) :: g_dp1(is:ie,js:je)
real, intent(inout) :: g_mfx(is:ie+1,js:je)
real, intent(inout) :: g_mfy(is:ie,js:je+1)
integer, intent(in) :: nq
real, intent(inout) :: g_q(isd:ied,jsd:jed,nq)
integer, intent(in) :: npz
real, intent(inout) :: g_q3(isd:ied,jsd:jed,npz,nq)
integer, intent(in) :: hord
integer, intent(in) :: id_divg
integer, intent(in) :: k
real, intent(inout) :: mfx(is:ie+1,js:je)
real, intent(inout) :: mfy(is:ie,js:je+1)
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: q(isd:ied,jsd:jed,nq)
real, intent(inout) :: q3(isd:ied,jsd:jed,npz,nq)
integer, intent(in) :: q_split
logical, intent(in) :: uniform_ppm

!==============================================
! declare local variables
!==============================================
real :: cmax
real :: cmaxh
real :: dp2(isd:ied,jsd:jed)
real :: frac
real :: fx(is:ie+1,js:je)
real :: fy(is:ie,js:je+1)
real :: g_cmax
real :: g_dp2(isd:ied,jsd:jed)
real :: g_frac
real :: g_fx(is:ie+1,js:je)
real :: g_fy(is:ie,js:je+1)
real :: g_ra_x(is:ie,jsd:jed)
real :: g_ra_y(isd:ied,js:je)
real :: g_rdt
real :: g_xfx(is:ie+1,jsd:jed)
real :: g_yfx(isd:ied,js:je+1)
integer :: i
integer :: i_taf
integer :: iq
integer :: iq_taf
integer :: it
integer :: j
integer :: nsplt
real :: ra_x(is:ie,jsd:jed)
real :: ra_y(isd:ied,js:je)
real :: rdt
real :: xfx(is:ie+1,jsd:jed)
real :: yfx(isd:ied,js:je+1)

!----------------------------------------------
! TANGENT LINEAR AND FUNCTION STATEMENTS
!----------------------------------------------
do j = jsd, jed
  do i = is, ie+1
    if (cx(i,j) .gt. 0.) then
      g_xfx(i,j) = g_cx(i,j)*dxa(i-1,j)*dy(i,j)*sina_u(i,j)
      xfx(i,j) = cx(i,j)*dxa(i-1,j)*dy(i,j)*sina_u(i,j)
    else
      g_xfx(i,j) = g_cx(i,j)*dxa(i,j)*dy(i,j)*sina_u(i,j)
      xfx(i,j) = cx(i,j)*dxa(i,j)*dy(i,j)*sina_u(i,j)
    endif
  end do
end do
do j = js, je+1
  do i = isd, ied
    if (cy(i,j) .gt. 0.) then
      g_yfx(i,j) = g_cy(i,j)*dya(i,j-1)*dx(i,j)*sina_v(i,j)
      yfx(i,j) = cy(i,j)*dya(i,j-1)*dx(i,j)*sina_v(i,j)
    else
      g_yfx(i,j) = g_cy(i,j)*dya(i,j)*dx(i,j)*sina_v(i,j)
      yfx(i,j) = cy(i,j)*dya(i,j)*dx(i,j)*sina_v(i,j)
    endif
  end do
end do
if (q_split .eq. 0) then
  g_cmax = 0.
  cmax = 0.
  do j = js, je
    do i = is, ie
      cmaxh = max(abs(cx(i,j))+1.-sina_u(i,j),abs(cy(i,j))+1.-sina_v(i,j))
      g_cmax = g_cmax*(0.5-sign(0.5,cmaxh-cmax))+(g_cx(i,j)*(0.5+sign(0.5,abs(cx(i,j))+1.-sina_u(i,j)-(abs(cy(i,j))+1.-sina_v(i,j))&
&))*sign(1.,cx(i,j))+g_cy(i,j)*(0.5-sign(0.5,abs(cx(i,j))+1.-sina_u(i,j)-(abs(cy(i,j))+1.-sina_v(i,j))))*sign(1.,cy(i,j)))*&
&(0.5+sign(0.5,cmaxh-cmax))
      cmax = max(cmaxh,cmax)
    end do
  end do
  call g_mp_reduce_max( cmax,g_cmax )
  nsplt = int(1.0001+cmax)
else
  nsplt = q_split
endif
if (nsplt .gt. nsplt_max) then
  nsplt = nsplt_max
endif
g_frac = 0.
frac = 1./real(nsplt)
if (nsplt .ne. 1) then
  do j = jsd, jed
    do i = is, ie+1
      g_cx(i,j) = g_cx(i,j)*frac+g_frac*cx(i,j)
      cx(i,j) = cx(i,j)*frac
      g_xfx(i,j) = g_frac*xfx(i,j)+g_xfx(i,j)*frac
      xfx(i,j) = xfx(i,j)*frac
    end do
  end do
  do j = js, je
    do i = is, ie+1
      g_mfx(i,j) = g_frac*mfx(i,j)+g_mfx(i,j)*frac
      mfx(i,j) = mfx(i,j)*frac
    end do
  end do
  do j = js, je+1
    do i = isd, ied
      g_cy(i,j) = g_cy(i,j)*frac+g_frac*cy(i,j)
      cy(i,j) = cy(i,j)*frac
      g_yfx(i,j) = g_frac*yfx(i,j)+g_yfx(i,j)*frac
      yfx(i,j) = yfx(i,j)*frac
    end do
  end do
  do j = js, je+1
    do i = is, ie
      g_mfy(i,j) = g_frac*mfy(i,j)+g_mfy(i,j)*frac
      mfy(i,j) = mfy(i,j)*frac
    end do
  end do
endif
do j = jsd, jed
  do i = is, ie
    g_ra_x(i,j) = (-g_xfx(i+1,j))+g_xfx(i,j)
    ra_x(i,j) = area(i,j)+xfx(i,j)-xfx(i+1,j)
  end do
end do
do j = js, je
  do i = isd, ied
    g_ra_y(i,j) = (-g_yfx(i,j+1))+g_yfx(i,j)
    ra_y(i,j) = area(i,j)+yfx(i,j)-yfx(i,j+1)
  end do
end do
do it = 1, nsplt
  do j = js, je
    do i = is, ie
      g_dp2(i,j) = g_dp1(i,j)-g_mfx(i+1,j)*rarea(i,j)+g_mfx(i,j)*rarea(i,j)-g_mfy(i,j+1)*rarea(i,j)+g_mfy(i,j)*rarea(i,j)
      dp2(i,j) = dp1(i,j)+(mfx(i,j)-mfx(i+1,j)+mfy(i,j)-mfy(i,j+1))*rarea(i,j)
    end do
  end do
  i_taf = (k-1)*nsplt_max+it
  call g_mpp_update_domains_dummy4( q,g_q,is,ie,js,je,isd,ied,jsd,jed,1,nq )
  do iq = 1, nq
    iq_taf = (k-1)*nq*nsplt_max+(it-1)*nq+iq

    call g_v2_fv_tp_2d_trc( q(isd,jsd,iq),g_q(isd,jsd,iq),cx,g_cx,cy,g_cy,npx,npy,hord,fx,g_fx,fy,g_fy,xfx,g_xfx,yfx,g_yfx,area,&
&ra_x,g_ra_x,ra_y,g_ra_y,uniform_ppm,mfx,g_mfx,mfy,g_mfy, .true. ,iq_taf )

    if (it .eq. nsplt) then
      do j = js, je
        do i = is, ie
          g_q3(i,j,k,iq) = g_dp1(i,j)*(q(i,j,iq)/dp2(i,j))-g_dp2(i,j)*((q(i,j,iq)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*&
&rarea(i,j))/(dp2(i,j)*dp2(i,j)))-g_fx(i+1,j)*(rarea(i,j)/dp2(i,j))+g_fx(i,j)*(rarea(i,j)/dp2(i,j))-g_fy(i,j+1)*(rarea(i,&
&j)/dp2(i,j))+g_fy(i,j)*(rarea(i,j)/dp2(i,j))+g_q(i,j,iq)*(dp1(i,j)/dp2(i,j))
          q3(i,j,k,iq) = (q(i,j,iq)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/dp2(i,j)
        end do
      end do
    else
      do j = js, je
        do i = is, ie
          g_q(i,j,iq) = g_dp1(i,j)*(q(i,j,iq)/dp2(i,j))-g_dp2(i,j)*((q(i,j,iq)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*&
&rarea(i,j))/(dp2(i,j)*dp2(i,j)))-g_fx(i+1,j)*(rarea(i,j)/dp2(i,j))+g_fx(i,j)*(rarea(i,j)/dp2(i,j))-g_fy(i,j+1)*(rarea(i,&
&j)/dp2(i,j))+g_fy(i,j)*(rarea(i,j)/dp2(i,j))+g_q(i,j,iq)*(dp1(i,j)/dp2(i,j))
          q(i,j,iq) = (q(i,j,iq)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/dp2(i,j)
        end do
      end do
    endif
  end do
  if (it .ne. nsplt) then
    do j = js, je
      do i = is, ie
        g_dp1(i,j) = g_dp2(i,j)
        dp1(i,j) = dp2(i,j)
      end do
    end do
  endif
end do
if (id_divg .gt. 0) then
  g_rdt = -(g_frac*(1.*dt/(frac*dt*frac*dt)))
  rdt = 1./(frac*dt)
  do j = js, je
    do i = is, ie
      g_dp1(i,j) = g_rdt*(xfx(i+1,j)-xfx(i,j)+yfx(i,j+1)-yfx(i,j))*rarea(i,j)+g_xfx(i+1,j)*rarea(i,j)*rdt-g_xfx(i,j)*rarea(i,j)*&
&rdt+g_yfx(i,j+1)*rarea(i,j)*rdt-g_yfx(i,j)*rarea(i,j)*rdt
      dp1(i,j) = (xfx(i+1,j)-xfx(i,j)+yfx(i,j+1)-yfx(i,j))*rarea(i,j)*rdt
    end do
  end do
endif

end subroutine g_v2_tracer_2d_1l
