subroutine adv2_tracer_2d_1l( q, adq, dp1, addp1, mfx, admfx, mfy, admfy, cx, adcx, cy, adcy, npx, npy, npz, nq, hord, q_split, k, &
&adq3, dt, uniform_ppm, id_divg )
!******************************************************************
!******************************************************************
!** This routine was generated by Automatic differentiation.     **
!** FastOpt: Transformation of Algorithm in Fortran, TAF 1.9.71  **
!******************************************************************
!******************************************************************
!==============================================
! referencing used modules
!==============================================
use adv2_tracer_2d_1l_store, only : trc_1l_nsplt_3h,trc_1l_v2_tracer_2d_1l,trc_1lnspzq_cx_2h,trc_1lnspzq_cy_3h,trc_1lnspzq_fx_13h,&
&trc_1lnspzq_fx_16h,trc_1lnspzq_fy_14h,trc_1lnspzq_fy_17h,trc_1lnspzq_mfx_10h,trc_1lnspzq_mfy_11h,trc_1lnspzq_q_12h,&
&trc_1lnspzq_q_15h,trc_1lnspzq_ra_x_8h,trc_1lnspzq_ra_y_9h,trc_1lnspzq_v2_tracer_2d_1l,trc_1lnspzq_xfx_6h,trc_1lnspzq_yfx_7h
use adv2_tp_core_mod, only : adv2_fv_tp_2d_trc
use adfv_my_mpp, only : admp_reduce_max_dummy, admpp_update_domains_dummy4

!==============================================
! all entries are defined explicitly
!==============================================
implicit none

!==============================================
! declare parameters
!==============================================
integer, parameter :: nsplt_maxi = 5

!==============================================
! declare arguments
!==============================================
real, intent(inout) :: adcx(is:ie+1,jsd:jed)
real, intent(inout) :: adcy(isd:ied,js:je+1)
real, intent(inout) :: addp1(is:ie,js:je)
real, intent(inout) :: admfx(is:ie+1,js:je)
real, intent(inout) :: admfy(is:ie,js:je+1)
integer, intent(in) :: nq
real, intent(inout) :: adq(isd:ied,jsd:jed,nq)
integer, intent(in) :: npz
real, intent(inout) :: adq3(isd:ied,jsd:jed,npz,nq)

real :: adcx_tmp(is:ie+1,jsd:jed)
real :: adcy_tmp(isd:ied,js:je+1)
real :: addp1_tmp(is:ie,js:je)
real :: admfx_tmp(is:ie+1,js:je)
real :: admfy_tmp(is:ie,js:je+1)
real :: adq_tmp(isd:ied,jsd:jed,nq)
real :: adq3_tmp(isd:ied,jsd:jed,npz,nq)

real, intent(inout) :: cx(is:ie+1,jsd:jed)
real, intent(inout) :: cy(isd:ied,js:je+1)
real, intent(inout) :: dp1(is:ie,js:je)
real, intent(in) :: dt
integer, intent(in) :: hord
integer, intent(in) :: id_divg
integer, intent(in) :: k
real, intent(inout) :: mfx(is:ie+1,js:je)
real, intent(inout) :: mfy(is:ie,js:je+1)
integer, intent(in) :: npx
integer, intent(in) :: npy
real, intent(inout) :: q(isd:ied,jsd:jed,nq)
integer, intent(in) :: q_split
logical, intent(in) :: uniform_ppm

!==============================================
! declare local variables
!==============================================
real :: adcmax
real :: adcmaxh
real :: addp2(isd:ied,jsd:jed)
real :: adfrac
real :: adfx(is:ie+1,js:je)
real :: adfy(is:ie,js:je+1)
real :: adra_x(is:ie,jsd:jed)
real :: adra_y(isd:ied,js:je)
real :: adrdt
real :: adxfx(is:ie+1,jsd:jed)
real :: adyfx(isd:ied,js:je+1)

real :: adcmax_tmp
real :: adcmaxh_tmp
real :: addp2_tmp(isd:ied,jsd:jed)
real :: adfrac_tmp
real :: adfx_tmp(is:ie+1,js:je)
real :: adfy_tmp(is:ie,js:je+1)
real :: adra_x_tmp(is:ie,jsd:jed)
real :: adra_y_tmp(isd:ied,js:je)
real :: adrdt_tmp
real :: adxfx_tmp(is:ie+1,jsd:jed)
real :: adyfx_tmp(isd:ied,js:je+1)

real :: cmax
real :: cmaxh
real :: cxh(lbound(cx,1):ubound(cx,1),lbound(cx,2):ubound(cx,2))
real :: cyh(lbound(cy,1):ubound(cy,1),lbound(cy,2):ubound(cy,2))
real :: dp2(isd:ied,jsd:jed)
real :: frac
real :: fx(is:ie+1,js:je)
real :: fy(is:ie,js:je+1)
integer :: i
integer :: iq
integer :: iq_taf
integer :: it
integer :: j
real :: mfxh(lbound(mfx,1):ubound(mfx,1),lbound(mfx,2):ubound(mfx,2))
real :: mfyh(lbound(mfy,1):ubound(mfy,1),lbound(mfy,2):ubound(mfy,2))
integer :: nsplt
real :: ra_x(is:ie,jsd:jed)
real :: ra_y(isd:ied,js:je)
real :: rdt
real :: xfx(is:ie+1,jsd:jed)
real :: yfx(isd:ied,js:je+1)

adcx_tmp = adcx
adcy_tmp = adcy
addp1_tmp = addp1
admfx_tmp = admfx
admfy_tmp = admfy
adq_tmp = adq
adq3_tmp = adq3
!adcmax_tmp = adcmax
!addp2_tmp = addp2
!adfrac_tmp = adfrac
!adfx_tmp = adfx
!adfy_tmp = adfy
!adra_x_tmp = adra_x
!adra_y_tmp = adra_y
!adrdt_tmp = adrdt
!adxfx_tmp = adxfx
!adyfx_tmp = adyfx

!----------------------------------------------
! SAVE REQUIRED INPUT VARIABLES
!----------------------------------------------
mfyh(:,:) = mfy(:,:)
mfxh(:,:) = mfx(:,:)
cyh(:,:) = cy(:,:)
cxh(:,:) = cx(:,:)

!----------------------------------------------
! RESET LOCAL ADJOINT VARIABLES
!----------------------------------------------
adcmax = 0.
addp2(:,:) = 0.
adfrac = 0.
adfx(:,:) = 0.
adfy(:,:) = 0.
adra_x(:,:) = 0.
adra_y(:,:) = 0.
adrdt = 0.
adxfx(:,:) = 0.
adyfx(:,:) = 0.

!----------------------------------------------
! ROUTINE BODY
!----------------------------------------------
do j = jsd, jed
  do i = is, ie+1
    if (cx(i,j) .gt. 0.) then
      xfx(i,j) = cx(i,j)*dxa(i-1,j)*dy(i,j)*sina_u(i,j)
    else
      xfx(i,j) = cx(i,j)*dxa(i,j)*dy(i,j)*sina_u(i,j)
    endif
  end do
end do
do j = js, je+1
  do i = isd, ied
    if (cy(i,j) .gt. 0.) then
      yfx(i,j) = cy(i,j)*dya(i,j-1)*dx(i,j)*sina_v(i,j)
    else
      yfx(i,j) = cy(i,j)*dya(i,j)*dx(i,j)*sina_v(i,j)
    endif
  end do
end do
nsplt = trc_1l_nsplt_3h(k)
frac = 1./real(nsplt)
if (nsplt .ne. 1) then
  do j = jsd, jed
    do i = is, ie+1
      xfx(i,j) = xfx(i,j)*frac
    end do
  end do
  do j = js, je
    do i = is, ie+1
      mfx(i,j) = mfx(i,j)*frac
    end do
  end do
  do j = js, je+1
    do i = isd, ied
      yfx(i,j) = yfx(i,j)*frac
    end do
  end do
  do j = js, je+1
    do i = is, ie
      mfy(i,j) = mfy(i,j)*frac
    end do
  end do
endif
if (id_divg .gt. 0) then
  rdt = 1./(frac*dt)
  do j = js, je
    do i = is, ie
      adrdt = adrdt+addp1(i,j)*(xfx(i+1,j)-xfx(i,j)+yfx(i,j+1)-yfx(i,j))*rarea(i,j)
      adxfx(i+1,j) = adxfx(i+1,j)+addp1(i,j)*rarea(i,j)*rdt
      adxfx(i,j) = adxfx(i,j)-addp1(i,j)*rarea(i,j)*rdt
      adyfx(i,j+1) = adyfx(i,j+1)+addp1(i,j)*rarea(i,j)*rdt
      adyfx(i,j) = adyfx(i,j)-addp1(i,j)*rarea(i,j)*rdt
      addp1(i,j) = 0.
    end do
  end do
  adfrac = adfrac-adrdt*(1.*dt/(frac*dt*frac*dt))
  adrdt = 0.
endif
do it = 1, nsplt
  do j = js, je
    do i = is, ie
      dp2(i,j) = dp1(i,j)+(mfx(i,j)-mfx(i+1,j)+mfy(i,j)-mfy(i,j+1))*rarea(i,j)
    end do
  end do
  if (it .ne. nsplt) then
    do j = js, je
      do i = is, ie
        addp2(i,j) = addp2(i,j)+addp1(i,j)
        addp1(i,j) = 0.
      end do
    end do
  endif
  do iq = nq, 1, -1
    iq_taf = (k-1)*nq*nsplt_max+(it-1)*nq+iq
    cx = trc_1lnspzq_cx_2h(:,:,iq_taf)
    cy = trc_1lnspzq_cy_3h(:,:,iq_taf)
    xfx = trc_1lnspzq_xfx_6h(:,:,iq_taf)
    yfx = trc_1lnspzq_yfx_7h(:,:,iq_taf)
    ra_x = trc_1lnspzq_ra_x_8h(:,:,iq_taf)
    ra_y = trc_1lnspzq_ra_y_9h(:,:,iq_taf)
    mfx = trc_1lnspzq_mfx_10h(:,:,iq_taf)
    mfy = trc_1lnspzq_mfy_11h(:,:,iq_taf)
    if (it .eq. nsplt) then
      q(:,:,iq) = trc_1lnspzq_q_12h(:,:,iq_taf)
      fx = trc_1lnspzq_fx_13h(:,:,iq_taf)
      fy = trc_1lnspzq_fy_14h(:,:,iq_taf)
      do j = js, je
        do i = is, ie
          addp1(i,j) = addp1(i,j)+adq3(i,j,k,iq)*(q(i,j,iq)/dp2(i,j))
          addp2(i,j) = addp2(i,j)-adq3(i,j,k,iq)*((q(i,j,iq)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/(dp2(i,j)*&
&dp2(i,j)))
          adfx(i+1,j) = adfx(i+1,j)-adq3(i,j,k,iq)*(rarea(i,j)/dp2(i,j))
          adfx(i,j) = adfx(i,j)+adq3(i,j,k,iq)*(rarea(i,j)/dp2(i,j))
          adfy(i,j+1) = adfy(i,j+1)-adq3(i,j,k,iq)*(rarea(i,j)/dp2(i,j))
          adfy(i,j) = adfy(i,j)+adq3(i,j,k,iq)*(rarea(i,j)/dp2(i,j))
          adq(i,j,iq) = adq(i,j,iq)+adq3(i,j,k,iq)*(dp1(i,j)/dp2(i,j))
          adq3(i,j,k,iq) = 0.
        end do
      end do
    else
      q(:,:,iq) = trc_1lnspzq_q_15h(:,:,iq_taf)
      fx = trc_1lnspzq_fx_16h(:,:,iq_taf)
      fy = trc_1lnspzq_fy_17h(:,:,iq_taf)
      do j = js, je
        do i = is, ie
          addp1(i,j) = addp1(i,j)+adq(i,j,iq)*(q(i,j,iq)/dp2(i,j))
          addp2(i,j) = addp2(i,j)-adq(i,j,iq)*((q(i,j,iq)*dp1(i,j)+(fx(i,j)-fx(i+1,j)+fy(i,j)-fy(i,j+1))*rarea(i,j))/(dp2(i,j)*&
&dp2(i,j)))
          adfx(i+1,j) = adfx(i+1,j)-adq(i,j,iq)*(rarea(i,j)/dp2(i,j))
          adfx(i,j) = adfx(i,j)+adq(i,j,iq)*(rarea(i,j)/dp2(i,j))
          adfy(i,j+1) = adfy(i,j+1)-adq(i,j,iq)*(rarea(i,j)/dp2(i,j))
          adfy(i,j) = adfy(i,j)+adq(i,j,iq)*(rarea(i,j)/dp2(i,j))
          adq(i,j,iq) = adq(i,j,iq)*(dp1(i,j)/dp2(i,j))
        end do
      end do
    endif

!adq_tmp = adq
!adcx_tmp = adcx
!adcy_tmp = adcy
!adfx_tmp = adfx
!adfy_tmp = adfy
!adxfx_tmp = adxfx
!adyfx_tmp = adyfx
!adra_x_tmp = adra_x
!adra_y_tmp = adra_y
!admfx_tmp = admfx
!admfy_tmp = admfy

    call adv2_fv_tp_2d_trc( adq(isd,jsd,iq),cx,adcx,cy,adcy,npx,npy,hord,adfx,adfy,xfx,adxfx,yfx,adyfx,area,ra_x,adra_x,ra_y,&
&adra_y,uniform_ppm,mfx,admfx,mfy,admfy, .true. ,iq_taf )

!adq = adq_tmp
!adcx = adcx_tmp
!adcy = adcy_tmp
!adfx = adfx_tmp
!adfy = adfy_tmp
!adxfx = adxfx_tmp
!adyfx = adyfx_tmp
!adra_x = adra_x_tmp
!adra_y = adra_y_tmp
!admfx = admfx_tmp
!admfy = admfy_tmp


  end do
  call admpp_update_domains_dummy4( adq,is,ie,js,je,isd,ied,jsd,jed,1,nq )
  do j = js, je
    do i = is, ie
      addp1(i,j) = addp1(i,j)+addp2(i,j)
      admfx(i+1,j) = admfx(i+1,j)-addp2(i,j)*rarea(i,j)
      admfx(i,j) = admfx(i,j)+addp2(i,j)*rarea(i,j)
      admfy(i,j+1) = admfy(i,j+1)-addp2(i,j)*rarea(i,j)
      admfy(i,j) = admfy(i,j)+addp2(i,j)*rarea(i,j)
      addp2(i,j) = 0.
    end do
  end do
end do
do j = js, je
  do i = isd, ied
    adyfx(i,j+1) = adyfx(i,j+1)-adra_y(i,j)
    adyfx(i,j) = adyfx(i,j)+adra_y(i,j)
    adra_y(i,j) = 0.
  end do
end do
do j = jsd, jed
  do i = is, ie
    adxfx(i+1,j) = adxfx(i+1,j)-adra_x(i,j)
    adxfx(i,j) = adxfx(i,j)+adra_x(i,j)
    adra_x(i,j) = 0.
  end do
end do
cx(:,:) = cxh(:,:)
cy(:,:) = cyh(:,:)
mfx(:,:) = mfxh(:,:)
mfy(:,:) = mfyh(:,:)
do j = jsd, jed
  do i = is, ie+1
    if (cx(i,j) .gt. 0.) then
      xfx(i,j) = cx(i,j)*dxa(i-1,j)*dy(i,j)*sina_u(i,j)
    else
      xfx(i,j) = cx(i,j)*dxa(i,j)*dy(i,j)*sina_u(i,j)
    endif
  end do
end do
do j = js, je+1
  do i = isd, ied
    if (cy(i,j) .gt. 0.) then
      yfx(i,j) = cy(i,j)*dya(i,j-1)*dx(i,j)*sina_v(i,j)
    else
      yfx(i,j) = cy(i,j)*dya(i,j)*dx(i,j)*sina_v(i,j)
    endif
  end do
end do
if (nsplt .ne. 1) then
  do j = js, je+1
    do i = is, ie
      adfrac = adfrac+admfy(i,j)*mfy(i,j)
      admfy(i,j) = admfy(i,j)*frac
    end do
  end do
  do j = js, je+1
    do i = isd, ied
      adfrac = adfrac+adyfx(i,j)*yfx(i,j)
      adyfx(i,j) = adyfx(i,j)*frac
      adfrac = adfrac+adcy(i,j)*cy(i,j)
      adcy(i,j) = adcy(i,j)*frac
    end do
  end do
  do j = js, je
    do i = is, ie+1
      adfrac = adfrac+admfx(i,j)*mfx(i,j)
      admfx(i,j) = admfx(i,j)*frac
    end do
  end do
  do j = jsd, jed
    do i = is, ie+1
      adfrac = adfrac+adxfx(i,j)*xfx(i,j)
      adxfx(i,j) = adxfx(i,j)*frac
      adfrac = adfrac+adcx(i,j)*cx(i,j)
      adcx(i,j) = adcx(i,j)*frac
    end do
  end do
endif
adfrac = 0.
cx(:,:) = cxh(:,:)
cy(:,:) = cyh(:,:)
if (q_split .eq. 0) then
  cmax = 0.
  call admp_reduce_max( adcmax )
  do j = js, je
    do i = is, ie
      cmaxh = max(abs(cx(i,j))+1.-sina_u(i,j),abs(cy(i,j))+1.-sina_v(i,j))
      adcmaxh = adcmax*(0.5+sign(0.5,cmaxh-cmax))
      adcmax = adcmax*(0.5-sign(0.5,cmaxh-cmax))
      adcx(i,j) = adcx(i,j)+adcmaxh*(0.5+sign(0.5,abs(cx(i,j))+1.-sina_u(i,j)-(abs(cy(i,j))+1.-sina_v(i,j))))*sign(1.,cx(i,j))
      adcy(i,j) = adcy(i,j)+adcmaxh*(0.5-sign(0.5,abs(cx(i,j))+1.-sina_u(i,j)-(abs(cy(i,j))+1.-sina_v(i,j))))*sign(1.,cy(i,j))
    end do
  end do
endif
cy(:,:) = cyh(:,:)
do j = js, je+1
  do i = isd, ied
    if (cy(i,j) .gt. 0.) then
      adcy(i,j) = adcy(i,j)+adyfx(i,j)*dya(i,j-1)*dx(i,j)*sina_v(i,j)
      adyfx(i,j) = 0.
    else
      adcy(i,j) = adcy(i,j)+adyfx(i,j)*dya(i,j)*dx(i,j)*sina_v(i,j)
      adyfx(i,j) = 0.
    endif
  end do
end do
cx(:,:) = cxh(:,:)
do j = jsd, jed
  do i = is, ie+1
    if (cx(i,j) .gt. 0.) then
      adcx(i,j) = adcx(i,j)+adxfx(i,j)*dxa(i-1,j)*dy(i,j)*sina_u(i,j)
      adxfx(i,j) = 0.
    else
      adcx(i,j) = adcx(i,j)+adxfx(i,j)*dxa(i,j)*dy(i,j)*sina_u(i,j)
      adxfx(i,j) = 0.
    endif
  end do
end do

!----------------------------------------------
! FREE DYNAMIC MEMORY
!----------------------------------------------

adcx = adcx_tmp
adcy = adcy_tmp
addp1 = addp1_tmp
admfx = admfx_tmp
admfy = admfy_tmp
adq = adq_tmp
adq3 = adq3_tmp
!adcmax = adcmax_tmp
!addp2 = addp2_tmp
!adfrac = adfrac_tmp
!adfx = adfx_tmp
!adfy = adfy_tmp
!adra_x = adra_x_tmp
!adra_y = adra_y_tmp
!adrdt = adrdt_tmp
!adxfx = adxfx_tmp
!adyfx = adyfx_tmp

end subroutine adv2_tracer_2d_1l
