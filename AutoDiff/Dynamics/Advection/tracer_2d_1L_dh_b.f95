!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.9 (r5096) - 24 Feb 2014 16:53
!
!  Differentiation of tracer_2d_1l_dh in reverse (adjoint) mode:
!   gradient     of useful results: q dp0 q3
!   with respect to varying inputs: q dp0 mfx mfy q3 cx cy
!   RW status of diff variables: q:in-out dp0:in-out mfx:out mfy:out
!                q3:in-out cx:out cy:out
SUBROUTINE TRACER_2D_1L_DH_B(q, qb, dp0, dp0b, mfx, mfxb, mfy, mfyb, cx&
& , cxb, cy, cyb, npx, npy, npz, nq, hord, q_split, k, q3, q3b, dt, &
& id_divg, is, ie, js, je, isd, ied, jsd, jed, ng, dxa, dya, sina_u, &
& sina_v, dx, dy, area, rarea, domain)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, ng
  INTEGER, INTENT(IN) :: npx, npy, npz
  INTEGER, INTENT(IN) :: k
! number of tracers to be advected
  INTEGER, INTENT(IN) :: nq
  INTEGER, INTENT(IN) :: hord
  INTEGER, INTENT(IN) :: q_split
  INTEGER, INTENT(IN) :: id_divg
  REAL, INTENT(IN) :: dt
! 2D Tracers
  REAL, INTENT(INOUT) :: q(isd:ied, jsd:jed, nq)
  REAL, INTENT(INOUT) :: qb(isd:ied, jsd:jed, nq)
! Tracers
  REAL, INTENT(INOUT) :: q3(isd:ied, jsd:jed, npz, nq)
  REAL, INTENT(INOUT) :: q3b(isd:ied, jsd:jed, npz, nq)
! DELP before dyn_core
  REAL, INTENT(INOUT) :: dp0(is:ie, js:je)
  REAL, INTENT(INOUT) :: dp0b(is:ie, js:je)
! Mass Flux X-Dir
  REAL, INTENT(IN) :: mfx(is:ie+1, js:je)
  REAL :: mfxb(is:ie+1, js:je)
! Mass Flux Y-Dir
  REAL, INTENT(IN) :: mfy(is:ie, js:je+1)
  REAL :: mfyb(is:ie, js:je+1)
! Courant Number X-Dir
  REAL, INTENT(IN) :: cx(is:ie+1, jsd:jed)
  REAL :: cxb(is:ie+1, jsd:jed)
! Courant Number Y-Dir
  REAL, INTENT(IN) :: cy(isd:ied, js:je+1)
  REAL :: cyb(isd:ied, js:je+1)
!Unrequired inputs
  REAL, INTENT(IN) :: dx(is:ie+1, jsd:jed), dy(isd:ied, js:je+1)
  REAL, INTENT(IN) :: dxa(is:ie+1, jsd:jed), dya(isd:ied, js:je+1)
  REAL, INTENT(IN) :: sina_u(is:ie+1, jsd:jed), sina_v(isd:ied, js:je+1)
  REAL, INTENT(IN) :: area(is:ie, jsd:jed), rarea(is:ie, js:je)
  REAL, INTENT(IN) :: domain
! Local Arrays
  REAL :: mfx2(is:ie+1, js:je)
  REAL :: mfx2b(is:ie+1, js:je)
  REAL :: mfy2(is:ie, js:je+1)
  REAL :: mfy2b(is:ie, js:je+1)
  REAL :: cx2(is:ie+1, jsd:jed)
  REAL :: cy2(isd:ied, js:je+1)
  REAL :: dp1(is:ie, js:je)
  REAL :: dp1b(is:ie, js:je)
  REAL :: dp2(is:ie, js:je)
  REAL :: dp2b(is:ie, js:je)
  REAL :: fx(is:ie+1, js:je)
  REAL :: fxb(is:ie+1, js:je)
  REAL :: fy(is:ie, js:je+1)
  REAL :: fyb(is:ie, js:je+1)
  REAL :: ra_x(is:ie, jsd:jed)
  REAL :: ra_xb(is:ie, jsd:jed)
  REAL :: ra_y(isd:ied, js:je)
  REAL :: ra_yb(isd:ied, js:je)
  REAL :: xfx(is:ie+1, jsd:jed)
  REAL :: xfxb(is:ie+1, jsd:jed)
  REAL :: yfx(isd:ied, js:je+1)
  REAL :: yfxb(isd:ied, js:je+1)
  REAL :: cmax
  REAL :: frac, rdt
  INTEGER :: nsplt
  INTEGER :: i, j, it, iq
  INTRINSIC ABS
  INTRINSIC MAX
  INTRINSIC INT
  INTRINSIC REAL
  INTEGER :: branch
  REAL :: tempb4
  REAL :: tempb3
  REAL :: tempb2
  REAL :: tempb1
  REAL :: tempb0
  REAL :: x1
  REAL :: tempb
  REAL :: abs1
  REAL :: abs0
  REAL :: y1
  DO j=jsd,jed
    DO i=is,ie+1
      IF (cx(i, j) .GT. 0.) THEN
        xfx(i, j) = cx(i, j)*dxa(i-1, j)*dy(i, j)*sina_u(i, j)
        CALL PUSHCONTROL1B(1)
      ELSE
        xfx(i, j) = cx(i, j)*dxa(i, j)*dy(i, j)*sina_u(i, j)
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
  END DO
  DO j=js,je+1
    DO i=isd,ied
      IF (cy(i, j) .GT. 0.) THEN
        yfx(i, j) = cy(i, j)*dya(i, j-1)*dx(i, j)*sina_v(i, j)
        CALL PUSHCONTROL1B(1)
      ELSE
        yfx(i, j) = cy(i, j)*dya(i, j)*dx(i, j)*sina_v(i, j)
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
  END DO
  IF (q_split .EQ. 0) THEN
! Determine nsplt for tracer advection
    cmax = 0.
    DO j=js,je
      DO i=is,ie
        IF (cx(i, j) .GE. 0.) THEN
          abs0 = cx(i, j)
        ELSE
          abs0 = -cx(i, j)
        END IF
        x1 = abs0 + (1.-sina_u(i, j))
        IF (cy(i, j) .GE. 0.) THEN
          abs1 = cy(i, j)
        ELSE
          abs1 = -cy(i, j)
        END IF
        y1 = abs1 + (1.-sina_v(i, j))
        IF (x1 .LT. y1) THEN
          IF (y1 .LT. cmax) THEN
            cmax = cmax
          ELSE
            cmax = y1
          END IF
        ELSE IF (x1 .LT. cmax) THEN
          cmax = cmax
        ELSE
          cmax = x1
        END IF
      END DO
    END DO
    CALL MP_REDUCE_MAX(cmax)
    nsplt = INT(1.01 + cmax)
  ELSE
    nsplt = q_split
  END IF
  frac = 1./REAL(nsplt)
  DO j=jsd,jed
    DO i=is,ie+1
      cx2(i, j) = cx(i, j)*frac
      xfx(i, j) = xfx(i, j)*frac
    END DO
  END DO
  DO j=js,je
    DO i=is,ie+1
      mfx2(i, j) = mfx(i, j)*frac
    END DO
  END DO
  DO j=js,je+1
    DO i=isd,ied
      cy2(i, j) = cy(i, j)*frac
      yfx(i, j) = yfx(i, j)*frac
    END DO
  END DO
  DO j=js,je+1
    DO i=is,ie
      mfy2(i, j) = mfy(i, j)*frac
    END DO
  END DO
  DO j=jsd,jed
    DO i=is,ie
      ra_x(i, j) = area(i, j) + xfx(i, j) - xfx(i+1, j)
    END DO
  END DO
  DO j=js,je
    DO i=isd,ied
      ra_y(i, j) = area(i, j) + yfx(i, j) - yfx(i, j+1)
    END DO
  END DO
  DO j=js,je
    DO i=is,ie
      dp1(i, j) = dp0(i, j)
    END DO
  END DO
  DO it=1,nsplt
    DO j=js,je
      DO i=is,ie
        CALL PUSHREAL4(dp2(i, j))
        dp2(i, j) = dp1(i, j) + (mfx2(i, j)-mfx2(i+1, j)+mfy2(i, j)-mfy2&
&         (i, j+1))*rarea(i, j)
      END DO
    END DO
!call timing_on('COMM_TOTAL')
!call timing_on('COMM_TRAC')
    CALL PUSHREAL4ARRAY(q, (ied-isd+1)*(jed-jsd+1)*nq)
    CALL MPP_UPDATE_DOMAINS(q, domain, complete=.true.)
!call timing_off('COMM_TRAC')
!call timing_off('COMM_TOTAL')
    DO iq=1,nq
      CALL PUSHREAL4ARRAY(fy, (ie-is+1)*(je-js+2))
      CALL PUSHREAL4ARRAY(fx, (ie-is+2)*(je-js+1))
      CALL PUSHREAL4ARRAY(q(:, :, iq), (ied-isd+1)*(jed-jsd+1))
      CALL FV_TP_2D_TRC_DH(q(isd:, jsd:, iq), cx2, cy2, npx, npy, hord, &
&                    fx, fy, xfx, yfx, area, ra_x, ra_y, mfx2, mfy2, is&
&                    , ie, js, je, isd, ied, jsd, jed, ng)
      IF (it .EQ. nsplt) THEN
        CALL PUSHCONTROL1B(1)
      ELSE
        DO j=js,je
          DO i=is,ie
            CALL PUSHREAL4(q(i, j, iq))
            q(i, j, iq) = (q(i, j, iq)*dp1(i, j)+(fx(i, j)-fx(i+1, j)+fy&
&             (i, j)-fy(i, j+1))*rarea(i, j))/dp2(i, j)
          END DO
        END DO
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    IF (it .NE. nsplt) THEN
      DO j=js,je
        DO i=is,ie
          CALL PUSHREAL4(dp1(i, j))
          dp1(i, j) = dp2(i, j)
        END DO
      END DO
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
  END DO
! nsplt
  IF (id_divg .GT. 0) THEN
    rdt = 1./(frac*dt)
    xfxb = 0.0
    yfxb = 0.0
    DO j=je,js,-1
      DO i=ie,is,-1
        tempb4 = rarea(i, j)*rdt*dp0b(i, j)
        xfxb(i+1, j) = xfxb(i+1, j) + tempb4
        xfxb(i, j) = xfxb(i, j) - tempb4
        yfxb(i, j+1) = yfxb(i, j+1) + tempb4
        yfxb(i, j) = yfxb(i, j) - tempb4
        dp0b(i, j) = 0.0
      END DO
    END DO
  ELSE
    xfxb = 0.0
    yfxb = 0.0
  END IF
  mfx2b = 0.0
  dp1b = 0.0
  dp2b = 0.0
  mfy2b = 0.0
  ra_xb = 0.0
  ra_yb = 0.0
  fxb = 0.0
  fyb = 0.0
  DO it=nsplt,1,-1
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      DO j=je,js,-1
        DO i=ie,is,-1
          CALL POPREAL4(dp1(i, j))
          dp2b(i, j) = dp2b(i, j) + dp1b(i, j)
          dp1b(i, j) = 0.0
        END DO
      END DO
    END IF
    DO iq=nq,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO j=je,js,-1
          DO i=ie,is,-1
            CALL POPREAL4(q(i, j, iq))
            tempb2 = qb(i, j, iq)/dp2(i, j)
            tempb3 = rarea(i, j)*tempb2
            dp1b(i, j) = dp1b(i, j) + q(i, j, iq)*tempb2
            fxb(i, j) = fxb(i, j) + tempb3
            fxb(i+1, j) = fxb(i+1, j) - tempb3
            fyb(i, j) = fyb(i, j) + tempb3
            fyb(i, j+1) = fyb(i, j+1) - tempb3
            dp2b(i, j) = dp2b(i, j) - (q(i, j, iq)*dp1(i, j)+rarea(i, j)&
&             *(fx(i, j)-fx(i+1, j)+fy(i, j)-fy(i, j+1)))*tempb2/dp2(i, &
&             j)
            qb(i, j, iq) = dp1(i, j)*tempb2
          END DO
        END DO
      ELSE
        DO j=je,js,-1
          DO i=ie,is,-1
            tempb0 = q3b(i, j, k, iq)/dp2(i, j)
            tempb1 = rarea(i, j)*tempb0
            qb(i, j, iq) = qb(i, j, iq) + dp1(i, j)*tempb0
            dp1b(i, j) = dp1b(i, j) + q(i, j, iq)*tempb0
            fxb(i, j) = fxb(i, j) + tempb1
            fxb(i+1, j) = fxb(i+1, j) - tempb1
            fyb(i, j) = fyb(i, j) + tempb1
            fyb(i, j+1) = fyb(i, j+1) - tempb1
            dp2b(i, j) = dp2b(i, j) - (q(i, j, iq)*dp1(i, j)+rarea(i, j)&
&             *(fx(i, j)-fx(i+1, j)+fy(i, j)-fy(i, j+1)))*tempb0/dp2(i, &
&             j)
            q3b(i, j, k, iq) = 0.0
          END DO
        END DO
      END IF
      CALL POPREAL4ARRAY(q(:, :, iq), (ied-isd+1)*(jed-jsd+1))
      CALL POPREAL4ARRAY(fx, (ie-is+2)*(je-js+1))
      CALL POPREAL4ARRAY(fy, (ie-is+1)*(je-js+2))
      CALL FV_TP_2D_TRC_DH_B(q(isd:, jsd:, iq), qb(isd:, jsd:, iq), cx2&
&                      , cy2, npx, npy, hord, fx, fxb, fy, fyb, xfx, &
&                      xfxb, yfx, yfxb, area, ra_x, ra_xb, ra_y, ra_yb, &
&                      mfx2, mfx2b, mfy2, mfy2b, is, ie, js, je, isd, &
&                      ied, jsd, jed, ng)
    END DO
    CALL POPREAL4ARRAY(q, (ied-isd+1)*(jed-jsd+1)*nq)
    CALL MPP_UPDATE_DOMAINS_B(q, qb, domain, complete=.true.)
    DO j=je,js,-1
      DO i=ie,is,-1
        CALL POPREAL4(dp2(i, j))
        tempb = rarea(i, j)*dp2b(i, j)
        dp1b(i, j) = dp1b(i, j) + dp2b(i, j)
        mfx2b(i, j) = mfx2b(i, j) + tempb
        mfx2b(i+1, j) = mfx2b(i+1, j) - tempb
        mfy2b(i, j) = mfy2b(i, j) + tempb
        mfy2b(i, j+1) = mfy2b(i, j+1) - tempb
        dp2b(i, j) = 0.0
      END DO
    END DO
  END DO
  DO j=je,js,-1
    DO i=ie,is,-1
      dp0b(i, j) = dp0b(i, j) + dp1b(i, j)
      dp1b(i, j) = 0.0
    END DO
  END DO
  DO j=je,js,-1
    DO i=ied,isd,-1
      yfxb(i, j) = yfxb(i, j) + ra_yb(i, j)
      yfxb(i, j+1) = yfxb(i, j+1) - ra_yb(i, j)
      ra_yb(i, j) = 0.0
    END DO
  END DO
  DO j=jed,jsd,-1
    DO i=ie,is,-1
      xfxb(i, j) = xfxb(i, j) + ra_xb(i, j)
      xfxb(i+1, j) = xfxb(i+1, j) - ra_xb(i, j)
      ra_xb(i, j) = 0.0
    END DO
  END DO
  mfyb = 0.0
  DO j=je+1,js,-1
    DO i=ie,is,-1
      mfyb(i, j) = mfyb(i, j) + frac*mfy2b(i, j)
      mfy2b(i, j) = 0.0
    END DO
  END DO
  DO j=je+1,js,-1
    DO i=ied,isd,-1
      yfxb(i, j) = frac*yfxb(i, j)
    END DO
  END DO
  mfxb = 0.0
  DO j=je,js,-1
    DO i=ie+1,is,-1
      mfxb(i, j) = mfxb(i, j) + frac*mfx2b(i, j)
      mfx2b(i, j) = 0.0
    END DO
  END DO
  DO j=jed,jsd,-1
    DO i=ie+1,is,-1
      xfxb(i, j) = frac*xfxb(i, j)
    END DO
  END DO
  cyb = 0.0
  DO j=je+1,js,-1
    DO i=ied,isd,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        cyb(i, j) = cyb(i, j) + dya(i, j)*dx(i, j)*sina_v(i, j)*yfxb(i, &
&         j)
        yfxb(i, j) = 0.0
      ELSE
        cyb(i, j) = cyb(i, j) + dx(i, j)*sina_v(i, j)*dya(i, j-1)*yfxb(i&
&         , j)
        yfxb(i, j) = 0.0
      END IF
    END DO
  END DO
  cxb = 0.0
  DO j=jed,jsd,-1
    DO i=ie+1,is,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        cxb(i, j) = cxb(i, j) + dxa(i, j)*dy(i, j)*sina_u(i, j)*xfxb(i, &
&         j)
        xfxb(i, j) = 0.0
      ELSE
        cxb(i, j) = cxb(i, j) + dy(i, j)*sina_u(i, j)*dxa(i-1, j)*xfxb(i&
&         , j)
        xfxb(i, j) = 0.0
      END IF
    END DO
  END DO
END SUBROUTINE TRACER_2D_1L_DH_B

!  Differentiation of mpp_update_domains in reverse (adjoint) mode:
!   gradient     of useful results: q
!   with respect to varying inputs: q
SUBROUTINE MPP_UPDATE_DOMAINS_B(q, qb, domain, complete)
  IMPLICIT NONE
  REAL :: q(:, :), domain
  REAL :: qb(:, :)
  LOGICAL :: complete
  IF (complete .EQ. .true. .AND. domain .GT. 1) qb = qb/2 + 2*q*qb
END SUBROUTINE MPP_UPDATE_DOMAINS_B

!  Differentiation of fv_tp_2d_trc_dh in reverse (adjoint) mode:
!   gradient     of useful results: xfx q mfx mfy ra_x ra_y yfx
!                fx fy
!   with respect to varying inputs: xfx q mfx mfy ra_x ra_y yfx
!                fx fy
SUBROUTINE FV_TP_2D_TRC_DH_B(q, qb, crx, cry, npx, npy, hord, fx, fxb, &
& fy, fyb, xfx, xfxb, yfx, yfxb, area, ra_x, ra_xb, ra_y, ra_yb, mfx, &
& mfxb, mfy, mfyb, is, ie, js, je, isd, ied, jsd, jed, ng)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, ng
  INTEGER, INTENT(IN) :: npx, npy
  INTEGER, INTENT(IN) :: hord
!
  REAL, INTENT(IN) :: crx(is:ie+1, jsd:jed)
!
  REAL, INTENT(IN) :: xfx(is:ie+1, jsd:jed)
  REAL :: xfxb(is:ie+1, jsd:jed)
!
  REAL, INTENT(IN) :: cry(isd:ied, js:je+1)
!
  REAL, INTENT(IN) :: yfx(isd:ied, js:je+1)
  REAL :: yfxb(isd:ied, js:je+1)
  REAL, INTENT(IN) :: area(isd:ied, jsd:jed)
  REAL, INTENT(IN) :: ra_x(is:ie, jsd:jed)
  REAL :: ra_xb(is:ie, jsd:jed)
  REAL, INTENT(IN) :: ra_y(isd:ied, js:je)
  REAL :: ra_yb(isd:ied, js:je)
! transported scalar
  REAL, INTENT(INOUT) :: q(isd:ied, jsd:jed)
  REAL, INTENT(INOUT) :: qb(isd:ied, jsd:jed)
! Flux in x ( E )
  REAL :: fx(is:ie+1, js:je)
  REAL :: fxb(is:ie+1, js:je)
! Flux in y ( N )
  REAL :: fy(is:ie, js:je+1)
  REAL :: fyb(is:ie, js:je+1)
! optional Arguments:
! Mass Flux X-Dir
  REAL, OPTIONAL, INTENT(IN) :: mfx(is:ie+1, js:je)
  REAL, OPTIONAL :: mfxb(is:ie+1, js:je)
! Mass Flux Y-Dir
  REAL, OPTIONAL, INTENT(IN) :: mfy(is:ie, js:je+1)
  REAL, OPTIONAL :: mfyb(is:ie, js:je+1)
! Local:
  INTEGER :: ord, ord_in
  REAL :: q_i(isd:ied, js:je)
  REAL :: q_ib(isd:ied, js:je)
  REAL :: q_j(is:ie, jsd:jed)
  REAL :: q_jb(is:ie, jsd:jed)
  REAL :: fx2(is:ie+1, jsd:jed)
  REAL :: fx2b(is:ie+1, jsd:jed)
  REAL :: fy2(isd:ied, js:je+1)
  REAL :: fy2b(isd:ied, js:je+1)
  REAL :: fyy(isd:ied, js:je+1)
  REAL :: fyyb(isd:ied, js:je+1)
  REAL :: fx1(is:ie+1)
  REAL :: fx1b(is:ie+1)
  REAL :: ppm_limiter
  INTEGER :: i, j
  INTRINSIC ABS
  INTRINSIC PRESENT
  REAL :: tempb4
  REAL :: tempb3
  REAL :: tempb2
  REAL :: tempb1
  REAL :: tempb0
  REAL :: tempb
!Part 1
  CALL PUSHREAL4ARRAY(q, (ied-isd+1)*(jed-jsd+1))
  CALL COPY_CORNERS(q, 2)
  CALL YTP_DH(fy2, q, cry, ord_in, isd, ied, js, je, npx, npy, &
&       ppm_limiter, is, ie, js, je, isd, ied, jsd, jed, ng)
  DO j=js,je+1
    DO i=isd,ied
      fyy(i, j) = yfx(i, j)*fy2(i, j)
    END DO
  END DO
  DO j=js,je
    DO i=isd,ied
      q_i(i, j) = (q(i, j)*area(i, j)+fyy(i, j)-fyy(i, j+1))/ra_y(i, j)
    END DO
  END DO
  CALL PUSHREAL4ARRAY(fx, (ie-is+2)*(je-js+1))
  CALL XTP_DH(fx, q_i, crx(is, js), ord, is, ie, js, je, npx, npy, &
&       ppm_limiter, is, ie, js, je, isd, ied, jsd, jed, ng)
!Part 2
  CALL PUSHREAL4ARRAY(q, (ied-isd+1)*(jed-jsd+1))
  CALL COPY_CORNERS(q, 1)
  CALL XTP_DH(fx2, q, crx, ord_in, is, ie, jsd, jed, npx, npy, &
&       ppm_limiter, is, ie, js, je, isd, ied, jsd, jed, ng)
  DO j=jsd,jed
    DO i=is,ie+1
      CALL PUSHREAL4(fx1(i))
      fx1(i) = xfx(i, j)*fx2(i, j)
    END DO
    DO i=is,ie
      q_j(i, j) = (q(i, j)*area(i, j)+fx1(i)-fx1(i+1))/ra_x(i, j)
    END DO
  END DO
  CALL PUSHREAL4ARRAY(fy, (ie-is+1)*(je-js+2))
  CALL YTP_DH(fy, q_j, cry, ord, is, ie, js, je, npx, npy, ppm_limiter, &
&       is, ie, js, je, isd, ied, jsd, jed, ng)
! Flux averaging:
!----------------
  IF (PRESENT(mfx) .AND. PRESENT(mfy)) THEN
    fy2b = 0.0
    DO j=je+1,js,-1
      DO i=ie,is,-1
        tempb2 = 0.5*mfy(i, j)*fyb(i, j)
        fy2b(i, j) = fy2b(i, j) + tempb2
        mfyb(i, j) = mfyb(i, j) + 0.5*(fy(i, j)+fy2(i, j))*fyb(i, j)
        fyb(i, j) = tempb2
      END DO
    END DO
    fx2b = 0.0
    DO j=je,js,-1
      DO i=ie+1,is,-1
        tempb1 = 0.5*mfx(i, j)*fxb(i, j)
        fx2b(i, j) = fx2b(i, j) + tempb1
        mfxb(i, j) = mfxb(i, j) + 0.5*(fx(i, j)+fx2(i, j))*fxb(i, j)
        fxb(i, j) = tempb1
      END DO
    END DO
  ELSE
    fy2b = 0.0
    DO j=je+1,js,-1
      DO i=ie,is,-1
        tempb4 = 0.5*yfx(i, j)*fyb(i, j)
        fy2b(i, j) = fy2b(i, j) + tempb4
        yfxb(i, j) = yfxb(i, j) + 0.5*(fy(i, j)+fy2(i, j))*fyb(i, j)
        fyb(i, j) = tempb4
      END DO
    END DO
    fx2b = 0.0
    DO j=je,js,-1
      DO i=ie+1,is,-1
        tempb3 = 0.5*xfx(i, j)*fxb(i, j)
        fx2b(i, j) = fx2b(i, j) + tempb3
        xfxb(i, j) = xfxb(i, j) + 0.5*(fx(i, j)+fx2(i, j))*fxb(i, j)
        fxb(i, j) = tempb3
      END DO
    END DO
  END IF
  CALL POPREAL4ARRAY(fy, (ie-is+1)*(je-js+2))
  q_jb = 0.0
  CALL YTP_DH_B(fy, fyb, q_j, q_jb, cry, ord, is, ie, js, je, npx, npy, &
&         ppm_limiter, is, ie, js, je, isd, ied, jsd, jed, ng)
  fx1b = 0.0
  DO j=jed,jsd,-1
    DO i=ie,is,-1
      tempb0 = q_jb(i, j)/ra_x(i, j)
      qb(i, j) = qb(i, j) + area(i, j)*tempb0
      fx1b(i) = fx1b(i) + tempb0
      fx1b(i+1) = fx1b(i+1) - tempb0
      ra_xb(i, j) = ra_xb(i, j) - (area(i, j)*q(i, j)+fx1(i)-fx1(i+1))*&
&       tempb0/ra_x(i, j)
      q_jb(i, j) = 0.0
    END DO
    DO i=ie+1,is,-1
      CALL POPREAL4(fx1(i))
      xfxb(i, j) = xfxb(i, j) + fx2(i, j)*fx1b(i)
      fx2b(i, j) = fx2b(i, j) + xfx(i, j)*fx1b(i)
      fx1b(i) = 0.0
    END DO
  END DO
  CALL XTP_DH_B(fx2, fx2b, q, qb, crx, ord_in, is, ie, jsd, jed, npx, &
&         npy, ppm_limiter, is, ie, js, je, isd, ied, jsd, jed, ng)
  CALL POPREAL4ARRAY(q, (ied-isd+1)*(jed-jsd+1))
  CALL COPY_CORNERS_B(q, qb, 1)
  CALL POPREAL4ARRAY(fx, (ie-is+2)*(je-js+1))
  q_ib = 0.0
  CALL XTP_DH_B(fx, fxb, q_i, q_ib, crx(is, js), ord, is, ie, js, je, &
&         npx, npy, ppm_limiter, is, ie, js, je, isd, ied, jsd, jed, ng)
  fyyb = 0.0
  DO j=je,js,-1
    DO i=ied,isd,-1
      tempb = q_ib(i, j)/ra_y(i, j)
      qb(i, j) = qb(i, j) + area(i, j)*tempb
      fyyb(i, j) = fyyb(i, j) + tempb
      fyyb(i, j+1) = fyyb(i, j+1) - tempb
      ra_yb(i, j) = ra_yb(i, j) - (area(i, j)*q(i, j)+fyy(i, j)-fyy(i, j&
&       +1))*tempb/ra_y(i, j)
      q_ib(i, j) = 0.0
    END DO
  END DO
  DO j=je+1,js,-1
    DO i=ied,isd,-1
      yfxb(i, j) = yfxb(i, j) + fy2(i, j)*fyyb(i, j)
      fy2b(i, j) = fy2b(i, j) + yfx(i, j)*fyyb(i, j)
      fyyb(i, j) = 0.0
    END DO
  END DO
  CALL YTP_DH_B(fy2, fy2b, q, qb, cry, ord_in, isd, ied, js, je, npx, &
&         npy, ppm_limiter, is, ie, js, je, isd, ied, jsd, jed, ng)
  CALL POPREAL4ARRAY(q, (ied-isd+1)*(jed-jsd+1))
  CALL COPY_CORNERS_B(q, qb, 2)
END SUBROUTINE FV_TP_2D_TRC_DH_B

!  Differentiation of copy_corners in reverse (adjoint) mode:
!   gradient     of useful results: q
!   with respect to varying inputs: q
SUBROUTINE COPY_CORNERS_B(q, qb, indy)
  IMPLICIT NONE
  INTEGER :: indy
!Prognostic
  REAL, INTENT(INOUT) :: q(:, :)
  REAL, INTENT(INOUT) :: qb(:, :)
!Locals
  INTEGER :: i, j
  INTRINSIC SIZE
  REAL :: tmp
  REAL :: tmp0
  INTEGER :: ad_to
  INTEGER :: ad_to0
  INTEGER :: ad_to1
  INTEGER :: ad_to2
  REAL :: tmpb
  REAL :: tmpb0
  IF (indy .EQ. 2) THEN
    DO j=1,SIZE(q, 1)
      DO i=1,SIZE(q, 2)
        tmp = q(j, 1-i)
        CALL PUSHREAL4(q(i, j))
        q(i, j) = tmp
      END DO
      CALL PUSHINTEGER4(i - 1)
    END DO
    ad_to0 = j - 1
    DO j=ad_to0,1,-1
      CALL POPINTEGER4(ad_to)
      DO i=ad_to,1,-1
        CALL POPREAL4(q(i, j))
        tmpb = qb(i, j)
        qb(i, j) = 0.0
        qb(j, 1-i) = qb(j, 1-i) + tmpb
      END DO
    END DO
  ELSE
    DO j=1,SIZE(q, 1)
      DO i=1,SIZE(q, 2)
        tmp0 = q(j, 1-2)
        CALL PUSHREAL4(q(i, j))
        q(i, j) = tmp0
      END DO
      CALL PUSHINTEGER4(i - 1)
    END DO
    ad_to2 = j - 1
    DO j=ad_to2,1,-1
      CALL POPINTEGER4(ad_to1)
      DO i=ad_to1,1,-1
        CALL POPREAL4(q(i, j))
        tmpb0 = qb(i, j)
        qb(i, j) = 0.0
        qb(j, 1-2) = qb(j, 1-2) + tmpb0
      END DO
    END DO
  END IF
END SUBROUTINE COPY_CORNERS_B

!  Differentiation of xtp_dh in reverse (adjoint) mode:
!   gradient     of useful results: q fx
!   with respect to varying inputs: q fx
SUBROUTINE XTP_DH_B(fx, fxb, q, qb, c, iord, ifirst, ilast, jfirst, &
& jlast, npx, npy, ppm_limiter, is, ie, js, je, isd, ied, jsd, jed, ng)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, ng
!  X-Dir strip
  INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
  INTEGER, INTENT(IN) :: jfirst, jlast
  INTEGER, INTENT(IN) :: npx, npy
  INTEGER, INTENT(IN) :: iord
! Courant numbers
  REAL, INTENT(IN) :: c(is:ie+1, jfirst:jlast)
  REAL, INTENT(IN) :: q(isd:ied, jfirst:jlast)
  REAL :: qb(isd:ied, jfirst:jlast)
  REAL, INTENT(IN) :: ppm_limiter
  REAL :: fx(ifirst:ilast+1, jfirst:jlast)
  REAL :: fxb(ifirst:ilast+1, jfirst:jlast)
! Local:
  REAL :: dm(is-2:ie+2)
  REAL :: x0, x1
  INTEGER :: i, j
  INTEGER :: branch
  DO j=jfirst,jlast
    DO i=ifirst,ilast+1
      IF (c(i, j) .GT. 0.) THEN
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
  END DO
  DO j=jlast,jfirst,-1
    DO i=ilast+1,ifirst,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        qb(i, j) = qb(i, j) + fxb(i, j)
        fxb(i, j) = 0.0
      ELSE
        qb(i-1, j) = qb(i-1, j) + fxb(i, j)
        fxb(i, j) = 0.0
      END IF
    END DO
  END DO
END SUBROUTINE XTP_DH_B

!  Differentiation of ytp_dh in reverse (adjoint) mode:
!   gradient     of useful results: q fy
!   with respect to varying inputs: q fy
SUBROUTINE YTP_DH_B(fy, fyb, q, qb, c, jord, ifirst, ilast, jfirst, &
& jlast, npx, npy, ppm_limiter, is, ie, js, je, isd, ied, jsd, jed, ng)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, ng
  INTEGER, INTENT(IN) :: npx, npy
!  X-Dir strip
  INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
  INTEGER, INTENT(IN) :: jfirst, jlast
  INTEGER, INTENT(IN) :: jord
  REAL, INTENT(IN) :: q(ifirst:ilast, jfirst-ng:jlast+ng)
  REAL :: qb(ifirst:ilast, jfirst-ng:jlast+ng)
! Courant number
  REAL, INTENT(IN) :: c(isd:ied, js:je+1)
!  Flux
  REAL :: fy(ifirst:ilast, jfirst:jlast+1)
  REAL :: fyb(ifirst:ilast, jfirst:jlast+1)
  REAL, INTENT(IN) :: ppm_limiter
! !LOCAL VARIABLES:
  REAL :: dm(ifirst:ilast, jfirst-2:jlast+2)
  REAL :: x0, x1
  INTEGER :: i, j
  INTEGER :: branch
  DO j=jfirst,jlast+1
    DO i=ifirst,ilast
      IF (c(i, j) .GT. 0.) THEN
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
  END DO
  DO j=jlast+1,jfirst,-1
    DO i=ilast,ifirst,-1
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        qb(i, j) = qb(i, j) + fyb(i, j)
        fyb(i, j) = 0.0
      ELSE
        qb(i, j-1) = qb(i, j-1) + fyb(i, j)
        fyb(i, j) = 0.0
      END IF
    END DO
  END DO
END SUBROUTINE YTP_DH_B

