!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.9 (r5096) - 24 Feb 2014 16:53
!
!  Differentiation of tracer_2d_1l_dh in forward (tangent) mode:
!   variations   of useful results: q dp0 q3
!   with respect to varying inputs: q dp0 mfx mfy q3 cx cy
!   RW status of diff variables: q:in-out dp0:in-out mfx:in mfy:in
!                q3:in-out cx:in cy:in
SUBROUTINE TRACER_2D_1L_DH_D(q, qd, dp0, dp0d, mfx, mfxd, mfy, mfyd, cx&
& , cxd, cy, cyd, npx, npy, npz, nq, hord, q_split, k, q3, q3d, dt, &
& id_divg, is, ie, js, je, isd, ied, jsd, jed, ng, dxa, dya, sina_u, &
& sina_v, dx, dy, area, rarea, domain)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, ng
  INTEGER, INTENT(IN) :: npx, npy, npz
  INTEGER, INTENT(IN) :: k
! number of tracers to be advected
  INTEGER, INTENT(IN) :: nq
  INTEGER, INTENT(IN) :: hord
  INTEGER, INTENT(IN) :: q_split
  INTEGER, INTENT(IN) :: id_divg
  REAL, INTENT(IN) :: dt
! 2D Tracers
  REAL, INTENT(INOUT) :: q(isd:ied, jsd:jed, nq)
  REAL, INTENT(INOUT) :: qd(isd:ied, jsd:jed, nq)
! Tracers
  REAL, INTENT(INOUT) :: q3(isd:ied, jsd:jed, npz, nq)
  REAL, INTENT(INOUT) :: q3d(isd:ied, jsd:jed, npz, nq)
! DELP before dyn_core
  REAL, INTENT(INOUT) :: dp0(is:ie, js:je)
  REAL, INTENT(INOUT) :: dp0d(is:ie, js:je)
! Mass Flux X-Dir
  REAL, INTENT(IN) :: mfx(is:ie+1, js:je)
  REAL, INTENT(IN) :: mfxd(is:ie+1, js:je)
! Mass Flux Y-Dir
  REAL, INTENT(IN) :: mfy(is:ie, js:je+1)
  REAL, INTENT(IN) :: mfyd(is:ie, js:je+1)
! Courant Number X-Dir
  REAL, INTENT(IN) :: cx(is:ie+1, jsd:jed)
  REAL, INTENT(IN) :: cxd(is:ie+1, jsd:jed)
! Courant Number Y-Dir
  REAL, INTENT(IN) :: cy(isd:ied, js:je+1)
  REAL, INTENT(IN) :: cyd(isd:ied, js:je+1)
!Unrequired inputs
  REAL, INTENT(IN) :: dx(is:ie+1, jsd:jed), dy(isd:ied, js:je+1)
  REAL, INTENT(IN) :: dxa(is:ie+1, jsd:jed), dya(isd:ied, js:je+1)
  REAL, INTENT(IN) :: sina_u(is:ie+1, jsd:jed), sina_v(isd:ied, js:je+1)
  REAL, INTENT(IN) :: area(is:ie, jsd:jed), rarea(is:ie, js:je)
  REAL, INTENT(IN) :: domain
! Local Arrays
  REAL :: mfx2(is:ie+1, js:je)
  REAL :: mfx2d(is:ie+1, js:je)
  REAL :: mfy2(is:ie, js:je+1)
  REAL :: mfy2d(is:ie, js:je+1)
  REAL :: cx2(is:ie+1, jsd:jed)
  REAL :: cy2(isd:ied, js:je+1)
  REAL :: dp1(is:ie, js:je)
  REAL :: dp1d(is:ie, js:je)
  REAL :: dp2(is:ie, js:je)
  REAL :: dp2d(is:ie, js:je)
  REAL :: fx(is:ie+1, js:je)
  REAL :: fxd(is:ie+1, js:je)
  REAL :: fy(is:ie, js:je+1)
  REAL :: fyd(is:ie, js:je+1)
  REAL :: ra_x(is:ie, jsd:jed)
  REAL :: ra_xd(is:ie, jsd:jed)
  REAL :: ra_y(isd:ied, js:je)
  REAL :: ra_yd(isd:ied, js:je)
  REAL :: xfx(is:ie+1, jsd:jed)
  REAL :: xfxd(is:ie+1, jsd:jed)
  REAL :: yfx(isd:ied, js:je+1)
  REAL :: yfxd(isd:ied, js:je+1)
  REAL :: cmax
  REAL :: frac, rdt
  INTEGER :: nsplt
  INTEGER :: i, j, it, iq
  INTRINSIC ABS
  INTRINSIC MAX
  INTRINSIC INT
  INTRINSIC REAL
  REAL :: x1
  REAL :: abs1
  REAL :: abs0
  REAL :: y1
  xfxd = 0.0
  DO j=jsd,jed
    DO i=is,ie+1
      IF (cx(i, j) .GT. 0.) THEN
        xfxd(i, j) = dxa(i-1, j)*dy(i, j)*sina_u(i, j)*cxd(i, j)
        xfx(i, j) = cx(i, j)*dxa(i-1, j)*dy(i, j)*sina_u(i, j)
      ELSE
        xfxd(i, j) = dxa(i, j)*dy(i, j)*sina_u(i, j)*cxd(i, j)
        xfx(i, j) = cx(i, j)*dxa(i, j)*dy(i, j)*sina_u(i, j)
      END IF
    END DO
  END DO
  yfxd = 0.0
  DO j=js,je+1
    DO i=isd,ied
      IF (cy(i, j) .GT. 0.) THEN
        yfxd(i, j) = dya(i, j-1)*dx(i, j)*sina_v(i, j)*cyd(i, j)
        yfx(i, j) = cy(i, j)*dya(i, j-1)*dx(i, j)*sina_v(i, j)
      ELSE
        yfxd(i, j) = dya(i, j)*dx(i, j)*sina_v(i, j)*cyd(i, j)
        yfx(i, j) = cy(i, j)*dya(i, j)*dx(i, j)*sina_v(i, j)
      END IF
    END DO
  END DO
  IF (q_split .EQ. 0) THEN
! Determine nsplt for tracer advection
    cmax = 0.
    DO j=js,je
      DO i=is,ie
        IF (cx(i, j) .GE. 0.) THEN
          abs0 = cx(i, j)
        ELSE
          abs0 = -cx(i, j)
        END IF
        x1 = abs0 + (1.-sina_u(i, j))
        IF (cy(i, j) .GE. 0.) THEN
          abs1 = cy(i, j)
        ELSE
          abs1 = -cy(i, j)
        END IF
        y1 = abs1 + (1.-sina_v(i, j))
        IF (x1 .LT. y1) THEN
          IF (y1 .LT. cmax) THEN
            cmax = cmax
          ELSE
            cmax = y1
          END IF
        ELSE IF (x1 .LT. cmax) THEN
          cmax = cmax
        ELSE
          cmax = x1
        END IF
      END DO
    END DO
    CALL MP_REDUCE_MAX(cmax)
    nsplt = INT(1.01 + cmax)
  ELSE
    nsplt = q_split
  END IF
  frac = 1./REAL(nsplt)
  DO j=jsd,jed
    DO i=is,ie+1
      cx2(i, j) = cx(i, j)*frac
      xfxd(i, j) = frac*xfxd(i, j)
      xfx(i, j) = xfx(i, j)*frac
    END DO
  END DO
  mfx2d = 0.0
  DO j=js,je
    DO i=is,ie+1
      mfx2d(i, j) = frac*mfxd(i, j)
      mfx2(i, j) = mfx(i, j)*frac
    END DO
  END DO
  DO j=js,je+1
    DO i=isd,ied
      cy2(i, j) = cy(i, j)*frac
      yfxd(i, j) = frac*yfxd(i, j)
      yfx(i, j) = yfx(i, j)*frac
    END DO
  END DO
  mfy2d = 0.0
  DO j=js,je+1
    DO i=is,ie
      mfy2d(i, j) = frac*mfyd(i, j)
      mfy2(i, j) = mfy(i, j)*frac
    END DO
  END DO
  ra_xd = 0.0
  DO j=jsd,jed
    DO i=is,ie
      ra_xd(i, j) = xfxd(i, j) - xfxd(i+1, j)
      ra_x(i, j) = area(i, j) + xfx(i, j) - xfx(i+1, j)
    END DO
  END DO
  ra_yd = 0.0
  DO j=js,je
    DO i=isd,ied
      ra_yd(i, j) = yfxd(i, j) - yfxd(i, j+1)
      ra_y(i, j) = area(i, j) + yfx(i, j) - yfx(i, j+1)
    END DO
  END DO
  dp1d = 0.0
  DO j=js,je
    DO i=is,ie
      dp1d(i, j) = dp0d(i, j)
      dp1(i, j) = dp0(i, j)
    END DO
  END DO
  dp2d = 0.0
  fxd = 0.0
  fyd = 0.0
  DO it=1,nsplt
    DO j=js,je
      DO i=is,ie
        dp2d(i, j) = dp1d(i, j) + rarea(i, j)*(mfx2d(i, j)-mfx2d(i+1, j)&
&         +mfy2d(i, j)-mfy2d(i, j+1))
        dp2(i, j) = dp1(i, j) + (mfx2(i, j)-mfx2(i+1, j)+mfy2(i, j)-mfy2&
&         (i, j+1))*rarea(i, j)
      END DO
    END DO
!call timing_on('COMM_TOTAL')
!call timing_on('COMM_TRAC')
    CALL MPP_UPDATE_DOMAINS_D(q, qd, domain, complete=.true.)
!call timing_off('COMM_TRAC')
!call timing_off('COMM_TOTAL')
    DO iq=1,nq
      CALL FV_TP_2D_TRC_DH_D(q(isd:, jsd:, iq), qd(isd:, jsd:, iq), cx2&
&                      , cy2, npx, npy, hord, fx, fxd, fy, fyd, xfx, &
&                      xfxd, yfx, yfxd, area, ra_x, ra_xd, ra_y, ra_yd, &
&                      mfx2, mfx2d, mfy2, mfy2d, is, ie, js, je, isd, &
&                      ied, jsd, jed, ng)
      IF (it .EQ. nsplt) THEN
        DO j=js,je
          DO i=is,ie
            q3d(i, j, k, iq) = ((qd(i, j, iq)*dp1(i, j)+q(i, j, iq)*dp1d&
&             (i, j)+rarea(i, j)*(fxd(i, j)-fxd(i+1, j)+fyd(i, j)-fyd(i&
&             , j+1)))*dp2(i, j)-(q(i, j, iq)*dp1(i, j)+(fx(i, j)-fx(i+1&
&             , j)+fy(i, j)-fy(i, j+1))*rarea(i, j))*dp2d(i, j))/dp2(i, &
&             j)**2
            q3(i, j, k, iq) = (q(i, j, iq)*dp1(i, j)+(fx(i, j)-fx(i+1, j&
&             )+fy(i, j)-fy(i, j+1))*rarea(i, j))/dp2(i, j)
          END DO
        END DO
      ELSE
        DO j=js,je
          DO i=is,ie
            qd(i, j, iq) = ((qd(i, j, iq)*dp1(i, j)+q(i, j, iq)*dp1d(i, &
&             j)+rarea(i, j)*(fxd(i, j)-fxd(i+1, j)+fyd(i, j)-fyd(i, j+1&
&             )))*dp2(i, j)-(q(i, j, iq)*dp1(i, j)+(fx(i, j)-fx(i+1, j)+&
&             fy(i, j)-fy(i, j+1))*rarea(i, j))*dp2d(i, j))/dp2(i, j)**2
            q(i, j, iq) = (q(i, j, iq)*dp1(i, j)+(fx(i, j)-fx(i+1, j)+fy&
&             (i, j)-fy(i, j+1))*rarea(i, j))/dp2(i, j)
          END DO
        END DO
      END IF
    END DO
    IF (it .NE. nsplt) THEN
      DO j=js,je
        DO i=is,ie
          dp1d(i, j) = dp2d(i, j)
          dp1(i, j) = dp2(i, j)
        END DO
      END DO
    END IF
  END DO
! nsplt
  IF (id_divg .GT. 0) THEN
    rdt = 1./(frac*dt)
    DO j=js,je
      DO i=is,ie
        dp0d(i, j) = rarea(i, j)*rdt*(xfxd(i+1, j)-xfxd(i, j)+yfxd(i, j+&
&         1)-yfxd(i, j))
        dp0(i, j) = (xfx(i+1, j)-xfx(i, j)+yfx(i, j+1)-yfx(i, j))*rarea(&
&         i, j)*rdt
      END DO
    END DO
  END IF
END SUBROUTINE TRACER_2D_1L_DH_D

!  Differentiation of mpp_update_domains in forward (tangent) mode:
!   variations   of useful results: q
!   with respect to varying inputs: q
SUBROUTINE MPP_UPDATE_DOMAINS_D(q, qd, domain, complete)
  IMPLICIT NONE
  REAL :: q(:, :), domain
  REAL :: qd(:, :)
  LOGICAL :: complete
  IF ((complete .EQV. .true.) .AND. domain .GT. 1) THEN
    qd = 2*q*qd + qd/2
    q = q**2 + q/2
  END IF
END SUBROUTINE MPP_UPDATE_DOMAINS_D

!  Differentiation of fv_tp_2d_trc_dh in forward (tangent) mode:
!   variations   of useful results: q fx fy
!   with respect to varying inputs: xfx q mfx mfy ra_x ra_y yfx
!                fx fy
SUBROUTINE FV_TP_2D_TRC_DH_D(q, qd, crx, cry, npx, npy, hord, fx, fxd, &
& fy, fyd, xfx, xfxd, yfx, yfxd, area, ra_x, ra_xd, ra_y, ra_yd, mfx, &
& mfxd, mfy, mfyd, is, ie, js, je, isd, ied, jsd, jed, ng)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, ng
  INTEGER, INTENT(IN) :: npx, npy
  INTEGER, INTENT(IN) :: hord
!
  REAL, INTENT(IN) :: crx(is:ie+1, jsd:jed)
!
  REAL, INTENT(IN) :: xfx(is:ie+1, jsd:jed)
  REAL, INTENT(IN) :: xfxd(is:ie+1, jsd:jed)
!
  REAL, INTENT(IN) :: cry(isd:ied, js:je+1)
!
  REAL, INTENT(IN) :: yfx(isd:ied, js:je+1)
  REAL, INTENT(IN) :: yfxd(isd:ied, js:je+1)
  REAL, INTENT(IN) :: area(isd:ied, jsd:jed)
  REAL, INTENT(IN) :: ra_x(is:ie, jsd:jed)
  REAL, INTENT(IN) :: ra_xd(is:ie, jsd:jed)
  REAL, INTENT(IN) :: ra_y(isd:ied, js:je)
  REAL, INTENT(IN) :: ra_yd(isd:ied, js:je)
! transported scalar
  REAL, INTENT(INOUT) :: q(isd:ied, jsd:jed)
  REAL, INTENT(INOUT) :: qd(isd:ied, jsd:jed)
! Flux in x ( E )
  REAL, INTENT(OUT) :: fx(is:ie+1, js:je)
  REAL, INTENT(OUT) :: fxd(is:ie+1, js:je)
! Flux in y ( N )
  REAL, INTENT(OUT) :: fy(is:ie, js:je+1)
  REAL, INTENT(OUT) :: fyd(is:ie, js:je+1)
! optional Arguments:
! Mass Flux X-Dir
  REAL, OPTIONAL, INTENT(IN) :: mfx(is:ie+1, js:je)
  REAL, OPTIONAL, INTENT(IN) :: mfxd(is:ie+1, js:je)
! Mass Flux Y-Dir
  REAL, OPTIONAL, INTENT(IN) :: mfy(is:ie, js:je+1)
  REAL, OPTIONAL, INTENT(IN) :: mfyd(is:ie, js:je+1)
! Local:
  INTEGER :: ord, ord_in
  REAL :: q_i(isd:ied, js:je)
  REAL :: q_id(isd:ied, js:je)
  REAL :: q_j(is:ie, jsd:jed)
  REAL :: q_jd(is:ie, jsd:jed)
  REAL :: fx2(is:ie+1, jsd:jed)
  REAL :: fx2d(is:ie+1, jsd:jed)
  REAL :: fy2(isd:ied, js:je+1)
  REAL :: fy2d(isd:ied, js:je+1)
  REAL :: fyy(isd:ied, js:je+1)
  REAL :: fyyd(isd:ied, js:je+1)
  REAL :: fx1(is:ie+1)
  REAL :: fx1d(is:ie+1)
  REAL :: ppm_limiter
  INTEGER :: i, j
  INTRINSIC ABS
  INTRINSIC PRESENT
  IF (hord .LT. 0) THEN
!More dissipation
    ord_in = 2
    IF (hord .GE. 0.) THEN
      ord = hord
    ELSE
      ord = -hord
    END IF
  ELSE
    ord_in = hord
    ord = hord
  END IF
  ppm_limiter = 2.0
!Part 1
  CALL COPY_CORNERS_D(q, qd, 2)
  fy2d = 0.0
  CALL YTP_DH_D(fy2, fy2d, q, qd, cry, ord_in, isd, ied, js, je, npx, &
&         npy, ppm_limiter, is, ie, js, je, isd, ied, jsd, jed, ng)
  fyyd = 0.0
  DO j=js,je+1
    DO i=isd,ied
      fyyd(i, j) = yfxd(i, j)*fy2(i, j) + yfx(i, j)*fy2d(i, j)
      fyy(i, j) = yfx(i, j)*fy2(i, j)
    END DO
  END DO
  q_id = 0.0
  DO j=js,je
    DO i=isd,ied
      q_id(i, j) = ((area(i, j)*qd(i, j)+fyyd(i, j)-fyyd(i, j+1))*ra_y(i&
&       , j)-(q(i, j)*area(i, j)+fyy(i, j)-fyy(i, j+1))*ra_yd(i, j))/&
&       ra_y(i, j)**2
      q_i(i, j) = (q(i, j)*area(i, j)+fyy(i, j)-fyy(i, j+1))/ra_y(i, j)
    END DO
  END DO
  CALL XTP_DH_D(fx, fxd, q_i, q_id, crx(is, js), ord, is, ie, js, je, &
&         npx, npy, ppm_limiter, is, ie, js, je, isd, ied, jsd, jed, ng)
!Part 2
  CALL COPY_CORNERS_D(q, qd, 1)
  fx2d = 0.0
  CALL XTP_DH_D(fx2, fx2d, q, qd, crx, ord_in, is, ie, jsd, jed, npx, &
&         npy, ppm_limiter, is, ie, js, je, isd, ied, jsd, jed, ng)
  q_jd = 0.0
  fx1d = 0.0
  DO j=jsd,jed
    DO i=is,ie+1
      fx1d(i) = xfxd(i, j)*fx2(i, j) + xfx(i, j)*fx2d(i, j)
      fx1(i) = xfx(i, j)*fx2(i, j)
    END DO
    DO i=is,ie
      q_jd(i, j) = ((area(i, j)*qd(i, j)+fx1d(i)-fx1d(i+1))*ra_x(i, j)-(&
&       q(i, j)*area(i, j)+fx1(i)-fx1(i+1))*ra_xd(i, j))/ra_x(i, j)**2
      q_j(i, j) = (q(i, j)*area(i, j)+fx1(i)-fx1(i+1))/ra_x(i, j)
    END DO
  END DO
  CALL YTP_DH_D(fy, fyd, q_j, q_jd, cry, ord, is, ie, js, je, npx, npy, &
&         ppm_limiter, is, ie, js, je, isd, ied, jsd, jed, ng)
! Flux averaging:
!----------------
  IF (PRESENT(mfx) .AND. PRESENT(mfy)) THEN
!---------------------------------
! For transport of pt and tracers
!---------------------------------
    DO j=js,je
      DO i=is,ie+1
        fxd(i, j) = 0.5*((fxd(i, j)+fx2d(i, j))*mfx(i, j)+(fx(i, j)+fx2(&
&         i, j))*mfxd(i, j))
        fx(i, j) = 0.5*(fx(i, j)+fx2(i, j))*mfx(i, j)
      END DO
    END DO
    DO j=js,je+1
      DO i=is,ie
        fyd(i, j) = 0.5*((fyd(i, j)+fy2d(i, j))*mfy(i, j)+(fy(i, j)+fy2(&
&         i, j))*mfyd(i, j))
        fy(i, j) = 0.5*(fy(i, j)+fy2(i, j))*mfy(i, j)
      END DO
    END DO
  ELSE
!---------------------------------
! For transport of delp, vorticity
!---------------------------------
    DO j=js,je
      DO i=is,ie+1
        fxd(i, j) = 0.5*((fxd(i, j)+fx2d(i, j))*xfx(i, j)+(fx(i, j)+fx2(&
&         i, j))*xfxd(i, j))
        fx(i, j) = 0.5*(fx(i, j)+fx2(i, j))*xfx(i, j)
      END DO
    END DO
    DO j=js,je+1
      DO i=is,ie
        fyd(i, j) = 0.5*((fyd(i, j)+fy2d(i, j))*yfx(i, j)+(fy(i, j)+fy2(&
&         i, j))*yfxd(i, j))
        fy(i, j) = 0.5*(fy(i, j)+fy2(i, j))*yfx(i, j)
      END DO
    END DO
  END IF
END SUBROUTINE FV_TP_2D_TRC_DH_D

!  Differentiation of copy_corners in forward (tangent) mode:
!   variations   of useful results: q
!   with respect to varying inputs: q
SUBROUTINE COPY_CORNERS_D(q, qd, indy)
  IMPLICIT NONE
  INTEGER :: indy
!Prognostic
  REAL, INTENT(INOUT) :: q(:, :)
  REAL, INTENT(INOUT) :: qd(:, :)
!Locals
  INTEGER :: i, j
  INTRINSIC SIZE
  IF (indy .EQ. 2) THEN
    DO j=1,SIZE(q, 1)
      DO i=1,SIZE(q, 2)
        qd(i, j) = qd(j, 1-i)
        q(i, j) = q(j, 1-i)
      END DO
    END DO
  ELSE
    DO j=1,SIZE(q, 1)
      DO i=1,SIZE(q, 2)
        qd(i, j) = qd(j, 1-2)
        q(i, j) = q(j, 1-2)
      END DO
    END DO
  END IF
END SUBROUTINE COPY_CORNERS_D

!  Differentiation of xtp_dh in forward (tangent) mode:
!   variations   of useful results: fx
!   with respect to varying inputs: q fx
SUBROUTINE XTP_DH_D(fx, fxd, q, qd, c, iord, ifirst, ilast, jfirst, &
& jlast, npx, npy, ppm_limiter, is, ie, js, je, isd, ied, jsd, jed, ng)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, ng
!  X-Dir strip
  INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
  INTEGER, INTENT(IN) :: jfirst, jlast
  INTEGER, INTENT(IN) :: npx, npy
  INTEGER, INTENT(IN) :: iord
! Courant numbers
  REAL, INTENT(IN) :: c(is:ie+1, jfirst:jlast)
  REAL, INTENT(IN) :: q(isd:ied, jfirst:jlast)
  REAL, INTENT(IN) :: qd(isd:ied, jfirst:jlast)
  REAL, INTENT(IN) :: ppm_limiter
  REAL, INTENT(OUT) :: fx(ifirst:ilast+1, jfirst:jlast)
  REAL, INTENT(OUT) :: fxd(ifirst:ilast+1, jfirst:jlast)
! Local:
  REAL :: dm(is-2:ie+2)
  REAL :: x0, x1
  INTEGER :: i, j
  DO j=jfirst,jlast
    DO i=ifirst,ilast+1
      IF (c(i, j) .GT. 0.) THEN
        fxd(i, j) = qd(i-1, j)
        fx(i, j) = q(i-1, j)
      ELSE
        fxd(i, j) = qd(i, j)
        fx(i, j) = q(i, j)
      END IF
    END DO
  END DO
END SUBROUTINE XTP_DH_D

!  Differentiation of ytp_dh in forward (tangent) mode:
!   variations   of useful results: fy
!   with respect to varying inputs: q fy
SUBROUTINE YTP_DH_D(fy, fyd, q, qd, c, jord, ifirst, ilast, jfirst, &
& jlast, npx, npy, ppm_limiter, is, ie, js, je, isd, ied, jsd, jed, ng)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: is, ie, js, je, isd, ied, jsd, jed, ng
  INTEGER, INTENT(IN) :: npx, npy
!  X-Dir strip
  INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
  INTEGER, INTENT(IN) :: jfirst, jlast
  INTEGER, INTENT(IN) :: jord
  REAL, INTENT(IN) :: q(ifirst:ilast, jfirst-ng:jlast+ng)
  REAL, INTENT(IN) :: qd(ifirst:ilast, jfirst-ng:jlast+ng)
! Courant number
  REAL, INTENT(IN) :: c(isd:ied, js:je+1)
!  Flux
  REAL, INTENT(OUT) :: fy(ifirst:ilast, jfirst:jlast+1)
  REAL, INTENT(OUT) :: fyd(ifirst:ilast, jfirst:jlast+1)
  REAL, INTENT(IN) :: ppm_limiter
! !LOCAL VARIABLES:
  REAL :: dm(ifirst:ilast, jfirst-2:jlast+2)
  REAL :: x0, x1
  INTEGER :: i, j
  DO j=jfirst,jlast+1
    DO i=ifirst,ilast
      IF (c(i, j) .GT. 0.) THEN
        fyd(i, j) = qd(i, j-1)
        fy(i, j) = q(i, j-1)
      ELSE
        fyd(i, j) = qd(i, j)
        fy(i, j) = q(i, j)
      END IF
    END DO
  END DO
END SUBROUTINE YTP_DH_D

