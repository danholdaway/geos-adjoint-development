!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.13 (r6666) - 27 Nov 2017 17:09
!
!  $Id: GEOS_Utilities.F90,v 1.16 2007/10/04 20:38:23 dasilva Exp $
!BOP
! !MODULE: GEOS_Utils -- A Module to containing computational utilities
MODULE GEOS_UTILSMOD_DIFF
! !USES:
  USE MAPL_CONSTANTSMOD
  IMPLICIT NONE
  PRIVATE 
! !PUBLIC MEMBER FUNCTIONS:
  PUBLIC geos_qsatset
  PUBLIC geos_qsatlqu
  PUBLIC geos_qsatlqu_tlm
  PUBLIC geos_qsatice
  PUBLIC geos_qsatice_tlm
  PUBLIC geos_qsat
  PUBLIC geos_dqsat
  PUBLIC geos_dqsat_tlm
  PUBLIC geos_trilu
  PUBLIC geos_trisolve
  REAL, PARAMETER :: esfac=mapl_h2omw/mapl_airmw
  REAL, PARAMETER :: max_mixing_ratio=1.
  REAL, PARAMETER :: zeroc=mapl_tice
  REAL, PARAMETER :: tmintbl=150.0
  REAL, PARAMETER :: tmaxtbl=333.0
  INTEGER, PARAMETER :: degsubs=100
  REAL, PARAMETER :: erfac=degsubs/esfac
  REAL, PARAMETER :: delta_t=1.0/degsubs
  INTEGER, PARAMETER :: tablesize=NINT(tmaxtbl-tmintbl)*degsubs+1
  REAL, PARAMETER :: tmix=-20.
  LOGICAL, SAVE :: utbl=.true.
  INTEGER, SAVE :: type=1
  LOGICAL, SAVE :: first=.true.
  REAL, SAVE :: estfrz
  REAL, SAVE :: estlqu
  REAL, SAVE :: estble(tablesize)
  REAL, SAVE :: estblw(tablesize)
  REAL, SAVE :: estblx(tablesize)
  REAL, PARAMETER :: tminstr=-95.
  REAL, PARAMETER :: tstarr1=-75.
  REAL, PARAMETER :: tstarr2=-65.
  REAL, PARAMETER :: tstarr3=-50.
  REAL, PARAMETER :: tstarr4=-40.
  REAL, PARAMETER :: tmaxstr=60.
  REAL*8, PARAMETER :: b6=6.136820929e-11*100.0
  REAL*8, PARAMETER :: b5=2.034080948e-8*100.0
  REAL*8, PARAMETER :: b4=3.031240396e-6*100.0
  REAL*8, PARAMETER :: b3=2.650648471e-4*100.0
  REAL*8, PARAMETER :: b2=1.428945805e-2*100.0
  REAL*8, PARAMETER :: b1=4.436518521e-1*100.0
  REAL*8, PARAMETER :: b0=6.107799961e+0*100.0
  REAL*8, PARAMETER :: bi6=1.838826904e-10*100.0
  REAL*8, PARAMETER :: bi5=4.838803174e-8*100.0
  REAL*8, PARAMETER :: bi4=5.824720280e-6*100.0
  REAL*8, PARAMETER :: bi3=4.176223716e-4*100.0
  REAL*8, PARAMETER :: bi2=1.886013408e-2*100.0
  REAL*8, PARAMETER :: bi1=5.034698970e-1*100.0
  REAL*8, PARAMETER :: bi0=6.109177956e+0*100.0
  REAL*8, PARAMETER :: s16=0.516000335e-11*100.0
  REAL*8, PARAMETER :: s15=0.276961083e-8*100.0
  REAL*8, PARAMETER :: s14=0.623439266e-6*100.0
  REAL*8, PARAMETER :: s13=0.754129933e-4*100.0
  REAL*8, PARAMETER :: s12=0.517609116e-2*100.0
  REAL*8, PARAMETER :: s11=0.191372282e+0*100.0
  REAL*8, PARAMETER :: s10=0.298152339e+1*100.0
  REAL*8, PARAMETER :: s26=0.314296723e-10*100.0
  REAL*8, PARAMETER :: s25=0.132243858e-7*100.0
  REAL*8, PARAMETER :: s24=0.236279781e-5*100.0
  REAL*8, PARAMETER :: s23=0.230325039e-3*100.0
  REAL*8, PARAMETER :: s22=0.129690326e-1*100.0
  REAL*8, PARAMETER :: s21=0.401390832e+0*100.0
  REAL*8, PARAMETER :: s20=0.535098336e+1*100.0
  REAL*8, PARAMETER :: di(0:3)=(/57518.5606e08, 2.01889049, 3.56654, &
&   20.947031/)
  REAL*8, PARAMETER :: ci(0:3)=(/9.550426, -5723.265, 3.53068, -&
&   .00728332/)
  REAL*8, PARAMETER :: dl(6)=(/-7.902980, 5.02808, -1.3816, 11.344, &
&   8.1328, -3.49149/)
! log10(1013.246)
  REAL*8, PARAMETER :: logps=3.005714898
  REAL*8, PARAMETER :: ts=373.16
  REAL*8, PARAMETER :: cl(0:9)=(/54.842763, -6763.22, -4.21000, .000367&
&   , .0415, 218.8, 53.878000, -1331.22, -9.44523, .014025/)
  REAL, SAVE :: tminlqu=zeroc-40.0
  REAL, SAVE :: tminice=zeroc+tminstr
  INTERFACE GEOS_QSATICE
      MODULE PROCEDURE QSATICE0
      MODULE PROCEDURE QSATICE1
      MODULE PROCEDURE QSATICE2
      MODULE PROCEDURE QSATICE3
  END INTERFACE

  INTERFACE GEOS_QSATICE_TLM
      MODULE PROCEDURE QSATICE0_TLM
  END INTERFACE

  INTERFACE GEOS_QSATLQU
      MODULE PROCEDURE QSATLQU0
      MODULE PROCEDURE QSATLQU1
      MODULE PROCEDURE QSATLQU2
      MODULE PROCEDURE QSATLQU3
  END INTERFACE

  INTERFACE GEOS_QSATLQU_TLM
      MODULE PROCEDURE QSATLQU0_TLM
  END INTERFACE

  INTERFACE GEOS_DQSAT
      MODULE PROCEDURE DQSAT0
      MODULE PROCEDURE DQSAT1
      MODULE PROCEDURE DQSAT2
      MODULE PROCEDURE DQSAT3
  END INTERFACE

  INTERFACE GEOS_DQSAT_TLM
      MODULE PROCEDURE DQSAT0_TLM
  END INTERFACE

  INTERFACE GEOS_QSAT
      MODULE PROCEDURE QSAT0
      MODULE PROCEDURE QSAT1
      MODULE PROCEDURE QSAT2
      MODULE PROCEDURE QSAT3
  END INTERFACE

  INTERFACE GEOS_TRILU
      MODULE PROCEDURE GEOS_TRILU1
      MODULE PROCEDURE GEOS_TRILU2
      MODULE PROCEDURE GEOS_TRILU3
  END INTERFACE

  INTERFACE GEOS_TRISOLVE
      MODULE PROCEDURE GEOS_TRISOLVE1
      MODULE PROCEDURE GEOS_TRISOLVE2
      MODULE PROCEDURE GEOS_TRISOLVE3
  END INTERFACE


CONTAINS
  FUNCTION QSATLQU1(tl, pl, dq) RESULT (QS)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:)
    REAL, OPTIONAL, INTENT(IN) :: pl(:)
    REAL, OPTIONAL, INTENT(OUT) :: dq(:)
    REAL :: qs(SIZE(tl, 1))
    INTEGER :: i
    REAL :: ti, w
    REAL :: tt
    REAL :: ddq
    REAL :: dd
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC LOG10
    INTRINSIC ALOG
    INTRINSIC TANH
    INTRINSIC EXP
    REAL*8 :: pwy1
    REAL*8 :: pwr1
    REAL*8 :: pwy2
    REAL*8 :: pwr2
    REAL*8 :: pwy3
    REAL*8 :: arg1
    REAL*8 :: arg2
    INTRINSIC SIZE
    DO i=1,SIZE(tl, 1)
! not table
      IF (utbl) THEN
        IF (first) THEN
          first = .false.
          CALL ESINIT()
        END IF
        IF (tl(i) .LE. tminlqu) THEN
          qs(i) = estlqu
          IF (PRESENT(dq)) ddq = 0.0
        ELSE IF (tl(i) .GE. tmaxtbl) THEN
          qs(i) = estblw(tablesize)
          IF (PRESENT(dq)) ddq = 0.0
        ELSE
          tt = (tl(i)-tmintbl)*degsubs + 1
          it = INT(tt)
          ddq = estblw(it+1) - estblw(it)
          qs(i) = (tt-it)*ddq + estblw(it)
        END IF
        IF (PRESENT(pl)) THEN
          IF (pl(i) .GT. qs(i)) THEN
            dd = esfac/(pl(i)-(1.0-esfac)*qs(i))
            qs(i) = qs(i)*dd
            IF (PRESENT(dq)) dq(i) = ddq*erfac*pl(i)*dd*dd
          ELSE
            qs(i) = max_mixing_ratio
            IF (PRESENT(dq)) dq(i) = 0.0
          END IF
        ELSE IF (PRESENT(dq)) THEN
          dq(i) = ddq
        END IF
      ELSE
! Exact Formulation
        IF (tl(i) .LT. tminlqu) THEN
          ti = tminlqu
        ELSE IF (tl(i) .GT. tmaxtbl) THEN
          ti = tmaxtbl
        ELSE
          ti = tl(i)
        END IF
        IF (type .EQ. 1) THEN
!  Starr polynomial fit
          tt = ti - zeroc
          qs(i) = tt*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+b1) + b0
        ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
          tt = ts/ti
          pwy1 = dl(4)*(1.0-1.0/tt)
          pwr1 = 10.0**pwy1
          pwy2 = dl(6)*(tt-1.0)
          pwr2 = 10.0**pwy2
          pwy3 = dl(1)*(tt-1.0) + dl(2)*LOG10(tt) + dl(3)*(pwr1-1.0)/&
&           10000000.0 + dl(5)*(pwr2-1.0)/1000.0 + logps + 2.0
          qs(i) = 10.0**pwy3
        ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
          arg1 = cl(4)*(ti-cl(5))
          arg2 = cl(0) + cl(1)/ti + cl(2)*ALOG(ti) + cl(3)*ti + TANH(&
&           arg1)*(cl(6)+cl(7)/ti+cl(8)*ALOG(ti)+cl(9)*ti)
          qs(i) = EXP(arg2)
        END IF
        IF (PRESENT(dq)) THEN
          IF (tl(i) .LT. tminlqu) THEN
            ddq = 0.0
          ELSE IF (tl(i) .GT. tmaxtbl) THEN
            ddq = 0.0
          ELSE IF (pl(i) .GT. qs(i)) THEN
            dd = qs(i)
            ti = tl(i) + delta_t
            IF (type .EQ. 1) THEN
!  Starr polynomial fit
              tt = ti - zeroc
              qs(i) = tt*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+b1) + b0
            ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
              tt = ts/ti
              pwy1 = dl(4)*(1.0-1.0/tt)
              pwr1 = 10.0**pwy1
              pwy2 = dl(6)*(tt-1.0)
              pwr2 = 10.0**pwy2
              pwy3 = dl(1)*(tt-1.0) + dl(2)*LOG10(tt) + dl(3)*(pwr1-1.0)&
&               /10000000.0 + dl(5)*(pwr2-1.0)/1000.0 + logps + 2.0
              qs(i) = 10.0**pwy3
            ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
              arg1 = cl(4)*(ti-cl(5))
              arg2 = cl(0) + cl(1)/ti + cl(2)*ALOG(ti) + cl(3)*ti + TANH&
&               (arg1)*(cl(6)+cl(7)/ti+cl(8)*ALOG(ti)+cl(9)*ti)
              qs(i) = EXP(arg2)
            END IF
            ddq = qs(i) - dd
            qs(i) = dd
          END IF
        END IF
        IF (PRESENT(pl)) THEN
          IF (pl(i) .GT. qs(i)) THEN
            dd = esfac/(pl(i)-(1.0-esfac)*qs(i))
            qs(i) = qs(i)*dd
            IF (PRESENT(dq)) dq(i) = ddq*erfac*pl(i)*dd*dd
          ELSE
            qs(i) = max_mixing_ratio
            IF (PRESENT(dq)) dq(i) = 0.0
          END IF
        ELSE IF (PRESENT(dq)) THEN
          dq(i) = ddq*(1.0/delta_t)
        END IF
      END IF
    END DO
  END FUNCTION QSATLQU1
  FUNCTION QSATLQU2(tl, pl, dq) RESULT (QS)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:, :)
    REAL, OPTIONAL, INTENT(IN) :: pl(:, :)
    REAL, OPTIONAL, INTENT(OUT) :: dq(:, :)
    REAL :: qs(SIZE(tl, 1), SIZE(tl, 2))
    INTEGER :: i, j
    REAL :: ti, w
    REAL :: tt
    REAL :: ddq
    REAL :: dd
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC LOG10
    INTRINSIC ALOG
    INTRINSIC TANH
    INTRINSIC EXP
    REAL*8 :: pwy1
    REAL*8 :: pwr1
    REAL*8 :: pwy2
    REAL*8 :: pwr2
    REAL*8 :: pwy3
    REAL*8 :: arg1
    REAL*8 :: arg2
    INTRINSIC SIZE
    DO j=1,SIZE(tl, 2)
      DO i=1,SIZE(tl, 1)
! not table
        IF (utbl) THEN
          IF (first) THEN
            first = .false.
            CALL ESINIT()
          END IF
          IF (tl(i, j) .LE. tminlqu) THEN
            qs(i, j) = estlqu
            IF (PRESENT(dq)) ddq = 0.0
          ELSE IF (tl(i, j) .GE. tmaxtbl) THEN
            qs(i, j) = estblw(tablesize)
            IF (PRESENT(dq)) ddq = 0.0
          ELSE
            tt = (tl(i, j)-tmintbl)*degsubs + 1
            it = INT(tt)
            ddq = estblw(it+1) - estblw(it)
            qs(i, j) = (tt-it)*ddq + estblw(it)
          END IF
          IF (PRESENT(pl)) THEN
            IF (pl(i, j) .GT. qs(i, j)) THEN
              dd = esfac/(pl(i, j)-(1.0-esfac)*qs(i, j))
              qs(i, j) = qs(i, j)*dd
              IF (PRESENT(dq)) dq(i, j) = ddq*erfac*pl(i, j)*dd*dd
            ELSE
              qs(i, j) = max_mixing_ratio
              IF (PRESENT(dq)) dq(i, j) = 0.0
            END IF
          ELSE IF (PRESENT(dq)) THEN
            dq(i, j) = ddq
          END IF
        ELSE
! Exact Formulation
          IF (tl(i, j) .LT. tminlqu) THEN
            ti = tminlqu
          ELSE IF (tl(i, j) .GT. tmaxtbl) THEN
            ti = tmaxtbl
          ELSE
            ti = tl(i, j)
          END IF
          IF (type .EQ. 1) THEN
!  Starr polynomial fit
            tt = ti - zeroc
            qs(i, j) = tt*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+b1) + &
&             b0
          ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
            tt = ts/ti
            pwy1 = dl(4)*(1.0-1.0/tt)
            pwr1 = 10.0**pwy1
            pwy2 = dl(6)*(tt-1.0)
            pwr2 = 10.0**pwy2
            pwy3 = dl(1)*(tt-1.0) + dl(2)*LOG10(tt) + dl(3)*(pwr1-1.0)/&
&             10000000.0 + dl(5)*(pwr2-1.0)/1000.0 + logps + 2.0
            qs(i, j) = 10.0**pwy3
          ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
            arg1 = cl(4)*(ti-cl(5))
            arg2 = cl(0) + cl(1)/ti + cl(2)*ALOG(ti) + cl(3)*ti + TANH(&
&             arg1)*(cl(6)+cl(7)/ti+cl(8)*ALOG(ti)+cl(9)*ti)
            qs(i, j) = EXP(arg2)
          END IF
          IF (PRESENT(dq)) THEN
            IF (tl(i, j) .LT. tminlqu) THEN
              ddq = 0.0
            ELSE IF (tl(i, j) .GT. tmaxtbl) THEN
              ddq = 0.0
            ELSE IF (pl(i, j) .GT. qs(i, j)) THEN
              dd = qs(i, j)
              ti = tl(i, j) + delta_t
              IF (type .EQ. 1) THEN
!  Starr polynomial fit
                tt = ti - zeroc
                qs(i, j) = tt*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+b1)&
&                 + b0
              ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
                tt = ts/ti
                pwy1 = dl(4)*(1.0-1.0/tt)
                pwr1 = 10.0**pwy1
                pwy2 = dl(6)*(tt-1.0)
                pwr2 = 10.0**pwy2
                pwy3 = dl(1)*(tt-1.0) + dl(2)*LOG10(tt) + dl(3)*(pwr1-&
&                 1.0)/10000000.0 + dl(5)*(pwr2-1.0)/1000.0 + logps + &
&                 2.0
                qs(i, j) = 10.0**pwy3
              ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
                arg1 = cl(4)*(ti-cl(5))
                arg2 = cl(0) + cl(1)/ti + cl(2)*ALOG(ti) + cl(3)*ti + &
&                 TANH(arg1)*(cl(6)+cl(7)/ti+cl(8)*ALOG(ti)+cl(9)*ti)
                qs(i, j) = EXP(arg2)
              END IF
              ddq = qs(i, j) - dd
              qs(i, j) = dd
            END IF
          END IF
          IF (PRESENT(pl)) THEN
            IF (pl(i, j) .GT. qs(i, j)) THEN
              dd = esfac/(pl(i, j)-(1.0-esfac)*qs(i, j))
              qs(i, j) = qs(i, j)*dd
              IF (PRESENT(dq)) dq(i, j) = ddq*erfac*pl(i, j)*dd*dd
            ELSE
              qs(i, j) = max_mixing_ratio
              IF (PRESENT(dq)) dq(i, j) = 0.0
            END IF
          ELSE IF (PRESENT(dq)) THEN
            dq(i, j) = ddq*(1.0/delta_t)
          END IF
        END IF
      END DO
    END DO
  END FUNCTION QSATLQU2
  FUNCTION QSATLQU3(tl, pl, dq) RESULT (QS)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:, :, :)
    REAL, OPTIONAL, INTENT(IN) :: pl(:, :, :)
    REAL, OPTIONAL, INTENT(OUT) :: dq(:, :, :)
    REAL :: qs(SIZE(tl, 1), SIZE(tl, 2), SIZE(tl, 3))
    INTEGER :: i, j, k
    REAL :: ti, w
    REAL :: tt
    REAL :: ddq
    REAL :: dd
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC LOG10
    INTRINSIC ALOG
    INTRINSIC TANH
    INTRINSIC EXP
    REAL*8 :: pwy1
    REAL*8 :: pwr1
    REAL*8 :: pwy2
    REAL*8 :: pwr2
    REAL*8 :: pwy3
    REAL*8 :: arg1
    REAL*8 :: arg2
    INTRINSIC SIZE
    DO k=1,SIZE(tl, 3)
      DO j=1,SIZE(tl, 2)
        DO i=1,SIZE(tl, 1)
! not table
          IF (utbl) THEN
            IF (first) THEN
              first = .false.
              CALL ESINIT()
            END IF
            IF (tl(i, j, k) .LE. tminlqu) THEN
              qs(i, j, k) = estlqu
              IF (PRESENT(dq)) ddq = 0.0
            ELSE IF (tl(i, j, k) .GE. tmaxtbl) THEN
              qs(i, j, k) = estblw(tablesize)
              IF (PRESENT(dq)) ddq = 0.0
            ELSE
              tt = (tl(i, j, k)-tmintbl)*degsubs + 1
              it = INT(tt)
              ddq = estblw(it+1) - estblw(it)
              qs(i, j, k) = (tt-it)*ddq + estblw(it)
            END IF
            IF (PRESENT(pl)) THEN
              IF (pl(i, j, k) .GT. qs(i, j, k)) THEN
                dd = esfac/(pl(i, j, k)-(1.0-esfac)*qs(i, j, k))
                qs(i, j, k) = qs(i, j, k)*dd
                IF (PRESENT(dq)) dq(i, j, k) = ddq*erfac*pl(i, j, k)*dd*&
&                   dd
              ELSE
                qs(i, j, k) = max_mixing_ratio
                IF (PRESENT(dq)) dq(i, j, k) = 0.0
              END IF
            ELSE IF (PRESENT(dq)) THEN
              dq(i, j, k) = ddq
            END IF
          ELSE
! Exact Formulation
            IF (tl(i, j, k) .LT. tminlqu) THEN
              ti = tminlqu
            ELSE IF (tl(i, j, k) .GT. tmaxtbl) THEN
              ti = tmaxtbl
            ELSE
              ti = tl(i, j, k)
            END IF
            IF (type .EQ. 1) THEN
!  Starr polynomial fit
              tt = ti - zeroc
              qs(i, j, k) = tt*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+b1&
&               ) + b0
            ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
              tt = ts/ti
              pwy1 = dl(4)*(1.0-1.0/tt)
              pwr1 = 10.0**pwy1
              pwy2 = dl(6)*(tt-1.0)
              pwr2 = 10.0**pwy2
              pwy3 = dl(1)*(tt-1.0) + dl(2)*LOG10(tt) + dl(3)*(pwr1-1.0)&
&               /10000000.0 + dl(5)*(pwr2-1.0)/1000.0 + logps + 2.0
              qs(i, j, k) = 10.0**pwy3
            ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
              arg1 = cl(4)*(ti-cl(5))
              arg2 = cl(0) + cl(1)/ti + cl(2)*ALOG(ti) + cl(3)*ti + TANH&
&               (arg1)*(cl(6)+cl(7)/ti+cl(8)*ALOG(ti)+cl(9)*ti)
              qs(i, j, k) = EXP(arg2)
            END IF
            IF (PRESENT(dq)) THEN
              IF (tl(i, j, k) .LT. tminlqu) THEN
                ddq = 0.0
              ELSE IF (tl(i, j, k) .GT. tmaxtbl) THEN
                ddq = 0.0
              ELSE IF (pl(i, j, k) .GT. qs(i, j, k)) THEN
                dd = qs(i, j, k)
                ti = tl(i, j, k) + delta_t
                IF (type .EQ. 1) THEN
!  Starr polynomial fit
                  tt = ti - zeroc
                  qs(i, j, k) = tt*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2&
&                   )+b1) + b0
                ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
                  tt = ts/ti
                  pwy1 = dl(4)*(1.0-1.0/tt)
                  pwr1 = 10.0**pwy1
                  pwy2 = dl(6)*(tt-1.0)
                  pwr2 = 10.0**pwy2
                  pwy3 = dl(1)*(tt-1.0) + dl(2)*LOG10(tt) + dl(3)*(pwr1-&
&                   1.0)/10000000.0 + dl(5)*(pwr2-1.0)/1000.0 + logps + &
&                   2.0
                  qs(i, j, k) = 10.0**pwy3
                ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
                  arg1 = cl(4)*(ti-cl(5))
                  arg2 = cl(0) + cl(1)/ti + cl(2)*ALOG(ti) + cl(3)*ti + &
&                   TANH(arg1)*(cl(6)+cl(7)/ti+cl(8)*ALOG(ti)+cl(9)*ti)
                  qs(i, j, k) = EXP(arg2)
                END IF
                ddq = qs(i, j, k) - dd
                qs(i, j, k) = dd
              END IF
            END IF
            IF (PRESENT(pl)) THEN
              IF (pl(i, j, k) .GT. qs(i, j, k)) THEN
                dd = esfac/(pl(i, j, k)-(1.0-esfac)*qs(i, j, k))
                qs(i, j, k) = qs(i, j, k)*dd
                IF (PRESENT(dq)) dq(i, j, k) = ddq*erfac*pl(i, j, k)*dd*&
&                   dd
              ELSE
                qs(i, j, k) = max_mixing_ratio
                IF (PRESENT(dq)) dq(i, j, k) = 0.0
              END IF
            ELSE IF (PRESENT(dq)) THEN
              dq(i, j, k) = ddq*(1.0/delta_t)
            END IF
          END IF
        END DO
      END DO
    END DO
  END FUNCTION QSATLQU3
  FUNCTION QSATICE1(tl, pl, dq) RESULT (QS)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:)
    REAL, OPTIONAL, INTENT(IN) :: pl(:)
    REAL, OPTIONAL, INTENT(OUT) :: dq(:)
    REAL :: qs(SIZE(tl, 1))
    INTEGER :: i
    REAL :: ti, w
    REAL :: tt
    REAL :: ddq
    REAL :: dd
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC LOG
    INTRINSIC EXP
    INTRINSIC ALOG
    REAL*8 :: arg1
    INTRINSIC SIZE
    DO i=1,SIZE(tl, 1)
      IF (utbl) THEN
        IF (first) THEN
          first = .false.
          CALL ESINIT()
        END IF
        IF (tl(i) .LE. tmintbl) THEN
          qs(i) = estble(1)
          IF (PRESENT(dq)) ddq = 0.0
        ELSE IF (tl(i) .GE. zeroc) THEN
          qs(i) = estfrz
          IF (PRESENT(dq)) ddq = 0.0
        ELSE
          tt = (tl(i)-tmintbl)*degsubs + 1
          it = INT(tt)
          ddq = estble(it+1) - estble(it)
          qs(i) = (tt-it)*ddq + estble(it)
        END IF
        IF (PRESENT(pl)) THEN
          IF (pl(i) .GT. qs(i)) THEN
            dd = esfac/(pl(i)-(1.0-esfac)*qs(i))
            qs(i) = qs(i)*dd
            IF (PRESENT(dq)) dq(i) = ddq*erfac*pl(i)*dd*dd
          ELSE
            qs(i) = max_mixing_ratio
            IF (PRESENT(dq)) dq(i) = 0.0
          END IF
        ELSE IF (PRESENT(dq)) THEN
          dq(i) = ddq
        END IF
      ELSE
! Exact Formulation
        IF (tl(i) .LT. tminice) THEN
          ti = tminice
        ELSE IF (tl(i) .GT. zeroc) THEN
          ti = zeroc
        ELSE
          ti = tl(i)
        END IF
        IF (type .EQ. 1) THEN
! Use Starr formulation
          tt = ti - zeroc
          IF (tt .LT. tstarr1) THEN
            qs(i) = tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+s11) &
&             + s10
          ELSE IF (tt .GE. tstarr1 .AND. tt .LT. tstarr2) THEN
            w = (tstarr2-tt)/(tstarr2-tstarr1)
            qs(i) = w*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+&
&             s11)+s10) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+&
&             s23)+s22)+s21)+s20)
          ELSE IF (tt .GE. tstarr2 .AND. tt .LT. tstarr3) THEN
            qs(i) = tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+s21) &
&             + s20
          ELSE IF (tt .GE. tstarr3 .AND. tt .LT. tstarr4) THEN
            w = (tstarr4-tt)/(tstarr4-tstarr3)
            qs(i) = w*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+&
&             s21)+s20) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+&
&             bi3)+bi2)+bi1)+bi0)
          ELSE
            qs(i) = tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2)+bi1) &
&             + bi0
          END IF
        ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
          tt = zeroc/ti
          arg1 = -(di(1)/tt+di(2)*LOG(tt)+di(3)*tt)
          qs(i) = di(0)*EXP(arg1)
        ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
          arg1 = ci(0) + ci(1)/ti + ci(2)*ALOG(ti) + ci(3)*ti
          qs(i) = EXP(arg1)
        END IF
        IF (PRESENT(dq)) THEN
          IF (tl(i) .LT. tminice) THEN
            ddq = 0.0
          ELSE IF (tl(i) .GT. zeroc) THEN
            ddq = 0.0
          ELSE IF (pl(i) .GT. qs(i)) THEN
            dd = qs(i)
            ti = tl(i) + delta_t
            IF (type .EQ. 1) THEN
! Use Starr formulation
              tt = ti - zeroc
              IF (tt .LT. tstarr1) THEN
                qs(i) = tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+&
&                 s11) + s10
              ELSE IF (tt .GE. tstarr1 .AND. tt .LT. tstarr2) THEN
                w = (tstarr2-tt)/(tstarr2-tstarr1)
                qs(i) = w*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12&
&                 )+s11)+s10) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+&
&                 s24)+s23)+s22)+s21)+s20)
              ELSE IF (tt .GE. tstarr2 .AND. tt .LT. tstarr3) THEN
                qs(i) = tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+&
&                 s21) + s20
              ELSE IF (tt .GE. tstarr3 .AND. tt .LT. tstarr4) THEN
                w = (tstarr4-tt)/(tstarr4-tstarr3)
                qs(i) = w*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22&
&                 )+s21)+s20) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+&
&                 bi4)+bi3)+bi2)+bi1)+bi0)
              ELSE
                qs(i) = tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2)+&
&                 bi1) + bi0
              END IF
            ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
              tt = zeroc/ti
              arg1 = -(di(1)/tt+di(2)*LOG(tt)+di(3)*tt)
              qs(i) = di(0)*EXP(arg1)
            ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
              arg1 = ci(0) + ci(1)/ti + ci(2)*ALOG(ti) + ci(3)*ti
              qs(i) = EXP(arg1)
            END IF
            ddq = qs(i) - dd
            qs(i) = dd
          END IF
        END IF
        IF (PRESENT(pl)) THEN
          IF (pl(i) .GT. qs(i)) THEN
            dd = esfac/(pl(i)-(1.0-esfac)*qs(i))
            qs(i) = qs(i)*dd
            IF (PRESENT(dq)) dq(i) = ddq*erfac*pl(i)*dd*dd
          ELSE
            qs(i) = max_mixing_ratio
            IF (PRESENT(dq)) dq(i) = 0.0
          END IF
        ELSE IF (PRESENT(dq)) THEN
          dq(i) = ddq*(1.0/delta_t)
        END IF
      END IF
    END DO
  END FUNCTION QSATICE1
  FUNCTION QSATICE2(tl, pl, dq) RESULT (QS)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:, :)
    REAL, OPTIONAL, INTENT(IN) :: pl(:, :)
    REAL, OPTIONAL, INTENT(OUT) :: dq(:, :)
    REAL :: qs(SIZE(tl, 1), SIZE(tl, 2))
    INTEGER :: i, j
    REAL :: ti, w
    REAL :: tt
    REAL :: ddq
    REAL :: dd
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC LOG
    INTRINSIC EXP
    INTRINSIC ALOG
    REAL*8 :: arg1
    INTRINSIC SIZE
    DO j=1,SIZE(tl, 2)
      DO i=1,SIZE(tl, 1)
        IF (utbl) THEN
          IF (first) THEN
            first = .false.
            CALL ESINIT()
          END IF
          IF (tl(i, j) .LE. tmintbl) THEN
            qs(i, j) = estble(1)
            IF (PRESENT(dq)) ddq = 0.0
          ELSE IF (tl(i, j) .GE. zeroc) THEN
            qs(i, j) = estfrz
            IF (PRESENT(dq)) ddq = 0.0
          ELSE
            tt = (tl(i, j)-tmintbl)*degsubs + 1
            it = INT(tt)
            ddq = estble(it+1) - estble(it)
            qs(i, j) = (tt-it)*ddq + estble(it)
          END IF
          IF (PRESENT(pl)) THEN
            IF (pl(i, j) .GT. qs(i, j)) THEN
              dd = esfac/(pl(i, j)-(1.0-esfac)*qs(i, j))
              qs(i, j) = qs(i, j)*dd
              IF (PRESENT(dq)) dq(i, j) = ddq*erfac*pl(i, j)*dd*dd
            ELSE
              qs(i, j) = max_mixing_ratio
              IF (PRESENT(dq)) dq(i, j) = 0.0
            END IF
          ELSE IF (PRESENT(dq)) THEN
            dq(i, j) = ddq
          END IF
        ELSE
! Exact Formulation
          IF (tl(i, j) .LT. tminice) THEN
            ti = tminice
          ELSE IF (tl(i, j) .GT. zeroc) THEN
            ti = zeroc
          ELSE
            ti = tl(i, j)
          END IF
          IF (type .EQ. 1) THEN
! Use Starr formulation
            tt = ti - zeroc
            IF (tt .LT. tstarr1) THEN
              qs(i, j) = tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+&
&               s11) + s10
            ELSE IF (tt .GE. tstarr1 .AND. tt .LT. tstarr2) THEN
              w = (tstarr2-tt)/(tstarr2-tstarr1)
              qs(i, j) = w*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+&
&               s12)+s11)+s10) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)&
&               +s24)+s23)+s22)+s21)+s20)
            ELSE IF (tt .GE. tstarr2 .AND. tt .LT. tstarr3) THEN
              qs(i, j) = tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+&
&               s21) + s20
            ELSE IF (tt .GE. tstarr3 .AND. tt .LT. tstarr4) THEN
              w = (tstarr4-tt)/(tstarr4-tstarr3)
              qs(i, j) = w*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+&
&               s22)+s21)+s20) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)&
&               +bi4)+bi3)+bi2)+bi1)+bi0)
            ELSE
              qs(i, j) = tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2)+&
&               bi1) + bi0
            END IF
          ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
            tt = zeroc/ti
            arg1 = -(di(1)/tt+di(2)*LOG(tt)+di(3)*tt)
            qs(i, j) = di(0)*EXP(arg1)
          ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
            arg1 = ci(0) + ci(1)/ti + ci(2)*ALOG(ti) + ci(3)*ti
            qs(i, j) = EXP(arg1)
          END IF
          IF (PRESENT(dq)) THEN
            IF (tl(i, j) .LT. tminice) THEN
              ddq = 0.0
            ELSE IF (tl(i, j) .GT. zeroc) THEN
              ddq = 0.0
            ELSE IF (pl(i, j) .GT. qs(i, j)) THEN
              dd = qs(i, j)
              ti = tl(i, j) + delta_t
              IF (type .EQ. 1) THEN
! Use Starr formulation
                tt = ti - zeroc
                IF (tt .LT. tstarr1) THEN
                  qs(i, j) = tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+&
&                   s12)+s11) + s10
                ELSE IF (tt .GE. tstarr1 .AND. tt .LT. tstarr2) THEN
                  w = (tstarr2-tt)/(tstarr2-tstarr1)
                  qs(i, j) = w*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13&
&                   )+s12)+s11)+s10) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*&
&                   s26+s25)+s24)+s23)+s22)+s21)+s20)
                ELSE IF (tt .GE. tstarr2 .AND. tt .LT. tstarr3) THEN
                  qs(i, j) = tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+&
&                   s22)+s21) + s20
                ELSE IF (tt .GE. tstarr3 .AND. tt .LT. tstarr4) THEN
                  w = (tstarr4-tt)/(tstarr4-tstarr3)
                  qs(i, j) = w*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23&
&                   )+s22)+s21)+s20) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*&
&                   bi6+bi5)+bi4)+bi3)+bi2)+bi1)+bi0)
                ELSE
                  qs(i, j) = tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+&
&                   bi2)+bi1) + bi0
                END IF
              ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
                tt = zeroc/ti
                arg1 = -(di(1)/tt+di(2)*LOG(tt)+di(3)*tt)
                qs(i, j) = di(0)*EXP(arg1)
              ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
                arg1 = ci(0) + ci(1)/ti + ci(2)*ALOG(ti) + ci(3)*ti
                qs(i, j) = EXP(arg1)
              END IF
              ddq = qs(i, j) - dd
              qs(i, j) = dd
            END IF
          END IF
          IF (PRESENT(pl)) THEN
            IF (pl(i, j) .GT. qs(i, j)) THEN
              dd = esfac/(pl(i, j)-(1.0-esfac)*qs(i, j))
              qs(i, j) = qs(i, j)*dd
              IF (PRESENT(dq)) dq(i, j) = ddq*erfac*pl(i, j)*dd*dd
            ELSE
              qs(i, j) = max_mixing_ratio
              IF (PRESENT(dq)) dq(i, j) = 0.0
            END IF
          ELSE IF (PRESENT(dq)) THEN
            dq(i, j) = ddq*(1.0/delta_t)
          END IF
        END IF
      END DO
    END DO
  END FUNCTION QSATICE2
  FUNCTION QSATICE3(tl, pl, dq) RESULT (QS)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:, :, :)
    REAL, OPTIONAL, INTENT(IN) :: pl(:, :, :)
    REAL, OPTIONAL, INTENT(OUT) :: dq(:, :, :)
    REAL :: qs(SIZE(tl, 1), SIZE(tl, 2), SIZE(tl, 3))
    INTEGER :: i, j, k
    REAL :: ti, w
    REAL :: tt
    REAL :: ddq
    REAL :: dd
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC LOG
    INTRINSIC EXP
    INTRINSIC ALOG
    REAL*8 :: arg1
    INTRINSIC SIZE
    DO k=1,SIZE(tl, 3)
      DO j=1,SIZE(tl, 2)
        DO i=1,SIZE(tl, 1)
          IF (utbl) THEN
            IF (first) THEN
              first = .false.
              CALL ESINIT()
            END IF
            IF (tl(i, j, k) .LE. tmintbl) THEN
              qs(i, j, k) = estble(1)
              IF (PRESENT(dq)) ddq = 0.0
            ELSE IF (tl(i, j, k) .GE. zeroc) THEN
              qs(i, j, k) = estfrz
              IF (PRESENT(dq)) ddq = 0.0
            ELSE
              tt = (tl(i, j, k)-tmintbl)*degsubs + 1
              it = INT(tt)
              ddq = estble(it+1) - estble(it)
              qs(i, j, k) = (tt-it)*ddq + estble(it)
            END IF
            IF (PRESENT(pl)) THEN
              IF (pl(i, j, k) .GT. qs(i, j, k)) THEN
                dd = esfac/(pl(i, j, k)-(1.0-esfac)*qs(i, j, k))
                qs(i, j, k) = qs(i, j, k)*dd
                IF (PRESENT(dq)) dq(i, j, k) = ddq*erfac*pl(i, j, k)*dd*&
&                   dd
              ELSE
                qs(i, j, k) = max_mixing_ratio
                IF (PRESENT(dq)) dq(i, j, k) = 0.0
              END IF
            ELSE IF (PRESENT(dq)) THEN
              dq(i, j, k) = ddq
            END IF
          ELSE
! Exact Formulation
            IF (tl(i, j, k) .LT. tminice) THEN
              ti = tminice
            ELSE IF (tl(i, j, k) .GT. zeroc) THEN
              ti = zeroc
            ELSE
              ti = tl(i, j, k)
            END IF
            IF (type .EQ. 1) THEN
! Use Starr formulation
              tt = ti - zeroc
              IF (tt .LT. tstarr1) THEN
                qs(i, j, k) = tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+&
&                 s12)+s11) + s10
              ELSE IF (tt .GE. tstarr1 .AND. tt .LT. tstarr2) THEN
                w = (tstarr2-tt)/(tstarr2-tstarr1)
                qs(i, j, k) = w*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+&
&                 s13)+s12)+s11)+s10) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*&
&                 s26+s25)+s24)+s23)+s22)+s21)+s20)
              ELSE IF (tt .GE. tstarr2 .AND. tt .LT. tstarr3) THEN
                qs(i, j, k) = tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+&
&                 s22)+s21) + s20
              ELSE IF (tt .GE. tstarr3 .AND. tt .LT. tstarr4) THEN
                w = (tstarr4-tt)/(tstarr4-tstarr3)
                qs(i, j, k) = w*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+&
&                 s23)+s22)+s21)+s20) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*&
&                 bi6+bi5)+bi4)+bi3)+bi2)+bi1)+bi0)
              ELSE
                qs(i, j, k) = tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+&
&                 bi2)+bi1) + bi0
              END IF
            ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
              tt = zeroc/ti
              arg1 = -(di(1)/tt+di(2)*LOG(tt)+di(3)*tt)
              qs(i, j, k) = di(0)*EXP(arg1)
            ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
              arg1 = ci(0) + ci(1)/ti + ci(2)*ALOG(ti) + ci(3)*ti
              qs(i, j, k) = EXP(arg1)
            END IF
            IF (PRESENT(dq)) THEN
              IF (tl(i, j, k) .LT. tminice) THEN
                ddq = 0.0
              ELSE IF (tl(i, j, k) .GT. zeroc) THEN
                ddq = 0.0
              ELSE IF (pl(i, j, k) .GT. qs(i, j, k)) THEN
                dd = qs(i, j, k)
                ti = tl(i, j, k) + delta_t
                IF (type .EQ. 1) THEN
! Use Starr formulation
                  tt = ti - zeroc
                  IF (tt .LT. tstarr1) THEN
                    qs(i, j, k) = tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+&
&                     s13)+s12)+s11) + s10
                  ELSE IF (tt .GE. tstarr1 .AND. tt .LT. tstarr2) THEN
                    w = (tstarr2-tt)/(tstarr2-tstarr1)
                    qs(i, j, k) = w*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14&
&                     )+s13)+s12)+s11)+s10) + (1.-w)*(tt*(tt*(tt*(tt*(tt&
&                     *(tt*s26+s25)+s24)+s23)+s22)+s21)+s20)
                  ELSE IF (tt .GE. tstarr2 .AND. tt .LT. tstarr3) THEN
                    qs(i, j, k) = tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+&
&                     s23)+s22)+s21) + s20
                  ELSE IF (tt .GE. tstarr3 .AND. tt .LT. tstarr4) THEN
                    w = (tstarr4-tt)/(tstarr4-tstarr3)
                    qs(i, j, k) = w*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24&
&                     )+s23)+s22)+s21)+s20) + (1.-w)*(tt*(tt*(tt*(tt*(tt&
&                     *(tt*bi6+bi5)+bi4)+bi3)+bi2)+bi1)+bi0)
                  ELSE
                    qs(i, j, k) = tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+&
&                     bi3)+bi2)+bi1) + bi0
                  END IF
                ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
                  tt = zeroc/ti
                  arg1 = -(di(1)/tt+di(2)*LOG(tt)+di(3)*tt)
                  qs(i, j, k) = di(0)*EXP(arg1)
                ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
                  arg1 = ci(0) + ci(1)/ti + ci(2)*ALOG(ti) + ci(3)*ti
                  qs(i, j, k) = EXP(arg1)
                END IF
                ddq = qs(i, j, k) - dd
                qs(i, j, k) = dd
              END IF
            END IF
            IF (PRESENT(pl)) THEN
              IF (pl(i, j, k) .GT. qs(i, j, k)) THEN
                dd = esfac/(pl(i, j, k)-(1.0-esfac)*qs(i, j, k))
                qs(i, j, k) = qs(i, j, k)*dd
                IF (PRESENT(dq)) dq(i, j, k) = ddq*erfac*pl(i, j, k)*dd*&
&                   dd
              ELSE
                qs(i, j, k) = max_mixing_ratio
                IF (PRESENT(dq)) dq(i, j, k) = 0.0
              END IF
            ELSE IF (PRESENT(dq)) THEN
              dq(i, j, k) = ddq*(1.0/delta_t)
            END IF
          END IF
        END DO
      END DO
    END DO
  END FUNCTION QSATICE3
  FUNCTION QSAT1(tl, pl, ramp, pascals, dqsat) RESULT (QSAT)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:), pl(:)
    LOGICAL, OPTIONAL, INTENT(IN) :: pascals
    REAL, OPTIONAL, INTENT(IN) :: ramp
    REAL, OPTIONAL, INTENT(OUT) :: dqsat(:)
    REAL :: qsat(SIZE(tl, 1))
    INTEGER :: i
    INTRINSIC PRESENT
    INTRINSIC SIZE
    DO i=1,SIZE(tl, 1)
      IF (PRESENT(dqsat)) THEN
        qsat(i) = QSAT0(tl(i), pl(i), ramp, pascals, dqsat(i))
      ELSE
        qsat(i) = QSAT0(tl(i), pl(i), ramp, pascals)
      END IF
    END DO
  END FUNCTION QSAT1
  FUNCTION QSAT2(tl, pl, ramp, pascals, dqsat) RESULT (QSAT)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:, :), pl(:, :)
    LOGICAL, OPTIONAL, INTENT(IN) :: pascals
    REAL, OPTIONAL, INTENT(IN) :: ramp
    REAL, OPTIONAL, INTENT(OUT) :: dqsat(:, :)
    REAL :: qsat(SIZE(tl, 1), SIZE(tl, 2))
    INTEGER :: i, j
    INTRINSIC PRESENT
    INTRINSIC SIZE
    DO j=1,SIZE(tl, 2)
      DO i=1,SIZE(tl, 1)
        IF (PRESENT(dqsat)) THEN
          qsat(i, j) = QSAT0(tl(i, j), pl(i, j), ramp, pascals, dqsat(i&
&           , j))
        ELSE
          qsat(i, j) = QSAT0(tl(i, j), pl(i, j), ramp, pascals)
        END IF
      END DO
    END DO
  END FUNCTION QSAT2
  FUNCTION QSAT3(tl, pl, ramp, pascals, dqsat) RESULT (QSAT)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:, :, :), pl(:, :, :)
    LOGICAL, OPTIONAL, INTENT(IN) :: pascals
    REAL, OPTIONAL, INTENT(IN) :: ramp
    REAL, OPTIONAL, INTENT(OUT) :: dqsat(:, :, :)
    REAL :: qsat(SIZE(tl, 1), SIZE(tl, 2), SIZE(tl, 3))
    INTEGER :: i, j, k
    INTRINSIC PRESENT
    INTRINSIC SIZE
    DO k=1,SIZE(tl, 3)
      DO j=1,SIZE(tl, 2)
        DO i=1,SIZE(tl, 1)
          IF (PRESENT(dqsat)) THEN
            qsat(i, j, k) = QSAT0(tl(i, j, k), pl(i, j, k), ramp, &
&             pascals, dqsat(i, j, k))
          ELSE
            qsat(i, j, k) = QSAT0(tl(i, j, k), pl(i, j, k), ramp, &
&             pascals)
          END IF
        END DO
      END DO
    END DO
  END FUNCTION QSAT3
!==============================================
!==============================================
!  Traditional Qsat and Dqsat (these are deprecated)
!==============================================
!==============================================
!BOPI
! !IROUTINE: GEOS_Qsat -- Computes satuation specific humidity.
! !INTERFACE:
!    function GEOS_Qsat(TL,PL,RAMP,PASCALS,DQSAT) result(QSAT)
!
! Overloads:
!
!      real,                      intent(IN)                        :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real,                     optional, intent(OUT)              :: DQSAT
!      real                                                         :: QSAT
!
!      real, dimension(:),        intent(IN)                        :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real,                     optional, intent(OUT)              :: DQSAT(:)
!      real, dimension(size(PL,1))                                  :: QSAT
!
!      real, dimension(:,:),      intent(IN)                        :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real,                     optional, intent(OUT)              :: DQSAT(:,:)
!      real, dimension(size(PL,1),size(PL,2))                       :: QSAT
!
!      real, dimension(:,:,:),    intent(IN)                        :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real,                     optional, intent(OUT)              :: DQSAT(:,:,:)
!      real, dimension(size(PL,1),size(PL,2),size(PL,3))            :: QSAT
!
! !DESCRIPTION:  Uses various formulations of the saturation
!                vapor pressure to compute the saturation specific
!    humidity for temperature TL and pressure PL.
!
!    For temperatures <= TMIX (-20C)
!    the calculation is done over ice; for temperatures >= ZEROC (0C) the calculation
!    is done over liquid water; and in between these values,
!    it interpolates linearly between the two.
!
!    The optional RAMP is the width of this
!    ice/water ramp (i.e., TMIX = ZEROC-RAMP); its default is 20.
!
!    If PASCALS is true, PL is
!    assumed to be in Pa; if false or not present, it is assumed to be in mb.
!
!    The choice of saturation vapor pressure formulation is a compile-time
!    option. Three choices are currently supported: The CAM formulation,
!    Murphy and Koop (2005, QJRMS), and Staars formulation from NSIPP-1.
!
!    Another compile time choice is whether to use the exact formulation
!    or a table look-up.
!    If UTBL is true, tabled values of the saturation vapor pressures
!    are used. These tables are automatically generated at a 0.1K resolution
!    for whatever vapor pressure formulation is being used.
!
!
!EOPI
  FUNCTION QSAT0(tl, pl, ramp, pascals, dqsat) RESULT (QSAT)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl, pl
    LOGICAL, OPTIONAL, INTENT(IN) :: pascals
    REAL, OPTIONAL, INTENT(IN) :: ramp
    REAL, OPTIONAL, INTENT(OUT) :: dqsat
    REAL :: qsat
    REAL :: uramp, dd, qq, ti, dq, pp
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC ABS
    INTRINSIC INT
    REAL :: abs0
    IF (PRESENT(ramp)) THEN
      IF (ramp .GE. 0.) THEN
        abs0 = ramp
      ELSE
        abs0 = -ramp
      END IF
      uramp = -abs0
    ELSE
      uramp = tmix
    END IF
    IF (PRESENT(pascals)) THEN
      IF (pascals) THEN
        pp = pl
      ELSE
        pp = pl*100.
      END IF
    ELSE
      pp = pl*100.
    END IF
    IF (uramp .EQ. tmix .OR. (uramp .EQ. 0. .AND. utbl)) THEN
      IF (first) THEN
        first = .false.
        CALL ESINIT()
      END IF
      IF (tl .LE. tmintbl) THEN
        ti = tmintbl
      ELSE IF (tl .GE. tmaxtbl - .001) THEN
        ti = tmaxtbl - .001
      ELSE
        ti = tl
      END IF
      ti = (ti-tmintbl)*degsubs + 1
      it = INT(ti)
      IF (uramp .EQ. tmix) THEN
        dq = estblx(it+1) - estblx(it)
        qsat = (ti-it)*dq + estblx(it)
      ELSE
        dq = estble(it+1) - estble(it)
        qsat = (ti-it)*dq + estble(it)
      END IF
      IF (PRESENT(dqsat)) dqsat = dq*degsubs
      IF (pp .LE. qsat) THEN
        qsat = max_mixing_ratio
        IF (PRESENT(dqsat)) dqsat = 0.0
      ELSE
        dd = 1.0/(pp-(1.0-esfac)*qsat)
        qsat = esfac*qsat*dd
        IF (PRESENT(dqsat)) dqsat = esfac*dqsat*pp*(dd*dd)
      END IF
    ELSE
      ti = tl - zeroc
      IF (ti .LE. uramp) THEN
        qsat = QSATICE0(tl, pp, dqsat)
      ELSE IF (ti .GE. 0.0) THEN
        qsat = QSATLQU0(tl, pp, dqsat)
      ELSE
        qsat = QSATICE0(tl, pp, dqsat)
        qq = QSATLQU0(tl, pp, dq)
        ti = ti/uramp
        qsat = ti*(qsat-qq) + qq
        IF (PRESENT(dqsat)) dqsat = ti*(dqsat-dq) + dq
      END IF
    END IF
  END FUNCTION QSAT0
!  Differentiation of dqsat0 in forward (tangent) mode (with options r8):
!   variations   of useful results: qsat dqsat
!   with respect to varying inputs: tl qsat
!=======================================================================================
!BOPI
! !IROUTINE: GEOS_DQsat -- Computes derivative satuation specific humidity wrt temperature.
! !INTERFACE:
!    function GEOS_DQsat(TL,PL,RAMP,PASCALS,QSAT) result(DQSAT)
!
! Overloads:
!
!      real,                               intent(IN)               :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real,                     optional, intent(OUT)              :: QSAT
!      real                                                         :: DQSAT
!
!      real, dimension(:),                 intent(IN)               :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real, dimension(:),       optional, intent(OUT)              :: QSAT
!      real, dimension(size(PL,1))                                  :: DQSAT
!
!      real, dimension(:,:),               intent(IN)               :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real, dimension(:,:),     optional, intent(OUT)              :: QSAT
!      real, dimension(size(PL,1),size(PL,2))                       :: DQSAT
!
!      real, dimension(:,:,:),             intent(IN)               :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real, dimension(:,:,:),   optional, intent(OUT)              :: QSAT
!      real, dimension(size(PL,1),size(PL,2),size(PL,3))            :: DQSAT
!
!      real, dimension(:,:,:,:),           intent(IN)               :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real, dimension(:,:,:,:), optional, intent(OUT)              :: QSAT
!      real, dimension(size(PL,1),size(PL,2),size(PL,3),size(PL,4)) :: DQSAT
! !DESCRIPTION:  Differentiates the approximations used
!                by GEOS_Qsat with respect to temperature,
!    using the same scheme to handle ice. Arguments are as in
!    GEOS_Qsat, with the addition of QSAT, which is the saturation specific
!    humidity. This is for economy, in case both qsat and dqsat are
!    required.
!
!EOPI
  FUNCTION DQSAT0_TLM(tl, tl_tl, pl, ramp, pascals, qsat, qsat_tl, dqsat&
& ) RESULT (DQSAT_TL)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl, pl
    REAL, INTENT(IN) :: tl_tl
    LOGICAL, OPTIONAL, INTENT(IN) :: pascals
    REAL, OPTIONAL, INTENT(IN) :: ramp
    REAL, OPTIONAL, INTENT(OUT) :: qsat
    REAL, OPTIONAL, INTENT(OUT) :: qsat_tl
    REAL :: dqsat
    REAL :: dqsat_tl
    REAL :: uramp, tt, ww, dd, dqq, qq, ti, dqi, qi, pp
    REAL :: tt_tl, dd_tl, dqq_tl, qq_tl, ti_tl, dqi_tl, qi_tl
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC ABS
    INTRINSIC INT
    REAL :: abs0
    IF (PRESENT(ramp)) THEN
      IF (ramp .GE. 0.) THEN
        abs0 = ramp
      ELSE
        abs0 = -ramp
      END IF
      uramp = -abs0
    ELSE
      uramp = tmix
    END IF
    IF (PRESENT(pascals)) THEN
      IF (pascals) THEN
        pp = pl
      ELSE
        pp = pl*100.
      END IF
    ELSE
      pp = pl*100.
    END IF
    IF (uramp .EQ. tmix .OR. (uramp .EQ. 0. .AND. utbl)) THEN
      IF (first) THEN
        first = .false.
        CALL ESINIT()
      END IF
      IF (tl .LE. tmintbl) THEN
        ti = tmintbl
        ti_tl = 0.0_8
      ELSE IF (tl .GE. tmaxtbl - .001) THEN
        ti = tmaxtbl - .001
        ti_tl = 0.0_8
      ELSE
        ti_tl = tl_tl
        ti = tl
      END IF
      tt_tl = degsubs*ti_tl
      tt = (ti-tmintbl)*degsubs + 1
      it = INT(tt)
      IF (uramp .EQ. tmix) THEN
        dqq = estblx(it+1) - estblx(it)
        qq_tl = dqq*tt_tl
        qq = (tt-it)*dqq + estblx(it)
      ELSE
        dqq = estble(it+1) - estble(it)
        qq_tl = dqq*tt_tl
        qq = (tt-it)*dqq + estble(it)
      END IF
      IF (pp .LE. qq) THEN
        IF (PRESENT(qsat)) THEN
          qsat = max_mixing_ratio
          qsat_tl = 0.0_8
        END IF
        dqsat = 0.0
        dqsat_tl = 0.0_8
      ELSE
        dd_tl = -((-((1.0-esfac)*qq_tl))/(pp-(1.0-esfac)*qq)**2)
        dd = 1.0/(pp-(1.0-esfac)*qq)
        IF (PRESENT(qsat)) THEN
          qsat_tl = esfac*(qq_tl*dd+qq*dd_tl)
          qsat = esfac*qq*dd
        END IF
        dqsat_tl = esfac*degsubs*dqq*pp*(dd_tl*dd+dd*dd_tl)
        dqsat = esfac*degsubs*dqq*pp*(dd*dd)
      END IF
    ELSE
      ti_tl = tl_tl
      ti = tl - zeroc
      IF (ti .LE. uramp) THEN
        qq_tl = QSATICE0_TLM(tl, tl_tl, pp, dq=dqsat, dq_tl=dqsat_tl, qs&
&         =qq)
        IF (PRESENT(qsat)) THEN
          qsat_tl = qq_tl
          qsat = qq
        END IF
      ELSE IF (ti .GE. 0.0) THEN
        qq_tl = QSATLQU0_TLM(tl, tl_tl, pp, dq=dqsat, dq_tl=dqsat_tl, qs&
&         =qq)
        IF (PRESENT(qsat)) THEN
          qsat_tl = qq_tl
          qsat = qq
        END IF
      ELSE
        qq_tl = QSATLQU0_TLM(tl, tl_tl, pp, dq=dqq, dq_tl=dqq_tl, qs=qq)
        qi_tl = QSATICE0_TLM(tl, tl_tl, pp, dq=dqi, dq_tl=dqi_tl, qs=qi)
        ti_tl = ti_tl/uramp
        ti = ti/uramp
        dqsat_tl = ti_tl*(dqi-dqq) + ti*(dqi_tl-dqq_tl) + dqq_tl
        dqsat = ti*(dqi-dqq) + dqq
        IF (PRESENT(qsat)) THEN
          qsat_tl = ti_tl*(qi-qq) + ti*(qi_tl-qq_tl) + qq_tl
          qsat = ti*(qi-qq) + qq
        END IF
      END IF
    END IF
  END FUNCTION DQSAT0_TLM
!  Differentiation of qsatlqu0 in forward (tangent) mode (with options r8):
!   variations   of useful results: dq qs
!   with respect to varying inputs: tl
!BOPI
! !IROUTINE: GEOS_QsatLqu Computes saturation specific humidity over
!            liquid water.
! !IROUTINE: GEOS_QsatIce Computes saturation specific humidity over
!            frozen water.
! !INTERFACE:
!    function GEOS_QsatLqu(TL,PL,DQ) result(QS)
!    function GEOS_QsatIce(TL,PL,DQ) result(QS)
!
! Overloads:
!
!      real,                               intent(IN)               :: TL
!      logical,                  optional, intent(IN)               :: PL
!      real,                     optional, intent(OUT)              :: DQ
!      real                                                         :: QS
!
!      real,                               intent(IN)               :: TL(:)
!      logical,                  optional, intent(IN)               :: PL(:)
!      real,                     optional, intent(OUT)              :: DQ(:)
!      real, dimension(size(TL,1))                                  :: QS
!
!      real,                               intent(IN)               :: TL(:,:)
!      logical,                  optional, intent(IN)               :: PL(:,:)
!      real,                     optional, intent(OUT)              :: DQ(:,:)
!      real, dimension(size(TL,1),size(TL,2))                       :: QS
!
!      real,                               intent(IN)               :: TL(:,:,:)
!      logical,                  optional, intent(IN)               :: PL(:,:,:)
!      real,                     optional, intent(OUT)              :: DQ(:,:,:)
!      real, dimension(size(TL,1),size(TL,2),size(TL,3))            :: QS
!
!
! !DESCRIPTION:  Uses various formulations of the saturation
!                vapor pressure to compute the saturation specific
!    humidity and, optionally, its derivative with respect to temperature
!    for temperature TL and pressure PL. If PL is not present
!    it returns the saturation vapor pressure and, optionally, its derivative.
!
!    All pressures are in Pascals and all temperatures in Kelvins.
!
!    The choice of saturation vapor pressure formulation is controlled by  GEOS_QsatSet.
!    Three choices are currently supported: The CAM formulation,
!    Murphy and Koop (2005, QJRMS), and the Staar formulation from NSIPP-1.
!    The default is Starr. All three are valid up to 333K. Above the
!    freezing point, GEOS_QsatIce returns values at the freezing point.
!    Murphy and Koop is valid down to 150K, for both liquid and ice.
!    The other two are valid down to 178K for ice and 233K for super-cooled liquid.
!
!    Another choice is whether to use the exact formulation
!    or a table look-up. This can also be controlled with GEOS_QsatSet.
!    The default is to do a table look-up. The tables are generated
!    at 0.1C intervals, controlled by parameter DEGSUBS=10.
!
!
!EOPI
  FUNCTION QSATLQU0_TLM(tl, tl_tl, pl, dq, dq_tl, qs) RESULT (QS_TL)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl
    REAL, INTENT(IN) :: tl_tl
    REAL, OPTIONAL, INTENT(IN) :: pl
    REAL, OPTIONAL, INTENT(OUT) :: dq
    REAL, OPTIONAL, INTENT(OUT) :: dq_tl
    REAL :: qs
    REAL :: qs_tl
    REAL :: ti, w
    REAL :: ti_tl
    REAL :: dd
    REAL :: dd_tl
    REAL :: tt
    REAL :: tt_tl
    REAL :: ddq
    REAL :: ddq_tl
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC LOG10
    INTRINSIC ALOG
    INTRINSIC TANH
    INTRINSIC EXP
    REAL*8 :: pwy1
    REAL*8 :: pwy1_tl
    REAL*8 :: pwr1
    REAL*8 :: pwr1_tl
    REAL*8 :: pwy2
    REAL*8 :: pwy2_tl
    REAL*8 :: pwr2
    REAL*8 :: pwr2_tl
    REAL*8 :: pwy3
    REAL*8 :: pwy3_tl
    REAL*8 :: arg1
    REAL*8 :: arg1_tl
    REAL*8 :: arg2
    REAL*8 :: arg2_tl
! not table
    IF (utbl) THEN
      IF (first) THEN
        first = .false.
        CALL ESINIT()
      END IF
      IF (tl .LE. tminlqu) THEN
        qs = estlqu
        IF (PRESENT(dq)) THEN
          ddq = 0.0
          qs_tl = 0.0_8
        ELSE
          qs_tl = 0.0_8
        END IF
      ELSE IF (tl .GE. tmaxtbl) THEN
        qs = estblw(tablesize)
        IF (PRESENT(dq)) THEN
          ddq = 0.0
          qs_tl = 0.0_8
        ELSE
          qs_tl = 0.0_8
        END IF
      ELSE
        tt_tl = degsubs*tl_tl
        tt = (tl-tmintbl)*degsubs + 1
        it = INT(tt)
        ddq = estblw(it+1) - estblw(it)
        qs_tl = ddq*tt_tl
        qs = (tt-it)*ddq + estblw(it)
      END IF
      IF (PRESENT(pl)) THEN
        IF (pl .GT. qs) THEN
          dd_tl = -((-(esfac*(1.0-esfac)*qs_tl))/(pl-(1.0-esfac)*qs)**2)
          dd = esfac/(pl-(1.0-esfac)*qs)
          qs_tl = qs_tl*dd + qs*dd_tl
          qs = qs*dd
          IF (PRESENT(dq)) THEN
            dq_tl = ddq*erfac*pl*(dd_tl*dd+dd*dd_tl)
            dq = ddq*erfac*pl*dd*dd
          ELSE
            dq_tl = 0.0_8
          END IF
        ELSE
          qs = max_mixing_ratio
          IF (PRESENT(dq)) THEN
            dq = 0.0
            dq_tl = 0.0_8
            qs_tl = 0.0_8
          ELSE
            dq_tl = 0.0_8
            qs_tl = 0.0_8
          END IF
        END IF
      ELSE IF (PRESENT(dq)) THEN
        dq = ddq
        dq_tl = 0.0_8
      ELSE
        dq_tl = 0.0_8
      END IF
    ELSE
! Exact Formulation
      IF (tl .LT. tminlqu) THEN
        ti = tminlqu
        ti_tl = 0.0_8
      ELSE IF (tl .GT. tmaxtbl) THEN
        ti = tmaxtbl
        ti_tl = 0.0_8
      ELSE
        ti_tl = tl_tl
        ti = tl
      END IF
      IF (type .EQ. 1) THEN
!  Starr polynomial fit
        tt_tl = ti_tl
        tt = ti - zeroc
        qs_tl = tt_tl*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+b1) + tt*(&
&         tt_tl*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+tt*(tt_tl*(tt*(tt*(tt&
&         *b6+b5)+b4)+b3)+tt*(tt_tl*(tt*(tt*b6+b5)+b4)+tt*(tt_tl*(tt*b6+&
&         b5)+tt*b6*tt_tl))))
        qs = tt*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+b1) + b0
      ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
        tt_tl = -(ts*ti_tl/ti**2)
        tt = ts/ti
        pwy1_tl = dl(4)*tt_tl/tt**2
        pwy1 = dl(4)*(1.0-1.0/tt)
        pwr1_tl = 10.0**pwy1*LOG(10.0)*pwy1_tl
        pwr1 = 10.0**pwy1
        pwy2_tl = dl(6)*tt_tl
        pwy2 = dl(6)*(tt-1.0)
        pwr2_tl = 10.0**pwy2*LOG(10.0)*pwy2_tl
        pwr2 = 10.0**pwy2
        pwy3_tl = dl(1)*tt_tl + dl(2)*tt_tl/(tt*LOG(10.0)) + dl(3)*&
&         pwr1_tl/10000000.0 + dl(5)*pwr2_tl/1000.0
        pwy3 = dl(1)*(tt-1.0) + dl(2)*LOG10(tt) + dl(3)*(pwr1-1.0)/&
&         10000000.0 + dl(5)*(pwr2-1.0)/1000.0 + logps + 2.0
        qs_tl = 10.0**pwy3*LOG(10.0)*pwy3_tl
        qs = 10.0**pwy3
      ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
        arg1_tl = cl(4)*ti_tl
        arg1 = cl(4)*(ti-cl(5))
        arg2_tl = cl(2)*ti_tl/ti - cl(1)*ti_tl/ti**2 + cl(3)*ti_tl + &
&         arg1_tl*(1.0-TANH(arg1)**2)*(cl(6)+cl(7)/ti+cl(8)*ALOG(ti)+cl(&
&         9)*ti) + TANH(arg1)*(cl(8)*ti_tl/ti-cl(7)*ti_tl/ti**2+cl(9)*&
&         ti_tl)
        arg2 = cl(0) + cl(1)/ti + cl(2)*ALOG(ti) + cl(3)*ti + TANH(arg1)&
&         *(cl(6)+cl(7)/ti+cl(8)*ALOG(ti)+cl(9)*ti)
        qs_tl = arg2_tl*EXP(arg2)
        qs = EXP(arg2)
      ELSE
        qs_tl = 0.0_8
      END IF
      IF (PRESENT(dq)) THEN
        IF (tl .LT. tminlqu) THEN
          ddq = 0.0
          ddq_tl = 0.0_8
        ELSE IF (tl .GT. tmaxtbl) THEN
          ddq = 0.0
          ddq_tl = 0.0_8
        ELSE IF (pl .GT. qs) THEN
          dd_tl = qs_tl
          dd = qs
          ti_tl = tl_tl
          ti = tl + delta_t
          IF (type .EQ. 1) THEN
!  Starr polynomial fit
            tt_tl = ti_tl
            tt = ti - zeroc
            qs_tl = tt_tl*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+b1) + &
&             tt*(tt_tl*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+tt*(tt_tl*(tt&
&             *(tt*(tt*b6+b5)+b4)+b3)+tt*(tt_tl*(tt*(tt*b6+b5)+b4)+tt*(&
&             tt_tl*(tt*b6+b5)+tt*b6*tt_tl))))
            qs = tt*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+b1) + b0
          ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
            tt_tl = -(ts*ti_tl/ti**2)
            tt = ts/ti
            pwy1_tl = dl(4)*tt_tl/tt**2
            pwy1 = dl(4)*(1.0-1.0/tt)
            pwr1_tl = 10.0**pwy1*LOG(10.0)*pwy1_tl
            pwr1 = 10.0**pwy1
            pwy2_tl = dl(6)*tt_tl
            pwy2 = dl(6)*(tt-1.0)
            pwr2_tl = 10.0**pwy2*LOG(10.0)*pwy2_tl
            pwr2 = 10.0**pwy2
            pwy3_tl = dl(1)*tt_tl + dl(2)*tt_tl/(tt*LOG(10.0)) + dl(3)*&
&             pwr1_tl/10000000.0 + dl(5)*pwr2_tl/1000.0
            pwy3 = dl(1)*(tt-1.0) + dl(2)*LOG10(tt) + dl(3)*(pwr1-1.0)/&
&             10000000.0 + dl(5)*(pwr2-1.0)/1000.0 + logps + 2.0
            qs_tl = 10.0**pwy3*LOG(10.0)*pwy3_tl
            qs = 10.0**pwy3
          ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
            arg1_tl = cl(4)*ti_tl
            arg1 = cl(4)*(ti-cl(5))
            arg2_tl = cl(2)*ti_tl/ti - cl(1)*ti_tl/ti**2 + cl(3)*ti_tl +&
&             arg1_tl*(1.0-TANH(arg1)**2)*(cl(6)+cl(7)/ti+cl(8)*ALOG(ti)&
&             +cl(9)*ti) + TANH(arg1)*(cl(8)*ti_tl/ti-cl(7)*ti_tl/ti**2+&
&             cl(9)*ti_tl)
            arg2 = cl(0) + cl(1)/ti + cl(2)*ALOG(ti) + cl(3)*ti + TANH(&
&             arg1)*(cl(6)+cl(7)/ti+cl(8)*ALOG(ti)+cl(9)*ti)
            qs_tl = arg2_tl*EXP(arg2)
            qs = EXP(arg2)
          END IF
          ddq_tl = qs_tl - dd_tl
          ddq = qs - dd
          qs_tl = dd_tl
          qs = dd
        ELSE
          ddq_tl = 0.0_8
        END IF
      ELSE
        ddq_tl = 0.0_8
      END IF
      IF (PRESENT(pl)) THEN
        IF (pl .GT. qs) THEN
          dd_tl = -((-(esfac*(1.0-esfac)*qs_tl))/(pl-(1.0-esfac)*qs)**2)
          dd = esfac/(pl-(1.0-esfac)*qs)
          qs_tl = qs_tl*dd + qs*dd_tl
          qs = qs*dd
          IF (PRESENT(dq)) THEN
            dq_tl = erfac*pl*((ddq_tl*dd+ddq*dd_tl)*dd+ddq*dd*dd_tl)
            dq = ddq*erfac*pl*dd*dd
          ELSE
            dq_tl = 0.0_8
          END IF
        ELSE
          qs = max_mixing_ratio
          IF (PRESENT(dq)) THEN
            dq = 0.0
            dq_tl = 0.0_8
            qs_tl = 0.0_8
          ELSE
            dq_tl = 0.0_8
            qs_tl = 0.0_8
          END IF
        END IF
      ELSE IF (PRESENT(dq)) THEN
        dq_tl = ddq_tl/delta_t
        dq = ddq*(1.0/delta_t)
      ELSE
        dq_tl = 0.0_8
      END IF
    END IF
    RETURN
  END FUNCTION QSATLQU0_TLM
!  Differentiation of qsatice0 in forward (tangent) mode (with options r8):
!   variations   of useful results: dq qs
!   with respect to varying inputs: tl
  FUNCTION QSATICE0_TLM(tl, tl_tl, pl, dq, dq_tl, qs) RESULT (QS_TL)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl
    REAL, INTENT(IN) :: tl_tl
    REAL, OPTIONAL, INTENT(IN) :: pl
    REAL, OPTIONAL, INTENT(OUT) :: dq
    REAL, OPTIONAL, INTENT(OUT) :: dq_tl
    REAL :: qs
    REAL :: qs_tl
    REAL :: ti, w
    REAL :: ti_tl, w_tl
    REAL :: dd
    REAL :: dd_tl
    REAL :: tt
    REAL :: tt_tl
    REAL :: ddq
    REAL :: ddq_tl
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC LOG
    INTRINSIC EXP
    INTRINSIC ALOG
    REAL*8 :: arg1
    REAL*8 :: arg1_tl
    IF (utbl) THEN
      IF (first) THEN
        first = .false.
        CALL ESINIT()
      END IF
      IF (tl .LE. tmintbl) THEN
        qs = estble(1)
        IF (PRESENT(dq)) THEN
          ddq = 0.0
          qs_tl = 0.0_8
        ELSE
          qs_tl = 0.0_8
        END IF
      ELSE IF (tl .GE. zeroc) THEN
        qs = estfrz
        IF (PRESENT(dq)) THEN
          ddq = 0.0
          qs_tl = 0.0_8
        ELSE
          qs_tl = 0.0_8
        END IF
      ELSE
        tt_tl = degsubs*tl_tl
        tt = (tl-tmintbl)*degsubs + 1
        it = INT(tt)
        ddq = estble(it+1) - estble(it)
        qs_tl = ddq*tt_tl
        qs = (tt-it)*ddq + estble(it)
      END IF
      IF (PRESENT(pl)) THEN
        IF (pl .GT. qs) THEN
          dd_tl = -((-(esfac*(1.0-esfac)*qs_tl))/(pl-(1.0-esfac)*qs)**2)
          dd = esfac/(pl-(1.0-esfac)*qs)
          qs_tl = qs_tl*dd + qs*dd_tl
          qs = qs*dd
          IF (PRESENT(dq)) THEN
            dq_tl = ddq*erfac*pl*(dd_tl*dd+dd*dd_tl)
            dq = ddq*erfac*pl*dd*dd
          ELSE
            dq_tl = 0.0_8
          END IF
        ELSE
          qs = max_mixing_ratio
          IF (PRESENT(dq)) THEN
            dq = 0.0
            dq_tl = 0.0_8
            qs_tl = 0.0_8
          ELSE
            dq_tl = 0.0_8
            qs_tl = 0.0_8
          END IF
        END IF
      ELSE IF (PRESENT(dq)) THEN
        dq = ddq
        dq_tl = 0.0_8
      ELSE
        dq_tl = 0.0_8
      END IF
    ELSE
! Exact Formulation
      IF (tl .LT. tminice) THEN
        ti = tminice
        ti_tl = 0.0_8
      ELSE IF (tl .GT. zeroc) THEN
        ti = zeroc
        ti_tl = 0.0_8
      ELSE
        ti_tl = tl_tl
        ti = tl
      END IF
      IF (type .EQ. 1) THEN
! Use Starr formulation
        tt_tl = ti_tl
        tt = ti - zeroc
        IF (tt .LT. tstarr1) THEN
          qs_tl = tt_tl*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+s11)&
&           + tt*(tt_tl*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+tt*(&
&           tt_tl*(tt*(tt*(tt*s16+s15)+s14)+s13)+tt*(tt_tl*(tt*(tt*s16+&
&           s15)+s14)+tt*(tt_tl*(tt*s16+s15)+tt*s16*tt_tl))))
          qs = tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+s11) + s10
        ELSE IF (tt .GE. tstarr1 .AND. tt .LT. tstarr2) THEN
          w_tl = (-tt_tl)/(tstarr2-tstarr1)
          w = (tstarr2-tt)/(tstarr2-tstarr1)
          qs_tl = w_tl*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+&
&           s11)+s10) + w*(tt_tl*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+&
&           s12)+s11)+tt*(tt_tl*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+&
&           tt*(tt_tl*(tt*(tt*(tt*s16+s15)+s14)+s13)+tt*(tt_tl*(tt*(tt*&
&           s16+s15)+s14)+tt*(tt_tl*(tt*s16+s15)+tt*s16*tt_tl))))) + (1.&
&           -w)*(tt_tl*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+s21)+&
&           tt*(tt_tl*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+tt*(tt_tl*&
&           (tt*(tt*(tt*s26+s25)+s24)+s23)+tt*(tt_tl*(tt*(tt*s26+s25)+&
&           s24)+tt*(tt_tl*(tt*s26+s25)+tt*s26*tt_tl))))) - w_tl*(tt*(tt&
&           *(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+s21)+s20)
          qs = w*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+s11)+&
&           s10) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22&
&           )+s21)+s20)
        ELSE IF (tt .GE. tstarr2 .AND. tt .LT. tstarr3) THEN
          qs_tl = tt_tl*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+s21)&
&           + tt*(tt_tl*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+tt*(&
&           tt_tl*(tt*(tt*(tt*s26+s25)+s24)+s23)+tt*(tt_tl*(tt*(tt*s26+&
&           s25)+s24)+tt*(tt_tl*(tt*s26+s25)+tt*s26*tt_tl))))
          qs = tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+s21) + s20
        ELSE IF (tt .GE. tstarr3 .AND. tt .LT. tstarr4) THEN
          w_tl = (-tt_tl)/(tstarr4-tstarr3)
          w = (tstarr4-tt)/(tstarr4-tstarr3)
          qs_tl = w_tl*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+&
&           s21)+s20) + w*(tt_tl*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+&
&           s22)+s21)+tt*(tt_tl*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+&
&           tt*(tt_tl*(tt*(tt*(tt*s26+s25)+s24)+s23)+tt*(tt_tl*(tt*(tt*&
&           s26+s25)+s24)+tt*(tt_tl*(tt*s26+s25)+tt*s26*tt_tl))))) + (1.&
&           -w)*(tt_tl*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2)+bi1)+&
&           tt*(tt_tl*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2)+tt*(tt_tl*&
&           (tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+tt*(tt_tl*(tt*(tt*bi6+bi5)+&
&           bi4)+tt*(tt_tl*(tt*bi6+bi5)+tt*bi6*tt_tl))))) - w_tl*(tt*(tt&
&           *(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2)+bi1)+bi0)
          qs = w*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+s21)+&
&           s20) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2&
&           )+bi1)+bi0)
        ELSE
          qs_tl = tt_tl*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2)+bi1)&
&           + tt*(tt_tl*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2)+tt*(&
&           tt_tl*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+tt*(tt_tl*(tt*(tt*bi6+&
&           bi5)+bi4)+tt*(tt_tl*(tt*bi6+bi5)+tt*bi6*tt_tl))))
          qs = tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2)+bi1) + bi0
        END IF
      ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
        tt_tl = -(zeroc*ti_tl/ti**2)
        tt = zeroc/ti
        arg1_tl = -(di(2)*tt_tl/tt-di(1)*tt_tl/tt**2+di(3)*tt_tl)
        arg1 = -(di(1)/tt+di(2)*LOG(tt)+di(3)*tt)
        qs_tl = di(0)*arg1_tl*EXP(arg1)
        qs = di(0)*EXP(arg1)
      ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
        arg1_tl = ci(2)*ti_tl/ti - ci(1)*ti_tl/ti**2 + ci(3)*ti_tl
        arg1 = ci(0) + ci(1)/ti + ci(2)*ALOG(ti) + ci(3)*ti
        qs_tl = arg1_tl*EXP(arg1)
        qs = EXP(arg1)
      ELSE
        qs_tl = 0.0_8
      END IF
      IF (PRESENT(dq)) THEN
        IF (tl .LT. tminice) THEN
          ddq = 0.0
          ddq_tl = 0.0_8
        ELSE IF (tl .GT. zeroc) THEN
          ddq = 0.0
          ddq_tl = 0.0_8
        ELSE IF (pl .GT. qs) THEN
          dd_tl = qs_tl
          dd = qs
          ti_tl = tl_tl
          ti = tl + delta_t
          IF (type .EQ. 1) THEN
! Use Starr formulation
            tt_tl = ti_tl
            tt = ti - zeroc
            IF (tt .LT. tstarr1) THEN
              qs_tl = tt_tl*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+&
&               s11) + tt*(tt_tl*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)&
&               +tt*(tt_tl*(tt*(tt*(tt*s16+s15)+s14)+s13)+tt*(tt_tl*(tt*&
&               (tt*s16+s15)+s14)+tt*(tt_tl*(tt*s16+s15)+tt*s16*tt_tl)))&
&               )
              qs = tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+s11) +&
&               s10
            ELSE IF (tt .GE. tstarr1 .AND. tt .LT. tstarr2) THEN
              w_tl = (-tt_tl)/(tstarr2-tstarr1)
              w = (tstarr2-tt)/(tstarr2-tstarr1)
              qs_tl = w_tl*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+&
&               s12)+s11)+s10) + w*(tt_tl*(tt*(tt*(tt*(tt*(tt*s16+s15)+&
&               s14)+s13)+s12)+s11)+tt*(tt_tl*(tt*(tt*(tt*(tt*s16+s15)+&
&               s14)+s13)+s12)+tt*(tt_tl*(tt*(tt*(tt*s16+s15)+s14)+s13)+&
&               tt*(tt_tl*(tt*(tt*s16+s15)+s14)+tt*(tt_tl*(tt*s16+s15)+&
&               tt*s16*tt_tl))))) + (1.-w)*(tt_tl*(tt*(tt*(tt*(tt*(tt*&
&               s26+s25)+s24)+s23)+s22)+s21)+tt*(tt_tl*(tt*(tt*(tt*(tt*&
&               s26+s25)+s24)+s23)+s22)+tt*(tt_tl*(tt*(tt*(tt*s26+s25)+&
&               s24)+s23)+tt*(tt_tl*(tt*(tt*s26+s25)+s24)+tt*(tt_tl*(tt*&
&               s26+s25)+tt*s26*tt_tl))))) - w_tl*(tt*(tt*(tt*(tt*(tt*(&
&               tt*s26+s25)+s24)+s23)+s22)+s21)+s20)
              qs = w*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+s11&
&               )+s10) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+&
&               s23)+s22)+s21)+s20)
            ELSE IF (tt .GE. tstarr2 .AND. tt .LT. tstarr3) THEN
              qs_tl = tt_tl*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+&
&               s21) + tt*(tt_tl*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)&
&               +tt*(tt_tl*(tt*(tt*(tt*s26+s25)+s24)+s23)+tt*(tt_tl*(tt*&
&               (tt*s26+s25)+s24)+tt*(tt_tl*(tt*s26+s25)+tt*s26*tt_tl)))&
&               )
              qs = tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+s21) +&
&               s20
            ELSE IF (tt .GE. tstarr3 .AND. tt .LT. tstarr4) THEN
              w_tl = (-tt_tl)/(tstarr4-tstarr3)
              w = (tstarr4-tt)/(tstarr4-tstarr3)
              qs_tl = w_tl*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+&
&               s22)+s21)+s20) + w*(tt_tl*(tt*(tt*(tt*(tt*(tt*s26+s25)+&
&               s24)+s23)+s22)+s21)+tt*(tt_tl*(tt*(tt*(tt*(tt*s26+s25)+&
&               s24)+s23)+s22)+tt*(tt_tl*(tt*(tt*(tt*s26+s25)+s24)+s23)+&
&               tt*(tt_tl*(tt*(tt*s26+s25)+s24)+tt*(tt_tl*(tt*s26+s25)+&
&               tt*s26*tt_tl))))) + (1.-w)*(tt_tl*(tt*(tt*(tt*(tt*(tt*&
&               bi6+bi5)+bi4)+bi3)+bi2)+bi1)+tt*(tt_tl*(tt*(tt*(tt*(tt*&
&               bi6+bi5)+bi4)+bi3)+bi2)+tt*(tt_tl*(tt*(tt*(tt*bi6+bi5)+&
&               bi4)+bi3)+tt*(tt_tl*(tt*(tt*bi6+bi5)+bi4)+tt*(tt_tl*(tt*&
&               bi6+bi5)+tt*bi6*tt_tl))))) - w_tl*(tt*(tt*(tt*(tt*(tt*(&
&               tt*bi6+bi5)+bi4)+bi3)+bi2)+bi1)+bi0)
              qs = w*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+s21&
&               )+s20) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+&
&               bi3)+bi2)+bi1)+bi0)
            ELSE
              qs_tl = tt_tl*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2)+&
&               bi1) + tt*(tt_tl*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2)&
&               +tt*(tt_tl*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+tt*(tt_tl*(tt*&
&               (tt*bi6+bi5)+bi4)+tt*(tt_tl*(tt*bi6+bi5)+tt*bi6*tt_tl)))&
&               )
              qs = tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2)+bi1) +&
&               bi0
            END IF
          ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
            tt_tl = -(zeroc*ti_tl/ti**2)
            tt = zeroc/ti
            arg1_tl = -(di(2)*tt_tl/tt-di(1)*tt_tl/tt**2+di(3)*tt_tl)
            arg1 = -(di(1)/tt+di(2)*LOG(tt)+di(3)*tt)
            qs_tl = di(0)*arg1_tl*EXP(arg1)
            qs = di(0)*EXP(arg1)
          ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
            arg1_tl = ci(2)*ti_tl/ti - ci(1)*ti_tl/ti**2 + ci(3)*ti_tl
            arg1 = ci(0) + ci(1)/ti + ci(2)*ALOG(ti) + ci(3)*ti
            qs_tl = arg1_tl*EXP(arg1)
            qs = EXP(arg1)
          END IF
          ddq_tl = qs_tl - dd_tl
          ddq = qs - dd
          qs_tl = dd_tl
          qs = dd
        ELSE
          ddq_tl = 0.0_8
        END IF
      ELSE
        ddq_tl = 0.0_8
      END IF
      IF (PRESENT(pl)) THEN
        IF (pl .GT. qs) THEN
          dd_tl = -((-(esfac*(1.0-esfac)*qs_tl))/(pl-(1.0-esfac)*qs)**2)
          dd = esfac/(pl-(1.0-esfac)*qs)
          qs_tl = qs_tl*dd + qs*dd_tl
          qs = qs*dd
          IF (PRESENT(dq)) THEN
            dq_tl = erfac*pl*((ddq_tl*dd+ddq*dd_tl)*dd+ddq*dd*dd_tl)
            dq = ddq*erfac*pl*dd*dd
          ELSE
            dq_tl = 0.0_8
          END IF
        ELSE
          qs = max_mixing_ratio
          IF (PRESENT(dq)) THEN
            dq = 0.0
            dq_tl = 0.0_8
            qs_tl = 0.0_8
          ELSE
            dq_tl = 0.0_8
            qs_tl = 0.0_8
          END IF
        END IF
      ELSE IF (PRESENT(dq)) THEN
        dq_tl = ddq_tl/delta_t
        dq = ddq*(1.0/delta_t)
      ELSE
        dq_tl = 0.0_8
      END IF
    END IF
    RETURN
  END FUNCTION QSATICE0_TLM
  FUNCTION DQSAT1(tl, pl, ramp, pascals, qsat) RESULT (DQSAT)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:), pl(:)
    LOGICAL, OPTIONAL, INTENT(IN) :: pascals
    REAL, OPTIONAL, INTENT(IN) :: ramp
    REAL, OPTIONAL, INTENT(OUT) :: qsat(:)
    REAL :: dqsat(SIZE(tl, 1))
    INTEGER :: i
    INTRINSIC PRESENT
    INTRINSIC SIZE
    DO i=1,SIZE(tl, 1)
      IF (PRESENT(qsat)) THEN
        dqsat(i) = DQSAT0(tl(i), pl(i), ramp, pascals, qsat(i))
      ELSE
        dqsat(i) = DQSAT0(tl(i), pl(i), ramp, pascals)
      END IF
    END DO
  END FUNCTION DQSAT1
  FUNCTION DQSAT2(tl, pl, ramp, pascals, qsat) RESULT (DQSAT)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:, :), pl(:, :)
    LOGICAL, OPTIONAL, INTENT(IN) :: pascals
    REAL, OPTIONAL, INTENT(IN) :: ramp
    REAL, OPTIONAL, INTENT(OUT) :: qsat(:, :)
    REAL :: dqsat(SIZE(tl, 1), SIZE(tl, 2))
    INTEGER :: i, j
    INTRINSIC PRESENT
    INTRINSIC SIZE
    DO j=1,SIZE(tl, 2)
      DO i=1,SIZE(tl, 1)
        IF (PRESENT(qsat)) THEN
          dqsat(i, j) = DQSAT0(tl(i, j), pl(i, j), ramp, pascals, qsat(i&
&           , j))
        ELSE
          dqsat(i, j) = DQSAT0(tl(i, j), pl(i, j), ramp, pascals)
        END IF
      END DO
    END DO
  END FUNCTION DQSAT2
  FUNCTION DQSAT3(tl, pl, ramp, pascals, qsat) RESULT (DQSAT)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:, :, :), pl(:, :, :)
    LOGICAL, OPTIONAL, INTENT(IN) :: pascals
    REAL, OPTIONAL, INTENT(IN) :: ramp
    REAL, OPTIONAL, INTENT(OUT) :: qsat(:, :, :)
    REAL :: dqsat(SIZE(tl, 1), SIZE(tl, 2), SIZE(tl, 3))
    INTEGER :: i, j, k
    INTRINSIC PRESENT
    INTRINSIC SIZE
    DO k=1,SIZE(tl, 3)
      DO j=1,SIZE(tl, 2)
        DO i=1,SIZE(tl, 1)
          IF (PRESENT(qsat)) THEN
            dqsat(i, j, k) = DQSAT0(tl(i, j, k), pl(i, j, k), ramp, &
&             pascals, qsat(i, j, k))
          ELSE
            dqsat(i, j, k) = DQSAT0(tl(i, j, k), pl(i, j, k), ramp, &
&             pascals)
          END IF
        END DO
      END DO
    END DO
  END FUNCTION DQSAT3
!=======================================================================================
!BOPI
! !IROUTINE: GEOS_DQsat -- Computes derivative satuation specific humidity wrt temperature.
! !INTERFACE:
!    function GEOS_DQsat(TL,PL,RAMP,PASCALS,QSAT) result(DQSAT)
!
! Overloads:
!
!      real,                               intent(IN)               :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real,                     optional, intent(OUT)              :: QSAT
!      real                                                         :: DQSAT
!
!      real, dimension(:),                 intent(IN)               :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real, dimension(:),       optional, intent(OUT)              :: QSAT
!      real, dimension(size(PL,1))                                  :: DQSAT
!
!      real, dimension(:,:),               intent(IN)               :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real, dimension(:,:),     optional, intent(OUT)              :: QSAT
!      real, dimension(size(PL,1),size(PL,2))                       :: DQSAT
!
!      real, dimension(:,:,:),             intent(IN)               :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real, dimension(:,:,:),   optional, intent(OUT)              :: QSAT
!      real, dimension(size(PL,1),size(PL,2),size(PL,3))            :: DQSAT
!
!      real, dimension(:,:,:,:),           intent(IN)               :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real, dimension(:,:,:,:), optional, intent(OUT)              :: QSAT
!      real, dimension(size(PL,1),size(PL,2),size(PL,3),size(PL,4)) :: DQSAT
! !DESCRIPTION:  Differentiates the approximations used
!                by GEOS_Qsat with respect to temperature,
!    using the same scheme to handle ice. Arguments are as in
!    GEOS_Qsat, with the addition of QSAT, which is the saturation specific
!    humidity. This is for economy, in case both qsat and dqsat are
!    required.
!
!EOPI
  FUNCTION DQSAT0(tl, pl, ramp, pascals, qsat) RESULT (DQSAT)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl, pl
    LOGICAL, OPTIONAL, INTENT(IN) :: pascals
    REAL, OPTIONAL, INTENT(IN) :: ramp
    REAL, OPTIONAL, INTENT(OUT) :: qsat
    REAL :: dqsat
    REAL :: uramp, tt, ww, dd, dqq, qq, ti, dqi, qi, pp
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC ABS
    INTRINSIC INT
    REAL :: abs0
    IF (PRESENT(ramp)) THEN
      IF (ramp .GE. 0.) THEN
        abs0 = ramp
      ELSE
        abs0 = -ramp
      END IF
      uramp = -abs0
    ELSE
      uramp = tmix
    END IF
    IF (PRESENT(pascals)) THEN
      IF (pascals) THEN
        pp = pl
      ELSE
        pp = pl*100.
      END IF
    ELSE
      pp = pl*100.
    END IF
    IF (uramp .EQ. tmix .OR. (uramp .EQ. 0. .AND. utbl)) THEN
      IF (first) THEN
        first = .false.
        CALL ESINIT()
      END IF
      IF (tl .LE. tmintbl) THEN
        ti = tmintbl
      ELSE IF (tl .GE. tmaxtbl - .001) THEN
        ti = tmaxtbl - .001
      ELSE
        ti = tl
      END IF
      tt = (ti-tmintbl)*degsubs + 1
      it = INT(tt)
      IF (uramp .EQ. tmix) THEN
        dqq = estblx(it+1) - estblx(it)
        qq = (tt-it)*dqq + estblx(it)
      ELSE
        dqq = estble(it+1) - estble(it)
        qq = (tt-it)*dqq + estble(it)
      END IF
      IF (pp .LE. qq) THEN
        IF (PRESENT(qsat)) qsat = max_mixing_ratio
        dqsat = 0.0
      ELSE
        dd = 1.0/(pp-(1.0-esfac)*qq)
        IF (PRESENT(qsat)) qsat = esfac*qq*dd
        dqsat = esfac*degsubs*dqq*pp*(dd*dd)
      END IF
    ELSE
      ti = tl - zeroc
      IF (ti .LE. uramp) THEN
        qq = QSATICE0(tl, pp, dqsat)
        IF (PRESENT(qsat)) qsat = qq
      ELSE IF (ti .GE. 0.0) THEN
        qq = QSATLQU0(tl, pp, dqsat)
        IF (PRESENT(qsat)) qsat = qq
      ELSE
        qq = QSATLQU0(tl, pp, dqq)
        qi = QSATICE0(tl, pp, dqi)
        ti = ti/uramp
        dqsat = ti*(dqi-dqq) + dqq
        IF (PRESENT(qsat)) qsat = ti*(qi-qq) + qq
      END IF
    END IF
  END FUNCTION DQSAT0
!==============================================
!BOPI
! !IROUTINE: GEOS_QsatSet -- Sets behavior of GEOS_QsatLqu an GEOS_QsatIce
! !INTERFACE:
  SUBROUTINE GEOS_QSATSET(usetable, formulation)
    IMPLICIT NONE
    LOGICAL, OPTIONAL, INTENT(IN) :: usetable
    INTEGER, OPTIONAL, INTENT(IN) :: formulation
    INTRINSIC PRESENT
    INTRINSIC MIN
    INTRINSIC MAX
    INTEGER :: x1
! !DESCRIPTION: GEOS_QsatSet can be used to modify
!  the behavior of GEOS_QsatLqu an GEOS_QsatIce
!  from its default setting.
!  If {\tt \bf USETABLE} is true, tabled values of the saturation vapor pressures are used.
!  These tables are automatically generated at a 0.1K resolution for whatever
!  vapor pressure formulation is being used. The default is to use the table.
!  {\tt \bf FORMULATION} sets the saturation vapor pressure function.
!  Three formulations of saturation vapor pressure are supported:
!  the Starr code that was in NSIPP-1 (FORMULATION==1), the formulation in  CAM
!  (FORMULATION==2), and Murphy and Koop (2005, QJRMS) (FORMULATION==3).
!  The default is FORMULATION=1.
!  If appropriate, GEOS_QsatSet also initializes the tables. If GEOS_QsatSet is
!  not called and tables are required, they will be initialized the first time
!  a Qsat function is called.
!EOPI
    IF (PRESENT(usetable)) utbl = usetable
    IF (PRESENT(formulation)) THEN
      IF (formulation .GT. 3) THEN
        x1 = 3
      ELSE
        x1 = formulation
      END IF
      IF (x1 .LT. 1) THEN
        type = 1
      ELSE
        type = x1
      END IF
    END IF
    IF (type .EQ. 3) THEN
      IF (tmintbl .LT. 110.) THEN
        tminice = 110.
      ELSE
        tminice = tmintbl
      END IF
      IF (tmintbl .LT. 123.) THEN
        tminlqu = 123.
      ELSE
        tminlqu = tmintbl
      END IF
    ELSE
      tminlqu = zeroc - 40.0
      tminice = zeroc + tminstr
    END IF
    IF (utbl) CALL ESINIT()
    RETURN
  END SUBROUTINE GEOS_QSATSET
!=======================================================================================
  SUBROUTINE ESINIT()
    IMPLICIT NONE
! Saturation vapor pressure table initialization. This is invoked if UTBL is true
! on the first call to any qsat routine or whenever GEOS_QsatSet is called
! N.B.--Tables are in Pa
    INTEGER :: i
    REAL :: t
    LOGICAL :: ut
    ut = utbl
    utbl = .false.
    DO i=1,tablesize
      t = (i-1)*delta_t + tmintbl
      estblw(i) = QSATLQU0(t)
      IF (t .GT. zeroc) THEN
        estble(i) = estblw(i)
      ELSE
        estble(i) = QSATICE0(t)
      END IF
      t = t - zeroc
      IF (t .GE. tmix .AND. t .LT. 0.0) THEN
        estblx(i) = t/tmix*(estble(i)-estblw(i)) + estblw(i)
      ELSE
        estblx(i) = estble(i)
      END IF
    END DO
    estfrz = QSATLQU0(zeroc)
    estlqu = QSATLQU0(tminlqu)
    utbl = ut
  END SUBROUTINE ESINIT
!BOPI
! !IROUTINE: GEOS_QsatLqu Computes saturation specific humidity over
!            liquid water.
! !IROUTINE: GEOS_QsatIce Computes saturation specific humidity over
!            frozen water.
! !INTERFACE:
!    function GEOS_QsatLqu(TL,PL,DQ) result(QS)
!    function GEOS_QsatIce(TL,PL,DQ) result(QS)
!
! Overloads:
!
!      real,                               intent(IN)               :: TL
!      logical,                  optional, intent(IN)               :: PL
!      real,                     optional, intent(OUT)              :: DQ
!      real                                                         :: QS
!
!      real,                               intent(IN)               :: TL(:)
!      logical,                  optional, intent(IN)               :: PL(:)
!      real,                     optional, intent(OUT)              :: DQ(:)
!      real, dimension(size(TL,1))                                  :: QS
!
!      real,                               intent(IN)               :: TL(:,:)
!      logical,                  optional, intent(IN)               :: PL(:,:)
!      real,                     optional, intent(OUT)              :: DQ(:,:)
!      real, dimension(size(TL,1),size(TL,2))                       :: QS
!
!      real,                               intent(IN)               :: TL(:,:,:)
!      logical,                  optional, intent(IN)               :: PL(:,:,:)
!      real,                     optional, intent(OUT)              :: DQ(:,:,:)
!      real, dimension(size(TL,1),size(TL,2),size(TL,3))            :: QS
!
!
! !DESCRIPTION:  Uses various formulations of the saturation
!                vapor pressure to compute the saturation specific
!    humidity and, optionally, its derivative with respect to temperature
!    for temperature TL and pressure PL. If PL is not present
!    it returns the saturation vapor pressure and, optionally, its derivative.
!
!    All pressures are in Pascals and all temperatures in Kelvins.
!
!    The choice of saturation vapor pressure formulation is controlled by  GEOS_QsatSet.
!    Three choices are currently supported: The CAM formulation,
!    Murphy and Koop (2005, QJRMS), and the Staar formulation from NSIPP-1.
!    The default is Starr. All three are valid up to 333K. Above the
!    freezing point, GEOS_QsatIce returns values at the freezing point.
!    Murphy and Koop is valid down to 150K, for both liquid and ice.
!    The other two are valid down to 178K for ice and 233K for super-cooled liquid.
!
!    Another choice is whether to use the exact formulation
!    or a table look-up. This can also be controlled with GEOS_QsatSet.
!    The default is to do a table look-up. The tables are generated
!    at 0.1C intervals, controlled by parameter DEGSUBS=10.
!
!
!EOPI
  FUNCTION QSATLQU0(tl, pl, dq) RESULT (QS)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl
    REAL, OPTIONAL, INTENT(IN) :: pl
    REAL, OPTIONAL, INTENT(OUT) :: dq
    REAL :: qs
    REAL :: ti, w
    REAL :: dd
    REAL :: tt
    REAL :: ddq
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC LOG10
    INTRINSIC ALOG
    INTRINSIC TANH
    INTRINSIC EXP
    REAL*8 :: pwy1
    REAL*8 :: pwr1
    REAL*8 :: pwy2
    REAL*8 :: pwr2
    REAL*8 :: pwy3
    REAL*8 :: arg1
    REAL*8 :: arg2
! not table
    IF (utbl) THEN
      IF (first) THEN
        first = .false.
        CALL ESINIT()
      END IF
      IF (tl .LE. tminlqu) THEN
        qs = estlqu
        IF (PRESENT(dq)) ddq = 0.0
      ELSE IF (tl .GE. tmaxtbl) THEN
        qs = estblw(tablesize)
        IF (PRESENT(dq)) ddq = 0.0
      ELSE
        tt = (tl-tmintbl)*degsubs + 1
        it = INT(tt)
        ddq = estblw(it+1) - estblw(it)
        qs = (tt-it)*ddq + estblw(it)
      END IF
      IF (PRESENT(pl)) THEN
        IF (pl .GT. qs) THEN
          dd = esfac/(pl-(1.0-esfac)*qs)
          qs = qs*dd
          IF (PRESENT(dq)) dq = ddq*erfac*pl*dd*dd
        ELSE
          qs = max_mixing_ratio
          IF (PRESENT(dq)) dq = 0.0
        END IF
      ELSE IF (PRESENT(dq)) THEN
        dq = ddq
      END IF
    ELSE
! Exact Formulation
      IF (tl .LT. tminlqu) THEN
        ti = tminlqu
      ELSE IF (tl .GT. tmaxtbl) THEN
        ti = tmaxtbl
      ELSE
        ti = tl
      END IF
      IF (type .EQ. 1) THEN
!  Starr polynomial fit
        tt = ti - zeroc
        qs = tt*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+b1) + b0
      ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
        tt = ts/ti
        pwy1 = dl(4)*(1.0-1.0/tt)
        pwr1 = 10.0**pwy1
        pwy2 = dl(6)*(tt-1.0)
        pwr2 = 10.0**pwy2
        pwy3 = dl(1)*(tt-1.0) + dl(2)*LOG10(tt) + dl(3)*(pwr1-1.0)/&
&         10000000.0 + dl(5)*(pwr2-1.0)/1000.0 + logps + 2.0
        qs = 10.0**pwy3
      ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
        arg1 = cl(4)*(ti-cl(5))
        arg2 = cl(0) + cl(1)/ti + cl(2)*ALOG(ti) + cl(3)*ti + TANH(arg1)&
&         *(cl(6)+cl(7)/ti+cl(8)*ALOG(ti)+cl(9)*ti)
        qs = EXP(arg2)
      END IF
      IF (PRESENT(dq)) THEN
        IF (tl .LT. tminlqu) THEN
          ddq = 0.0
        ELSE IF (tl .GT. tmaxtbl) THEN
          ddq = 0.0
        ELSE IF (pl .GT. qs) THEN
          dd = qs
          ti = tl + delta_t
          IF (type .EQ. 1) THEN
!  Starr polynomial fit
            tt = ti - zeroc
            qs = tt*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+b1) + b0
          ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
            tt = ts/ti
            pwy1 = dl(4)*(1.0-1.0/tt)
            pwr1 = 10.0**pwy1
            pwy2 = dl(6)*(tt-1.0)
            pwr2 = 10.0**pwy2
            pwy3 = dl(1)*(tt-1.0) + dl(2)*LOG10(tt) + dl(3)*(pwr1-1.0)/&
&             10000000.0 + dl(5)*(pwr2-1.0)/1000.0 + logps + 2.0
            qs = 10.0**pwy3
          ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
            arg1 = cl(4)*(ti-cl(5))
            arg2 = cl(0) + cl(1)/ti + cl(2)*ALOG(ti) + cl(3)*ti + TANH(&
&             arg1)*(cl(6)+cl(7)/ti+cl(8)*ALOG(ti)+cl(9)*ti)
            qs = EXP(arg2)
          END IF
          ddq = qs - dd
          qs = dd
        END IF
      END IF
      IF (PRESENT(pl)) THEN
        IF (pl .GT. qs) THEN
          dd = esfac/(pl-(1.0-esfac)*qs)
          qs = qs*dd
          IF (PRESENT(dq)) dq = ddq*erfac*pl*dd*dd
        ELSE
          qs = max_mixing_ratio
          IF (PRESENT(dq)) dq = 0.0
        END IF
      ELSE IF (PRESENT(dq)) THEN
        dq = ddq*(1.0/delta_t)
      END IF
    END IF
    RETURN
  END FUNCTION QSATLQU0
  FUNCTION QSATICE0(tl, pl, dq) RESULT (QS)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl
    REAL, OPTIONAL, INTENT(IN) :: pl
    REAL, OPTIONAL, INTENT(OUT) :: dq
    REAL :: qs
    REAL :: ti, w
    REAL :: dd
    REAL :: tt
    REAL :: ddq
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC LOG
    INTRINSIC EXP
    INTRINSIC ALOG
    REAL*8 :: arg1
    IF (utbl) THEN
      IF (first) THEN
        first = .false.
        CALL ESINIT()
      END IF
      IF (tl .LE. tmintbl) THEN
        qs = estble(1)
        IF (PRESENT(dq)) ddq = 0.0
      ELSE IF (tl .GE. zeroc) THEN
        qs = estfrz
        IF (PRESENT(dq)) ddq = 0.0
      ELSE
        tt = (tl-tmintbl)*degsubs + 1
        it = INT(tt)
        ddq = estble(it+1) - estble(it)
        qs = (tt-it)*ddq + estble(it)
      END IF
      IF (PRESENT(pl)) THEN
        IF (pl .GT. qs) THEN
          dd = esfac/(pl-(1.0-esfac)*qs)
          qs = qs*dd
          IF (PRESENT(dq)) dq = ddq*erfac*pl*dd*dd
        ELSE
          qs = max_mixing_ratio
          IF (PRESENT(dq)) dq = 0.0
        END IF
      ELSE IF (PRESENT(dq)) THEN
        dq = ddq
      END IF
    ELSE
! Exact Formulation
      IF (tl .LT. tminice) THEN
        ti = tminice
      ELSE IF (tl .GT. zeroc) THEN
        ti = zeroc
      ELSE
        ti = tl
      END IF
      IF (type .EQ. 1) THEN
! Use Starr formulation
        tt = ti - zeroc
        IF (tt .LT. tstarr1) THEN
          qs = tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+s11) + s10
        ELSE IF (tt .GE. tstarr1 .AND. tt .LT. tstarr2) THEN
          w = (tstarr2-tt)/(tstarr2-tstarr1)
          qs = w*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+s11)+&
&           s10) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22&
&           )+s21)+s20)
        ELSE IF (tt .GE. tstarr2 .AND. tt .LT. tstarr3) THEN
          qs = tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+s21) + s20
        ELSE IF (tt .GE. tstarr3 .AND. tt .LT. tstarr4) THEN
          w = (tstarr4-tt)/(tstarr4-tstarr3)
          qs = w*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+s21)+&
&           s20) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2&
&           )+bi1)+bi0)
        ELSE
          qs = tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2)+bi1) + bi0
        END IF
      ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
        tt = zeroc/ti
        arg1 = -(di(1)/tt+di(2)*LOG(tt)+di(3)*tt)
        qs = di(0)*EXP(arg1)
      ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
        arg1 = ci(0) + ci(1)/ti + ci(2)*ALOG(ti) + ci(3)*ti
        qs = EXP(arg1)
      END IF
      IF (PRESENT(dq)) THEN
        IF (tl .LT. tminice) THEN
          ddq = 0.0
        ELSE IF (tl .GT. zeroc) THEN
          ddq = 0.0
        ELSE IF (pl .GT. qs) THEN
          dd = qs
          ti = tl + delta_t
          IF (type .EQ. 1) THEN
! Use Starr formulation
            tt = ti - zeroc
            IF (tt .LT. tstarr1) THEN
              qs = tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+s11) +&
&               s10
            ELSE IF (tt .GE. tstarr1 .AND. tt .LT. tstarr2) THEN
              w = (tstarr2-tt)/(tstarr2-tstarr1)
              qs = w*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+s11&
&               )+s10) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+&
&               s23)+s22)+s21)+s20)
            ELSE IF (tt .GE. tstarr2 .AND. tt .LT. tstarr3) THEN
              qs = tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+s21) +&
&               s20
            ELSE IF (tt .GE. tstarr3 .AND. tt .LT. tstarr4) THEN
              w = (tstarr4-tt)/(tstarr4-tstarr3)
              qs = w*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+s21&
&               )+s20) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+&
&               bi3)+bi2)+bi1)+bi0)
            ELSE
              qs = tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2)+bi1) +&
&               bi0
            END IF
          ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
            tt = zeroc/ti
            arg1 = -(di(1)/tt+di(2)*LOG(tt)+di(3)*tt)
            qs = di(0)*EXP(arg1)
          ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
            arg1 = ci(0) + ci(1)/ti + ci(2)*ALOG(ti) + ci(3)*ti
            qs = EXP(arg1)
          END IF
          ddq = qs - dd
          qs = dd
        END IF
      END IF
      IF (PRESENT(pl)) THEN
        IF (pl .GT. qs) THEN
          dd = esfac/(pl-(1.0-esfac)*qs)
          qs = qs*dd
          IF (PRESENT(dq)) dq = ddq*erfac*pl*dd*dd
        ELSE
          qs = max_mixing_ratio
          IF (PRESENT(dq)) dq = 0.0
        END IF
      ELSE IF (PRESENT(dq)) THEN
        dq = ddq*(1.0/delta_t)
      END IF
    END IF
    RETURN
  END FUNCTION QSATICE0
!*************************************************************************
!*************************************************************************
!  Tridiagonal solvers
!*************************************************************************
!*************************************************************************
!BOP
! !IROUTINE:  VTRISOLVE -- Solves for tridiagonal system that has been decomposed by VTRILU
! !INTERFACE:
!  subroutine GEOS_TRISOLVE ( A,B,C,Y,YG )
! !ARGUMENTS:
!    real, dimension([:,[:,]] :),  intent(IN   ) ::  A, B, C
!    real, dimension([:,[:,]] :),  intent(INOUT) ::  Y
!    real, dimension([:,[:,]] :),  intent(IN   ) ::  YG
! !DESCRIPTION: Solves tridiagonal system that has been LU decomposed
!   $LU x = f$. This is done by first solving $L g = f$ for $g$, and
!   then solving $U x = g$ for $x$. The solutions are:
! $$
! \begin{array}{rcl}
! g_1 & = & f_1, \\
! g_k & = & \makebox[2 in][l]{$f_k - g_{k-1} \hat{a}_{k}$,}  k=2, K, \\
! \end{array}
! $$
! and
! $$
! \begin{array}{rcl}
! x_K & = & g_K /\hat{b}_K, \\
! x_k & = & \makebox[2 in][l]{($g_k - c_k g_{k+1}) / \hat{b}_{k}$,}  k=K-1, 1 \\
! \end{array}
! $$
!
!  On input A contains the $\hat{a}_k$, the lower diagonal of $L$,
!   B contains the $1/\hat{b}_k$, inverse of the  main diagonal of $U$,
!   C contains the $c_k$, the upper diagonal of $U$. The forcing, $f_k$ is
!
!   It returns the
!   solution in the r.h.s input vector, Y. A has the multiplier from the
!   decomposition, B the
!   matrix (U), and C the upper diagonal of the original matrix and of U.
!   YG is the LM+1 (Ground) value of Y.
!EOP
!BOP
! !IROUTINE:  VTRILU --  Does LU decomposition of tridiagonal matrix.
! !INTERFACE:
!  subroutine GEOS_TRILU  ( A,B,C )
! !ARGUMENTS:
!    real, dimension ([:,[:,]] :), intent(IN   ) ::  C
!    real, dimension ([:,[:,]] :), intent(INOUT) ::  A, B
! !DESCRIPTION: {\tt VTRILU} performs an $LU$ decomposition on
! a tridiagonal matrix $M=LU$.
!
! $$
! M = \left( \begin{array}{ccccccc}
!      b_1 & c_1 & & & & & \\
!      a_2 & b_2 & c_2 & & & &  \\
!      &  \cdot& \cdot & \cdot & & &  \\
!      & & \cdot& \cdot & \cdot & &  \\
!      &&  & \cdot& \cdot & \cdot &  \\
!      &&&& a_{K-1} & b_{K-1} & c_{K-1}   \\
!      &&&&& a_{K} & b_{K}
!    \end{array} \right)
! $$
!
! $$
! \begin{array}{lr}
! L = \left( \begin{array}{ccccccc}
!      1 &&&&&& \\
!      \hat{a}_2 & 1 & &&&&  \\
!      &  \cdot& \cdot &  & & &  \\
!      & & \cdot& \cdot &  &&  \\
!      &&  & \cdot& \cdot &  &  \\
!      &&&& \hat{a}_{K-1} & 1 &   \\
!      &&&&& \hat{a}_{K} & 1
!    \end{array} \right)
! &
! U = \left( \begin{array}{ccccccc}
!      \hat{b}_1 & c_1 &&&&& \\
!       & \hat{b}_2 & c_2 &&&&  \\
!      &  & \cdot & \cdot & & &  \\
!      & & & \cdot & \cdot &&  \\
!      &&  & & \cdot & \cdot &  \\
!      &&&&  & \hat{b}_{K-1} & c_{K-1}   \\
!      &&&&&  & \hat{b}_{K}
!    \end{array} \right)
! \end{array}
! $$
!
! On input, A, B, and C contain, $a_k$, $b_k$, and $c_k$
! the lower, main, and upper diagonals of the matrix, respectively.
! On output, B contains $1/\hat{b}_k$, the inverse of the main diagonal of $U$,
! and A contains $\hat{a}_k$,
! the lower diagonal of $L$. C contains the upper diagonal of the original matrix and of $U$.
!
! The new diagonals $\hat{a}_k$ and $\hat{b}_k$ are:
! $$
! \begin{array}{rcl}
! \hat{b}_1 & = & b_1, \\
! \hat{a}_k & = & \makebox[2 in][l]{$a_k / \hat{b}_{k-1}$,}  k=2, K, \\
! \hat{b}_k & = & \makebox[2 in][l]{$b_k - c_{k-1} \hat{a}_k$,} k=2, K.
! \end{array}
! $$
!EOP
  SUBROUTINE GEOS_TRILU1(a, b, c)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: c
    REAL, DIMENSION(:), INTENT(INOUT) :: a, b
    INTEGER :: lm, l
    INTRINSIC SHAPE
    INTRINSIC SIZE
    lm = SIZE(a, SIZE(SHAPE(a)))
    b(1) = 1./b(1)
    DO l=2,lm
      a(l) = a(l)*b(l-1)
      b(l) = 1./(b(l)-c(l-1)*a(l))
    END DO
    RETURN
  END SUBROUTINE GEOS_TRILU1
  SUBROUTINE GEOS_TRISOLVE1(a, b, c, y, yg)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: a, b, c
    REAL, DIMENSION(:), INTENT(INOUT) :: y
    REAL, DIMENSION(:), INTENT(IN) :: yg
    INTEGER :: lm, l
    INTRINSIC SHAPE
    INTRINSIC SIZE
    lm = SIZE(a, SIZE(SHAPE(a)))
! Sweep down, modifying rhs with multiplier A
    y(1) = y(1) - a(1)*yg(1)
    DO l=2,lm
      y(l) = y(l) - y(l-1)*a(l)
    END DO
! Sweep up, solving for updated value. Note B has the inverse of the main diagonal
    y(lm) = (y(lm)-c(lm)*yg(2))*b(lm)
    DO l=lm-1,1,-1
      y(l) = (y(l)-c(l)*y(l+1))*b(l)
    END DO
    RETURN
  END SUBROUTINE GEOS_TRISOLVE1
  SUBROUTINE GEOS_TRILU2(a, b, c)
    IMPLICIT NONE
    REAL, DIMENSION(:, :), INTENT(IN) :: c
    REAL, DIMENSION(:, :), INTENT(INOUT) :: a, b
    INTEGER :: lm, l
    INTRINSIC SHAPE
    INTRINSIC SIZE
    lm = SIZE(a, SIZE(SHAPE(a)))
    b(:, 1) = 1./b(:, 1)
    DO l=2,lm
      a(:, l) = a(:, l)*b(:, l-1)
      b(:, l) = 1./(b(:, l)-c(:, l-1)*a(:, l))
    END DO
    RETURN
  END SUBROUTINE GEOS_TRILU2
  SUBROUTINE GEOS_TRISOLVE2(a, b, c, y, yg)
    IMPLICIT NONE
    REAL, DIMENSION(:, :), INTENT(IN) :: a, b, c
    REAL, DIMENSION(:, :), INTENT(INOUT) :: y
    REAL, DIMENSION(:, :), INTENT(IN) :: yg
    INTEGER :: lm, l
    INTRINSIC SHAPE
    INTRINSIC SIZE
    lm = SIZE(a, SIZE(SHAPE(a)))
! Sweep down, modifying rhs with multiplier A
    y(:, 1) = y(:, 1) - a(:, 1)*yg(:, 1)
    DO l=2,lm
      y(:, l) = y(:, l) - y(:, l-1)*a(:, l)
    END DO
! Sweep up, solving for updated value. Note B has the inverse of the main diagonal
    y(:, lm) = (y(:, lm)-c(:, lm)*yg(:, 2))*b(:, lm)
    DO l=lm-1,1,-1
      y(:, l) = (y(:, l)-c(:, l)*y(:, l+1))*b(:, l)
    END DO
    RETURN
  END SUBROUTINE GEOS_TRISOLVE2
  SUBROUTINE GEOS_TRILU3(a, b, c)
    IMPLICIT NONE
    REAL, DIMENSION(:, :, :), INTENT(IN) :: c
    REAL, DIMENSION(:, :, :), INTENT(INOUT) :: a, b
    INTEGER :: lm, l
    INTRINSIC SHAPE
    INTRINSIC SIZE
    lm = SIZE(a, SIZE(SHAPE(a)))
    b(:, :, 1) = 1./b(:, :, 1)
    DO l=2,lm
      a(:, :, l) = a(:, :, l)*b(:, :, l-1)
      b(:, :, l) = 1./(b(:, :, l)-c(:, :, l-1)*a(:, :, l))
    END DO
    RETURN
  END SUBROUTINE GEOS_TRILU3
  SUBROUTINE GEOS_TRISOLVE3(a, b, c, y, yg)
    IMPLICIT NONE
    REAL, DIMENSION(:, :, :), INTENT(IN) :: a, b, c
    REAL, DIMENSION(:, :, :), INTENT(INOUT) :: y
    REAL, DIMENSION(:, :, :), INTENT(IN) :: yg
    INTEGER :: lm, l
    INTRINSIC SHAPE
    INTRINSIC SIZE
    lm = SIZE(a, SIZE(SHAPE(a)))
! Sweep down, modifying rhs with multiplier A
    y(:, :, 1) = y(:, :, 1) - a(:, :, 1)*yg(:, :, 1)
    DO l=2,lm
      y(:, :, l) = y(:, :, l) - y(:, :, l-1)*a(:, :, l)
    END DO
! Sweep up, solving for updated value. Note B has the inverse of the main diagonal
    y(:, :, lm) = (y(:, :, lm)-c(:, :, lm)*yg(:, :, 2))*b(:, :, lm)
    DO l=lm-1,1,-1
      y(:, :, l) = (y(:, :, l)-c(:, :, l)*y(:, :, l+1))*b(:, :, l)
    END DO
    RETURN
  END SUBROUTINE GEOS_TRISOLVE3
END MODULE GEOS_UTILSMOD_DIFF
