!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.13 (r6666) - 27 Nov 2017 17:09
!
! $Id: ras.F90,v 1.29.20.1.28.2 2017/09/08 16:58:21 mathomp4 Exp $
MODULE RAS_DIFF
!   use ESMF
!   use GEOS_Mod
  USE GEOS_UTILSMOD_DIFF, ONLY : dqsat => geos_dqsat, dqsat_tlm => &
& geos_dqsat_tlm
!   use module_ras
!use aer_cloud, only: AerProps, getINsubset
  USE AER_CLOUD, ONLY : aerprops, getinsubset, init_aer
  USE RASPARAMS
  USE MAPL_CONSTANTSMOD
  IMPLICIT NONE
  PRIVATE 
  PUBLIC rase
  PUBLIC rase_tlm
! -2
! -1
! 0
! 1
! 2
! 3
! 4
! 5
! 6
! 7
  CHARACTER(len=32), PARAMETER, PUBLIC :: rascodes(-2:7)=(/&
&   'Default                         ', &
&   'Invalid Code                    ', &
&   'Cloud detraining here is active ', &
&   'PBL h < layer''s h*              ', &
&   'No Valid lambda                 ', &
&   'Lambda out of bounds            ', &
&   'A < Acrit                       ', &
&   'Negative Kernel                 ', &
&   'Invalid Code                    ', &
&   'RH Trigger not met              '/)

CONTAINS
!!  RAS Relaxation Diagnostics
!!!!!AER_CLOUD
!DONIF
  SUBROUTINE RASE(idim, irun, k0, icmin, dt, cpo, alhlo, alhl1, tice, &
&   gravo, seedras, iras, jras, sige, kcbl, wgt0, wgt1, zcbl, mxdiam, &
&   tpert, qpert, tho, qho, uho, vho, qss, dqs, cnv_fraction, rasal2_2d&
&   , co_auto, pko, plo, phio, phie, qlo, qio, ple, pke, clw, flx, flxd&
&   , flxc, cnv_prc3, cnv_updfrc, cnv_cvw, cnv_qc, entlam, clan, hho, &
&   hso, precu, rasparams, ras_time, ras_trg, ras_toki, ras_pbl, ras_wfn&
&   , ras_alpha, ras_tau, aeroprops, cnv_fice, cnv_nice, cnv_ndrop, &
&   itrcr, irc, xho, triedlev_diag, fscav, disske)
    IMPLICIT NONE
! !!!!!!!!!!!!!!======================================
! !!!!!!!!!   Subroutine ARGact: finds the activated droplet number from Abdul_Razzak and Ghan 2000.
! ! Tailored for GOCART AEROSOL and works with AERO input
! !Written by Donifan Barahona
! !!donifan.o.barahona@nasa.gov
! !!!!!!!!!!!!!!====================================
! 
!       SUBROUTINE ARGact (TEMP, WX, NCPL_ACT, NCPL_AMB,  CDUST, CSOOT, LEV, ISBASE, DDUSTAMB, DSOOTAMB, ENT_PARAM)
! !
!          Integer, intent(in)     ::  LEV    
!          LOGICAL,  intent(in)     ::   ISBASE
! 
!          REAL, intent(inout)     ::   TEMP, WX, ENT_PARAM
!          REAL, intent(out)     ::   NCPL_ACT, NCPL_AMB, CSOOT, DSOOTAMB
!          REAL, DIMENSION(NDUSTMAX), INTENT(OUT) :: CDUST, DDUSTAMB
!          integer                 :: INDEX, NMODES, naux       
! 
!          type(AerProps)  :: AER, auxaer      
! 
! 
!          real     ::      kappa, alfa, beta, Akoh, G, T, smax, fi, gi, nui, &
!                        citai, ui, aux1, PACT,  Ntot, auxx, aux, auxconc, W, alph, aseasalt_aux, f_seasalt1
!          real, dimension (30) ::  SMI, TPI, SIGI 
! 
! 
!          SMI=0.0      
!          TPI = 0.0
!          SIGI =2.0
!          NCPL_ACT=0.0
!          NCPL_AMB=0.0
!          CDUST=0.0
!          CSOOT=0.0
!          DDUSTAMB =1.0e-9
!          DSOOTAMB= 1.0e-9
!          W=MIN(WX*(1.0-ENT_PARAM), 20.0)    
! 
!          PACT=0.0 !activation probability of entrained aerosol
! 
!          AER%nmods = 0
!          AER%num   = 0.0
! 
!          do INDEX = 1, AERO(LEV)%nmods
!              if (AERO(LEV)%num(INDEX) > 0.1) then
!                  AER%nmods = AER%nmods + 1
!                  naux = AER%nmods
! 
!                  AER%num(naux)   = AERO(LEV)%num(INDEX)
!                  AER%dpg(naux)   = max(AERO(LEV)%dpg(INDEX), 1.0e-9)
!                  AER%sig(naux)   = AERO(LEV)%sig(INDEX)
!                  AER%den(naux)   = AERO(LEV)%den(INDEX)
!                  AER%kap(naux)   = AERO(LEV)%kap(INDEX)
!                  AER%fdust(naux) = AERO(LEV)%fdust(INDEX)
!                  AER%fsoot(naux) = AERO(LEV)%fsoot(INDEX)
!                  AER%forg(naux)  = AERO(LEV)%forg(INDEX)
!              end if
!          end do
! 
!          if (AER%nmods == 0) then
!              call init_Aer(AER)
!          end if
! 
! !!!!!!!!!!activate aerosol transported from cloud base
!              NMODES =  AER_BASE%nmods
!              TPI(1:nmodes) = AER_BASE%num(1:nmodes)
!              SIGI(1:nmodes) = AER_BASE%sig(1:nmodes)                          
! 
!              
!              Ntot= 0.0
!               do index = 1, nmodes 
! 	              if (AER_BASE%kap(index) .gt. 0.1) Ntot =  Ntot + TPI(index)  
!               end do
!          
! 
!          if ((Ntot .lt. 1.0e4) .or. (TEMP .lt. 245.0) .or. (W .lt. 0.01)) then !no activation if aerosol < 1e-4 1/cm3
!             NCPL_ACT  = 0.0
!          else
! 
! ! Calculate constants. These fits were obtained from detailed correlations of physical properties. G is actually 1/G
!             T = min(max(TEMP, 243.0), 323.0)     
!             alfa=2.8915E-08*(T**2) - 2.1328E-05*T + 4.2523E-03
!             beta=exp(3.49996E-04*T**2 - 2.27938E-01*T + 4.20901E+01)
!             G=exp(-2.94362E-06*T**3 + 2.77941E-03*T**2 - 8.92889E-01*T + 1.18787E+02)
!             Akoh= 0.66e-6/T  !from Seinfeld and Pandis (1998)
!      
! !=======================================================
! !Activate droplets
! !=======================================================
! !Calculate maximum supersaturation according to ARG2002
! 
!             auxx=0.0 
!             
!             
!             DO INDEX = 1, NMODES            
!                 
!                kappa=  max(AER_BASE%kap(INDEX), 0.001)
!              
!                   SMI (INDEX) = ((0.667*Akoh/AER_BASE%dpg(INDEX))**1.5)/SQRT(2.0*kappa)   ! Critical supersat for mode I
!                   SMI=MAX(SMI, 1.0e-5)   
!                    
!               if ((TPI(INDEX) .gt. 1e4) .and.  (kappa .gt. 0.1)) then                       
!                   fi=0.5*exp(2.5*SIGI(INDEX)) !sigi is now log(sigi)
!                   gi=1.0+0.25*SIGI(INDEX)
!                   nui=((alfa*W*G)**1.5)/(2.0*MAPL_PI*980.0*beta*TPI(INDEX))
!                   citai = 0.667*Akoh*SQRT(alfa*W*G)
!                   aux1=fi*((citai/nui)**1.5) + gi*(SMI(INDEX)*SMI(INDEX)/(nui+(3.0*citai)))**0.75
!                   aux1=aux1/(SMI(INDEX)*SMI(INDEX))      
!                   auxx=auxx+aux1                  
!                 end if
!             end do
! 
! !Calculate number of activated droplets
!             if (auxx .gt. 0.0) then
!                smax = 1/sqrt(auxx)
!                auxx=0.0
! 
!                    DO INDEX = 1, NMODES
!                         if ((TPI(INDEX) .gt. 1e4) .and. (AER_BASE%kap(index) .gt. 0.1)) then
!                            ui=sqrt(2.0)*log(SMI(INDEX)/smax)/3.0
!                            aux1=0.5*TPI(INDEX)*(1.0-ERFAPP(ui))
!                            auxx=auxx+aux1
!                            AER_BASE%num(index) = max(TPI(INDEX) -aux1, 0.0) !remove already activated aerosol
!                         end if                    
!                    END DO
!                   NCPL_ACT=auxx             
!             else
!                   NCPL_ACT = 0.0             
!             end if
! 
!      
!  
!        end if
! 
! !now filllup dust and soot number
!          NMODES =  AER%nmods
! 
!          call getINsubset(1, AER,  auxaer)
!          CDUST(1:auxaer%nmods)= auxaer%num(1:auxaer%nmods)
!          DDUSTAMB(1:auxaer%nmods)= auxaer%dpg(1:auxaer%nmods)
!          call getINsubset(2, AER,  auxaer)
!          naux = max(auxaer%nmods, 1)
!          CSOOT= sum(auxaer%num) 
!          DSOOTAMB= sum(auxaer%dpg)/naux
! 
! 
!          PACT=1.0 ! fraction of entrained aerosol that is activated
!          auxconc =0.0
!          aseasalt_aux  = 0.0
! 
!          do index = 1, nmodes 
! 	       if (AER%kap(index) .gt. 0.8)  auxconc = AER%num(index) + auxconc
!            if (AER_BASE%kap(index) .gt. 0.8)    aseasalt_aux  = aseasalt_aux  + &
!            AER_BASE%num(index)*AER_BASE%dpg(index)*AER_BASE%dpg(index)*1.61*MAPL_PI !assumes a fixed sigma = 2.0
! 
!          end do
!        aseasalt = max(aseasalt, aseasalt_aux)
!      
! 	  NCPL_AMB=auxconc !Activate  entrained aerosol with kappa>0.8
! 
! 
! 
!       END SUBROUTINE ARGact
! 
! !!!!!!!!!!!!!!!!!!!!!!!!!!
! !=====Subroutine INfreezing=========
! ! Freeze droplets in immersion and contact ice nucleation modes, according to Barahona et al. GMD (2014)
! !!!!!!!!!!!!!!!!!!!!!
! 
!       subroutine INfreezing(QL, NL, NIN, NDUST, NSOOT, INDUST, INSOOT, TEMP, PRE, WSUB_, DDUST, DSOOT)  !NIN freezing tendency
!          REAL, INTENT( IN) :: TEMP, NSOOT, WSUB_, PRE, QL, NL, DSOOT
!          REAL, DIMENSION(NDUSTMAX), INTENT (IN) ::  NDUST, DDUST
!          REAL, DIMENSION(NDUSTMAX), INTENT (OUT) ::  INDUST
!          REAL, INTENT(OUT) ::  NIN, INSOOT 
!          REAL, DIMENSION(NDUSTMAX) ::  INDUST_C
! 
!          real :: a, b, c , d, Tx, n05, ui, aux, nssoot, nsdust, ninbkg, SI, acorr, &
!                dnsd, dnss, coolr, WSUB, ahet, INSOOT_C
! 
!          real :: nssoot_c, nsdust_c, mfp, nslip, ndfaer, viscosity, lam_r, taux, rho_a, &
!                 fdust_drop, fsoot_drop, min_ns_dust, min_ns_soot, nsss, INsea, dnsss, min_ns_seasalt 
! 
!          logical :: demott, Drop_mediated
!          integer :: ix
! 
!          min_ns_dust= 3.75e6 !limits ice nucleation to -12 !new 02/10/14
!          min_ns_soot= 3.75e9 !limits ice nucleation to -18
!          min_ns_seasalt = 4.0e2 !limits ice nucleation to -5
!          
!          demott=.false.
!          INDUST=0.0
!          INSOOT=0.0
!          INDUST_C=0.0
!          INSOOT_C=0.0   
!          NIN=0.0
!          Drop_mediated = .false.
!        INsea = 0.0 ! sea salt only in immersion
!    
!    
! ! note for sea salt we just assume that it is equal to the current droplet concentration and take the area 
! ! from the calculation at cloud base
! 
! ! fraction of dust and soot within droplets
!          fdust_drop= FDROP_DUST
!          fsoot_drop = FDROP_SOOT
! 
! 
!          WSUB=MAX(MIN(WSUB_, 10.0), 0.8)
!          coolr=5.0e-3*WSUB  !Approximation to saturated cooling rate
!          n05=sum(NDUST)+NSOOT
! 
!          if (TEMP .gt. T_ICE_MAX) then 
!             return
!          end if
! 
!          if (TEMP .lt. T_ICE_ALL   ) then 
!             return
!          end if
! 
! 
!          if ((QL .le. 1.0e-10) .or. (NL .le. 1.0)) then 
!             return
!          end if
! 
! !Background IN
! ! SI at water saturation
! 
!          rho_a = PRE*100.0/MAPL_RGAS/TEMP 
!          ninbkg=0.0
!          SI = -1.2379e-2+3.3595 !Ice supersat at water sat. Derived from Murphy and Koop 2005
! !if (TEMP .lt. 260.0)  ninbkg=coolr*42.8*exp(3.88*si)*0.1 !tendency in IN from background IN. Derived from Phillips et al. 2007
! 
! 
!          Tx = max(TEMP-273.16, -38.0 )
! 
!          lam_r=min((MAPL_PI*950.0*NL/rho_a/QL)**(1./3.), 1.0e8)
!          viscosity=1.8e-5*(TEMP/298.0)**0.85    ! Viscosity (kg/m/s)
!          mfp=2.0*viscosity/(PRE  &                   ! Mean free path (m)
!                *sqrt(8.0*28.96e-3/(MAPL_PI*8.314409*TEMP)))        
! 
!          if ((n05 .gt.1.0) .and. (TEMP .lt. 272.0)) then
! 
!             nsdust=  max(exp(-0.517*Tx + 8.934)-min_ns_dust, 0.0) !From Niemand 2012
!             nssoot= max(1.0e4*exp(-0.0101*Tx*Tx - 0.8525*Tx + 0.7667)-min_ns_soot, 0.0) !Murray (review_ 2012)
!             dnsd  = 0.517*nsdust
!             dnss  = max(-(-2.0*0.0101*Tx -0.8525)*nssoot, 0.0)
! 
! !ns in  contact. It is assumed that in contact is T-3 immersion
!             taux=max(Tx-3.0, -35.0)
!             nsdust_c= max(exp(-0.517*taux + 8.934)-min_ns_dust, 0.0) !From Niemand 2012
!             nssoot_c= max(1.0e4*exp(-0.0101*taux*taux - 0.8525*taux + 0.7667)-min_ns_soot, 0.0) !Murray (review_ 2012)
! 
!             aux=0.0        
!             acorr=2.7e7 !m2/m3 correction to the area due to non sphericity and aggregation. Assumes 10 m2/g (Murray 2011)
! 
! 
!             DO ix=1, NDUSTMAX
! !Immersion
!                ahet=0.52*DDUST(ix)*DDUST(ix)*DDUST(ix)*acorr*exp(4.5*log(2.0)*log(2.0)*log(2.0))    !this needs to be improved
! 
!                INDUST(ix) = NDUST(ix)*exp(-nsdust*ahet)* &
!                      dnsd*coolr*ahet*fdust_drop
! !Contact
!                nslip =1.0+(2.0*mfp/DDUST(ix))*(1.257+(0.4*exp(-(1.1*DDUST(ix)*0.5/mfp))))! Slip correction factor
!                ndfaer =1.381e-23*TEMP*nslip*(1.0-exp(-nsdust_c*ahet)) /(12.*MAPL_PI*viscosity*DDUST(ix))             
!                INDUST_C(ix) = 2.0*MAPL_PI*ndfaer*NDUST(ix)*NL/lam_r
! 
!             END DO
! 
! 
!             acorr=8.0e7 !m2/m3 correction to the area due to non sphericity and aggregation  Assumes 50 m2/g (Popovicheva 2003)
!             ahet =0.52*DSOOT*DSOOT*DSOOT*acorr*exp(4.5*log(2.0)*log(2.0)*log(2.0))             
!             INSOOT=fsoot_drop*NSOOT*exp(-nssoot*ahet)*dnss*ahet*coolr !
! 
!             nslip =1.0+(2.0*mfp/DSOOT)*(1.257+(0.4*exp(-(1.1*DSOOT*0.5/mfp))))! Slip correction factor
!             ndfaer =1.381e-23*TEMP*nslip*(1.0-exp(-nssoot_c*ahet)) /(12.*MAPL_PI*viscosity*DSOOT)             
!             INSOOT_c= 2.0*MAPL_PI*ndfaer*NSOOT*NL/lam_r
! 
! ! sea salt
!          nsss =  -0.459*TEMP +128.6235 ! from Demott et al. PNAS, 2015
!          nsss=  max(exp(nsss)-min_ns_seasalt, 0.0)           
!     	 dnsss=  max(0.459*nsss, 0.0)
!          INsea= aseasalt*dnsss*coolr 
! 
!  
!          end if
! 
! 	    NIN =ninbkg+ INSOOT + SUM(INDUST) + INSOOT_C + SUM(INDUST_C) + INsea!
!          INSOOT=INSOOT +INSOOT_C
!          INDUST =INDUST + INDUST_C
! 
! 	    
!       end subroutine INfreezing
! 
! 
! 
! 
! !!!!!!!!!!!!!!!!!!!!!!!!!!
! !===================Subroutine Qgrowth======================
! !Partitions water and ice according to Korolev and Mazin 2005. Assume spheres by now.
! !!!!!!!!!!!!!!!!!!!!
!       subroutine Qgrowth(TEMP, PRE, QICE0, NIPRE, QT, NINUC, DQIG, RIM, FNDRIM) 
! !freezing of IN according to Demott et al 2010 (everything SI)
!          REAL, INTENT(IN) :: TEMP, QICE0, NIPRE, NINUC,  PRE, QT
!          REAL, INTENT(INOUT) :: DQIG, RIM, FNDRIM
! 
! !real :: A, denI, aux, Dco, SI, denA, DQold, DQnew
!          real :: DIFF, DENICE, DENAIR, K1, K2, K3, SI, AUX, DC, TEFF, PLo, TEo, TC, &
!                DQnew, DQold, rho_a, LWC, IWC, qmin_rim
! 
! 
!          if (TEMP .gt. 272.15) then
!             DQIG =0.0
!             return
!          end if
! 
!          TC=TEMP-273.0 
!          PLo = max(PRE, 10.0) !limits  of the correlations
!          TEo = max(190.0, TEMP)
! 
!          qmin_rim = 1.0e-12
! 
! 
!          DENICE= 1000.0*(0.9167 - 1.75e-4*TC -5.0e-7*TC*TC) !From PK 97
!          DENAIR= PLo*100.0/MAPL_RGAS/TEMP
!          DIFF=(0.211*1013.25/(PLo+0.1))*(((TEo+0.1)/273.0)**1.94)*1e-4  !From Seinfeld and Pandis 2006
! 
!          K1 = EXP(7.1170e-4*TEo*TEo-0.43563*TEo+78.744) 
!          K2 = EXP(-9.933e-3*TEo+25.26)
!          K3 = EXP(7.1772e-4*TEo*TEo-0.44055*TEo+73.996)
! 
! 
!          AUX= 210368.0 + 131.438*TEMP - (3.32373E6/TEMP)- (41729.1*LOG(TEMP)) !From Murphy and Koop 2005
!          SI=exp(-aux/8.314/TEMP)-1.0 !ratio of pw/pi-1
!          rho_a = PRE*100.0/MAPL_RGAS/TEMP 
! 
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 
!          if  ((NIPRE .gt. 1.0) .and. (QICE0 .gt. 1.0e-10)) then 
!             DC=max((QICE0/(NIPRE*500.0*MAPL_PI))**(0.333), 40.0e-6) 
! !Assumme monodisperse size distribution about size distribution is made.
!          else   
!             DC = 40.0e-6
!          end if
! 
!          AUX=  NIPRE*DENICE*MAPL_PI*DC*DC
!          TEFF = DENAIR*2.0*((K1*DIFF+K2)*DC+(K3/0.1))
! 
!          if  (AUX .gt. 1.0e-12) then 
!             TEFF=min(TEFF/AUX, 1.0e20)   
!             DQold= SI/TEFF  
!          else
!             DQold=0.0
!          end if
! 
! ! Calculate rimming fraction
!          IWC =  QICE0*rho_a
!          LWC =  max(QT-QICE0, 0.0)*rho_a
!          aux = DQold ! only due to deposition
! 
! 
! !Account for rimming
! 
!          if ((LWC .gt. qmin_rim)  .and. (IWC .gt. qmin_rim))  then 
!             RIM = 6.0e-5/(LWC*(IWC**0.17)) !Fom Lin and Colle, NRW, 2011
!             RIM = 1.0/(1.0+RIM)
!             RIM  = min (0.95, RIM)
!             DQold =  DQold*(1 + RIM/(1.0-RIM))
!             FNDrim =  max(min(rho_a*(DQold -aux)/LWC, 1.0), 0.0) !Fraction of liquid condensate removed due to riming
!          END if
! 
! 
! 
! 
! !!!!!!!!!!!!!!!!!!!!!recently nucleated!!!!!!!!!!!!!!!!!!!!!!!!
! 
! 
!          AUX=  NINUC*DENICE*MAPL_PI*20.0e-6*20.0e-6
!          TEFF = DENAIR*2.0*((K1*DIFF+K2)*DC+(K3/0.1))
! 
!          if  (AUX .gt. 1.0e-12)  then 
!             TEFF=min(TEFF/AUX, 1.0e10)
!             DQnew= SI/TEFF
!          else
!             DQnew = 0.0
!          end if
! 
!          DQIG = DQold+DQnew     
! 
!       end subroutine Qgrowth
! 
! 
! 
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 
! !*************************************************************
! ! Function PDG07 (simplified background ice nucleation
! !                     spectra according to Phillips et. al. 2007).
! ! si is supersaturation wrt ice and T is in K
! !************************************************************
! 
!       subroutine PDG07_ice(si, Tx, N)     
! 
!          real, intent(in) :: si, Tx
!          real, intent(out)  :: N 
!          N=0.0
! 
! !if (Tx .le. 243.0)then
! 
! 
!          N=1000.0*exp(-0.388)*(exp(3.88*si)-1.0)/0.76
! !elseif (Tx .le. 260.0) then
! !  N=60.0*exp(-0.639)*(exp(12.96*si)-1.0)/0.76
! !end if
!       end subroutine PDG07_ice
! 
! 
! !*********************************************************************
! 
!*********************************************************************
!*********************************************************************
!******************** Relaxed Arakawa-Schubert ***********************
!************************ Parameterization ***************************
!********************** SCALAR RAS-1 VERSION  ************************
!************************* 31 DECEMBER 1999 **************************
!*********************************************************************
!************************** Developed By *****************************
!*********************************************************************
!************************ Shrinivas Moorthi **************************
!******************************* and *********************************
!************************** Max J. Suarez ****************************
!*********************************************************************
!******************** Laboratory for Atmospheres *********************
!****************** NASA/GSFC, Greenbelt, MD 20771 *******************
!*********************************************************************
!*********************************************************************
!  Input:
!  ------
!
!     K0      : Number of vertical levels (increasing downwards)
!
!     DT      : Time step in seconds
!
!     RASAL   : Array of dimension K-1 containing relaxation parameters
!               for cloud-types detraining at those levels
!
!     CPO     : Specific heat at constant pressure (J/kg/K)
!
!     ALHLO   : Latent Heat of condensation (J/kg)
!
!     ALHL1   : Latent Heat of condensation + fusion (J/kg)
!
!     GRAVO   : Acceleration due to gravity (m/s^2)
!
!     PLE     : 2D array of dimension (IDIM,K0+1) containing pressure
!               in hPa at the interfaces of K-layers from top of the
!               atmosphere to the bottom  (mb)
!
!     PKE     : 2D array of dimension (IDIM,K0+1) containing (PRS/P00) **
!               RKAP.  i.e. Exner function at layer edges.
!
!     PKL     : 2D array of dimension (IDIM,K0) ) containing the
!               Exner function at the layers.
!
!     QSS     : 2D array of dimension (IDIM,K0  ) containing the
!               saturation specific humidity at the layers. (kg/kg)
!
!     DQS     : 2D array of dimension (IDIM,K0  ) containing
!               d(qss)/dt at the layers.  (1/K)
!
!     CNV_FRACTION    : 1D array of dimension (IDIM) containing
!               fraction of grid cell considered to be convective
!
!  Update:
!  -------
!
!     THO     : 2D array of dimension (IDIM,K0) containing potential
!               temperature (K)
!
!     QHO     : 2D array of dimension (IDIM,K0) containing specific
!               humidity (kg/kg)
!
!     UHO     : 2D array of dimension (IDIM,K0) containing u-wind (m/s)
!
!     VHO     : 2D array of dimension (IDIM,K0) containing v-wind (m/s)
!
!  Output:
!  -------
!!
!     CLW     : 2D array of dimension (IDIM,K0) containing the
!               detrained cloud liquid water.  (kg/m^2/s)
!
!     FLX     : 2D array of dimension (IDIM,K0) containing the
!               cloud-base mass flux for each cloud type ordered by
!               detrainment level.   (kg/m^2/s)
!
!     FLXD    : 2D array of dimension (IDIM,K0) containing the
!               detrained  mass flux for each cloud type ordered by
!               detrainment level.   (kg/m^2/s)
!
!     FLXC    : 2D array of dimension (IDIM,K0+1) containing the
!               total cloud mass flux for all cloud types through
!               the top of each level. (e.g., FLXC(K)=SUM(FLX(ICMIN:K))
!               and  FLXD(L) = FLXC(L+1)-FLSD(L) )
!                (kg/m^2/s)
!
!     PRECU   : 1D (IDIM) Locally-handled convective precip
!               Zero if older version of RAS-1 is used. Nonzero if
!               RAS-2 is used.
!
!   AEROPROPS, Structure containing aerosol propoerties (in)
!   CNV_NICE, CNV_DROP.  Flux of ice crystals and droplet number at det level (1/m^2/s) (out)
!   CNV_FICE: Ice fraction in the detrained condensate (out)
!************************************************************************
!  ARGUMENTS
    INTEGER, INTENT(IN) :: idim, irun, k0, icmin
    REAL, DIMENSION(idim, k0), INTENT(INOUT) :: tho, qho, uho, vho, qlo&
&   , qio, clan
    REAL, DIMENSION(idim, k0+1), INTENT(IN) :: ple, pke, phie
    REAL, DIMENSION(idim, k0), INTENT(IN) :: qss, dqs, plo, pko, phio
    REAL, DIMENSION(idim), INTENT(IN) :: cnv_fraction, rasal2_2d
    REAL, DIMENSION(k0+1), INTENT(IN) :: sige
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: flx, clw, flxd
    REAL, DIMENSION(idim, k0+1), INTENT(OUT) :: flxc
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: cnv_prc3
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: cnv_updfrc, cnv_qc, &
&   cnv_cvw
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: entlam
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: hho, hso
    REAL, INTENT(IN) :: dt, cpo, alhlo, gravo
    REAL, INTENT(IN) :: alhl1, tice
    INTEGER, INTENT(IN) :: itrcr
    INTEGER, DIMENSION(idim, 2), INTENT(IN) :: seedras
    INTEGER, DIMENSION(idim), INTENT(IN) :: iras, jras, kcbl
    REAL, DIMENSION(idim), INTENT(IN) :: zcbl, tpert, qpert
    REAL, DIMENSION(idim), INTENT(IN) :: co_auto
    REAL, DIMENSION(idim), INTENT(OUT) :: mxdiam
    REAL, DIMENSION(idim), INTENT(OUT) :: precu
    REAL, DIMENSION(idim, k0), INTENT(IN) :: wgt0, wgt1
!     REAL, DIMENSION(:),          INTENT(IN   ) ::  RASPARAMS
    TYPE(RASPARAM_TYPE), INTENT(IN) :: rasparams
    REAL, DIMENSION(idim), INTENT(OUT) :: ras_time, ras_trg, ras_toki, &
&   ras_pbl, ras_wfn
    INTEGER, DIMENSION(idim, k0), INTENT(OUT) :: irc
    REAL, OPTIONAL, INTENT(INOUT) :: xho(idim, k0, itrcr)
    REAL, OPTIONAL, INTENT(OUT) :: triedlev_diag(idim, k0)
    REAL, OPTIONAL, INTENT(OUT) :: disske(idim, k0)
! Fraction scavenged per km
    REAL, OPTIONAL, INTENT(IN) :: fscav(itrcr)
! = 0 (no scav), = 1 (full scav)
!  LOCALS
    REAL, DIMENSION(k0) :: poi_sv, qoi_sv, uoi_sv, voi_sv
    REAL, DIMENSION(k0) :: poi, qoi, uoi, voi, dqq, bet, gam, cll
    REAL, DIMENSION(k0) :: poi_c, qoi_c
    REAL, DIMENSION(k0) :: prh, pri, ght, dpt, dpb, pki, dissk0, dissk1&
&   , clantnd
    REAL, DIMENSION(k0) :: tcu, qcu, ucu, vcu, cln, rns, pol, dm
    REAL, DIMENSION(k0) :: qst, ssl, rmf, rnn, rn1, rmfc, rmfp
    REAL, DIMENSION(k0) :: gms, eta, gmh, eht, gm1, hcc, rmfd
    REAL, DIMENSION(k0) :: hol, hst, qol, zol, hcld, cll0, cllx, clli, &
&   cllb
    REAL, DIMENSION(k0) :: wsp, lambdsv, bke, cvw, updfrc
    REAL, DIMENSION(k0) :: tau, rasal, mtkwi, updfrp, bk2, bk3, dll0, &
&   dllx
    REAL, DIMENSION(itrcr) :: xht
    REAL, DIMENSION(k0, itrcr) :: xoi, xcu, xoi_sv
    REAL, DIMENSION(k0+1) :: prj, prs, qht, sht, zet, xyd, xyd0
    INTEGER, DIMENSION(k0-1) :: rc
    INTEGER :: k, my_pe
    REAL, DIMENSION(idim, k0) :: lambdsv2
    REAL :: tx2, tx3, uht, vht, akm, acr, alm, tth, qqh, shtrg, wspbl, &
&   dqx
!, BKE
    REAL :: wfn, tem, trg, trgexp, evp, wlq, qcc, mtkw_max
    REAL :: shtrg_fac, sige_minhol, wfnog
    INTEGER :: i, ic, l, icl, itr, icl_c, n_dtl
    INTEGER :: ndtlexpon
    INTEGER, DIMENSION(:), ALLOCATABLE :: icl_v
!  RASE GLOBAL CONSTANTS
    REAL :: grav, cp, alhl, cpbg, alhi, cpi, gravi, ddt, lbcp, obg, afc
!!!!!!!!!
    REAL :: fricfac, dpth_bl, wupdrft, pblfrac, autorampb, co_zdep
    REAL :: rasal1, rasal2, rasal2i, co_t, rasncl, friclambda, sdqvt1, &
&   sdqv2
    REAL :: lambda_fac, strapping, acritfac, hmintrigger, lldisaggxp
    REAL :: lambmx_fac, diammn_min, rdtlexpon, cli_crit, sdqv3, &
&   maxdallowed_d, maxdallowed_s, maxdallowed_e
    REAL :: rhmn, rhmx, cldmicro, fdrop_dust, fdrop_soot, rasal_slope
    INTEGER :: kstrap
    REAL :: cld_radius, areal_frac, spect_mflx, cvw_cbase
!!!!!!!!!
    REAL, PARAMETER :: onepkap=1.+2./7., daylen=86400.0
!      REAL, PARAMETER :: PBLFRAC = 0.5
    REAL, PARAMETER :: rhmax=0.9999
!  LAMBDA LIMITS
    REAL :: lambda_min
    REAL :: lambda_max
!  TRIGGER PARAMETERS
! Density of liquid water in kg/m^3
    REAL, PARAMETER :: rho_w=1.0e3
    LOGICAL :: dyna_strapping, do_tracers, smooth_hst
!character(len=ESMF_MAXSTR)          :: CBL_STYLE
    REAL*8, DIMENSION(k0) :: tcu8, qcu8, pcu, flx8
    REAL*8, DIMENSION(k0, itrcr+2) :: rcu
!, dpd, tla
    REAL*8 :: cup
    LOGICAL :: revap, wrkfun, calkpb, crtfun, lprnt, dndrft
    REAL*8, DIMENSION(k0) :: toi8, qoi8, prsm8, phil8, qli8, qii8, &
&   trcfac
    REAL*8, DIMENSION(k0) :: alfind, alfint, alfinq, rhc_ls
    REAL*8, DIMENSION(k0+1) :: prs8, phih8
    REAL*8, DIMENSION(k0, itrcr+2) :: roi8
    REAL*8 :: fracbl, dt8, rasalf
    INTEGER :: kpbl
! no inhibition for =1.0
    REAL*8, SAVE :: max_neg_bouy=1.0
!!real*8 :: ALFINT = 0.5
!!real*8 :: ALFINQ = 0.5
! not used
    REAL*8, SAVE :: rhfacl=0.0
! no inhibition
    REAL*8, SAVE :: rhfacs=0.0
! 1 degree resolution
    REAL*8, SAVE :: garea=1.e10
!!real*8 :: ALFIND = 1.0
!!real*8 :: RHC_LS = 0.80
    REAL*8, SAVE :: dsfc=0.001
    REAL*8, SAVE :: cd=1.e-3
    REAL*8, SAVE :: wfnc=0.0
    REAL*8, SAVE :: tla=-1.0
    REAL*8, SAVE :: dpd=300.
!  SCAVANGING RELATED PARAMETERS
! layer thickness in km
    REAL :: delzkm
! fraction of tracer *not* scavenged
    REAL :: fnoscav
! Fraction scavenged per km
    REAL :: fscav_(itrcr)
! ************************AER_CLOUD *********************************************
!DONIF
    TYPE(AERPROPS), DIMENSION(idim, k0), INTENT(IN) :: aeroprops
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: cnv_ndrop, cnv_fice, &
&   cnv_nice
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: ras_tau, ras_alpha
!DONIF
    REAL, DIMENSION(k0) :: cnvndrop, cnvnice, cnvfice
!AEROSOL VERTICAl ARRAY FOR ALL SPECIES
    TYPE(AERPROPS), DIMENSION(k0) :: aero
    REAL :: t_ice_all, t_ice_max, aseasalt, f_seasalt
    INTEGER, PARAMETER :: ndustmax=10
    INTEGER :: index
    TYPE(AERPROPS) :: aeraux, aer_base
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC SQRT
    INTRINSIC SUM
    INTRINSIC ALLOCATED
    REAL :: result1
    cnv_fice = 0.0
    cnv_ndrop = 0.0
    cnv_nice = 0.0
    cnvfice = 0.0
    cnvndrop = 0.0
    cnvnice = 0.0
    t_ice_all = 238.0
    t_ice_max = mapl_tice
    cldmicro = 0.0
    fdrop_dust = 0.1
    fdrop_soot = 0.01
    ras_alpha = 1.0e15
    ras_tau = 1.0e15
! *********************************************************************
    IF (PRESENT(fscav)) THEN
      fscav_ = fscav
    ELSE
! NO SCAVENGING BY DEFAULT
      fscav_ = 0.0
    END IF
    IF (irun .LE. 0) THEN
      RETURN
    ELSE
      IF (PRESENT(triedlev_diag)) triedlev_diag = 0.
      cnv_prc3 = 0.
      cnv_updfrc = 0.
      cnv_cvw = 0.
      cnv_qc = 0.
      entlam = 0.
      IF (PRESENT(disske)) disske = 0.
!!LAMBDSV2 = 0.
      irc = -2
!      SMOOTH_HST   = .TRUE.
      smooth_hst = .false.
      fricfac = rasparams%cufricfac
      shtrg_fac = rasparams%shr_lambda_fac
! MAT CO_AUTO is now passed in from outside
!     in order to allow this code to run over im*jm
!     columns
!CO_AUTO      = RASPARAMS(3)     !  ---  3
      cli_crit = rasparams%qc_crit_cn
      rasal1 = rasparams%rasal1
      rasal2 = rasparams%rasal2
      rasncl = rasparams%rasncl
      lambda_fac = rasparams%lambda_fac
      lambmx_fac = rasparams%lambmx_fac
      diammn_min = rasparams%min_diameter
      friclambda = rasparams%cufriclambda
      rdtlexpon = rasparams%rdtlexpon
      strapping = rasparams%strapping
      sdqv2 = rasparams%sdqv2
      sdqv3 = rasparams%sdqv3
      sdqvt1 = rasparams%sdqvt1
      acritfac = rasparams%acritfac
      hmintrigger = rasparams%hmintrigger
      lldisaggxp = rasparams%lldisaggxp
      pblfrac = rasparams%pblfrac
      autorampb = rasparams%rasautorampb
      co_zdep = rasparams%autoc_cn_zdep
      maxdallowed_s = rasparams%maxdallowed_s
      maxdallowed_d = rasparams%maxdallowed_d
      maxdallowed_e = rasparams%maxdallowed_e
      rasal_slope = rasparams%rasal_slope
      rhmn = rasparams%ras_rhmin
      rhmx = rasparams%ras_rhfull
      cldmicro = rasparams%cldmicro
      fdrop_dust = rasparams%fdrop_dust
      fdrop_soot = rasparams%fdrop_soot
      IF (strapping .LE. 0.0) THEN
        dyna_strapping = .true.
      ELSE
        dyna_strapping = .false.
        kstrap = INT(strapping)
      END IF
      do_tracers = PRESENT(xho) .AND. itrcr .GT. 0
      wupdrft = 2.500
      grav = gravo
      alhl = alhlo
      cp = cpo
      cpi = 1.0/cp
      alhi = 1.0/alhl
      gravi = 1.0/grav
      cpbg = cp*gravi
      ddt = daylen/dt
      result1 = SQRT(dt*113.84)
      afc = -(1.04e-4*result1)
      lbcp = alhl*cpi
      obg = 100.*gravi
      hho = 1.0e15
      hso = 1.0e15
      DO i=1,irun
!===================AER_CLOUD
!            AERO =  AEROPROPS(I, :)
!            CNVFICE  =0.0
!            CNVNDROP =0.0
!            CNVNICE  =0.0
!!CALL FINDBASE
        k = kcbl(i)
        rc(icmin) = 0
        CALL FINDDTLS()
        IF (k .GT. 0) THEN
          CALL STRAP(0)
          CALL HTEST()
          hho(i, :) = hol
          hso(i, :) = hst
          tau = 0.0
          rasal = 0.0
          DO icl_c=1,n_dtl
            icl = icl_v(icl_c)
            IF (do_tracers) xcu(icmin:, :) = 0.
            IF (PRESENT(triedlev_diag)) triedlev_diag(i, icl) = 1.
! This change makes cumulus friction
            ucu(icmin:) = 0.
! correct.
            vcu(icmin:) = 0.
            IF (icl .GT. icmin) CALL CLOUDE(icl)
            entlam(i, icl) = alm
            ras_tau(i, icl) = tau(icl)
            ras_alpha(i, icl) = rasal(icl)
          END DO
          IF (SUM(rmf(icmin:k)) .GT. 0.0) THEN
            CALL RNEVP()
            CALL STRAP(1)
          ELSE
            CALL STRAP(2)
          END IF
        ELSE
          CALL STRAP(2)
        END IF
! Zero out precip - TBD w/ in progno_cloud
        precu = 0.0
      END DO
      IF (ALLOCATED(icl_v)) THEN
        DEALLOCATE(icl_v)
      END IF
      RETURN
    END IF

  CONTAINS
!*********************************************************************
    SUBROUTINE CLOUDE(ic)
      IMPLICIT NONE
!=======================================
      INTEGER, INTENT(IN) :: ic
      REAL :: deep_fact, cu_diam, wscale
!, dQx
      REAL :: cli, te_a, c00_x, cli_crit_x, pete, toki, gmhx, hstx
      REAL :: dt_lyr, rate, cvw_x, closs, f2, f3, f4, f5
      INTEGER :: k700
!=============================AER_CLOUD local variables ====================
      REAL :: wbase, ndrop, nice, fp_d, ff_a, fp_i, fice, ndrop_amb, &
&     nsoot_amb, nsoot, nin, insoot, dcvw2, qice, dqice, dqig, fpice, &
&     dnice, dndrop, dsoot_amb, dsoot, qliq, dqliq, fprecip, aux, qt, &
&     maxnice, maxndrop, minnice, minndrop, ndrop_act, rimm, fndrim, &
&     tminusta, tparcel, alph_e, beta_e, rh_amb, ecrit
      REAL, DIMENSION(ndustmax) :: ndust, ndust_amb, indust, ddust_amb, &
&     ddust
      INTEGER :: inx, naux, index
      INTRINSIC AMIN1
      INTRINSIC MAX
      INTRINSIC MIN
      INTRINSIC AMAX1
      INTRINSIC SQRT
      INTRINSIC EXP
      REAL :: min1
      REAL :: max1
      REAL :: min2
      REAL :: max2
      REAL :: arg1
      REAL :: x4
      REAL :: x3
      REAL :: x2
      REAL :: x1
      REAL :: y1
!A little higher so there is ice at the freezing level
      t_ice_all = 238.0
      wbase = 1.0
      fice = 0.0
      nice = 0.0
      ndrop = 0.0
      ndrop_amb = 0.0
      ndrop_act = 0.0
      nin = 0.0
      ndust = 0.0
      nsoot = 0.0
      ndust_amb = 0.0
      nsoot_amb = 0.0
      dcvw2 = 0.0
      qice = 0.0
      qliq = 0.0
      fpice = 0.0
      indust = 0.0
      insoot = 0.0
      qt = 0.0
      fprecip = 0.0
      fndrim = 0.0
      rimm = 0.0
      tminusta = 0.0
      f_seasalt = 0.0
      aseasalt = 0.0
      CALL INIT_AER(aer_base)
!AER_CLOUD=============================
      alm = 0.
      IF (1. .GT. (qoi(k)/qst(k)-rhmn)/(rhmx-rhmn)) THEN
        trg = (qoi(k)/qst(k)-rhmn)/(rhmx-rhmn)
      ELSE
        trg = 1.
      END IF
      IF (0.0 .LT. (autorampb-sige(ic))/0.2) THEN
        y1 = (autorampb-sige(ic))/0.2
      ELSE
        y1 = 0.0
      END IF
      IF (1.0 .GT. y1) THEN
        f4 = y1
      ELSE
        f4 = 1.0
      END IF
! to 1 at SIG=AUTORAMPB-0.2
      IF (sige(ic) .GE. 0.5) THEN
        f5 = 1.0
      ELSE
        f5 = 1.0 - 2.*co_zdep*(0.5-sige(ic))
        IF (f5 .LT. 0.0) THEN
          f5 = 0.0
        ELSE
          f5 = f5
        END IF
      END IF
      IF (trg .LE. 1.0e-5) THEN
! TRIGGER  =========>>
        rc(ic) = 7
        RETURN
      ELSE
!  RECOMPUTE SOUNDING UP TO DETRAINMENT LEVEL
        poi_c = poi
        qoi_c = qoi
        poi_c(k) = poi_c(k) + tpert(i)
        qoi_c(k) = qoi_c(k) + qpert(i)
        zet(k+1) = 0.
        sht(k+1) = cp*poi_c(k)*prj(k+1)
        DO l=k,ic,-1
          IF (qst(l)*rhmax .GT. qoi_c(l)) THEN
            qol(l) = qoi_c(l)
          ELSE
            qol(l) = qst(l)*rhmax
          END IF
          IF (0.000 .LT. qol(l)) THEN
            qol(l) = qol(l)
          ELSE
            qol(l) = 0.000
          END IF
          ssl(l) = cp*prj(l+1)*poi_c(l) + grav*zet(l+1)
          hol(l) = ssl(l) + qol(l)*alhl
          hst(l) = ssl(l) + qst(l)*alhl
          tem = poi_c(l)*(prj(l+1)-prj(l))*cpbg
          zet(l) = zet(l+1) + tem
          zol(l) = zet(l+1) + (prj(l+1)-prh(l))*poi_c(l)*cpbg
        END DO
        DO l=ic+1,k
          tem = (prj(l)-prh(l-1))/(prh(l)-prh(l-1))
          sht(l) = ssl(l-1) + tem*(ssl(l)-ssl(l-1))
          qht(l) = .5*(qol(l)+qol(l-1))
        END DO
! SMOOTH HSTAR W/ 1-2-1 Filter
        IF (smooth_hst) THEN
! save for later
          hstx = hst(ic)
          DO l=k-1,ic+1,-1
            hst(l) = 0.25*(hst(l+1)+hst(l-1)) + 0.5*hst(l)
          END DO
          DO l=ic,ic
            hst(l) = 0.5*hst(l+1) + 0.5*hst(l)
          END DO
        END IF
!  CALCULATE LAMBDA, ETA, AND WORKFUNCTION
        lambda_min = .2/mxdiam(i)
        lambda_max = .2/diammn_min
!     LAMBDA_MIN = .2/(LAMBDA_FAC*DPTH_BL)
!     LAMBDA_MAX = .2/( MAX( LAMBMX_FAC*DPTH_BL , DIAMMN_MIN ) )
        IF (hol(k) .LE. hst(ic)) THEN
! CANNOT REACH IC LEVEL  ======>>
          rc(ic) = 1
          RETURN
        ELSE
!  LAMBDA CALCULATION: MS-A18
          tem = (hst(ic)-hol(ic))*(zol(ic)-zet(ic+1))
          DO l=ic+1,k-1
            tem = tem + (hst(ic)-hol(l))*(zet(l)-zet(l+1))
          END DO
          IF (tem .LE. 0.0) THEN
! NO VALID LAMBDA  ============>>
            rc(ic) = 2
            RETURN
          ELSE
            alm = (hol(k)-hst(ic))/tem
            IF (alm .GT. lambda_max) THEN
              rc(ic) = 3
              RETURN
            ELSE
!   ALPHA CALCULATION
              rasal2i = rasal2_2d(i)
              IF (zet(ic) .LT. 2000.) rasal(ic) = rasal1
              IF (zet(ic) .GE. 2000.) THEN
                IF (1.0 .GT. (zet(ic)-2000.)/rasal_slope) THEN
                  min1 = (zet(ic)-2000.)/rasal_slope
                ELSE
                  min1 = 1.0
                END IF
                rasal(ic) = rasal1 + (rasal2i-rasal1)*min1
              END IF
              rasal(ic) = dt/rasal(ic)
              IF (1.0 .GT. (alm/lambda_min)**2) THEN
                toki = (alm/lambda_min)**2
              ELSE
                toki = 1.0
              END IF
!   RAS relaxation timescale
              IF (k0 .GT. 96) THEN
!! AMM kluge to run 132 levels for now -- multiply time scale by ratio of number of levels
!! AMM between 900 and 30 mb in 72 and 132 level grids, 0.46
                tau(ic) = toki*trg*rasal(ic)*0.46
              ELSE
                tau(ic) = toki*trg*rasal(ic)
              END IF
!IF (TAU(IC) < 1.0E-5) THEN
!   RC(IC) = 6
!   RETURN
!ENDIF
!LAMBDSV(IC) = ALM
!  ETA CALCULATION: MS-A2
              DO l=ic+1,k
                eta(l) = 1.0 + alm*(zet(l)-zet(k))
              END DO
              eta(ic) = 1.0 + alm*(zol(ic)-zet(k))
!  WORKFUNCTION CALCULATION:  MS-A22
              wfn = 0.0
              hcc(k) = hol(k)
              DO l=k-1,ic+1,-1
                hcc(l) = hcc(l+1) + (eta(l)-eta(l+1))*hol(l)
                tem = hcc(l+1)*dpb(l) + hcc(l)*dpt(l)
                eht(l) = eta(l+1)*dpb(l) + eta(l)*dpt(l)
                wfn = wfn + (tem-eht(l)*hst(l))*gam(l)
              END DO
              hcc(ic) = hst(ic)*eta(ic)
              wfn = wfn + (hcc(ic+1)-hst(ic)*eta(ic+1))*gam(ic)*dpb(ic)
!  VERTICAL VELOCITY/KE CALCULATION (ADDED 12/2001 JTB)
              bk3(k) = 0.0
              bk2(k) = 0.0
              bke(k) = 0.0
              hcld(k) = hol(k)
              DO l=k-1,ic,-1
                hcld(l) = (eta(l+1)*hcld(l+1)+(eta(l)-eta(l+1))*hol(l))/&
&                 eta(l)
                tem = (hcld(l)-hst(l))*(zet(l)-zet(l+1))/(1.0+lbcp*dqq(l&
&                 ))
                IF (cldmicro .LE. 0.0) THEN
                  bke(l) = bke(l+1) + grav*tem/(cp*prj(l+1)*poi(l))
                  IF (tem .LT. 0.0) THEN
                    max1 = 0.0
                  ELSE
                    max1 = tem
                  END IF
                  bk2(l) = bk2(l+1) + grav*max1/(cp*prj(l+1)*poi(l))
                  IF (tem .GT. 0.0) THEN
                    min2 = 0.0
                  ELSE
                    min2 = tem
                  END IF
                  bk3(l) = bk3(l+1) + grav*min2/(cp*prj(l+1)*poi(l))
                  IF (bk2(l) .LT. 0.0) THEN
                    max2 = 0.0
                  ELSE
                    max2 = bk2(l)
                  END IF
                  cvw(l) = SQRT(2.0*max2)
                END IF
              END DO
              WHERE (cvw(ic:k) .LT. 1.00) 
                cvw(ic:k) = 1.00
              ELSEWHERE
                cvw(ic:k) = cvw(ic:k)
              END WHERE
!  NOTE THIS "CENTRALIZES" A KLUGE PRESENT IN OTHER LOCATIONS.
!  CLEAN UP SOME TIME.      -JTB 12/04/03
!  TEST FOR CRITICAL WORK FUNCTION
              CALL ACRITN(pol(ic), prs(k), acr)
              IF (wfn .LE. acr) THEN
! SUB-CRITICAL WORK FUNCTION ======>>
                rc(ic) = 4
                RETURN
              ELSE
!  CLOUD TOP WATER AND MOMENTUM (TIMES ETA(IC)) MS-A16
! Tracer scavenging
! RAS loops over a series of plumes all having common cloud base level K
! and different detrainment levels IC.  The plumes operate sequentially
! on the grid box mean quantities (wind, moisture, tracer) and so each
! subsequent plume is seeing the effects of previous plumes.  We parameterize
! scavenging following Liu et al. [JGR, 2001], their equation 1:
!  AEROSOL FRACTION SCAVENGED = 1 - exp(-FSCAV*DZ)
! where FSCAV is a specified scavenging efficiency [km-1] and DZ is the
! distance [km] the tracer traverses in the plume from its entrainment
! level to its detrainment level.  We write the aerosol fraction surviving as:
!  FNOSCAV = exp(- FSCAV_(ITR) * DZ)
! The total scavenging is proportional to the convective mass flux, which
! is not explicitly solved for at this point.
                IF (do_tracers) THEN
                  DO itr=1,itrcr
!           Scavenging of the below cloud tracer
                    delzkm = (zet(ic)-zet(k))/1000.
                    x3 = EXP(-(fscav_(itr)*delzkm))
                    IF (x3 .GT. 1.) THEN
                      x1 = 1.
                    ELSE
                      x1 = x3
                    END IF
                    IF (x1 .LT. 0.) THEN
                      fnoscav = 0.
                    ELSE
                      fnoscav = x1
                    END IF
                    xht(itr) = xoi(k, itr)*fnoscav
                  END DO
                END IF
                wlq = qol(k)
                uht = uoi(k)
                vht = voi(k)
                rnn(k) = 0.
                cll0(k) = 0.
!print *, '========================================='
                DO l=k-1,ic,-1
                  tem = eta(l) - eta(l+1)
                  wlq = wlq + tem*qol(l)
                  uht = uht + tem*uoi(l)
                  vht = vht + tem*voi(l)
                  IF (do_tracers) THEN
                    DO itr=1,itrcr
!         Scavenging of the entrained tracer.  Updates transported tracer mass.
                      delzkm = (zet(ic)-zet(l+1))/1000.
                      x4 = EXP(-(fscav_(itr)*delzkm))
                      IF (x4 .GT. 1.) THEN
                        x2 = 1.
                      ELSE
                        x2 = x4
                      END IF
                      IF (x2 .LT. 0.) THEN
                        fnoscav = 0.
                      ELSE
                        fnoscav = x2
                      END IF
                      xht(itr) = xht(itr) + tem*xoi(l, itr)*fnoscav
                    END DO
                  END IF
!!!! How much condensate (CLI) is present here?
                  IF (l .GT. ic) THEN
                    tx2 = 0.5*(qst(l)+qst(l-1))*eta(l)
                    tx3 = 0.5*(hst(l)+hst(l-1))*eta(l)
                    qcc = tx2 + gm1(l)*(hcc(l)-tx3)
                    cll0(l) = wlq - qcc
                  ELSE
                    cll0(l) = wlq - qst(ic)*eta(ic)
                  END IF
                  IF (cll0(l) .LT. 0.00) THEN
                    cll0(l) = 0.00
                  ELSE
                    cll0(l) = cll0(l)
                  END IF
! condensate (kg/kg)
                  cli = cll0(l)/eta(l)
! Temperature (K)
                  te_a = poi(l)*prh(l)
!=====================================================================
!            if (CLDMICRO .gt. 0.0) then  !AER_CLOUD MIcrophysics considering activation and nucleation
!recompute vertical velocity
!
!               Tparcel = TE_A
!               CVW(K) = 0.8  ! Assume a below cloud base  W of 0.8 m s-1
!               BK2(K)   = 0.0
!
!     
!               TEM     = (HCLD(L)-HST(L) )/ (1.0+LBCP*DQQ(L))  
!               TminusTa = max(min(TEM/CP, 5.0), 0.0) !limit DT to 5 K. According to Wei, JAS, 1998
!	     TEM =0.33*TminusTa*CO_AUTO(I)/TE_A !Bouyancy term, effciency =0.5 mwr Roode et al
!
!               BK2(L)  = BK2(L+1) + GRAV * TEM*(ZET(L)-ZET(L+1)) 
!               BK2(L) = BK2(L) - (ZET(L)-ZET(L+1))*(BK2(L+1)*ALM + CLI*GRAV)  !Account for drag from entrainment of stagnat air 
!and condesate loading
!               CVW(L) = max(SQRT(  2.0* MAX( BK2(L) , 0.0 )  ), 1.0) 
!
!
!	    CVW_X = MIN(CVW(L), 50.0)
!               DT_LYR  =  max(( ZET(L)-ZET(L+1) )/CVW_X, 1.0) !Sanity check
!               TEM   = ETA(L) - ETA(L+1)
!
!               Tparcel  =  TE_A + TminusTa
!
!
!
!!!!!!!!!!account for entrainment effects on activation !!!!!!!!!!!
!! Barahona and Nenes, JGR, 2007
!               alph_e = 2.8915e-8*Tparcel*Tparcel -2.1328e-5*Tparcel+4.2523e-3
!               beta_e = MAPL_ALHL*TminusTa/MAPL_RVAP/Tparcel/Tparcel
!               RH_AMB=QOI(L)/QST(L)
!               ECRIT  = max(1.0-RH_AMB -beta_e, 1.0e-6) 
!               ECRIT =  alph_e/ECRIT
!! print *, L, Tparcel, RH_AMB, ECRIT, ALM
!	           ECRIT =  ALM/ECRIT
!!Print *, ECRIT
!
!
!               if (L .eq. K-1) then
!
!                  FICE=0.0
!                  NICE=0.0
!                  NDROP=0.0
!                  NIN =0.0
!                  NDUST_AMB =0.0
!                  NSOOT_AMB = 0.0
!                  NSOOT=0.0
!                  NDUST= 0.0
!                  RATE=0.0
!                  FPRECIP=0.0
!
!                  AER_BASE%nmods = 0
!                  AER_BASE%num   = 0.0
!                  do INDEX = 1, AERO(L)%nmods
!                      if (AERO(L)%num(INDEX) > 0.1) then
!                          AER_BASE%nmods = AER_BASE%nmods + 1
!                          naux = AER_BASE%nmods
!
!                          AER_BASE%num(naux)   = AERO(L)%num(INDEX)
!                          AER_BASE%dpg(naux)   = max(AERO(L)%dpg(INDEX), 1.0e-9)
!                          AER_BASE%sig(naux)   = AERO(L)%sig(INDEX)
!                          AER_BASE%den(naux)   = AERO(L)%den(INDEX)
!                          AER_BASE%kap(naux)   = AERO(L)%kap(INDEX)
!                          AER_BASE%fdust(naux) = AERO(L)%fdust(INDEX)
!                          AER_BASE%fsoot(naux) = AERO(L)%fsoot(INDEX)
!                          AER_BASE%forg(naux)  = AERO(L)%forg(INDEX)
!                      end if
!                  end do
!
!!initial conditions
!                  call ARGact(Tparcel, CVW_X, NDROP_ACT, NDROP_AMB, NDUST_AMB, NSOOT_AMB, L,  .true., DDUST_AMB, DSOOT_AMB, ECRI
!T) !cloud droplet number and INsource at cloud base
!                  NDUST=NDUST_AMB
!                  NSOOT=NSOOT_AMB
!                  DDUST=DDUST_AMB
!                  DSOOT=DSOOT_AMB                                     
!
!               else 
!                  call ARGact(Tparcel, CVW_X, NDROP_ACT, NDROP_AMB, NDUST_AMB, NSOOT_AMB, L, .false., DDUST_AMB, DSOOT_AMB, ECRI
!T) !cloud droplet number above cloud base
!
!               end if
!
!               QT = CLI
!               RATE = 0.0
!               FPRECIP = 0.0
!
!               if (QT .gt. 0.0) then
!
!! if FICE is already >= 1.0 then the cloud is glaciated and there is no need to do anymore partitioning
!
!                  if (FICE .ge. 1.0) then
!
!
!                     CALL  Qremoval(RATE, FICE, FP_D, FP_I, Tparcel,  & 
!                           POL(L), QT,  NICE, NDROP, CVW_X, FPICE, &
!                           DT_LYR, RIMM, CO_AUTO(I)) 
!
!
!
!                     dNICE = -NICE*FP_I 
!                     NICE  =  (NICE +dNICE*DT_LYR)*ETA(L+1)/ETA(L) !ice
!
!                     MINNICE = max(QICE*(1.0-RATE*DT_LYR), 0.0)/4.0e-8!assuming maximum vol radius 250 microns
!                     MAXNICE = max(QICE*(1.0-RATE*DT_LYR), 0.0)/2.51e-12 !assuming minimum vol radius 10 microns
!
!                     NICE=MIN(max(NICE, MINNICE), MAXNICE)
!
!                     FICE = 1.0
!
!                  else 
!
!! Cloud is not completely glaciated do the whole thing
!! ALL these subroutines return tendencies
!
!
!                     CALL  INfreezing(QLIQ, NDROP, NIN, NDUST, NSOOT, INDUST, INSOOT, Tparcel, POL(L), CVW_X, DDUST, DSOOT)  !ca
!lculate the freezing fraction of the aerosol at this level
!
!                     NIN = min(NIN, NDROP/DT_LYR)
!
!                     call Qgrowth(Tparcel, POL(L), QICE, NICE, QT, NIN, dQIG, RIMM, FNDRIM)
!
!                     CALL  Qremoval(RATE, FICE, FP_D, FP_I, Tparcel,  & 
!                           POL(L), QT,  NICE, NDROP, CVW_X, FPICE, &
!                           DT_LYR,  RIMM, CO_AUTO(I)) 
!
!
!
!!ice number tendency: -precip + freezin
!                     dNICE = -NICE*FP_I  + NIN     
!                     NICE  =  (NICE +dNICE*DT_LYR)*ETA(L+1)/ETA(L) !ice
!                     NICE =max(NICE, 0.0)
!
!
!!ice mass tendency: growth - precip
!                     dQICE = -QICE*FPICE + dQIG
!                     QICE  =  min((QICE + dQICE*DT_LYR)*ETA(L+1)/ETA(L), QT) !ice
!                     QICE=max(min(QT, QICE), 0.0)
!
!
!! Liquid Tendency: source/evap -  precip
!!dQLIQ = max((CLI-QICE), -QLIQ)/DT_LYR -QLIQ*max(RATE-FPICE, 0.0)
!! dQLIQ = CLI*(1.0-RATE*DT_LYR)/DT_LYR -dQICE - QLIQ*max(RATE-FPICE, 0.0)
!!QLIQ  =  max((QLIQ + dQLIQ*DT_LYR)*ETA(L+1)/ETA(L), 0.0) !liquid. This is actually diagnostic
!                     QLIQ=max((QT-QICE), 0.0)
!
!
!!droplet number tendency: -precip - freezin + activation + activated entrained aerosol
!
!
!                     dNDROP =-NDROP*FP_D - NIN -  FNDRIM*NDROP/DT_LYR + max(NDROP_ACT-NDROP, 0.0)/DT_LYR          
!
!!dNDROP =-NDROP*FP_D - NIN -  FNDRIM*NDROP/DT_LYR + NDROP_ACT/DT_LYR
!
!                     NDROP =  (NDROP + dNDROP*DT_LYR)*ETA(L+1)/ETA(L) + &
!                           (ZET(L) - ZET(L+1))*ALM*MAX((NDROP_AMB-NDROP), 0.0)
!
!!Aerosol tendency: Entrainment - freezing
!
!                     NDUST = (NDUST - INDUST*DT_LYR)*ETA(L+1)/ETA(L) + &
!                           (ZET(L) - ZET(L+1))*ALM*MAX(NDUST_AMB-NDUST, 0.0) 
!
!                     NSOOT =  (NSOOT - INSOOT*DT_LYR)*ETA(L+1)/ETA(L)  + &     
!                           (ZET(L) - ZET(L+1))*ALM*MAX(NSOOT_AMB-NSOOT, 0.0)  
!
!
!                           
!!Update FICE and perform Sanity checks
!
!
!                     MINNDROP = (1.0-FICE)*QLIQ*max(1.0-RATE*DT_LYR, 0.0)/2.e-10    !assuming maximum vol radius 36 microns
!                     MAXNDROP = (1.0-FICE)*QLIQ*max(1.0-RATE*DT_LYR, 0.0)/3.35e-14 !assuming minimum vol radius 2 microns
!                     MINNICE = QICE/4.0e-8!assuming maximum vol radius 250 microns
!                     MAXNICE = QICE/2.51e-12 !assuming minimum vol radius 10 microns
!
!                     IF ((NICE .gt. MAXNICE) .or. (NICE .lt. MINNICE))   then    
!!print *, 'nilim', NICE*1e-6, MINNICE*1e-6, MAXNICE*1e-6
!                     END IF
!
!                     IF ((NDROP .gt. MAXNDROP) .or. (NDROP .lt. MINNDROP))      then 
!!print *, 'ndroplim', NDROP*1e-6, MINNDROP*1e-6, MAXNDROP*1e-6
!                     end if
!
!
!                     NSOOT=MAX(NSOOT, 0.0)
!                     NDUST=MAX(NDUST, 0.0)              
!
!                     NDROP=MIN(max(NDROP, MINNDROP), MAXNDROP)
!                     NICE=MIN(max(NICE, MINNICE), MAXNICE)
!
!                     FICE=max(min(QICE/QT, 1.0), 0.0)
!
!                     IF (FICE .ge. 1.0) THEN !Complete glaciation
!                        NICE=NICE+NDROP 
!                        NDROP = 0.0
!                        QICE  = QT
!                        QLIQ= 0.0
!                     END IF
!
!                     IF (Tparcel .LT. T_ICE_ALL) THEN !instantaneous freezing
!                        NICE=NICE+NDROP 
!                        NDROP = 0.0
!                        FICE  = 1.0
!                        QICE  = QT
!                        QLIQ=0.0
!                     END IF
!
!                     IF (Tparcel .GT. T_ICE_MAX) THEN !instantaneous melting
!                        NDROP=NICE+NDROP 
!                        NICE = 0.0
!                        FICE  = 0.0
!                        QICE  = 0.0
!                        QLIQ=QT
!                     END IF
!
!                  END IF
!
!               else 
!
!                  FICE =0.0 
!                  QICE = 0.0
!                  QLIQ = 0.0
!                  NICE= 0.0 
!                  NDROP = 0.0
!                  RATE =0.0
!               end if
!
!               FPRECIP= RATE*DT_LYR
!
!!RATE=RATE*F4
!! NDROP=NDROP*F4
!!NICE=NICE*(1.0-F4)
!
!!print *, TE_A, FICE, 'NICE', NICE*1e-6, 'NDROP', NDROP*1e-6, L
!!print *, 'FPI', FP_I*DT_LYR, 'FPD', FP_D*DT_LYR, 'FPICE', FPICE, 'FPRE', FPRECIP, QT, QLIQ
!
!            else !Bacmeister 2006 microphysics
                  CALL SUNDQ3_ICE(te_a, sdqv2, sdqv3, sdqvt1, f2, f3)
! * F5  ! F4 reduces AUTO for shallow clouds, F5 modifies auto for deep clouds
                  c00_x = co_auto(i)*f2*f3*f4
                  cli_crit_x = cli_crit/(f2*f3)
                  arg1 = -(cli**2/cli_crit_x**2)
                  rate = c00_x*(1.0-EXP(arg1))
                  IF (cvw(l) .LT. 1.00) THEN
                    cvw_x = 1.00
                  ELSE
                    cvw_x = cvw(l)
                  END IF
! really trust it at low values
! l.h.s. DT_LYR => time in layer (L,L+1)
                  dt_lyr = (zet(l)-zet(l+1))/cvw_x
                  closs = cll0(l)*rate*dt_lyr
                  IF (closs .GT. cll0(l)) THEN
                    closs = cll0(l)
                  ELSE
                    closs = closs
                  END IF
                  cll0(l) = cll0(l) - closs
                  dll0(l) = closs
                  IF (closs .GT. 0.) THEN
                    wlq = wlq - closs
                    rnn(l) = closs
                  ELSE
                    rnn(l) = 0.
                  END IF
                END DO
!AER_CLOUD=======================================
!            CNVNDROP(IC)=NDROP
!            CNVNICE(IC)=NICE
!            CNVFICE(IC)=FICE
                wlq = wlq - qst(ic)*eta(ic)
!     CALCULATE GAMMAS AND KERNEL
! MS-A30 (W/O GRAV)
                gms(k) = (sht(k)-ssl(k))*pri(k)
! MS-A31 (W/O GRAV)
                gmh(k) = gms(k) + (qht(k)-qol(k))*pri(k)*alhl
! MS-A37 (W/O GRAV)
                akm = gmh(k)*gam(k-1)*dpb(k-1)
                tx2 = gmh(k)
                DO l=k-1,ic+1,-1
                  gms(l) = (eta(l)*(sht(l)-ssl(l))+eta(l+1)*(ssl(l)-sht(&
&                   l+1)))*pri(l)
                  gmh(l) = gms(l) + (eta(l)*(qht(l)-qol(l))+eta(l+1)*(&
&                   qol(l)-qht(l+1)))*alhl*pri(l)
                  tx2 = tx2 + (eta(l)-eta(l+1))*gmh(l)
                  akm = akm - gms(l)*eht(l)*pki(l) + tx2*ght(l)
                END DO
                gms(ic) = eta(ic+1)*(ssl(ic)-sht(ic+1))*pri(ic)
                akm = akm - gms(ic)*eta(ic+1)*dpb(ic)*pki(ic)
                gmh(ic) = gms(ic) + (eta(ic+1)*(qol(ic)-qht(ic+1))*alhl+&
&                 eta(ic)*(hst(ic)-hol(ic)))*pri(ic)
                IF (smooth_hst) gmhx = gms(ic) + (eta(ic+1)*(qol(ic)-qht&
&                   (ic+1))*alhl+eta(ic)*(hstx-hol(ic)))*pri(ic)
!    CLOUD BASE MASS FLUX
                IF (akm .GE. 0.0 .OR. wlq .LT. 0.0) THEN
!  =========>
                  rc(ic) = 5
                  RETURN
                ELSE
! MS-A39 MASS-FLUX IN Pa/step
                  wfn = -((wfn-acr)/akm)
! WMP Store the full mass-flux to use in efficiency diagnostic
                  ras_wfn(i) = wfn
                  IF (tau(ic)*wfn .GT. (prs(k+1)-prs(k))*(100.*pblfrac)&
&                 ) THEN
                    wfn = (prs(k+1)-prs(k))*(100.*pblfrac)
                  ELSE
                    wfn = tau(ic)*wfn
                  END IF
!! WMP RAS DIAGNOSTICS that make up TAU(IC)
! Fill the RAS timescale diagnostic
                  ras_time(i) = rasal(ic)
! Fill the RAS RH trigger diagnostic
                  ras_trg(i) = trg
! Fill the RAS Tokioka diagnostic
                  ras_toki(i) = toki
! Fill the RAS PBL fraction diagnostic
                  ras_pbl(i) = (prs(k+1)-prs(k))*(100.*pblfrac)
! Fill the RAS efficiency diagnostic
! RAS_EFFICIENCY(I) = WFN/RAS_EFFICIENCY(I)
!! WMP RAS DIAGNOSTICS
!    CUMULATIVE PRECIP AND CLOUD-BASE MASS FLUX FOR OUTPUT
                  wfnog = wfn*gravi
                  tem = wfn*gravi
! (kg/m^2/step)
                  cll(ic) = cll(ic) + wlq*tem
! (kg/m^2/step)
                  rmf(ic) = rmf(ic) + tem
! (kg/m^2/step)
                  rmfd(ic) = rmfd(ic) + tem*eta(ic)
                  DO l=ic+1,k
! (kg/m^2/step)
                    rmfp(l) = tem*eta(l)
! (kg/m^2/step)
                    rmfc(l) = rmfc(l) + rmfp(l)
                    dllx(l) = dllx(l) + tem*dll0(l)
                    IF (cvw(l) .GT. 0.0) THEN
                      updfrp(l) = rmfp(l)*(ddt/daylen)*1000./(cvw(l)*prs&
&                       (l))
                    ELSE
                      updfrp(l) = 0.0
                    END IF
! current cloud; incloud condensate
                    clli(l) = cll0(l)/eta(l)
!  cumulative grid mean convective condensate
                    cllb(l) = cllb(l) + updfrp(l)*clli(l)
                    updfrc(l) = updfrc(l) + updfrp(l)
                  END DO
!    THETA AND Q CHANGE DUE TO CLOUD TYPE IC
                  DO l=ic,k
! (kg/m^2/step)
                    rns(l) = rns(l) + rnn(l)*tem
                    gmh(l) = gmh(l)*wfn
                    gms(l) = gms(l)*wfn
                    qoi(l) = qoi(l) + (gmh(l)-gms(l))*alhi
                    poi(l) = poi(l) + gms(l)*pki(l)*cpi
                    qst(l) = qst(l) + gms(l)*bet(l)*cpi
                  END DO
                  IF (smooth_hst) THEN
                    gmhx = gmhx*wfn
                    dqx = (gmhx-gmh(ic))*alhi
                    rns(ic) = rns(ic) + dqx/(pri(ic)*grav)
                  END IF
                  IF (do_tracers) THEN
!*FRICFAC*0.5
                    wfn = wfn*0.5*1.0
                    tem = wfn*pri(k)
                    DO itr=1,itrcr
                      xcu(k, itr) = xcu(k, itr) + tem*(xoi(k-1, itr)-xoi&
&                       (k, itr))
                    END DO
                    DO itr=1,itrcr
                      DO l=k-1,ic+1,-1
                        tem = wfn*pri(l)
                        xcu(l, itr) = xcu(l, itr) + tem*((xoi(l-1, itr)-&
&                         xoi(l, itr))*eta(l)+(xoi(l, itr)-xoi(l+1, itr)&
&                         )*eta(l+1))
                      END DO
                    END DO
                    tem = wfn*pri(ic)
                    DO itr=1,itrcr
                      xcu(ic, itr) = xcu(ic, itr) + (2.*(xht(itr)-xoi(ic&
&                       , itr)*(eta(ic)-eta(ic+1)))-(xoi(ic, itr)+xoi(ic&
&                       +1, itr))*eta(ic+1))*tem
                    END DO
                    DO itr=1,itrcr
                      DO l=ic,k
                        xoi(l, itr) = xoi(l, itr) + xcu(l, itr)
                      END DO
                    END DO
                  ELSE
!*FRICFAC*0.5
                    wfn = wfn*0.5*1.0
                  END IF
                  lambdsv(ic) = 1.000
!   CUMULUS FRICTION
                  IF (fricfac .LE. 0.0) THEN
                    rc(ic) = 0
!  NO CUMULUS FRICTION =========>>
                    RETURN
                  ELSE
                    wfn = wfn*fricfac*EXP(-(alm/friclambda))
                    tem = wfn*pri(k)
                    ucu(k) = ucu(k) + tem*(uoi(k-1)-uoi(k))
                    vcu(k) = vcu(k) + tem*(voi(k-1)-voi(k))
                    DO l=k-1,ic+1,-1
                      tem = wfn*pri(l)
                      ucu(l) = ucu(l) + tem*((uoi(l-1)-uoi(l))*eta(l)+(&
&                       uoi(l)-uoi(l+1))*eta(l+1))
                      vcu(l) = vcu(l) + tem*((voi(l-1)-voi(l))*eta(l)+(&
&                       voi(l)-voi(l+1))*eta(l+1))
                    END DO
                    tem = wfn*pri(ic)
                    ucu(ic) = ucu(ic) + (2.*(uht-uoi(ic)*(eta(ic)-eta(ic&
&                     +1)))-(uoi(ic)+uoi(ic+1))*eta(ic+1))*tem
                    vcu(ic) = vcu(ic) + (2.*(vht-voi(ic)*(eta(ic)-eta(ic&
&                     +1)))-(voi(ic)+voi(ic+1))*eta(ic+1))*tem
                    dissk0(ic) = eta(ic)*grav*wfnog*pri(ic)*0.5*((uht/&
&                     eta(ic)-uoi(ic))**2+(vht/eta(ic)-voi(ic))**2)
                    DO l=ic,k
                      uoi(l) = uoi(l) + ucu(l)
                      voi(l) = voi(l) + vcu(l)
                    END DO
                    rc(ic) = 0
                    RETURN
                  END IF
                END IF
              END IF
            END IF
          END IF
        END IF
      END IF
    END SUBROUTINE CLOUDE
    SUBROUTINE ACRITN(pl, plb, acr)
      IMPLICIT NONE
      REAL, INTENT(IN) :: pl, plb
      REAL, INTENT(OUT) :: acr
      INTEGER :: iwk
!!REAL, PARAMETER :: FACM=0.5
      REAL, PARAMETER :: ph(15)=(/150.0, 200.0, 250.0, 300.0, 350.0, &
&       400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, &
&       850.0/)
!!*FACM
      REAL, PARAMETER :: a(15)=(/1.6851, 1.1686, 0.7663, 0.5255, 0.4100&
&       , 0.3677, 0.3151, 0.2216, 0.1521, 0.1082, 0.0750, 0.0664, 0.0553&
&       , 0.0445, 0.0633/)
      INTRINSIC INT
      iwk = INT(pl*0.02 - 0.999999999)
      IF (iwk .GT. 1 .AND. iwk .LE. 15) THEN
        acr = a(iwk-1) + (pl-ph(iwk-1))*.02*(a(iwk)-a(iwk-1))
      ELSE IF (iwk .GT. 15) THEN
        acr = a(15)
      ELSE
        acr = a(1)
      END IF
      acr = acritfac*acr*(plb-pl)
      RETURN
    END SUBROUTINE ACRITN
    SUBROUTINE RNEVP()
      IMPLICIT NONE
      zet(k+1) = 0
      DO l=k,icmin,-1
        tem = poi(l)*(prj(l+1)-prj(l))*cpbg
        zet(l) = zet(l+1) + tem
      END DO
      DO l=icmin,k
        tem = pri(l)*grav
        cnv_prc3(i, l) = rns(l)*tem
      END DO
!! If hst is smoothed then adjusted precips may be negative
      IF (smooth_hst) THEN
        DO l=icmin,k
          IF (cnv_prc3(i, l) .LT. 0.) THEN
            qoi(l) = qoi(l) + cnv_prc3(i, l)
            poi(l) = poi(l) - cnv_prc3(i, l)*(alhl/cp)/prj(l+1)
            cnv_prc3(i, l) = 0.
          END IF
        END DO
      END IF
      RETURN
    END SUBROUTINE RNEVP
    SUBROUTINE HTEST()
      IMPLICIT NONE
      REAL, DIMENSION(k0) :: hol1
      INTEGER :: lminhol
      REAL :: minhol
      INTRINSIC AMIN1
      INTRINSIC AMAX1
! HOL initialized here in order not to confuse Valgrind debugger
      hol = 0.
      lminhol = k + 1
      minhol = -999999.
      zet(k+1) = 0
      sht(k+1) = cp*poi(k)*prj(k+1)
      DO l=k,icmin,-1
        IF (qst(l)*rhmax .GT. qoi(l)) THEN
          qol(l) = qoi(l)
        ELSE
          qol(l) = qst(l)*rhmax
        END IF
        IF (0.000 .LT. qol(l)) THEN
          qol(l) = qol(l)
        ELSE
          qol(l) = 0.000
        END IF
        ssl(l) = cp*prj(l+1)*poi(l) + grav*zet(l+1)
        hol(l) = ssl(l) + qol(l)*alhl
        hst(l) = ssl(l) + qst(l)*alhl
        tem = poi(l)*(prj(l+1)-prj(l))*cpbg
        zet(l) = zet(l+1) + tem
        zol(l) = zet(l+1) + (prj(l+1)-prh(l))*poi(l)*cpbg
      END DO
      hol1 = hol
      DO l=k-1,icmin+1,-1
        hol1(l) = 0.25*hol(l+1) + 0.50*hol(l) + 0.25*hol(l-1)
        IF (minhol .GE. hol1(l) .OR. minhol .LT. 0.) THEN
          minhol = hol1(l)
          lminhol = l
        END IF
      END DO
      sige_minhol = sige(lminhol)
    END SUBROUTINE HTEST
    SUBROUTINE FINDDTLS()
      IMPLICIT NONE
      REAL :: sigdt0, sigmax, sigmin
      INTEGER :: ll
      INTEGER, ALLOCATABLE :: the_seed(:)
      INTEGER :: seed_len
      INTRINSIC RANDOM_SEED
      INTRINSIC INT
      INTRINSIC MIN
      INTRINSIC ALLOCATED
      INTRINSIC RANDOM_NUMBER
      REAL :: pwr1
      INTEGER :: x1
      seed_len = 0
      CALL RANDOM_SEED(size=seed_len)
      ALLOCATE(the_seed(seed_len))
      the_seed(1) = seedras(i, 1)*iras(i) + seedras(i, 2)*jras(i)
      the_seed(2) = seedras(i, 1)*jras(i) + seedras(i, 2)*iras(i)
      the_seed(1) = the_seed(1)*seedras(i, 1)/(seedras(i, 2)+10)
      the_seed(2) = the_seed(2)*seedras(i, 1)/(seedras(i, 2)+10)
      IF (the_seed(1) .EQ. 0) the_seed(1) = 5
      IF (the_seed(2) .EQ. 0) the_seed(2) = -5
! Gfortran uses longer seeds, so fill the rest with zero
      IF (seed_len .GT. 2) the_seed(3:) = 0
      CALL RANDOM_SEED(put=the_seed)
      sigmax = sige(k)
      sigmin = sige(icmin)
      IF (rasncl .LT. 0.0) THEN
!! NO SHALLOW CONV   N_DTL = 56 - ICMIN
        n_dtl = k - icmin
      ELSE
        x1 = INT(rasncl)
        IF (x1 .GT. k - icmin) THEN
          n_dtl = k - icmin
        ELSE
          n_dtl = x1
        END IF
      END IF
      IF (ALLOCATED(icl_v)) THEN
        DEALLOCATE(icl_v)
      END IF
      ALLOCATE(icl_v(n_dtl))
      IF (rasncl .LT. 0.0 .AND. rasncl .GE. -100.) THEN
        DO l=1,n_dtl
          icl_v(l) = icmin + l - 1
        END DO
      ELSE IF (rasncl .LT. -100.0) THEN
        DO l=1,n_dtl
          icl_v(l) = k - l
        END DO
      ELSE
!! NO SHALLOW CONV           ICL_V(L) = 56 - L
        DO l=1,n_dtl
          CALL RANDOM_NUMBER(sigdt0)
          pwr1 = sigdt0**rdtlexpon
          sigdt0 = 1.00 - pwr1
          sigdt0 = sigmin + sigdt0*(sigmax-sigmin)
          DO ll=icmin,k
            IF (sige(ll+1) .GE. sigdt0 .AND. sige(ll) .LT. sigdt0) icl_v&
&             (l) = ll
          END DO
        END DO
      END IF
      DEALLOCATE(the_seed)
    END SUBROUTINE FINDDTLS
    SUBROUTINE STRAP(final)
      IMPLICIT NONE
      INTEGER :: final
      REAL, DIMENSION(k0) :: wght, massf
      REAL :: wght0, prcbl
      INTEGER, PARAMETER :: nrands=1
      REAL :: rndu(nrands)
      INTEGER :: seedcbl(nrands)
! !DESCRIPTION:
!   {\tt STRAP} is called: FINAL=0, to compute cloud base layer CBL properties
!   given a value K for the index of the upper {\em EDGE} of the CBL; FINAL=1
!   to redistribute convective tendencies within CBL
      INTEGER :: kk
      INTRINSIC SQRT
      INTRINSIC MAX
      INTRINSIC ABS
      INTRINSIC PRESENT
      INTRINSIC ALLOCATED
      REAL :: abs0
      REAL :: abs1
      REAL, DIMENSION(k-icmin+1) :: arg1
      REAL :: pwx1
      REAL :: pwy1
      REAL :: pwr1
!  LOCAL VARIABLES FOR USE IN CLOUDE
!!IF (.NOT. PRESENT(FINAL)) THEN
      IF (final .EQ. 0) THEN
!!PRJ(ICMIN:K+1) = PKE(I,ICMIN:K+1)
        DO kk=icmin,k+1
          prj(kk) = pke(i, kk)
        END DO
! These initialized here in order not to confuse Valgrind debugger
        poi = 0.
! Do not believe it actually makes any difference.
        qoi = 0.
        uoi = 0.
        voi = 0.
        prs(icmin:k0+1) = ple(i, icmin:k0+1)
        poi(icmin:k) = tho(i, icmin:k)
        qoi(icmin:k) = qho(i, icmin:k)
        uoi(icmin:k) = uho(i, icmin:k)
        voi(icmin:k) = vho(i, icmin:k)
        arg1(:) = (uoi(icmin:k)-uoi(k))**2 + (voi(icmin:k)-voi(k))**2
        wsp(icmin:k) = SQRT(arg1(:))
        qst(icmin:k) = qss(i, icmin:k)
        dqq(icmin:k) = dqs(i, icmin:k)
        IF (do_tracers) THEN
          DO itr=1,itrcr
            xoi(icmin:k, itr) = xho(i, icmin:k, itr)
          END DO
        END IF
!!! Mass fraction of each layer below cloud base
!!! contributed to aggregate cloudbase layer (CBL)
        massf(:) = wgt0(i, :)
!!! RESET PRESSURE at bottom edge of CBL
        prcbl = prs(k)
        DO l=k,k0
          prcbl = prcbl + massf(l)*(prs(l+1)-prs(l))
        END DO
        prs(k+1) = prcbl
        pwx1 = prs(k+1)/1000.
        pwy1 = mapl_rgas/mapl_cp
        prj(k+1) = pwx1**pwy1
        DO l=k,icmin,-1
          pol(l) = 0.5*(prs(l)+prs(l+1))
          prh(l) = (prs(l+1)*prj(l+1)-prs(l)*prj(l))/(onepkap*(prs(l+1)-&
&           prs(l)))
          pki(l) = 1.0/prh(l)
          dpt(l) = prh(l) - prj(l)
          dpb(l) = prj(l+1) - prh(l)
          pri(l) = .01/(prs(l+1)-prs(l))
        END DO
!!!!! RECALCULATE PROFILE QUAN. IN LOWEST STRAPPED LAYER
        IF (k .LE. k0) THEN
          poi(k) = 0.
          qoi(k) = 0.
          uoi(k) = 0.
          voi(k) = 0.
!! SPECIFY WEIGHTS GIVEN TO EACH LAYER WITHIN SUBCLOUD "SUPERLAYER"
          wght = 0.
          DO l=k,k0
            wght(l) = massf(l)*(ple(i, l+1)-ple(i, l))/(prs(k+1)-prs(k))
          END DO
          DO l=k,k0
            poi(k) = poi(k) + wght(l)*tho(i, l)
            qoi(k) = qoi(k) + wght(l)*qho(i, l)
            uoi(k) = uoi(k) + wght(l)*uho(i, l)
            voi(k) = voi(k) + wght(l)*vho(i, l)
          END DO
          IF (do_tracers) THEN
            xoi(k, :) = 0.
            DO itr=1,itrcr
              DO l=k,k0
                xoi(k, itr) = xoi(k, itr) + wght(l)*xho(i, l, itr)
              END DO
            END DO
          END IF
          dqq(k) = DQSAT(poi(k)*prh(k), pol(k), qsat=qst(k))
        END IF
        WHERE (seedras(i, 1)/1000000. .LT. 1e-6) 
          rndu(:) = 1e-6
        ELSEWHERE
          rndu(:) = seedras(i, 1)/1000000.
        END WHERE
!!call congvec( npoints , seedcbl , rndu )
        dpth_bl = zcbl(i)
        IF (maxdallowed_d .GE. 0.) THEN
          abs0 = maxdallowed_d
        ELSE
          abs0 = -maxdallowed_d
        END IF
        IF (maxdallowed_s .GE. 0.) THEN
          abs1 = maxdallowed_s
        ELSE
          abs1 = -maxdallowed_s
        END IF
        mxdiam(i) = cnv_fraction(i)*abs0 + (1-cnv_fraction(i))*abs1
        IF (maxdallowed_e .LT. 0) THEN
! Make MXDIAM stochastic
          pwr1 = rndu(1)**maxdallowed_e
          mxdiam(i) = mxdiam(i)*pwr1
        END IF
        DO l=k,icmin,-1
!*
          bet(l) = dqq(l)*pki(l)
!*
          gam(l) = pki(l)/(1.0+lbcp*dqq(l))
          IF (l .LT. k) THEN
            ght(l+1) = gam(l)*dpb(l) + gam(l+1)*dpt(l+1)
            gm1(l+1) = 0.5*lbcp*(dqq(l)/(alhl*(1.0+lbcp*dqq(l)))+dqq(l+1&
&             )/(alhl*(1.0+lbcp*dqq(l+1))))
          END IF
        END DO
        tcu(icmin:k) = -(poi(icmin:k)*prh(icmin:k))
        qcu(icmin:k) = -qoi(icmin:k)
        rns = 0.
        cll = 0.
        rmf = 0.
        rmfd = 0.
        rmfc = 0.
        rmfp = 0.
        cll0 = 0.
        dll0 = 0.
        cllx = 0.
        dllx = 0.
        clli = 0.
        cllb = 0.
        poi_sv = poi
        qoi_sv = qoi
        uoi_sv = uoi
        voi_sv = voi
        IF (do_tracers) xoi_sv = xoi
        lambdsv = 0.0
        cvw = 0.0
        updfrc = 0.0
        updfrp = 0.0
        dissk0 = 0.0
      END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!    IF (PRESENT(FINAL)) THEN
      IF (final .EQ. 1) THEN
        tho(i, icmin:k-1) = poi(icmin:k-1)
        qho(i, icmin:k-1) = qoi(icmin:k-1)
        uho(i, icmin:k-1) = uoi(icmin:k-1)
        vho(i, icmin:k-1) = voi(icmin:k-1)
        cnv_updfrc(i, icmin:k-1) = updfrc(icmin:k-1)
        cnv_cvw(i, icmin:k-1) = cvw(icmin:k-1)
        cnv_qc(i, icmin:k-1) = cllb(icmin:k-1)
!======================AER_CLOUD=============
!               CNV_NDROP   (I,ICMIN:K-1)  =    CNVNDROP(ICMIN:K-1) !DONIF
!               CNV_NICE   (I,ICMIN:K-1)   =     CNVNICE(ICMIN:K-1) !DONIF
!               CNV_FICE   (I,ICMIN:K-1)   =     CNVFICE(ICMIN:K-1) !DONIF
!! De-strap tendencies from RAS
!! specify weighting "SHAPE"
        wght = wgt1(i, :)
!! Scale properly by layer masses
        wght0 = 0.
        DO l=k,k0
          wght0 = wght0 + wght(l)*(ple(i, l+1)-ple(i, l))
        END DO
        wght0 = (prs(k+1)-prs(k))/wght0
        wght = wght0*wght
        DO l=k,k0
          tho(i, l) = tho(i, l) + wght(l)*(poi(k)-poi_sv(k))
          qho(i, l) = qho(i, l) + wght(l)*(qoi(k)-qoi_sv(k))
          uho(i, l) = uho(i, l) + wght(l)*(uoi(k)-uoi_sv(k))
          vho(i, l) = vho(i, l) + wght(l)*(voi(k)-voi_sv(k))
        END DO
        IF (do_tracers) THEN
          xho(i, icmin:k-1, :) = xoi(icmin:k-1, :)
          DO itr=1,itrcr
            DO l=k,k0
              xho(i, l, itr) = xho(i, l, itr) + wght(l)*(xoi(k, itr)-&
&               xoi_sv(k, itr))
            END DO
          END DO
        END IF
!  (KG/m^2/s @ CLOUD BASE)
        flx(i, icmin:k) = rmf(icmin:k)*ddt/daylen
!  (KG/m^2/s @ CLOUD TOP)
        flxd(i, icmin:k) = rmfd(icmin:k)*ddt/daylen
!  (KG/m^2/s @ CLOUD TOP)
        flxc(i, icmin:k) = rmfc(icmin:k)*ddt/daylen
!  (KG/m^2/s )
        clw(i, icmin:k) = cll(icmin:k)*ddt/daylen
        IF (PRESENT(disske)) disske(i, icmin:k-1) = dissk0(icmin:k-1)*&
&           ddt/daylen
        flx(i, 1:icmin-1) = 0.
        flxd(i, 1:icmin-1) = 0.
        flxc(i, 1:icmin-1) = 0.
        clw(i, 1:icmin-1) = 0.
        IF (k .LT. k0) THEN
          flx(i, k:k0) = 0.
          flxd(i, k:k0) = 0.
          flxc(i, k:k0) = 0.
          clw(i, k:k0) = 0.
        END IF
        irc(i, icmin:k-1) = rc(icmin:k-1)
        IF (ALLOCATED(icl_v)) THEN
          DEALLOCATE(icl_v)
        END IF
      END IF
      IF (final .EQ. 2) THEN
        flx(i, :) = 0.
        flxd(i, :) = 0.
        flxc(i, :) = 0.
        clw(i, :) = 0.
        irc(i, icmin:k-1) = rc(icmin:k-1)
      END IF
      RETURN
    END SUBROUTINE STRAP
  END SUBROUTINE RASE
!  Differentiation of rase in forward (tangent) mode (with options r8):
!   variations   of useful results: clw cnv_prc3 tho qho vho cnv_updfrc
!                uho flxd
!   with respect to varying inputs: tho qho
!   RW status of diff variables: clw:out cnv_prc3:out tho:in-out
!                qho:in-out vho:out cnv_updfrc:out uho:out flxd:out
!!  RAS Relaxation Diagnostics
!!!!!AER_CLOUD
!DONIF
  SUBROUTINE RASE_TLM(idim, irun, k0, icmin, dt, cpo, alhlo, alhl1, tice&
&   , gravo, seedras, iras, jras, sige, kcbl, wgt0, wgt1, zcbl, mxdiam, &
&   tpert, qpert, tho, tho_tl, qho, qho_tl, uho, uho_tl, vho, vho_tl, &
&   qss, dqs, cnv_fraction, rasal2_2d, co_auto, pko, plo, phio, phie, &
&   qlo, qio, ple, pke, clw, clw_tl, flx, flxd, flxd_tl, flxc, cnv_prc3&
&   , cnv_prc3_tl, cnv_updfrc, cnv_updfrc_tl, cnv_cvw, cnv_qc, entlam, &
&   clan, hho, hso, precu, rasparams, ras_time, ras_trg, ras_toki, &
&   ras_pbl, ras_wfn, ras_alpha, ras_tau, aeroprops, cnv_fice, cnv_nice&
&   , cnv_ndrop, itrcr, irc, xho, triedlev_diag, fscav, disske)
    IMPLICIT NONE
! !!!!!!!!!!!!!!======================================
! !!!!!!!!!   Subroutine ARGact: finds the activated droplet number from Abdul_Razzak and Ghan 2000.
! ! Tailored for GOCART AEROSOL and works with AERO input
! !Written by Donifan Barahona
! !!donifan.o.barahona@nasa.gov
! !!!!!!!!!!!!!!====================================
! 
!       SUBROUTINE ARGact (TEMP, WX, NCPL_ACT, NCPL_AMB,  CDUST, CSOOT, LEV, ISBASE, DDUSTAMB, DSOOTAMB, ENT_PARAM)
! !
!          Integer, intent(in)     ::  LEV    
!          LOGICAL,  intent(in)     ::   ISBASE
! 
!          REAL, intent(inout)     ::   TEMP, WX, ENT_PARAM
!          REAL, intent(out)     ::   NCPL_ACT, NCPL_AMB, CSOOT, DSOOTAMB
!          REAL, DIMENSION(NDUSTMAX), INTENT(OUT) :: CDUST, DDUSTAMB
!          integer                 :: INDEX, NMODES, naux       
! 
!          type(AerProps)  :: AER, auxaer      
! 
! 
!          real     ::      kappa, alfa, beta, Akoh, G, T, smax, fi, gi, nui, &
!                        citai, ui, aux1, PACT,  Ntot, auxx, aux, auxconc, W, alph, aseasalt_aux, f_seasalt1
!          real, dimension (30) ::  SMI, TPI, SIGI 
! 
! 
!          SMI=0.0      
!          TPI = 0.0
!          SIGI =2.0
!          NCPL_ACT=0.0
!          NCPL_AMB=0.0
!          CDUST=0.0
!          CSOOT=0.0
!          DDUSTAMB =1.0e-9
!          DSOOTAMB= 1.0e-9
!          W=MIN(WX*(1.0-ENT_PARAM), 20.0)    
! 
!          PACT=0.0 !activation probability of entrained aerosol
! 
!          AER%nmods = 0
!          AER%num   = 0.0
! 
!          do INDEX = 1, AERO(LEV)%nmods
!              if (AERO(LEV)%num(INDEX) > 0.1) then
!                  AER%nmods = AER%nmods + 1
!                  naux = AER%nmods
! 
!                  AER%num(naux)   = AERO(LEV)%num(INDEX)
!                  AER%dpg(naux)   = max(AERO(LEV)%dpg(INDEX), 1.0e-9)
!                  AER%sig(naux)   = AERO(LEV)%sig(INDEX)
!                  AER%den(naux)   = AERO(LEV)%den(INDEX)
!                  AER%kap(naux)   = AERO(LEV)%kap(INDEX)
!                  AER%fdust(naux) = AERO(LEV)%fdust(INDEX)
!                  AER%fsoot(naux) = AERO(LEV)%fsoot(INDEX)
!                  AER%forg(naux)  = AERO(LEV)%forg(INDEX)
!              end if
!          end do
! 
!          if (AER%nmods == 0) then
!              call init_Aer(AER)
!          end if
! 
! !!!!!!!!!!activate aerosol transported from cloud base
!              NMODES =  AER_BASE%nmods
!              TPI(1:nmodes) = AER_BASE%num(1:nmodes)
!              SIGI(1:nmodes) = AER_BASE%sig(1:nmodes)                          
! 
!              
!              Ntot= 0.0
!               do index = 1, nmodes 
! 	              if (AER_BASE%kap(index) .gt. 0.1) Ntot =  Ntot + TPI(index)  
!               end do
!          
! 
!          if ((Ntot .lt. 1.0e4) .or. (TEMP .lt. 245.0) .or. (W .lt. 0.01)) then !no activation if aerosol < 1e-4 1/cm3
!             NCPL_ACT  = 0.0
!          else
! 
! ! Calculate constants. These fits were obtained from detailed correlations of physical properties. G is actually 1/G
!             T = min(max(TEMP, 243.0), 323.0)     
!             alfa=2.8915E-08*(T**2) - 2.1328E-05*T + 4.2523E-03
!             beta=exp(3.49996E-04*T**2 - 2.27938E-01*T + 4.20901E+01)
!             G=exp(-2.94362E-06*T**3 + 2.77941E-03*T**2 - 8.92889E-01*T + 1.18787E+02)
!             Akoh= 0.66e-6/T  !from Seinfeld and Pandis (1998)
!      
! !=======================================================
! !Activate droplets
! !=======================================================
! !Calculate maximum supersaturation according to ARG2002
! 
!             auxx=0.0 
!             
!             
!             DO INDEX = 1, NMODES            
!                 
!                kappa=  max(AER_BASE%kap(INDEX), 0.001)
!              
!                   SMI (INDEX) = ((0.667*Akoh/AER_BASE%dpg(INDEX))**1.5)/SQRT(2.0*kappa)   ! Critical supersat for mode I
!                   SMI=MAX(SMI, 1.0e-5)   
!                    
!               if ((TPI(INDEX) .gt. 1e4) .and.  (kappa .gt. 0.1)) then                       
!                   fi=0.5*exp(2.5*SIGI(INDEX)) !sigi is now log(sigi)
!                   gi=1.0+0.25*SIGI(INDEX)
!                   nui=((alfa*W*G)**1.5)/(2.0*MAPL_PI*980.0*beta*TPI(INDEX))
!                   citai = 0.667*Akoh*SQRT(alfa*W*G)
!                   aux1=fi*((citai/nui)**1.5) + gi*(SMI(INDEX)*SMI(INDEX)/(nui+(3.0*citai)))**0.75
!                   aux1=aux1/(SMI(INDEX)*SMI(INDEX))      
!                   auxx=auxx+aux1                  
!                 end if
!             end do
! 
! !Calculate number of activated droplets
!             if (auxx .gt. 0.0) then
!                smax = 1/sqrt(auxx)
!                auxx=0.0
! 
!                    DO INDEX = 1, NMODES
!                         if ((TPI(INDEX) .gt. 1e4) .and. (AER_BASE%kap(index) .gt. 0.1)) then
!                            ui=sqrt(2.0)*log(SMI(INDEX)/smax)/3.0
!                            aux1=0.5*TPI(INDEX)*(1.0-ERFAPP(ui))
!                            auxx=auxx+aux1
!                            AER_BASE%num(index) = max(TPI(INDEX) -aux1, 0.0) !remove already activated aerosol
!                         end if                    
!                    END DO
!                   NCPL_ACT=auxx             
!             else
!                   NCPL_ACT = 0.0             
!             end if
! 
!      
!  
!        end if
! 
! !now filllup dust and soot number
!          NMODES =  AER%nmods
! 
!          call getINsubset(1, AER,  auxaer)
!          CDUST(1:auxaer%nmods)= auxaer%num(1:auxaer%nmods)
!          DDUSTAMB(1:auxaer%nmods)= auxaer%dpg(1:auxaer%nmods)
!          call getINsubset(2, AER,  auxaer)
!          naux = max(auxaer%nmods, 1)
!          CSOOT= sum(auxaer%num) 
!          DSOOTAMB= sum(auxaer%dpg)/naux
! 
! 
!          PACT=1.0 ! fraction of entrained aerosol that is activated
!          auxconc =0.0
!          aseasalt_aux  = 0.0
! 
!          do index = 1, nmodes 
! 	       if (AER%kap(index) .gt. 0.8)  auxconc = AER%num(index) + auxconc
!            if (AER_BASE%kap(index) .gt. 0.8)    aseasalt_aux  = aseasalt_aux  + &
!            AER_BASE%num(index)*AER_BASE%dpg(index)*AER_BASE%dpg(index)*1.61*MAPL_PI !assumes a fixed sigma = 2.0
! 
!          end do
!        aseasalt = max(aseasalt, aseasalt_aux)
!      
! 	  NCPL_AMB=auxconc !Activate  entrained aerosol with kappa>0.8
! 
! 
! 
!       END SUBROUTINE ARGact
! 
! !!!!!!!!!!!!!!!!!!!!!!!!!!
! !=====Subroutine INfreezing=========
! ! Freeze droplets in immersion and contact ice nucleation modes, according to Barahona et al. GMD (2014)
! !!!!!!!!!!!!!!!!!!!!!
! 
!       subroutine INfreezing(QL, NL, NIN, NDUST, NSOOT, INDUST, INSOOT, TEMP, PRE, WSUB_, DDUST, DSOOT)  !NIN freezing tendency
!          REAL, INTENT( IN) :: TEMP, NSOOT, WSUB_, PRE, QL, NL, DSOOT
!          REAL, DIMENSION(NDUSTMAX), INTENT (IN) ::  NDUST, DDUST
!          REAL, DIMENSION(NDUSTMAX), INTENT (OUT) ::  INDUST
!          REAL, INTENT(OUT) ::  NIN, INSOOT 
!          REAL, DIMENSION(NDUSTMAX) ::  INDUST_C
! 
!          real :: a, b, c , d, Tx, n05, ui, aux, nssoot, nsdust, ninbkg, SI, acorr, &
!                dnsd, dnss, coolr, WSUB, ahet, INSOOT_C
! 
!          real :: nssoot_c, nsdust_c, mfp, nslip, ndfaer, viscosity, lam_r, taux, rho_a, &
!                 fdust_drop, fsoot_drop, min_ns_dust, min_ns_soot, nsss, INsea, dnsss, min_ns_seasalt 
! 
!          logical :: demott, Drop_mediated
!          integer :: ix
! 
!          min_ns_dust= 3.75e6 !limits ice nucleation to -12 !new 02/10/14
!          min_ns_soot= 3.75e9 !limits ice nucleation to -18
!          min_ns_seasalt = 4.0e2 !limits ice nucleation to -5
!          
!          demott=.false.
!          INDUST=0.0
!          INSOOT=0.0
!          INDUST_C=0.0
!          INSOOT_C=0.0   
!          NIN=0.0
!          Drop_mediated = .false.
!        INsea = 0.0 ! sea salt only in immersion
!    
!    
! ! note for sea salt we just assume that it is equal to the current droplet concentration and take the area 
! ! from the calculation at cloud base
! 
! ! fraction of dust and soot within droplets
!          fdust_drop= FDROP_DUST
!          fsoot_drop = FDROP_SOOT
! 
! 
!          WSUB=MAX(MIN(WSUB_, 10.0), 0.8)
!          coolr=5.0e-3*WSUB  !Approximation to saturated cooling rate
!          n05=sum(NDUST)+NSOOT
! 
!          if (TEMP .gt. T_ICE_MAX) then 
!             return
!          end if
! 
!          if (TEMP .lt. T_ICE_ALL   ) then 
!             return
!          end if
! 
! 
!          if ((QL .le. 1.0e-10) .or. (NL .le. 1.0)) then 
!             return
!          end if
! 
! !Background IN
! ! SI at water saturation
! 
!          rho_a = PRE*100.0/MAPL_RGAS/TEMP 
!          ninbkg=0.0
!          SI = -1.2379e-2+3.3595 !Ice supersat at water sat. Derived from Murphy and Koop 2005
! !if (TEMP .lt. 260.0)  ninbkg=coolr*42.8*exp(3.88*si)*0.1 !tendency in IN from background IN. Derived from Phillips et al. 2007
! 
! 
!          Tx = max(TEMP-273.16, -38.0 )
! 
!          lam_r=min((MAPL_PI*950.0*NL/rho_a/QL)**(1./3.), 1.0e8)
!          viscosity=1.8e-5*(TEMP/298.0)**0.85    ! Viscosity (kg/m/s)
!          mfp=2.0*viscosity/(PRE  &                   ! Mean free path (m)
!                *sqrt(8.0*28.96e-3/(MAPL_PI*8.314409*TEMP)))        
! 
!          if ((n05 .gt.1.0) .and. (TEMP .lt. 272.0)) then
! 
!             nsdust=  max(exp(-0.517*Tx + 8.934)-min_ns_dust, 0.0) !From Niemand 2012
!             nssoot= max(1.0e4*exp(-0.0101*Tx*Tx - 0.8525*Tx + 0.7667)-min_ns_soot, 0.0) !Murray (review_ 2012)
!             dnsd  = 0.517*nsdust
!             dnss  = max(-(-2.0*0.0101*Tx -0.8525)*nssoot, 0.0)
! 
! !ns in  contact. It is assumed that in contact is T-3 immersion
!             taux=max(Tx-3.0, -35.0)
!             nsdust_c= max(exp(-0.517*taux + 8.934)-min_ns_dust, 0.0) !From Niemand 2012
!             nssoot_c= max(1.0e4*exp(-0.0101*taux*taux - 0.8525*taux + 0.7667)-min_ns_soot, 0.0) !Murray (review_ 2012)
! 
!             aux=0.0        
!             acorr=2.7e7 !m2/m3 correction to the area due to non sphericity and aggregation. Assumes 10 m2/g (Murray 2011)
! 
! 
!             DO ix=1, NDUSTMAX
! !Immersion
!                ahet=0.52*DDUST(ix)*DDUST(ix)*DDUST(ix)*acorr*exp(4.5*log(2.0)*log(2.0)*log(2.0))    !this needs to be improved
! 
!                INDUST(ix) = NDUST(ix)*exp(-nsdust*ahet)* &
!                      dnsd*coolr*ahet*fdust_drop
! !Contact
!                nslip =1.0+(2.0*mfp/DDUST(ix))*(1.257+(0.4*exp(-(1.1*DDUST(ix)*0.5/mfp))))! Slip correction factor
!                ndfaer =1.381e-23*TEMP*nslip*(1.0-exp(-nsdust_c*ahet)) /(12.*MAPL_PI*viscosity*DDUST(ix))             
!                INDUST_C(ix) = 2.0*MAPL_PI*ndfaer*NDUST(ix)*NL/lam_r
! 
!             END DO
! 
! 
!             acorr=8.0e7 !m2/m3 correction to the area due to non sphericity and aggregation  Assumes 50 m2/g (Popovicheva 2003)
!             ahet =0.52*DSOOT*DSOOT*DSOOT*acorr*exp(4.5*log(2.0)*log(2.0)*log(2.0))             
!             INSOOT=fsoot_drop*NSOOT*exp(-nssoot*ahet)*dnss*ahet*coolr !
! 
!             nslip =1.0+(2.0*mfp/DSOOT)*(1.257+(0.4*exp(-(1.1*DSOOT*0.5/mfp))))! Slip correction factor
!             ndfaer =1.381e-23*TEMP*nslip*(1.0-exp(-nssoot_c*ahet)) /(12.*MAPL_PI*viscosity*DSOOT)             
!             INSOOT_c= 2.0*MAPL_PI*ndfaer*NSOOT*NL/lam_r
! 
! ! sea salt
!          nsss =  -0.459*TEMP +128.6235 ! from Demott et al. PNAS, 2015
!          nsss=  max(exp(nsss)-min_ns_seasalt, 0.0)           
!     	 dnsss=  max(0.459*nsss, 0.0)
!          INsea= aseasalt*dnsss*coolr 
! 
!  
!          end if
! 
! 	    NIN =ninbkg+ INSOOT + SUM(INDUST) + INSOOT_C + SUM(INDUST_C) + INsea!
!          INSOOT=INSOOT +INSOOT_C
!          INDUST =INDUST + INDUST_C
! 
! 	    
!       end subroutine INfreezing
! 
! 
! 
! 
! !!!!!!!!!!!!!!!!!!!!!!!!!!
! !===================Subroutine Qgrowth======================
! !Partitions water and ice according to Korolev and Mazin 2005. Assume spheres by now.
! !!!!!!!!!!!!!!!!!!!!
!       subroutine Qgrowth(TEMP, PRE, QICE0, NIPRE, QT, NINUC, DQIG, RIM, FNDRIM) 
! !freezing of IN according to Demott et al 2010 (everything SI)
!          REAL, INTENT(IN) :: TEMP, QICE0, NIPRE, NINUC,  PRE, QT
!          REAL, INTENT(INOUT) :: DQIG, RIM, FNDRIM
! 
! !real :: A, denI, aux, Dco, SI, denA, DQold, DQnew
!          real :: DIFF, DENICE, DENAIR, K1, K2, K3, SI, AUX, DC, TEFF, PLo, TEo, TC, &
!                DQnew, DQold, rho_a, LWC, IWC, qmin_rim
! 
! 
!          if (TEMP .gt. 272.15) then
!             DQIG =0.0
!             return
!          end if
! 
!          TC=TEMP-273.0 
!          PLo = max(PRE, 10.0) !limits  of the correlations
!          TEo = max(190.0, TEMP)
! 
!          qmin_rim = 1.0e-12
! 
! 
!          DENICE= 1000.0*(0.9167 - 1.75e-4*TC -5.0e-7*TC*TC) !From PK 97
!          DENAIR= PLo*100.0/MAPL_RGAS/TEMP
!          DIFF=(0.211*1013.25/(PLo+0.1))*(((TEo+0.1)/273.0)**1.94)*1e-4  !From Seinfeld and Pandis 2006
! 
!          K1 = EXP(7.1170e-4*TEo*TEo-0.43563*TEo+78.744) 
!          K2 = EXP(-9.933e-3*TEo+25.26)
!          K3 = EXP(7.1772e-4*TEo*TEo-0.44055*TEo+73.996)
! 
! 
!          AUX= 210368.0 + 131.438*TEMP - (3.32373E6/TEMP)- (41729.1*LOG(TEMP)) !From Murphy and Koop 2005
!          SI=exp(-aux/8.314/TEMP)-1.0 !ratio of pw/pi-1
!          rho_a = PRE*100.0/MAPL_RGAS/TEMP 
! 
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 
!          if  ((NIPRE .gt. 1.0) .and. (QICE0 .gt. 1.0e-10)) then 
!             DC=max((QICE0/(NIPRE*500.0*MAPL_PI))**(0.333), 40.0e-6) 
! !Assumme monodisperse size distribution about size distribution is made.
!          else   
!             DC = 40.0e-6
!          end if
! 
!          AUX=  NIPRE*DENICE*MAPL_PI*DC*DC
!          TEFF = DENAIR*2.0*((K1*DIFF+K2)*DC+(K3/0.1))
! 
!          if  (AUX .gt. 1.0e-12) then 
!             TEFF=min(TEFF/AUX, 1.0e20)   
!             DQold= SI/TEFF  
!          else
!             DQold=0.0
!          end if
! 
! ! Calculate rimming fraction
!          IWC =  QICE0*rho_a
!          LWC =  max(QT-QICE0, 0.0)*rho_a
!          aux = DQold ! only due to deposition
! 
! 
! !Account for rimming
! 
!          if ((LWC .gt. qmin_rim)  .and. (IWC .gt. qmin_rim))  then 
!             RIM = 6.0e-5/(LWC*(IWC**0.17)) !Fom Lin and Colle, NRW, 2011
!             RIM = 1.0/(1.0+RIM)
!             RIM  = min (0.95, RIM)
!             DQold =  DQold*(1 + RIM/(1.0-RIM))
!             FNDrim =  max(min(rho_a*(DQold -aux)/LWC, 1.0), 0.0) !Fraction of liquid condensate removed due to riming
!          END if
! 
! 
! 
! 
! !!!!!!!!!!!!!!!!!!!!!recently nucleated!!!!!!!!!!!!!!!!!!!!!!!!
! 
! 
!          AUX=  NINUC*DENICE*MAPL_PI*20.0e-6*20.0e-6
!          TEFF = DENAIR*2.0*((K1*DIFF+K2)*DC+(K3/0.1))
! 
!          if  (AUX .gt. 1.0e-12)  then 
!             TEFF=min(TEFF/AUX, 1.0e10)
!             DQnew= SI/TEFF
!          else
!             DQnew = 0.0
!          end if
! 
!          DQIG = DQold+DQnew     
! 
!       end subroutine Qgrowth
! 
! 
! 
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 
! !*************************************************************
! ! Function PDG07 (simplified background ice nucleation
! !                     spectra according to Phillips et. al. 2007).
! ! si is supersaturation wrt ice and T is in K
! !************************************************************
! 
!       subroutine PDG07_ice(si, Tx, N)     
! 
!          real, intent(in) :: si, Tx
!          real, intent(out)  :: N 
!          N=0.0
! 
! !if (Tx .le. 243.0)then
! 
! 
!          N=1000.0*exp(-0.388)*(exp(3.88*si)-1.0)/0.76
! !elseif (Tx .le. 260.0) then
! !  N=60.0*exp(-0.639)*(exp(12.96*si)-1.0)/0.76
! !end if
!       end subroutine PDG07_ice
! 
! 
! !*********************************************************************
! 
!*********************************************************************
!*********************************************************************
!******************** Relaxed Arakawa-Schubert ***********************
!************************ Parameterization ***************************
!********************** SCALAR RAS-1 VERSION  ************************
!************************* 31 DECEMBER 1999 **************************
!*********************************************************************
!************************** Developed By *****************************
!*********************************************************************
!************************ Shrinivas Moorthi **************************
!******************************* and *********************************
!************************** Max J. Suarez ****************************
!*********************************************************************
!******************** Laboratory for Atmospheres *********************
!****************** NASA/GSFC, Greenbelt, MD 20771 *******************
!*********************************************************************
!*********************************************************************
!  Input:
!  ------
!
!     K0      : Number of vertical levels (increasing downwards)
!
!     DT      : Time step in seconds
!
!     RASAL   : Array of dimension K-1 containing relaxation parameters
!               for cloud-types detraining at those levels
!
!     CPO     : Specific heat at constant pressure (J/kg/K)
!
!     ALHLO   : Latent Heat of condensation (J/kg)
!
!     ALHL1   : Latent Heat of condensation + fusion (J/kg)
!
!     GRAVO   : Acceleration due to gravity (m/s^2)
!
!     PLE     : 2D array of dimension (IDIM,K0+1) containing pressure
!               in hPa at the interfaces of K-layers from top of the
!               atmosphere to the bottom  (mb)
!
!     PKE     : 2D array of dimension (IDIM,K0+1) containing (PRS/P00) **
!               RKAP.  i.e. Exner function at layer edges.
!
!     PKL     : 2D array of dimension (IDIM,K0) ) containing the
!               Exner function at the layers.
!
!     QSS     : 2D array of dimension (IDIM,K0  ) containing the
!               saturation specific humidity at the layers. (kg/kg)
!
!     DQS     : 2D array of dimension (IDIM,K0  ) containing
!               d(qss)/dt at the layers.  (1/K)
!
!     CNV_FRACTION    : 1D array of dimension (IDIM) containing
!               fraction of grid cell considered to be convective
!
!  Update:
!  -------
!
!     THO     : 2D array of dimension (IDIM,K0) containing potential
!               temperature (K)
!
!     QHO     : 2D array of dimension (IDIM,K0) containing specific
!               humidity (kg/kg)
!
!     UHO     : 2D array of dimension (IDIM,K0) containing u-wind (m/s)
!
!     VHO     : 2D array of dimension (IDIM,K0) containing v-wind (m/s)
!
!  Output:
!  -------
!!
!     CLW     : 2D array of dimension (IDIM,K0) containing the
!               detrained cloud liquid water.  (kg/m^2/s)
!
!     FLX     : 2D array of dimension (IDIM,K0) containing the
!               cloud-base mass flux for each cloud type ordered by
!               detrainment level.   (kg/m^2/s)
!
!     FLXD    : 2D array of dimension (IDIM,K0) containing the
!               detrained  mass flux for each cloud type ordered by
!               detrainment level.   (kg/m^2/s)
!
!     FLXC    : 2D array of dimension (IDIM,K0+1) containing the
!               total cloud mass flux for all cloud types through
!               the top of each level. (e.g., FLXC(K)=SUM(FLX(ICMIN:K))
!               and  FLXD(L) = FLXC(L+1)-FLSD(L) )
!                (kg/m^2/s)
!
!     PRECU   : 1D (IDIM) Locally-handled convective precip
!               Zero if older version of RAS-1 is used. Nonzero if
!               RAS-2 is used.
!
!   AEROPROPS, Structure containing aerosol propoerties (in)
!   CNV_NICE, CNV_DROP.  Flux of ice crystals and droplet number at det level (1/m^2/s) (out)
!   CNV_FICE: Ice fraction in the detrained condensate (out)
!************************************************************************
!  ARGUMENTS
    INTEGER, INTENT(IN) :: idim, irun, k0, icmin
    REAL, DIMENSION(idim, k0), INTENT(INOUT) :: tho, qho, uho, vho, qlo&
&   , qio, clan
    REAL, DIMENSION(idim, k0), INTENT(INOUT) :: tho_tl, qho_tl, uho_tl, &
&   vho_tl
    REAL, DIMENSION(idim, k0+1), INTENT(IN) :: ple, pke, phie
    REAL, DIMENSION(idim, k0), INTENT(IN) :: qss, dqs, plo, pko, phio
    REAL, DIMENSION(idim), INTENT(IN) :: cnv_fraction, rasal2_2d
    REAL, DIMENSION(k0+1), INTENT(IN) :: sige
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: flx, clw, flxd
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: clw_tl, flxd_tl
    REAL, DIMENSION(idim, k0+1), INTENT(OUT) :: flxc
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: cnv_prc3
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: cnv_prc3_tl
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: cnv_updfrc, cnv_qc, &
&   cnv_cvw
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: cnv_updfrc_tl
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: entlam
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: hho, hso
    REAL, INTENT(IN) :: dt, cpo, alhlo, gravo
    REAL, INTENT(IN) :: alhl1, tice
    INTEGER, INTENT(IN) :: itrcr
    INTEGER, DIMENSION(idim, 2), INTENT(IN) :: seedras
    INTEGER, DIMENSION(idim), INTENT(IN) :: iras, jras, kcbl
    REAL, DIMENSION(idim), INTENT(IN) :: zcbl, tpert, qpert
    REAL, DIMENSION(idim), INTENT(IN) :: co_auto
    REAL, DIMENSION(idim), INTENT(OUT) :: mxdiam
    REAL, DIMENSION(idim), INTENT(OUT) :: precu
    REAL, DIMENSION(idim, k0), INTENT(IN) :: wgt0, wgt1
!     REAL, DIMENSION(:),          INTENT(IN   ) ::  RASPARAMS
    TYPE(RASPARAM_TYPE), INTENT(IN) :: rasparams
    REAL, DIMENSION(idim), INTENT(OUT) :: ras_time, ras_trg, ras_toki, &
&   ras_pbl, ras_wfn
    INTEGER, DIMENSION(idim, k0), INTENT(OUT) :: irc
    REAL, OPTIONAL, INTENT(INOUT) :: xho(idim, k0, itrcr)
    REAL, OPTIONAL, INTENT(OUT) :: triedlev_diag(idim, k0)
    REAL, OPTIONAL, INTENT(OUT) :: disske(idim, k0)
! Fraction scavenged per km
    REAL, OPTIONAL, INTENT(IN) :: fscav(itrcr)
! = 0 (no scav), = 1 (full scav)
!  LOCALS
    REAL, DIMENSION(k0) :: poi_sv, qoi_sv, uoi_sv, voi_sv
    REAL, DIMENSION(k0) :: poi_sv_tl, qoi_sv_tl, uoi_sv_tl, voi_sv_tl
    REAL, DIMENSION(k0) :: poi, qoi, uoi, voi, dqq, bet, gam, cll
    REAL, DIMENSION(k0) :: poi_tl, qoi_tl, uoi_tl, voi_tl, dqq_tl, &
&   bet_tl, gam_tl, cll_tl
    REAL, DIMENSION(k0) :: poi_c, qoi_c
    REAL, DIMENSION(k0) :: poi_c_tl, qoi_c_tl
    REAL, DIMENSION(k0) :: prh, pri, ght, dpt, dpb, pki, dissk0, dissk1&
&   , clantnd
    REAL, DIMENSION(k0) :: ght_tl
    REAL, DIMENSION(k0) :: tcu, qcu, ucu, vcu, cln, rns, pol, dm
    REAL, DIMENSION(k0) :: ucu_tl, vcu_tl, rns_tl
    REAL, DIMENSION(k0) :: qst, ssl, rmf, rnn, rn1, rmfc, rmfp
    REAL, DIMENSION(k0) :: qst_tl, ssl_tl, rnn_tl, rmfp_tl
    REAL, DIMENSION(k0) :: gms, eta, gmh, eht, gm1, hcc, rmfd
    REAL, DIMENSION(k0) :: gms_tl, eta_tl, gmh_tl, eht_tl, gm1_tl, &
&   hcc_tl, rmfd_tl
    REAL, DIMENSION(k0) :: hol, hst, qol, zol, hcld, cll0, cllx, clli, &
&   cllb
    REAL, DIMENSION(k0) :: hol_tl, hst_tl, qol_tl, zol_tl, hcld_tl, &
&   cll0_tl
    REAL, DIMENSION(k0) :: wsp, lambdsv, bke, cvw, updfrc
    REAL, DIMENSION(k0) :: cvw_tl, updfrc_tl
    REAL, DIMENSION(k0) :: tau, rasal, mtkwi, updfrp, bk2, bk3, dll0, &
&   dllx
    REAL, DIMENSION(k0) :: tau_tl, rasal_tl, updfrp_tl, bk2_tl
    REAL, DIMENSION(itrcr) :: xht
    REAL, DIMENSION(k0, itrcr) :: xoi, xcu, xoi_sv
    REAL, DIMENSION(k0+1) :: prj, prs, qht, sht, zet, xyd, xyd0
    REAL, DIMENSION(k0+1) :: qht_tl, sht_tl, zet_tl
    INTEGER, DIMENSION(k0-1) :: rc
    INTEGER :: k, my_pe
    REAL, DIMENSION(idim, k0) :: lambdsv2
    REAL :: tx2, tx3, uht, vht, akm, acr, alm, tth, qqh, shtrg, wspbl, &
&   dqx
    REAL :: tx2_tl, tx3_tl, uht_tl, vht_tl, akm_tl, alm_tl, dqx_tl
!, BKE
    REAL :: wfn, tem, trg, trgexp, evp, wlq, qcc, mtkw_max
    REAL :: wfn_tl, tem_tl, trg_tl, wlq_tl, qcc_tl
    REAL :: shtrg_fac, sige_minhol, wfnog
    INTEGER :: i, ic, l, icl, itr, icl_c, n_dtl
    INTEGER :: ndtlexpon
    INTEGER, DIMENSION(:), ALLOCATABLE :: icl_v
!  RASE GLOBAL CONSTANTS
    REAL :: grav, cp, alhl, cpbg, alhi, cpi, gravi, ddt, lbcp, obg, afc
!!!!!!!!!
    REAL :: fricfac, dpth_bl, wupdrft, pblfrac, autorampb, co_zdep
    REAL :: rasal1, rasal2, rasal2i, co_t, rasncl, friclambda, sdqvt1, &
&   sdqv2
    REAL :: lambda_fac, strapping, acritfac, hmintrigger, lldisaggxp
    REAL :: lambmx_fac, diammn_min, rdtlexpon, cli_crit, sdqv3, &
&   maxdallowed_d, maxdallowed_s, maxdallowed_e
    REAL :: rhmn, rhmx, cldmicro, fdrop_dust, fdrop_soot, rasal_slope
    INTEGER :: kstrap
    REAL :: cld_radius, areal_frac, spect_mflx, cvw_cbase
!!!!!!!!!
    REAL, PARAMETER :: onepkap=1.+2./7., daylen=86400.0
!      REAL, PARAMETER :: PBLFRAC = 0.5
    REAL, PARAMETER :: rhmax=0.9999
!  LAMBDA LIMITS
    REAL :: lambda_min
    REAL :: lambda_max
!  TRIGGER PARAMETERS
! Density of liquid water in kg/m^3
    REAL, PARAMETER :: rho_w=1.0e3
    LOGICAL :: dyna_strapping, do_tracers, smooth_hst
!character(len=ESMF_MAXSTR)          :: CBL_STYLE
    REAL*8, DIMENSION(k0) :: tcu8, qcu8, pcu, flx8
    REAL*8, DIMENSION(k0, itrcr+2) :: rcu
!, dpd, tla
    REAL*8 :: cup
    LOGICAL :: revap, wrkfun, calkpb, crtfun, lprnt, dndrft
    REAL*8, DIMENSION(k0) :: toi8, qoi8, prsm8, phil8, qli8, qii8, &
&   trcfac
    REAL*8, DIMENSION(k0) :: alfind, alfint, alfinq, rhc_ls
    REAL*8, DIMENSION(k0+1) :: prs8, phih8
    REAL*8, DIMENSION(k0, itrcr+2) :: roi8
    REAL*8 :: fracbl, dt8, rasalf
    INTEGER :: kpbl
! no inhibition for =1.0
    REAL*8, SAVE :: max_neg_bouy=1.0
!!real*8 :: ALFINT = 0.5
!!real*8 :: ALFINQ = 0.5
! not used
    REAL*8, SAVE :: rhfacl=0.0
! no inhibition
    REAL*8, SAVE :: rhfacs=0.0
! 1 degree resolution
    REAL*8, SAVE :: garea=1.e10
!!real*8 :: ALFIND = 1.0
!!real*8 :: RHC_LS = 0.80
    REAL*8, SAVE :: dsfc=0.001
    REAL*8, SAVE :: cd=1.e-3
    REAL*8, SAVE :: wfnc=0.0
    REAL*8, SAVE :: tla=-1.0
    REAL*8, SAVE :: dpd=300.
!  SCAVANGING RELATED PARAMETERS
! layer thickness in km
    REAL :: delzkm
! fraction of tracer *not* scavenged
    REAL :: fnoscav
! Fraction scavenged per km
    REAL :: fscav_(itrcr)
! ************************AER_CLOUD *********************************************
!DONIF
    TYPE(AERPROPS), DIMENSION(idim, k0), INTENT(IN) :: aeroprops
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: cnv_ndrop, cnv_fice, &
&   cnv_nice
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: ras_tau, ras_alpha
!DONIF
    REAL, DIMENSION(k0) :: cnvndrop, cnvnice, cnvfice
!AEROSOL VERTICAl ARRAY FOR ALL SPECIES
    TYPE(AERPROPS), DIMENSION(k0) :: aero
    REAL :: t_ice_all, t_ice_max, aseasalt, f_seasalt
    INTEGER, PARAMETER :: ndustmax=10
    INTEGER :: index
    TYPE(AERPROPS) :: aeraux, aer_base
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC SQRT
    INTRINSIC SUM
    INTRINSIC ALLOCATED
    REAL :: result1
    cnv_fice = 0.0
    cnv_ndrop = 0.0
    cnv_nice = 0.0
    cnvfice = 0.0
    cnvndrop = 0.0
    cnvnice = 0.0
    t_ice_all = 238.0
    t_ice_max = mapl_tice
    cldmicro = 0.0
    fdrop_dust = 0.1
    fdrop_soot = 0.01
    ras_alpha = 1.0e15
    ras_tau = 1.0e15
! *********************************************************************
    IF (PRESENT(fscav)) THEN
      fscav_ = fscav
    ELSE
! NO SCAVENGING BY DEFAULT
      fscav_ = 0.0
    END IF
    IF (irun .LE. 0) THEN
      clw_tl = 0.0_8
      cnv_prc3_tl = 0.0_8
      vho_tl = 0.0_8
      cnv_updfrc_tl = 0.0_8
      uho_tl = 0.0_8
      flxd_tl = 0.0_8
      RETURN
    ELSE
      IF (PRESENT(triedlev_diag)) triedlev_diag = 0.
      cnv_prc3 = 0.
      cnv_updfrc = 0.
      cnv_cvw = 0.
      cnv_qc = 0.
      entlam = 0.
      IF (PRESENT(disske)) disske = 0.
!!LAMBDSV2 = 0.
      irc = -2
!      SMOOTH_HST   = .TRUE.
      smooth_hst = .false.
      fricfac = rasparams%cufricfac
      shtrg_fac = rasparams%shr_lambda_fac
! MAT CO_AUTO is now passed in from outside
!     in order to allow this code to run over im*jm
!     columns
!CO_AUTO      = RASPARAMS(3)     !  ---  3
      cli_crit = rasparams%qc_crit_cn
      rasal1 = rasparams%rasal1
      rasal2 = rasparams%rasal2
      rasncl = rasparams%rasncl
      lambda_fac = rasparams%lambda_fac
      lambmx_fac = rasparams%lambmx_fac
      diammn_min = rasparams%min_diameter
      friclambda = rasparams%cufriclambda
      rdtlexpon = rasparams%rdtlexpon
      strapping = rasparams%strapping
      sdqv2 = rasparams%sdqv2
      sdqv3 = rasparams%sdqv3
      sdqvt1 = rasparams%sdqvt1
      acritfac = rasparams%acritfac
      hmintrigger = rasparams%hmintrigger
      lldisaggxp = rasparams%lldisaggxp
      pblfrac = rasparams%pblfrac
      autorampb = rasparams%rasautorampb
      co_zdep = rasparams%autoc_cn_zdep
      maxdallowed_s = rasparams%maxdallowed_s
      maxdallowed_d = rasparams%maxdallowed_d
      maxdallowed_e = rasparams%maxdallowed_e
      rasal_slope = rasparams%rasal_slope
      rhmn = rasparams%ras_rhmin
      rhmx = rasparams%ras_rhfull
      cldmicro = rasparams%cldmicro
      fdrop_dust = rasparams%fdrop_dust
      fdrop_soot = rasparams%fdrop_soot
      IF (strapping .LE. 0.0) THEN
        dyna_strapping = .true.
      ELSE
        dyna_strapping = .false.
        kstrap = INT(strapping)
      END IF
      do_tracers = PRESENT(xho) .AND. itrcr .GT. 0
      wupdrft = 2.500
      grav = gravo
      alhl = alhlo
      cp = cpo
      cpi = 1.0/cp
      alhi = 1.0/alhl
      gravi = 1.0/grav
      cpbg = cp*gravi
      ddt = daylen/dt
      result1 = SQRT(dt*113.84)
      afc = -(1.04e-4*result1)
      lbcp = alhl*cpi
      obg = 100.*gravi
      hho = 1.0e15
      hso = 1.0e15
      clw_tl = 0.0_8
      cnv_prc3_tl = 0.0_8
      vho_tl = 0.0_8
      cnv_updfrc_tl = 0.0_8
      uho_tl = 0.0_8
      flxd_tl = 0.0_8
      eht_tl = 0.0_8
      gm1_tl = 0.0_8
      hcc_tl = 0.0_8
      cvw_tl = 0.0_8
      dqq_tl = 0.0_8
      ucu_tl = 0.0_8
      ght_tl = 0.0_8
      hst_tl = 0.0_8
      bet_tl = 0.0_8
      qoi_sv_tl = 0.0_8
      qht_tl = 0.0_8
      uoi_sv_tl = 0.0_8
      qoi_tl = 0.0_8
      qol_tl = 0.0_8
      voi_tl = 0.0_8
      bk2_tl = 0.0_8
      hcld_tl = 0.0_8
      eta_tl = 0.0_8
      sht_tl = 0.0_8
      gmh_tl = 0.0_8
      rnn_tl = 0.0_8
      qst_tl = 0.0_8
      gms_tl = 0.0_8
      updfrc_tl = 0.0_8
      poi_tl = 0.0_8
      rns_tl = 0.0_8
      poi_sv_tl = 0.0_8
      uoi_tl = 0.0_8
      vcu_tl = 0.0_8
      rmfd_tl = 0.0_8
      voi_sv_tl = 0.0_8
      ssl_tl = 0.0_8
      zet_tl = 0.0_8
      updfrp_tl = 0.0_8
      zol_tl = 0.0_8
      cll0_tl = 0.0_8
      cll_tl = 0.0_8
      rmfp_tl = 0.0_8
      gam_tl = 0.0_8
      DO i=1,irun
!===================AER_CLOUD
!            AERO =  AEROPROPS(I, :)
!            CNVFICE  =0.0
!            CNVNDROP =0.0
!            CNVNICE  =0.0
!!CALL FINDBASE
        k = kcbl(i)
        rc(icmin) = 0
        CALL FINDDTLS()
        IF (k .GT. 0) THEN
          CALL STRAP_TLM(final=0)
          CALL HTEST_TLM()
          hho(i, :) = hol
          hso(i, :) = hst
          tau = 0.0
          rasal = 0.0
          tau_tl = 0.0_8
          rasal_tl = 0.0_8
          DO icl_c=1,n_dtl
            icl = icl_v(icl_c)
            IF (do_tracers) xcu(icmin:, :) = 0.
            IF (PRESENT(triedlev_diag)) triedlev_diag(i, icl) = 1.
! This change makes cumulus friction
            ucu_tl(icmin:) = 0.0_8
            ucu(icmin:) = 0.
! correct.
            vcu_tl(icmin:) = 0.0_8
            vcu(icmin:) = 0.
            IF (icl .GT. icmin) CALL CLOUDE_TLM(icl)
            entlam(i, icl) = alm
            ras_tau(i, icl) = tau(icl)
            ras_alpha(i, icl) = rasal(icl)
          END DO
          IF (SUM(rmf(icmin:k)) .GT. 0.0) THEN
            CALL RNEVP_TLM()
            CALL STRAP_TLM(final=1)
          ELSE
            CALL STRAP_TLM(final=2)
          END IF
        ELSE
          CALL STRAP_TLM(final=2)
        END IF
! Zero out precip - TBD w/ in progno_cloud
        precu = 0.0
      END DO
      IF (ALLOCATED(icl_v)) THEN
        DEALLOCATE(icl_v)
      END IF
      RETURN
    END IF

  CONTAINS
!  Differentiation of cloude in forward (tangent) mode (with options r8):
!   variations   of useful results: tau eht hcc cvw ucu hst qht
!                qoi qol voi bk2 rasal hcld eta sht gmh rnn qst
!                gms updfrc poi rns uoi vcu rmfd ssl zet updfrp
!                zol cll0 hol cll rmfp
!   with respect to varying inputs: tau eht gm1 hcc cvw dqq ucu
!                ght hst bet qht qoi qol voi bk2 rasal hcld eta
!                sht gmh rnn qst gms updfrc poi rns uoi vcu rmfd
!                ssl zet updfrp zol cll0 hol cll rmfp gam
!*********************************************************************
    SUBROUTINE CLOUDE_TLM(ic)
      IMPLICIT NONE
!=======================================
      INTEGER, INTENT(IN) :: ic
      REAL :: deep_fact, cu_diam, wscale
!, dQx
      REAL :: cli, te_a, c00_x, cli_crit_x, pete, toki, gmhx, hstx
      REAL :: cli_tl, te_a_tl, c00_x_tl, cli_crit_x_tl, toki_tl, gmhx_tl&
&     , hstx_tl
      REAL :: dt_lyr, rate, cvw_x, closs, f2, f3, f4, f5
      REAL :: dt_lyr_tl, rate_tl, cvw_x_tl, closs_tl, f2_tl
      INTEGER :: k700
!=============================AER_CLOUD local variables ====================
      REAL :: wbase, ndrop, nice, fp_d, ff_a, fp_i, fice, ndrop_amb, &
&     nsoot_amb, nsoot, nin, insoot, dcvw2, qice, dqice, dqig, fpice, &
&     dnice, dndrop, dsoot_amb, dsoot, qliq, dqliq, fprecip, aux, qt, &
&     maxnice, maxndrop, minnice, minndrop, ndrop_act, rimm, fndrim, &
&     tminusta, tparcel, alph_e, beta_e, rh_amb, ecrit
      REAL, DIMENSION(ndustmax) :: ndust, ndust_amb, indust, ddust_amb, &
&     ddust
      INTEGER :: inx, naux, index
      INTRINSIC AMIN1
      INTRINSIC MAX
      INTRINSIC MIN
      INTRINSIC AMAX1
      INTRINSIC SQRT
      INTRINSIC EXP
      REAL :: min1
      REAL :: min1_tl
      REAL :: max1
      REAL :: max1_tl
      REAL :: min2
      REAL :: max2
      REAL :: max2_tl
      REAL :: arg1
      REAL :: arg1_tl
      REAL :: x4
      REAL :: x3
      REAL :: x2
      REAL :: x1
      REAL :: y1
!A little higher so there is ice at the freezing level
      t_ice_all = 238.0
      wbase = 1.0
      fice = 0.0
      nice = 0.0
      ndrop = 0.0
      ndrop_amb = 0.0
      ndrop_act = 0.0
      nin = 0.0
      ndust = 0.0
      nsoot = 0.0
      ndust_amb = 0.0
      nsoot_amb = 0.0
      dcvw2 = 0.0
      qice = 0.0
      qliq = 0.0
      fpice = 0.0
      indust = 0.0
      insoot = 0.0
      qt = 0.0
      fprecip = 0.0
      fndrim = 0.0
      rimm = 0.0
      tminusta = 0.0
      f_seasalt = 0.0
      aseasalt = 0.0
      CALL INIT_AER(aer_base)
!AER_CLOUD=============================
      alm = 0.
      IF (1. .GT. (qoi(k)/qst(k)-rhmn)/(rhmx-rhmn)) THEN
        trg_tl = (qoi_tl(k)*qst(k)-qoi(k)*qst_tl(k))/qst(k)**2/(rhmx-&
&         rhmn)
        trg = (qoi(k)/qst(k)-rhmn)/(rhmx-rhmn)
      ELSE
        trg = 1.
        trg_tl = 0.0_8
      END IF
      IF (0.0 .LT. (autorampb-sige(ic))/0.2) THEN
        y1 = (autorampb-sige(ic))/0.2
      ELSE
        y1 = 0.0
      END IF
      IF (1.0 .GT. y1) THEN
        f4 = y1
      ELSE
        f4 = 1.0
      END IF
! to 1 at SIG=AUTORAMPB-0.2
      IF (sige(ic) .GE. 0.5) THEN
        f5 = 1.0
      ELSE
        f5 = 1.0 - 2.*co_zdep*(0.5-sige(ic))
        IF (f5 .LT. 0.0) THEN
          f5 = 0.0
        ELSE
          f5 = f5
        END IF
      END IF
      IF (trg .LE. 1.0e-5) THEN
! TRIGGER  =========>>
        rc(ic) = 7
        RETURN
      ELSE
!  RECOMPUTE SOUNDING UP TO DETRAINMENT LEVEL
        poi_c_tl = poi_tl
        poi_c = poi
        qoi_c_tl = qoi_tl
        qoi_c = qoi
        poi_c(k) = poi_c(k) + tpert(i)
        qoi_c(k) = qoi_c(k) + qpert(i)
        zet_tl(k+1) = 0.0_8
        zet(k+1) = 0.
        sht_tl(k+1) = cp*prj(k+1)*poi_c_tl(k)
        sht(k+1) = cp*poi_c(k)*prj(k+1)
        DO l=k,ic,-1
          IF (qst(l)*rhmax .GT. qoi_c(l)) THEN
            qol_tl(l) = qoi_c_tl(l)
            qol(l) = qoi_c(l)
          ELSE
            qol_tl(l) = rhmax*qst_tl(l)
            qol(l) = qst(l)*rhmax
          END IF
          IF (0.000 .LT. qol(l)) THEN
            qol(l) = qol(l)
          ELSE
            qol_tl(l) = 0.0_8
            qol(l) = 0.000
          END IF
          ssl_tl(l) = cp*prj(l+1)*poi_c_tl(l) + grav*zet_tl(l+1)
          ssl(l) = cp*prj(l+1)*poi_c(l) + grav*zet(l+1)
          hol_tl(l) = ssl_tl(l) + alhl*qol_tl(l)
          hol(l) = ssl(l) + qol(l)*alhl
          hst_tl(l) = ssl_tl(l) + alhl*qst_tl(l)
          hst(l) = ssl(l) + qst(l)*alhl
          tem_tl = (prj(l+1)-prj(l))*cpbg*poi_c_tl(l)
          tem = poi_c(l)*(prj(l+1)-prj(l))*cpbg
          zet_tl(l) = zet_tl(l+1) + tem_tl
          zet(l) = zet(l+1) + tem
          zol_tl(l) = zet_tl(l+1) + (prj(l+1)-prh(l))*cpbg*poi_c_tl(l)
          zol(l) = zet(l+1) + (prj(l+1)-prh(l))*poi_c(l)*cpbg
        END DO
        DO l=ic+1,k
          tem = (prj(l)-prh(l-1))/(prh(l)-prh(l-1))
          sht_tl(l) = ssl_tl(l-1) + tem*(ssl_tl(l)-ssl_tl(l-1))
          sht(l) = ssl(l-1) + tem*(ssl(l)-ssl(l-1))
          qht_tl(l) = .5*(qol_tl(l)+qol_tl(l-1))
          qht(l) = .5*(qol(l)+qol(l-1))
        END DO
! SMOOTH HSTAR W/ 1-2-1 Filter
        IF (smooth_hst) THEN
! save for later
          hstx_tl = hst_tl(ic)
          hstx = hst(ic)
          DO l=k-1,ic+1,-1
            hst_tl(l) = 0.25*(hst_tl(l+1)+hst_tl(l-1)) + 0.5*hst_tl(l)
            hst(l) = 0.25*(hst(l+1)+hst(l-1)) + 0.5*hst(l)
          END DO
          DO l=ic,ic
            hst_tl(l) = 0.5*hst_tl(l+1) + 0.5*hst_tl(l)
            hst(l) = 0.5*hst(l+1) + 0.5*hst(l)
          END DO
        ELSE
          hstx_tl = 0.0_8
        END IF
!  CALCULATE LAMBDA, ETA, AND WORKFUNCTION
        lambda_min = .2/mxdiam(i)
        lambda_max = .2/diammn_min
!     LAMBDA_MIN = .2/(LAMBDA_FAC*DPTH_BL)
!     LAMBDA_MAX = .2/( MAX( LAMBMX_FAC*DPTH_BL , DIAMMN_MIN ) )
        IF (hol(k) .LE. hst(ic)) THEN
! CANNOT REACH IC LEVEL  ======>>
          rc(ic) = 1
          RETURN
        ELSE
!  LAMBDA CALCULATION: MS-A18
          tem_tl = (hst_tl(ic)-hol_tl(ic))*(zol(ic)-zet(ic+1)) + (hst(ic&
&           )-hol(ic))*(zol_tl(ic)-zet_tl(ic+1))
          tem = (hst(ic)-hol(ic))*(zol(ic)-zet(ic+1))
          DO l=ic+1,k-1
            tem_tl = tem_tl + (hst_tl(ic)-hol_tl(l))*(zet(l)-zet(l+1)) +&
&             (hst(ic)-hol(l))*(zet_tl(l)-zet_tl(l+1))
            tem = tem + (hst(ic)-hol(l))*(zet(l)-zet(l+1))
          END DO
          IF (tem .LE. 0.0) THEN
! NO VALID LAMBDA  ============>>
            rc(ic) = 2
            RETURN
          ELSE
            alm_tl = ((hol_tl(k)-hst_tl(ic))*tem-(hol(k)-hst(ic))*tem_tl&
&             )/tem**2
            alm = (hol(k)-hst(ic))/tem
            IF (alm .GT. lambda_max) THEN
              rc(ic) = 3
              RETURN
            ELSE
!   ALPHA CALCULATION
              rasal2i = rasal2_2d(i)
              IF (zet(ic) .LT. 2000.) THEN
                rasal_tl(ic) = 0.0_8
                rasal(ic) = rasal1
              END IF
              IF (zet(ic) .GE. 2000.) THEN
                IF (1.0 .GT. (zet(ic)-2000.)/rasal_slope) THEN
                  min1_tl = zet_tl(ic)/rasal_slope
                  min1 = (zet(ic)-2000.)/rasal_slope
                ELSE
                  min1 = 1.0
                  min1_tl = 0.0_8
                END IF
                rasal_tl(ic) = (rasal2i-rasal1)*min1_tl
                rasal(ic) = rasal1 + (rasal2i-rasal1)*min1
              END IF
              rasal_tl(ic) = -(dt*rasal_tl(ic)/rasal(ic)**2)
              rasal(ic) = dt/rasal(ic)
              IF (1.0 .GT. (alm/lambda_min)**2) THEN
                toki_tl = 2*alm*alm_tl/lambda_min**2
                toki = (alm/lambda_min)**2
              ELSE
                toki = 1.0
                toki_tl = 0.0_8
              END IF
!   RAS relaxation timescale
              IF (k0 .GT. 96) THEN
!! AMM kluge to run 132 levels for now -- multiply time scale by ratio of number of levels
!! AMM between 900 and 30 mb in 72 and 132 level grids, 0.46
                tau_tl(ic) = 0.46*((toki_tl*trg+toki*trg_tl)*rasal(ic)+&
&                 toki*trg*rasal_tl(ic))
                tau(ic) = toki*trg*rasal(ic)*0.46
              ELSE
                tau_tl(ic) = (toki_tl*trg+toki*trg_tl)*rasal(ic) + toki*&
&                 trg*rasal_tl(ic)
                tau(ic) = toki*trg*rasal(ic)
              END IF
!IF (TAU(IC) < 1.0E-5) THEN
!   RC(IC) = 6
!   RETURN
!ENDIF
!LAMBDSV(IC) = ALM
!  ETA CALCULATION: MS-A2
              DO l=ic+1,k
                eta_tl(l) = alm_tl*(zet(l)-zet(k)) + alm*(zet_tl(l)-&
&                 zet_tl(k))
                eta(l) = 1.0 + alm*(zet(l)-zet(k))
              END DO
              eta_tl(ic) = alm_tl*(zol(ic)-zet(k)) + alm*(zol_tl(ic)-&
&               zet_tl(k))
              eta(ic) = 1.0 + alm*(zol(ic)-zet(k))
!  WORKFUNCTION CALCULATION:  MS-A22
              wfn = 0.0
              hcc_tl(k) = hol_tl(k)
              hcc(k) = hol(k)
              wfn_tl = 0.0_8
              DO l=k-1,ic+1,-1
                hcc_tl(l) = hcc_tl(l+1) + (eta_tl(l)-eta_tl(l+1))*hol(l)&
&                 + (eta(l)-eta(l+1))*hol_tl(l)
                hcc(l) = hcc(l+1) + (eta(l)-eta(l+1))*hol(l)
                tem_tl = dpb(l)*hcc_tl(l+1) + dpt(l)*hcc_tl(l)
                tem = hcc(l+1)*dpb(l) + hcc(l)*dpt(l)
                eht_tl(l) = dpb(l)*eta_tl(l+1) + dpt(l)*eta_tl(l)
                eht(l) = eta(l+1)*dpb(l) + eta(l)*dpt(l)
                wfn_tl = wfn_tl + (tem_tl-eht_tl(l)*hst(l)-eht(l)*hst_tl&
&                 (l))*gam(l) + (tem-eht(l)*hst(l))*gam_tl(l)
                wfn = wfn + (tem-eht(l)*hst(l))*gam(l)
              END DO
              hcc_tl(ic) = hst_tl(ic)*eta(ic) + hst(ic)*eta_tl(ic)
              hcc(ic) = hst(ic)*eta(ic)
              wfn_tl = wfn_tl + dpb(ic)*((hcc_tl(ic+1)-hst_tl(ic)*eta(ic&
&               +1)-hst(ic)*eta_tl(ic+1))*gam(ic)+(hcc(ic+1)-hst(ic)*eta&
&               (ic+1))*gam_tl(ic))
              wfn = wfn + (hcc(ic+1)-hst(ic)*eta(ic+1))*gam(ic)*dpb(ic)
!  VERTICAL VELOCITY/KE CALCULATION (ADDED 12/2001 JTB)
              bk3(k) = 0.0
              bk2_tl(k) = 0.0_8
              bk2(k) = 0.0
              bke(k) = 0.0
              hcld_tl(k) = hol_tl(k)
              hcld(k) = hol(k)
              DO l=k-1,ic,-1
                hcld_tl(l) = ((eta_tl(l+1)*hcld(l+1)+eta(l+1)*hcld_tl(l+&
&                 1)+(eta_tl(l)-eta_tl(l+1))*hol(l)+(eta(l)-eta(l+1))*&
&                 hol_tl(l))*eta(l)-(eta(l+1)*hcld(l+1)+(eta(l)-eta(l+1)&
&                 )*hol(l))*eta_tl(l))/eta(l)**2
                hcld(l) = (eta(l+1)*hcld(l+1)+(eta(l)-eta(l+1))*hol(l))/&
&                 eta(l)
                tem_tl = (((hcld_tl(l)-hst_tl(l))*(zet(l)-zet(l+1))+(&
&                 hcld(l)-hst(l))*(zet_tl(l)-zet_tl(l+1)))*(1.0+lbcp*dqq&
&                 (l))-(hcld(l)-hst(l))*(zet(l)-zet(l+1))*lbcp*dqq_tl(l)&
&                 )/(1.0+lbcp*dqq(l))**2
                tem = (hcld(l)-hst(l))*(zet(l)-zet(l+1))/(1.0+lbcp*dqq(l&
&                 ))
                IF (cldmicro .LE. 0.0) THEN
                  bke(l) = bke(l+1) + grav*tem/(cp*prj(l+1)*poi(l))
                  IF (tem .LT. 0.0) THEN
                    max1 = 0.0
                    max1_tl = 0.0_8
                  ELSE
                    max1_tl = tem_tl
                    max1 = tem
                  END IF
                  bk2_tl(l) = bk2_tl(l+1) + (grav*max1_tl*cp*prj(l+1)*&
&                   poi(l)-grav*max1*cp*prj(l+1)*poi_tl(l))/(cp*prj(l+1)&
&                   *poi(l))**2
                  bk2(l) = bk2(l+1) + grav*max1/(cp*prj(l+1)*poi(l))
                  IF (tem .GT. 0.0) THEN
                    min2 = 0.0
                  ELSE
                    min2 = tem
                  END IF
                  bk3(l) = bk3(l+1) + grav*min2/(cp*prj(l+1)*poi(l))
                  IF (bk2(l) .LT. 0.0) THEN
                    max2 = 0.0
                    max2_tl = 0.0_8
                  ELSE
                    max2_tl = bk2_tl(l)
                    max2 = bk2(l)
                  END IF
                  IF (2.0*max2 .EQ. 0.0_8) THEN
                    cvw_tl(l) = 0.0_8
                  ELSE
                    cvw_tl(l) = max2_tl/SQRT(2.0*max2)
                  END IF
                  cvw(l) = SQRT(2.0*max2)
                END IF
              END DO
              WHERE (cvw(ic:k) .LT. 1.00) 
                cvw_tl(ic:k) = 0.0_8
                cvw(ic:k) = 1.00
              ELSEWHERE
                cvw(ic:k) = cvw(ic:k)
              END WHERE
!  NOTE THIS "CENTRALIZES" A KLUGE PRESENT IN OTHER LOCATIONS.
!  CLEAN UP SOME TIME.      -JTB 12/04/03
!  TEST FOR CRITICAL WORK FUNCTION
              CALL ACRITN(pol(ic), prs(k), acr)
              IF (wfn .LE. acr) THEN
! SUB-CRITICAL WORK FUNCTION ======>>
                rc(ic) = 4
                RETURN
              ELSE
!  CLOUD TOP WATER AND MOMENTUM (TIMES ETA(IC)) MS-A16
! Tracer scavenging
! RAS loops over a series of plumes all having common cloud base level K
! and different detrainment levels IC.  The plumes operate sequentially
! on the grid box mean quantities (wind, moisture, tracer) and so each
! subsequent plume is seeing the effects of previous plumes.  We parameterize
! scavenging following Liu et al. [JGR, 2001], their equation 1:
!  AEROSOL FRACTION SCAVENGED = 1 - exp(-FSCAV*DZ)
! where FSCAV is a specified scavenging efficiency [km-1] and DZ is the
! distance [km] the tracer traverses in the plume from its entrainment
! level to its detrainment level.  We write the aerosol fraction surviving as:
!  FNOSCAV = exp(- FSCAV_(ITR) * DZ)
! The total scavenging is proportional to the convective mass flux, which
! is not explicitly solved for at this point.
                IF (do_tracers) THEN
                  DO itr=1,itrcr
!           Scavenging of the below cloud tracer
                    delzkm = (zet(ic)-zet(k))/1000.
                    x3 = EXP(-(fscav_(itr)*delzkm))
                    IF (x3 .GT. 1.) THEN
                      x1 = 1.
                    ELSE
                      x1 = x3
                    END IF
                    IF (x1 .LT. 0.) THEN
                      fnoscav = 0.
                    ELSE
                      fnoscav = x1
                    END IF
                    xht(itr) = xoi(k, itr)*fnoscav
                  END DO
                END IF
                wlq_tl = qol_tl(k)
                wlq = qol(k)
                uht_tl = uoi_tl(k)
                uht = uoi(k)
                vht_tl = voi_tl(k)
                vht = voi(k)
                rnn_tl(k) = 0.0_8
                rnn(k) = 0.
                cll0_tl(k) = 0.0_8
                cll0(k) = 0.
                f2_tl = 0.0_8
!print *, '========================================='
                DO l=k-1,ic,-1
                  tem_tl = eta_tl(l) - eta_tl(l+1)
                  tem = eta(l) - eta(l+1)
                  wlq_tl = wlq_tl + tem_tl*qol(l) + tem*qol_tl(l)
                  wlq = wlq + tem*qol(l)
                  uht_tl = uht_tl + tem_tl*uoi(l) + tem*uoi_tl(l)
                  uht = uht + tem*uoi(l)
                  vht_tl = vht_tl + tem_tl*voi(l) + tem*voi_tl(l)
                  vht = vht + tem*voi(l)
                  IF (do_tracers) THEN
                    DO itr=1,itrcr
!         Scavenging of the entrained tracer.  Updates transported tracer mass.
                      delzkm = (zet(ic)-zet(l+1))/1000.
                      x4 = EXP(-(fscav_(itr)*delzkm))
                      IF (x4 .GT. 1.) THEN
                        x2 = 1.
                      ELSE
                        x2 = x4
                      END IF
                      IF (x2 .LT. 0.) THEN
                        fnoscav = 0.
                      ELSE
                        fnoscav = x2
                      END IF
                      xht(itr) = xht(itr) + tem*xoi(l, itr)*fnoscav
                    END DO
                  END IF
!!!! How much condensate (CLI) is present here?
                  IF (l .GT. ic) THEN
                    tx2_tl = 0.5*((qst_tl(l)+qst_tl(l-1))*eta(l)+(qst(l)&
&                     +qst(l-1))*eta_tl(l))
                    tx2 = 0.5*(qst(l)+qst(l-1))*eta(l)
                    tx3_tl = 0.5*((hst_tl(l)+hst_tl(l-1))*eta(l)+(hst(l)&
&                     +hst(l-1))*eta_tl(l))
                    tx3 = 0.5*(hst(l)+hst(l-1))*eta(l)
                    qcc_tl = tx2_tl + gm1_tl(l)*(hcc(l)-tx3) + gm1(l)*(&
&                     hcc_tl(l)-tx3_tl)
                    qcc = tx2 + gm1(l)*(hcc(l)-tx3)
                    cll0_tl(l) = wlq_tl - qcc_tl
                    cll0(l) = wlq - qcc
                  ELSE
                    cll0_tl(l) = wlq_tl - qst_tl(ic)*eta(ic) - qst(ic)*&
&                     eta_tl(ic)
                    cll0(l) = wlq - qst(ic)*eta(ic)
                  END IF
                  IF (cll0(l) .LT. 0.00) THEN
                    cll0_tl(l) = 0.0_8
                    cll0(l) = 0.00
                  ELSE
                    cll0(l) = cll0(l)
                  END IF
! condensate (kg/kg)
                  cli_tl = (cll0_tl(l)*eta(l)-cll0(l)*eta_tl(l))/eta(l)&
&                   **2
                  cli = cll0(l)/eta(l)
! Temperature (K)
                  te_a_tl = prh(l)*poi_tl(l)
                  te_a = poi(l)*prh(l)
!=====================================================================
!            if (CLDMICRO .gt. 0.0) then  !AER_CLOUD MIcrophysics considering activation and nucleation
!recompute vertical velocity
!
!               Tparcel = TE_A
!               CVW(K) = 0.8  ! Assume a below cloud base  W of 0.8 m s-1
!               BK2(K)   = 0.0
!
!     
!               TEM     = (HCLD(L)-HST(L) )/ (1.0+LBCP*DQQ(L))  
!               TminusTa = max(min(TEM/CP, 5.0), 0.0) !limit DT to 5 K. According to Wei, JAS, 1998
!	     TEM =0.33*TminusTa*CO_AUTO(I)/TE_A !Bouyancy term, effciency =0.5 mwr Roode et al
!
!               BK2(L)  = BK2(L+1) + GRAV * TEM*(ZET(L)-ZET(L+1)) 
!               BK2(L) = BK2(L) - (ZET(L)-ZET(L+1))*(BK2(L+1)*ALM + CLI*GRAV)  !Account for drag from entrainment of stagnat air 
!and condesate loading
!               CVW(L) = max(SQRT(  2.0* MAX( BK2(L) , 0.0 )  ), 1.0) 
!
!
!	    CVW_X = MIN(CVW(L), 50.0)
!               DT_LYR  =  max(( ZET(L)-ZET(L+1) )/CVW_X, 1.0) !Sanity check
!               TEM   = ETA(L) - ETA(L+1)
!
!               Tparcel  =  TE_A + TminusTa
!
!
!
!!!!!!!!!!account for entrainment effects on activation !!!!!!!!!!!
!! Barahona and Nenes, JGR, 2007
!               alph_e = 2.8915e-8*Tparcel*Tparcel -2.1328e-5*Tparcel+4.2523e-3
!               beta_e = MAPL_ALHL*TminusTa/MAPL_RVAP/Tparcel/Tparcel
!               RH_AMB=QOI(L)/QST(L)
!               ECRIT  = max(1.0-RH_AMB -beta_e, 1.0e-6) 
!               ECRIT =  alph_e/ECRIT
!! print *, L, Tparcel, RH_AMB, ECRIT, ALM
!	           ECRIT =  ALM/ECRIT
!!Print *, ECRIT
!
!
!               if (L .eq. K-1) then
!
!                  FICE=0.0
!                  NICE=0.0
!                  NDROP=0.0
!                  NIN =0.0
!                  NDUST_AMB =0.0
!                  NSOOT_AMB = 0.0
!                  NSOOT=0.0
!                  NDUST= 0.0
!                  RATE=0.0
!                  FPRECIP=0.0
!
!                  AER_BASE%nmods = 0
!                  AER_BASE%num   = 0.0
!                  do INDEX = 1, AERO(L)%nmods
!                      if (AERO(L)%num(INDEX) > 0.1) then
!                          AER_BASE%nmods = AER_BASE%nmods + 1
!                          naux = AER_BASE%nmods
!
!                          AER_BASE%num(naux)   = AERO(L)%num(INDEX)
!                          AER_BASE%dpg(naux)   = max(AERO(L)%dpg(INDEX), 1.0e-9)
!                          AER_BASE%sig(naux)   = AERO(L)%sig(INDEX)
!                          AER_BASE%den(naux)   = AERO(L)%den(INDEX)
!                          AER_BASE%kap(naux)   = AERO(L)%kap(INDEX)
!                          AER_BASE%fdust(naux) = AERO(L)%fdust(INDEX)
!                          AER_BASE%fsoot(naux) = AERO(L)%fsoot(INDEX)
!                          AER_BASE%forg(naux)  = AERO(L)%forg(INDEX)
!                      end if
!                  end do
!
!!initial conditions
!                  call ARGact(Tparcel, CVW_X, NDROP_ACT, NDROP_AMB, NDUST_AMB, NSOOT_AMB, L,  .true., DDUST_AMB, DSOOT_AMB, ECRI
!T) !cloud droplet number and INsource at cloud base
!                  NDUST=NDUST_AMB
!                  NSOOT=NSOOT_AMB
!                  DDUST=DDUST_AMB
!                  DSOOT=DSOOT_AMB                                     
!
!               else 
!                  call ARGact(Tparcel, CVW_X, NDROP_ACT, NDROP_AMB, NDUST_AMB, NSOOT_AMB, L, .false., DDUST_AMB, DSOOT_AMB, ECRI
!T) !cloud droplet number above cloud base
!
!               end if
!
!               QT = CLI
!               RATE = 0.0
!               FPRECIP = 0.0
!
!               if (QT .gt. 0.0) then
!
!! if FICE is already >= 1.0 then the cloud is glaciated and there is no need to do anymore partitioning
!
!                  if (FICE .ge. 1.0) then
!
!
!                     CALL  Qremoval(RATE, FICE, FP_D, FP_I, Tparcel,  & 
!                           POL(L), QT,  NICE, NDROP, CVW_X, FPICE, &
!                           DT_LYR, RIMM, CO_AUTO(I)) 
!
!
!
!                     dNICE = -NICE*FP_I 
!                     NICE  =  (NICE +dNICE*DT_LYR)*ETA(L+1)/ETA(L) !ice
!
!                     MINNICE = max(QICE*(1.0-RATE*DT_LYR), 0.0)/4.0e-8!assuming maximum vol radius 250 microns
!                     MAXNICE = max(QICE*(1.0-RATE*DT_LYR), 0.0)/2.51e-12 !assuming minimum vol radius 10 microns
!
!                     NICE=MIN(max(NICE, MINNICE), MAXNICE)
!
!                     FICE = 1.0
!
!                  else 
!
!! Cloud is not completely glaciated do the whole thing
!! ALL these subroutines return tendencies
!
!
!                     CALL  INfreezing(QLIQ, NDROP, NIN, NDUST, NSOOT, INDUST, INSOOT, Tparcel, POL(L), CVW_X, DDUST, DSOOT)  !ca
!lculate the freezing fraction of the aerosol at this level
!
!                     NIN = min(NIN, NDROP/DT_LYR)
!
!                     call Qgrowth(Tparcel, POL(L), QICE, NICE, QT, NIN, dQIG, RIMM, FNDRIM)
!
!                     CALL  Qremoval(RATE, FICE, FP_D, FP_I, Tparcel,  & 
!                           POL(L), QT,  NICE, NDROP, CVW_X, FPICE, &
!                           DT_LYR,  RIMM, CO_AUTO(I)) 
!
!
!
!!ice number tendency: -precip + freezin
!                     dNICE = -NICE*FP_I  + NIN     
!                     NICE  =  (NICE +dNICE*DT_LYR)*ETA(L+1)/ETA(L) !ice
!                     NICE =max(NICE, 0.0)
!
!
!!ice mass tendency: growth - precip
!                     dQICE = -QICE*FPICE + dQIG
!                     QICE  =  min((QICE + dQICE*DT_LYR)*ETA(L+1)/ETA(L), QT) !ice
!                     QICE=max(min(QT, QICE), 0.0)
!
!
!! Liquid Tendency: source/evap -  precip
!!dQLIQ = max((CLI-QICE), -QLIQ)/DT_LYR -QLIQ*max(RATE-FPICE, 0.0)
!! dQLIQ = CLI*(1.0-RATE*DT_LYR)/DT_LYR -dQICE - QLIQ*max(RATE-FPICE, 0.0)
!!QLIQ  =  max((QLIQ + dQLIQ*DT_LYR)*ETA(L+1)/ETA(L), 0.0) !liquid. This is actually diagnostic
!                     QLIQ=max((QT-QICE), 0.0)
!
!
!!droplet number tendency: -precip - freezin + activation + activated entrained aerosol
!
!
!                     dNDROP =-NDROP*FP_D - NIN -  FNDRIM*NDROP/DT_LYR + max(NDROP_ACT-NDROP, 0.0)/DT_LYR          
!
!!dNDROP =-NDROP*FP_D - NIN -  FNDRIM*NDROP/DT_LYR + NDROP_ACT/DT_LYR
!
!                     NDROP =  (NDROP + dNDROP*DT_LYR)*ETA(L+1)/ETA(L) + &
!                           (ZET(L) - ZET(L+1))*ALM*MAX((NDROP_AMB-NDROP), 0.0)
!
!!Aerosol tendency: Entrainment - freezing
!
!                     NDUST = (NDUST - INDUST*DT_LYR)*ETA(L+1)/ETA(L) + &
!                           (ZET(L) - ZET(L+1))*ALM*MAX(NDUST_AMB-NDUST, 0.0) 
!
!                     NSOOT =  (NSOOT - INSOOT*DT_LYR)*ETA(L+1)/ETA(L)  + &     
!                           (ZET(L) - ZET(L+1))*ALM*MAX(NSOOT_AMB-NSOOT, 0.0)  
!
!
!                           
!!Update FICE and perform Sanity checks
!
!
!                     MINNDROP = (1.0-FICE)*QLIQ*max(1.0-RATE*DT_LYR, 0.0)/2.e-10    !assuming maximum vol radius 36 microns
!                     MAXNDROP = (1.0-FICE)*QLIQ*max(1.0-RATE*DT_LYR, 0.0)/3.35e-14 !assuming minimum vol radius 2 microns
!                     MINNICE = QICE/4.0e-8!assuming maximum vol radius 250 microns
!                     MAXNICE = QICE/2.51e-12 !assuming minimum vol radius 10 microns
!
!                     IF ((NICE .gt. MAXNICE) .or. (NICE .lt. MINNICE))   then    
!!print *, 'nilim', NICE*1e-6, MINNICE*1e-6, MAXNICE*1e-6
!                     END IF
!
!                     IF ((NDROP .gt. MAXNDROP) .or. (NDROP .lt. MINNDROP))      then 
!!print *, 'ndroplim', NDROP*1e-6, MINNDROP*1e-6, MAXNDROP*1e-6
!                     end if
!
!
!                     NSOOT=MAX(NSOOT, 0.0)
!                     NDUST=MAX(NDUST, 0.0)              
!
!                     NDROP=MIN(max(NDROP, MINNDROP), MAXNDROP)
!                     NICE=MIN(max(NICE, MINNICE), MAXNICE)
!
!                     FICE=max(min(QICE/QT, 1.0), 0.0)
!
!                     IF (FICE .ge. 1.0) THEN !Complete glaciation
!                        NICE=NICE+NDROP 
!                        NDROP = 0.0
!                        QICE  = QT
!                        QLIQ= 0.0
!                     END IF
!
!                     IF (Tparcel .LT. T_ICE_ALL) THEN !instantaneous freezing
!                        NICE=NICE+NDROP 
!                        NDROP = 0.0
!                        FICE  = 1.0
!                        QICE  = QT
!                        QLIQ=0.0
!                     END IF
!
!                     IF (Tparcel .GT. T_ICE_MAX) THEN !instantaneous melting
!                        NDROP=NICE+NDROP 
!                        NICE = 0.0
!                        FICE  = 0.0
!                        QICE  = 0.0
!                        QLIQ=QT
!                     END IF
!
!                  END IF
!
!               else 
!
!                  FICE =0.0 
!                  QICE = 0.0
!                  QLIQ = 0.0
!                  NICE= 0.0 
!                  NDROP = 0.0
!                  RATE =0.0
!               end if
!
!               FPRECIP= RATE*DT_LYR
!
!!RATE=RATE*F4
!! NDROP=NDROP*F4
!!NICE=NICE*(1.0-F4)
!
!!print *, TE_A, FICE, 'NICE', NICE*1e-6, 'NDROP', NDROP*1e-6, L
!!print *, 'FPI', FP_I*DT_LYR, 'FPD', FP_D*DT_LYR, 'FPICE', FPICE, 'FPRE', FPRECIP, QT, QLIQ
!
!            else !Bacmeister 2006 microphysics
                  CALL SUNDQ3_ICE_TLM(te_a, te_a_tl, sdqv2, sdqv3, &
&                               sdqvt1, f2, f2_tl, f3)
! * F5  ! F4 reduces AUTO for shallow clouds, F5 modifies auto for deep clouds
                  c00_x_tl = co_auto(i)*f3*f4*f2_tl
                  c00_x = co_auto(i)*f2*f3*f4
                  cli_crit_x_tl = -(cli_crit*f3*f2_tl/(f2*f3)**2)
                  cli_crit_x = cli_crit/(f2*f3)
                  arg1_tl = -((2*cli*cli_tl*cli_crit_x**2-cli**2*2*&
&                   cli_crit_x*cli_crit_x_tl)/(cli_crit_x**2)**2)
                  arg1 = -(cli**2/cli_crit_x**2)
                  rate_tl = c00_x_tl*(1.0-EXP(arg1)) - c00_x*arg1_tl*EXP&
&                   (arg1)
                  rate = c00_x*(1.0-EXP(arg1))
                  IF (cvw(l) .LT. 1.00) THEN
                    cvw_x = 1.00
                    cvw_x_tl = 0.0_8
                  ELSE
                    cvw_x_tl = cvw_tl(l)
                    cvw_x = cvw(l)
                  END IF
! really trust it at low values
! l.h.s. DT_LYR => time in layer (L,L+1)
                  dt_lyr_tl = ((zet_tl(l)-zet_tl(l+1))*cvw_x-(zet(l)-zet&
&                   (l+1))*cvw_x_tl)/cvw_x**2
                  dt_lyr = (zet(l)-zet(l+1))/cvw_x
                  closs_tl = cll0_tl(l)*rate*dt_lyr + cll0(l)*(rate_tl*&
&                   dt_lyr+rate*dt_lyr_tl)
                  closs = cll0(l)*rate*dt_lyr
                  IF (closs .GT. cll0(l)) THEN
                    closs_tl = cll0_tl(l)
                    closs = cll0(l)
                  ELSE
                    closs = closs
                  END IF
                  cll0_tl(l) = cll0_tl(l) - closs_tl
                  cll0(l) = cll0(l) - closs
                  dll0(l) = closs
                  IF (closs .GT. 0.) THEN
                    wlq_tl = wlq_tl - closs_tl
                    wlq = wlq - closs
                    rnn_tl(l) = closs_tl
                    rnn(l) = closs
                  ELSE
                    rnn_tl(l) = 0.0_8
                    rnn(l) = 0.
                  END IF
                END DO
!AER_CLOUD=======================================
!            CNVNDROP(IC)=NDROP
!            CNVNICE(IC)=NICE
!            CNVFICE(IC)=FICE
                wlq_tl = wlq_tl - qst_tl(ic)*eta(ic) - qst(ic)*eta_tl(ic&
&                 )
                wlq = wlq - qst(ic)*eta(ic)
!     CALCULATE GAMMAS AND KERNEL
! MS-A30 (W/O GRAV)
                gms_tl(k) = pri(k)*(sht_tl(k)-ssl_tl(k))
                gms(k) = (sht(k)-ssl(k))*pri(k)
! MS-A31 (W/O GRAV)
                gmh_tl(k) = gms_tl(k) + pri(k)*alhl*(qht_tl(k)-qol_tl(k)&
&                 )
                gmh(k) = gms(k) + (qht(k)-qol(k))*pri(k)*alhl
! MS-A37 (W/O GRAV)
                akm_tl = dpb(k-1)*(gmh_tl(k)*gam(k-1)+gmh(k)*gam_tl(k-1)&
&                 )
                akm = gmh(k)*gam(k-1)*dpb(k-1)
                tx2_tl = gmh_tl(k)
                tx2 = gmh(k)
                DO l=k-1,ic+1,-1
                  gms_tl(l) = pri(l)*(eta_tl(l)*(sht(l)-ssl(l))+eta(l)*(&
&                   sht_tl(l)-ssl_tl(l))+eta_tl(l+1)*(ssl(l)-sht(l+1))+&
&                   eta(l+1)*(ssl_tl(l)-sht_tl(l+1)))
                  gms(l) = (eta(l)*(sht(l)-ssl(l))+eta(l+1)*(ssl(l)-sht(&
&                   l+1)))*pri(l)
                  gmh_tl(l) = gms_tl(l) + alhl*pri(l)*(eta_tl(l)*(qht(l)&
&                   -qol(l))+eta(l)*(qht_tl(l)-qol_tl(l))+eta_tl(l+1)*(&
&                   qol(l)-qht(l+1))+eta(l+1)*(qol_tl(l)-qht_tl(l+1)))
                  gmh(l) = gms(l) + (eta(l)*(qht(l)-qol(l))+eta(l+1)*(&
&                   qol(l)-qht(l+1)))*alhl*pri(l)
                  tx2_tl = tx2_tl + (eta_tl(l)-eta_tl(l+1))*gmh(l) + (&
&                   eta(l)-eta(l+1))*gmh_tl(l)
                  tx2 = tx2 + (eta(l)-eta(l+1))*gmh(l)
                  akm_tl = akm_tl - pki(l)*(gms_tl(l)*eht(l)+gms(l)*&
&                   eht_tl(l)) + tx2_tl*ght(l) + tx2*ght_tl(l)
                  akm = akm - gms(l)*eht(l)*pki(l) + tx2*ght(l)
                END DO
                gms_tl(ic) = pri(ic)*(eta_tl(ic+1)*(ssl(ic)-sht(ic+1))+&
&                 eta(ic+1)*(ssl_tl(ic)-sht_tl(ic+1)))
                gms(ic) = eta(ic+1)*(ssl(ic)-sht(ic+1))*pri(ic)
                akm_tl = akm_tl - dpb(ic)*pki(ic)*(gms_tl(ic)*eta(ic+1)+&
&                 gms(ic)*eta_tl(ic+1))
                akm = akm - gms(ic)*eta(ic+1)*dpb(ic)*pki(ic)
                gmh_tl(ic) = gms_tl(ic) + pri(ic)*(alhl*(eta_tl(ic+1)*(&
&                 qol(ic)-qht(ic+1))+eta(ic+1)*(qol_tl(ic)-qht_tl(ic+1))&
&                 )+eta_tl(ic)*(hst(ic)-hol(ic))+eta(ic)*(hst_tl(ic)-&
&                 hol_tl(ic)))
                gmh(ic) = gms(ic) + (eta(ic+1)*(qol(ic)-qht(ic+1))*alhl+&
&                 eta(ic)*(hst(ic)-hol(ic)))*pri(ic)
                IF (smooth_hst) THEN
                  gmhx_tl = gms_tl(ic) + pri(ic)*(alhl*(eta_tl(ic+1)*(&
&                   qol(ic)-qht(ic+1))+eta(ic+1)*(qol_tl(ic)-qht_tl(ic+1&
&                   )))+eta_tl(ic)*(hstx-hol(ic))+eta(ic)*(hstx_tl-&
&                   hol_tl(ic)))
                  gmhx = gms(ic) + (eta(ic+1)*(qol(ic)-qht(ic+1))*alhl+&
&                   eta(ic)*(hstx-hol(ic)))*pri(ic)
                ELSE
                  gmhx_tl = 0.0_8
                END IF
!    CLOUD BASE MASS FLUX
                IF (akm .GE. 0.0 .OR. wlq .LT. 0.0) THEN
!  =========>
                  rc(ic) = 5
                  RETURN
                ELSE
! MS-A39 MASS-FLUX IN Pa/step
                  wfn_tl = -((wfn_tl*akm-(wfn-acr)*akm_tl)/akm**2)
                  wfn = -((wfn-acr)/akm)
! WMP Store the full mass-flux to use in efficiency diagnostic
                  ras_wfn(i) = wfn
                  IF (tau(ic)*wfn .GT. (prs(k+1)-prs(k))*(100.*pblfrac)&
&                 ) THEN
                    wfn = (prs(k+1)-prs(k))*(100.*pblfrac)
                    wfn_tl = 0.0_8
                  ELSE
                    wfn_tl = tau_tl(ic)*wfn + tau(ic)*wfn_tl
                    wfn = tau(ic)*wfn
                  END IF
!! WMP RAS DIAGNOSTICS that make up TAU(IC)
! Fill the RAS timescale diagnostic
                  ras_time(i) = rasal(ic)
! Fill the RAS RH trigger diagnostic
                  ras_trg(i) = trg
! Fill the RAS Tokioka diagnostic
                  ras_toki(i) = toki
! Fill the RAS PBL fraction diagnostic
                  ras_pbl(i) = (prs(k+1)-prs(k))*(100.*pblfrac)
! Fill the RAS efficiency diagnostic
! RAS_EFFICIENCY(I) = WFN/RAS_EFFICIENCY(I)
!! WMP RAS DIAGNOSTICS
!    CUMULATIVE PRECIP AND CLOUD-BASE MASS FLUX FOR OUTPUT
                  wfnog = wfn*gravi
                  tem_tl = gravi*wfn_tl
                  tem = wfn*gravi
! (kg/m^2/step)
                  cll_tl(ic) = cll_tl(ic) + wlq_tl*tem + wlq*tem_tl
                  cll(ic) = cll(ic) + wlq*tem
! (kg/m^2/step)
                  rmf(ic) = rmf(ic) + tem
! (kg/m^2/step)
                  rmfd_tl(ic) = rmfd_tl(ic) + tem_tl*eta(ic) + tem*&
&                   eta_tl(ic)
                  rmfd(ic) = rmfd(ic) + tem*eta(ic)
                  DO l=ic+1,k
! (kg/m^2/step)
                    rmfp_tl(l) = tem_tl*eta(l) + tem*eta_tl(l)
                    rmfp(l) = tem*eta(l)
! (kg/m^2/step)
                    rmfc(l) = rmfc(l) + rmfp(l)
                    dllx(l) = dllx(l) + tem*dll0(l)
                    IF (cvw(l) .GT. 0.0) THEN
                      updfrp_tl(l) = (ddt*1000.*rmfp_tl(l)*cvw(l)*prs(l)&
&                       /daylen-rmfp(l)*ddt*1000.*prs(l)*cvw_tl(l)/&
&                       daylen)/(cvw(l)*prs(l))**2
                      updfrp(l) = rmfp(l)*(ddt/daylen)*1000./(cvw(l)*prs&
&                       (l))
                    ELSE
                      updfrp_tl(l) = 0.0_8
                      updfrp(l) = 0.0
                    END IF
! current cloud; incloud condensate
                    clli(l) = cll0(l)/eta(l)
!  cumulative grid mean convective condensate
                    cllb(l) = cllb(l) + updfrp(l)*clli(l)
                    updfrc_tl(l) = updfrc_tl(l) + updfrp_tl(l)
                    updfrc(l) = updfrc(l) + updfrp(l)
                  END DO
!    THETA AND Q CHANGE DUE TO CLOUD TYPE IC
                  DO l=ic,k
! (kg/m^2/step)
                    rns_tl(l) = rns_tl(l) + rnn_tl(l)*tem + rnn(l)*&
&                     tem_tl
                    rns(l) = rns(l) + rnn(l)*tem
                    gmh_tl(l) = gmh_tl(l)*wfn + gmh(l)*wfn_tl
                    gmh(l) = gmh(l)*wfn
                    gms_tl(l) = gms_tl(l)*wfn + gms(l)*wfn_tl
                    gms(l) = gms(l)*wfn
                    qoi_tl(l) = qoi_tl(l) + alhi*(gmh_tl(l)-gms_tl(l))
                    qoi(l) = qoi(l) + (gmh(l)-gms(l))*alhi
                    poi_tl(l) = poi_tl(l) + pki(l)*cpi*gms_tl(l)
                    poi(l) = poi(l) + gms(l)*pki(l)*cpi
                    qst_tl(l) = qst_tl(l) + cpi*(gms_tl(l)*bet(l)+gms(l)&
&                     *bet_tl(l))
                    qst(l) = qst(l) + gms(l)*bet(l)*cpi
                  END DO
                  IF (smooth_hst) THEN
                    gmhx_tl = gmhx_tl*wfn + gmhx*wfn_tl
                    gmhx = gmhx*wfn
                    dqx_tl = alhi*(gmhx_tl-gmh_tl(ic))
                    dqx = (gmhx-gmh(ic))*alhi
                    rns_tl(ic) = rns_tl(ic) + dqx_tl/(pri(ic)*grav)
                    rns(ic) = rns(ic) + dqx/(pri(ic)*grav)
                  END IF
                  IF (do_tracers) THEN
!*FRICFAC*0.5
                    wfn_tl = 0.5*wfn_tl
                    wfn = wfn*0.5*1.0
                    tem = wfn*pri(k)
                    DO itr=1,itrcr
                      xcu(k, itr) = xcu(k, itr) + tem*(xoi(k-1, itr)-xoi&
&                       (k, itr))
                    END DO
                    DO itr=1,itrcr
                      DO l=k-1,ic+1,-1
                        tem = wfn*pri(l)
                        xcu(l, itr) = xcu(l, itr) + tem*((xoi(l-1, itr)-&
&                         xoi(l, itr))*eta(l)+(xoi(l, itr)-xoi(l+1, itr)&
&                         )*eta(l+1))
                      END DO
                    END DO
                    tem = wfn*pri(ic)
                    DO itr=1,itrcr
                      xcu(ic, itr) = xcu(ic, itr) + (2.*(xht(itr)-xoi(ic&
&                       , itr)*(eta(ic)-eta(ic+1)))-(xoi(ic, itr)+xoi(ic&
&                       +1, itr))*eta(ic+1))*tem
                    END DO
                    DO itr=1,itrcr
                      DO l=ic,k
                        xoi(l, itr) = xoi(l, itr) + xcu(l, itr)
                      END DO
                    END DO
                  ELSE
!*FRICFAC*0.5
                    wfn_tl = 0.5*wfn_tl
                    wfn = wfn*0.5*1.0
                  END IF
                  lambdsv(ic) = 1.000
!   CUMULUS FRICTION
                  IF (fricfac .LE. 0.0) THEN
                    rc(ic) = 0
!  NO CUMULUS FRICTION =========>>
                    RETURN
                  ELSE
                    wfn_tl = fricfac*(wfn_tl*EXP(-(alm/friclambda))-wfn*&
&                     alm_tl*EXP(-(alm/friclambda))/friclambda)
                    wfn = wfn*fricfac*EXP(-(alm/friclambda))
                    tem_tl = pri(k)*wfn_tl
                    tem = wfn*pri(k)
                    ucu_tl(k) = ucu_tl(k) + tem_tl*(uoi(k-1)-uoi(k)) + &
&                     tem*(uoi_tl(k-1)-uoi_tl(k))
                    ucu(k) = ucu(k) + tem*(uoi(k-1)-uoi(k))
                    vcu_tl(k) = vcu_tl(k) + tem_tl*(voi(k-1)-voi(k)) + &
&                     tem*(voi_tl(k-1)-voi_tl(k))
                    vcu(k) = vcu(k) + tem*(voi(k-1)-voi(k))
                    DO l=k-1,ic+1,-1
                      tem_tl = pri(l)*wfn_tl
                      tem = wfn*pri(l)
                      ucu_tl(l) = ucu_tl(l) + tem_tl*((uoi(l-1)-uoi(l))*&
&                       eta(l)+(uoi(l)-uoi(l+1))*eta(l+1)) + tem*((&
&                       uoi_tl(l-1)-uoi_tl(l))*eta(l)+(uoi(l-1)-uoi(l))*&
&                       eta_tl(l)+(uoi_tl(l)-uoi_tl(l+1))*eta(l+1)+(uoi(&
&                       l)-uoi(l+1))*eta_tl(l+1))
                      ucu(l) = ucu(l) + tem*((uoi(l-1)-uoi(l))*eta(l)+(&
&                       uoi(l)-uoi(l+1))*eta(l+1))
                      vcu_tl(l) = vcu_tl(l) + tem_tl*((voi(l-1)-voi(l))*&
&                       eta(l)+(voi(l)-voi(l+1))*eta(l+1)) + tem*((&
&                       voi_tl(l-1)-voi_tl(l))*eta(l)+(voi(l-1)-voi(l))*&
&                       eta_tl(l)+(voi_tl(l)-voi_tl(l+1))*eta(l+1)+(voi(&
&                       l)-voi(l+1))*eta_tl(l+1))
                      vcu(l) = vcu(l) + tem*((voi(l-1)-voi(l))*eta(l)+(&
&                       voi(l)-voi(l+1))*eta(l+1))
                    END DO
                    tem_tl = pri(ic)*wfn_tl
                    tem = wfn*pri(ic)
                    ucu_tl(ic) = ucu_tl(ic) + (2.*(uht_tl-uoi_tl(ic)*(&
&                     eta(ic)-eta(ic+1))-uoi(ic)*(eta_tl(ic)-eta_tl(ic+1&
&                     )))-(uoi_tl(ic)+uoi_tl(ic+1))*eta(ic+1)-(uoi(ic)+&
&                     uoi(ic+1))*eta_tl(ic+1))*tem + (2.*(uht-uoi(ic)*(&
&                     eta(ic)-eta(ic+1)))-(uoi(ic)+uoi(ic+1))*eta(ic+1))&
&                     *tem_tl
                    ucu(ic) = ucu(ic) + (2.*(uht-uoi(ic)*(eta(ic)-eta(ic&
&                     +1)))-(uoi(ic)+uoi(ic+1))*eta(ic+1))*tem
                    vcu_tl(ic) = vcu_tl(ic) + (2.*(vht_tl-voi_tl(ic)*(&
&                     eta(ic)-eta(ic+1))-voi(ic)*(eta_tl(ic)-eta_tl(ic+1&
&                     )))-(voi_tl(ic)+voi_tl(ic+1))*eta(ic+1)-(voi(ic)+&
&                     voi(ic+1))*eta_tl(ic+1))*tem + (2.*(vht-voi(ic)*(&
&                     eta(ic)-eta(ic+1)))-(voi(ic)+voi(ic+1))*eta(ic+1))&
&                     *tem_tl
                    vcu(ic) = vcu(ic) + (2.*(vht-voi(ic)*(eta(ic)-eta(ic&
&                     +1)))-(voi(ic)+voi(ic+1))*eta(ic+1))*tem
                    dissk0(ic) = eta(ic)*grav*wfnog*pri(ic)*0.5*((uht/&
&                     eta(ic)-uoi(ic))**2+(vht/eta(ic)-voi(ic))**2)
                    DO l=ic,k
                      uoi_tl(l) = uoi_tl(l) + ucu_tl(l)
                      uoi(l) = uoi(l) + ucu(l)
                      voi_tl(l) = voi_tl(l) + vcu_tl(l)
                      voi(l) = voi(l) + vcu(l)
                    END DO
                    rc(ic) = 0
                    RETURN
                  END IF
                END IF
              END IF
            END IF
          END IF
        END IF
      END IF
    END SUBROUTINE CLOUDE_TLM
!*********************************************************************
    SUBROUTINE CLOUDE(ic)
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: ic
      REAL :: deep_fact, cu_diam, wscale
!, dQx
      REAL :: cli, te_a, c00_x, cli_crit_x, pete, toki, gmhx, hstx
      REAL :: dt_lyr, rate, cvw_x, closs, f2, f3, f4, f5
      INTEGER :: k700
!=============================AER_CLOUD local variables ====================
      REAL :: wbase, ndrop, nice, fp_d, ff_a, fp_i, fice, ndrop_amb, &
&     nsoot_amb, nsoot, nin, insoot, dcvw2, qice, dqice, dqig, fpice, &
&     dnice, dndrop, dsoot_amb, dsoot, qliq, dqliq, fprecip, aux, qt, &
&     maxnice, maxndrop, minnice, minndrop, ndrop_act, rimm, fndrim, &
&     tminusta, tparcel, alph_e, beta_e, rh_amb, ecrit
      REAL, DIMENSION(ndustmax) :: ndust, ndust_amb, indust, ddust_amb, &
&     ddust
      INTEGER :: inx, naux, index
      INTRINSIC AMIN1
      INTRINSIC MAX
      INTRINSIC MIN
      INTRINSIC AMAX1
      INTRINSIC SQRT
      INTRINSIC EXP
      REAL :: min1
      REAL :: max1
      REAL :: min2
      REAL :: max2
      REAL :: arg1
      REAL :: x4
      REAL :: x3
      REAL :: x2
      REAL :: x1
      REAL :: y1
!A little higher so there is ice at the freezing level
      t_ice_all = 238.0
      wbase = 1.0
      fice = 0.0
      nice = 0.0
      ndrop = 0.0
      ndrop_amb = 0.0
      ndrop_act = 0.0
      nin = 0.0
      ndust = 0.0
      nsoot = 0.0
      ndust_amb = 0.0
      nsoot_amb = 0.0
      dcvw2 = 0.0
      qice = 0.0
      qliq = 0.0
      fpice = 0.0
      indust = 0.0
      insoot = 0.0
      qt = 0.0
      fprecip = 0.0
      fndrim = 0.0
      rimm = 0.0
      tminusta = 0.0
      f_seasalt = 0.0
      aseasalt = 0.0
      CALL INIT_AER(aer_base)
!AER_CLOUD=============================
      alm = 0.
      IF (1. .GT. (qoi(k)/qst(k)-rhmn)/(rhmx-rhmn)) THEN
        trg = (qoi(k)/qst(k)-rhmn)/(rhmx-rhmn)
      ELSE
        trg = 1.
      END IF
      IF (0.0 .LT. (autorampb-sige(ic))/0.2) THEN
        y1 = (autorampb-sige(ic))/0.2
      ELSE
        y1 = 0.0
      END IF
      IF (1.0 .GT. y1) THEN
        f4 = y1
      ELSE
        f4 = 1.0
      END IF
! to 1 at SIG=AUTORAMPB-0.2
      IF (sige(ic) .GE. 0.5) THEN
        f5 = 1.0
      ELSE
        f5 = 1.0 - 2.*co_zdep*(0.5-sige(ic))
        IF (f5 .LT. 0.0) THEN
          f5 = 0.0
        ELSE
          f5 = f5
        END IF
      END IF
      IF (trg .LE. 1.0e-5) THEN
! TRIGGER  =========>>
        rc(ic) = 7
        RETURN
      ELSE
!  RECOMPUTE SOUNDING UP TO DETRAINMENT LEVEL
        poi_c = poi
        qoi_c = qoi
        poi_c(k) = poi_c(k) + tpert(i)
        qoi_c(k) = qoi_c(k) + qpert(i)
        zet(k+1) = 0.
        sht(k+1) = cp*poi_c(k)*prj(k+1)
        DO l=k,ic,-1
          IF (qst(l)*rhmax .GT. qoi_c(l)) THEN
            qol(l) = qoi_c(l)
          ELSE
            qol(l) = qst(l)*rhmax
          END IF
          IF (0.000 .LT. qol(l)) THEN
            qol(l) = qol(l)
          ELSE
            qol(l) = 0.000
          END IF
          ssl(l) = cp*prj(l+1)*poi_c(l) + grav*zet(l+1)
          hol(l) = ssl(l) + qol(l)*alhl
          hst(l) = ssl(l) + qst(l)*alhl
          tem = poi_c(l)*(prj(l+1)-prj(l))*cpbg
          zet(l) = zet(l+1) + tem
          zol(l) = zet(l+1) + (prj(l+1)-prh(l))*poi_c(l)*cpbg
        END DO
        DO l=ic+1,k
          tem = (prj(l)-prh(l-1))/(prh(l)-prh(l-1))
          sht(l) = ssl(l-1) + tem*(ssl(l)-ssl(l-1))
          qht(l) = .5*(qol(l)+qol(l-1))
        END DO
! SMOOTH HSTAR W/ 1-2-1 Filter
        IF (smooth_hst) THEN
! save for later
          hstx = hst(ic)
          DO l=k-1,ic+1,-1
            hst(l) = 0.25*(hst(l+1)+hst(l-1)) + 0.5*hst(l)
          END DO
          DO l=ic,ic
            hst(l) = 0.5*hst(l+1) + 0.5*hst(l)
          END DO
        END IF
!  CALCULATE LAMBDA, ETA, AND WORKFUNCTION
        lambda_min = .2/mxdiam(i)
        lambda_max = .2/diammn_min
!     LAMBDA_MIN = .2/(LAMBDA_FAC*DPTH_BL)
!     LAMBDA_MAX = .2/( MAX( LAMBMX_FAC*DPTH_BL , DIAMMN_MIN ) )
        IF (hol(k) .LE. hst(ic)) THEN
! CANNOT REACH IC LEVEL  ======>>
          rc(ic) = 1
          RETURN
        ELSE
!  LAMBDA CALCULATION: MS-A18
          tem = (hst(ic)-hol(ic))*(zol(ic)-zet(ic+1))
          DO l=ic+1,k-1
            tem = tem + (hst(ic)-hol(l))*(zet(l)-zet(l+1))
          END DO
          IF (tem .LE. 0.0) THEN
! NO VALID LAMBDA  ============>>
            rc(ic) = 2
            RETURN
          ELSE
            alm = (hol(k)-hst(ic))/tem
            IF (alm .GT. lambda_max) THEN
              rc(ic) = 3
              RETURN
            ELSE
!   ALPHA CALCULATION
              rasal2i = rasal2_2d(i)
              IF (zet(ic) .LT. 2000.) rasal(ic) = rasal1
              IF (zet(ic) .GE. 2000.) THEN
                IF (1.0 .GT. (zet(ic)-2000.)/rasal_slope) THEN
                  min1 = (zet(ic)-2000.)/rasal_slope
                ELSE
                  min1 = 1.0
                END IF
                rasal(ic) = rasal1 + (rasal2i-rasal1)*min1
              END IF
              rasal(ic) = dt/rasal(ic)
              IF (1.0 .GT. (alm/lambda_min)**2) THEN
                toki = (alm/lambda_min)**2
              ELSE
                toki = 1.0
              END IF
!   RAS relaxation timescale
              IF (k0 .GT. 96) THEN
!! AMM kluge to run 132 levels for now -- multiply time scale by ratio of number of levels
!! AMM between 900 and 30 mb in 72 and 132 level grids, 0.46
                tau(ic) = toki*trg*rasal(ic)*0.46
              ELSE
                tau(ic) = toki*trg*rasal(ic)
              END IF
!IF (TAU(IC) < 1.0E-5) THEN
!   RC(IC) = 6
!   RETURN
!ENDIF
!LAMBDSV(IC) = ALM
!  ETA CALCULATION: MS-A2
              DO l=ic+1,k
                eta(l) = 1.0 + alm*(zet(l)-zet(k))
              END DO
              eta(ic) = 1.0 + alm*(zol(ic)-zet(k))
!  WORKFUNCTION CALCULATION:  MS-A22
              wfn = 0.0
              hcc(k) = hol(k)
              DO l=k-1,ic+1,-1
                hcc(l) = hcc(l+1) + (eta(l)-eta(l+1))*hol(l)
                tem = hcc(l+1)*dpb(l) + hcc(l)*dpt(l)
                eht(l) = eta(l+1)*dpb(l) + eta(l)*dpt(l)
                wfn = wfn + (tem-eht(l)*hst(l))*gam(l)
              END DO
              hcc(ic) = hst(ic)*eta(ic)
              wfn = wfn + (hcc(ic+1)-hst(ic)*eta(ic+1))*gam(ic)*dpb(ic)
!  VERTICAL VELOCITY/KE CALCULATION (ADDED 12/2001 JTB)
              bk3(k) = 0.0
              bk2(k) = 0.0
              bke(k) = 0.0
              hcld(k) = hol(k)
              DO l=k-1,ic,-1
                hcld(l) = (eta(l+1)*hcld(l+1)+(eta(l)-eta(l+1))*hol(l))/&
&                 eta(l)
                tem = (hcld(l)-hst(l))*(zet(l)-zet(l+1))/(1.0+lbcp*dqq(l&
&                 ))
                IF (cldmicro .LE. 0.0) THEN
                  bke(l) = bke(l+1) + grav*tem/(cp*prj(l+1)*poi(l))
                  IF (tem .LT. 0.0) THEN
                    max1 = 0.0
                  ELSE
                    max1 = tem
                  END IF
                  bk2(l) = bk2(l+1) + grav*max1/(cp*prj(l+1)*poi(l))
                  IF (tem .GT. 0.0) THEN
                    min2 = 0.0
                  ELSE
                    min2 = tem
                  END IF
                  bk3(l) = bk3(l+1) + grav*min2/(cp*prj(l+1)*poi(l))
                  IF (bk2(l) .LT. 0.0) THEN
                    max2 = 0.0
                  ELSE
                    max2 = bk2(l)
                  END IF
                  cvw(l) = SQRT(2.0*max2)
                END IF
              END DO
              WHERE (cvw(ic:k) .LT. 1.00) 
                WHERE (cvw(ic:k) .LT. 1.00) 
                  cvw(ic:k) = 1.00
                ELSEWHERE
                  cvw(ic:k) = cvw(ic:k)
                END WHERE
              END WHERE
!  NOTE THIS "CENTRALIZES" A KLUGE PRESENT IN OTHER LOCATIONS.
!  CLEAN UP SOME TIME.      -JTB 12/04/03
!  TEST FOR CRITICAL WORK FUNCTION
              CALL ACRITN(pol(ic), prs(k), acr)
              IF (wfn .LE. acr) THEN
! SUB-CRITICAL WORK FUNCTION ======>>
                rc(ic) = 4
                RETURN
              ELSE
!  CLOUD TOP WATER AND MOMENTUM (TIMES ETA(IC)) MS-A16
! Tracer scavenging
! RAS loops over a series of plumes all having common cloud base level K
! and different detrainment levels IC.  The plumes operate sequentially
! on the grid box mean quantities (wind, moisture, tracer) and so each
! subsequent plume is seeing the effects of previous plumes.  We parameterize
! scavenging following Liu et al. [JGR, 2001], their equation 1:
!  AEROSOL FRACTION SCAVENGED = 1 - exp(-FSCAV*DZ)
! where FSCAV is a specified scavenging efficiency [km-1] and DZ is the
! distance [km] the tracer traverses in the plume from its entrainment
! level to its detrainment level.  We write the aerosol fraction surviving as:
!  FNOSCAV = exp(- FSCAV_(ITR) * DZ)
! The total scavenging is proportional to the convective mass flux, which
! is not explicitly solved for at this point.
                IF (do_tracers) THEN
                  DO itr=1,itrcr
!           Scavenging of the below cloud tracer
                    delzkm = (zet(ic)-zet(k))/1000.
                    x3 = EXP(-(fscav_(itr)*delzkm))
                    IF (x3 .GT. 1.) THEN
                      x1 = 1.
                    ELSE
                      x1 = x3
                    END IF
                    IF (x1 .LT. 0.) THEN
                      fnoscav = 0.
                    ELSE
                      fnoscav = x1
                    END IF
                    xht(itr) = xoi(k, itr)*fnoscav
                  END DO
                END IF
                wlq = qol(k)
                uht = uoi(k)
                vht = voi(k)
                rnn(k) = 0.
                cll0(k) = 0.
!print *, '========================================='
                DO l=k-1,ic,-1
                  tem = eta(l) - eta(l+1)
                  wlq = wlq + tem*qol(l)
                  uht = uht + tem*uoi(l)
                  vht = vht + tem*voi(l)
                  IF (do_tracers) THEN
                    DO itr=1,itrcr
!         Scavenging of the entrained tracer.  Updates transported tracer mass.
                      delzkm = (zet(ic)-zet(l+1))/1000.
                      x4 = EXP(-(fscav_(itr)*delzkm))
                      IF (x4 .GT. 1.) THEN
                        x2 = 1.
                      ELSE
                        x2 = x4
                      END IF
                      IF (x2 .LT. 0.) THEN
                        fnoscav = 0.
                      ELSE
                        fnoscav = x2
                      END IF
                      xht(itr) = xht(itr) + tem*xoi(l, itr)*fnoscav
                    END DO
                  END IF
!!!! How much condensate (CLI) is present here?
                  IF (l .GT. ic) THEN
                    tx2 = 0.5*(qst(l)+qst(l-1))*eta(l)
                    tx3 = 0.5*(hst(l)+hst(l-1))*eta(l)
                    qcc = tx2 + gm1(l)*(hcc(l)-tx3)
                    cll0(l) = wlq - qcc
                  ELSE
                    cll0(l) = wlq - qst(ic)*eta(ic)
                  END IF
                  IF (cll0(l) .LT. 0.00) THEN
                    cll0(l) = 0.00
                  ELSE
                    cll0(l) = cll0(l)
                  END IF
! condensate (kg/kg)
                  cli = cll0(l)/eta(l)
! Temperature (K)
                  te_a = poi(l)*prh(l)
!=====================================================================
!            if (CLDMICRO .gt. 0.0) then  !AER_CLOUD MIcrophysics considering activation and nucleation
!recompute vertical velocity
!
!               Tparcel = TE_A
!               CVW(K) = 0.8  ! Assume a below cloud base  W of 0.8 m s-1
!               BK2(K)   = 0.0
!
!     
!               TEM     = (HCLD(L)-HST(L) )/ (1.0+LBCP*DQQ(L))  
!               TminusTa = max(min(TEM/CP, 5.0), 0.0) !limit DT to 5 K. According to Wei, JAS, 1998
!	     TEM =0.33*TminusTa*CO_AUTO(I)/TE_A !Bouyancy term, effciency =0.5 mwr Roode et al
!
!               BK2(L)  = BK2(L+1) + GRAV * TEM*(ZET(L)-ZET(L+1)) 
!               BK2(L) = BK2(L) - (ZET(L)-ZET(L+1))*(BK2(L+1)*ALM + CLI*GRAV)  !Account for drag from entrainment of stagnat air 
!and condesate loading
!               CVW(L) = max(SQRT(  2.0* MAX( BK2(L) , 0.0 )  ), 1.0) 
!
!
!	    CVW_X = MIN(CVW(L), 50.0)
!               DT_LYR  =  max(( ZET(L)-ZET(L+1) )/CVW_X, 1.0) !Sanity check
!               TEM   = ETA(L) - ETA(L+1)
!
!               Tparcel  =  TE_A + TminusTa
!
!
!
!!!!!!!!!!account for entrainment effects on activation !!!!!!!!!!!
!! Barahona and Nenes, JGR, 2007
!               alph_e = 2.8915e-8*Tparcel*Tparcel -2.1328e-5*Tparcel+4.2523e-3
!               beta_e = MAPL_ALHL*TminusTa/MAPL_RVAP/Tparcel/Tparcel
!               RH_AMB=QOI(L)/QST(L)
!               ECRIT  = max(1.0-RH_AMB -beta_e, 1.0e-6) 
!               ECRIT =  alph_e/ECRIT
!! print *, L, Tparcel, RH_AMB, ECRIT, ALM
!	           ECRIT =  ALM/ECRIT
!!Print *, ECRIT
!
!
!               if (L .eq. K-1) then
!
!                  FICE=0.0
!                  NICE=0.0
!                  NDROP=0.0
!                  NIN =0.0
!                  NDUST_AMB =0.0
!                  NSOOT_AMB = 0.0
!                  NSOOT=0.0
!                  NDUST= 0.0
!                  RATE=0.0
!                  FPRECIP=0.0
!
!                  AER_BASE%nmods = 0
!                  AER_BASE%num   = 0.0
!                  do INDEX = 1, AERO(L)%nmods
!                      if (AERO(L)%num(INDEX) > 0.1) then
!                          AER_BASE%nmods = AER_BASE%nmods + 1
!                          naux = AER_BASE%nmods
!
!                          AER_BASE%num(naux)   = AERO(L)%num(INDEX)
!                          AER_BASE%dpg(naux)   = max(AERO(L)%dpg(INDEX), 1.0e-9)
!                          AER_BASE%sig(naux)   = AERO(L)%sig(INDEX)
!                          AER_BASE%den(naux)   = AERO(L)%den(INDEX)
!                          AER_BASE%kap(naux)   = AERO(L)%kap(INDEX)
!                          AER_BASE%fdust(naux) = AERO(L)%fdust(INDEX)
!                          AER_BASE%fsoot(naux) = AERO(L)%fsoot(INDEX)
!                          AER_BASE%forg(naux)  = AERO(L)%forg(INDEX)
!                      end if
!                  end do
!
!!initial conditions
!                  call ARGact(Tparcel, CVW_X, NDROP_ACT, NDROP_AMB, NDUST_AMB, NSOOT_AMB, L,  .true., DDUST_AMB, DSOOT_AMB, ECRI
!T) !cloud droplet number and INsource at cloud base
!                  NDUST=NDUST_AMB
!                  NSOOT=NSOOT_AMB
!                  DDUST=DDUST_AMB
!                  DSOOT=DSOOT_AMB                                     
!
!               else 
!                  call ARGact(Tparcel, CVW_X, NDROP_ACT, NDROP_AMB, NDUST_AMB, NSOOT_AMB, L, .false., DDUST_AMB, DSOOT_AMB, ECRI
!T) !cloud droplet number above cloud base
!
!               end if
!
!               QT = CLI
!               RATE = 0.0
!               FPRECIP = 0.0
!
!               if (QT .gt. 0.0) then
!
!! if FICE is already >= 1.0 then the cloud is glaciated and there is no need to do anymore partitioning
!
!                  if (FICE .ge. 1.0) then
!
!
!                     CALL  Qremoval(RATE, FICE, FP_D, FP_I, Tparcel,  & 
!                           POL(L), QT,  NICE, NDROP, CVW_X, FPICE, &
!                           DT_LYR, RIMM, CO_AUTO(I)) 
!
!
!
!                     dNICE = -NICE*FP_I 
!                     NICE  =  (NICE +dNICE*DT_LYR)*ETA(L+1)/ETA(L) !ice
!
!                     MINNICE = max(QICE*(1.0-RATE*DT_LYR), 0.0)/4.0e-8!assuming maximum vol radius 250 microns
!                     MAXNICE = max(QICE*(1.0-RATE*DT_LYR), 0.0)/2.51e-12 !assuming minimum vol radius 10 microns
!
!                     NICE=MIN(max(NICE, MINNICE), MAXNICE)
!
!                     FICE = 1.0
!
!                  else 
!
!! Cloud is not completely glaciated do the whole thing
!! ALL these subroutines return tendencies
!
!
!                     CALL  INfreezing(QLIQ, NDROP, NIN, NDUST, NSOOT, INDUST, INSOOT, Tparcel, POL(L), CVW_X, DDUST, DSOOT)  !ca
!lculate the freezing fraction of the aerosol at this level
!
!                     NIN = min(NIN, NDROP/DT_LYR)
!
!                     call Qgrowth(Tparcel, POL(L), QICE, NICE, QT, NIN, dQIG, RIMM, FNDRIM)
!
!                     CALL  Qremoval(RATE, FICE, FP_D, FP_I, Tparcel,  & 
!                           POL(L), QT,  NICE, NDROP, CVW_X, FPICE, &
!                           DT_LYR,  RIMM, CO_AUTO(I)) 
!
!
!
!!ice number tendency: -precip + freezin
!                     dNICE = -NICE*FP_I  + NIN     
!                     NICE  =  (NICE +dNICE*DT_LYR)*ETA(L+1)/ETA(L) !ice
!                     NICE =max(NICE, 0.0)
!
!
!!ice mass tendency: growth - precip
!                     dQICE = -QICE*FPICE + dQIG
!                     QICE  =  min((QICE + dQICE*DT_LYR)*ETA(L+1)/ETA(L), QT) !ice
!                     QICE=max(min(QT, QICE), 0.0)
!
!
!! Liquid Tendency: source/evap -  precip
!!dQLIQ = max((CLI-QICE), -QLIQ)/DT_LYR -QLIQ*max(RATE-FPICE, 0.0)
!! dQLIQ = CLI*(1.0-RATE*DT_LYR)/DT_LYR -dQICE - QLIQ*max(RATE-FPICE, 0.0)
!!QLIQ  =  max((QLIQ + dQLIQ*DT_LYR)*ETA(L+1)/ETA(L), 0.0) !liquid. This is actually diagnostic
!                     QLIQ=max((QT-QICE), 0.0)
!
!
!!droplet number tendency: -precip - freezin + activation + activated entrained aerosol
!
!
!                     dNDROP =-NDROP*FP_D - NIN -  FNDRIM*NDROP/DT_LYR + max(NDROP_ACT-NDROP, 0.0)/DT_LYR          
!
!!dNDROP =-NDROP*FP_D - NIN -  FNDRIM*NDROP/DT_LYR + NDROP_ACT/DT_LYR
!
!                     NDROP =  (NDROP + dNDROP*DT_LYR)*ETA(L+1)/ETA(L) + &
!                           (ZET(L) - ZET(L+1))*ALM*MAX((NDROP_AMB-NDROP), 0.0)
!
!!Aerosol tendency: Entrainment - freezing
!
!                     NDUST = (NDUST - INDUST*DT_LYR)*ETA(L+1)/ETA(L) + &
!                           (ZET(L) - ZET(L+1))*ALM*MAX(NDUST_AMB-NDUST, 0.0) 
!
!                     NSOOT =  (NSOOT - INSOOT*DT_LYR)*ETA(L+1)/ETA(L)  + &     
!                           (ZET(L) - ZET(L+1))*ALM*MAX(NSOOT_AMB-NSOOT, 0.0)  
!
!
!                           
!!Update FICE and perform Sanity checks
!
!
!                     MINNDROP = (1.0-FICE)*QLIQ*max(1.0-RATE*DT_LYR, 0.0)/2.e-10    !assuming maximum vol radius 36 microns
!                     MAXNDROP = (1.0-FICE)*QLIQ*max(1.0-RATE*DT_LYR, 0.0)/3.35e-14 !assuming minimum vol radius 2 microns
!                     MINNICE = QICE/4.0e-8!assuming maximum vol radius 250 microns
!                     MAXNICE = QICE/2.51e-12 !assuming minimum vol radius 10 microns
!
!                     IF ((NICE .gt. MAXNICE) .or. (NICE .lt. MINNICE))   then    
!!print *, 'nilim', NICE*1e-6, MINNICE*1e-6, MAXNICE*1e-6
!                     END IF
!
!                     IF ((NDROP .gt. MAXNDROP) .or. (NDROP .lt. MINNDROP))      then 
!!print *, 'ndroplim', NDROP*1e-6, MINNDROP*1e-6, MAXNDROP*1e-6
!                     end if
!
!
!                     NSOOT=MAX(NSOOT, 0.0)
!                     NDUST=MAX(NDUST, 0.0)              
!
!                     NDROP=MIN(max(NDROP, MINNDROP), MAXNDROP)
!                     NICE=MIN(max(NICE, MINNICE), MAXNICE)
!
!                     FICE=max(min(QICE/QT, 1.0), 0.0)
!
!                     IF (FICE .ge. 1.0) THEN !Complete glaciation
!                        NICE=NICE+NDROP 
!                        NDROP = 0.0
!                        QICE  = QT
!                        QLIQ= 0.0
!                     END IF
!
!                     IF (Tparcel .LT. T_ICE_ALL) THEN !instantaneous freezing
!                        NICE=NICE+NDROP 
!                        NDROP = 0.0
!                        FICE  = 1.0
!                        QICE  = QT
!                        QLIQ=0.0
!                     END IF
!
!                     IF (Tparcel .GT. T_ICE_MAX) THEN !instantaneous melting
!                        NDROP=NICE+NDROP 
!                        NICE = 0.0
!                        FICE  = 0.0
!                        QICE  = 0.0
!                        QLIQ=QT
!                     END IF
!
!                  END IF
!
!               else 
!
!                  FICE =0.0 
!                  QICE = 0.0
!                  QLIQ = 0.0
!                  NICE= 0.0 
!                  NDROP = 0.0
!                  RATE =0.0
!               end if
!
!               FPRECIP= RATE*DT_LYR
!
!!RATE=RATE*F4
!! NDROP=NDROP*F4
!!NICE=NICE*(1.0-F4)
!
!!print *, TE_A, FICE, 'NICE', NICE*1e-6, 'NDROP', NDROP*1e-6, L
!!print *, 'FPI', FP_I*DT_LYR, 'FPD', FP_D*DT_LYR, 'FPICE', FPICE, 'FPRE', FPRECIP, QT, QLIQ
!
!            else !Bacmeister 2006 microphysics
                  CALL SUNDQ3_ICE(te_a, sdqv2, sdqv3, sdqvt1, f2, f3)
! * F5  ! F4 reduces AUTO for shallow clouds, F5 modifies auto for deep clouds
                  c00_x = co_auto(i)*f2*f3*f4
                  cli_crit_x = cli_crit/(f2*f3)
                  arg1 = -(cli**2/cli_crit_x**2)
                  rate = c00_x*(1.0-EXP(arg1))
                  IF (cvw(l) .LT. 1.00) THEN
                    cvw_x = 1.00
                  ELSE
                    cvw_x = cvw(l)
                  END IF
! really trust it at low values
! l.h.s. DT_LYR => time in layer (L,L+1)
                  dt_lyr = (zet(l)-zet(l+1))/cvw_x
                  closs = cll0(l)*rate*dt_lyr
                  IF (closs .GT. cll0(l)) THEN
                    closs = cll0(l)
                  ELSE
                    closs = closs
                  END IF
                  cll0(l) = cll0(l) - closs
                  dll0(l) = closs
                  IF (closs .GT. 0.) THEN
                    wlq = wlq - closs
                    rnn(l) = closs
                  ELSE
                    rnn(l) = 0.
                  END IF
                END DO
!AER_CLOUD=======================================
!            CNVNDROP(IC)=NDROP
!            CNVNICE(IC)=NICE
!            CNVFICE(IC)=FICE
                wlq = wlq - qst(ic)*eta(ic)
!     CALCULATE GAMMAS AND KERNEL
! MS-A30 (W/O GRAV)
                gms(k) = (sht(k)-ssl(k))*pri(k)
! MS-A31 (W/O GRAV)
                gmh(k) = gms(k) + (qht(k)-qol(k))*pri(k)*alhl
! MS-A37 (W/O GRAV)
                akm = gmh(k)*gam(k-1)*dpb(k-1)
                tx2 = gmh(k)
                DO l=k-1,ic+1,-1
                  gms(l) = (eta(l)*(sht(l)-ssl(l))+eta(l+1)*(ssl(l)-sht(&
&                   l+1)))*pri(l)
                  gmh(l) = gms(l) + (eta(l)*(qht(l)-qol(l))+eta(l+1)*(&
&                   qol(l)-qht(l+1)))*alhl*pri(l)
                  tx2 = tx2 + (eta(l)-eta(l+1))*gmh(l)
                  akm = akm - gms(l)*eht(l)*pki(l) + tx2*ght(l)
                END DO
                gms(ic) = eta(ic+1)*(ssl(ic)-sht(ic+1))*pri(ic)
                akm = akm - gms(ic)*eta(ic+1)*dpb(ic)*pki(ic)
                gmh(ic) = gms(ic) + (eta(ic+1)*(qol(ic)-qht(ic+1))*alhl+&
&                 eta(ic)*(hst(ic)-hol(ic)))*pri(ic)
                IF (smooth_hst) gmhx = gms(ic) + (eta(ic+1)*(qol(ic)-qht&
&                   (ic+1))*alhl+eta(ic)*(hstx-hol(ic)))*pri(ic)
!    CLOUD BASE MASS FLUX
                IF (akm .GE. 0.0 .OR. wlq .LT. 0.0) THEN
!  =========>
                  rc(ic) = 5
                  RETURN
                ELSE
! MS-A39 MASS-FLUX IN Pa/step
                  wfn = -((wfn-acr)/akm)
! WMP Store the full mass-flux to use in efficiency diagnostic
                  ras_wfn(i) = wfn
                  IF (tau(ic)*wfn .GT. (prs(k+1)-prs(k))*(100.*pblfrac)&
&                 ) THEN
                    wfn = (prs(k+1)-prs(k))*(100.*pblfrac)
                  ELSE
                    wfn = tau(ic)*wfn
                  END IF
!! WMP RAS DIAGNOSTICS that make up TAU(IC)
! Fill the RAS timescale diagnostic
                  ras_time(i) = rasal(ic)
! Fill the RAS RH trigger diagnostic
                  ras_trg(i) = trg
! Fill the RAS Tokioka diagnostic
                  ras_toki(i) = toki
! Fill the RAS PBL fraction diagnostic
                  ras_pbl(i) = (prs(k+1)-prs(k))*(100.*pblfrac)
! Fill the RAS efficiency diagnostic
! RAS_EFFICIENCY(I) = WFN/RAS_EFFICIENCY(I)
!! WMP RAS DIAGNOSTICS
!    CUMULATIVE PRECIP AND CLOUD-BASE MASS FLUX FOR OUTPUT
                  wfnog = wfn*gravi
                  tem = wfn*gravi
! (kg/m^2/step)
                  cll(ic) = cll(ic) + wlq*tem
! (kg/m^2/step)
                  rmf(ic) = rmf(ic) + tem
! (kg/m^2/step)
                  rmfd(ic) = rmfd(ic) + tem*eta(ic)
                  DO l=ic+1,k
! (kg/m^2/step)
                    rmfp(l) = tem*eta(l)
! (kg/m^2/step)
                    rmfc(l) = rmfc(l) + rmfp(l)
                    dllx(l) = dllx(l) + tem*dll0(l)
                    IF (cvw(l) .GT. 0.0) THEN
                      updfrp(l) = rmfp(l)*(ddt/daylen)*1000./(cvw(l)*prs&
&                       (l))
                    ELSE
                      updfrp(l) = 0.0
                    END IF
! current cloud; incloud condensate
                    clli(l) = cll0(l)/eta(l)
!  cumulative grid mean convective condensate
                    cllb(l) = cllb(l) + updfrp(l)*clli(l)
                    updfrc(l) = updfrc(l) + updfrp(l)
                  END DO
!    THETA AND Q CHANGE DUE TO CLOUD TYPE IC
                  DO l=ic,k
! (kg/m^2/step)
                    rns(l) = rns(l) + rnn(l)*tem
                    gmh(l) = gmh(l)*wfn
                    gms(l) = gms(l)*wfn
                    qoi(l) = qoi(l) + (gmh(l)-gms(l))*alhi
                    poi(l) = poi(l) + gms(l)*pki(l)*cpi
                    qst(l) = qst(l) + gms(l)*bet(l)*cpi
                  END DO
                  IF (smooth_hst) THEN
                    gmhx = gmhx*wfn
                    dqx = (gmhx-gmh(ic))*alhi
                    rns(ic) = rns(ic) + dqx/(pri(ic)*grav)
                  END IF
                  IF (do_tracers) THEN
!*FRICFAC*0.5
                    wfn = wfn*0.5*1.0
                    tem = wfn*pri(k)
                    DO itr=1,itrcr
                      xcu(k, itr) = xcu(k, itr) + tem*(xoi(k-1, itr)-xoi&
&                       (k, itr))
                    END DO
                    DO itr=1,itrcr
                      DO l=k-1,ic+1,-1
                        tem = wfn*pri(l)
                        xcu(l, itr) = xcu(l, itr) + tem*((xoi(l-1, itr)-&
&                         xoi(l, itr))*eta(l)+(xoi(l, itr)-xoi(l+1, itr)&
&                         )*eta(l+1))
                      END DO
                    END DO
                    tem = wfn*pri(ic)
                    DO itr=1,itrcr
                      xcu(ic, itr) = xcu(ic, itr) + (2.*(xht(itr)-xoi(ic&
&                       , itr)*(eta(ic)-eta(ic+1)))-(xoi(ic, itr)+xoi(ic&
&                       +1, itr))*eta(ic+1))*tem
                    END DO
                    DO itr=1,itrcr
                      DO l=ic,k
                        xoi(l, itr) = xoi(l, itr) + xcu(l, itr)
                      END DO
                    END DO
                  ELSE
!*FRICFAC*0.5
                    wfn = wfn*0.5*1.0
                  END IF
                  lambdsv(ic) = 1.000
!   CUMULUS FRICTION
                  IF (fricfac .LE. 0.0) THEN
                    rc(ic) = 0
!  NO CUMULUS FRICTION =========>>
                    RETURN
                  ELSE
                    wfn = wfn*fricfac*EXP(-(alm/friclambda))
                    tem = wfn*pri(k)
                    ucu(k) = ucu(k) + tem*(uoi(k-1)-uoi(k))
                    vcu(k) = vcu(k) + tem*(voi(k-1)-voi(k))
                    DO l=k-1,ic+1,-1
                      tem = wfn*pri(l)
                      ucu(l) = ucu(l) + tem*((uoi(l-1)-uoi(l))*eta(l)+(&
&                       uoi(l)-uoi(l+1))*eta(l+1))
                      vcu(l) = vcu(l) + tem*((voi(l-1)-voi(l))*eta(l)+(&
&                       voi(l)-voi(l+1))*eta(l+1))
                    END DO
                    tem = wfn*pri(ic)
                    ucu(ic) = ucu(ic) + (2.*(uht-uoi(ic)*(eta(ic)-eta(ic&
&                     +1)))-(uoi(ic)+uoi(ic+1))*eta(ic+1))*tem
                    vcu(ic) = vcu(ic) + (2.*(vht-voi(ic)*(eta(ic)-eta(ic&
&                     +1)))-(voi(ic)+voi(ic+1))*eta(ic+1))*tem
                    dissk0(ic) = eta(ic)*grav*wfnog*pri(ic)*0.5*((uht/&
&                     eta(ic)-uoi(ic))**2+(vht/eta(ic)-voi(ic))**2)
                    DO l=ic,k
                      uoi(l) = uoi(l) + ucu(l)
                      voi(l) = voi(l) + vcu(l)
                    END DO
                    rc(ic) = 0
                    RETURN
                  END IF
                END IF
              END IF
            END IF
          END IF
        END IF
      END IF
    END SUBROUTINE CLOUDE
    SUBROUTINE ACRITN(pl, plb, acr)
      IMPLICIT NONE
      REAL, INTENT(IN) :: pl, plb
      REAL, INTENT(OUT) :: acr
      INTEGER :: iwk
!!REAL, PARAMETER :: FACM=0.5
      REAL, PARAMETER :: ph(15)=(/150.0, 200.0, 250.0, 300.0, 350.0, &
&       400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, &
&       850.0/)
!!*FACM
      REAL, PARAMETER :: a(15)=(/1.6851, 1.1686, 0.7663, 0.5255, 0.4100&
&       , 0.3677, 0.3151, 0.2216, 0.1521, 0.1082, 0.0750, 0.0664, 0.0553&
&       , 0.0445, 0.0633/)
      INTRINSIC INT
      iwk = INT(pl*0.02 - 0.999999999)
      IF (iwk .GT. 1 .AND. iwk .LE. 15) THEN
        acr = a(iwk-1) + (pl-ph(iwk-1))*.02*(a(iwk)-a(iwk-1))
      ELSE IF (iwk .GT. 15) THEN
        acr = a(15)
      ELSE
        acr = a(1)
      END IF
      acr = acritfac*acr*(plb-pl)
      RETURN
    END SUBROUTINE ACRITN
!  Differentiation of rnevp in forward (tangent) mode (with options r8):
!   variations   of useful results: cnv_prc3 qoi poi zet
!   with respect to varying inputs: cnv_prc3 qoi poi rns zet
    SUBROUTINE RNEVP_TLM()
      IMPLICIT NONE
      zet_tl(k+1) = 0.0_8
      zet(k+1) = 0
      DO l=k,icmin,-1
        tem_tl = (prj(l+1)-prj(l))*cpbg*poi_tl(l)
        tem = poi(l)*(prj(l+1)-prj(l))*cpbg
        zet_tl(l) = zet_tl(l+1) + tem_tl
        zet(l) = zet(l+1) + tem
      END DO
      DO l=icmin,k
        tem = pri(l)*grav
        cnv_prc3_tl(i, l) = tem*rns_tl(l)
        cnv_prc3(i, l) = rns(l)*tem
      END DO
!! If hst is smoothed then adjusted precips may be negative
      IF (smooth_hst) THEN
        DO l=icmin,k
          IF (cnv_prc3(i, l) .LT. 0.) THEN
            qoi_tl(l) = qoi_tl(l) + cnv_prc3_tl(i, l)
            qoi(l) = qoi(l) + cnv_prc3(i, l)
            poi_tl(l) = poi_tl(l) - alhl*cnv_prc3_tl(i, l)/cp/prj(l+1)
            poi(l) = poi(l) - cnv_prc3(i, l)*(alhl/cp)/prj(l+1)
            cnv_prc3_tl(i, l) = 0.0_8
            cnv_prc3(i, l) = 0.
          END IF
        END DO
      END IF
      RETURN
    END SUBROUTINE RNEVP_TLM
    SUBROUTINE RNEVP()
      IMPLICIT NONE
      zet(k+1) = 0
      DO l=k,icmin,-1
        tem = poi(l)*(prj(l+1)-prj(l))*cpbg
        zet(l) = zet(l+1) + tem
      END DO
      DO l=icmin,k
        tem = pri(l)*grav
        cnv_prc3(i, l) = rns(l)*tem
      END DO
!! If hst is smoothed then adjusted precips may be negative
      IF (smooth_hst) THEN
        DO l=icmin,k
          IF (cnv_prc3(i, l) .LT. 0.) THEN
            qoi(l) = qoi(l) + cnv_prc3(i, l)
            poi(l) = poi(l) - cnv_prc3(i, l)*(alhl/cp)/prj(l+1)
            cnv_prc3(i, l) = 0.
          END IF
        END DO
      END IF
      RETURN
    END SUBROUTINE RNEVP
!  Differentiation of htest in forward (tangent) mode (with options r8):
!   variations   of useful results: hst qol sht ssl zet zol hol
!   with respect to varying inputs: hst qoi qol sht qst poi ssl
!                zet zol
    SUBROUTINE HTEST_TLM()
      IMPLICIT NONE
      REAL, DIMENSION(k0) :: hol1
      INTEGER :: lminhol
      REAL :: minhol
      INTRINSIC AMIN1
      INTRINSIC AMAX1
! HOL initialized here in order not to confuse Valgrind debugger
      hol = 0.
      lminhol = k + 1
      minhol = -999999.
      zet_tl(k+1) = 0.0_8
      zet(k+1) = 0
      sht_tl(k+1) = cp*prj(k+1)*poi_tl(k)
      sht(k+1) = cp*poi(k)*prj(k+1)
      hol_tl = 0.0_8
      DO l=k,icmin,-1
        IF (qst(l)*rhmax .GT. qoi(l)) THEN
          qol_tl(l) = qoi_tl(l)
          qol(l) = qoi(l)
        ELSE
          qol_tl(l) = rhmax*qst_tl(l)
          qol(l) = qst(l)*rhmax
        END IF
        IF (0.000 .LT. qol(l)) THEN
          qol(l) = qol(l)
        ELSE
          qol_tl(l) = 0.0_8
          qol(l) = 0.000
        END IF
        ssl_tl(l) = cp*prj(l+1)*poi_tl(l) + grav*zet_tl(l+1)
        ssl(l) = cp*prj(l+1)*poi(l) + grav*zet(l+1)
        hol_tl(l) = ssl_tl(l) + alhl*qol_tl(l)
        hol(l) = ssl(l) + qol(l)*alhl
        hst_tl(l) = ssl_tl(l) + alhl*qst_tl(l)
        hst(l) = ssl(l) + qst(l)*alhl
        tem_tl = (prj(l+1)-prj(l))*cpbg*poi_tl(l)
        tem = poi(l)*(prj(l+1)-prj(l))*cpbg
        zet_tl(l) = zet_tl(l+1) + tem_tl
        zet(l) = zet(l+1) + tem
        zol_tl(l) = zet_tl(l+1) + (prj(l+1)-prh(l))*cpbg*poi_tl(l)
        zol(l) = zet(l+1) + (prj(l+1)-prh(l))*poi(l)*cpbg
      END DO
      hol1 = hol
      DO l=k-1,icmin+1,-1
        hol1(l) = 0.25*hol(l+1) + 0.50*hol(l) + 0.25*hol(l-1)
        IF (minhol .GE. hol1(l) .OR. minhol .LT. 0.) THEN
          minhol = hol1(l)
          lminhol = l
        END IF
      END DO
      sige_minhol = sige(lminhol)
    END SUBROUTINE HTEST_TLM
    SUBROUTINE HTEST()
      IMPLICIT NONE
      REAL, DIMENSION(k0) :: hol1
      INTEGER :: lminhol
      REAL :: minhol
      INTRINSIC AMIN1
      INTRINSIC AMAX1
! HOL initialized here in order not to confuse Valgrind debugger
      hol = 0.
      lminhol = k + 1
      minhol = -999999.
      zet(k+1) = 0
      sht(k+1) = cp*poi(k)*prj(k+1)
      DO l=k,icmin,-1
        IF (qst(l)*rhmax .GT. qoi(l)) THEN
          qol(l) = qoi(l)
        ELSE
          qol(l) = qst(l)*rhmax
        END IF
        IF (0.000 .LT. qol(l)) THEN
          qol(l) = qol(l)
        ELSE
          qol(l) = 0.000
        END IF
        ssl(l) = cp*prj(l+1)*poi(l) + grav*zet(l+1)
        hol(l) = ssl(l) + qol(l)*alhl
        hst(l) = ssl(l) + qst(l)*alhl
        tem = poi(l)*(prj(l+1)-prj(l))*cpbg
        zet(l) = zet(l+1) + tem
        zol(l) = zet(l+1) + (prj(l+1)-prh(l))*poi(l)*cpbg
      END DO
      hol1 = hol
      DO l=k-1,icmin+1,-1
        hol1(l) = 0.25*hol(l+1) + 0.50*hol(l) + 0.25*hol(l-1)
        IF (minhol .GE. hol1(l) .OR. minhol .LT. 0.) THEN
          minhol = hol1(l)
          lminhol = l
        END IF
      END DO
      sige_minhol = sige(lminhol)
    END SUBROUTINE HTEST
    SUBROUTINE FINDDTLS()
      IMPLICIT NONE
      REAL :: sigdt0, sigmax, sigmin
      INTEGER :: ll
      INTEGER, ALLOCATABLE :: the_seed(:)
      INTEGER :: seed_len
      INTRINSIC RANDOM_SEED
      INTRINSIC INT
      INTRINSIC MIN
      INTRINSIC ALLOCATED
      INTRINSIC RANDOM_NUMBER
      REAL :: pwr1
      INTEGER :: x1
      seed_len = 0
      CALL RANDOM_SEED(size=seed_len)
      ALLOCATE(the_seed(seed_len))
      the_seed(1) = seedras(i, 1)*iras(i) + seedras(i, 2)*jras(i)
      the_seed(2) = seedras(i, 1)*jras(i) + seedras(i, 2)*iras(i)
      the_seed(1) = the_seed(1)*seedras(i, 1)/(seedras(i, 2)+10)
      the_seed(2) = the_seed(2)*seedras(i, 1)/(seedras(i, 2)+10)
      IF (the_seed(1) .EQ. 0) the_seed(1) = 5
      IF (the_seed(2) .EQ. 0) the_seed(2) = -5
! Gfortran uses longer seeds, so fill the rest with zero
      IF (seed_len .GT. 2) the_seed(3:) = 0
      CALL RANDOM_SEED(put=the_seed)
      sigmax = sige(k)
      sigmin = sige(icmin)
      IF (rasncl .LT. 0.0) THEN
!! NO SHALLOW CONV   N_DTL = 56 - ICMIN
        n_dtl = k - icmin
      ELSE
        x1 = INT(rasncl)
        IF (x1 .GT. k - icmin) THEN
          n_dtl = k - icmin
        ELSE
          n_dtl = x1
        END IF
      END IF
      IF (ALLOCATED(icl_v)) THEN
        DEALLOCATE(icl_v)
      END IF
      ALLOCATE(icl_v(n_dtl))
      IF (rasncl .LT. 0.0 .AND. rasncl .GE. -100.) THEN
        DO l=1,n_dtl
          icl_v(l) = icmin + l - 1
        END DO
      ELSE IF (rasncl .LT. -100.0) THEN
        DO l=1,n_dtl
          icl_v(l) = k - l
        END DO
      ELSE
!! NO SHALLOW CONV           ICL_V(L) = 56 - L
        DO l=1,n_dtl
          CALL RANDOM_NUMBER(sigdt0)
          pwr1 = sigdt0**rdtlexpon
          sigdt0 = 1.00 - pwr1
          sigdt0 = sigmin + sigdt0*(sigmax-sigmin)
          DO ll=icmin,k
            IF (sige(ll+1) .GE. sigdt0 .AND. sige(ll) .LT. sigdt0) icl_v&
&             (l) = ll
          END DO
        END DO
      END IF
      DEALLOCATE(the_seed)
    END SUBROUTINE FINDDTLS
!  Differentiation of strap in forward (tangent) mode (with options r8):
!   variations   of useful results: clw tho qho vho cnv_updfrc
!                uho flxd gm1 cvw dqq ght bet qoi_sv uoi_sv qoi
!                voi qst updfrc poi rns poi_sv uoi rmfd voi_sv
!                updfrp cll0 cll rmfp gam
!   with respect to varying inputs: clw tho qho vho cnv_updfrc
!                uho flxd gm1 cvw dqq ght bet qoi_sv uoi_sv qoi
!                voi qst updfrc poi rns poi_sv uoi rmfd voi_sv
!                updfrp cll0 cll rmfp gam
    SUBROUTINE STRAP_TLM(final)
      IMPLICIT NONE
      INTEGER :: final
      REAL, DIMENSION(k0) :: wght, massf
      REAL :: wght0, prcbl
      INTEGER, PARAMETER :: nrands=1
      REAL :: rndu(nrands)
      INTEGER :: seedcbl(nrands)
! !DESCRIPTION:
!   {\tt STRAP} is called: FINAL=0, to compute cloud base layer CBL properties
!   given a value K for the index of the upper {\em EDGE} of the CBL; FINAL=1
!   to redistribute convective tendencies within CBL
      INTEGER :: kk
      INTRINSIC SQRT
      INTRINSIC MAX
      INTRINSIC ABS
      INTRINSIC PRESENT
      INTRINSIC ALLOCATED
      REAL :: abs0
      REAL :: abs1
      REAL, DIMENSION(k-icmin+1) :: arg1
      REAL :: pwx1
      REAL :: pwy1
      REAL :: pwr1
!  LOCAL VARIABLES FOR USE IN CLOUDE
!!IF (.NOT. PRESENT(FINAL)) THEN
      IF (final .EQ. 0) THEN
!!PRJ(ICMIN:K+1) = PKE(I,ICMIN:K+1)
        DO kk=icmin,k+1
          prj(kk) = pke(i, kk)
        END DO
! These initialized here in order not to confuse Valgrind debugger
        poi = 0.
! Do not believe it actually makes any difference.
        qoi = 0.
        uoi = 0.
        voi = 0.
        prs(icmin:k0+1) = ple(i, icmin:k0+1)
        poi_tl = 0.0_8
        poi_tl(icmin:k) = tho_tl(i, icmin:k)
        poi(icmin:k) = tho(i, icmin:k)
        qoi_tl = 0.0_8
        qoi_tl(icmin:k) = qho_tl(i, icmin:k)
        qoi(icmin:k) = qho(i, icmin:k)
        uoi_tl = 0.0_8
        uoi_tl(icmin:k) = uho_tl(i, icmin:k)
        uoi(icmin:k) = uho(i, icmin:k)
        voi_tl = 0.0_8
        voi_tl(icmin:k) = vho_tl(i, icmin:k)
        voi(icmin:k) = vho(i, icmin:k)
        arg1(:) = (uoi(icmin:k)-uoi(k))**2 + (voi(icmin:k)-voi(k))**2
        wsp(icmin:k) = SQRT(arg1(:))
        qst_tl(icmin:k) = 0.0_8
        qst(icmin:k) = qss(i, icmin:k)
        dqq_tl(icmin:k) = 0.0_8
        dqq(icmin:k) = dqs(i, icmin:k)
        IF (do_tracers) THEN
          DO itr=1,itrcr
            xoi(icmin:k, itr) = xho(i, icmin:k, itr)
          END DO
        END IF
!!! Mass fraction of each layer below cloud base
!!! contributed to aggregate cloudbase layer (CBL)
        massf(:) = wgt0(i, :)
!!! RESET PRESSURE at bottom edge of CBL
        prcbl = prs(k)
        DO l=k,k0
          prcbl = prcbl + massf(l)*(prs(l+1)-prs(l))
        END DO
        prs(k+1) = prcbl
        pwx1 = prs(k+1)/1000.
        pwy1 = mapl_rgas/mapl_cp
        prj(k+1) = pwx1**pwy1
        DO l=k,icmin,-1
          pol(l) = 0.5*(prs(l)+prs(l+1))
          prh(l) = (prs(l+1)*prj(l+1)-prs(l)*prj(l))/(onepkap*(prs(l+1)-&
&           prs(l)))
          pki(l) = 1.0/prh(l)
          dpt(l) = prh(l) - prj(l)
          dpb(l) = prj(l+1) - prh(l)
          pri(l) = .01/(prs(l+1)-prs(l))
        END DO
!!!!! RECALCULATE PROFILE QUAN. IN LOWEST STRAPPED LAYER
        IF (k .LE. k0) THEN
          poi_tl(k) = 0.0_8
          poi(k) = 0.
          qoi_tl(k) = 0.0_8
          qoi(k) = 0.
          uoi_tl(k) = 0.0_8
          uoi(k) = 0.
          voi_tl(k) = 0.0_8
          voi(k) = 0.
!! SPECIFY WEIGHTS GIVEN TO EACH LAYER WITHIN SUBCLOUD "SUPERLAYER"
          wght = 0.
          DO l=k,k0
            wght(l) = massf(l)*(ple(i, l+1)-ple(i, l))/(prs(k+1)-prs(k))
          END DO
          DO l=k,k0
            poi_tl(k) = poi_tl(k) + wght(l)*tho_tl(i, l)
            poi(k) = poi(k) + wght(l)*tho(i, l)
            qoi_tl(k) = qoi_tl(k) + wght(l)*qho_tl(i, l)
            qoi(k) = qoi(k) + wght(l)*qho(i, l)
            uoi_tl(k) = uoi_tl(k) + wght(l)*uho_tl(i, l)
            uoi(k) = uoi(k) + wght(l)*uho(i, l)
            voi_tl(k) = voi_tl(k) + wght(l)*vho_tl(i, l)
            voi(k) = voi(k) + wght(l)*vho(i, l)
          END DO
          IF (do_tracers) THEN
            xoi(k, :) = 0.
            DO itr=1,itrcr
              DO l=k,k0
                xoi(k, itr) = xoi(k, itr) + wght(l)*xho(i, l, itr)
              END DO
            END DO
          END IF
          dqq_tl(k) = DQSAT_TLM(poi(k)*prh(k), prh(k)*poi_tl(k), pol(k)&
&           , qsat=qst(k), qsat_tl=qst_tl(k), dqsat=dqq(k))
        END IF
        WHERE (seedras(i, 1)/1000000. .LT. 1e-6) 
          rndu(:) = 1e-6
        ELSEWHERE
          rndu(:) = seedras(i, 1)/1000000.
        END WHERE
!!call congvec( npoints , seedcbl , rndu )
        dpth_bl = zcbl(i)
        IF (maxdallowed_d .GE. 0.) THEN
          abs0 = maxdallowed_d
        ELSE
          abs0 = -maxdallowed_d
        END IF
        IF (maxdallowed_s .GE. 0.) THEN
          abs1 = maxdallowed_s
        ELSE
          abs1 = -maxdallowed_s
        END IF
        mxdiam(i) = cnv_fraction(i)*abs0 + (1-cnv_fraction(i))*abs1
        IF (maxdallowed_e .LT. 0) THEN
! Make MXDIAM stochastic
          pwr1 = rndu(1)**maxdallowed_e
          mxdiam(i) = mxdiam(i)*pwr1
        END IF
        DO l=k,icmin,-1
!*
          bet_tl(l) = pki(l)*dqq_tl(l)
          bet(l) = dqq(l)*pki(l)
!*
          gam_tl(l) = -(pki(l)*lbcp*dqq_tl(l)/(1.0+lbcp*dqq(l))**2)
          gam(l) = pki(l)/(1.0+lbcp*dqq(l))
          IF (l .LT. k) THEN
            ght_tl(l+1) = dpb(l)*gam_tl(l) + dpt(l+1)*gam_tl(l+1)
            ght(l+1) = gam(l)*dpb(l) + gam(l+1)*dpt(l+1)
            gm1_tl(l+1) = 0.5*lbcp*((dqq_tl(l)*alhl*(1.0+lbcp*dqq(l))-&
&             dqq(l)*alhl*lbcp*dqq_tl(l))/(alhl*(1.0+lbcp*dqq(l)))**2+(&
&             dqq_tl(l+1)*alhl*(1.0+lbcp*dqq(l+1))-dqq(l+1)*alhl*lbcp*&
&             dqq_tl(l+1))/(alhl*(1.0+lbcp*dqq(l+1)))**2)
            gm1(l+1) = 0.5*lbcp*(dqq(l)/(alhl*(1.0+lbcp*dqq(l)))+dqq(l+1&
&             )/(alhl*(1.0+lbcp*dqq(l+1))))
          END IF
        END DO
        tcu(icmin:k) = -(poi(icmin:k)*prh(icmin:k))
        qcu(icmin:k) = -qoi(icmin:k)
        rns = 0.
        cll = 0.
        rmf = 0.
        rmfd = 0.
        rmfc = 0.
        rmfp = 0.
        cll0 = 0.
        dll0 = 0.
        cllx = 0.
        dllx = 0.
        clli = 0.
        cllb = 0.
        poi_sv_tl = poi_tl
        poi_sv = poi
        qoi_sv_tl = qoi_tl
        qoi_sv = qoi
        uoi_sv_tl = uoi_tl
        uoi_sv = uoi
        voi_sv_tl = voi_tl
        voi_sv = voi
        IF (do_tracers) xoi_sv = xoi
        lambdsv = 0.0
        cvw = 0.0
        updfrc = 0.0
        updfrp = 0.0
        dissk0 = 0.0
        cvw_tl = 0.0_8
        updfrc_tl = 0.0_8
        rns_tl = 0.0_8
        rmfd_tl = 0.0_8
        updfrp_tl = 0.0_8
        cll0_tl = 0.0_8
        cll_tl = 0.0_8
        rmfp_tl = 0.0_8
      END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!    IF (PRESENT(FINAL)) THEN
      IF (final .EQ. 1) THEN
        tho_tl(i, icmin:k-1) = poi_tl(icmin:k-1)
        tho(i, icmin:k-1) = poi(icmin:k-1)
        qho_tl(i, icmin:k-1) = qoi_tl(icmin:k-1)
        qho(i, icmin:k-1) = qoi(icmin:k-1)
        uho_tl(i, icmin:k-1) = uoi_tl(icmin:k-1)
        uho(i, icmin:k-1) = uoi(icmin:k-1)
        vho_tl(i, icmin:k-1) = voi_tl(icmin:k-1)
        vho(i, icmin:k-1) = voi(icmin:k-1)
        cnv_updfrc_tl(i, icmin:k-1) = updfrc_tl(icmin:k-1)
        cnv_updfrc(i, icmin:k-1) = updfrc(icmin:k-1)
        cnv_cvw(i, icmin:k-1) = cvw(icmin:k-1)
        cnv_qc(i, icmin:k-1) = cllb(icmin:k-1)
!======================AER_CLOUD=============
!               CNV_NDROP   (I,ICMIN:K-1)  =    CNVNDROP(ICMIN:K-1) !DONIF
!               CNV_NICE   (I,ICMIN:K-1)   =     CNVNICE(ICMIN:K-1) !DONIF
!               CNV_FICE   (I,ICMIN:K-1)   =     CNVFICE(ICMIN:K-1) !DONIF
!! De-strap tendencies from RAS
!! specify weighting "SHAPE"
        wght = wgt1(i, :)
!! Scale properly by layer masses
        wght0 = 0.
        DO l=k,k0
          wght0 = wght0 + wght(l)*(ple(i, l+1)-ple(i, l))
        END DO
        wght0 = (prs(k+1)-prs(k))/wght0
        wght = wght0*wght
        DO l=k,k0
          tho_tl(i, l) = tho_tl(i, l) + wght(l)*(poi_tl(k)-poi_sv_tl(k))
          tho(i, l) = tho(i, l) + wght(l)*(poi(k)-poi_sv(k))
          qho_tl(i, l) = qho_tl(i, l) + wght(l)*(qoi_tl(k)-qoi_sv_tl(k))
          qho(i, l) = qho(i, l) + wght(l)*(qoi(k)-qoi_sv(k))
          uho_tl(i, l) = uho_tl(i, l) + wght(l)*(uoi_tl(k)-uoi_sv_tl(k))
          uho(i, l) = uho(i, l) + wght(l)*(uoi(k)-uoi_sv(k))
          vho_tl(i, l) = vho_tl(i, l) + wght(l)*(voi_tl(k)-voi_sv_tl(k))
          vho(i, l) = vho(i, l) + wght(l)*(voi(k)-voi_sv(k))
        END DO
        IF (do_tracers) THEN
          xho(i, icmin:k-1, :) = xoi(icmin:k-1, :)
          DO itr=1,itrcr
            DO l=k,k0
              xho(i, l, itr) = xho(i, l, itr) + wght(l)*(xoi(k, itr)-&
&               xoi_sv(k, itr))
            END DO
          END DO
        END IF
!  (KG/m^2/s @ CLOUD BASE)
        flx(i, icmin:k) = rmf(icmin:k)*ddt/daylen
!  (KG/m^2/s @ CLOUD TOP)
        flxd_tl(i, icmin:k) = ddt*rmfd_tl(icmin:k)/daylen
        flxd(i, icmin:k) = rmfd(icmin:k)*ddt/daylen
!  (KG/m^2/s @ CLOUD TOP)
        flxc(i, icmin:k) = rmfc(icmin:k)*ddt/daylen
!  (KG/m^2/s )
        clw_tl(i, icmin:k) = ddt*cll_tl(icmin:k)/daylen
        clw(i, icmin:k) = cll(icmin:k)*ddt/daylen
        IF (PRESENT(disske)) disske(i, icmin:k-1) = dissk0(icmin:k-1)*&
&           ddt/daylen
        flx(i, 1:icmin-1) = 0.
        flxd_tl(i, 1:icmin-1) = 0.0_8
        flxd(i, 1:icmin-1) = 0.
        flxc(i, 1:icmin-1) = 0.
        clw_tl(i, 1:icmin-1) = 0.0_8
        clw(i, 1:icmin-1) = 0.
        IF (k .LT. k0) THEN
          flx(i, k:k0) = 0.
          flxd_tl(i, k:k0) = 0.0_8
          flxd(i, k:k0) = 0.
          flxc(i, k:k0) = 0.
          clw_tl(i, k:k0) = 0.0_8
          clw(i, k:k0) = 0.
        END IF
        irc(i, icmin:k-1) = rc(icmin:k-1)
        IF (ALLOCATED(icl_v)) THEN
          DEALLOCATE(icl_v)
        END IF
      END IF
      IF (final .EQ. 2) THEN
        flx(i, :) = 0.
        flxd_tl(i, :) = 0.0_8
        flxd(i, :) = 0.
        flxc(i, :) = 0.
        clw_tl(i, :) = 0.0_8
        clw(i, :) = 0.
        irc(i, icmin:k-1) = rc(icmin:k-1)
      END IF
      RETURN
    END SUBROUTINE STRAP_TLM
    SUBROUTINE STRAP(final)
      IMPLICIT NONE
      INTEGER :: final
      REAL, DIMENSION(k0) :: wght, massf
      REAL :: wght0, prcbl
      INTEGER, PARAMETER :: nrands=1
      REAL :: rndu(nrands)
      INTEGER :: seedcbl(nrands)
! !DESCRIPTION:
!   {\tt STRAP} is called: FINAL=0, to compute cloud base layer CBL properties
!   given a value K for the index of the upper {\em EDGE} of the CBL; FINAL=1
!   to redistribute convective tendencies within CBL
      INTEGER :: kk
      INTRINSIC SQRT
      INTRINSIC MAX
      INTRINSIC ABS
      INTRINSIC PRESENT
      INTRINSIC ALLOCATED
      REAL :: abs0
      REAL :: abs1
      REAL, DIMENSION(k-icmin+1) :: arg1
      REAL :: pwx1
      REAL :: pwy1
      REAL :: pwr1
!  LOCAL VARIABLES FOR USE IN CLOUDE
!!IF (.NOT. PRESENT(FINAL)) THEN
      IF (final .EQ. 0) THEN
!!PRJ(ICMIN:K+1) = PKE(I,ICMIN:K+1)
        DO kk=icmin,k+1
          prj(kk) = pke(i, kk)
        END DO
! These initialized here in order not to confuse Valgrind debugger
        poi = 0.
! Do not believe it actually makes any difference.
        qoi = 0.
        uoi = 0.
        voi = 0.
        prs(icmin:k0+1) = ple(i, icmin:k0+1)
        poi(icmin:k) = tho(i, icmin:k)
        qoi(icmin:k) = qho(i, icmin:k)
        uoi(icmin:k) = uho(i, icmin:k)
        voi(icmin:k) = vho(i, icmin:k)
        arg1(:) = (uoi(icmin:k)-uoi(k))**2 + (voi(icmin:k)-voi(k))**2
        wsp(icmin:k) = SQRT(arg1(:))
        qst(icmin:k) = qss(i, icmin:k)
        dqq(icmin:k) = dqs(i, icmin:k)
        IF (do_tracers) THEN
          DO itr=1,itrcr
            xoi(icmin:k, itr) = xho(i, icmin:k, itr)
          END DO
        END IF
!!! Mass fraction of each layer below cloud base
!!! contributed to aggregate cloudbase layer (CBL)
        massf(:) = wgt0(i, :)
!!! RESET PRESSURE at bottom edge of CBL
        prcbl = prs(k)
        DO l=k,k0
          prcbl = prcbl + massf(l)*(prs(l+1)-prs(l))
        END DO
        prs(k+1) = prcbl
        pwx1 = prs(k+1)/1000.
        pwy1 = mapl_rgas/mapl_cp
        prj(k+1) = pwx1**pwy1
        DO l=k,icmin,-1
          pol(l) = 0.5*(prs(l)+prs(l+1))
          prh(l) = (prs(l+1)*prj(l+1)-prs(l)*prj(l))/(onepkap*(prs(l+1)-&
&           prs(l)))
          pki(l) = 1.0/prh(l)
          dpt(l) = prh(l) - prj(l)
          dpb(l) = prj(l+1) - prh(l)
          pri(l) = .01/(prs(l+1)-prs(l))
        END DO
!!!!! RECALCULATE PROFILE QUAN. IN LOWEST STRAPPED LAYER
        IF (k .LE. k0) THEN
          poi(k) = 0.
          qoi(k) = 0.
          uoi(k) = 0.
          voi(k) = 0.
!! SPECIFY WEIGHTS GIVEN TO EACH LAYER WITHIN SUBCLOUD "SUPERLAYER"
          wght = 0.
          DO l=k,k0
            wght(l) = massf(l)*(ple(i, l+1)-ple(i, l))/(prs(k+1)-prs(k))
          END DO
          DO l=k,k0
            poi(k) = poi(k) + wght(l)*tho(i, l)
            qoi(k) = qoi(k) + wght(l)*qho(i, l)
            uoi(k) = uoi(k) + wght(l)*uho(i, l)
            voi(k) = voi(k) + wght(l)*vho(i, l)
          END DO
          IF (do_tracers) THEN
            xoi(k, :) = 0.
            DO itr=1,itrcr
              DO l=k,k0
                xoi(k, itr) = xoi(k, itr) + wght(l)*xho(i, l, itr)
              END DO
            END DO
          END IF
          dqq(k) = DQSAT(poi(k)*prh(k), pol(k), qsat=qst(k))
        END IF
        WHERE (seedras(i, 1)/1000000. .LT. 1e-6) 
          WHERE (seedras(i, 1)/1000000. .LT. 1e-6) 
            rndu(:) = 1e-6
          ELSEWHERE
            rndu(:) = seedras(i, 1)/1000000.
          END WHERE
        END WHERE
!!call congvec( npoints , seedcbl , rndu )
        dpth_bl = zcbl(i)
        IF (maxdallowed_d .GE. 0.) THEN
          abs0 = maxdallowed_d
        ELSE
          abs0 = -maxdallowed_d
        END IF
        IF (maxdallowed_s .GE. 0.) THEN
          abs1 = maxdallowed_s
        ELSE
          abs1 = -maxdallowed_s
        END IF
        mxdiam(i) = cnv_fraction(i)*abs0 + (1-cnv_fraction(i))*abs1
        IF (maxdallowed_e .LT. 0) THEN
! Make MXDIAM stochastic
          pwr1 = rndu(1)**maxdallowed_e
          mxdiam(i) = mxdiam(i)*pwr1
        END IF
        DO l=k,icmin,-1
!*
          bet(l) = dqq(l)*pki(l)
!*
          gam(l) = pki(l)/(1.0+lbcp*dqq(l))
          IF (l .LT. k) THEN
            ght(l+1) = gam(l)*dpb(l) + gam(l+1)*dpt(l+1)
            gm1(l+1) = 0.5*lbcp*(dqq(l)/(alhl*(1.0+lbcp*dqq(l)))+dqq(l+1&
&             )/(alhl*(1.0+lbcp*dqq(l+1))))
          END IF
        END DO
        tcu(icmin:k) = -(poi(icmin:k)*prh(icmin:k))
        qcu(icmin:k) = -qoi(icmin:k)
        rns = 0.
        cll = 0.
        rmf = 0.
        rmfd = 0.
        rmfc = 0.
        rmfp = 0.
        cll0 = 0.
        dll0 = 0.
        cllx = 0.
        dllx = 0.
        clli = 0.
        cllb = 0.
        poi_sv = poi
        qoi_sv = qoi
        uoi_sv = uoi
        voi_sv = voi
        IF (do_tracers) xoi_sv = xoi
        lambdsv = 0.0
        cvw = 0.0
        updfrc = 0.0
        updfrp = 0.0
        dissk0 = 0.0
      END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!    IF (PRESENT(FINAL)) THEN
      IF (final .EQ. 1) THEN
        tho(i, icmin:k-1) = poi(icmin:k-1)
        qho(i, icmin:k-1) = qoi(icmin:k-1)
        uho(i, icmin:k-1) = uoi(icmin:k-1)
        vho(i, icmin:k-1) = voi(icmin:k-1)
        cnv_updfrc(i, icmin:k-1) = updfrc(icmin:k-1)
        cnv_cvw(i, icmin:k-1) = cvw(icmin:k-1)
        cnv_qc(i, icmin:k-1) = cllb(icmin:k-1)
!======================AER_CLOUD=============
!               CNV_NDROP   (I,ICMIN:K-1)  =    CNVNDROP(ICMIN:K-1) !DONIF
!               CNV_NICE   (I,ICMIN:K-1)   =     CNVNICE(ICMIN:K-1) !DONIF
!               CNV_FICE   (I,ICMIN:K-1)   =     CNVFICE(ICMIN:K-1) !DONIF
!! De-strap tendencies from RAS
!! specify weighting "SHAPE"
        wght = wgt1(i, :)
!! Scale properly by layer masses
        wght0 = 0.
        DO l=k,k0
          wght0 = wght0 + wght(l)*(ple(i, l+1)-ple(i, l))
        END DO
        wght0 = (prs(k+1)-prs(k))/wght0
        wght = wght0*wght
        DO l=k,k0
          tho(i, l) = tho(i, l) + wght(l)*(poi(k)-poi_sv(k))
          qho(i, l) = qho(i, l) + wght(l)*(qoi(k)-qoi_sv(k))
          uho(i, l) = uho(i, l) + wght(l)*(uoi(k)-uoi_sv(k))
          vho(i, l) = vho(i, l) + wght(l)*(voi(k)-voi_sv(k))
        END DO
        IF (do_tracers) THEN
          xho(i, icmin:k-1, :) = xoi(icmin:k-1, :)
          DO itr=1,itrcr
            DO l=k,k0
              xho(i, l, itr) = xho(i, l, itr) + wght(l)*(xoi(k, itr)-&
&               xoi_sv(k, itr))
            END DO
          END DO
        END IF
!  (KG/m^2/s @ CLOUD BASE)
        flx(i, icmin:k) = rmf(icmin:k)*ddt/daylen
!  (KG/m^2/s @ CLOUD TOP)
        flxd(i, icmin:k) = rmfd(icmin:k)*ddt/daylen
!  (KG/m^2/s @ CLOUD TOP)
        flxc(i, icmin:k) = rmfc(icmin:k)*ddt/daylen
!  (KG/m^2/s )
        clw(i, icmin:k) = cll(icmin:k)*ddt/daylen
        IF (PRESENT(disske)) disske(i, icmin:k-1) = dissk0(icmin:k-1)*&
&           ddt/daylen
        flx(i, 1:icmin-1) = 0.
        flxd(i, 1:icmin-1) = 0.
        flxc(i, 1:icmin-1) = 0.
        clw(i, 1:icmin-1) = 0.
        IF (k .LT. k0) THEN
          flx(i, k:k0) = 0.
          flxd(i, k:k0) = 0.
          flxc(i, k:k0) = 0.
          clw(i, k:k0) = 0.
        END IF
        irc(i, icmin:k-1) = rc(icmin:k-1)
        IF (ALLOCATED(icl_v)) THEN
          DEALLOCATE(icl_v)
        END IF
      END IF
      IF (final .EQ. 2) THEN
        flx(i, :) = 0.
        flxd(i, :) = 0.
        flxc(i, :) = 0.
        clw(i, :) = 0.
        irc(i, icmin:k-1) = rc(icmin:k-1)
      END IF
      RETURN
    END SUBROUTINE STRAP
  END SUBROUTINE RASE_TLM
!  Differentiation of sundq3_ice in forward (tangent) mode (with options r8):
!   variations   of useful results: f2
!   with respect to varying inputs: temp f2
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE SUNDQ3_ICE_TLM(temp, temp_tl, rate2, rate3, te1, f2, f2_tl&
&   , f3)
    IMPLICIT NONE
    REAL, INTENT(IN) :: temp, rate2, rate3, te1
    REAL, INTENT(IN) :: temp_tl
    REAL, INTENT(OUT) :: f2, f3
    REAL, INTENT(OUT) :: f2_tl
!,RATE2,RATE3,TE1
    REAL :: xx, yy, te0, te2, jump1
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!  Ice - phase treatment totally invented
!!  Sharp increase in autoconversion in range
!!  ~~TE1 K ~< T < TE0 K .
!!  (JTB, 3/25/2003)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    te0 = 273.
    te2 = 200.
    jump1 = (rate2-1.0)/(te0-te1)**0.333
!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Ice - phase treatment  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IF (temp .GE. te0) THEN
      f2 = 1.0
      f3 = 1.0
      f2_tl = 0.0_8
    END IF
    IF (temp .GE. te1 .AND. temp .LT. te0) THEN
      f2_tl = -(jump1*0.3333*(te0-temp)**(-0.6667)*temp_tl)
      f2 = 1.0 + jump1*(te0-temp)**0.3333
      f3 = 1.0
    END IF
    IF (temp .LT. te1) THEN
      f2_tl = (-((rate3-rate2)*temp_tl))/(te1-te2)
      f2 = rate2 + (rate3-rate2)*(te1-temp)/(te1-te2)
      f3 = 1.0
    END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IF (f2 .GT. 27.0) THEN
      f2 = 27.0
      f2_tl = 0.0_8
    END IF
  END SUBROUTINE SUNDQ3_ICE_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE SUNDQ3_ICE(temp, rate2, rate3, te1, f2, f3)
    IMPLICIT NONE
    REAL, INTENT(IN) :: temp, rate2, rate3, te1
    REAL, INTENT(OUT) :: f2, f3
!,RATE2,RATE3,TE1
    REAL :: xx, yy, te0, te2, jump1
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!  Ice - phase treatment totally invented
!!  Sharp increase in autoconversion in range
!!  ~~TE1 K ~< T < TE0 K .
!!  (JTB, 3/25/2003)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    te0 = 273.
    te2 = 200.
    jump1 = (rate2-1.0)/(te0-te1)**0.333
!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Ice - phase treatment  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IF (temp .GE. te0) THEN
      f2 = 1.0
      f3 = 1.0
    END IF
    IF (temp .GE. te1 .AND. temp .LT. te0) THEN
      f2 = 1.0 + jump1*(te0-temp)**0.3333
      f3 = 1.0
    END IF
    IF (temp .LT. te1) THEN
      f2 = rate2 + (rate3-rate2)*(te1-temp)/(te1-te2)
      f3 = 1.0
    END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IF (f2 .GT. 27.0) f2 = 27.0
  END SUBROUTINE SUNDQ3_ICE
  SUBROUTINE CONGVEC(npoints, seed, ran)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npoints
    INTEGER, INTENT(INOUT) :: seed(npoints)
    REAL, INTENT(INOUT) :: ran(npoints)
! variables for RNG
    INTEGER :: irand, i2_16, overflow_32
    INTEGER, PARAMETER :: huge32=2147483647
    INTRINSIC MOD
    i2_16 = 65536
!i2_16=111
! Num. Recipes
    DO irand=1,npoints
! Marsaglia CONG algorithm
      seed(irand) = 1664525*seed(irand) + 1013904223
! mod 32 bit overflow
      seed(irand) = MOD(seed(irand), 2**32)
      ran(irand) = seed(irand)*0.931322574615479e-09
    END DO
  END SUBROUTINE CONGVEC
!==Subroutine Qremoval ============
!Physically based parameterization for removal of condensate (Barahona et al. GMD 2014)
!Written by Donifan Barahona according to DelGenio et al. 2005. J Climate with some modifications
!donifan.barahona@nasa.gov
!================================================================
  SUBROUTINE QREMOVAL(rate_q, fice_, f_nl, f_ni, te, pre, qc, ni, nl, &
&   vcnx, fpice_, dtl, rim, coauto)
    IMPLICIT NONE
!This calculations are needed since we do not have explicit microphysics in RAS. All Fs are tendencies
    REAL, INTENT(IN) :: fice_, te, pre, qc, vcnx, ni, nl, dtl, coauto
    REAL, INTENT(INOUT) :: rim
    REAL, INTENT(OUT) :: rate_q, f_nl, f_ni, fpice_
    REAL :: dc_r, dc_g, dc_i, lamr, lamg, lami, fqi, fqr, fqg, fpi, fpr&
&   , fpg, no, rho_r, rho_g, rho_i, qr, qg, qi, fqig, rho_a, psc, qpt, &
&   aux, vcn, ng, fni, fnr, fng, ni_, beta6, xs, prc, si, ai, ah, bh, tc&
&   , l, n
    REAL :: mui
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC EXP
    INTRINSIC LOG
    INTRINSIC SQRT
    REAL :: min1
    REAL :: min2
    REAL :: min3
    REAL :: arg1
    REAL :: pwx1
    REAL :: pwr1
    REAL :: result1
    REAL :: result2
    REAL :: x7
    REAL :: x6
    REAL :: x5
    REAL :: x4
    REAL :: x3
    REAL :: x2
    REAL :: x1
    vcn = 1.0
    IF (vcnx .GT. 10.0) THEN
      x1 = 10.0
    ELSE
      x1 = vcnx
    END IF
    IF (x1 .LT. 0.8) THEN
      vcn = 0.8
    ELSE
      vcn = x1
    END IF
!From detailed calculations
    arg1 = 7.48416e-04*te*te - 4.38424e-01*te + 8.62639e+01
    ai = EXP(arg1)
    ai = 1.0/ai
!From Murphy and Koop 2005
    aux = 210368.0 + 131.438*te - 3.32373e6/te - 41729.1*LOG(te)
!Assumes a saturated environment
    si = EXP(-(aux/8.314/te)) - 1.0
    fqr = 0.0
    fpr = 0.0
    fqi = 0.0
    fpi = 0.0
    fqg = 0.0
    fpg = 0.0
    rate_q = 0.0
    fpice_ = 0.0
    xs = 0.8
!Some constants
!Kg/m3 rain
    rho_r = 1000.0
!Kg/m3 graupel
    rho_g = 500.0
!Kg/m3 ice/snow
    rho_i = 900.0
    rho_a = pre*100.0/mapl_rgas/te
    psc = (pre*273.0/1000.0/te)**0.54
    IF (te - 273.15 .LT. -80.0) THEN
      tc = -80.0
    ELSE
      tc = te - 273.15
    END IF
!fqi  = min(0.25*(1.0-exp((TE-273.15)/10.0)), 1.0) !From delGenio 2005
!fqg  = 1.0-fqi
    fqg = rim
    fqi = 1.0 - fqg
    ng = ni*fqg
    ni_ = ni - ng
    qr = qc*(1.0-fice_)
    qg = qc*fqg*fice_
    qi = qc*fqi*fice_
    IF ((vcn/842.0/psc)**1.25 .LT. 1e-6) THEN
      x2 = 1e-6
    ELSE
      x2 = (vcn/842.0/psc)**1.25
    END IF
    IF (x2 .GT. 1.e-4) THEN
      dc_r = 1.e-4
    ELSE
      dc_r = x2
    END IF
    IF (1.0e-3*(vcn/19.3/psc)**2.70 .LT. 1.e-6) THEN
      x3 = 1.e-6
    ELSE
      x3 = 1.0e-3*(vcn/19.3/psc)**2.70
    END IF
    IF (x3 .GT. 1.e-2) THEN
      dc_g = 1.e-2
    ELSE
      dc_g = x3
    END IF
    ah = 2.0*psc
    IF (tc .GT. 0.0) THEN
      min1 = 0.0
    ELSE
      min1 = tc
    END IF
    bh = 0.244 - 0.0049*min1
!
    bh = 1/bh
    pwx1 = vcn/ah
    pwr1 = pwx1**bh
    dc_i = 0.01*pwr1
    IF (dc_i .LT. 4.0e-6) THEN
      x4 = 4.0e-6
    ELSE
      x4 = dc_i
    END IF
    IF (x4 .GT. 5.e-4) THEN
      dc_i = 5.e-4
    ELSE
      dc_i = x4
    END IF
!rain===============Follow Liu 2006====================
    IF (qr .GT. 1.e-9 .AND. nl .GT. 1.0) THEN
      pwx1 = mapl_pi*rho_r*nl/rho_a/qr
      pwr1 = pwx1**(1./3.)
      IF (pwr1 .GT. 1.0e8) THEN
        lamr = 1.0e8
      ELSE
        pwx1 = mapl_pi*rho_r*nl/rho_a/qr
        lamr = pwx1**(1./3.)
      END IF
      IF (dc_r*lamr .GT. 10.0) THEN
        x5 = 10.0
      ELSE
        x5 = dc_r*lamr
      END IF
      IF (x5 .LT. 0.1) THEN
        aux = 0.1
      ELSE
        aux = x5
      END IF
!g cm-3
      l = 1.0e-3*qr*rho_a
!cm-3
      n = nl*1.e-6*rho_a
! relative dispersion from Yangang Liu et al 2008 Environ. Res. Lett. 3 045021 doi:10.1088/1748-9326/3/4/045021
!Corrected
      pwx1 = l/n
      pwr1 = pwx1**(-0.140)
      xs = 0.070*pwr1
      IF (xs .GT. 1.7) THEN
        x6 = 1.7
      ELSE
        x6 = xs
      END IF
      IF (x6 .LT. 1.0001) THEN
        xs = 1.0001
      ELSE
        xs = x6
      END IF
      xs = xs*xs*xs
! from Eq. 2 (gives e^2)
      result1 = SQRT(xs + 8.0)
      result2 = SQRT(xs)
      xs = (xs+result1*result2-4.0)/8.0
! Autoconvesion rate from Liu, Yangang, et al. Journal of the atmospheric sciences 63.3 (2006): 1103-1109.
      beta6 = (1.0+3.0*xs)*(1.0+4.0*xs)*(1.0+5.0*xs)/(1.0+xs)/(1.0+2.0*&
&       xs)
!xs =aux*aux*aux
!xs = max(min(1/xs, 20.0), 1.e-6)
!ratio of mean mass to critical mass
      result1 = SQRT(n)
      xs = 1.03e16*(l*l)/(n*result1)
      IF (20.0 .GT. xs) THEN
        x7 = xs
      ELSE
        x7 = 20.0
      END IF
      IF (x7 .LT. 1.0e-6) THEN
        xs = 1.0e-6
      ELSE
        xs = x7
      END IF
      IF (xs*xs .GT. 20.0) THEN
        min2 = 20.0
      ELSE
        min2 = xs*xs
      END IF
!Using miu =2.0
      prc = 1.1e10*beta6*l*l*l*(1.0-EXP(-min2))/n
!return to mixing ratio
      prc = prc*1.0e3/rho_a
!COAUTO is a tuning factor that accounts for the increase in rain by accretion
      fpr = prc/qr
! NUmber autoconversion rate is approximated according to Liu, Yangang, et al. Geophysical Research Letters 34.16 (2007).
! Assumes e =  0.33. Replaces previous formulatin by Barahona et al. 2014 GMD
!xs= 9.7e-17*N*sqrt(N)/L/L !Eq. 8c
!fnr=fpr*6.0/(aux*aux*aux+3.0*aux*aux+6.0*aux + 6.)
! from Eqs. 13a and 13b
      fnr = fpr/(1.0+1./xs)
!print *, '====f===',xs, fpr, fnr
    ELSE
      fpr = 0.0
      fnr = 0.0
    END IF
!graupel
    IF (.false.) THEN
      IF (qg .GT. 1.e-9 .AND. ng .GT. 1.0) THEN
        pwx1 = mapl_pi*rho_g*ng/rho_a/qg
        pwr1 = pwx1**(1./3.)
        IF (pwr1 .GT. 1.0e6) THEN
          lamg = 1.0e6
        ELSE
          pwx1 = mapl_pi*rho_g*ng/rho_a/qg
          lamg = pwx1**(1./3.)
        END IF
        aux = dc_g*lamg
!precipitated fraction
        fpg = EXP(-aux)*(aux*aux*aux+3.0*aux*aux+6.0*aux+6.)/6.0
        IF (fpg .GT. 1.0) THEN
          min3 = 1.0
        ELSE
          min3 = fpg
        END IF
        fpg = min3/dtl
        fng = EXP(-aux)/dtl
      ELSE
        fpg = 0.0
        fng = 0.0
      END IF
    ELSE IF (qg .GT. 1.e-9 .AND. ng .GT. 1.0) THEN
!use diffusion equation instead
      pwx1 = mapl_pi*rho_g*ng/rho_a/qg
      pwr1 = pwx1**(1./3.)
      IF (pwr1 .GT. 1.0e6) THEN
        lamg = 1.0e6
      ELSE
        pwx1 = mapl_pi*rho_g*ng/rho_a/qg
        lamg = pwx1**(1./3.)
      END IF
      aux = dc_g*lamg
!fpi=exp(-aux)*(aux*aux*aux+3.0*aux*aux+6.0*aux + 6.)/6.0  !precipitated fraction
!fpi=min(fpi, 1.0)
!fni=exp(-aux)
!Assume that ice crystals only grow by diffusion
      fng = ai*si/dc_g/dc_g
!Only sizes with D<Dc can grow to Dc
      fng = fng*(1.0-EXP(-aux))
      fpg = fng*(aux*aux*aux+3.0*aux*aux+6.0*aux+6.)/6.0
    ELSE
      fpg = 0.0
      fng = 0.0
    END IF
!ice
    IF (qi .GT. 1.e-9 .AND. ni_ .GT. 1.0) THEN
      pwx1 = mapl_pi*rho_i*ni_/rho_a/qi
      lami = pwx1**(1./3.)
      aux = dc_i*lami
!fpi=exp(-aux)*(aux*aux*aux+3.0*aux*aux+6.0*aux + 6.)/6.0  !precipitated fraction
!fpi=min(fpi, 1.0)/DTL
!fni=exp(-aux)/DTL
!Assume that ice crystals only grow by diffusion
      fni = ai*si/dc_i/dc_i
!Only sizes with D<Dc can grow to Dc
      fni = fni*(1.0-EXP(-aux))
      fpi = fni*(aux*aux*aux+3.0*aux*aux+6.0*aux+6.)/6.0
    ELSE
      fpi = 0.0
      fni = 0.0
    END IF
    IF (fng .GT. 1.0/dtl) THEN
      fng = 1.0/dtl
    ELSE
      fng = fng
    END IF
    IF (fpg .GT. 1.0/dtl) THEN
      fpg = 1.0/dtl
    ELSE
      fpg = fpg
    END IF
    IF (fni .GT. 1.0/dtl) THEN
      fni = 1.0/dtl
    ELSE
      fni = fni
    END IF
    IF (fpi .GT. 1.0/dtl) THEN
      fpi = 1.0/dtl
    ELSE
      fpi = fpi
    END IF
    IF (fnr .GT. 1.0/dtl) THEN
      fnr = 1.0/dtl
    ELSE
      fnr = fnr
    END IF
    IF (fpr .GT. 1.0/dtl) THEN
      fpr = 1.0/dtl
    ELSE
      fpr = fpr
    END IF
    qpt = fpr*qr*(1.0-fice_) + fpg*qg*fice_ + fpi*qi*fice_
    f_nl = fnr
    f_ni = fqg*fng + fqi*fni
    fpice_ = fqi*fpi + fqg*fpg
    IF (qc .GT. 1e-10) rate_q = qpt/qc
    IF (rate_q .GT. 1.0/dtl) THEN
      rate_q = 1.0/dtl
    ELSE
      rate_q = rate_q
    END IF
    IF (fpice_ .GT. 1.0/dtl) THEN
      fpice_ = 1.0/dtl
    ELSE
      fpice_ = fpice_
    END IF
  END SUBROUTINE QREMOVAL
!=================================================================
  FUNCTION ICE_FRACTION(temp) RESULT (ICEFRCT)
    IMPLICIT NONE
    REAL, INTENT(IN) :: temp
    REAL :: icefrct, t_ice_all, t_ice_max
    INTRINSIC MIN
    INTRINSIC MAX
    t_ice_all = 238.0
    t_ice_max = 273.0
    icefrct = 0.00
    IF (temp .LE. t_ice_all) icefrct = 1.000
    IF (temp .GT. t_ice_all .AND. temp .LE. t_ice_max) icefrct = 1.00 - &
&       (temp-t_ice_all)/(t_ice_max-t_ice_all)
    IF (icefrct .GT. 1.00) THEN
      icefrct = 1.00
    ELSE
      icefrct = icefrct
    END IF
    IF (icefrct .LT. 0.00) THEN
      icefrct = 0.00
    ELSE
      icefrct = icefrct
    END IF
  END FUNCTION ICE_FRACTION
!*************************************************************
!Approximation to the error function
!*************************************************************
  REAL*8 FUNCTION ERFAPP(x)
    IMPLICIT NONE
    REAL, INTENT(IN) :: x
    REAL :: a
    INTRINSIC EXP
    INTRINSIC SQRT
    DOUBLE PRECISION :: arg1
    a = x*x*(1.27324d0+0.147d0*x*x)/(1d0+0.147d0*x*x)
    arg1 = 1d0 - EXP(-a)
    erfapp = SQRT(arg1)
    IF (x .LT. 0.0) erfapp = -erfapp
  END FUNCTION ERFAPP
END MODULE RAS_DIFF
