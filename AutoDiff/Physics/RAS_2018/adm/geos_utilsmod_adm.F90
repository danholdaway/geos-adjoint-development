!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.13 (r6666) - 27 Nov 2017 17:09
!
!  $Id: GEOS_Utilities.F90,v 1.16 2007/10/04 20:38:23 dasilva Exp $
!BOP
! !MODULE: GEOS_Utils -- A Module to containing computational utilities
MODULE GEOS_UTILSMOD_DIFF
! !USES:
  USE MAPL_CONSTANTSMOD
  IMPLICIT NONE
  PRIVATE 
! !PUBLIC MEMBER FUNCTIONS:
  PUBLIC geos_qsatset
  PUBLIC geos_qsatlqu
  PUBLIC geos_qsatlqu_adm
  PUBLIC geos_qsatice
  PUBLIC geos_qsatice_adm
  PUBLIC geos_qsat
  PUBLIC geos_dqsat
  PUBLIC geos_dqsat_adm
  PUBLIC geos_trilu
  PUBLIC geos_trisolve
  REAL, PARAMETER :: esfac=mapl_h2omw/mapl_airmw
  REAL, PARAMETER :: max_mixing_ratio=1.
  REAL, PARAMETER :: zeroc=mapl_tice
  REAL, PARAMETER :: tmintbl=150.0
  REAL, PARAMETER :: tmaxtbl=333.0
  INTEGER, PARAMETER :: degsubs=100
  REAL, PARAMETER :: erfac=degsubs/esfac
  REAL, PARAMETER :: delta_t=1.0/degsubs
  INTEGER, PARAMETER :: tablesize=NINT(tmaxtbl-tmintbl)*degsubs+1
  REAL, PARAMETER :: tmix=-20.
  LOGICAL, SAVE :: utbl=.true.
  INTEGER, SAVE :: type=1
  LOGICAL, SAVE :: first=.true.
  REAL, SAVE :: estfrz
  REAL, SAVE :: estlqu
  REAL, SAVE :: estble(tablesize)
  REAL, SAVE :: estblw(tablesize)
  REAL, SAVE :: estblx(tablesize)
  REAL, PARAMETER :: tminstr=-95.
  REAL, PARAMETER :: tstarr1=-75.
  REAL, PARAMETER :: tstarr2=-65.
  REAL, PARAMETER :: tstarr3=-50.
  REAL, PARAMETER :: tstarr4=-40.
  REAL, PARAMETER :: tmaxstr=60.
  REAL*8, PARAMETER :: b6=6.136820929e-11*100.0
  REAL*8, PARAMETER :: b5=2.034080948e-8*100.0
  REAL*8, PARAMETER :: b4=3.031240396e-6*100.0
  REAL*8, PARAMETER :: b3=2.650648471e-4*100.0
  REAL*8, PARAMETER :: b2=1.428945805e-2*100.0
  REAL*8, PARAMETER :: b1=4.436518521e-1*100.0
  REAL*8, PARAMETER :: b0=6.107799961e+0*100.0
  REAL*8, PARAMETER :: bi6=1.838826904e-10*100.0
  REAL*8, PARAMETER :: bi5=4.838803174e-8*100.0
  REAL*8, PARAMETER :: bi4=5.824720280e-6*100.0
  REAL*8, PARAMETER :: bi3=4.176223716e-4*100.0
  REAL*8, PARAMETER :: bi2=1.886013408e-2*100.0
  REAL*8, PARAMETER :: bi1=5.034698970e-1*100.0
  REAL*8, PARAMETER :: bi0=6.109177956e+0*100.0
  REAL*8, PARAMETER :: s16=0.516000335e-11*100.0
  REAL*8, PARAMETER :: s15=0.276961083e-8*100.0
  REAL*8, PARAMETER :: s14=0.623439266e-6*100.0
  REAL*8, PARAMETER :: s13=0.754129933e-4*100.0
  REAL*8, PARAMETER :: s12=0.517609116e-2*100.0
  REAL*8, PARAMETER :: s11=0.191372282e+0*100.0
  REAL*8, PARAMETER :: s10=0.298152339e+1*100.0
  REAL*8, PARAMETER :: s26=0.314296723e-10*100.0
  REAL*8, PARAMETER :: s25=0.132243858e-7*100.0
  REAL*8, PARAMETER :: s24=0.236279781e-5*100.0
  REAL*8, PARAMETER :: s23=0.230325039e-3*100.0
  REAL*8, PARAMETER :: s22=0.129690326e-1*100.0
  REAL*8, PARAMETER :: s21=0.401390832e+0*100.0
  REAL*8, PARAMETER :: s20=0.535098336e+1*100.0
  REAL*8, PARAMETER :: di(0:3)=(/57518.5606e08, 2.01889049, 3.56654, &
&   20.947031/)
  REAL*8, PARAMETER :: ci(0:3)=(/9.550426, -5723.265, 3.53068, -&
&   .00728332/)
  REAL*8, PARAMETER :: dl(6)=(/-7.902980, 5.02808, -1.3816, 11.344, &
&   8.1328, -3.49149/)
! log10(1013.246)
  REAL*8, PARAMETER :: logps=3.005714898
  REAL*8, PARAMETER :: ts=373.16
  REAL*8, PARAMETER :: cl(0:9)=(/54.842763, -6763.22, -4.21000, .000367&
&   , .0415, 218.8, 53.878000, -1331.22, -9.44523, .014025/)
  REAL, SAVE :: tminlqu=zeroc-40.0
  REAL, SAVE :: tminice=zeroc+tminstr
  INTERFACE GEOS_QSATICE
      MODULE PROCEDURE QSATICE0
      MODULE PROCEDURE QSATICE1
      MODULE PROCEDURE QSATICE2
      MODULE PROCEDURE QSATICE3
  END INTERFACE

  INTERFACE GEOS_QSATICE_ADM
      MODULE PROCEDURE QSATICE0_ADM
  END INTERFACE

  INTERFACE GEOS_QSATLQU
      MODULE PROCEDURE QSATLQU0
      MODULE PROCEDURE QSATLQU1
      MODULE PROCEDURE QSATLQU2
      MODULE PROCEDURE QSATLQU3
  END INTERFACE

  INTERFACE GEOS_QSATLQU_ADM
      MODULE PROCEDURE QSATLQU0_ADM
  END INTERFACE

  INTERFACE GEOS_DQSAT
      MODULE PROCEDURE DQSAT0
      MODULE PROCEDURE DQSAT1
      MODULE PROCEDURE DQSAT2
      MODULE PROCEDURE DQSAT3
  END INTERFACE

  INTERFACE GEOS_DQSAT_ADM
      MODULE PROCEDURE DQSAT0_ADM
  END INTERFACE

  INTERFACE GEOS_QSAT
      MODULE PROCEDURE QSAT0
      MODULE PROCEDURE QSAT1
      MODULE PROCEDURE QSAT2
      MODULE PROCEDURE QSAT3
  END INTERFACE

  INTERFACE GEOS_TRILU
      MODULE PROCEDURE GEOS_TRILU1
      MODULE PROCEDURE GEOS_TRILU2
      MODULE PROCEDURE GEOS_TRILU3
  END INTERFACE

  INTERFACE GEOS_TRISOLVE
      MODULE PROCEDURE GEOS_TRISOLVE1
      MODULE PROCEDURE GEOS_TRISOLVE2
      MODULE PROCEDURE GEOS_TRISOLVE3
  END INTERFACE


CONTAINS
!BOPI
! !IROUTINE: GEOS_QsatLqu Computes saturation specific humidity over
!            liquid water.
! !IROUTINE: GEOS_QsatIce Computes saturation specific humidity over
!            frozen water.
! !INTERFACE:
!    function GEOS_QsatLqu(TL,PL,DQ) result(QS)
!    function GEOS_QsatIce(TL,PL,DQ) result(QS)
!
! Overloads:
!
!      real,                               intent(IN)               :: TL
!      logical,                  optional, intent(IN)               :: PL
!      real,                     optional, intent(OUT)              :: DQ
!      real                                                         :: QS
!
!      real,                               intent(IN)               :: TL(:)
!      logical,                  optional, intent(IN)               :: PL(:)
!      real,                     optional, intent(OUT)              :: DQ(:)
!      real, dimension(size(TL,1))                                  :: QS
!
!      real,                               intent(IN)               :: TL(:,:)
!      logical,                  optional, intent(IN)               :: PL(:,:)
!      real,                     optional, intent(OUT)              :: DQ(:,:)
!      real, dimension(size(TL,1),size(TL,2))                       :: QS
!
!      real,                               intent(IN)               :: TL(:,:,:)
!      logical,                  optional, intent(IN)               :: PL(:,:,:)
!      real,                     optional, intent(OUT)              :: DQ(:,:,:)
!      real, dimension(size(TL,1),size(TL,2),size(TL,3))            :: QS
!
!
! !DESCRIPTION:  Uses various formulations of the saturation
!                vapor pressure to compute the saturation specific
!    humidity and, optionally, its derivative with respect to temperature
!    for temperature TL and pressure PL. If PL is not present
!    it returns the saturation vapor pressure and, optionally, its derivative.
!
!    All pressures are in Pascals and all temperatures in Kelvins.
!
!    The choice of saturation vapor pressure formulation is controlled by  GEOS_QsatSet.
!    Three choices are currently supported: The CAM formulation,
!    Murphy and Koop (2005, QJRMS), and the Staar formulation from NSIPP-1.
!    The default is Starr. All three are valid up to 333K. Above the
!    freezing point, GEOS_QsatIce returns values at the freezing point.
!    Murphy and Koop is valid down to 150K, for both liquid and ice.
!    The other two are valid down to 178K for ice and 233K for super-cooled liquid.
!
!    Another choice is whether to use the exact formulation
!    or a table look-up. This can also be controlled with GEOS_QsatSet.
!    The default is to do a table look-up. The tables are generated
!    at 0.1C intervals, controlled by parameter DEGSUBS=10.
!
!
!EOPI
  FUNCTION QSATLQU0(tl, pl, dq) RESULT (QS)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl
    REAL, OPTIONAL, INTENT(IN) :: pl
    REAL, OPTIONAL, INTENT(OUT) :: dq
    REAL :: qs
    REAL :: ti, w
    REAL :: dd
    REAL :: tt
    REAL :: ddq
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC LOG10
    INTRINSIC ALOG
    INTRINSIC TANH
    INTRINSIC EXP
! not table
    IF (utbl) THEN
      IF (first) THEN
        first = .false.
        CALL ESINIT()
      END IF
      IF (tl .LE. tminlqu) THEN
        qs = estlqu
        IF (PRESENT(dq)) ddq = 0.0
      ELSE IF (tl .GE. tmaxtbl) THEN
        qs = estblw(tablesize)
        IF (PRESENT(dq)) ddq = 0.0
      ELSE
        tt = (tl-tmintbl)*degsubs + 1
        it = INT(tt)
        ddq = estblw(it+1) - estblw(it)
        qs = (tt-it)*ddq + estblw(it)
      END IF
      IF (PRESENT(pl)) THEN
        IF (pl .GT. qs) THEN
          dd = esfac/(pl-(1.0-esfac)*qs)
          qs = qs*dd
          IF (PRESENT(dq)) dq = ddq*erfac*pl*dd*dd
        ELSE
          qs = max_mixing_ratio
          IF (PRESENT(dq)) dq = 0.0
        END IF
      ELSE IF (PRESENT(dq)) THEN
        dq = ddq
      END IF
    ELSE
! Exact Formulation
      IF (tl .LT. tminlqu) THEN
        ti = tminlqu
      ELSE IF (tl .GT. tmaxtbl) THEN
        ti = tmaxtbl
      ELSE
        ti = tl
      END IF
      IF (type .EQ. 1) THEN
!  Starr polynomial fit
        tt = ti - zeroc
        qs = tt*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+b1) + b0
      ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
        tt = ts/ti
        qs = 10.0**(dl(1)*(tt-1.0)+dl(2)*LOG10(tt)+dl(3)*(10.0**(dl(4)*(&
&         1.0-1.0/tt))-1.0)/10000000.0+dl(5)*(10.0**(dl(6)*(tt-1.0))-1.0&
&         )/1000.0+logps+2.0)
      ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
        qs = EXP(cl(0) + cl(1)/ti + cl(2)*ALOG(ti) + cl(3)*ti + TANH(cl(&
&         4)*(ti-cl(5)))*(cl(6)+cl(7)/ti+cl(8)*ALOG(ti)+cl(9)*ti))
      END IF
      IF (PRESENT(dq)) THEN
        IF (tl .LT. tminlqu) THEN
          ddq = 0.0
        ELSE IF (tl .GT. tmaxtbl) THEN
          ddq = 0.0
        ELSE IF (pl .GT. qs) THEN
          dd = qs
          ti = tl + delta_t
          IF (type .EQ. 1) THEN
!  Starr polynomial fit
            tt = ti - zeroc
            qs = tt*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+b1) + b0
          ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
            tt = ts/ti
            qs = 10.0**(dl(1)*(tt-1.0)+dl(2)*LOG10(tt)+dl(3)*(10.0**(dl(&
&             4)*(1.0-1.0/tt))-1.0)/10000000.0+dl(5)*(10.0**(dl(6)*(tt-&
&             1.0))-1.0)/1000.0+logps+2.0)
          ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
            qs = EXP(cl(0) + cl(1)/ti + cl(2)*ALOG(ti) + cl(3)*ti + TANH&
&             (cl(4)*(ti-cl(5)))*(cl(6)+cl(7)/ti+cl(8)*ALOG(ti)+cl(9)*ti&
&             ))
          END IF
          ddq = qs - dd
          qs = dd
        END IF
      END IF
      IF (PRESENT(pl)) THEN
        IF (pl .GT. qs) THEN
          dd = esfac/(pl-(1.0-esfac)*qs)
          qs = qs*dd
          IF (PRESENT(dq)) dq = ddq*erfac*pl*dd*dd
        ELSE
          qs = max_mixing_ratio
          IF (PRESENT(dq)) dq = 0.0
        END IF
      ELSE IF (PRESENT(dq)) THEN
        dq = ddq*(1.0/delta_t)
      END IF
    END IF
    RETURN
  END FUNCTION QSATLQU0
  FUNCTION QSATLQU1(tl, pl, dq) RESULT (QS)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:)
    REAL, OPTIONAL, INTENT(IN) :: pl(:)
    REAL, OPTIONAL, INTENT(OUT) :: dq(:)
    REAL :: qs(SIZE(tl, 1))
    INTEGER :: i
    REAL :: ti, w
    REAL :: tt
    REAL :: ddq
    REAL :: dd
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC LOG10
    INTRINSIC ALOG
    INTRINSIC TANH
    INTRINSIC EXP
    INTRINSIC SIZE
    DO i=1,SIZE(tl, 1)
! not table
      IF (utbl) THEN
        IF (first) THEN
          first = .false.
          CALL ESINIT()
        END IF
        IF (tl(i) .LE. tminlqu) THEN
          qs(i) = estlqu
          IF (PRESENT(dq)) ddq = 0.0
        ELSE IF (tl(i) .GE. tmaxtbl) THEN
          qs(i) = estblw(tablesize)
          IF (PRESENT(dq)) ddq = 0.0
        ELSE
          tt = (tl(i)-tmintbl)*degsubs + 1
          it = INT(tt)
          ddq = estblw(it+1) - estblw(it)
          qs(i) = (tt-it)*ddq + estblw(it)
        END IF
        IF (PRESENT(pl)) THEN
          IF (pl(i) .GT. qs(i)) THEN
            dd = esfac/(pl(i)-(1.0-esfac)*qs(i))
            qs(i) = qs(i)*dd
            IF (PRESENT(dq)) dq(i) = ddq*erfac*pl(i)*dd*dd
          ELSE
            qs(i) = max_mixing_ratio
            IF (PRESENT(dq)) dq(i) = 0.0
          END IF
        ELSE IF (PRESENT(dq)) THEN
          dq(i) = ddq
        END IF
      ELSE
! Exact Formulation
        IF (tl(i) .LT. tminlqu) THEN
          ti = tminlqu
        ELSE IF (tl(i) .GT. tmaxtbl) THEN
          ti = tmaxtbl
        ELSE
          ti = tl(i)
        END IF
        IF (type .EQ. 1) THEN
!  Starr polynomial fit
          tt = ti - zeroc
          qs(i) = tt*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+b1) + b0
        ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
          tt = ts/ti
          qs(i) = 10.0**(dl(1)*(tt-1.0)+dl(2)*LOG10(tt)+dl(3)*(10.0**(dl&
&           (4)*(1.0-1.0/tt))-1.0)/10000000.0+dl(5)*(10.0**(dl(6)*(tt-&
&           1.0))-1.0)/1000.0+logps+2.0)
        ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
          qs(i) = EXP(cl(0) + cl(1)/ti + cl(2)*ALOG(ti) + cl(3)*ti + &
&           TANH(cl(4)*(ti-cl(5)))*(cl(6)+cl(7)/ti+cl(8)*ALOG(ti)+cl(9)*&
&           ti))
        END IF
        IF (PRESENT(dq)) THEN
          IF (tl(i) .LT. tminlqu) THEN
            ddq = 0.0
          ELSE IF (tl(i) .GT. tmaxtbl) THEN
            ddq = 0.0
          ELSE IF (pl(i) .GT. qs(i)) THEN
            dd = qs(i)
            ti = tl(i) + delta_t
            IF (type .EQ. 1) THEN
!  Starr polynomial fit
              tt = ti - zeroc
              qs(i) = tt*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+b1) + b0
            ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
              tt = ts/ti
              qs(i) = 10.0**(dl(1)*(tt-1.0)+dl(2)*LOG10(tt)+dl(3)*(10.0&
&               **(dl(4)*(1.0-1.0/tt))-1.0)/10000000.0+dl(5)*(10.0**(dl(&
&               6)*(tt-1.0))-1.0)/1000.0+logps+2.0)
            ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
              qs(i) = EXP(cl(0) + cl(1)/ti + cl(2)*ALOG(ti) + cl(3)*ti +&
&               TANH(cl(4)*(ti-cl(5)))*(cl(6)+cl(7)/ti+cl(8)*ALOG(ti)+cl&
&               (9)*ti))
            END IF
            ddq = qs(i) - dd
            qs(i) = dd
          END IF
        END IF
        IF (PRESENT(pl)) THEN
          IF (pl(i) .GT. qs(i)) THEN
            dd = esfac/(pl(i)-(1.0-esfac)*qs(i))
            qs(i) = qs(i)*dd
            IF (PRESENT(dq)) dq(i) = ddq*erfac*pl(i)*dd*dd
          ELSE
            qs(i) = max_mixing_ratio
            IF (PRESENT(dq)) dq(i) = 0.0
          END IF
        ELSE IF (PRESENT(dq)) THEN
          dq(i) = ddq*(1.0/delta_t)
        END IF
      END IF
    END DO
  END FUNCTION QSATLQU1
  FUNCTION QSATLQU2(tl, pl, dq) RESULT (QS)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:, :)
    REAL, OPTIONAL, INTENT(IN) :: pl(:, :)
    REAL, OPTIONAL, INTENT(OUT) :: dq(:, :)
    REAL :: qs(SIZE(tl, 1), SIZE(tl, 2))
    INTEGER :: i, j
    REAL :: ti, w
    REAL :: tt
    REAL :: ddq
    REAL :: dd
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC LOG10
    INTRINSIC ALOG
    INTRINSIC TANH
    INTRINSIC EXP
    INTRINSIC SIZE
    DO j=1,SIZE(tl, 2)
      DO i=1,SIZE(tl, 1)
! not table
        IF (utbl) THEN
          IF (first) THEN
            first = .false.
            CALL ESINIT()
          END IF
          IF (tl(i, j) .LE. tminlqu) THEN
            qs(i, j) = estlqu
            IF (PRESENT(dq)) ddq = 0.0
          ELSE IF (tl(i, j) .GE. tmaxtbl) THEN
            qs(i, j) = estblw(tablesize)
            IF (PRESENT(dq)) ddq = 0.0
          ELSE
            tt = (tl(i, j)-tmintbl)*degsubs + 1
            it = INT(tt)
            ddq = estblw(it+1) - estblw(it)
            qs(i, j) = (tt-it)*ddq + estblw(it)
          END IF
          IF (PRESENT(pl)) THEN
            IF (pl(i, j) .GT. qs(i, j)) THEN
              dd = esfac/(pl(i, j)-(1.0-esfac)*qs(i, j))
              qs(i, j) = qs(i, j)*dd
              IF (PRESENT(dq)) dq(i, j) = ddq*erfac*pl(i, j)*dd*dd
            ELSE
              qs(i, j) = max_mixing_ratio
              IF (PRESENT(dq)) dq(i, j) = 0.0
            END IF
          ELSE IF (PRESENT(dq)) THEN
            dq(i, j) = ddq
          END IF
        ELSE
! Exact Formulation
          IF (tl(i, j) .LT. tminlqu) THEN
            ti = tminlqu
          ELSE IF (tl(i, j) .GT. tmaxtbl) THEN
            ti = tmaxtbl
          ELSE
            ti = tl(i, j)
          END IF
          IF (type .EQ. 1) THEN
!  Starr polynomial fit
            tt = ti - zeroc
            qs(i, j) = tt*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+b1) + &
&             b0
          ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
            tt = ts/ti
            qs(i, j) = 10.0**(dl(1)*(tt-1.0)+dl(2)*LOG10(tt)+dl(3)*(10.0&
&             **(dl(4)*(1.0-1.0/tt))-1.0)/10000000.0+dl(5)*(10.0**(dl(6)&
&             *(tt-1.0))-1.0)/1000.0+logps+2.0)
          ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
            qs(i, j) = EXP(cl(0) + cl(1)/ti + cl(2)*ALOG(ti) + cl(3)*ti &
&             + TANH(cl(4)*(ti-cl(5)))*(cl(6)+cl(7)/ti+cl(8)*ALOG(ti)+cl&
&             (9)*ti))
          END IF
          IF (PRESENT(dq)) THEN
            IF (tl(i, j) .LT. tminlqu) THEN
              ddq = 0.0
            ELSE IF (tl(i, j) .GT. tmaxtbl) THEN
              ddq = 0.0
            ELSE IF (pl(i, j) .GT. qs(i, j)) THEN
              dd = qs(i, j)
              ti = tl(i, j) + delta_t
              IF (type .EQ. 1) THEN
!  Starr polynomial fit
                tt = ti - zeroc
                qs(i, j) = tt*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+b1)&
&                 + b0
              ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
                tt = ts/ti
                qs(i, j) = 10.0**(dl(1)*(tt-1.0)+dl(2)*LOG10(tt)+dl(3)*(&
&                 10.0**(dl(4)*(1.0-1.0/tt))-1.0)/10000000.0+dl(5)*(10.0&
&                 **(dl(6)*(tt-1.0))-1.0)/1000.0+logps+2.0)
              ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
                qs(i, j) = EXP(cl(0) + cl(1)/ti + cl(2)*ALOG(ti) + cl(3)&
&                 *ti + TANH(cl(4)*(ti-cl(5)))*(cl(6)+cl(7)/ti+cl(8)*&
&                 ALOG(ti)+cl(9)*ti))
              END IF
              ddq = qs(i, j) - dd
              qs(i, j) = dd
            END IF
          END IF
          IF (PRESENT(pl)) THEN
            IF (pl(i, j) .GT. qs(i, j)) THEN
              dd = esfac/(pl(i, j)-(1.0-esfac)*qs(i, j))
              qs(i, j) = qs(i, j)*dd
              IF (PRESENT(dq)) dq(i, j) = ddq*erfac*pl(i, j)*dd*dd
            ELSE
              qs(i, j) = max_mixing_ratio
              IF (PRESENT(dq)) dq(i, j) = 0.0
            END IF
          ELSE IF (PRESENT(dq)) THEN
            dq(i, j) = ddq*(1.0/delta_t)
          END IF
        END IF
      END DO
    END DO
  END FUNCTION QSATLQU2
  FUNCTION QSATLQU3(tl, pl, dq) RESULT (QS)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:, :, :)
    REAL, OPTIONAL, INTENT(IN) :: pl(:, :, :)
    REAL, OPTIONAL, INTENT(OUT) :: dq(:, :, :)
    REAL :: qs(SIZE(tl, 1), SIZE(tl, 2), SIZE(tl, 3))
    INTEGER :: i, j, k
    REAL :: ti, w
    REAL :: tt
    REAL :: ddq
    REAL :: dd
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC LOG10
    INTRINSIC ALOG
    INTRINSIC TANH
    INTRINSIC EXP
    INTRINSIC SIZE
    DO k=1,SIZE(tl, 3)
      DO j=1,SIZE(tl, 2)
        DO i=1,SIZE(tl, 1)
! not table
          IF (utbl) THEN
            IF (first) THEN
              first = .false.
              CALL ESINIT()
            END IF
            IF (tl(i, j, k) .LE. tminlqu) THEN
              qs(i, j, k) = estlqu
              IF (PRESENT(dq)) ddq = 0.0
            ELSE IF (tl(i, j, k) .GE. tmaxtbl) THEN
              qs(i, j, k) = estblw(tablesize)
              IF (PRESENT(dq)) ddq = 0.0
            ELSE
              tt = (tl(i, j, k)-tmintbl)*degsubs + 1
              it = INT(tt)
              ddq = estblw(it+1) - estblw(it)
              qs(i, j, k) = (tt-it)*ddq + estblw(it)
            END IF
            IF (PRESENT(pl)) THEN
              IF (pl(i, j, k) .GT. qs(i, j, k)) THEN
                dd = esfac/(pl(i, j, k)-(1.0-esfac)*qs(i, j, k))
                qs(i, j, k) = qs(i, j, k)*dd
                IF (PRESENT(dq)) dq(i, j, k) = ddq*erfac*pl(i, j, k)*dd*&
&                   dd
              ELSE
                qs(i, j, k) = max_mixing_ratio
                IF (PRESENT(dq)) dq(i, j, k) = 0.0
              END IF
            ELSE IF (PRESENT(dq)) THEN
              dq(i, j, k) = ddq
            END IF
          ELSE
! Exact Formulation
            IF (tl(i, j, k) .LT. tminlqu) THEN
              ti = tminlqu
            ELSE IF (tl(i, j, k) .GT. tmaxtbl) THEN
              ti = tmaxtbl
            ELSE
              ti = tl(i, j, k)
            END IF
            IF (type .EQ. 1) THEN
!  Starr polynomial fit
              tt = ti - zeroc
              qs(i, j, k) = tt*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+b1&
&               ) + b0
            ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
              tt = ts/ti
              qs(i, j, k) = 10.0**(dl(1)*(tt-1.0)+dl(2)*LOG10(tt)+dl(3)*&
&               (10.0**(dl(4)*(1.0-1.0/tt))-1.0)/10000000.0+dl(5)*(10.0&
&               **(dl(6)*(tt-1.0))-1.0)/1000.0+logps+2.0)
            ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
              qs(i, j, k) = EXP(cl(0) + cl(1)/ti + cl(2)*ALOG(ti) + cl(3&
&               )*ti + TANH(cl(4)*(ti-cl(5)))*(cl(6)+cl(7)/ti+cl(8)*ALOG&
&               (ti)+cl(9)*ti))
            END IF
            IF (PRESENT(dq)) THEN
              IF (tl(i, j, k) .LT. tminlqu) THEN
                ddq = 0.0
              ELSE IF (tl(i, j, k) .GT. tmaxtbl) THEN
                ddq = 0.0
              ELSE IF (pl(i, j, k) .GT. qs(i, j, k)) THEN
                dd = qs(i, j, k)
                ti = tl(i, j, k) + delta_t
                IF (type .EQ. 1) THEN
!  Starr polynomial fit
                  tt = ti - zeroc
                  qs(i, j, k) = tt*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2&
&                   )+b1) + b0
                ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
                  tt = ts/ti
                  qs(i, j, k) = 10.0**(dl(1)*(tt-1.0)+dl(2)*LOG10(tt)+dl&
&                   (3)*(10.0**(dl(4)*(1.0-1.0/tt))-1.0)/10000000.0+dl(5&
&                   )*(10.0**(dl(6)*(tt-1.0))-1.0)/1000.0+logps+2.0)
                ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
                  qs(i, j, k) = EXP(cl(0) + cl(1)/ti + cl(2)*ALOG(ti) + &
&                   cl(3)*ti + TANH(cl(4)*(ti-cl(5)))*(cl(6)+cl(7)/ti+cl&
&                   (8)*ALOG(ti)+cl(9)*ti))
                END IF
                ddq = qs(i, j, k) - dd
                qs(i, j, k) = dd
              END IF
            END IF
            IF (PRESENT(pl)) THEN
              IF (pl(i, j, k) .GT. qs(i, j, k)) THEN
                dd = esfac/(pl(i, j, k)-(1.0-esfac)*qs(i, j, k))
                qs(i, j, k) = qs(i, j, k)*dd
                IF (PRESENT(dq)) dq(i, j, k) = ddq*erfac*pl(i, j, k)*dd*&
&                   dd
              ELSE
                qs(i, j, k) = max_mixing_ratio
                IF (PRESENT(dq)) dq(i, j, k) = 0.0
              END IF
            ELSE IF (PRESENT(dq)) THEN
              dq(i, j, k) = ddq*(1.0/delta_t)
            END IF
          END IF
        END DO
      END DO
    END DO
  END FUNCTION QSATLQU3
  FUNCTION QSATICE0(tl, pl, dq) RESULT (QS)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl
    REAL, OPTIONAL, INTENT(IN) :: pl
    REAL, OPTIONAL, INTENT(OUT) :: dq
    REAL :: qs
    REAL :: ti, w
    REAL :: dd
    REAL :: tt
    REAL :: ddq
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC LOG
    INTRINSIC EXP
    INTRINSIC ALOG
    IF (utbl) THEN
      IF (first) THEN
        first = .false.
        CALL ESINIT()
      END IF
      IF (tl .LE. tmintbl) THEN
        qs = estble(1)
        IF (PRESENT(dq)) ddq = 0.0
      ELSE IF (tl .GE. zeroc) THEN
        qs = estfrz
        IF (PRESENT(dq)) ddq = 0.0
      ELSE
        tt = (tl-tmintbl)*degsubs + 1
        it = INT(tt)
        ddq = estble(it+1) - estble(it)
        qs = (tt-it)*ddq + estble(it)
      END IF
      IF (PRESENT(pl)) THEN
        IF (pl .GT. qs) THEN
          dd = esfac/(pl-(1.0-esfac)*qs)
          qs = qs*dd
          IF (PRESENT(dq)) dq = ddq*erfac*pl*dd*dd
        ELSE
          qs = max_mixing_ratio
          IF (PRESENT(dq)) dq = 0.0
        END IF
      ELSE IF (PRESENT(dq)) THEN
        dq = ddq
      END IF
    ELSE
! Exact Formulation
      IF (tl .LT. tminice) THEN
        ti = tminice
      ELSE IF (tl .GT. zeroc) THEN
        ti = zeroc
      ELSE
        ti = tl
      END IF
      IF (type .EQ. 1) THEN
! Use Starr formulation
        tt = ti - zeroc
        IF (tt .LT. tstarr1) THEN
          qs = tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+s11) + s10
        ELSE IF (tt .GE. tstarr1 .AND. tt .LT. tstarr2) THEN
          w = (tstarr2-tt)/(tstarr2-tstarr1)
          qs = w*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+s11)+&
&           s10) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22&
&           )+s21)+s20)
        ELSE IF (tt .GE. tstarr2 .AND. tt .LT. tstarr3) THEN
          qs = tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+s21) + s20
        ELSE IF (tt .GE. tstarr3 .AND. tt .LT. tstarr4) THEN
          w = (tstarr4-tt)/(tstarr4-tstarr3)
          qs = w*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+s21)+&
&           s20) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2&
&           )+bi1)+bi0)
        ELSE
          qs = tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2)+bi1) + bi0
        END IF
      ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
        tt = zeroc/ti
        qs = di(0)*EXP(-(di(1)/tt+di(2)*LOG(tt)+di(3)*tt))
      ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
        qs = EXP(ci(0) + ci(1)/ti + ci(2)*ALOG(ti) + ci(3)*ti)
      END IF
      IF (PRESENT(dq)) THEN
        IF (tl .LT. tminice) THEN
          ddq = 0.0
        ELSE IF (tl .GT. zeroc) THEN
          ddq = 0.0
        ELSE IF (pl .GT. qs) THEN
          dd = qs
          ti = tl + delta_t
          IF (type .EQ. 1) THEN
! Use Starr formulation
            tt = ti - zeroc
            IF (tt .LT. tstarr1) THEN
              qs = tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+s11) +&
&               s10
            ELSE IF (tt .GE. tstarr1 .AND. tt .LT. tstarr2) THEN
              w = (tstarr2-tt)/(tstarr2-tstarr1)
              qs = w*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+s11&
&               )+s10) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+&
&               s23)+s22)+s21)+s20)
            ELSE IF (tt .GE. tstarr2 .AND. tt .LT. tstarr3) THEN
              qs = tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+s21) +&
&               s20
            ELSE IF (tt .GE. tstarr3 .AND. tt .LT. tstarr4) THEN
              w = (tstarr4-tt)/(tstarr4-tstarr3)
              qs = w*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+s21&
&               )+s20) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+&
&               bi3)+bi2)+bi1)+bi0)
            ELSE
              qs = tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2)+bi1) +&
&               bi0
            END IF
          ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
            tt = zeroc/ti
            qs = di(0)*EXP(-(di(1)/tt+di(2)*LOG(tt)+di(3)*tt))
          ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
            qs = EXP(ci(0) + ci(1)/ti + ci(2)*ALOG(ti) + ci(3)*ti)
          END IF
          ddq = qs - dd
          qs = dd
        END IF
      END IF
      IF (PRESENT(pl)) THEN
        IF (pl .GT. qs) THEN
          dd = esfac/(pl-(1.0-esfac)*qs)
          qs = qs*dd
          IF (PRESENT(dq)) dq = ddq*erfac*pl*dd*dd
        ELSE
          qs = max_mixing_ratio
          IF (PRESENT(dq)) dq = 0.0
        END IF
      ELSE IF (PRESENT(dq)) THEN
        dq = ddq*(1.0/delta_t)
      END IF
    END IF
    RETURN
  END FUNCTION QSATICE0
  FUNCTION QSATICE1(tl, pl, dq) RESULT (QS)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:)
    REAL, OPTIONAL, INTENT(IN) :: pl(:)
    REAL, OPTIONAL, INTENT(OUT) :: dq(:)
    REAL :: qs(SIZE(tl, 1))
    INTEGER :: i
    REAL :: ti, w
    REAL :: tt
    REAL :: ddq
    REAL :: dd
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC LOG
    INTRINSIC EXP
    INTRINSIC ALOG
    INTRINSIC SIZE
    DO i=1,SIZE(tl, 1)
      IF (utbl) THEN
        IF (first) THEN
          first = .false.
          CALL ESINIT()
        END IF
        IF (tl(i) .LE. tmintbl) THEN
          qs(i) = estble(1)
          IF (PRESENT(dq)) ddq = 0.0
        ELSE IF (tl(i) .GE. zeroc) THEN
          qs(i) = estfrz
          IF (PRESENT(dq)) ddq = 0.0
        ELSE
          tt = (tl(i)-tmintbl)*degsubs + 1
          it = INT(tt)
          ddq = estble(it+1) - estble(it)
          qs(i) = (tt-it)*ddq + estble(it)
        END IF
        IF (PRESENT(pl)) THEN
          IF (pl(i) .GT. qs(i)) THEN
            dd = esfac/(pl(i)-(1.0-esfac)*qs(i))
            qs(i) = qs(i)*dd
            IF (PRESENT(dq)) dq(i) = ddq*erfac*pl(i)*dd*dd
          ELSE
            qs(i) = max_mixing_ratio
            IF (PRESENT(dq)) dq(i) = 0.0
          END IF
        ELSE IF (PRESENT(dq)) THEN
          dq(i) = ddq
        END IF
      ELSE
! Exact Formulation
        IF (tl(i) .LT. tminice) THEN
          ti = tminice
        ELSE IF (tl(i) .GT. zeroc) THEN
          ti = zeroc
        ELSE
          ti = tl(i)
        END IF
        IF (type .EQ. 1) THEN
! Use Starr formulation
          tt = ti - zeroc
          IF (tt .LT. tstarr1) THEN
            qs(i) = tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+s11) &
&             + s10
          ELSE IF (tt .GE. tstarr1 .AND. tt .LT. tstarr2) THEN
            w = (tstarr2-tt)/(tstarr2-tstarr1)
            qs(i) = w*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+&
&             s11)+s10) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+&
&             s23)+s22)+s21)+s20)
          ELSE IF (tt .GE. tstarr2 .AND. tt .LT. tstarr3) THEN
            qs(i) = tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+s21) &
&             + s20
          ELSE IF (tt .GE. tstarr3 .AND. tt .LT. tstarr4) THEN
            w = (tstarr4-tt)/(tstarr4-tstarr3)
            qs(i) = w*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+&
&             s21)+s20) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+&
&             bi3)+bi2)+bi1)+bi0)
          ELSE
            qs(i) = tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2)+bi1) &
&             + bi0
          END IF
        ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
          tt = zeroc/ti
          qs(i) = di(0)*EXP(-(di(1)/tt+di(2)*LOG(tt)+di(3)*tt))
        ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
          qs(i) = EXP(ci(0) + ci(1)/ti + ci(2)*ALOG(ti) + ci(3)*ti)
        END IF
        IF (PRESENT(dq)) THEN
          IF (tl(i) .LT. tminice) THEN
            ddq = 0.0
          ELSE IF (tl(i) .GT. zeroc) THEN
            ddq = 0.0
          ELSE IF (pl(i) .GT. qs(i)) THEN
            dd = qs(i)
            ti = tl(i) + delta_t
            IF (type .EQ. 1) THEN
! Use Starr formulation
              tt = ti - zeroc
              IF (tt .LT. tstarr1) THEN
                qs(i) = tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+&
&                 s11) + s10
              ELSE IF (tt .GE. tstarr1 .AND. tt .LT. tstarr2) THEN
                w = (tstarr2-tt)/(tstarr2-tstarr1)
                qs(i) = w*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12&
&                 )+s11)+s10) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+&
&                 s24)+s23)+s22)+s21)+s20)
              ELSE IF (tt .GE. tstarr2 .AND. tt .LT. tstarr3) THEN
                qs(i) = tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+&
&                 s21) + s20
              ELSE IF (tt .GE. tstarr3 .AND. tt .LT. tstarr4) THEN
                w = (tstarr4-tt)/(tstarr4-tstarr3)
                qs(i) = w*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22&
&                 )+s21)+s20) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+&
&                 bi4)+bi3)+bi2)+bi1)+bi0)
              ELSE
                qs(i) = tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2)+&
&                 bi1) + bi0
              END IF
            ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
              tt = zeroc/ti
              qs(i) = di(0)*EXP(-(di(1)/tt+di(2)*LOG(tt)+di(3)*tt))
            ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
              qs(i) = EXP(ci(0) + ci(1)/ti + ci(2)*ALOG(ti) + ci(3)*ti)
            END IF
            ddq = qs(i) - dd
            qs(i) = dd
          END IF
        END IF
        IF (PRESENT(pl)) THEN
          IF (pl(i) .GT. qs(i)) THEN
            dd = esfac/(pl(i)-(1.0-esfac)*qs(i))
            qs(i) = qs(i)*dd
            IF (PRESENT(dq)) dq(i) = ddq*erfac*pl(i)*dd*dd
          ELSE
            qs(i) = max_mixing_ratio
            IF (PRESENT(dq)) dq(i) = 0.0
          END IF
        ELSE IF (PRESENT(dq)) THEN
          dq(i) = ddq*(1.0/delta_t)
        END IF
      END IF
    END DO
  END FUNCTION QSATICE1
  FUNCTION QSATICE2(tl, pl, dq) RESULT (QS)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:, :)
    REAL, OPTIONAL, INTENT(IN) :: pl(:, :)
    REAL, OPTIONAL, INTENT(OUT) :: dq(:, :)
    REAL :: qs(SIZE(tl, 1), SIZE(tl, 2))
    INTEGER :: i, j
    REAL :: ti, w
    REAL :: tt
    REAL :: ddq
    REAL :: dd
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC LOG
    INTRINSIC EXP
    INTRINSIC ALOG
    INTRINSIC SIZE
    DO j=1,SIZE(tl, 2)
      DO i=1,SIZE(tl, 1)
        IF (utbl) THEN
          IF (first) THEN
            first = .false.
            CALL ESINIT()
          END IF
          IF (tl(i, j) .LE. tmintbl) THEN
            qs(i, j) = estble(1)
            IF (PRESENT(dq)) ddq = 0.0
          ELSE IF (tl(i, j) .GE. zeroc) THEN
            qs(i, j) = estfrz
            IF (PRESENT(dq)) ddq = 0.0
          ELSE
            tt = (tl(i, j)-tmintbl)*degsubs + 1
            it = INT(tt)
            ddq = estble(it+1) - estble(it)
            qs(i, j) = (tt-it)*ddq + estble(it)
          END IF
          IF (PRESENT(pl)) THEN
            IF (pl(i, j) .GT. qs(i, j)) THEN
              dd = esfac/(pl(i, j)-(1.0-esfac)*qs(i, j))
              qs(i, j) = qs(i, j)*dd
              IF (PRESENT(dq)) dq(i, j) = ddq*erfac*pl(i, j)*dd*dd
            ELSE
              qs(i, j) = max_mixing_ratio
              IF (PRESENT(dq)) dq(i, j) = 0.0
            END IF
          ELSE IF (PRESENT(dq)) THEN
            dq(i, j) = ddq
          END IF
        ELSE
! Exact Formulation
          IF (tl(i, j) .LT. tminice) THEN
            ti = tminice
          ELSE IF (tl(i, j) .GT. zeroc) THEN
            ti = zeroc
          ELSE
            ti = tl(i, j)
          END IF
          IF (type .EQ. 1) THEN
! Use Starr formulation
            tt = ti - zeroc
            IF (tt .LT. tstarr1) THEN
              qs(i, j) = tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+&
&               s11) + s10
            ELSE IF (tt .GE. tstarr1 .AND. tt .LT. tstarr2) THEN
              w = (tstarr2-tt)/(tstarr2-tstarr1)
              qs(i, j) = w*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+&
&               s12)+s11)+s10) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)&
&               +s24)+s23)+s22)+s21)+s20)
            ELSE IF (tt .GE. tstarr2 .AND. tt .LT. tstarr3) THEN
              qs(i, j) = tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+&
&               s21) + s20
            ELSE IF (tt .GE. tstarr3 .AND. tt .LT. tstarr4) THEN
              w = (tstarr4-tt)/(tstarr4-tstarr3)
              qs(i, j) = w*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+&
&               s22)+s21)+s20) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)&
&               +bi4)+bi3)+bi2)+bi1)+bi0)
            ELSE
              qs(i, j) = tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2)+&
&               bi1) + bi0
            END IF
          ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
            tt = zeroc/ti
            qs(i, j) = di(0)*EXP(-(di(1)/tt+di(2)*LOG(tt)+di(3)*tt))
          ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
            qs(i, j) = EXP(ci(0) + ci(1)/ti + ci(2)*ALOG(ti) + ci(3)*ti)
          END IF
          IF (PRESENT(dq)) THEN
            IF (tl(i, j) .LT. tminice) THEN
              ddq = 0.0
            ELSE IF (tl(i, j) .GT. zeroc) THEN
              ddq = 0.0
            ELSE IF (pl(i, j) .GT. qs(i, j)) THEN
              dd = qs(i, j)
              ti = tl(i, j) + delta_t
              IF (type .EQ. 1) THEN
! Use Starr formulation
                tt = ti - zeroc
                IF (tt .LT. tstarr1) THEN
                  qs(i, j) = tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+&
&                   s12)+s11) + s10
                ELSE IF (tt .GE. tstarr1 .AND. tt .LT. tstarr2) THEN
                  w = (tstarr2-tt)/(tstarr2-tstarr1)
                  qs(i, j) = w*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13&
&                   )+s12)+s11)+s10) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*&
&                   s26+s25)+s24)+s23)+s22)+s21)+s20)
                ELSE IF (tt .GE. tstarr2 .AND. tt .LT. tstarr3) THEN
                  qs(i, j) = tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+&
&                   s22)+s21) + s20
                ELSE IF (tt .GE. tstarr3 .AND. tt .LT. tstarr4) THEN
                  w = (tstarr4-tt)/(tstarr4-tstarr3)
                  qs(i, j) = w*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23&
&                   )+s22)+s21)+s20) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*&
&                   bi6+bi5)+bi4)+bi3)+bi2)+bi1)+bi0)
                ELSE
                  qs(i, j) = tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+&
&                   bi2)+bi1) + bi0
                END IF
              ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
                tt = zeroc/ti
                qs(i, j) = di(0)*EXP(-(di(1)/tt+di(2)*LOG(tt)+di(3)*tt))
              ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
                qs(i, j) = EXP(ci(0) + ci(1)/ti + ci(2)*ALOG(ti) + ci(3)&
&                 *ti)
              END IF
              ddq = qs(i, j) - dd
              qs(i, j) = dd
            END IF
          END IF
          IF (PRESENT(pl)) THEN
            IF (pl(i, j) .GT. qs(i, j)) THEN
              dd = esfac/(pl(i, j)-(1.0-esfac)*qs(i, j))
              qs(i, j) = qs(i, j)*dd
              IF (PRESENT(dq)) dq(i, j) = ddq*erfac*pl(i, j)*dd*dd
            ELSE
              qs(i, j) = max_mixing_ratio
              IF (PRESENT(dq)) dq(i, j) = 0.0
            END IF
          ELSE IF (PRESENT(dq)) THEN
            dq(i, j) = ddq*(1.0/delta_t)
          END IF
        END IF
      END DO
    END DO
  END FUNCTION QSATICE2
  FUNCTION QSATICE3(tl, pl, dq) RESULT (QS)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:, :, :)
    REAL, OPTIONAL, INTENT(IN) :: pl(:, :, :)
    REAL, OPTIONAL, INTENT(OUT) :: dq(:, :, :)
    REAL :: qs(SIZE(tl, 1), SIZE(tl, 2), SIZE(tl, 3))
    INTEGER :: i, j, k
    REAL :: ti, w
    REAL :: tt
    REAL :: ddq
    REAL :: dd
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC LOG
    INTRINSIC EXP
    INTRINSIC ALOG
    INTRINSIC SIZE
    DO k=1,SIZE(tl, 3)
      DO j=1,SIZE(tl, 2)
        DO i=1,SIZE(tl, 1)
          IF (utbl) THEN
            IF (first) THEN
              first = .false.
              CALL ESINIT()
            END IF
            IF (tl(i, j, k) .LE. tmintbl) THEN
              qs(i, j, k) = estble(1)
              IF (PRESENT(dq)) ddq = 0.0
            ELSE IF (tl(i, j, k) .GE. zeroc) THEN
              qs(i, j, k) = estfrz
              IF (PRESENT(dq)) ddq = 0.0
            ELSE
              tt = (tl(i, j, k)-tmintbl)*degsubs + 1
              it = INT(tt)
              ddq = estble(it+1) - estble(it)
              qs(i, j, k) = (tt-it)*ddq + estble(it)
            END IF
            IF (PRESENT(pl)) THEN
              IF (pl(i, j, k) .GT. qs(i, j, k)) THEN
                dd = esfac/(pl(i, j, k)-(1.0-esfac)*qs(i, j, k))
                qs(i, j, k) = qs(i, j, k)*dd
                IF (PRESENT(dq)) dq(i, j, k) = ddq*erfac*pl(i, j, k)*dd*&
&                   dd
              ELSE
                qs(i, j, k) = max_mixing_ratio
                IF (PRESENT(dq)) dq(i, j, k) = 0.0
              END IF
            ELSE IF (PRESENT(dq)) THEN
              dq(i, j, k) = ddq
            END IF
          ELSE
! Exact Formulation
            IF (tl(i, j, k) .LT. tminice) THEN
              ti = tminice
            ELSE IF (tl(i, j, k) .GT. zeroc) THEN
              ti = zeroc
            ELSE
              ti = tl(i, j, k)
            END IF
            IF (type .EQ. 1) THEN
! Use Starr formulation
              tt = ti - zeroc
              IF (tt .LT. tstarr1) THEN
                qs(i, j, k) = tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+&
&                 s12)+s11) + s10
              ELSE IF (tt .GE. tstarr1 .AND. tt .LT. tstarr2) THEN
                w = (tstarr2-tt)/(tstarr2-tstarr1)
                qs(i, j, k) = w*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+&
&                 s13)+s12)+s11)+s10) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*&
&                 s26+s25)+s24)+s23)+s22)+s21)+s20)
              ELSE IF (tt .GE. tstarr2 .AND. tt .LT. tstarr3) THEN
                qs(i, j, k) = tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+&
&                 s22)+s21) + s20
              ELSE IF (tt .GE. tstarr3 .AND. tt .LT. tstarr4) THEN
                w = (tstarr4-tt)/(tstarr4-tstarr3)
                qs(i, j, k) = w*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+&
&                 s23)+s22)+s21)+s20) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*&
&                 bi6+bi5)+bi4)+bi3)+bi2)+bi1)+bi0)
              ELSE
                qs(i, j, k) = tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+&
&                 bi2)+bi1) + bi0
              END IF
            ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
              tt = zeroc/ti
              qs(i, j, k) = di(0)*EXP(-(di(1)/tt+di(2)*LOG(tt)+di(3)*tt)&
&               )
            ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
              qs(i, j, k) = EXP(ci(0) + ci(1)/ti + ci(2)*ALOG(ti) + ci(3&
&               )*ti)
            END IF
            IF (PRESENT(dq)) THEN
              IF (tl(i, j, k) .LT. tminice) THEN
                ddq = 0.0
              ELSE IF (tl(i, j, k) .GT. zeroc) THEN
                ddq = 0.0
              ELSE IF (pl(i, j, k) .GT. qs(i, j, k)) THEN
                dd = qs(i, j, k)
                ti = tl(i, j, k) + delta_t
                IF (type .EQ. 1) THEN
! Use Starr formulation
                  tt = ti - zeroc
                  IF (tt .LT. tstarr1) THEN
                    qs(i, j, k) = tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+&
&                     s13)+s12)+s11) + s10
                  ELSE IF (tt .GE. tstarr1 .AND. tt .LT. tstarr2) THEN
                    w = (tstarr2-tt)/(tstarr2-tstarr1)
                    qs(i, j, k) = w*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14&
&                     )+s13)+s12)+s11)+s10) + (1.-w)*(tt*(tt*(tt*(tt*(tt&
&                     *(tt*s26+s25)+s24)+s23)+s22)+s21)+s20)
                  ELSE IF (tt .GE. tstarr2 .AND. tt .LT. tstarr3) THEN
                    qs(i, j, k) = tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+&
&                     s23)+s22)+s21) + s20
                  ELSE IF (tt .GE. tstarr3 .AND. tt .LT. tstarr4) THEN
                    w = (tstarr4-tt)/(tstarr4-tstarr3)
                    qs(i, j, k) = w*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24&
&                     )+s23)+s22)+s21)+s20) + (1.-w)*(tt*(tt*(tt*(tt*(tt&
&                     *(tt*bi6+bi5)+bi4)+bi3)+bi2)+bi1)+bi0)
                  ELSE
                    qs(i, j, k) = tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+&
&                     bi3)+bi2)+bi1) + bi0
                  END IF
                ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
                  tt = zeroc/ti
                  qs(i, j, k) = di(0)*EXP(-(di(1)/tt+di(2)*LOG(tt)+di(3)&
&                   *tt))
                ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
                  qs(i, j, k) = EXP(ci(0) + ci(1)/ti + ci(2)*ALOG(ti) + &
&                   ci(3)*ti)
                END IF
                ddq = qs(i, j, k) - dd
                qs(i, j, k) = dd
              END IF
            END IF
            IF (PRESENT(pl)) THEN
              IF (pl(i, j, k) .GT. qs(i, j, k)) THEN
                dd = esfac/(pl(i, j, k)-(1.0-esfac)*qs(i, j, k))
                qs(i, j, k) = qs(i, j, k)*dd
                IF (PRESENT(dq)) dq(i, j, k) = ddq*erfac*pl(i, j, k)*dd*&
&                   dd
              ELSE
                qs(i, j, k) = max_mixing_ratio
                IF (PRESENT(dq)) dq(i, j, k) = 0.0
              END IF
            ELSE IF (PRESENT(dq)) THEN
              dq(i, j, k) = ddq*(1.0/delta_t)
            END IF
          END IF
        END DO
      END DO
    END DO
  END FUNCTION QSATICE3
  FUNCTION QSAT1(tl, pl, ramp, pascals, dqsat) RESULT (QSAT)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:), pl(:)
    LOGICAL, OPTIONAL, INTENT(IN) :: pascals
    REAL, OPTIONAL, INTENT(IN) :: ramp
    REAL, OPTIONAL, INTENT(OUT) :: dqsat(:)
    REAL :: qsat(SIZE(tl, 1))
    INTEGER :: i
    INTRINSIC PRESENT
    INTRINSIC SIZE
    DO i=1,SIZE(tl, 1)
      IF (PRESENT(dqsat)) THEN
        qsat(i) = QSAT0(tl(i), pl(i), ramp, pascals, dqsat(i))
      ELSE
        qsat(i) = QSAT0(tl(i), pl(i), ramp, pascals)
      END IF
    END DO
  END FUNCTION QSAT1
  FUNCTION QSAT2(tl, pl, ramp, pascals, dqsat) RESULT (QSAT)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:, :), pl(:, :)
    LOGICAL, OPTIONAL, INTENT(IN) :: pascals
    REAL, OPTIONAL, INTENT(IN) :: ramp
    REAL, OPTIONAL, INTENT(OUT) :: dqsat(:, :)
    REAL :: qsat(SIZE(tl, 1), SIZE(tl, 2))
    INTEGER :: i, j
    INTRINSIC PRESENT
    INTRINSIC SIZE
    DO j=1,SIZE(tl, 2)
      DO i=1,SIZE(tl, 1)
        IF (PRESENT(dqsat)) THEN
          qsat(i, j) = QSAT0(tl(i, j), pl(i, j), ramp, pascals, dqsat(i&
&           , j))
        ELSE
          qsat(i, j) = QSAT0(tl(i, j), pl(i, j), ramp, pascals)
        END IF
      END DO
    END DO
  END FUNCTION QSAT2
  FUNCTION QSAT3(tl, pl, ramp, pascals, dqsat) RESULT (QSAT)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:, :, :), pl(:, :, :)
    LOGICAL, OPTIONAL, INTENT(IN) :: pascals
    REAL, OPTIONAL, INTENT(IN) :: ramp
    REAL, OPTIONAL, INTENT(OUT) :: dqsat(:, :, :)
    REAL :: qsat(SIZE(tl, 1), SIZE(tl, 2), SIZE(tl, 3))
    INTEGER :: i, j, k
    INTRINSIC PRESENT
    INTRINSIC SIZE
    DO k=1,SIZE(tl, 3)
      DO j=1,SIZE(tl, 2)
        DO i=1,SIZE(tl, 1)
          IF (PRESENT(dqsat)) THEN
            qsat(i, j, k) = QSAT0(tl(i, j, k), pl(i, j, k), ramp, &
&             pascals, dqsat(i, j, k))
          ELSE
            qsat(i, j, k) = QSAT0(tl(i, j, k), pl(i, j, k), ramp, &
&             pascals)
          END IF
        END DO
      END DO
    END DO
  END FUNCTION QSAT3
!==============================================
!==============================================
!  Traditional Qsat and Dqsat (these are deprecated)
!==============================================
!==============================================
!BOPI
! !IROUTINE: GEOS_Qsat -- Computes satuation specific humidity.
! !INTERFACE:
!    function GEOS_Qsat(TL,PL,RAMP,PASCALS,DQSAT) result(QSAT)
!
! Overloads:
!
!      real,                      intent(IN)                        :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real,                     optional, intent(OUT)              :: DQSAT
!      real                                                         :: QSAT
!
!      real, dimension(:),        intent(IN)                        :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real,                     optional, intent(OUT)              :: DQSAT(:)
!      real, dimension(size(PL,1))                                  :: QSAT
!
!      real, dimension(:,:),      intent(IN)                        :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real,                     optional, intent(OUT)              :: DQSAT(:,:)
!      real, dimension(size(PL,1),size(PL,2))                       :: QSAT
!
!      real, dimension(:,:,:),    intent(IN)                        :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real,                     optional, intent(OUT)              :: DQSAT(:,:,:)
!      real, dimension(size(PL,1),size(PL,2),size(PL,3))            :: QSAT
!
! !DESCRIPTION:  Uses various formulations of the saturation
!                vapor pressure to compute the saturation specific
!    humidity for temperature TL and pressure PL.
!
!    For temperatures <= TMIX (-20C)
!    the calculation is done over ice; for temperatures >= ZEROC (0C) the calculation
!    is done over liquid water; and in between these values,
!    it interpolates linearly between the two.
!
!    The optional RAMP is the width of this
!    ice/water ramp (i.e., TMIX = ZEROC-RAMP); its default is 20.
!
!    If PASCALS is true, PL is
!    assumed to be in Pa; if false or not present, it is assumed to be in mb.
!
!    The choice of saturation vapor pressure formulation is a compile-time
!    option. Three choices are currently supported: The CAM formulation,
!    Murphy and Koop (2005, QJRMS), and Staars formulation from NSIPP-1.
!
!    Another compile time choice is whether to use the exact formulation
!    or a table look-up.
!    If UTBL is true, tabled values of the saturation vapor pressures
!    are used. These tables are automatically generated at a 0.1K resolution
!    for whatever vapor pressure formulation is being used.
!
!
!EOPI
  FUNCTION QSAT0(tl, pl, ramp, pascals, dqsat) RESULT (QSAT)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl, pl
    LOGICAL, OPTIONAL, INTENT(IN) :: pascals
    REAL, OPTIONAL, INTENT(IN) :: ramp
    REAL, OPTIONAL, INTENT(OUT) :: dqsat
    REAL :: qsat
    REAL :: uramp, dd, qq, ti, dq, pp
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC ABS
    INTRINSIC INT
    REAL :: abs0
    IF (PRESENT(ramp)) THEN
      IF (ramp .GE. 0.) THEN
        abs0 = ramp
      ELSE
        abs0 = -ramp
      END IF
      uramp = -abs0
    ELSE
      uramp = tmix
    END IF
    IF (PRESENT(pascals)) THEN
      IF (pascals) THEN
        pp = pl
      ELSE
        pp = pl*100.
      END IF
    ELSE
      pp = pl*100.
    END IF
    IF (uramp .EQ. tmix .OR. (uramp .EQ. 0. .AND. utbl)) THEN
      IF (first) THEN
        first = .false.
        CALL ESINIT()
      END IF
      IF (tl .LE. tmintbl) THEN
        ti = tmintbl
      ELSE IF (tl .GE. tmaxtbl - .001) THEN
        ti = tmaxtbl - .001
      ELSE
        ti = tl
      END IF
      ti = (ti-tmintbl)*degsubs + 1
      it = INT(ti)
      IF (uramp .EQ. tmix) THEN
        dq = estblx(it+1) - estblx(it)
        qsat = (ti-it)*dq + estblx(it)
      ELSE
        dq = estble(it+1) - estble(it)
        qsat = (ti-it)*dq + estble(it)
      END IF
      IF (PRESENT(dqsat)) dqsat = dq*degsubs
      IF (pp .LE. qsat) THEN
        qsat = max_mixing_ratio
        IF (PRESENT(dqsat)) dqsat = 0.0
      ELSE
        dd = 1.0/(pp-(1.0-esfac)*qsat)
        qsat = esfac*qsat*dd
        IF (PRESENT(dqsat)) dqsat = esfac*dqsat*pp*(dd*dd)
      END IF
    ELSE
      ti = tl - zeroc
      IF (ti .LE. uramp) THEN
        qsat = QSATICE0(tl, pp, dqsat)
      ELSE IF (ti .GE. 0.0) THEN
        qsat = QSATLQU0(tl, pp, dqsat)
      ELSE
        qsat = QSATICE0(tl, pp, dqsat)
        qq = QSATLQU0(tl, pp, dq)
        ti = ti/uramp
        qsat = ti*(qsat-qq) + qq
        IF (PRESENT(dqsat)) dqsat = ti*(dqsat-dq) + dq
      END IF
    END IF
  END FUNCTION QSAT0
!  Differentiation of dqsat0 in reverse (adjoint) mode (with options r8):
!   gradient     of useful results: qsat dqsat
!   with respect to varying inputs: tl qsat
!=======================================================================================
!BOPI
! !IROUTINE: GEOS_DQsat -- Computes derivative satuation specific humidity wrt temperature.
! !INTERFACE:
!    function GEOS_DQsat(TL,PL,RAMP,PASCALS,QSAT) result(DQSAT)
!
! Overloads:
!
!      real,                               intent(IN)               :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real,                     optional, intent(OUT)              :: QSAT
!      real                                                         :: DQSAT
!
!      real, dimension(:),                 intent(IN)               :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real, dimension(:),       optional, intent(OUT)              :: QSAT
!      real, dimension(size(PL,1))                                  :: DQSAT
!
!      real, dimension(:,:),               intent(IN)               :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real, dimension(:,:),     optional, intent(OUT)              :: QSAT
!      real, dimension(size(PL,1),size(PL,2))                       :: DQSAT
!
!      real, dimension(:,:,:),             intent(IN)               :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real, dimension(:,:,:),   optional, intent(OUT)              :: QSAT
!      real, dimension(size(PL,1),size(PL,2),size(PL,3))            :: DQSAT
!
!      real, dimension(:,:,:,:),           intent(IN)               :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real, dimension(:,:,:,:), optional, intent(OUT)              :: QSAT
!      real, dimension(size(PL,1),size(PL,2),size(PL,3),size(PL,4)) :: DQSAT
! !DESCRIPTION:  Differentiates the approximations used
!                by GEOS_Qsat with respect to temperature,
!    using the same scheme to handle ice. Arguments are as in
!    GEOS_Qsat, with the addition of QSAT, which is the saturation specific
!    humidity. This is for economy, in case both qsat and dqsat are
!    required.
!
!EOPI
  SUBROUTINE DQSAT0_ADM(tl, tl_ad, pl, ramp, pascals, qsat, qsat_ad, &
&   dqsat_ad)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl, pl
    REAL :: tl_ad
    LOGICAL, OPTIONAL, INTENT(IN) :: pascals
    REAL, OPTIONAL, INTENT(IN) :: ramp
    REAL, OPTIONAL :: qsat
    REAL, OPTIONAL :: qsat_ad
    REAL :: dqsat
    REAL :: dqsat_ad
    REAL :: uramp, tt, ww, dd, dqq, qq, ti, dqi, qi, pp
    REAL :: tt_ad, dd_ad, dqq_ad, qq_ad, ti_ad, dqi_ad, qi_ad
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC ABS
    INTRINSIC INT
    REAL :: abs0
    REAL :: temp
    INTEGER :: branch
    IF (PRESENT(ramp)) THEN
      IF (ramp .GE. 0.) THEN
        CALL PUSHCONTROL1B(0)
        abs0 = ramp
      ELSE
        CALL PUSHCONTROL1B(0)
        abs0 = -ramp
      END IF
      uramp = -abs0
    ELSE
      CALL PUSHCONTROL1B(1)
      uramp = tmix
    END IF
    IF (PRESENT(pascals)) THEN
      IF (pascals) THEN
        CALL PUSHCONTROL1B(0)
        pp = pl
      ELSE
        CALL PUSHCONTROL1B(0)
        pp = pl*100.
      END IF
    ELSE
      CALL PUSHCONTROL1B(1)
      pp = pl*100.
    END IF
    IF (uramp .EQ. tmix .OR. (uramp .EQ. 0. .AND. utbl)) THEN
      IF (tl .LE. tmintbl) THEN
        ti = tmintbl
        CALL PUSHCONTROL2B(0)
      ELSE IF (tl .GE. tmaxtbl - .001) THEN
        ti = tmaxtbl - .001
        CALL PUSHCONTROL2B(1)
      ELSE
        ti = tl
        CALL PUSHCONTROL2B(2)
      END IF
      tt = (ti-tmintbl)*degsubs + 1
      it = INT(tt)
      IF (uramp .EQ. tmix) THEN
        dqq = estblx(it+1) - estblx(it)
        qq = (tt-it)*dqq + estblx(it)
        CALL PUSHCONTROL1B(0)
      ELSE
        dqq = estble(it+1) - estble(it)
        qq = (tt-it)*dqq + estble(it)
        CALL PUSHCONTROL1B(1)
      END IF
      IF (pp .LE. qq) THEN
        IF (PRESENT(qsat)) qsat_ad = 0.0_8
        qq_ad = 0.0_8
      ELSE
        dd = 1.0/(pp-(1.0-esfac)*qq)
        IF (PRESENT(qsat)) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        dd_ad = esfac*degsubs*dqq*pp*2*dd*dqsat_ad
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          qq_ad = esfac*dd*qsat_ad
          dd_ad = dd_ad + esfac*qq*qsat_ad
          qsat_ad = 0.0_8
        ELSE
          qq_ad = 0.0_8
        END IF
        temp = pp - (-esfac+1.0)*qq
        qq_ad = qq_ad + (1.0-esfac)*dd_ad/temp**2
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        tt_ad = dqq*qq_ad
      ELSE
        tt_ad = dqq*qq_ad
      END IF
      ti_ad = degsubs*tt_ad
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        tl_ad = 0.0_8
      ELSE IF (branch .EQ. 1) THEN
        tl_ad = 0.0_8
      ELSE
        tl_ad = ti_ad
      END IF
    ELSE
      ti = tl - zeroc
      IF (ti .LE. uramp) THEN
        IF (PRESENT(qsat)) THEN
          qq_ad = qsat_ad
          qsat_ad = 0.0_8
        ELSE
          qq_ad = 0.0_8
        END IF
        CALL QSATICE0_ADM(tl, tl_ad, pp, dq=dqsat, dq_ad=dqsat_ad, qs_ad&
&                   =qq_ad)
        ti_ad = 0.0_8
      ELSE IF (ti .GE. 0.0) THEN
        IF (PRESENT(qsat)) THEN
          qq_ad = qsat_ad
          qsat_ad = 0.0_8
        ELSE
          qq_ad = 0.0_8
        END IF
        tl_ad = 0.0_8
        CALL QSATLQU0_ADM(tl, tl_ad, pp, dq=dqsat, dq_ad=dqsat_ad, qs_ad&
&                   =qq_ad)
        ti_ad = 0.0_8
      ELSE
        CALL PUSHREAL8ARRAY(estblw, tablesize)
        CALL PUSHBOOLEAN(utbl)
        CALL PUSHREAL8(estlqu)
        qq = QSATLQU0(tl, pp, dq=dqq)
        CALL PUSHBOOLEAN(utbl)
        CALL PUSHREAL8ARRAY(estble, tablesize)
        CALL PUSHREAL8(estfrz)
        qi = QSATICE0(tl, pp, dq=dqi)
        ti = ti/uramp
        IF (PRESENT(qsat)) THEN
          ti_ad = (qi-qq)*qsat_ad
          qi_ad = ti*qsat_ad
          qq_ad = (1.0-ti)*qsat_ad
          qsat_ad = 0.0_8
        ELSE
          ti_ad = 0.0_8
          qi_ad = 0.0_8
          qq_ad = 0.0_8
        END IF
        ti_ad = ti_ad + (dqi-dqq)*dqsat_ad
        dqi_ad = ti*dqsat_ad
        dqq_ad = (1.0-ti)*dqsat_ad
        ti_ad = ti_ad/uramp
        CALL POPREAL8(estfrz)
        CALL POPREAL8ARRAY(estble, tablesize)
        CALL POPBOOLEAN(utbl)
        CALL QSATICE0_ADM(tl, tl_ad, pp, dq=dqi, dq_ad=dqi_ad, qs_ad=&
&                   qi_ad)
        CALL POPREAL8(estlqu)
        CALL POPBOOLEAN(utbl)
        CALL POPREAL8ARRAY(estblw, tablesize)
        CALL QSATLQU0_ADM(tl, tl_ad, pp, dq=dqq, dq_ad=dqq_ad, qs_ad=&
&                   qq_ad)
      END IF
      tl_ad = tl_ad + ti_ad
    END IF
    CALL POPCONTROL1B(branch)
    CALL POPCONTROL1B(branch)
  END SUBROUTINE DQSAT0_ADM
!  Differentiation of qsatlqu0 in reverse (adjoint) mode (with options r8):
!   gradient     of useful results: tl dq qs
!   with respect to varying inputs: tl
!BOPI
! !IROUTINE: GEOS_QsatLqu Computes saturation specific humidity over
!            liquid water.
! !IROUTINE: GEOS_QsatIce Computes saturation specific humidity over
!            frozen water.
! !INTERFACE:
!    function GEOS_QsatLqu(TL,PL,DQ) result(QS)
!    function GEOS_QsatIce(TL,PL,DQ) result(QS)
!
! Overloads:
!
!      real,                               intent(IN)               :: TL
!      logical,                  optional, intent(IN)               :: PL
!      real,                     optional, intent(OUT)              :: DQ
!      real                                                         :: QS
!
!      real,                               intent(IN)               :: TL(:)
!      logical,                  optional, intent(IN)               :: PL(:)
!      real,                     optional, intent(OUT)              :: DQ(:)
!      real, dimension(size(TL,1))                                  :: QS
!
!      real,                               intent(IN)               :: TL(:,:)
!      logical,                  optional, intent(IN)               :: PL(:,:)
!      real,                     optional, intent(OUT)              :: DQ(:,:)
!      real, dimension(size(TL,1),size(TL,2))                       :: QS
!
!      real,                               intent(IN)               :: TL(:,:,:)
!      logical,                  optional, intent(IN)               :: PL(:,:,:)
!      real,                     optional, intent(OUT)              :: DQ(:,:,:)
!      real, dimension(size(TL,1),size(TL,2),size(TL,3))            :: QS
!
!
! !DESCRIPTION:  Uses various formulations of the saturation
!                vapor pressure to compute the saturation specific
!    humidity and, optionally, its derivative with respect to temperature
!    for temperature TL and pressure PL. If PL is not present
!    it returns the saturation vapor pressure and, optionally, its derivative.
!
!    All pressures are in Pascals and all temperatures in Kelvins.
!
!    The choice of saturation vapor pressure formulation is controlled by  GEOS_QsatSet.
!    Three choices are currently supported: The CAM formulation,
!    Murphy and Koop (2005, QJRMS), and the Staar formulation from NSIPP-1.
!    The default is Starr. All three are valid up to 333K. Above the
!    freezing point, GEOS_QsatIce returns values at the freezing point.
!    Murphy and Koop is valid down to 150K, for both liquid and ice.
!    The other two are valid down to 178K for ice and 233K for super-cooled liquid.
!
!    Another choice is whether to use the exact formulation
!    or a table look-up. This can also be controlled with GEOS_QsatSet.
!    The default is to do a table look-up. The tables are generated
!    at 0.1C intervals, controlled by parameter DEGSUBS=10.
!
!
!EOPI
  SUBROUTINE QSATLQU0_ADM(tl, tl_ad, pl, dq, dq_ad, qs_ad)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl
    REAL :: tl_ad
    REAL, OPTIONAL, INTENT(IN) :: pl
    REAL, OPTIONAL :: dq
    REAL, OPTIONAL :: dq_ad
    REAL :: qs
    REAL :: qs_ad
    REAL :: ti, w
    REAL :: ti_ad
    REAL :: dd
    REAL :: dd_ad
    REAL :: tt
    REAL :: tt_ad
    REAL :: ddq
    REAL :: ddq_ad
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC LOG10
    INTRINSIC ALOG
    INTRINSIC TANH
    INTRINSIC EXP
    REAL :: temp
    REAL*8 :: temp0
    REAL*8 :: temp1
    REAL*8 :: temp_ad
    REAL*8 :: temp_ad0
    REAL*8 :: temp2
    REAL*8 :: temp3
    REAL*8 :: temp4
    REAL*8 :: temp_ad1
    REAL*8 :: temp5
    REAL*8 :: temp6
    REAL*8 :: temp7
    REAL*8 :: temp8
    REAL*8 :: temp9
    REAL*8 :: temp_ad2
    REAL*8 :: temp_ad3
    REAL*8 :: temp10
    REAL*8 :: temp11
    REAL*8 :: temp_ad4
    REAL*8 :: temp_ad5
    REAL*8 :: temp12
    REAL*8 :: temp13
    REAL*8 :: temp14
    REAL*8 :: temp_ad6
    REAL*8 :: temp15
    REAL*8 :: temp16
    REAL*8 :: temp17
    REAL*8 :: temp18
    REAL*8 :: temp19
    REAL*8 :: temp_ad7
    REAL*8 :: temp_ad8
    REAL :: temp20
    REAL :: temp_ad9
    INTEGER :: branch
! not table
    IF (utbl) THEN
      IF (tl .LE. tminlqu) THEN
        qs = estlqu
        IF (PRESENT(dq)) THEN
          CALL PUSHCONTROL2B(0)
          ddq = 0.0
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
      ELSE IF (tl .GE. tmaxtbl) THEN
        qs = estblw(tablesize)
        IF (PRESENT(dq)) THEN
          CALL PUSHCONTROL2B(1)
          ddq = 0.0
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        tt = (tl-tmintbl)*degsubs + 1
        it = INT(tt)
        ddq = estblw(it+1) - estblw(it)
        qs = (tt-it)*ddq + estblw(it)
        CALL PUSHCONTROL2B(2)
      END IF
      IF (PRESENT(pl)) THEN
        IF (pl .GT. qs) THEN
          dd = esfac/(pl-(1.0-esfac)*qs)
          IF (PRESENT(dq)) THEN
            dd_ad = pl*ddq*erfac*2*dd*dq_ad
          ELSE
            dd_ad = 0.0_8
          END IF
          temp = pl - (-esfac+1.0)*qs
          dd_ad = dd_ad + qs*qs_ad
          qs_ad = esfac*(1.0-esfac)*dd_ad/temp**2 + dd*qs_ad
        ELSE
          qs_ad = 0.0_8
        END IF
      END IF
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .NE. 1) THEN
          tt_ad = ddq*qs_ad
          tl_ad = tl_ad + degsubs*tt_ad
        END IF
      END IF
    ELSE
! Exact Formulation
      IF (tl .LT. tminlqu) THEN
        CALL PUSHCONTROL2B(0)
        ti = tminlqu
      ELSE IF (tl .GT. tmaxtbl) THEN
        CALL PUSHCONTROL2B(1)
        ti = tmaxtbl
      ELSE
        ti = tl
        CALL PUSHCONTROL2B(2)
      END IF
      IF (type .EQ. 1) THEN
!  Starr polynomial fit
        tt = ti - zeroc
        qs = tt*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+b1) + b0
        CALL PUSHCONTROL2B(0)
      ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
        tt = ts/ti
        qs = 10.0**(dl(1)*(tt-1.0)+dl(2)*LOG10(tt)+dl(3)*(10.0**(dl(4)*(&
&         1.0-1.0/tt))-1.0)/10000000.0+dl(5)*(10.0**(dl(6)*(tt-1.0))-1.0&
&         )/1000.0+logps+2.0)
        CALL PUSHCONTROL2B(1)
      ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
        qs = EXP(cl(0) + cl(1)/ti + cl(2)*ALOG(ti) + cl(3)*ti + TANH(cl(&
&         4)*(ti-cl(5)))*(cl(6)+cl(7)/ti+cl(8)*ALOG(ti)+cl(9)*ti))
        CALL PUSHCONTROL2B(2)
      ELSE
        CALL PUSHCONTROL2B(3)
      END IF
      IF (PRESENT(dq)) THEN
        IF (tl .LT. tminlqu) THEN
          CALL PUSHCONTROL3B(0)
          ddq = 0.0
        ELSE IF (tl .GT. tmaxtbl) THEN
          CALL PUSHCONTROL3B(1)
          ddq = 0.0
        ELSE IF (pl .GT. qs) THEN
          dd = qs
          CALL PUSHREAL8(ti)
          ti = tl + delta_t
          IF (type .EQ. 1) THEN
!  Starr polynomial fit
            CALL PUSHREAL8(tt)
            tt = ti - zeroc
            qs = tt*(tt*(tt*(tt*(tt*(tt*b6+b5)+b4)+b3)+b2)+b1) + b0
            CALL PUSHCONTROL2B(0)
          ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
            CALL PUSHREAL8(tt)
            tt = ts/ti
            qs = 10.0**(dl(1)*(tt-1.0)+dl(2)*LOG10(tt)+dl(3)*(10.0**(dl(&
&             4)*(1.0-1.0/tt))-1.0)/10000000.0+dl(5)*(10.0**(dl(6)*(tt-&
&             1.0))-1.0)/1000.0+logps+2.0)
            CALL PUSHCONTROL2B(1)
          ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
            qs = EXP(cl(0) + cl(1)/ti + cl(2)*ALOG(ti) + cl(3)*ti + TANH&
&             (cl(4)*(ti-cl(5)))*(cl(6)+cl(7)/ti+cl(8)*ALOG(ti)+cl(9)*ti&
&             ))
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(3)
          END IF
          ddq = qs - dd
          qs = dd
          CALL PUSHCONTROL3B(2)
        ELSE
          CALL PUSHCONTROL3B(3)
        END IF
      ELSE
        CALL PUSHCONTROL3B(4)
      END IF
      IF (PRESENT(pl)) THEN
        IF (pl .GT. qs) THEN
          dd = esfac/(pl-(1.0-esfac)*qs)
          IF (PRESENT(dq)) THEN
            temp_ad9 = erfac*pl*dq_ad
            ddq_ad = dd**2*temp_ad9
            dd_ad = ddq*2*dd*temp_ad9
          ELSE
            dd_ad = 0.0_8
            ddq_ad = 0.0_8
          END IF
          temp20 = pl - (-esfac+1.0)*qs
          dd_ad = dd_ad + qs*qs_ad
          qs_ad = esfac*(1.0-esfac)*dd_ad/temp20**2 + dd*qs_ad
        ELSE
          qs_ad = 0.0_8
          ddq_ad = 0.0_8
        END IF
      ELSE IF (PRESENT(dq)) THEN
        ddq_ad = dq_ad/delta_t
      ELSE
        ddq_ad = 0.0_8
      END IF
      CALL POPCONTROL3B(branch)
      IF (branch .GE. 2) THEN
        IF (branch .EQ. 2) THEN
          dd_ad = qs_ad - ddq_ad
          qs_ad = ddq_ad
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              temp11 = b4 + tt*(b5+b6*tt)
              temp10 = b3 + tt*temp11
              temp_ad4 = tt**2*qs_ad
              temp_ad5 = tt*temp_ad4
              tt_ad = (tt**2*b6+tt*(b5+b6*tt)+temp11)*temp_ad5 + temp10*&
&               temp_ad4 + (2*(tt*(b2+tt*temp10))+b1)*qs_ad
              CALL POPREAL8(tt)
              ti_ad = tt_ad
              qs_ad = 0.0_8
            ELSE
              temp14 = 10.0**(dl(6)*(tt-1.0))
              temp13 = dl(4)*(-(1.0/tt)+1.0)
              temp12 = 10.0**temp13
              temp_ad6 = 10.0**(logps+dl(1)*(tt-1.0)+dl(2)*LOG10(tt)+dl(&
&               3)*((temp12-1.0)/10000000.0)+dl(5)*((temp14-1.0)/1000.0)&
&               +2.0)*LOG(10.0)*qs_ad
              tt_ad = (temp14*LOG(10.0)*dl(5)*dl(6)/1000.0+dl(4)*temp12*&
&               LOG(10.0)*dl(3)/(tt**2*10000000.0)+dl(2)/(tt*LOG(10.0))+&
&               dl(1))*temp_ad6
              CALL POPREAL8(tt)
              ti_ad = -(ts*tt_ad/ti**2)
              qs_ad = 0.0_8
            END IF
          ELSE IF (branch .EQ. 2) THEN
            temp19 = cl(7)/ti
            temp15 = cl(6) + temp19 + cl(8)*ALOG(ti) + cl(9)*ti
            temp18 = cl(4)*(ti-cl(5))
            temp17 = TANH(temp18)
            temp16 = cl(1)/ti
            temp_ad7 = EXP(cl(0)+temp16+cl(2)*ALOG(ti)+cl(3)*ti+temp17*&
&             temp15)*qs_ad
            temp_ad8 = temp17*temp_ad7
            ti_ad = (cl(9)+cl(8)/ti-temp19/ti)*temp_ad8 + ((1.0-TANH(&
&             temp18)**2)*temp15*cl(4)+cl(3)+cl(2)/ti-temp16/ti)*&
&             temp_ad7
            qs_ad = 0.0_8
          ELSE
            ti_ad = 0.0_8
          END IF
          CALL POPREAL8(ti)
          tl_ad = tl_ad + ti_ad
          qs_ad = qs_ad + dd_ad
        END IF
      END IF
      CALL POPCONTROL2B(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          temp1 = b4 + tt*(b5+b6*tt)
          temp0 = b3 + tt*temp1
          temp_ad = tt**2*qs_ad
          temp_ad0 = tt*temp_ad
          tt_ad = (tt**2*b6+tt*(b5+b6*tt)+temp1)*temp_ad0 + temp0*&
&           temp_ad + (2*(tt*(b2+tt*temp0))+b1)*qs_ad
          ti_ad = tt_ad
        ELSE
          tt = ts/ti
          temp4 = 10.0**(dl(6)*(tt-1.0))
          temp3 = dl(4)*(-(1.0/tt)+1.0)
          temp2 = 10.0**temp3
          temp_ad1 = 10.0**(logps+dl(1)*(tt-1.0)+dl(2)*LOG10(tt)+dl(3)*(&
&           (temp2-1.0)/10000000.0)+dl(5)*((temp4-1.0)/1000.0)+2.0)*LOG(&
&           10.0)*qs_ad
          tt_ad = (temp4*LOG(10.0)*dl(5)*dl(6)/1000.0+dl(4)*temp2*LOG(&
&           10.0)*dl(3)/(tt**2*10000000.0)+dl(2)/(tt*LOG(10.0))+dl(1))*&
&           temp_ad1
          ti_ad = -(ts*tt_ad/ti**2)
        END IF
      ELSE IF (branch .EQ. 2) THEN
        temp9 = cl(7)/ti
        temp5 = cl(6) + temp9 + cl(8)*ALOG(ti) + cl(9)*ti
        temp8 = cl(4)*(ti-cl(5))
        temp7 = TANH(temp8)
        temp6 = cl(1)/ti
        temp_ad2 = EXP(cl(0)+temp6+cl(2)*ALOG(ti)+cl(3)*ti+temp7*temp5)*&
&         qs_ad
        temp_ad3 = temp7*temp_ad2
        ti_ad = (cl(9)+cl(8)/ti-temp9/ti)*temp_ad3 + ((1.0-TANH(temp8)**&
&         2)*temp5*cl(4)+cl(3)+cl(2)/ti-temp6/ti)*temp_ad2
      ELSE
        ti_ad = 0.0_8
      END IF
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .NE. 1) tl_ad = tl_ad + ti_ad
      END IF
    END IF
  END SUBROUTINE QSATLQU0_ADM
!  Differentiation of qsatice0 in reverse (adjoint) mode (with options r8):
!   gradient     of useful results: dq qs
!   with respect to varying inputs: tl
  SUBROUTINE QSATICE0_ADM(tl, tl_ad, pl, dq, dq_ad, qs_ad)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl
    REAL :: tl_ad
    REAL, OPTIONAL, INTENT(IN) :: pl
    REAL, OPTIONAL :: dq
    REAL, OPTIONAL :: dq_ad
    REAL :: qs
    REAL :: qs_ad
    REAL :: ti, w
    REAL :: ti_ad, w_ad
    REAL :: dd
    REAL :: dd_ad
    REAL :: tt
    REAL :: tt_ad
    REAL :: ddq
    REAL :: ddq_ad
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC LOG
    INTRINSIC EXP
    INTRINSIC ALOG
    REAL :: temp
    REAL*8 :: temp0
    REAL*8 :: temp1
    REAL*8 :: temp_ad
    REAL*8 :: temp_ad0
    REAL*8 :: temp2
    REAL*8 :: temp3
    REAL*8 :: temp4
    REAL*8 :: temp5
    REAL*8 :: temp6
    REAL*8 :: temp7
    REAL*8 :: temp_ad1
    REAL*8 :: temp_ad2
    REAL*8 :: temp_ad3
    REAL*8 :: temp_ad4
    REAL*8 :: temp_ad5
    REAL*8 :: temp_ad6
    REAL*8 :: temp8
    REAL*8 :: temp9
    REAL*8 :: temp_ad7
    REAL*8 :: temp_ad8
    REAL*8 :: temp10
    REAL*8 :: temp11
    REAL*8 :: temp12
    REAL*8 :: temp13
    REAL*8 :: temp14
    REAL*8 :: temp15
    REAL*8 :: temp_ad9
    REAL*8 :: temp_ad10
    REAL*8 :: temp_ad11
    REAL*8 :: temp_ad12
    REAL*8 :: temp_ad13
    REAL*8 :: temp_ad14
    REAL*8 :: temp16
    REAL*8 :: temp17
    REAL*8 :: temp_ad15
    REAL*8 :: temp_ad16
    REAL*8 :: temp18
    REAL*8 :: temp_ad17
    REAL*8 :: temp19
    REAL*8 :: temp_ad18
    REAL*8 :: temp20
    REAL*8 :: temp21
    REAL*8 :: temp_ad19
    REAL*8 :: temp_ad20
    REAL*8 :: temp22
    REAL*8 :: temp23
    REAL*8 :: temp24
    REAL*8 :: temp25
    REAL*8 :: temp26
    REAL*8 :: temp27
    REAL*8 :: temp_ad21
    REAL*8 :: temp_ad22
    REAL*8 :: temp_ad23
    REAL*8 :: temp_ad24
    REAL*8 :: temp_ad25
    REAL*8 :: temp_ad26
    REAL*8 :: temp28
    REAL*8 :: temp29
    REAL*8 :: temp_ad27
    REAL*8 :: temp_ad28
    REAL*8 :: temp30
    REAL*8 :: temp31
    REAL*8 :: temp32
    REAL*8 :: temp33
    REAL*8 :: temp34
    REAL*8 :: temp35
    REAL*8 :: temp_ad29
    REAL*8 :: temp_ad30
    REAL*8 :: temp_ad31
    REAL*8 :: temp_ad32
    REAL*8 :: temp_ad33
    REAL*8 :: temp_ad34
    REAL*8 :: temp36
    REAL*8 :: temp37
    REAL*8 :: temp_ad35
    REAL*8 :: temp_ad36
    REAL*8 :: temp38
    REAL*8 :: temp_ad37
    REAL*8 :: temp39
    REAL*8 :: temp_ad38
    REAL :: temp40
    REAL :: temp_ad39
    INTEGER :: branch
    IF (utbl) THEN
      IF (tl .LE. tmintbl) THEN
        qs = estble(1)
        IF (PRESENT(dq)) THEN
          CALL PUSHCONTROL2B(0)
          ddq = 0.0
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
      ELSE IF (tl .GE. zeroc) THEN
        qs = estfrz
        IF (PRESENT(dq)) THEN
          CALL PUSHCONTROL2B(1)
          ddq = 0.0
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        tt = (tl-tmintbl)*degsubs + 1
        it = INT(tt)
        ddq = estble(it+1) - estble(it)
        qs = (tt-it)*ddq + estble(it)
        CALL PUSHCONTROL2B(2)
      END IF
      IF (PRESENT(pl)) THEN
        IF (pl .GT. qs) THEN
          dd = esfac/(pl-(1.0-esfac)*qs)
          IF (PRESENT(dq)) THEN
            dd_ad = pl*ddq*erfac*2*dd*dq_ad
          ELSE
            dd_ad = 0.0_8
          END IF
          temp = pl - (-esfac+1.0)*qs
          dd_ad = dd_ad + qs*qs_ad
          qs_ad = esfac*(1.0-esfac)*dd_ad/temp**2 + dd*qs_ad
        ELSE
          qs_ad = 0.0_8
        END IF
      END IF
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        tl_ad = 0.0_8
      ELSE IF (branch .EQ. 1) THEN
        tl_ad = 0.0_8
      ELSE
        tt_ad = ddq*qs_ad
        tl_ad = degsubs*tt_ad
      END IF
    ELSE
! Exact Formulation
      IF (tl .LT. tminice) THEN
        CALL PUSHCONTROL2B(0)
        ti = tminice
      ELSE IF (tl .GT. zeroc) THEN
        CALL PUSHCONTROL2B(1)
        ti = zeroc
      ELSE
        ti = tl
        CALL PUSHCONTROL2B(2)
      END IF
      IF (type .EQ. 1) THEN
! Use Starr formulation
        tt = ti - zeroc
        IF (tt .LT. tstarr1) THEN
          qs = tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+s11) + s10
          CALL PUSHCONTROL3B(0)
        ELSE IF (tt .GE. tstarr1 .AND. tt .LT. tstarr2) THEN
          w = (tstarr2-tt)/(tstarr2-tstarr1)
          qs = w*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+s11)+&
&           s10) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22&
&           )+s21)+s20)
          CALL PUSHCONTROL3B(1)
        ELSE IF (tt .GE. tstarr2 .AND. tt .LT. tstarr3) THEN
          qs = tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+s21) + s20
          CALL PUSHCONTROL3B(2)
        ELSE IF (tt .GE. tstarr3 .AND. tt .LT. tstarr4) THEN
          w = (tstarr4-tt)/(tstarr4-tstarr3)
          qs = w*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+s21)+&
&           s20) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2&
&           )+bi1)+bi0)
          CALL PUSHCONTROL3B(3)
        ELSE
          qs = tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2)+bi1) + bi0
          CALL PUSHCONTROL3B(4)
        END IF
      ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
        tt = zeroc/ti
        qs = di(0)*EXP(-(di(1)/tt+di(2)*LOG(tt)+di(3)*tt))
        CALL PUSHCONTROL3B(5)
      ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
        qs = EXP(ci(0) + ci(1)/ti + ci(2)*ALOG(ti) + ci(3)*ti)
        CALL PUSHCONTROL3B(6)
      ELSE
        CALL PUSHCONTROL3B(7)
      END IF
      IF (PRESENT(dq)) THEN
        IF (tl .LT. tminice) THEN
          ddq = 0.0
          CALL PUSHCONTROL3B(0)
        ELSE IF (tl .GT. zeroc) THEN
          ddq = 0.0
          CALL PUSHCONTROL3B(1)
        ELSE IF (pl .GT. qs) THEN
          dd = qs
          CALL PUSHREAL8(ti)
          ti = tl + delta_t
          IF (type .EQ. 1) THEN
! Use Starr formulation
            CALL PUSHREAL8(tt)
            tt = ti - zeroc
            IF (tt .LT. tstarr1) THEN
              qs = tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+s11) +&
&               s10
              CALL PUSHCONTROL3B(0)
            ELSE IF (tt .GE. tstarr1 .AND. tt .LT. tstarr2) THEN
              CALL PUSHREAL8(w)
              w = (tstarr2-tt)/(tstarr2-tstarr1)
              qs = w*(tt*(tt*(tt*(tt*(tt*(tt*s16+s15)+s14)+s13)+s12)+s11&
&               )+s10) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+&
&               s23)+s22)+s21)+s20)
              CALL PUSHCONTROL3B(1)
            ELSE IF (tt .GE. tstarr2 .AND. tt .LT. tstarr3) THEN
              qs = tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+s21) +&
&               s20
              CALL PUSHCONTROL3B(2)
            ELSE IF (tt .GE. tstarr3 .AND. tt .LT. tstarr4) THEN
              CALL PUSHREAL8(w)
              w = (tstarr4-tt)/(tstarr4-tstarr3)
              qs = w*(tt*(tt*(tt*(tt*(tt*(tt*s26+s25)+s24)+s23)+s22)+s21&
&               )+s20) + (1.-w)*(tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+&
&               bi3)+bi2)+bi1)+bi0)
              CALL PUSHCONTROL3B(3)
            ELSE
              qs = tt*(tt*(tt*(tt*(tt*(tt*bi6+bi5)+bi4)+bi3)+bi2)+bi1) +&
&               bi0
              CALL PUSHCONTROL3B(4)
            END IF
          ELSE IF (type .EQ. 2) THEN
!  Fit used in CAM.
            CALL PUSHREAL8(tt)
            tt = zeroc/ti
            qs = di(0)*EXP(-(di(1)/tt+di(2)*LOG(tt)+di(3)*tt))
            CALL PUSHCONTROL3B(5)
          ELSE IF (type .EQ. 3) THEN
!  Murphy and Koop (2005, QJRMS)
            qs = EXP(ci(0) + ci(1)/ti + ci(2)*ALOG(ti) + ci(3)*ti)
            CALL PUSHCONTROL3B(6)
          ELSE
            CALL PUSHCONTROL3B(7)
          END IF
          ddq = qs - dd
          qs = dd
          CALL PUSHCONTROL3B(2)
        ELSE
          CALL PUSHCONTROL3B(3)
        END IF
      ELSE
        CALL PUSHCONTROL3B(4)
      END IF
      IF (PRESENT(pl)) THEN
        IF (pl .GT. qs) THEN
          dd = esfac/(pl-(1.0-esfac)*qs)
          IF (PRESENT(dq)) THEN
            temp_ad39 = erfac*pl*dq_ad
            ddq_ad = dd**2*temp_ad39
            dd_ad = ddq*2*dd*temp_ad39
          ELSE
            dd_ad = 0.0_8
            ddq_ad = 0.0_8
          END IF
          temp40 = pl - (-esfac+1.0)*qs
          dd_ad = dd_ad + qs*qs_ad
          qs_ad = esfac*(1.0-esfac)*dd_ad/temp40**2 + dd*qs_ad
        ELSE
          qs_ad = 0.0_8
          ddq_ad = 0.0_8
        END IF
      ELSE IF (PRESENT(dq)) THEN
        ddq_ad = dq_ad/delta_t
      ELSE
        ddq_ad = 0.0_8
      END IF
      CALL POPCONTROL3B(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          tl_ad = 0.0_8
        ELSE
          tl_ad = 0.0_8
        END IF
      ELSE IF (branch .EQ. 2) THEN
        dd_ad = qs_ad - ddq_ad
        qs_ad = ddq_ad
        CALL POPCONTROL3B(branch)
        IF (branch .LT. 4) THEN
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              temp21 = s14 + tt*(s15+s16*tt)
              temp20 = s13 + tt*temp21
              temp_ad19 = tt**2*qs_ad
              temp_ad20 = tt*temp_ad19
              tt_ad = (tt**2*s16+tt*(s15+s16*tt)+temp21)*temp_ad20 + &
&               temp20*temp_ad19 + (2*(tt*(s12+tt*temp20))+s11)*qs_ad
            ELSE
              temp27 = s14 + tt*(s15+s16*tt)
              temp22 = s13 + tt*temp27
              temp26 = s11 + tt*(s12+tt*temp22)
              temp_ad21 = w*qs_ad
              temp_ad22 = tt**2*temp_ad21
              temp_ad23 = tt*temp_ad22
              temp25 = s24 + tt*(s25+s26*tt)
              temp23 = s23 + tt*temp25
              temp24 = s21 + tt*(s22+tt*temp23)
              temp_ad24 = (1.-w)*qs_ad
              temp_ad25 = tt**2*temp_ad24
              temp_ad26 = tt*temp_ad25
              w_ad = (s10-tt*temp24-s20+tt*temp26)*qs_ad
              tt_ad = (tt**2*s26+tt*(s25+s26*tt)+temp25)*temp_ad26 - &
&               w_ad/(tstarr2-tstarr1) + temp23*temp_ad25 + (tt*(s22+tt*&
&               temp23)+temp24)*temp_ad24 + (tt**2*s16+tt*(s15+s16*tt)+&
&               temp27)*temp_ad23 + temp22*temp_ad22 + (tt*(s12+tt*&
&               temp22)+temp26)*temp_ad21
              CALL POPREAL8(w)
            END IF
          ELSE IF (branch .EQ. 2) THEN
            temp29 = s24 + tt*(s25+s26*tt)
            temp28 = s23 + tt*temp29
            temp_ad27 = tt**2*qs_ad
            temp_ad28 = tt*temp_ad27
            tt_ad = (tt**2*s26+tt*(s25+s26*tt)+temp29)*temp_ad28 + &
&             temp28*temp_ad27 + (2*(tt*(s22+tt*temp28))+s21)*qs_ad
          ELSE
            temp35 = s24 + tt*(s25+s26*tt)
            temp30 = s23 + tt*temp35
            temp34 = s21 + tt*(s22+tt*temp30)
            temp_ad29 = w*qs_ad
            temp_ad30 = tt**2*temp_ad29
            temp_ad31 = tt*temp_ad30
            temp33 = bi4 + tt*(bi5+bi6*tt)
            temp31 = bi3 + tt*temp33
            temp32 = bi1 + tt*(bi2+tt*temp31)
            temp_ad32 = (1.-w)*qs_ad
            temp_ad33 = tt**2*temp_ad32
            temp_ad34 = tt*temp_ad33
            w_ad = (s20-tt*temp32-bi0+tt*temp34)*qs_ad
            tt_ad = (tt**2*bi6+tt*(bi5+bi6*tt)+temp33)*temp_ad34 - w_ad/&
&             (tstarr4-tstarr3) + temp31*temp_ad33 + (tt*(bi2+tt*temp31)&
&             +temp32)*temp_ad32 + (tt**2*s26+tt*(s25+s26*tt)+temp35)*&
&             temp_ad31 + temp30*temp_ad30 + (tt*(s22+tt*temp30)+temp34)&
&             *temp_ad29
            CALL POPREAL8(w)
          END IF
        ELSE IF (branch .LT. 6) THEN
          IF (branch .EQ. 4) THEN
            temp37 = bi4 + tt*(bi5+bi6*tt)
            temp36 = bi3 + tt*temp37
            temp_ad35 = tt**2*qs_ad
            temp_ad36 = tt*temp_ad35
            tt_ad = (tt**2*bi6+tt*(bi5+bi6*tt)+temp37)*temp_ad36 + &
&             temp36*temp_ad35 + (2*(tt*(bi2+tt*temp36))+bi1)*qs_ad
          ELSE
            temp38 = di(1)/tt
            temp_ad37 = di(0)*EXP(-temp38-di(2)*LOG(tt)-di(3)*tt)*qs_ad
            tt_ad = (temp38/tt-di(2)/tt-di(3))*temp_ad37
            CALL POPREAL8(tt)
            ti_ad = -(zeroc*tt_ad/ti**2)
            qs_ad = 0.0_8
            GOTO 100
          END IF
        ELSE
          IF (branch .EQ. 6) THEN
            temp39 = ci(1)/ti
            temp_ad38 = EXP(ci(0)+temp39+ci(2)*ALOG(ti)+ci(3)*ti)*qs_ad
            ti_ad = (ci(3)+ci(2)/ti-temp39/ti)*temp_ad38
            qs_ad = 0.0_8
          ELSE
            ti_ad = 0.0_8
          END IF
          GOTO 100
        END IF
        CALL POPREAL8(tt)
        ti_ad = tt_ad
        qs_ad = 0.0_8
 100    CALL POPREAL8(ti)
        tl_ad = ti_ad
        qs_ad = qs_ad + dd_ad
      ELSE IF (branch .EQ. 3) THEN
        tl_ad = 0.0_8
      ELSE
        tl_ad = 0.0_8
      END IF
      CALL POPCONTROL3B(branch)
      IF (branch .LT. 4) THEN
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) THEN
            temp1 = s14 + tt*(s15+s16*tt)
            temp0 = s13 + tt*temp1
            temp_ad = tt**2*qs_ad
            temp_ad0 = tt*temp_ad
            tt_ad = (tt**2*s16+tt*(s15+s16*tt)+temp1)*temp_ad0 + temp0*&
&             temp_ad + (2*(tt*(s12+tt*temp0))+s11)*qs_ad
          ELSE
            temp7 = s14 + tt*(s15+s16*tt)
            temp2 = s13 + tt*temp7
            temp6 = s11 + tt*(s12+tt*temp2)
            temp_ad1 = w*qs_ad
            temp_ad2 = tt**2*temp_ad1
            temp_ad3 = tt*temp_ad2
            temp5 = s24 + tt*(s25+s26*tt)
            temp3 = s23 + tt*temp5
            temp4 = s21 + tt*(s22+tt*temp3)
            temp_ad4 = (1.-w)*qs_ad
            temp_ad5 = tt**2*temp_ad4
            temp_ad6 = tt*temp_ad5
            w_ad = (s10-tt*temp4-s20+tt*temp6)*qs_ad
            tt_ad = (tt**2*s26+tt*(s25+s26*tt)+temp5)*temp_ad6 - w_ad/(&
&             tstarr2-tstarr1) + temp3*temp_ad5 + (tt*(s22+tt*temp3)+&
&             temp4)*temp_ad4 + (tt**2*s16+tt*(s15+s16*tt)+temp7)*&
&             temp_ad3 + temp2*temp_ad2 + (tt*(s12+tt*temp2)+temp6)*&
&             temp_ad1
          END IF
        ELSE IF (branch .EQ. 2) THEN
          temp9 = s24 + tt*(s25+s26*tt)
          temp8 = s23 + tt*temp9
          temp_ad7 = tt**2*qs_ad
          temp_ad8 = tt*temp_ad7
          tt_ad = (tt**2*s26+tt*(s25+s26*tt)+temp9)*temp_ad8 + temp8*&
&           temp_ad7 + (2*(tt*(s22+tt*temp8))+s21)*qs_ad
        ELSE
          temp15 = s24 + tt*(s25+s26*tt)
          temp10 = s23 + tt*temp15
          temp14 = s21 + tt*(s22+tt*temp10)
          temp_ad9 = w*qs_ad
          temp_ad10 = tt**2*temp_ad9
          temp_ad11 = tt*temp_ad10
          temp13 = bi4 + tt*(bi5+bi6*tt)
          temp11 = bi3 + tt*temp13
          temp12 = bi1 + tt*(bi2+tt*temp11)
          temp_ad12 = (1.-w)*qs_ad
          temp_ad13 = tt**2*temp_ad12
          temp_ad14 = tt*temp_ad13
          w_ad = (s20-tt*temp12-bi0+tt*temp14)*qs_ad
          tt_ad = (tt**2*bi6+tt*(bi5+bi6*tt)+temp13)*temp_ad14 - w_ad/(&
&           tstarr4-tstarr3) + temp11*temp_ad13 + (tt*(bi2+tt*temp11)+&
&           temp12)*temp_ad12 + (tt**2*s26+tt*(s25+s26*tt)+temp15)*&
&           temp_ad11 + temp10*temp_ad10 + (tt*(s22+tt*temp10)+temp14)*&
&           temp_ad9
        END IF
      ELSE IF (branch .LT. 6) THEN
        IF (branch .EQ. 4) THEN
          temp17 = bi4 + tt*(bi5+bi6*tt)
          temp16 = bi3 + tt*temp17
          temp_ad15 = tt**2*qs_ad
          temp_ad16 = tt*temp_ad15
          tt_ad = (tt**2*bi6+tt*(bi5+bi6*tt)+temp17)*temp_ad16 + temp16*&
&           temp_ad15 + (2*(tt*(bi2+tt*temp16))+bi1)*qs_ad
        ELSE
          tt = zeroc/ti
          temp18 = di(1)/tt
          temp_ad17 = di(0)*EXP(-temp18-di(2)*LOG(tt)-di(3)*tt)*qs_ad
          tt_ad = (temp18/tt-di(2)/tt-di(3))*temp_ad17
          ti_ad = -(zeroc*tt_ad/ti**2)
          GOTO 110
        END IF
      ELSE
        IF (branch .EQ. 6) THEN
          temp19 = ci(1)/ti
          temp_ad18 = EXP(ci(0)+temp19+ci(2)*ALOG(ti)+ci(3)*ti)*qs_ad
          ti_ad = (ci(3)+ci(2)/ti-temp19/ti)*temp_ad18
        ELSE
          ti_ad = 0.0_8
        END IF
        GOTO 110
      END IF
      ti_ad = tt_ad
 110  CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .NE. 1) tl_ad = tl_ad + ti_ad
      END IF
    END IF
  END SUBROUTINE QSATICE0_ADM
!=======================================================================================
!BOPI
! !IROUTINE: GEOS_DQsat -- Computes derivative satuation specific humidity wrt temperature.
! !INTERFACE:
!    function GEOS_DQsat(TL,PL,RAMP,PASCALS,QSAT) result(DQSAT)
!
! Overloads:
!
!      real,                               intent(IN)               :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real,                     optional, intent(OUT)              :: QSAT
!      real                                                         :: DQSAT
!
!      real, dimension(:),                 intent(IN)               :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real, dimension(:),       optional, intent(OUT)              :: QSAT
!      real, dimension(size(PL,1))                                  :: DQSAT
!
!      real, dimension(:,:),               intent(IN)               :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real, dimension(:,:),     optional, intent(OUT)              :: QSAT
!      real, dimension(size(PL,1),size(PL,2))                       :: DQSAT
!
!      real, dimension(:,:,:),             intent(IN)               :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real, dimension(:,:,:),   optional, intent(OUT)              :: QSAT
!      real, dimension(size(PL,1),size(PL,2),size(PL,3))            :: DQSAT
!
!      real, dimension(:,:,:,:),           intent(IN)               :: TL, PL
!      logical,                  optional, intent(IN)               :: PASCALS
!      real,                     optional, intent(IN)               :: RAMP
!      real, dimension(:,:,:,:), optional, intent(OUT)              :: QSAT
!      real, dimension(size(PL,1),size(PL,2),size(PL,3),size(PL,4)) :: DQSAT
! !DESCRIPTION:  Differentiates the approximations used
!                by GEOS_Qsat with respect to temperature,
!    using the same scheme to handle ice. Arguments are as in
!    GEOS_Qsat, with the addition of QSAT, which is the saturation specific
!    humidity. This is for economy, in case both qsat and dqsat are
!    required.
!
!EOPI
  FUNCTION DQSAT0(tl, pl, ramp, pascals, qsat) RESULT (DQSAT)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl, pl
    LOGICAL, OPTIONAL, INTENT(IN) :: pascals
    REAL, OPTIONAL, INTENT(IN) :: ramp
    REAL, OPTIONAL, INTENT(OUT) :: qsat
    REAL :: dqsat
    REAL :: uramp, tt, ww, dd, dqq, qq, ti, dqi, qi, pp
    INTEGER :: it
    INTRINSIC PRESENT
    INTRINSIC ABS
    INTRINSIC INT
    REAL :: abs0
    IF (PRESENT(ramp)) THEN
      IF (ramp .GE. 0.) THEN
        abs0 = ramp
      ELSE
        abs0 = -ramp
      END IF
      uramp = -abs0
    ELSE
      uramp = tmix
    END IF
    IF (PRESENT(pascals)) THEN
      IF (pascals) THEN
        pp = pl
      ELSE
        pp = pl*100.
      END IF
    ELSE
      pp = pl*100.
    END IF
    IF (uramp .EQ. tmix .OR. (uramp .EQ. 0. .AND. utbl)) THEN
      IF (first) THEN
        first = .false.
        CALL ESINIT()
      END IF
      IF (tl .LE. tmintbl) THEN
        ti = tmintbl
      ELSE IF (tl .GE. tmaxtbl - .001) THEN
        ti = tmaxtbl - .001
      ELSE
        ti = tl
      END IF
      tt = (ti-tmintbl)*degsubs + 1
      it = INT(tt)
      IF (uramp .EQ. tmix) THEN
        dqq = estblx(it+1) - estblx(it)
        qq = (tt-it)*dqq + estblx(it)
      ELSE
        dqq = estble(it+1) - estble(it)
        qq = (tt-it)*dqq + estble(it)
      END IF
      IF (pp .LE. qq) THEN
        IF (PRESENT(qsat)) qsat = max_mixing_ratio
        dqsat = 0.0
      ELSE
        dd = 1.0/(pp-(1.0-esfac)*qq)
        IF (PRESENT(qsat)) qsat = esfac*qq*dd
        dqsat = esfac*degsubs*dqq*pp*(dd*dd)
      END IF
    ELSE
      ti = tl - zeroc
      IF (ti .LE. uramp) THEN
        qq = QSATICE0(tl, pp, dqsat)
        IF (PRESENT(qsat)) qsat = qq
      ELSE IF (ti .GE. 0.0) THEN
        qq = QSATLQU0(tl, pp, dqsat)
        IF (PRESENT(qsat)) qsat = qq
      ELSE
        qq = QSATLQU0(tl, pp, dqq)
        qi = QSATICE0(tl, pp, dqi)
        ti = ti/uramp
        dqsat = ti*(dqi-dqq) + dqq
        IF (PRESENT(qsat)) qsat = ti*(qi-qq) + qq
      END IF
    END IF
  END FUNCTION DQSAT0
  FUNCTION DQSAT1(tl, pl, ramp, pascals, qsat) RESULT (DQSAT)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:), pl(:)
    LOGICAL, OPTIONAL, INTENT(IN) :: pascals
    REAL, OPTIONAL, INTENT(IN) :: ramp
    REAL, OPTIONAL, INTENT(OUT) :: qsat(:)
    REAL :: dqsat(SIZE(tl, 1))
    INTEGER :: i
    INTRINSIC PRESENT
    INTRINSIC SIZE
    DO i=1,SIZE(tl, 1)
      IF (PRESENT(qsat)) THEN
        dqsat(i) = DQSAT0(tl(i), pl(i), ramp, pascals, qsat(i))
      ELSE
        dqsat(i) = DQSAT0(tl(i), pl(i), ramp, pascals)
      END IF
    END DO
  END FUNCTION DQSAT1
  FUNCTION DQSAT2(tl, pl, ramp, pascals, qsat) RESULT (DQSAT)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:, :), pl(:, :)
    LOGICAL, OPTIONAL, INTENT(IN) :: pascals
    REAL, OPTIONAL, INTENT(IN) :: ramp
    REAL, OPTIONAL, INTENT(OUT) :: qsat(:, :)
    REAL :: dqsat(SIZE(tl, 1), SIZE(tl, 2))
    INTEGER :: i, j
    INTRINSIC PRESENT
    INTRINSIC SIZE
    DO j=1,SIZE(tl, 2)
      DO i=1,SIZE(tl, 1)
        IF (PRESENT(qsat)) THEN
          dqsat(i, j) = DQSAT0(tl(i, j), pl(i, j), ramp, pascals, qsat(i&
&           , j))
        ELSE
          dqsat(i, j) = DQSAT0(tl(i, j), pl(i, j), ramp, pascals)
        END IF
      END DO
    END DO
  END FUNCTION DQSAT2
  FUNCTION DQSAT3(tl, pl, ramp, pascals, qsat) RESULT (DQSAT)
    IMPLICIT NONE
    REAL, INTENT(IN) :: tl(:, :, :), pl(:, :, :)
    LOGICAL, OPTIONAL, INTENT(IN) :: pascals
    REAL, OPTIONAL, INTENT(IN) :: ramp
    REAL, OPTIONAL, INTENT(OUT) :: qsat(:, :, :)
    REAL :: dqsat(SIZE(tl, 1), SIZE(tl, 2), SIZE(tl, 3))
    INTEGER :: i, j, k
    INTRINSIC PRESENT
    INTRINSIC SIZE
    DO k=1,SIZE(tl, 3)
      DO j=1,SIZE(tl, 2)
        DO i=1,SIZE(tl, 1)
          IF (PRESENT(qsat)) THEN
            dqsat(i, j, k) = DQSAT0(tl(i, j, k), pl(i, j, k), ramp, &
&             pascals, qsat(i, j, k))
          ELSE
            dqsat(i, j, k) = DQSAT0(tl(i, j, k), pl(i, j, k), ramp, &
&             pascals)
          END IF
        END DO
      END DO
    END DO
  END FUNCTION DQSAT3
!==============================================
!BOPI
! !IROUTINE: GEOS_QsatSet -- Sets behavior of GEOS_QsatLqu an GEOS_QsatIce
! !INTERFACE:
  SUBROUTINE GEOS_QSATSET(usetable, formulation)
    IMPLICIT NONE
    LOGICAL, OPTIONAL, INTENT(IN) :: usetable
    INTEGER, OPTIONAL, INTENT(IN) :: formulation
    INTRINSIC PRESENT
    INTRINSIC MIN
    INTRINSIC MAX
    INTEGER :: x1
! !DESCRIPTION: GEOS_QsatSet can be used to modify
!  the behavior of GEOS_QsatLqu an GEOS_QsatIce
!  from its default setting.
!  If {\tt \bf USETABLE} is true, tabled values of the saturation vapor pressures are used.
!  These tables are automatically generated at a 0.1K resolution for whatever
!  vapor pressure formulation is being used. The default is to use the table.
!  {\tt \bf FORMULATION} sets the saturation vapor pressure function.
!  Three formulations of saturation vapor pressure are supported:
!  the Starr code that was in NSIPP-1 (FORMULATION==1), the formulation in  CAM
!  (FORMULATION==2), and Murphy and Koop (2005, QJRMS) (FORMULATION==3).
!  The default is FORMULATION=1.
!  If appropriate, GEOS_QsatSet also initializes the tables. If GEOS_QsatSet is
!  not called and tables are required, they will be initialized the first time
!  a Qsat function is called.
!EOPI
    IF (PRESENT(usetable)) utbl = usetable
    IF (PRESENT(formulation)) THEN
      IF (formulation .GT. 3) THEN
        x1 = 3
      ELSE
        x1 = formulation
      END IF
      IF (x1 .LT. 1) THEN
        type = 1
      ELSE
        type = x1
      END IF
    END IF
    IF (type .EQ. 3) THEN
      IF (tmintbl .LT. 110.) THEN
        tminice = 110.
      ELSE
        tminice = tmintbl
      END IF
      IF (tmintbl .LT. 123.) THEN
        tminlqu = 123.
      ELSE
        tminlqu = tmintbl
      END IF
    ELSE
      tminlqu = zeroc - 40.0
      tminice = zeroc + tminstr
    END IF
    IF (utbl) CALL ESINIT()
    RETURN
  END SUBROUTINE GEOS_QSATSET
!=======================================================================================
  SUBROUTINE ESINIT()
    IMPLICIT NONE
! Saturation vapor pressure table initialization. This is invoked if UTBL is true
! on the first call to any qsat routine or whenever GEOS_QsatSet is called
! N.B.--Tables are in Pa
    INTEGER :: i
    REAL :: t
    LOGICAL :: ut
    ut = utbl
    utbl = .false.
    DO i=1,tablesize
      t = (i-1)*delta_t + tmintbl
      estblw(i) = QSATLQU0(t)
      IF (t .GT. zeroc) THEN
        estble(i) = estblw(i)
      ELSE
        estble(i) = QSATICE0(t)
      END IF
      t = t - zeroc
      IF (t .GE. tmix .AND. t .LT. 0.0) THEN
        estblx(i) = t/tmix*(estble(i)-estblw(i)) + estblw(i)
      ELSE
        estblx(i) = estble(i)
      END IF
    END DO
    estfrz = QSATLQU0(zeroc)
    estlqu = QSATLQU0(tminlqu)
    utbl = ut
  END SUBROUTINE ESINIT
!*************************************************************************
!*************************************************************************
!  Tridiagonal solvers
!*************************************************************************
!*************************************************************************
!BOP
! !IROUTINE:  VTRISOLVE -- Solves for tridiagonal system that has been decomposed by VTRILU
! !INTERFACE:
!  subroutine GEOS_TRISOLVE ( A,B,C,Y,YG )
! !ARGUMENTS:
!    real, dimension([:,[:,]] :),  intent(IN   ) ::  A, B, C
!    real, dimension([:,[:,]] :),  intent(INOUT) ::  Y
!    real, dimension([:,[:,]] :),  intent(IN   ) ::  YG
! !DESCRIPTION: Solves tridiagonal system that has been LU decomposed
!   $LU x = f$. This is done by first solving $L g = f$ for $g$, and
!   then solving $U x = g$ for $x$. The solutions are:
! $$
! \begin{array}{rcl}
! g_1 & = & f_1, \\
! g_k & = & \makebox[2 in][l]{$f_k - g_{k-1} \hat{a}_{k}$,}  k=2, K, \\
! \end{array}
! $$
! and
! $$
! \begin{array}{rcl}
! x_K & = & g_K /\hat{b}_K, \\
! x_k & = & \makebox[2 in][l]{($g_k - c_k g_{k+1}) / \hat{b}_{k}$,}  k=K-1, 1 \\
! \end{array}
! $$
!
!  On input A contains the $\hat{a}_k$, the lower diagonal of $L$,
!   B contains the $1/\hat{b}_k$, inverse of the  main diagonal of $U$,
!   C contains the $c_k$, the upper diagonal of $U$. The forcing, $f_k$ is
!
!   It returns the
!   solution in the r.h.s input vector, Y. A has the multiplier from the
!   decomposition, B the
!   matrix (U), and C the upper diagonal of the original matrix and of U.
!   YG is the LM+1 (Ground) value of Y.
!EOP
!BOP
! !IROUTINE:  VTRILU --  Does LU decomposition of tridiagonal matrix.
! !INTERFACE:
!  subroutine GEOS_TRILU  ( A,B,C )
! !ARGUMENTS:
!    real, dimension ([:,[:,]] :), intent(IN   ) ::  C
!    real, dimension ([:,[:,]] :), intent(INOUT) ::  A, B
! !DESCRIPTION: {\tt VTRILU} performs an $LU$ decomposition on
! a tridiagonal matrix $M=LU$.
!
! $$
! M = \left( \begin{array}{ccccccc}
!      b_1 & c_1 & & & & & \\
!      a_2 & b_2 & c_2 & & & &  \\
!      &  \cdot& \cdot & \cdot & & &  \\
!      & & \cdot& \cdot & \cdot & &  \\
!      &&  & \cdot& \cdot & \cdot &  \\
!      &&&& a_{K-1} & b_{K-1} & c_{K-1}   \\
!      &&&&& a_{K} & b_{K}
!    \end{array} \right)
! $$
!
! $$
! \begin{array}{lr}
! L = \left( \begin{array}{ccccccc}
!      1 &&&&&& \\
!      \hat{a}_2 & 1 & &&&&  \\
!      &  \cdot& \cdot &  & & &  \\
!      & & \cdot& \cdot &  &&  \\
!      &&  & \cdot& \cdot &  &  \\
!      &&&& \hat{a}_{K-1} & 1 &   \\
!      &&&&& \hat{a}_{K} & 1
!    \end{array} \right)
! &
! U = \left( \begin{array}{ccccccc}
!      \hat{b}_1 & c_1 &&&&& \\
!       & \hat{b}_2 & c_2 &&&&  \\
!      &  & \cdot & \cdot & & &  \\
!      & & & \cdot & \cdot &&  \\
!      &&  & & \cdot & \cdot &  \\
!      &&&&  & \hat{b}_{K-1} & c_{K-1}   \\
!      &&&&&  & \hat{b}_{K}
!    \end{array} \right)
! \end{array}
! $$
!
! On input, A, B, and C contain, $a_k$, $b_k$, and $c_k$
! the lower, main, and upper diagonals of the matrix, respectively.
! On output, B contains $1/\hat{b}_k$, the inverse of the main diagonal of $U$,
! and A contains $\hat{a}_k$,
! the lower diagonal of $L$. C contains the upper diagonal of the original matrix and of $U$.
!
! The new diagonals $\hat{a}_k$ and $\hat{b}_k$ are:
! $$
! \begin{array}{rcl}
! \hat{b}_1 & = & b_1, \\
! \hat{a}_k & = & \makebox[2 in][l]{$a_k / \hat{b}_{k-1}$,}  k=2, K, \\
! \hat{b}_k & = & \makebox[2 in][l]{$b_k - c_{k-1} \hat{a}_k$,} k=2, K.
! \end{array}
! $$
!EOP
  SUBROUTINE GEOS_TRILU1(a, b, c)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: c
    REAL, DIMENSION(:), INTENT(INOUT) :: a, b
    INTEGER :: lm, l
    INTRINSIC SHAPE
    INTRINSIC SIZE
    lm = SIZE(a, SIZE(SHAPE(a)))
    b(1) = 1./b(1)
    DO l=2,lm
      a(l) = a(l)*b(l-1)
      b(l) = 1./(b(l)-c(l-1)*a(l))
    END DO
    RETURN
  END SUBROUTINE GEOS_TRILU1
  SUBROUTINE GEOS_TRISOLVE1(a, b, c, y, yg)
    IMPLICIT NONE
    REAL, DIMENSION(:), INTENT(IN) :: a, b, c
    REAL, DIMENSION(:), INTENT(INOUT) :: y
    REAL, DIMENSION(:), INTENT(IN) :: yg
    INTEGER :: lm, l
    INTRINSIC SHAPE
    INTRINSIC SIZE
    lm = SIZE(a, SIZE(SHAPE(a)))
! Sweep down, modifying rhs with multiplier A
    y(1) = y(1) - a(1)*yg(1)
    DO l=2,lm
      y(l) = y(l) - y(l-1)*a(l)
    END DO
! Sweep up, solving for updated value. Note B has the inverse of the main diagonal
    y(lm) = (y(lm)-c(lm)*yg(2))*b(lm)
    DO l=lm-1,1,-1
      y(l) = (y(l)-c(l)*y(l+1))*b(l)
    END DO
    RETURN
  END SUBROUTINE GEOS_TRISOLVE1
  SUBROUTINE GEOS_TRILU2(a, b, c)
    IMPLICIT NONE
    REAL, DIMENSION(:, :), INTENT(IN) :: c
    REAL, DIMENSION(:, :), INTENT(INOUT) :: a, b
    INTEGER :: lm, l
    INTRINSIC SHAPE
    INTRINSIC SIZE
    lm = SIZE(a, SIZE(SHAPE(a)))
    b(:, 1) = 1./b(:, 1)
    DO l=2,lm
      a(:, l) = a(:, l)*b(:, l-1)
      b(:, l) = 1./(b(:, l)-c(:, l-1)*a(:, l))
    END DO
    RETURN
  END SUBROUTINE GEOS_TRILU2
  SUBROUTINE GEOS_TRISOLVE2(a, b, c, y, yg)
    IMPLICIT NONE
    REAL, DIMENSION(:, :), INTENT(IN) :: a, b, c
    REAL, DIMENSION(:, :), INTENT(INOUT) :: y
    REAL, DIMENSION(:, :), INTENT(IN) :: yg
    INTEGER :: lm, l
    INTRINSIC SHAPE
    INTRINSIC SIZE
    lm = SIZE(a, SIZE(SHAPE(a)))
! Sweep down, modifying rhs with multiplier A
    y(:, 1) = y(:, 1) - a(:, 1)*yg(:, 1)
    DO l=2,lm
      y(:, l) = y(:, l) - y(:, l-1)*a(:, l)
    END DO
! Sweep up, solving for updated value. Note B has the inverse of the main diagonal
    y(:, lm) = (y(:, lm)-c(:, lm)*yg(:, 2))*b(:, lm)
    DO l=lm-1,1,-1
      y(:, l) = (y(:, l)-c(:, l)*y(:, l+1))*b(:, l)
    END DO
    RETURN
  END SUBROUTINE GEOS_TRISOLVE2
  SUBROUTINE GEOS_TRILU3(a, b, c)
    IMPLICIT NONE
    REAL, DIMENSION(:, :, :), INTENT(IN) :: c
    REAL, DIMENSION(:, :, :), INTENT(INOUT) :: a, b
    INTEGER :: lm, l
    INTRINSIC SHAPE
    INTRINSIC SIZE
    lm = SIZE(a, SIZE(SHAPE(a)))
    b(:, :, 1) = 1./b(:, :, 1)
    DO l=2,lm
      a(:, :, l) = a(:, :, l)*b(:, :, l-1)
      b(:, :, l) = 1./(b(:, :, l)-c(:, :, l-1)*a(:, :, l))
    END DO
    RETURN
  END SUBROUTINE GEOS_TRILU3
  SUBROUTINE GEOS_TRISOLVE3(a, b, c, y, yg)
    IMPLICIT NONE
    REAL, DIMENSION(:, :, :), INTENT(IN) :: a, b, c
    REAL, DIMENSION(:, :, :), INTENT(INOUT) :: y
    REAL, DIMENSION(:, :, :), INTENT(IN) :: yg
    INTEGER :: lm, l
    INTRINSIC SHAPE
    INTRINSIC SIZE
    lm = SIZE(a, SIZE(SHAPE(a)))
! Sweep down, modifying rhs with multiplier A
    y(:, :, 1) = y(:, :, 1) - a(:, :, 1)*yg(:, :, 1)
    DO l=2,lm
      y(:, :, l) = y(:, :, l) - y(:, :, l-1)*a(:, :, l)
    END DO
! Sweep up, solving for updated value. Note B has the inverse of the main diagonal
    y(:, :, lm) = (y(:, :, lm)-c(:, :, lm)*yg(:, :, 2))*b(:, :, lm)
    DO l=lm-1,1,-1
      y(:, :, l) = (y(:, :, l)-c(:, :, l)*y(:, :, l+1))*b(:, :, l)
    END DO
    RETURN
  END SUBROUTINE GEOS_TRISOLVE3
END MODULE GEOS_UTILSMOD_DIFF
