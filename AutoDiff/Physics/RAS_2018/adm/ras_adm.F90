!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.13 (r6666) - 27 Nov 2017 17:09
!
! $Id: ras.F90,v 1.29.20.1.28.2 2017/09/08 16:58:21 mathomp4 Exp $
MODULE RAS_DIFF
!   use ESMF
!   use GEOS_Mod
  USE GEOS_UTILSMOD_DIFF, ONLY : dqsat => geos_dqsat, dqsat_adm => &
& geos_dqsat_adm
!   use module_ras
!use aer_cloud, only: AerProps, getINsubset
  USE AER_CLOUD, ONLY : aerprops, getinsubset, init_aer
  USE RASPARAMS
  USE MAPL_CONSTANTSMOD
  IMPLICIT NONE
  PRIVATE 
  PUBLIC rase
  PUBLIC rase_adm
! -2
! -1
! 0
! 1
! 2
! 3
! 4
! 5
! 6
! 7
  CHARACTER(len=32), PARAMETER, PUBLIC :: rascodes(-2:7)=(/&
&   'Default                         ', &
&   'Invalid Code                    ', &
&   'Cloud detraining here is active ', &
&   'PBL h < layer''s h*              ', &
&   'No Valid lambda                 ', &
&   'Lambda out of bounds            ', &
&   'A < Acrit                       ', &
&   'Negative Kernel                 ', &
&   'Invalid Code                    ', &
&   'RH Trigger not met              '/)

CONTAINS
!!  RAS Relaxation Diagnostics
!!!!!AER_CLOUD
!DONIF
  SUBROUTINE RASE(idim, irun, k0, icmin, dt, cpo, alhlo, alhl1, tice, &
&   gravo, seedras, iras, jras, sige, kcbl, wgt0, wgt1, zcbl, mxdiam, &
&   tpert, qpert, tho, qho, uho, vho, qss, dqs, cnv_fraction, rasal2_2d&
&   , co_auto, pko, plo, phio, phie, qlo, qio, ple, pke, clw, flx, flxd&
&   , flxc, cnv_prc3, cnv_updfrc, cnv_cvw, cnv_qc, entlam, clan, hho, &
&   hso, precu, rasparams, ras_time, ras_trg, ras_toki, ras_pbl, ras_wfn&
&   , ras_alpha, ras_tau, aeroprops, cnv_fice, cnv_nice, cnv_ndrop, &
&   itrcr, irc, xho, triedlev_diag, fscav, disske)
    IMPLICIT NONE
! !!!!!!!!!!!!!!======================================
! !!!!!!!!!   Subroutine ARGact: finds the activated droplet number from Abdul_Razzak and Ghan 2000.
! ! Tailored for GOCART AEROSOL and works with AERO input
! !Written by Donifan Barahona
! !!donifan.o.barahona@nasa.gov
! !!!!!!!!!!!!!!====================================
! 
!       SUBROUTINE ARGact (TEMP, WX, NCPL_ACT, NCPL_AMB,  CDUST, CSOOT, LEV, ISBASE, DDUSTAMB, DSOOTAMB, ENT_PARAM)
! !
!          Integer, intent(in)     ::  LEV    
!          LOGICAL,  intent(in)     ::   ISBASE
! 
!          REAL, intent(inout)     ::   TEMP, WX, ENT_PARAM
!          REAL, intent(out)     ::   NCPL_ACT, NCPL_AMB, CSOOT, DSOOTAMB
!          REAL, DIMENSION(NDUSTMAX), INTENT(OUT) :: CDUST, DDUSTAMB
!          integer                 :: INDEX, NMODES, naux       
! 
!          type(AerProps)  :: AER, auxaer      
! 
! 
!          real     ::      kappa, alfa, beta, Akoh, G, T, smax, fi, gi, nui, &
!                        citai, ui, aux1, PACT,  Ntot, auxx, aux, auxconc, W, alph, aseasalt_aux, f_seasalt1
!          real, dimension (30) ::  SMI, TPI, SIGI 
! 
! 
!          SMI=0.0      
!          TPI = 0.0
!          SIGI =2.0
!          NCPL_ACT=0.0
!          NCPL_AMB=0.0
!          CDUST=0.0
!          CSOOT=0.0
!          DDUSTAMB =1.0e-9
!          DSOOTAMB= 1.0e-9
!          W=MIN(WX*(1.0-ENT_PARAM), 20.0)    
! 
!          PACT=0.0 !activation probability of entrained aerosol
! 
!          AER%nmods = 0
!          AER%num   = 0.0
! 
!          do INDEX = 1, AERO(LEV)%nmods
!              if (AERO(LEV)%num(INDEX) > 0.1) then
!                  AER%nmods = AER%nmods + 1
!                  naux = AER%nmods
! 
!                  AER%num(naux)   = AERO(LEV)%num(INDEX)
!                  AER%dpg(naux)   = max(AERO(LEV)%dpg(INDEX), 1.0e-9)
!                  AER%sig(naux)   = AERO(LEV)%sig(INDEX)
!                  AER%den(naux)   = AERO(LEV)%den(INDEX)
!                  AER%kap(naux)   = AERO(LEV)%kap(INDEX)
!                  AER%fdust(naux) = AERO(LEV)%fdust(INDEX)
!                  AER%fsoot(naux) = AERO(LEV)%fsoot(INDEX)
!                  AER%forg(naux)  = AERO(LEV)%forg(INDEX)
!              end if
!          end do
! 
!          if (AER%nmods == 0) then
!              call init_Aer(AER)
!          end if
! 
! !!!!!!!!!!activate aerosol transported from cloud base
!              NMODES =  AER_BASE%nmods
!              TPI(1:nmodes) = AER_BASE%num(1:nmodes)
!              SIGI(1:nmodes) = AER_BASE%sig(1:nmodes)                          
! 
!              
!              Ntot= 0.0
!               do index = 1, nmodes 
! 	              if (AER_BASE%kap(index) .gt. 0.1) Ntot =  Ntot + TPI(index)  
!               end do
!          
! 
!          if ((Ntot .lt. 1.0e4) .or. (TEMP .lt. 245.0) .or. (W .lt. 0.01)) then !no activation if aerosol < 1e-4 1/cm3
!             NCPL_ACT  = 0.0
!          else
! 
! ! Calculate constants. These fits were obtained from detailed correlations of physical properties. G is actually 1/G
!             T = min(max(TEMP, 243.0), 323.0)     
!             alfa=2.8915E-08*(T**2) - 2.1328E-05*T + 4.2523E-03
!             beta=exp(3.49996E-04*T**2 - 2.27938E-01*T + 4.20901E+01)
!             G=exp(-2.94362E-06*T**3 + 2.77941E-03*T**2 - 8.92889E-01*T + 1.18787E+02)
!             Akoh= 0.66e-6/T  !from Seinfeld and Pandis (1998)
!      
! !=======================================================
! !Activate droplets
! !=======================================================
! !Calculate maximum supersaturation according to ARG2002
! 
!             auxx=0.0 
!             
!             
!             DO INDEX = 1, NMODES            
!                 
!                kappa=  max(AER_BASE%kap(INDEX), 0.001)
!              
!                   SMI (INDEX) = ((0.667*Akoh/AER_BASE%dpg(INDEX))**1.5)/SQRT(2.0*kappa)   ! Critical supersat for mode I
!                   SMI=MAX(SMI, 1.0e-5)   
!                    
!               if ((TPI(INDEX) .gt. 1e4) .and.  (kappa .gt. 0.1)) then                       
!                   fi=0.5*exp(2.5*SIGI(INDEX)) !sigi is now log(sigi)
!                   gi=1.0+0.25*SIGI(INDEX)
!                   nui=((alfa*W*G)**1.5)/(2.0*MAPL_PI*980.0*beta*TPI(INDEX))
!                   citai = 0.667*Akoh*SQRT(alfa*W*G)
!                   aux1=fi*((citai/nui)**1.5) + gi*(SMI(INDEX)*SMI(INDEX)/(nui+(3.0*citai)))**0.75
!                   aux1=aux1/(SMI(INDEX)*SMI(INDEX))      
!                   auxx=auxx+aux1                  
!                 end if
!             end do
! 
! !Calculate number of activated droplets
!             if (auxx .gt. 0.0) then
!                smax = 1/sqrt(auxx)
!                auxx=0.0
! 
!                    DO INDEX = 1, NMODES
!                         if ((TPI(INDEX) .gt. 1e4) .and. (AER_BASE%kap(index) .gt. 0.1)) then
!                            ui=sqrt(2.0)*log(SMI(INDEX)/smax)/3.0
!                            aux1=0.5*TPI(INDEX)*(1.0-ERFAPP(ui))
!                            auxx=auxx+aux1
!                            AER_BASE%num(index) = max(TPI(INDEX) -aux1, 0.0) !remove already activated aerosol
!                         end if                    
!                    END DO
!                   NCPL_ACT=auxx             
!             else
!                   NCPL_ACT = 0.0             
!             end if
! 
!      
!  
!        end if
! 
! !now filllup dust and soot number
!          NMODES =  AER%nmods
! 
!          call getINsubset(1, AER,  auxaer)
!          CDUST(1:auxaer%nmods)= auxaer%num(1:auxaer%nmods)
!          DDUSTAMB(1:auxaer%nmods)= auxaer%dpg(1:auxaer%nmods)
!          call getINsubset(2, AER,  auxaer)
!          naux = max(auxaer%nmods, 1)
!          CSOOT= sum(auxaer%num) 
!          DSOOTAMB= sum(auxaer%dpg)/naux
! 
! 
!          PACT=1.0 ! fraction of entrained aerosol that is activated
!          auxconc =0.0
!          aseasalt_aux  = 0.0
! 
!          do index = 1, nmodes 
! 	       if (AER%kap(index) .gt. 0.8)  auxconc = AER%num(index) + auxconc
!            if (AER_BASE%kap(index) .gt. 0.8)    aseasalt_aux  = aseasalt_aux  + &
!            AER_BASE%num(index)*AER_BASE%dpg(index)*AER_BASE%dpg(index)*1.61*MAPL_PI !assumes a fixed sigma = 2.0
! 
!          end do
!        aseasalt = max(aseasalt, aseasalt_aux)
!      
! 	  NCPL_AMB=auxconc !Activate  entrained aerosol with kappa>0.8
! 
! 
! 
!       END SUBROUTINE ARGact
! 
! !!!!!!!!!!!!!!!!!!!!!!!!!!
! !=====Subroutine INfreezing=========
! ! Freeze droplets in immersion and contact ice nucleation modes, according to Barahona et al. GMD (2014)
! !!!!!!!!!!!!!!!!!!!!!
! 
!       subroutine INfreezing(QL, NL, NIN, NDUST, NSOOT, INDUST, INSOOT, TEMP, PRE, WSUB_, DDUST, DSOOT)  !NIN freezing tendency
!          REAL, INTENT( IN) :: TEMP, NSOOT, WSUB_, PRE, QL, NL, DSOOT
!          REAL, DIMENSION(NDUSTMAX), INTENT (IN) ::  NDUST, DDUST
!          REAL, DIMENSION(NDUSTMAX), INTENT (OUT) ::  INDUST
!          REAL, INTENT(OUT) ::  NIN, INSOOT 
!          REAL, DIMENSION(NDUSTMAX) ::  INDUST_C
! 
!          real :: a, b, c , d, Tx, n05, ui, aux, nssoot, nsdust, ninbkg, SI, acorr, &
!                dnsd, dnss, coolr, WSUB, ahet, INSOOT_C
! 
!          real :: nssoot_c, nsdust_c, mfp, nslip, ndfaer, viscosity, lam_r, taux, rho_a, &
!                 fdust_drop, fsoot_drop, min_ns_dust, min_ns_soot, nsss, INsea, dnsss, min_ns_seasalt 
! 
!          logical :: demott, Drop_mediated
!          integer :: ix
! 
!          min_ns_dust= 3.75e6 !limits ice nucleation to -12 !new 02/10/14
!          min_ns_soot= 3.75e9 !limits ice nucleation to -18
!          min_ns_seasalt = 4.0e2 !limits ice nucleation to -5
!          
!          demott=.false.
!          INDUST=0.0
!          INSOOT=0.0
!          INDUST_C=0.0
!          INSOOT_C=0.0   
!          NIN=0.0
!          Drop_mediated = .false.
!        INsea = 0.0 ! sea salt only in immersion
!    
!    
! ! note for sea salt we just assume that it is equal to the current droplet concentration and take the area 
! ! from the calculation at cloud base
! 
! ! fraction of dust and soot within droplets
!          fdust_drop= FDROP_DUST
!          fsoot_drop = FDROP_SOOT
! 
! 
!          WSUB=MAX(MIN(WSUB_, 10.0), 0.8)
!          coolr=5.0e-3*WSUB  !Approximation to saturated cooling rate
!          n05=sum(NDUST)+NSOOT
! 
!          if (TEMP .gt. T_ICE_MAX) then 
!             return
!          end if
! 
!          if (TEMP .lt. T_ICE_ALL   ) then 
!             return
!          end if
! 
! 
!          if ((QL .le. 1.0e-10) .or. (NL .le. 1.0)) then 
!             return
!          end if
! 
! !Background IN
! ! SI at water saturation
! 
!          rho_a = PRE*100.0/MAPL_RGAS/TEMP 
!          ninbkg=0.0
!          SI = -1.2379e-2+3.3595 !Ice supersat at water sat. Derived from Murphy and Koop 2005
! !if (TEMP .lt. 260.0)  ninbkg=coolr*42.8*exp(3.88*si)*0.1 !tendency in IN from background IN. Derived from Phillips et al. 2007
! 
! 
!          Tx = max(TEMP-273.16, -38.0 )
! 
!          lam_r=min((MAPL_PI*950.0*NL/rho_a/QL)**(1./3.), 1.0e8)
!          viscosity=1.8e-5*(TEMP/298.0)**0.85    ! Viscosity (kg/m/s)
!          mfp=2.0*viscosity/(PRE  &                   ! Mean free path (m)
!                *sqrt(8.0*28.96e-3/(MAPL_PI*8.314409*TEMP)))        
! 
!          if ((n05 .gt.1.0) .and. (TEMP .lt. 272.0)) then
! 
!             nsdust=  max(exp(-0.517*Tx + 8.934)-min_ns_dust, 0.0) !From Niemand 2012
!             nssoot= max(1.0e4*exp(-0.0101*Tx*Tx - 0.8525*Tx + 0.7667)-min_ns_soot, 0.0) !Murray (review_ 2012)
!             dnsd  = 0.517*nsdust
!             dnss  = max(-(-2.0*0.0101*Tx -0.8525)*nssoot, 0.0)
! 
! !ns in  contact. It is assumed that in contact is T-3 immersion
!             taux=max(Tx-3.0, -35.0)
!             nsdust_c= max(exp(-0.517*taux + 8.934)-min_ns_dust, 0.0) !From Niemand 2012
!             nssoot_c= max(1.0e4*exp(-0.0101*taux*taux - 0.8525*taux + 0.7667)-min_ns_soot, 0.0) !Murray (review_ 2012)
! 
!             aux=0.0        
!             acorr=2.7e7 !m2/m3 correction to the area due to non sphericity and aggregation. Assumes 10 m2/g (Murray 2011)
! 
! 
!             DO ix=1, NDUSTMAX
! !Immersion
!                ahet=0.52*DDUST(ix)*DDUST(ix)*DDUST(ix)*acorr*exp(4.5*log(2.0)*log(2.0)*log(2.0))    !this needs to be improved
! 
!                INDUST(ix) = NDUST(ix)*exp(-nsdust*ahet)* &
!                      dnsd*coolr*ahet*fdust_drop
! !Contact
!                nslip =1.0+(2.0*mfp/DDUST(ix))*(1.257+(0.4*exp(-(1.1*DDUST(ix)*0.5/mfp))))! Slip correction factor
!                ndfaer =1.381e-23*TEMP*nslip*(1.0-exp(-nsdust_c*ahet)) /(12.*MAPL_PI*viscosity*DDUST(ix))             
!                INDUST_C(ix) = 2.0*MAPL_PI*ndfaer*NDUST(ix)*NL/lam_r
! 
!             END DO
! 
! 
!             acorr=8.0e7 !m2/m3 correction to the area due to non sphericity and aggregation  Assumes 50 m2/g (Popovicheva 2003)
!             ahet =0.52*DSOOT*DSOOT*DSOOT*acorr*exp(4.5*log(2.0)*log(2.0)*log(2.0))             
!             INSOOT=fsoot_drop*NSOOT*exp(-nssoot*ahet)*dnss*ahet*coolr !
! 
!             nslip =1.0+(2.0*mfp/DSOOT)*(1.257+(0.4*exp(-(1.1*DSOOT*0.5/mfp))))! Slip correction factor
!             ndfaer =1.381e-23*TEMP*nslip*(1.0-exp(-nssoot_c*ahet)) /(12.*MAPL_PI*viscosity*DSOOT)             
!             INSOOT_c= 2.0*MAPL_PI*ndfaer*NSOOT*NL/lam_r
! 
! ! sea salt
!          nsss =  -0.459*TEMP +128.6235 ! from Demott et al. PNAS, 2015
!          nsss=  max(exp(nsss)-min_ns_seasalt, 0.0)           
!     	 dnsss=  max(0.459*nsss, 0.0)
!          INsea= aseasalt*dnsss*coolr 
! 
!  
!          end if
! 
! 	    NIN =ninbkg+ INSOOT + SUM(INDUST) + INSOOT_C + SUM(INDUST_C) + INsea!
!          INSOOT=INSOOT +INSOOT_C
!          INDUST =INDUST + INDUST_C
! 
! 	    
!       end subroutine INfreezing
! 
! 
! 
! 
! !!!!!!!!!!!!!!!!!!!!!!!!!!
! !===================Subroutine Qgrowth======================
! !Partitions water and ice according to Korolev and Mazin 2005. Assume spheres by now.
! !!!!!!!!!!!!!!!!!!!!
!       subroutine Qgrowth(TEMP, PRE, QICE0, NIPRE, QT, NINUC, DQIG, RIM, FNDRIM) 
! !freezing of IN according to Demott et al 2010 (everything SI)
!          REAL, INTENT(IN) :: TEMP, QICE0, NIPRE, NINUC,  PRE, QT
!          REAL, INTENT(INOUT) :: DQIG, RIM, FNDRIM
! 
! !real :: A, denI, aux, Dco, SI, denA, DQold, DQnew
!          real :: DIFF, DENICE, DENAIR, K1, K2, K3, SI, AUX, DC, TEFF, PLo, TEo, TC, &
!                DQnew, DQold, rho_a, LWC, IWC, qmin_rim
! 
! 
!          if (TEMP .gt. 272.15) then
!             DQIG =0.0
!             return
!          end if
! 
!          TC=TEMP-273.0 
!          PLo = max(PRE, 10.0) !limits  of the correlations
!          TEo = max(190.0, TEMP)
! 
!          qmin_rim = 1.0e-12
! 
! 
!          DENICE= 1000.0*(0.9167 - 1.75e-4*TC -5.0e-7*TC*TC) !From PK 97
!          DENAIR= PLo*100.0/MAPL_RGAS/TEMP
!          DIFF=(0.211*1013.25/(PLo+0.1))*(((TEo+0.1)/273.0)**1.94)*1e-4  !From Seinfeld and Pandis 2006
! 
!          K1 = EXP(7.1170e-4*TEo*TEo-0.43563*TEo+78.744) 
!          K2 = EXP(-9.933e-3*TEo+25.26)
!          K3 = EXP(7.1772e-4*TEo*TEo-0.44055*TEo+73.996)
! 
! 
!          AUX= 210368.0 + 131.438*TEMP - (3.32373E6/TEMP)- (41729.1*LOG(TEMP)) !From Murphy and Koop 2005
!          SI=exp(-aux/8.314/TEMP)-1.0 !ratio of pw/pi-1
!          rho_a = PRE*100.0/MAPL_RGAS/TEMP 
! 
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 
!          if  ((NIPRE .gt. 1.0) .and. (QICE0 .gt. 1.0e-10)) then 
!             DC=max((QICE0/(NIPRE*500.0*MAPL_PI))**(0.333), 40.0e-6) 
! !Assumme monodisperse size distribution about size distribution is made.
!          else   
!             DC = 40.0e-6
!          end if
! 
!          AUX=  NIPRE*DENICE*MAPL_PI*DC*DC
!          TEFF = DENAIR*2.0*((K1*DIFF+K2)*DC+(K3/0.1))
! 
!          if  (AUX .gt. 1.0e-12) then 
!             TEFF=min(TEFF/AUX, 1.0e20)   
!             DQold= SI/TEFF  
!          else
!             DQold=0.0
!          end if
! 
! ! Calculate rimming fraction
!          IWC =  QICE0*rho_a
!          LWC =  max(QT-QICE0, 0.0)*rho_a
!          aux = DQold ! only due to deposition
! 
! 
! !Account for rimming
! 
!          if ((LWC .gt. qmin_rim)  .and. (IWC .gt. qmin_rim))  then 
!             RIM = 6.0e-5/(LWC*(IWC**0.17)) !Fom Lin and Colle, NRW, 2011
!             RIM = 1.0/(1.0+RIM)
!             RIM  = min (0.95, RIM)
!             DQold =  DQold*(1 + RIM/(1.0-RIM))
!             FNDrim =  max(min(rho_a*(DQold -aux)/LWC, 1.0), 0.0) !Fraction of liquid condensate removed due to riming
!          END if
! 
! 
! 
! 
! !!!!!!!!!!!!!!!!!!!!!recently nucleated!!!!!!!!!!!!!!!!!!!!!!!!
! 
! 
!          AUX=  NINUC*DENICE*MAPL_PI*20.0e-6*20.0e-6
!          TEFF = DENAIR*2.0*((K1*DIFF+K2)*DC+(K3/0.1))
! 
!          if  (AUX .gt. 1.0e-12)  then 
!             TEFF=min(TEFF/AUX, 1.0e10)
!             DQnew= SI/TEFF
!          else
!             DQnew = 0.0
!          end if
! 
!          DQIG = DQold+DQnew     
! 
!       end subroutine Qgrowth
! 
! 
! 
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 
! !*************************************************************
! ! Function PDG07 (simplified background ice nucleation
! !                     spectra according to Phillips et. al. 2007).
! ! si is supersaturation wrt ice and T is in K
! !************************************************************
! 
!       subroutine PDG07_ice(si, Tx, N)     
! 
!          real, intent(in) :: si, Tx
!          real, intent(out)  :: N 
!          N=0.0
! 
! !if (Tx .le. 243.0)then
! 
! 
!          N=1000.0*exp(-0.388)*(exp(3.88*si)-1.0)/0.76
! !elseif (Tx .le. 260.0) then
! !  N=60.0*exp(-0.639)*(exp(12.96*si)-1.0)/0.76
! !end if
!       end subroutine PDG07_ice
! 
! 
! !*********************************************************************
! 
!*********************************************************************
!*********************************************************************
!******************** Relaxed Arakawa-Schubert ***********************
!************************ Parameterization ***************************
!********************** SCALAR RAS-1 VERSION  ************************
!************************* 31 DECEMBER 1999 **************************
!*********************************************************************
!************************** Developed By *****************************
!*********************************************************************
!************************ Shrinivas Moorthi **************************
!******************************* and *********************************
!************************** Max J. Suarez ****************************
!*********************************************************************
!******************** Laboratory for Atmospheres *********************
!****************** NASA/GSFC, Greenbelt, MD 20771 *******************
!*********************************************************************
!*********************************************************************
!  Input:
!  ------
!
!     K0      : Number of vertical levels (increasing downwards)
!
!     DT      : Time step in seconds
!
!     RASAL   : Array of dimension K-1 containing relaxation parameters
!               for cloud-types detraining at those levels
!
!     CPO     : Specific heat at constant pressure (J/kg/K)
!
!     ALHLO   : Latent Heat of condensation (J/kg)
!
!     ALHL1   : Latent Heat of condensation + fusion (J/kg)
!
!     GRAVO   : Acceleration due to gravity (m/s^2)
!
!     PLE     : 2D array of dimension (IDIM,K0+1) containing pressure
!               in hPa at the interfaces of K-layers from top of the
!               atmosphere to the bottom  (mb)
!
!     PKE     : 2D array of dimension (IDIM,K0+1) containing (PRS/P00) **
!               RKAP.  i.e. Exner function at layer edges.
!
!     PKL     : 2D array of dimension (IDIM,K0) ) containing the
!               Exner function at the layers.
!
!     QSS     : 2D array of dimension (IDIM,K0  ) containing the
!               saturation specific humidity at the layers. (kg/kg)
!
!     DQS     : 2D array of dimension (IDIM,K0  ) containing
!               d(qss)/dt at the layers.  (1/K)
!
!     CNV_FRACTION    : 1D array of dimension (IDIM) containing
!               fraction of grid cell considered to be convective
!
!  Update:
!  -------
!
!     THO     : 2D array of dimension (IDIM,K0) containing potential
!               temperature (K)
!
!     QHO     : 2D array of dimension (IDIM,K0) containing specific
!               humidity (kg/kg)
!
!     UHO     : 2D array of dimension (IDIM,K0) containing u-wind (m/s)
!
!     VHO     : 2D array of dimension (IDIM,K0) containing v-wind (m/s)
!
!  Output:
!  -------
!!
!     CLW     : 2D array of dimension (IDIM,K0) containing the
!               detrained cloud liquid water.  (kg/m^2/s)
!
!     FLX     : 2D array of dimension (IDIM,K0) containing the
!               cloud-base mass flux for each cloud type ordered by
!               detrainment level.   (kg/m^2/s)
!
!     FLXD    : 2D array of dimension (IDIM,K0) containing the
!               detrained  mass flux for each cloud type ordered by
!               detrainment level.   (kg/m^2/s)
!
!     FLXC    : 2D array of dimension (IDIM,K0+1) containing the
!               total cloud mass flux for all cloud types through
!               the top of each level. (e.g., FLXC(K)=SUM(FLX(ICMIN:K))
!               and  FLXD(L) = FLXC(L+1)-FLSD(L) )
!                (kg/m^2/s)
!
!     PRECU   : 1D (IDIM) Locally-handled convective precip
!               Zero if older version of RAS-1 is used. Nonzero if
!               RAS-2 is used.
!
!   AEROPROPS, Structure containing aerosol propoerties (in)
!   CNV_NICE, CNV_DROP.  Flux of ice crystals and droplet number at det level (1/m^2/s) (out)
!   CNV_FICE: Ice fraction in the detrained condensate (out)
!************************************************************************
!  ARGUMENTS
    INTEGER, INTENT(IN) :: idim, irun, k0, icmin
    REAL, DIMENSION(idim, k0), INTENT(INOUT) :: tho, qho, uho, vho, qlo&
&   , qio, clan
    REAL, DIMENSION(idim, k0+1), INTENT(IN) :: ple, pke, phie
    REAL, DIMENSION(idim, k0), INTENT(IN) :: qss, dqs, plo, pko, phio
    REAL, DIMENSION(idim), INTENT(IN) :: cnv_fraction, rasal2_2d
    REAL, DIMENSION(k0+1), INTENT(IN) :: sige
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: flx, clw, flxd
    REAL, DIMENSION(idim, k0+1), INTENT(OUT) :: flxc
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: cnv_prc3
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: cnv_updfrc, cnv_qc, &
&   cnv_cvw
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: entlam
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: hho, hso
    REAL, INTENT(IN) :: dt, cpo, alhlo, gravo
    REAL, INTENT(IN) :: alhl1, tice
    INTEGER, INTENT(IN) :: itrcr
    INTEGER, DIMENSION(idim, 2), INTENT(IN) :: seedras
    INTEGER, DIMENSION(idim), INTENT(IN) :: iras, jras, kcbl
    REAL, DIMENSION(idim), INTENT(IN) :: zcbl, tpert, qpert
    REAL, DIMENSION(idim), INTENT(IN) :: co_auto
    REAL, DIMENSION(idim), INTENT(OUT) :: mxdiam
    REAL, DIMENSION(idim), INTENT(OUT) :: precu
    REAL, DIMENSION(idim, k0), INTENT(IN) :: wgt0, wgt1
!     REAL, DIMENSION(:),          INTENT(IN   ) ::  RASPARAMS
    TYPE(RASPARAM_TYPE), INTENT(IN) :: rasparams
    REAL, DIMENSION(idim), INTENT(OUT) :: ras_time, ras_trg, ras_toki, &
&   ras_pbl, ras_wfn
    INTEGER, DIMENSION(idim, k0), INTENT(OUT) :: irc
    REAL, OPTIONAL, INTENT(INOUT) :: xho(idim, k0, itrcr)
    REAL, OPTIONAL, INTENT(OUT) :: triedlev_diag(idim, k0)
    REAL, OPTIONAL, INTENT(OUT) :: disske(idim, k0)
! Fraction scavenged per km
    REAL, OPTIONAL, INTENT(IN) :: fscav(itrcr)
! = 0 (no scav), = 1 (full scav)
!  LOCALS
    REAL, DIMENSION(k0) :: poi_sv, qoi_sv, uoi_sv, voi_sv
    REAL, DIMENSION(k0) :: poi, qoi, uoi, voi, dqq, bet, gam, cll
    REAL, DIMENSION(k0) :: poi_c, qoi_c
    REAL, DIMENSION(k0) :: prh, pri, ght, dpt, dpb, pki, dissk0, dissk1&
&   , clantnd
    REAL, DIMENSION(k0) :: tcu, qcu, ucu, vcu, cln, rns, pol, dm
    REAL, DIMENSION(k0) :: qst, ssl, rmf, rnn, rn1, rmfc, rmfp
    REAL, DIMENSION(k0) :: gms, eta, gmh, eht, gm1, hcc, rmfd
    REAL, DIMENSION(k0) :: hol, hst, qol, zol, hcld, cll0, cllx, clli, &
&   cllb
    REAL, DIMENSION(k0) :: wsp, lambdsv, bke, cvw, updfrc
    REAL, DIMENSION(k0) :: tau, rasal, mtkwi, updfrp, bk2, bk3, dll0, &
&   dllx
    REAL, DIMENSION(itrcr) :: xht
    REAL, DIMENSION(k0, itrcr) :: xoi, xcu, xoi_sv
    REAL, DIMENSION(k0+1) :: prj, prs, qht, sht, zet, xyd, xyd0
    INTEGER, DIMENSION(k0-1) :: rc
    INTEGER :: k, my_pe
    REAL, DIMENSION(idim, k0) :: lambdsv2
    REAL :: tx2, tx3, uht, vht, akm, acr, alm, tth, qqh, shtrg, wspbl, &
&   dqx
!, BKE
    REAL :: wfn, tem, trg, trgexp, evp, wlq, qcc, mtkw_max
    REAL :: shtrg_fac, sige_minhol, wfnog
    INTEGER :: i, ic, l, icl, itr, icl_c, n_dtl
    INTEGER :: ndtlexpon
    INTEGER, DIMENSION(:), ALLOCATABLE :: icl_v
!  RASE GLOBAL CONSTANTS
    REAL :: grav, cp, alhl, cpbg, alhi, cpi, gravi, ddt, lbcp, obg, afc
!!!!!!!!!
    REAL :: fricfac, dpth_bl, wupdrft, pblfrac, autorampb, co_zdep
    REAL :: rasal1, rasal2, rasal2i, co_t, rasncl, friclambda, sdqvt1, &
&   sdqv2
    REAL :: lambda_fac, strapping, acritfac, hmintrigger, lldisaggxp
    REAL :: lambmx_fac, diammn_min, rdtlexpon, cli_crit, sdqv3, &
&   maxdallowed_d, maxdallowed_s, maxdallowed_e
    REAL :: rhmn, rhmx, cldmicro, fdrop_dust, fdrop_soot, rasal_slope
    INTEGER :: kstrap
    REAL :: cld_radius, areal_frac, spect_mflx, cvw_cbase
!!!!!!!!!
    REAL, PARAMETER :: onepkap=1.+2./7., daylen=86400.0
!      REAL, PARAMETER :: PBLFRAC = 0.5
    REAL, PARAMETER :: rhmax=0.9999
!  LAMBDA LIMITS
    REAL :: lambda_min
    REAL :: lambda_max
!  TRIGGER PARAMETERS
! Density of liquid water in kg/m^3
    REAL, PARAMETER :: rho_w=1.0e3
    LOGICAL :: dyna_strapping, do_tracers, smooth_hst
!character(len=ESMF_MAXSTR)          :: CBL_STYLE
    REAL*8, DIMENSION(k0) :: tcu8, qcu8, pcu, flx8
    REAL*8, DIMENSION(k0, itrcr+2) :: rcu
!, dpd, tla
    REAL*8 :: cup
    LOGICAL :: revap, wrkfun, calkpb, crtfun, lprnt, dndrft
    REAL*8, DIMENSION(k0) :: toi8, qoi8, prsm8, phil8, qli8, qii8, &
&   trcfac
    REAL*8, DIMENSION(k0) :: alfind, alfint, alfinq, rhc_ls
    REAL*8, DIMENSION(k0+1) :: prs8, phih8
    REAL*8, DIMENSION(k0, itrcr+2) :: roi8
    REAL*8 :: fracbl, dt8, rasalf
    INTEGER :: kpbl
! no inhibition for =1.0
    REAL*8, SAVE :: max_neg_bouy=1.0
!!real*8 :: ALFINT = 0.5
!!real*8 :: ALFINQ = 0.5
! not used
    REAL*8, SAVE :: rhfacl=0.0
! no inhibition
    REAL*8, SAVE :: rhfacs=0.0
! 1 degree resolution
    REAL*8, SAVE :: garea=1.e10
!!real*8 :: ALFIND = 1.0
!!real*8 :: RHC_LS = 0.80
    REAL*8, SAVE :: dsfc=0.001
    REAL*8, SAVE :: cd=1.e-3
    REAL*8, SAVE :: wfnc=0.0
    REAL*8, SAVE :: tla=-1.0
    REAL*8, SAVE :: dpd=300.
!  SCAVANGING RELATED PARAMETERS
! layer thickness in km
    REAL :: delzkm
! fraction of tracer *not* scavenged
    REAL :: fnoscav
! Fraction scavenged per km
    REAL :: fscav_(itrcr)
! ************************AER_CLOUD *********************************************
!DONIF
    TYPE(AERPROPS), DIMENSION(idim, k0), INTENT(IN) :: aeroprops
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: cnv_ndrop, cnv_fice, &
&   cnv_nice
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: ras_tau, ras_alpha
!DONIF
    REAL, DIMENSION(k0) :: cnvndrop, cnvnice, cnvfice
!AEROSOL VERTICAl ARRAY FOR ALL SPECIES
    TYPE(AERPROPS), DIMENSION(k0) :: aero
    REAL :: t_ice_all, t_ice_max, aseasalt, f_seasalt
    INTEGER, PARAMETER :: ndustmax=10
    INTEGER :: index
    TYPE(AERPROPS) :: aeraux, aer_base
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC SQRT
    INTRINSIC SUM
    INTRINSIC ALLOCATED
    cnv_fice = 0.0
    cnv_ndrop = 0.0
    cnv_nice = 0.0
    cnvfice = 0.0
    cnvndrop = 0.0
    cnvnice = 0.0
    t_ice_all = 238.0
    t_ice_max = mapl_tice
    cldmicro = 0.0
    fdrop_dust = 0.1
    fdrop_soot = 0.01
    ras_alpha = 1.0e15
    ras_tau = 1.0e15
! *********************************************************************
    IF (PRESENT(fscav)) THEN
      fscav_ = fscav
    ELSE
! NO SCAVENGING BY DEFAULT
      fscav_ = 0.0
    END IF
    IF (irun .LE. 0) THEN
      RETURN
    ELSE
      IF (PRESENT(triedlev_diag)) triedlev_diag = 0.
      cnv_prc3 = 0.
      cnv_updfrc = 0.
      cnv_cvw = 0.
      cnv_qc = 0.
      entlam = 0.
      IF (PRESENT(disske)) disske = 0.
!!LAMBDSV2 = 0.
      irc = -2
!      SMOOTH_HST   = .TRUE.
      smooth_hst = .false.
      fricfac = rasparams%cufricfac
      shtrg_fac = rasparams%shr_lambda_fac
! MAT CO_AUTO is now passed in from outside
!     in order to allow this code to run over im*jm
!     columns
!CO_AUTO      = RASPARAMS(3)     !  ---  3
      cli_crit = rasparams%qc_crit_cn
      rasal1 = rasparams%rasal1
      rasal2 = rasparams%rasal2
      rasncl = rasparams%rasncl
      lambda_fac = rasparams%lambda_fac
      lambmx_fac = rasparams%lambmx_fac
      diammn_min = rasparams%min_diameter
      friclambda = rasparams%cufriclambda
      rdtlexpon = rasparams%rdtlexpon
      strapping = rasparams%strapping
      sdqv2 = rasparams%sdqv2
      sdqv3 = rasparams%sdqv3
      sdqvt1 = rasparams%sdqvt1
      acritfac = rasparams%acritfac
      hmintrigger = rasparams%hmintrigger
      lldisaggxp = rasparams%lldisaggxp
      pblfrac = rasparams%pblfrac
      autorampb = rasparams%rasautorampb
      co_zdep = rasparams%autoc_cn_zdep
      maxdallowed_s = rasparams%maxdallowed_s
      maxdallowed_d = rasparams%maxdallowed_d
      maxdallowed_e = rasparams%maxdallowed_e
      rasal_slope = rasparams%rasal_slope
      rhmn = rasparams%ras_rhmin
      rhmx = rasparams%ras_rhfull
      cldmicro = rasparams%cldmicro
      fdrop_dust = rasparams%fdrop_dust
      fdrop_soot = rasparams%fdrop_soot
      IF (strapping .LE. 0.0) THEN
        dyna_strapping = .true.
      ELSE
        dyna_strapping = .false.
        kstrap = INT(strapping)
      END IF
      do_tracers = PRESENT(xho) .AND. itrcr .GT. 0
      wupdrft = 2.500
      grav = gravo
      alhl = alhlo
      cp = cpo
      cpi = 1.0/cp
      alhi = 1.0/alhl
      gravi = 1.0/grav
      cpbg = cp*gravi
      ddt = daylen/dt
      afc = -(1.04e-4*SQRT(dt*113.84))
      lbcp = alhl*cpi
      obg = 100.*gravi
      hho = 1.0e15
      hso = 1.0e15
      DO i=1,irun
!===================AER_CLOUD
!            AERO =  AEROPROPS(I, :)
!            CNVFICE  =0.0
!            CNVNDROP =0.0
!            CNVNICE  =0.0
!!CALL FINDBASE
        k = kcbl(i)
        rc(icmin) = 0
        CALL FINDDTLS()
        IF (k .GT. 0) THEN
          CALL STRAP(0)
          CALL HTEST()
          hho(i, :) = hol
          hso(i, :) = hst
          tau = 0.0
          rasal = 0.0
          DO icl_c=1,n_dtl
            icl = icl_v(icl_c)
            IF (do_tracers) xcu(icmin:, :) = 0.
            IF (PRESENT(triedlev_diag)) triedlev_diag(i, icl) = 1.
! This change makes cumulus friction
            ucu(icmin:) = 0.
! correct.
            vcu(icmin:) = 0.
            IF (icl .GT. icmin) CALL CLOUDE(icl)
            entlam(i, icl) = alm
            ras_tau(i, icl) = tau(icl)
            ras_alpha(i, icl) = rasal(icl)
          END DO
          IF (SUM(rmf(icmin:k)) .GT. 0.0) THEN
            CALL RNEVP()
            CALL STRAP(1)
          ELSE
            CALL STRAP(2)
          END IF
        ELSE
          CALL STRAP(2)
        END IF
! Zero out precip - TBD w/ in progno_cloud
        precu = 0.0
      END DO
      IF (ALLOCATED(icl_v)) THEN
        DEALLOCATE(icl_v)
      END IF
      RETURN
    END IF

  CONTAINS
!*********************************************************************
    SUBROUTINE CLOUDE(ic)
      IMPLICIT NONE
!=======================================
      INTEGER, INTENT(IN) :: ic
      REAL :: deep_fact, cu_diam, wscale
!, dQx
      REAL :: cli, te_a, c00_x, cli_crit_x, pete, toki, gmhx, hstx
      REAL :: dt_lyr, rate, cvw_x, closs, f2, f3, f4, f5
      INTEGER :: k700
!=============================AER_CLOUD local variables ====================
      REAL :: wbase, ndrop, nice, fp_d, ff_a, fp_i, fice, ndrop_amb, &
&     nsoot_amb, nsoot, nin, insoot, dcvw2, qice, dqice, dqig, fpice, &
&     dnice, dndrop, dsoot_amb, dsoot, qliq, dqliq, fprecip, aux, qt, &
&     maxnice, maxndrop, minnice, minndrop, ndrop_act, rimm, fndrim, &
&     tminusta, tparcel, alph_e, beta_e, rh_amb, ecrit
      REAL, DIMENSION(ndustmax) :: ndust, ndust_amb, indust, ddust_amb, &
&     ddust
      INTEGER :: inx, naux, index
      INTRINSIC AMIN1
      INTRINSIC MAX
      INTRINSIC MIN
      INTRINSIC AMAX1
      INTRINSIC SQRT
      INTRINSIC EXP
      REAL :: min1
      REAL :: max1
      REAL :: min2
      REAL :: max2
      LOGICAL, DIMENSION(k-ic+1) :: mask
      REAL :: x4
      REAL :: x3
      REAL :: x2
      REAL :: x1
      REAL :: y1
!A little higher so there is ice at the freezing level
      t_ice_all = 238.0
      wbase = 1.0
      fice = 0.0
      nice = 0.0
      ndrop = 0.0
      ndrop_amb = 0.0
      ndrop_act = 0.0
      nin = 0.0
      ndust = 0.0
      nsoot = 0.0
      ndust_amb = 0.0
      nsoot_amb = 0.0
      dcvw2 = 0.0
      qice = 0.0
      qliq = 0.0
      fpice = 0.0
      indust = 0.0
      insoot = 0.0
      qt = 0.0
      fprecip = 0.0
      fndrim = 0.0
      rimm = 0.0
      tminusta = 0.0
      f_seasalt = 0.0
      aseasalt = 0.0
      CALL INIT_AER(aer_base)
!AER_CLOUD=============================
      alm = 0.
      IF (1. .GT. (qoi(k)/qst(k)-rhmn)/(rhmx-rhmn)) THEN
        trg = (qoi(k)/qst(k)-rhmn)/(rhmx-rhmn)
      ELSE
        trg = 1.
      END IF
      IF (0.0 .LT. (autorampb-sige(ic))/0.2) THEN
        y1 = (autorampb-sige(ic))/0.2
      ELSE
        y1 = 0.0
      END IF
      IF (1.0 .GT. y1) THEN
        f4 = y1
      ELSE
        f4 = 1.0
      END IF
! to 1 at SIG=AUTORAMPB-0.2
      IF (sige(ic) .GE. 0.5) THEN
        f5 = 1.0
      ELSE
        f5 = 1.0 - 2.*co_zdep*(0.5-sige(ic))
        IF (f5 .LT. 0.0) THEN
          f5 = 0.0
        ELSE
          f5 = f5
        END IF
      END IF
      IF (trg .LE. 1.0e-5) THEN
! TRIGGER  =========>>
        rc(ic) = 7
        RETURN
      ELSE
!  RECOMPUTE SOUNDING UP TO DETRAINMENT LEVEL
        poi_c = poi
        qoi_c = qoi
        poi_c(k) = poi_c(k) + tpert(i)
        qoi_c(k) = qoi_c(k) + qpert(i)
        zet(k+1) = 0.
        sht(k+1) = cp*poi_c(k)*prj(k+1)
        DO l=k,ic,-1
          IF (qst(l)*rhmax .GT. qoi_c(l)) THEN
            qol(l) = qoi_c(l)
          ELSE
            qol(l) = qst(l)*rhmax
          END IF
          IF (0.000 .LT. qol(l)) THEN
            qol(l) = qol(l)
          ELSE
            qol(l) = 0.000
          END IF
          ssl(l) = cp*prj(l+1)*poi_c(l) + grav*zet(l+1)
          hol(l) = ssl(l) + qol(l)*alhl
          hst(l) = ssl(l) + qst(l)*alhl
          tem = poi_c(l)*(prj(l+1)-prj(l))*cpbg
          zet(l) = zet(l+1) + tem
          zol(l) = zet(l+1) + (prj(l+1)-prh(l))*poi_c(l)*cpbg
        END DO
        DO l=ic+1,k
          tem = (prj(l)-prh(l-1))/(prh(l)-prh(l-1))
          sht(l) = ssl(l-1) + tem*(ssl(l)-ssl(l-1))
          qht(l) = .5*(qol(l)+qol(l-1))
        END DO
! SMOOTH HSTAR W/ 1-2-1 Filter
        IF (smooth_hst) THEN
! save for later
          hstx = hst(ic)
          DO l=k-1,ic+1,-1
            hst(l) = 0.25*(hst(l+1)+hst(l-1)) + 0.5*hst(l)
          END DO
          DO l=ic,ic
            hst(l) = 0.5*hst(l+1) + 0.5*hst(l)
          END DO
        END IF
!  CALCULATE LAMBDA, ETA, AND WORKFUNCTION
        lambda_min = .2/mxdiam(i)
        lambda_max = .2/diammn_min
!     LAMBDA_MIN = .2/(LAMBDA_FAC*DPTH_BL)
!     LAMBDA_MAX = .2/( MAX( LAMBMX_FAC*DPTH_BL , DIAMMN_MIN ) )
        IF (hol(k) .LE. hst(ic)) THEN
! CANNOT REACH IC LEVEL  ======>>
          rc(ic) = 1
          RETURN
        ELSE
!  LAMBDA CALCULATION: MS-A18
          tem = (hst(ic)-hol(ic))*(zol(ic)-zet(ic+1))
          DO l=ic+1,k-1
            tem = tem + (hst(ic)-hol(l))*(zet(l)-zet(l+1))
          END DO
          IF (tem .LE. 0.0) THEN
! NO VALID LAMBDA  ============>>
            rc(ic) = 2
            RETURN
          ELSE
            alm = (hol(k)-hst(ic))/tem
            IF (alm .GT. lambda_max) THEN
              rc(ic) = 3
              RETURN
            ELSE
!   ALPHA CALCULATION
              rasal2i = rasal2_2d(i)
              IF (zet(ic) .LT. 2000.) rasal(ic) = rasal1
              IF (zet(ic) .GE. 2000.) THEN
                IF (1.0 .GT. (zet(ic)-2000.)/rasal_slope) THEN
                  min1 = (zet(ic)-2000.)/rasal_slope
                ELSE
                  min1 = 1.0
                END IF
                rasal(ic) = rasal1 + (rasal2i-rasal1)*min1
              END IF
              rasal(ic) = dt/rasal(ic)
              IF (1.0 .GT. (alm/lambda_min)**2) THEN
                toki = (alm/lambda_min)**2
              ELSE
                toki = 1.0
              END IF
!   RAS relaxation timescale
              IF (k0 .GT. 96) THEN
!! AMM kluge to run 132 levels for now -- multiply time scale by ratio of number of levels
!! AMM between 900 and 30 mb in 72 and 132 level grids, 0.46
                tau(ic) = toki*trg*rasal(ic)*0.46
              ELSE
                tau(ic) = toki*trg*rasal(ic)
              END IF
!IF (TAU(IC) < 1.0E-5) THEN
!   RC(IC) = 6
!   RETURN
!ENDIF
!LAMBDSV(IC) = ALM
!  ETA CALCULATION: MS-A2
              DO l=ic+1,k
                eta(l) = 1.0 + alm*(zet(l)-zet(k))
              END DO
              eta(ic) = 1.0 + alm*(zol(ic)-zet(k))
!  WORKFUNCTION CALCULATION:  MS-A22
              wfn = 0.0
              hcc(k) = hol(k)
              DO l=k-1,ic+1,-1
                hcc(l) = hcc(l+1) + (eta(l)-eta(l+1))*hol(l)
                tem = hcc(l+1)*dpb(l) + hcc(l)*dpt(l)
                eht(l) = eta(l+1)*dpb(l) + eta(l)*dpt(l)
                wfn = wfn + (tem-eht(l)*hst(l))*gam(l)
              END DO
              hcc(ic) = hst(ic)*eta(ic)
              wfn = wfn + (hcc(ic+1)-hst(ic)*eta(ic+1))*gam(ic)*dpb(ic)
!  VERTICAL VELOCITY/KE CALCULATION (ADDED 12/2001 JTB)
              bk3(k) = 0.0
              bk2(k) = 0.0
              bke(k) = 0.0
              hcld(k) = hol(k)
              DO l=k-1,ic,-1
                hcld(l) = (eta(l+1)*hcld(l+1)+(eta(l)-eta(l+1))*hol(l))/&
&                 eta(l)
                tem = (hcld(l)-hst(l))*(zet(l)-zet(l+1))/(1.0+lbcp*dqq(l&
&                 ))
                IF (cldmicro .LE. 0.0) THEN
                  bke(l) = bke(l+1) + grav*tem/(cp*prj(l+1)*poi(l))
                  IF (tem .LT. 0.0) THEN
                    max1 = 0.0
                  ELSE
                    max1 = tem
                  END IF
                  bk2(l) = bk2(l+1) + grav*max1/(cp*prj(l+1)*poi(l))
                  IF (tem .GT. 0.0) THEN
                    min2 = 0.0
                  ELSE
                    min2 = tem
                  END IF
                  bk3(l) = bk3(l+1) + grav*min2/(cp*prj(l+1)*poi(l))
                  IF (bk2(l) .LT. 0.0) THEN
                    max2 = 0.0
                  ELSE
                    max2 = bk2(l)
                  END IF
                  cvw(l) = SQRT(2.0*max2)
                END IF
              END DO
              mask(1:k-ic+1) = cvw(ic:k) .LT. 1.00
              WHERE (mask(1:k-ic+1)) 
                cvw(ic:k) = 1.00
              ELSEWHERE
                cvw(ic:k) = cvw(ic:k)
              END WHERE
!  NOTE THIS "CENTRALIZES" A KLUGE PRESENT IN OTHER LOCATIONS.
!  CLEAN UP SOME TIME.      -JTB 12/04/03
!  TEST FOR CRITICAL WORK FUNCTION
              CALL ACRITN(pol(ic), prs(k), acr)
              IF (wfn .LE. acr) THEN
! SUB-CRITICAL WORK FUNCTION ======>>
                rc(ic) = 4
                RETURN
              ELSE
!  CLOUD TOP WATER AND MOMENTUM (TIMES ETA(IC)) MS-A16
! Tracer scavenging
! RAS loops over a series of plumes all having common cloud base level K
! and different detrainment levels IC.  The plumes operate sequentially
! on the grid box mean quantities (wind, moisture, tracer) and so each
! subsequent plume is seeing the effects of previous plumes.  We parameterize
! scavenging following Liu et al. [JGR, 2001], their equation 1:
!  AEROSOL FRACTION SCAVENGED = 1 - exp(-FSCAV*DZ)
! where FSCAV is a specified scavenging efficiency [km-1] and DZ is the
! distance [km] the tracer traverses in the plume from its entrainment
! level to its detrainment level.  We write the aerosol fraction surviving as:
!  FNOSCAV = exp(- FSCAV_(ITR) * DZ)
! The total scavenging is proportional to the convective mass flux, which
! is not explicitly solved for at this point.
                IF (do_tracers) THEN
                  DO itr=1,itrcr
!           Scavenging of the below cloud tracer
                    delzkm = (zet(ic)-zet(k))/1000.
                    x3 = EXP(-(fscav_(itr)*delzkm))
                    IF (x3 .GT. 1.) THEN
                      x1 = 1.
                    ELSE
                      x1 = x3
                    END IF
                    IF (x1 .LT. 0.) THEN
                      fnoscav = 0.
                    ELSE
                      fnoscav = x1
                    END IF
                    xht(itr) = xoi(k, itr)*fnoscav
                  END DO
                END IF
                wlq = qol(k)
                uht = uoi(k)
                vht = voi(k)
                rnn(k) = 0.
                cll0(k) = 0.
!print *, '========================================='
                DO l=k-1,ic,-1
                  tem = eta(l) - eta(l+1)
                  wlq = wlq + tem*qol(l)
                  uht = uht + tem*uoi(l)
                  vht = vht + tem*voi(l)
                  IF (do_tracers) THEN
                    DO itr=1,itrcr
!         Scavenging of the entrained tracer.  Updates transported tracer mass.
                      delzkm = (zet(ic)-zet(l+1))/1000.
                      x4 = EXP(-(fscav_(itr)*delzkm))
                      IF (x4 .GT. 1.) THEN
                        x2 = 1.
                      ELSE
                        x2 = x4
                      END IF
                      IF (x2 .LT. 0.) THEN
                        fnoscav = 0.
                      ELSE
                        fnoscav = x2
                      END IF
                      xht(itr) = xht(itr) + tem*xoi(l, itr)*fnoscav
                    END DO
                  END IF
!!!! How much condensate (CLI) is present here?
                  IF (l .GT. ic) THEN
                    tx2 = 0.5*(qst(l)+qst(l-1))*eta(l)
                    tx3 = 0.5*(hst(l)+hst(l-1))*eta(l)
                    qcc = tx2 + gm1(l)*(hcc(l)-tx3)
                    cll0(l) = wlq - qcc
                  ELSE
                    cll0(l) = wlq - qst(ic)*eta(ic)
                  END IF
                  IF (cll0(l) .LT. 0.00) THEN
                    cll0(l) = 0.00
                  ELSE
                    cll0(l) = cll0(l)
                  END IF
! condensate (kg/kg)
                  cli = cll0(l)/eta(l)
! Temperature (K)
                  te_a = poi(l)*prh(l)
!=====================================================================
!            if (CLDMICRO .gt. 0.0) then  !AER_CLOUD MIcrophysics considering activation and nucleation
!recompute vertical velocity
!
!               Tparcel = TE_A
!               CVW(K) = 0.8  ! Assume a below cloud base  W of 0.8 m s-1
!               BK2(K)   = 0.0
!
!     
!               TEM     = (HCLD(L)-HST(L) )/ (1.0+LBCP*DQQ(L))  
!               TminusTa = max(min(TEM/CP, 5.0), 0.0) !limit DT to 5 K. According to Wei, JAS, 1998
!	     TEM =0.33*TminusTa*CO_AUTO(I)/TE_A !Bouyancy term, effciency =0.5 mwr Roode et al
!
!               BK2(L)  = BK2(L+1) + GRAV * TEM*(ZET(L)-ZET(L+1)) 
!               BK2(L) = BK2(L) - (ZET(L)-ZET(L+1))*(BK2(L+1)*ALM + CLI*GRAV)  !Account for drag from entrainment of stagnat air 
!and condesate loading
!               CVW(L) = max(SQRT(  2.0* MAX( BK2(L) , 0.0 )  ), 1.0) 
!
!
!	    CVW_X = MIN(CVW(L), 50.0)
!               DT_LYR  =  max(( ZET(L)-ZET(L+1) )/CVW_X, 1.0) !Sanity check
!               TEM   = ETA(L) - ETA(L+1)
!
!               Tparcel  =  TE_A + TminusTa
!
!
!
!!!!!!!!!!account for entrainment effects on activation !!!!!!!!!!!
!! Barahona and Nenes, JGR, 2007
!               alph_e = 2.8915e-8*Tparcel*Tparcel -2.1328e-5*Tparcel+4.2523e-3
!               beta_e = MAPL_ALHL*TminusTa/MAPL_RVAP/Tparcel/Tparcel
!               RH_AMB=QOI(L)/QST(L)
!               ECRIT  = max(1.0-RH_AMB -beta_e, 1.0e-6) 
!               ECRIT =  alph_e/ECRIT
!! print *, L, Tparcel, RH_AMB, ECRIT, ALM
!	           ECRIT =  ALM/ECRIT
!!Print *, ECRIT
!
!
!               if (L .eq. K-1) then
!
!                  FICE=0.0
!                  NICE=0.0
!                  NDROP=0.0
!                  NIN =0.0
!                  NDUST_AMB =0.0
!                  NSOOT_AMB = 0.0
!                  NSOOT=0.0
!                  NDUST= 0.0
!                  RATE=0.0
!                  FPRECIP=0.0
!
!                  AER_BASE%nmods = 0
!                  AER_BASE%num   = 0.0
!                  do INDEX = 1, AERO(L)%nmods
!                      if (AERO(L)%num(INDEX) > 0.1) then
!                          AER_BASE%nmods = AER_BASE%nmods + 1
!                          naux = AER_BASE%nmods
!
!                          AER_BASE%num(naux)   = AERO(L)%num(INDEX)
!                          AER_BASE%dpg(naux)   = max(AERO(L)%dpg(INDEX), 1.0e-9)
!                          AER_BASE%sig(naux)   = AERO(L)%sig(INDEX)
!                          AER_BASE%den(naux)   = AERO(L)%den(INDEX)
!                          AER_BASE%kap(naux)   = AERO(L)%kap(INDEX)
!                          AER_BASE%fdust(naux) = AERO(L)%fdust(INDEX)
!                          AER_BASE%fsoot(naux) = AERO(L)%fsoot(INDEX)
!                          AER_BASE%forg(naux)  = AERO(L)%forg(INDEX)
!                      end if
!                  end do
!
!!initial conditions
!                  call ARGact(Tparcel, CVW_X, NDROP_ACT, NDROP_AMB, NDUST_AMB, NSOOT_AMB, L,  .true., DDUST_AMB, DSOOT_AMB, ECRI
!T) !cloud droplet number and INsource at cloud base
!                  NDUST=NDUST_AMB
!                  NSOOT=NSOOT_AMB
!                  DDUST=DDUST_AMB
!                  DSOOT=DSOOT_AMB                                     
!
!               else 
!                  call ARGact(Tparcel, CVW_X, NDROP_ACT, NDROP_AMB, NDUST_AMB, NSOOT_AMB, L, .false., DDUST_AMB, DSOOT_AMB, ECRI
!T) !cloud droplet number above cloud base
!
!               end if
!
!               QT = CLI
!               RATE = 0.0
!               FPRECIP = 0.0
!
!               if (QT .gt. 0.0) then
!
!! if FICE is already >= 1.0 then the cloud is glaciated and there is no need to do anymore partitioning
!
!                  if (FICE .ge. 1.0) then
!
!
!                     CALL  Qremoval(RATE, FICE, FP_D, FP_I, Tparcel,  & 
!                           POL(L), QT,  NICE, NDROP, CVW_X, FPICE, &
!                           DT_LYR, RIMM, CO_AUTO(I)) 
!
!
!
!                     dNICE = -NICE*FP_I 
!                     NICE  =  (NICE +dNICE*DT_LYR)*ETA(L+1)/ETA(L) !ice
!
!                     MINNICE = max(QICE*(1.0-RATE*DT_LYR), 0.0)/4.0e-8!assuming maximum vol radius 250 microns
!                     MAXNICE = max(QICE*(1.0-RATE*DT_LYR), 0.0)/2.51e-12 !assuming minimum vol radius 10 microns
!
!                     NICE=MIN(max(NICE, MINNICE), MAXNICE)
!
!                     FICE = 1.0
!
!                  else 
!
!! Cloud is not completely glaciated do the whole thing
!! ALL these subroutines return tendencies
!
!
!                     CALL  INfreezing(QLIQ, NDROP, NIN, NDUST, NSOOT, INDUST, INSOOT, Tparcel, POL(L), CVW_X, DDUST, DSOOT)  !ca
!lculate the freezing fraction of the aerosol at this level
!
!                     NIN = min(NIN, NDROP/DT_LYR)
!
!                     call Qgrowth(Tparcel, POL(L), QICE, NICE, QT, NIN, dQIG, RIMM, FNDRIM)
!
!                     CALL  Qremoval(RATE, FICE, FP_D, FP_I, Tparcel,  & 
!                           POL(L), QT,  NICE, NDROP, CVW_X, FPICE, &
!                           DT_LYR,  RIMM, CO_AUTO(I)) 
!
!
!
!!ice number tendency: -precip + freezin
!                     dNICE = -NICE*FP_I  + NIN     
!                     NICE  =  (NICE +dNICE*DT_LYR)*ETA(L+1)/ETA(L) !ice
!                     NICE =max(NICE, 0.0)
!
!
!!ice mass tendency: growth - precip
!                     dQICE = -QICE*FPICE + dQIG
!                     QICE  =  min((QICE + dQICE*DT_LYR)*ETA(L+1)/ETA(L), QT) !ice
!                     QICE=max(min(QT, QICE), 0.0)
!
!
!! Liquid Tendency: source/evap -  precip
!!dQLIQ = max((CLI-QICE), -QLIQ)/DT_LYR -QLIQ*max(RATE-FPICE, 0.0)
!! dQLIQ = CLI*(1.0-RATE*DT_LYR)/DT_LYR -dQICE - QLIQ*max(RATE-FPICE, 0.0)
!!QLIQ  =  max((QLIQ + dQLIQ*DT_LYR)*ETA(L+1)/ETA(L), 0.0) !liquid. This is actually diagnostic
!                     QLIQ=max((QT-QICE), 0.0)
!
!
!!droplet number tendency: -precip - freezin + activation + activated entrained aerosol
!
!
!                     dNDROP =-NDROP*FP_D - NIN -  FNDRIM*NDROP/DT_LYR + max(NDROP_ACT-NDROP, 0.0)/DT_LYR          
!
!!dNDROP =-NDROP*FP_D - NIN -  FNDRIM*NDROP/DT_LYR + NDROP_ACT/DT_LYR
!
!                     NDROP =  (NDROP + dNDROP*DT_LYR)*ETA(L+1)/ETA(L) + &
!                           (ZET(L) - ZET(L+1))*ALM*MAX((NDROP_AMB-NDROP), 0.0)
!
!!Aerosol tendency: Entrainment - freezing
!
!                     NDUST = (NDUST - INDUST*DT_LYR)*ETA(L+1)/ETA(L) + &
!                           (ZET(L) - ZET(L+1))*ALM*MAX(NDUST_AMB-NDUST, 0.0) 
!
!                     NSOOT =  (NSOOT - INSOOT*DT_LYR)*ETA(L+1)/ETA(L)  + &     
!                           (ZET(L) - ZET(L+1))*ALM*MAX(NSOOT_AMB-NSOOT, 0.0)  
!
!
!                           
!!Update FICE and perform Sanity checks
!
!
!                     MINNDROP = (1.0-FICE)*QLIQ*max(1.0-RATE*DT_LYR, 0.0)/2.e-10    !assuming maximum vol radius 36 microns
!                     MAXNDROP = (1.0-FICE)*QLIQ*max(1.0-RATE*DT_LYR, 0.0)/3.35e-14 !assuming minimum vol radius 2 microns
!                     MINNICE = QICE/4.0e-8!assuming maximum vol radius 250 microns
!                     MAXNICE = QICE/2.51e-12 !assuming minimum vol radius 10 microns
!
!                     IF ((NICE .gt. MAXNICE) .or. (NICE .lt. MINNICE))   then    
!!print *, 'nilim', NICE*1e-6, MINNICE*1e-6, MAXNICE*1e-6
!                     END IF
!
!                     IF ((NDROP .gt. MAXNDROP) .or. (NDROP .lt. MINNDROP))      then 
!!print *, 'ndroplim', NDROP*1e-6, MINNDROP*1e-6, MAXNDROP*1e-6
!                     end if
!
!
!                     NSOOT=MAX(NSOOT, 0.0)
!                     NDUST=MAX(NDUST, 0.0)              
!
!                     NDROP=MIN(max(NDROP, MINNDROP), MAXNDROP)
!                     NICE=MIN(max(NICE, MINNICE), MAXNICE)
!
!                     FICE=max(min(QICE/QT, 1.0), 0.0)
!
!                     IF (FICE .ge. 1.0) THEN !Complete glaciation
!                        NICE=NICE+NDROP 
!                        NDROP = 0.0
!                        QICE  = QT
!                        QLIQ= 0.0
!                     END IF
!
!                     IF (Tparcel .LT. T_ICE_ALL) THEN !instantaneous freezing
!                        NICE=NICE+NDROP 
!                        NDROP = 0.0
!                        FICE  = 1.0
!                        QICE  = QT
!                        QLIQ=0.0
!                     END IF
!
!                     IF (Tparcel .GT. T_ICE_MAX) THEN !instantaneous melting
!                        NDROP=NICE+NDROP 
!                        NICE = 0.0
!                        FICE  = 0.0
!                        QICE  = 0.0
!                        QLIQ=QT
!                     END IF
!
!                  END IF
!
!               else 
!
!                  FICE =0.0 
!                  QICE = 0.0
!                  QLIQ = 0.0
!                  NICE= 0.0 
!                  NDROP = 0.0
!                  RATE =0.0
!               end if
!
!               FPRECIP= RATE*DT_LYR
!
!!RATE=RATE*F4
!! NDROP=NDROP*F4
!!NICE=NICE*(1.0-F4)
!
!!print *, TE_A, FICE, 'NICE', NICE*1e-6, 'NDROP', NDROP*1e-6, L
!!print *, 'FPI', FP_I*DT_LYR, 'FPD', FP_D*DT_LYR, 'FPICE', FPICE, 'FPRE', FPRECIP, QT, QLIQ
!
!            else !Bacmeister 2006 microphysics
                  CALL SUNDQ3_ICE(te_a, sdqv2, sdqv3, sdqvt1, f2, f3)
! * F5  ! F4 reduces AUTO for shallow clouds, F5 modifies auto for deep clouds
                  c00_x = co_auto(i)*f2*f3*f4
                  cli_crit_x = cli_crit/(f2*f3)
                  rate = c00_x*(1.0-EXP(-(cli**2/cli_crit_x**2)))
                  IF (cvw(l) .LT. 1.00) THEN
                    cvw_x = 1.00
                  ELSE
                    cvw_x = cvw(l)
                  END IF
! really trust it at low values
! l.h.s. DT_LYR => time in layer (L,L+1)
                  dt_lyr = (zet(l)-zet(l+1))/cvw_x
                  closs = cll0(l)*rate*dt_lyr
                  IF (closs .GT. cll0(l)) THEN
                    closs = cll0(l)
                  ELSE
                    closs = closs
                  END IF
                  cll0(l) = cll0(l) - closs
                  dll0(l) = closs
                  IF (closs .GT. 0.) THEN
                    wlq = wlq - closs
                    rnn(l) = closs
                  ELSE
                    rnn(l) = 0.
                  END IF
                END DO
!AER_CLOUD=======================================
!            CNVNDROP(IC)=NDROP
!            CNVNICE(IC)=NICE
!            CNVFICE(IC)=FICE
                wlq = wlq - qst(ic)*eta(ic)
!     CALCULATE GAMMAS AND KERNEL
! MS-A30 (W/O GRAV)
                gms(k) = (sht(k)-ssl(k))*pri(k)
! MS-A31 (W/O GRAV)
                gmh(k) = gms(k) + (qht(k)-qol(k))*pri(k)*alhl
! MS-A37 (W/O GRAV)
                akm = gmh(k)*gam(k-1)*dpb(k-1)
                tx2 = gmh(k)
                DO l=k-1,ic+1,-1
                  gms(l) = (eta(l)*(sht(l)-ssl(l))+eta(l+1)*(ssl(l)-sht(&
&                   l+1)))*pri(l)
                  gmh(l) = gms(l) + (eta(l)*(qht(l)-qol(l))+eta(l+1)*(&
&                   qol(l)-qht(l+1)))*alhl*pri(l)
                  tx2 = tx2 + (eta(l)-eta(l+1))*gmh(l)
                  akm = akm - gms(l)*eht(l)*pki(l) + tx2*ght(l)
                END DO
                gms(ic) = eta(ic+1)*(ssl(ic)-sht(ic+1))*pri(ic)
                akm = akm - gms(ic)*eta(ic+1)*dpb(ic)*pki(ic)
                gmh(ic) = gms(ic) + (eta(ic+1)*(qol(ic)-qht(ic+1))*alhl+&
&                 eta(ic)*(hst(ic)-hol(ic)))*pri(ic)
                IF (smooth_hst) gmhx = gms(ic) + (eta(ic+1)*(qol(ic)-qht&
&                   (ic+1))*alhl+eta(ic)*(hstx-hol(ic)))*pri(ic)
!    CLOUD BASE MASS FLUX
                IF (akm .GE. 0.0 .OR. wlq .LT. 0.0) THEN
!  =========>
                  rc(ic) = 5
                  RETURN
                ELSE
! MS-A39 MASS-FLUX IN Pa/step
                  wfn = -((wfn-acr)/akm)
! WMP Store the full mass-flux to use in efficiency diagnostic
                  ras_wfn(i) = wfn
                  IF (tau(ic)*wfn .GT. (prs(k+1)-prs(k))*(100.*pblfrac)&
&                 ) THEN
                    wfn = (prs(k+1)-prs(k))*(100.*pblfrac)
                  ELSE
                    wfn = tau(ic)*wfn
                  END IF
!! WMP RAS DIAGNOSTICS that make up TAU(IC)
! Fill the RAS timescale diagnostic
                  ras_time(i) = rasal(ic)
! Fill the RAS RH trigger diagnostic
                  ras_trg(i) = trg
! Fill the RAS Tokioka diagnostic
                  ras_toki(i) = toki
! Fill the RAS PBL fraction diagnostic
                  ras_pbl(i) = (prs(k+1)-prs(k))*(100.*pblfrac)
! Fill the RAS efficiency diagnostic
! RAS_EFFICIENCY(I) = WFN/RAS_EFFICIENCY(I)
!! WMP RAS DIAGNOSTICS
!    CUMULATIVE PRECIP AND CLOUD-BASE MASS FLUX FOR OUTPUT
                  wfnog = wfn*gravi
                  tem = wfn*gravi
! (kg/m^2/step)
                  cll(ic) = cll(ic) + wlq*tem
! (kg/m^2/step)
                  rmf(ic) = rmf(ic) + tem
! (kg/m^2/step)
                  rmfd(ic) = rmfd(ic) + tem*eta(ic)
                  DO l=ic+1,k
! (kg/m^2/step)
                    rmfp(l) = tem*eta(l)
! (kg/m^2/step)
                    rmfc(l) = rmfc(l) + rmfp(l)
                    dllx(l) = dllx(l) + tem*dll0(l)
                    IF (cvw(l) .GT. 0.0) THEN
                      updfrp(l) = rmfp(l)*(ddt/daylen)*1000./(cvw(l)*prs&
&                       (l))
                    ELSE
                      updfrp(l) = 0.0
                    END IF
! current cloud; incloud condensate
                    clli(l) = cll0(l)/eta(l)
!  cumulative grid mean convective condensate
                    cllb(l) = cllb(l) + updfrp(l)*clli(l)
                    updfrc(l) = updfrc(l) + updfrp(l)
                  END DO
!    THETA AND Q CHANGE DUE TO CLOUD TYPE IC
                  DO l=ic,k
! (kg/m^2/step)
                    rns(l) = rns(l) + rnn(l)*tem
                    gmh(l) = gmh(l)*wfn
                    gms(l) = gms(l)*wfn
                    qoi(l) = qoi(l) + (gmh(l)-gms(l))*alhi
                    poi(l) = poi(l) + gms(l)*pki(l)*cpi
                    qst(l) = qst(l) + gms(l)*bet(l)*cpi
                  END DO
                  IF (smooth_hst) THEN
                    gmhx = gmhx*wfn
                    dqx = (gmhx-gmh(ic))*alhi
                    rns(ic) = rns(ic) + dqx/(pri(ic)*grav)
                  END IF
                  IF (do_tracers) THEN
!*FRICFAC*0.5
                    wfn = wfn*0.5*1.0
                    tem = wfn*pri(k)
                    DO itr=1,itrcr
                      xcu(k, itr) = xcu(k, itr) + tem*(xoi(k-1, itr)-xoi&
&                       (k, itr))
                    END DO
                    DO itr=1,itrcr
                      DO l=k-1,ic+1,-1
                        tem = wfn*pri(l)
                        xcu(l, itr) = xcu(l, itr) + tem*((xoi(l-1, itr)-&
&                         xoi(l, itr))*eta(l)+(xoi(l, itr)-xoi(l+1, itr)&
&                         )*eta(l+1))
                      END DO
                    END DO
                    tem = wfn*pri(ic)
                    DO itr=1,itrcr
                      xcu(ic, itr) = xcu(ic, itr) + (2.*(xht(itr)-xoi(ic&
&                       , itr)*(eta(ic)-eta(ic+1)))-(xoi(ic, itr)+xoi(ic&
&                       +1, itr))*eta(ic+1))*tem
                    END DO
                    DO itr=1,itrcr
                      DO l=ic,k
                        xoi(l, itr) = xoi(l, itr) + xcu(l, itr)
                      END DO
                    END DO
                  ELSE
!*FRICFAC*0.5
                    wfn = wfn*0.5*1.0
                  END IF
                  lambdsv(ic) = 1.000
!   CUMULUS FRICTION
                  IF (fricfac .LE. 0.0) THEN
                    rc(ic) = 0
!  NO CUMULUS FRICTION =========>>
                    RETURN
                  ELSE
                    wfn = wfn*fricfac*EXP(-(alm/friclambda))
                    tem = wfn*pri(k)
                    ucu(k) = ucu(k) + tem*(uoi(k-1)-uoi(k))
                    vcu(k) = vcu(k) + tem*(voi(k-1)-voi(k))
                    DO l=k-1,ic+1,-1
                      tem = wfn*pri(l)
                      ucu(l) = ucu(l) + tem*((uoi(l-1)-uoi(l))*eta(l)+(&
&                       uoi(l)-uoi(l+1))*eta(l+1))
                      vcu(l) = vcu(l) + tem*((voi(l-1)-voi(l))*eta(l)+(&
&                       voi(l)-voi(l+1))*eta(l+1))
                    END DO
                    tem = wfn*pri(ic)
                    ucu(ic) = ucu(ic) + (2.*(uht-uoi(ic)*(eta(ic)-eta(ic&
&                     +1)))-(uoi(ic)+uoi(ic+1))*eta(ic+1))*tem
                    vcu(ic) = vcu(ic) + (2.*(vht-voi(ic)*(eta(ic)-eta(ic&
&                     +1)))-(voi(ic)+voi(ic+1))*eta(ic+1))*tem
                    dissk0(ic) = eta(ic)*grav*wfnog*pri(ic)*0.5*((uht/&
&                     eta(ic)-uoi(ic))**2+(vht/eta(ic)-voi(ic))**2)
                    DO l=ic,k
                      uoi(l) = uoi(l) + ucu(l)
                      voi(l) = voi(l) + vcu(l)
                    END DO
                    rc(ic) = 0
                    RETURN
                  END IF
                END IF
              END IF
            END IF
          END IF
        END IF
      END IF
    END SUBROUTINE CLOUDE
    SUBROUTINE ACRITN(pl, plb, acr)
      IMPLICIT NONE
      REAL, INTENT(IN) :: pl, plb
      REAL, INTENT(OUT) :: acr
      INTEGER :: iwk
!!REAL, PARAMETER :: FACM=0.5
      REAL, PARAMETER :: ph(15)=(/150.0, 200.0, 250.0, 300.0, 350.0, &
&       400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, &
&       850.0/)
!!*FACM
      REAL, PARAMETER :: a(15)=(/1.6851, 1.1686, 0.7663, 0.5255, 0.4100&
&       , 0.3677, 0.3151, 0.2216, 0.1521, 0.1082, 0.0750, 0.0664, 0.0553&
&       , 0.0445, 0.0633/)
      INTRINSIC INT
      iwk = INT(pl*0.02 - 0.999999999)
      IF (iwk .GT. 1 .AND. iwk .LE. 15) THEN
        acr = a(iwk-1) + (pl-ph(iwk-1))*.02*(a(iwk)-a(iwk-1))
      ELSE IF (iwk .GT. 15) THEN
        acr = a(15)
      ELSE
        acr = a(1)
      END IF
      acr = acritfac*acr*(plb-pl)
      RETURN
    END SUBROUTINE ACRITN
    SUBROUTINE RNEVP()
      IMPLICIT NONE
      zet(k+1) = 0
      DO l=k,icmin,-1
        tem = poi(l)*(prj(l+1)-prj(l))*cpbg
        zet(l) = zet(l+1) + tem
      END DO
      DO l=icmin,k
        tem = pri(l)*grav
        cnv_prc3(i, l) = rns(l)*tem
      END DO
!! If hst is smoothed then adjusted precips may be negative
      IF (smooth_hst) THEN
        DO l=icmin,k
          IF (cnv_prc3(i, l) .LT. 0.) THEN
            qoi(l) = qoi(l) + cnv_prc3(i, l)
            poi(l) = poi(l) - cnv_prc3(i, l)*(alhl/cp)/prj(l+1)
            cnv_prc3(i, l) = 0.
          END IF
        END DO
      END IF
      RETURN
    END SUBROUTINE RNEVP
    SUBROUTINE HTEST()
      IMPLICIT NONE
      REAL, DIMENSION(k0) :: hol1
      INTEGER :: lminhol
      REAL :: minhol
      INTRINSIC AMIN1
      INTRINSIC AMAX1
! HOL initialized here in order not to confuse Valgrind debugger
      hol = 0.
      lminhol = k + 1
      minhol = -999999.
      zet(k+1) = 0
      sht(k+1) = cp*poi(k)*prj(k+1)
      DO l=k,icmin,-1
        IF (qst(l)*rhmax .GT. qoi(l)) THEN
          qol(l) = qoi(l)
        ELSE
          qol(l) = qst(l)*rhmax
        END IF
        IF (0.000 .LT. qol(l)) THEN
          qol(l) = qol(l)
        ELSE
          qol(l) = 0.000
        END IF
        ssl(l) = cp*prj(l+1)*poi(l) + grav*zet(l+1)
        hol(l) = ssl(l) + qol(l)*alhl
        hst(l) = ssl(l) + qst(l)*alhl
        tem = poi(l)*(prj(l+1)-prj(l))*cpbg
        zet(l) = zet(l+1) + tem
        zol(l) = zet(l+1) + (prj(l+1)-prh(l))*poi(l)*cpbg
      END DO
      hol1 = hol
      DO l=k-1,icmin+1,-1
        hol1(l) = 0.25*hol(l+1) + 0.50*hol(l) + 0.25*hol(l-1)
        IF (minhol .GE. hol1(l) .OR. minhol .LT. 0.) THEN
          minhol = hol1(l)
          lminhol = l
        END IF
      END DO
      sige_minhol = sige(lminhol)
    END SUBROUTINE HTEST
    SUBROUTINE FINDDTLS()
      IMPLICIT NONE
      REAL :: sigdt0, sigmax, sigmin
      INTEGER :: ll
      INTEGER, ALLOCATABLE :: the_seed(:)
      INTEGER :: seed_len
      INTRINSIC RANDOM_SEED
      INTRINSIC INT
      INTRINSIC MIN
      INTRINSIC ALLOCATED
      INTRINSIC RANDOM_NUMBER
      INTEGER :: x1
      seed_len = 0
      CALL RANDOM_SEED(size=seed_len)
      ALLOCATE(the_seed(seed_len))
      the_seed(1) = seedras(i, 1)*iras(i) + seedras(i, 2)*jras(i)
      the_seed(2) = seedras(i, 1)*jras(i) + seedras(i, 2)*iras(i)
      the_seed(1) = the_seed(1)*seedras(i, 1)/(seedras(i, 2)+10)
      the_seed(2) = the_seed(2)*seedras(i, 1)/(seedras(i, 2)+10)
      IF (the_seed(1) .EQ. 0) the_seed(1) = 5
      IF (the_seed(2) .EQ. 0) the_seed(2) = -5
! Gfortran uses longer seeds, so fill the rest with zero
      IF (seed_len .GT. 2) the_seed(3:) = 0
      CALL RANDOM_SEED(put=the_seed)
      sigmax = sige(k)
      sigmin = sige(icmin)
      IF (rasncl .LT. 0.0) THEN
!! NO SHALLOW CONV   N_DTL = 56 - ICMIN
        n_dtl = k - icmin
      ELSE
        x1 = INT(rasncl)
        IF (x1 .GT. k - icmin) THEN
          n_dtl = k - icmin
        ELSE
          n_dtl = x1
        END IF
      END IF
      IF (ALLOCATED(icl_v)) THEN
        DEALLOCATE(icl_v)
      END IF
      ALLOCATE(icl_v(n_dtl))
      IF (rasncl .LT. 0.0 .AND. rasncl .GE. -100.) THEN
        DO l=1,n_dtl
          icl_v(l) = icmin + l - 1
        END DO
      ELSE IF (rasncl .LT. -100.0) THEN
        DO l=1,n_dtl
          icl_v(l) = k - l
        END DO
      ELSE
!! NO SHALLOW CONV           ICL_V(L) = 56 - L
        DO l=1,n_dtl
          CALL RANDOM_NUMBER(sigdt0)
          sigdt0 = 1.00 - sigdt0**rdtlexpon
          sigdt0 = sigmin + sigdt0*(sigmax-sigmin)
          DO ll=icmin,k
            IF (sige(ll+1) .GE. sigdt0 .AND. sige(ll) .LT. sigdt0) icl_v&
&             (l) = ll
          END DO
        END DO
      END IF
      DEALLOCATE(the_seed)
    END SUBROUTINE FINDDTLS
    SUBROUTINE STRAP(final)
      IMPLICIT NONE
      INTEGER :: final
      REAL, DIMENSION(k0) :: wght, massf
      REAL :: wght0, prcbl
      INTEGER, PARAMETER :: nrands=1
      REAL :: rndu(nrands)
      INTEGER :: seedcbl(nrands)
! !DESCRIPTION:
!   {\tt STRAP} is called: FINAL=0, to compute cloud base layer CBL properties
!   given a value K for the index of the upper {\em EDGE} of the CBL; FINAL=1
!   to redistribute convective tendencies within CBL
      INTEGER :: kk
      INTRINSIC SQRT
      INTRINSIC MAX
      INTRINSIC ABS
      INTRINSIC PRESENT
      INTRINSIC ALLOCATED
      REAL :: abs0
      REAL :: abs1
      REAL :: arg1
      LOGICAL :: mask
!  LOCAL VARIABLES FOR USE IN CLOUDE
!!IF (.NOT. PRESENT(FINAL)) THEN
      IF (final .EQ. 0) THEN
!!PRJ(ICMIN:K+1) = PKE(I,ICMIN:K+1)
        DO kk=icmin,k+1
          prj(kk) = pke(i, kk)
        END DO
! These initialized here in order not to confuse Valgrind debugger
        poi = 0.
! Do not believe it actually makes any difference.
        qoi = 0.
        uoi = 0.
        voi = 0.
        prs(icmin:k0+1) = ple(i, icmin:k0+1)
        poi(icmin:k) = tho(i, icmin:k)
        qoi(icmin:k) = qho(i, icmin:k)
        uoi(icmin:k) = uho(i, icmin:k)
        voi(icmin:k) = vho(i, icmin:k)
        wsp(icmin:k) = SQRT((uoi(icmin:k)-uoi(k))**2 + (voi(icmin:k)-voi&
&         (k))**2)
        qst(icmin:k) = qss(i, icmin:k)
        dqq(icmin:k) = dqs(i, icmin:k)
        IF (do_tracers) THEN
          DO itr=1,itrcr
            xoi(icmin:k, itr) = xho(i, icmin:k, itr)
          END DO
        END IF
!!! Mass fraction of each layer below cloud base
!!! contributed to aggregate cloudbase layer (CBL)
        massf(:) = wgt0(i, :)
!!! RESET PRESSURE at bottom edge of CBL
        prcbl = prs(k)
        DO l=k,k0
          prcbl = prcbl + massf(l)*(prs(l+1)-prs(l))
        END DO
        prs(k+1) = prcbl
        prj(k+1) = (prs(k+1)/1000.)**(mapl_rgas/mapl_cp)
        DO l=k,icmin,-1
          pol(l) = 0.5*(prs(l)+prs(l+1))
          prh(l) = (prs(l+1)*prj(l+1)-prs(l)*prj(l))/(onepkap*(prs(l+1)-&
&           prs(l)))
          pki(l) = 1.0/prh(l)
          dpt(l) = prh(l) - prj(l)
          dpb(l) = prj(l+1) - prh(l)
          pri(l) = .01/(prs(l+1)-prs(l))
        END DO
!!!!! RECALCULATE PROFILE QUAN. IN LOWEST STRAPPED LAYER
        IF (k .LE. k0) THEN
          poi(k) = 0.
          qoi(k) = 0.
          uoi(k) = 0.
          voi(k) = 0.
!! SPECIFY WEIGHTS GIVEN TO EACH LAYER WITHIN SUBCLOUD "SUPERLAYER"
          wght = 0.
          DO l=k,k0
            wght(l) = massf(l)*(ple(i, l+1)-ple(i, l))/(prs(k+1)-prs(k))
          END DO
          DO l=k,k0
            poi(k) = poi(k) + wght(l)*tho(i, l)
            qoi(k) = qoi(k) + wght(l)*qho(i, l)
            uoi(k) = uoi(k) + wght(l)*uho(i, l)
            voi(k) = voi(k) + wght(l)*vho(i, l)
          END DO
          IF (do_tracers) THEN
            xoi(k, :) = 0.
            DO itr=1,itrcr
              DO l=k,k0
                xoi(k, itr) = xoi(k, itr) + wght(l)*xho(i, l, itr)
              END DO
            END DO
          END IF
          arg1 = poi(k)*prh(k)
          dqq(k) = DQSAT(arg1, pol(k), qsat=qst(k))
        END IF
        mask = seedras(i, 1)/1000000. .LT. 1e-6
        WHERE (mask) 
          rndu(:) = 1e-6
        ELSEWHERE
          rndu(:) = seedras(i, 1)/1000000.
        END WHERE
!!call congvec( npoints , seedcbl , rndu )
        dpth_bl = zcbl(i)
        IF (maxdallowed_d .GE. 0.) THEN
          abs0 = maxdallowed_d
        ELSE
          abs0 = -maxdallowed_d
        END IF
        IF (maxdallowed_s .GE. 0.) THEN
          abs1 = maxdallowed_s
        ELSE
          abs1 = -maxdallowed_s
        END IF
        mxdiam(i) = cnv_fraction(i)*abs0 + (1-cnv_fraction(i))*abs1
        IF (maxdallowed_e .LT. 0) mxdiam(i) = mxdiam(i)*rndu(1)**&
&           maxdallowed_e
! Make MXDIAM stochastic
        DO l=k,icmin,-1
!*
          bet(l) = dqq(l)*pki(l)
!*
          gam(l) = pki(l)/(1.0+lbcp*dqq(l))
          IF (l .LT. k) THEN
            ght(l+1) = gam(l)*dpb(l) + gam(l+1)*dpt(l+1)
            gm1(l+1) = 0.5*lbcp*(dqq(l)/(alhl*(1.0+lbcp*dqq(l)))+dqq(l+1&
&             )/(alhl*(1.0+lbcp*dqq(l+1))))
          END IF
        END DO
        tcu(icmin:k) = -(poi(icmin:k)*prh(icmin:k))
        qcu(icmin:k) = -qoi(icmin:k)
        rns = 0.
        cll = 0.
        rmf = 0.
        rmfd = 0.
        rmfc = 0.
        rmfp = 0.
        cll0 = 0.
        dll0 = 0.
        cllx = 0.
        dllx = 0.
        clli = 0.
        cllb = 0.
        poi_sv = poi
        qoi_sv = qoi
        uoi_sv = uoi
        voi_sv = voi
        IF (do_tracers) xoi_sv = xoi
        lambdsv = 0.0
        cvw = 0.0
        updfrc = 0.0
        updfrp = 0.0
        dissk0 = 0.0
      END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!    IF (PRESENT(FINAL)) THEN
      IF (final .EQ. 1) THEN
        tho(i, icmin:k-1) = poi(icmin:k-1)
        qho(i, icmin:k-1) = qoi(icmin:k-1)
        uho(i, icmin:k-1) = uoi(icmin:k-1)
        vho(i, icmin:k-1) = voi(icmin:k-1)
        cnv_updfrc(i, icmin:k-1) = updfrc(icmin:k-1)
        cnv_cvw(i, icmin:k-1) = cvw(icmin:k-1)
        cnv_qc(i, icmin:k-1) = cllb(icmin:k-1)
!======================AER_CLOUD=============
!               CNV_NDROP   (I,ICMIN:K-1)  =    CNVNDROP(ICMIN:K-1) !DONIF
!               CNV_NICE   (I,ICMIN:K-1)   =     CNVNICE(ICMIN:K-1) !DONIF
!               CNV_FICE   (I,ICMIN:K-1)   =     CNVFICE(ICMIN:K-1) !DONIF
!! De-strap tendencies from RAS
!! specify weighting "SHAPE"
        wght = wgt1(i, :)
!! Scale properly by layer masses
        wght0 = 0.
        DO l=k,k0
          wght0 = wght0 + wght(l)*(ple(i, l+1)-ple(i, l))
        END DO
        wght0 = (prs(k+1)-prs(k))/wght0
        wght = wght0*wght
        DO l=k,k0
          tho(i, l) = tho(i, l) + wght(l)*(poi(k)-poi_sv(k))
          qho(i, l) = qho(i, l) + wght(l)*(qoi(k)-qoi_sv(k))
          uho(i, l) = uho(i, l) + wght(l)*(uoi(k)-uoi_sv(k))
          vho(i, l) = vho(i, l) + wght(l)*(voi(k)-voi_sv(k))
        END DO
        IF (do_tracers) THEN
          xho(i, icmin:k-1, :) = xoi(icmin:k-1, :)
          DO itr=1,itrcr
            DO l=k,k0
              xho(i, l, itr) = xho(i, l, itr) + wght(l)*(xoi(k, itr)-&
&               xoi_sv(k, itr))
            END DO
          END DO
        END IF
!  (KG/m^2/s @ CLOUD BASE)
        flx(i, icmin:k) = rmf(icmin:k)*ddt/daylen
!  (KG/m^2/s @ CLOUD TOP)
        flxd(i, icmin:k) = rmfd(icmin:k)*ddt/daylen
!  (KG/m^2/s @ CLOUD TOP)
        flxc(i, icmin:k) = rmfc(icmin:k)*ddt/daylen
!  (KG/m^2/s )
        clw(i, icmin:k) = cll(icmin:k)*ddt/daylen
        IF (PRESENT(disske)) disske(i, icmin:k-1) = dissk0(icmin:k-1)*&
&           ddt/daylen
        flx(i, 1:icmin-1) = 0.
        flxd(i, 1:icmin-1) = 0.
        flxc(i, 1:icmin-1) = 0.
        clw(i, 1:icmin-1) = 0.
        IF (k .LT. k0) THEN
          flx(i, k:k0) = 0.
          flxd(i, k:k0) = 0.
          flxc(i, k:k0) = 0.
          clw(i, k:k0) = 0.
        END IF
        irc(i, icmin:k-1) = rc(icmin:k-1)
        IF (ALLOCATED(icl_v)) THEN
          DEALLOCATE(icl_v)
        END IF
      END IF
      IF (final .EQ. 2) THEN
        flx(i, :) = 0.
        flxd(i, :) = 0.
        flxc(i, :) = 0.
        clw(i, :) = 0.
        irc(i, icmin:k-1) = rc(icmin:k-1)
      END IF
      RETURN
    END SUBROUTINE STRAP
  END SUBROUTINE RASE
!  Differentiation of rase in reverse (adjoint) mode (with options r8):
!   gradient     of useful results: clw cnv_prc3 tho qho vho cnv_updfrc
!                uho flxd
!   with respect to varying inputs: clw cnv_prc3 tho qho vho cnv_updfrc
!                uho flxd
!   RW status of diff variables: clw:in-out cnv_prc3:in-out tho:in-out
!                qho:in-out vho:in-out cnv_updfrc:in-out uho:in-out
!                flxd:in-out
!!  RAS Relaxation Diagnostics
!!!!!AER_CLOUD
!DONIF
  SUBROUTINE RASE_ADM(idim, irun, k0, icmin, dt, cpo, alhlo, alhl1, tice&
&   , gravo, seedras, iras, jras, sige, kcbl, wgt0, wgt1, zcbl, mxdiam, &
&   tpert, qpert, tho, tho_ad, qho, qho_ad, uho, uho_ad, vho, vho_ad, &
&   qss, dqs, cnv_fraction, rasal2_2d, co_auto, pko, plo, phio, phie, &
&   qlo, qio, ple, pke, clw, clw_ad, flx, flxd, flxd_ad, flxc, cnv_prc3&
&   , cnv_prc3_ad, cnv_updfrc, cnv_updfrc_ad, cnv_cvw, cnv_qc, entlam, &
&   clan, hho, hso, precu, rasparams, ras_time, ras_trg, ras_toki, &
&   ras_pbl, ras_wfn, ras_alpha, ras_tau, aeroprops, cnv_fice, cnv_nice&
&   , cnv_ndrop, itrcr, irc, xho, triedlev_diag, fscav, disske)
    IMPLICIT NONE
! !!!!!!!!!!!!!!======================================
! !!!!!!!!!   Subroutine ARGact: finds the activated droplet number from Abdul_Razzak and Ghan 2000.
! ! Tailored for GOCART AEROSOL and works with AERO input
! !Written by Donifan Barahona
! !!donifan.o.barahona@nasa.gov
! !!!!!!!!!!!!!!====================================
! 
!       SUBROUTINE ARGact (TEMP, WX, NCPL_ACT, NCPL_AMB,  CDUST, CSOOT, LEV, ISBASE, DDUSTAMB, DSOOTAMB, ENT_PARAM)
! !
!          Integer, intent(in)     ::  LEV    
!          LOGICAL,  intent(in)     ::   ISBASE
! 
!          REAL, intent(inout)     ::   TEMP, WX, ENT_PARAM
!          REAL, intent(out)     ::   NCPL_ACT, NCPL_AMB, CSOOT, DSOOTAMB
!          REAL, DIMENSION(NDUSTMAX), INTENT(OUT) :: CDUST, DDUSTAMB
!          integer                 :: INDEX, NMODES, naux       
! 
!          type(AerProps)  :: AER, auxaer      
! 
! 
!          real     ::      kappa, alfa, beta, Akoh, G, T, smax, fi, gi, nui, &
!                        citai, ui, aux1, PACT,  Ntot, auxx, aux, auxconc, W, alph, aseasalt_aux, f_seasalt1
!          real, dimension (30) ::  SMI, TPI, SIGI 
! 
! 
!          SMI=0.0      
!          TPI = 0.0
!          SIGI =2.0
!          NCPL_ACT=0.0
!          NCPL_AMB=0.0
!          CDUST=0.0
!          CSOOT=0.0
!          DDUSTAMB =1.0e-9
!          DSOOTAMB= 1.0e-9
!          W=MIN(WX*(1.0-ENT_PARAM), 20.0)    
! 
!          PACT=0.0 !activation probability of entrained aerosol
! 
!          AER%nmods = 0
!          AER%num   = 0.0
! 
!          do INDEX = 1, AERO(LEV)%nmods
!              if (AERO(LEV)%num(INDEX) > 0.1) then
!                  AER%nmods = AER%nmods + 1
!                  naux = AER%nmods
! 
!                  AER%num(naux)   = AERO(LEV)%num(INDEX)
!                  AER%dpg(naux)   = max(AERO(LEV)%dpg(INDEX), 1.0e-9)
!                  AER%sig(naux)   = AERO(LEV)%sig(INDEX)
!                  AER%den(naux)   = AERO(LEV)%den(INDEX)
!                  AER%kap(naux)   = AERO(LEV)%kap(INDEX)
!                  AER%fdust(naux) = AERO(LEV)%fdust(INDEX)
!                  AER%fsoot(naux) = AERO(LEV)%fsoot(INDEX)
!                  AER%forg(naux)  = AERO(LEV)%forg(INDEX)
!              end if
!          end do
! 
!          if (AER%nmods == 0) then
!              call init_Aer(AER)
!          end if
! 
! !!!!!!!!!!activate aerosol transported from cloud base
!              NMODES =  AER_BASE%nmods
!              TPI(1:nmodes) = AER_BASE%num(1:nmodes)
!              SIGI(1:nmodes) = AER_BASE%sig(1:nmodes)                          
! 
!              
!              Ntot= 0.0
!               do index = 1, nmodes 
! 	              if (AER_BASE%kap(index) .gt. 0.1) Ntot =  Ntot + TPI(index)  
!               end do
!          
! 
!          if ((Ntot .lt. 1.0e4) .or. (TEMP .lt. 245.0) .or. (W .lt. 0.01)) then !no activation if aerosol < 1e-4 1/cm3
!             NCPL_ACT  = 0.0
!          else
! 
! ! Calculate constants. These fits were obtained from detailed correlations of physical properties. G is actually 1/G
!             T = min(max(TEMP, 243.0), 323.0)     
!             alfa=2.8915E-08*(T**2) - 2.1328E-05*T + 4.2523E-03
!             beta=exp(3.49996E-04*T**2 - 2.27938E-01*T + 4.20901E+01)
!             G=exp(-2.94362E-06*T**3 + 2.77941E-03*T**2 - 8.92889E-01*T + 1.18787E+02)
!             Akoh= 0.66e-6/T  !from Seinfeld and Pandis (1998)
!      
! !=======================================================
! !Activate droplets
! !=======================================================
! !Calculate maximum supersaturation according to ARG2002
! 
!             auxx=0.0 
!             
!             
!             DO INDEX = 1, NMODES            
!                 
!                kappa=  max(AER_BASE%kap(INDEX), 0.001)
!              
!                   SMI (INDEX) = ((0.667*Akoh/AER_BASE%dpg(INDEX))**1.5)/SQRT(2.0*kappa)   ! Critical supersat for mode I
!                   SMI=MAX(SMI, 1.0e-5)   
!                    
!               if ((TPI(INDEX) .gt. 1e4) .and.  (kappa .gt. 0.1)) then                       
!                   fi=0.5*exp(2.5*SIGI(INDEX)) !sigi is now log(sigi)
!                   gi=1.0+0.25*SIGI(INDEX)
!                   nui=((alfa*W*G)**1.5)/(2.0*MAPL_PI*980.0*beta*TPI(INDEX))
!                   citai = 0.667*Akoh*SQRT(alfa*W*G)
!                   aux1=fi*((citai/nui)**1.5) + gi*(SMI(INDEX)*SMI(INDEX)/(nui+(3.0*citai)))**0.75
!                   aux1=aux1/(SMI(INDEX)*SMI(INDEX))      
!                   auxx=auxx+aux1                  
!                 end if
!             end do
! 
! !Calculate number of activated droplets
!             if (auxx .gt. 0.0) then
!                smax = 1/sqrt(auxx)
!                auxx=0.0
! 
!                    DO INDEX = 1, NMODES
!                         if ((TPI(INDEX) .gt. 1e4) .and. (AER_BASE%kap(index) .gt. 0.1)) then
!                            ui=sqrt(2.0)*log(SMI(INDEX)/smax)/3.0
!                            aux1=0.5*TPI(INDEX)*(1.0-ERFAPP(ui))
!                            auxx=auxx+aux1
!                            AER_BASE%num(index) = max(TPI(INDEX) -aux1, 0.0) !remove already activated aerosol
!                         end if                    
!                    END DO
!                   NCPL_ACT=auxx             
!             else
!                   NCPL_ACT = 0.0             
!             end if
! 
!      
!  
!        end if
! 
! !now filllup dust and soot number
!          NMODES =  AER%nmods
! 
!          call getINsubset(1, AER,  auxaer)
!          CDUST(1:auxaer%nmods)= auxaer%num(1:auxaer%nmods)
!          DDUSTAMB(1:auxaer%nmods)= auxaer%dpg(1:auxaer%nmods)
!          call getINsubset(2, AER,  auxaer)
!          naux = max(auxaer%nmods, 1)
!          CSOOT= sum(auxaer%num) 
!          DSOOTAMB= sum(auxaer%dpg)/naux
! 
! 
!          PACT=1.0 ! fraction of entrained aerosol that is activated
!          auxconc =0.0
!          aseasalt_aux  = 0.0
! 
!          do index = 1, nmodes 
! 	       if (AER%kap(index) .gt. 0.8)  auxconc = AER%num(index) + auxconc
!            if (AER_BASE%kap(index) .gt. 0.8)    aseasalt_aux  = aseasalt_aux  + &
!            AER_BASE%num(index)*AER_BASE%dpg(index)*AER_BASE%dpg(index)*1.61*MAPL_PI !assumes a fixed sigma = 2.0
! 
!          end do
!        aseasalt = max(aseasalt, aseasalt_aux)
!      
! 	  NCPL_AMB=auxconc !Activate  entrained aerosol with kappa>0.8
! 
! 
! 
!       END SUBROUTINE ARGact
! 
! !!!!!!!!!!!!!!!!!!!!!!!!!!
! !=====Subroutine INfreezing=========
! ! Freeze droplets in immersion and contact ice nucleation modes, according to Barahona et al. GMD (2014)
! !!!!!!!!!!!!!!!!!!!!!
! 
!       subroutine INfreezing(QL, NL, NIN, NDUST, NSOOT, INDUST, INSOOT, TEMP, PRE, WSUB_, DDUST, DSOOT)  !NIN freezing tendency
!          REAL, INTENT( IN) :: TEMP, NSOOT, WSUB_, PRE, QL, NL, DSOOT
!          REAL, DIMENSION(NDUSTMAX), INTENT (IN) ::  NDUST, DDUST
!          REAL, DIMENSION(NDUSTMAX), INTENT (OUT) ::  INDUST
!          REAL, INTENT(OUT) ::  NIN, INSOOT 
!          REAL, DIMENSION(NDUSTMAX) ::  INDUST_C
! 
!          real :: a, b, c , d, Tx, n05, ui, aux, nssoot, nsdust, ninbkg, SI, acorr, &
!                dnsd, dnss, coolr, WSUB, ahet, INSOOT_C
! 
!          real :: nssoot_c, nsdust_c, mfp, nslip, ndfaer, viscosity, lam_r, taux, rho_a, &
!                 fdust_drop, fsoot_drop, min_ns_dust, min_ns_soot, nsss, INsea, dnsss, min_ns_seasalt 
! 
!          logical :: demott, Drop_mediated
!          integer :: ix
! 
!          min_ns_dust= 3.75e6 !limits ice nucleation to -12 !new 02/10/14
!          min_ns_soot= 3.75e9 !limits ice nucleation to -18
!          min_ns_seasalt = 4.0e2 !limits ice nucleation to -5
!          
!          demott=.false.
!          INDUST=0.0
!          INSOOT=0.0
!          INDUST_C=0.0
!          INSOOT_C=0.0   
!          NIN=0.0
!          Drop_mediated = .false.
!        INsea = 0.0 ! sea salt only in immersion
!    
!    
! ! note for sea salt we just assume that it is equal to the current droplet concentration and take the area 
! ! from the calculation at cloud base
! 
! ! fraction of dust and soot within droplets
!          fdust_drop= FDROP_DUST
!          fsoot_drop = FDROP_SOOT
! 
! 
!          WSUB=MAX(MIN(WSUB_, 10.0), 0.8)
!          coolr=5.0e-3*WSUB  !Approximation to saturated cooling rate
!          n05=sum(NDUST)+NSOOT
! 
!          if (TEMP .gt. T_ICE_MAX) then 
!             return
!          end if
! 
!          if (TEMP .lt. T_ICE_ALL   ) then 
!             return
!          end if
! 
! 
!          if ((QL .le. 1.0e-10) .or. (NL .le. 1.0)) then 
!             return
!          end if
! 
! !Background IN
! ! SI at water saturation
! 
!          rho_a = PRE*100.0/MAPL_RGAS/TEMP 
!          ninbkg=0.0
!          SI = -1.2379e-2+3.3595 !Ice supersat at water sat. Derived from Murphy and Koop 2005
! !if (TEMP .lt. 260.0)  ninbkg=coolr*42.8*exp(3.88*si)*0.1 !tendency in IN from background IN. Derived from Phillips et al. 2007
! 
! 
!          Tx = max(TEMP-273.16, -38.0 )
! 
!          lam_r=min((MAPL_PI*950.0*NL/rho_a/QL)**(1./3.), 1.0e8)
!          viscosity=1.8e-5*(TEMP/298.0)**0.85    ! Viscosity (kg/m/s)
!          mfp=2.0*viscosity/(PRE  &                   ! Mean free path (m)
!                *sqrt(8.0*28.96e-3/(MAPL_PI*8.314409*TEMP)))        
! 
!          if ((n05 .gt.1.0) .and. (TEMP .lt. 272.0)) then
! 
!             nsdust=  max(exp(-0.517*Tx + 8.934)-min_ns_dust, 0.0) !From Niemand 2012
!             nssoot= max(1.0e4*exp(-0.0101*Tx*Tx - 0.8525*Tx + 0.7667)-min_ns_soot, 0.0) !Murray (review_ 2012)
!             dnsd  = 0.517*nsdust
!             dnss  = max(-(-2.0*0.0101*Tx -0.8525)*nssoot, 0.0)
! 
! !ns in  contact. It is assumed that in contact is T-3 immersion
!             taux=max(Tx-3.0, -35.0)
!             nsdust_c= max(exp(-0.517*taux + 8.934)-min_ns_dust, 0.0) !From Niemand 2012
!             nssoot_c= max(1.0e4*exp(-0.0101*taux*taux - 0.8525*taux + 0.7667)-min_ns_soot, 0.0) !Murray (review_ 2012)
! 
!             aux=0.0        
!             acorr=2.7e7 !m2/m3 correction to the area due to non sphericity and aggregation. Assumes 10 m2/g (Murray 2011)
! 
! 
!             DO ix=1, NDUSTMAX
! !Immersion
!                ahet=0.52*DDUST(ix)*DDUST(ix)*DDUST(ix)*acorr*exp(4.5*log(2.0)*log(2.0)*log(2.0))    !this needs to be improved
! 
!                INDUST(ix) = NDUST(ix)*exp(-nsdust*ahet)* &
!                      dnsd*coolr*ahet*fdust_drop
! !Contact
!                nslip =1.0+(2.0*mfp/DDUST(ix))*(1.257+(0.4*exp(-(1.1*DDUST(ix)*0.5/mfp))))! Slip correction factor
!                ndfaer =1.381e-23*TEMP*nslip*(1.0-exp(-nsdust_c*ahet)) /(12.*MAPL_PI*viscosity*DDUST(ix))             
!                INDUST_C(ix) = 2.0*MAPL_PI*ndfaer*NDUST(ix)*NL/lam_r
! 
!             END DO
! 
! 
!             acorr=8.0e7 !m2/m3 correction to the area due to non sphericity and aggregation  Assumes 50 m2/g (Popovicheva 2003)
!             ahet =0.52*DSOOT*DSOOT*DSOOT*acorr*exp(4.5*log(2.0)*log(2.0)*log(2.0))             
!             INSOOT=fsoot_drop*NSOOT*exp(-nssoot*ahet)*dnss*ahet*coolr !
! 
!             nslip =1.0+(2.0*mfp/DSOOT)*(1.257+(0.4*exp(-(1.1*DSOOT*0.5/mfp))))! Slip correction factor
!             ndfaer =1.381e-23*TEMP*nslip*(1.0-exp(-nssoot_c*ahet)) /(12.*MAPL_PI*viscosity*DSOOT)             
!             INSOOT_c= 2.0*MAPL_PI*ndfaer*NSOOT*NL/lam_r
! 
! ! sea salt
!          nsss =  -0.459*TEMP +128.6235 ! from Demott et al. PNAS, 2015
!          nsss=  max(exp(nsss)-min_ns_seasalt, 0.0)           
!     	 dnsss=  max(0.459*nsss, 0.0)
!          INsea= aseasalt*dnsss*coolr 
! 
!  
!          end if
! 
! 	    NIN =ninbkg+ INSOOT + SUM(INDUST) + INSOOT_C + SUM(INDUST_C) + INsea!
!          INSOOT=INSOOT +INSOOT_C
!          INDUST =INDUST + INDUST_C
! 
! 	    
!       end subroutine INfreezing
! 
! 
! 
! 
! !!!!!!!!!!!!!!!!!!!!!!!!!!
! !===================Subroutine Qgrowth======================
! !Partitions water and ice according to Korolev and Mazin 2005. Assume spheres by now.
! !!!!!!!!!!!!!!!!!!!!
!       subroutine Qgrowth(TEMP, PRE, QICE0, NIPRE, QT, NINUC, DQIG, RIM, FNDRIM) 
! !freezing of IN according to Demott et al 2010 (everything SI)
!          REAL, INTENT(IN) :: TEMP, QICE0, NIPRE, NINUC,  PRE, QT
!          REAL, INTENT(INOUT) :: DQIG, RIM, FNDRIM
! 
! !real :: A, denI, aux, Dco, SI, denA, DQold, DQnew
!          real :: DIFF, DENICE, DENAIR, K1, K2, K3, SI, AUX, DC, TEFF, PLo, TEo, TC, &
!                DQnew, DQold, rho_a, LWC, IWC, qmin_rim
! 
! 
!          if (TEMP .gt. 272.15) then
!             DQIG =0.0
!             return
!          end if
! 
!          TC=TEMP-273.0 
!          PLo = max(PRE, 10.0) !limits  of the correlations
!          TEo = max(190.0, TEMP)
! 
!          qmin_rim = 1.0e-12
! 
! 
!          DENICE= 1000.0*(0.9167 - 1.75e-4*TC -5.0e-7*TC*TC) !From PK 97
!          DENAIR= PLo*100.0/MAPL_RGAS/TEMP
!          DIFF=(0.211*1013.25/(PLo+0.1))*(((TEo+0.1)/273.0)**1.94)*1e-4  !From Seinfeld and Pandis 2006
! 
!          K1 = EXP(7.1170e-4*TEo*TEo-0.43563*TEo+78.744) 
!          K2 = EXP(-9.933e-3*TEo+25.26)
!          K3 = EXP(7.1772e-4*TEo*TEo-0.44055*TEo+73.996)
! 
! 
!          AUX= 210368.0 + 131.438*TEMP - (3.32373E6/TEMP)- (41729.1*LOG(TEMP)) !From Murphy and Koop 2005
!          SI=exp(-aux/8.314/TEMP)-1.0 !ratio of pw/pi-1
!          rho_a = PRE*100.0/MAPL_RGAS/TEMP 
! 
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 
!          if  ((NIPRE .gt. 1.0) .and. (QICE0 .gt. 1.0e-10)) then 
!             DC=max((QICE0/(NIPRE*500.0*MAPL_PI))**(0.333), 40.0e-6) 
! !Assumme monodisperse size distribution about size distribution is made.
!          else   
!             DC = 40.0e-6
!          end if
! 
!          AUX=  NIPRE*DENICE*MAPL_PI*DC*DC
!          TEFF = DENAIR*2.0*((K1*DIFF+K2)*DC+(K3/0.1))
! 
!          if  (AUX .gt. 1.0e-12) then 
!             TEFF=min(TEFF/AUX, 1.0e20)   
!             DQold= SI/TEFF  
!          else
!             DQold=0.0
!          end if
! 
! ! Calculate rimming fraction
!          IWC =  QICE0*rho_a
!          LWC =  max(QT-QICE0, 0.0)*rho_a
!          aux = DQold ! only due to deposition
! 
! 
! !Account for rimming
! 
!          if ((LWC .gt. qmin_rim)  .and. (IWC .gt. qmin_rim))  then 
!             RIM = 6.0e-5/(LWC*(IWC**0.17)) !Fom Lin and Colle, NRW, 2011
!             RIM = 1.0/(1.0+RIM)
!             RIM  = min (0.95, RIM)
!             DQold =  DQold*(1 + RIM/(1.0-RIM))
!             FNDrim =  max(min(rho_a*(DQold -aux)/LWC, 1.0), 0.0) !Fraction of liquid condensate removed due to riming
!          END if
! 
! 
! 
! 
! !!!!!!!!!!!!!!!!!!!!!recently nucleated!!!!!!!!!!!!!!!!!!!!!!!!
! 
! 
!          AUX=  NINUC*DENICE*MAPL_PI*20.0e-6*20.0e-6
!          TEFF = DENAIR*2.0*((K1*DIFF+K2)*DC+(K3/0.1))
! 
!          if  (AUX .gt. 1.0e-12)  then 
!             TEFF=min(TEFF/AUX, 1.0e10)
!             DQnew= SI/TEFF
!          else
!             DQnew = 0.0
!          end if
! 
!          DQIG = DQold+DQnew     
! 
!       end subroutine Qgrowth
! 
! 
! 
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 
! !*************************************************************
! ! Function PDG07 (simplified background ice nucleation
! !                     spectra according to Phillips et. al. 2007).
! ! si is supersaturation wrt ice and T is in K
! !************************************************************
! 
!       subroutine PDG07_ice(si, Tx, N)     
! 
!          real, intent(in) :: si, Tx
!          real, intent(out)  :: N 
!          N=0.0
! 
! !if (Tx .le. 243.0)then
! 
! 
!          N=1000.0*exp(-0.388)*(exp(3.88*si)-1.0)/0.76
! !elseif (Tx .le. 260.0) then
! !  N=60.0*exp(-0.639)*(exp(12.96*si)-1.0)/0.76
! !end if
!       end subroutine PDG07_ice
! 
! 
! !*********************************************************************
! 
!*********************************************************************
!*********************************************************************
!******************** Relaxed Arakawa-Schubert ***********************
!************************ Parameterization ***************************
!********************** SCALAR RAS-1 VERSION  ************************
!************************* 31 DECEMBER 1999 **************************
!*********************************************************************
!************************** Developed By *****************************
!*********************************************************************
!************************ Shrinivas Moorthi **************************
!******************************* and *********************************
!************************** Max J. Suarez ****************************
!*********************************************************************
!******************** Laboratory for Atmospheres *********************
!****************** NASA/GSFC, Greenbelt, MD 20771 *******************
!*********************************************************************
!*********************************************************************
!  Input:
!  ------
!
!     K0      : Number of vertical levels (increasing downwards)
!
!     DT      : Time step in seconds
!
!     RASAL   : Array of dimension K-1 containing relaxation parameters
!               for cloud-types detraining at those levels
!
!     CPO     : Specific heat at constant pressure (J/kg/K)
!
!     ALHLO   : Latent Heat of condensation (J/kg)
!
!     ALHL1   : Latent Heat of condensation + fusion (J/kg)
!
!     GRAVO   : Acceleration due to gravity (m/s^2)
!
!     PLE     : 2D array of dimension (IDIM,K0+1) containing pressure
!               in hPa at the interfaces of K-layers from top of the
!               atmosphere to the bottom  (mb)
!
!     PKE     : 2D array of dimension (IDIM,K0+1) containing (PRS/P00) **
!               RKAP.  i.e. Exner function at layer edges.
!
!     PKL     : 2D array of dimension (IDIM,K0) ) containing the
!               Exner function at the layers.
!
!     QSS     : 2D array of dimension (IDIM,K0  ) containing the
!               saturation specific humidity at the layers. (kg/kg)
!
!     DQS     : 2D array of dimension (IDIM,K0  ) containing
!               d(qss)/dt at the layers.  (1/K)
!
!     CNV_FRACTION    : 1D array of dimension (IDIM) containing
!               fraction of grid cell considered to be convective
!
!  Update:
!  -------
!
!     THO     : 2D array of dimension (IDIM,K0) containing potential
!               temperature (K)
!
!     QHO     : 2D array of dimension (IDIM,K0) containing specific
!               humidity (kg/kg)
!
!     UHO     : 2D array of dimension (IDIM,K0) containing u-wind (m/s)
!
!     VHO     : 2D array of dimension (IDIM,K0) containing v-wind (m/s)
!
!  Output:
!  -------
!!
!     CLW     : 2D array of dimension (IDIM,K0) containing the
!               detrained cloud liquid water.  (kg/m^2/s)
!
!     FLX     : 2D array of dimension (IDIM,K0) containing the
!               cloud-base mass flux for each cloud type ordered by
!               detrainment level.   (kg/m^2/s)
!
!     FLXD    : 2D array of dimension (IDIM,K0) containing the
!               detrained  mass flux for each cloud type ordered by
!               detrainment level.   (kg/m^2/s)
!
!     FLXC    : 2D array of dimension (IDIM,K0+1) containing the
!               total cloud mass flux for all cloud types through
!               the top of each level. (e.g., FLXC(K)=SUM(FLX(ICMIN:K))
!               and  FLXD(L) = FLXC(L+1)-FLSD(L) )
!                (kg/m^2/s)
!
!     PRECU   : 1D (IDIM) Locally-handled convective precip
!               Zero if older version of RAS-1 is used. Nonzero if
!               RAS-2 is used.
!
!   AEROPROPS, Structure containing aerosol propoerties (in)
!   CNV_NICE, CNV_DROP.  Flux of ice crystals and droplet number at det level (1/m^2/s) (out)
!   CNV_FICE: Ice fraction in the detrained condensate (out)
!************************************************************************
!  ARGUMENTS
    INTEGER, INTENT(IN) :: idim, irun, k0, icmin
    REAL, DIMENSION(idim, k0), INTENT(INOUT) :: tho, qho, uho, vho, qlo&
&   , qio, clan
    REAL, DIMENSION(idim, k0), INTENT(INOUT) :: tho_ad, qho_ad, uho_ad, &
&   vho_ad
    REAL, DIMENSION(idim, k0+1), INTENT(IN) :: ple, pke, phie
    REAL, DIMENSION(idim, k0), INTENT(IN) :: qss, dqs, plo, pko, phio
    REAL, DIMENSION(idim), INTENT(IN) :: cnv_fraction, rasal2_2d
    REAL, DIMENSION(k0+1), INTENT(IN) :: sige
    REAL, DIMENSION(idim, k0) :: flx, clw, flxd
    REAL, DIMENSION(idim, k0) :: clw_ad, flxd_ad
    REAL, DIMENSION(idim, k0+1), INTENT(OUT) :: flxc
    REAL, DIMENSION(idim, k0) :: cnv_prc3
    REAL, DIMENSION(idim, k0) :: cnv_prc3_ad
    REAL, DIMENSION(idim, k0) :: cnv_updfrc, cnv_qc, cnv_cvw
    REAL, DIMENSION(idim, k0) :: cnv_updfrc_ad
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: entlam
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: hho, hso
    REAL, INTENT(IN) :: dt, cpo, alhlo, gravo
    REAL, INTENT(IN) :: alhl1, tice
    INTEGER, INTENT(IN) :: itrcr
    INTEGER, DIMENSION(idim, 2), INTENT(IN) :: seedras
    INTEGER, DIMENSION(idim), INTENT(IN) :: iras, jras, kcbl
    REAL, DIMENSION(idim), INTENT(IN) :: zcbl, tpert, qpert
    REAL, DIMENSION(idim), INTENT(IN) :: co_auto
    REAL, DIMENSION(idim), INTENT(OUT) :: mxdiam
    REAL, DIMENSION(idim), INTENT(OUT) :: precu
    REAL, DIMENSION(idim, k0), INTENT(IN) :: wgt0, wgt1
!     REAL, DIMENSION(:),          INTENT(IN   ) ::  RASPARAMS
    TYPE(RASPARAM_TYPE), INTENT(IN) :: rasparams
    REAL, DIMENSION(idim), INTENT(OUT) :: ras_time, ras_trg, ras_toki, &
&   ras_pbl, ras_wfn
    INTEGER, DIMENSION(idim, k0), INTENT(OUT) :: irc
    REAL, OPTIONAL, INTENT(INOUT) :: xho(idim, k0, itrcr)
    REAL, OPTIONAL, INTENT(OUT) :: triedlev_diag(idim, k0)
    REAL, OPTIONAL, INTENT(OUT) :: disske(idim, k0)
! Fraction scavenged per km
    REAL, OPTIONAL, INTENT(IN) :: fscav(itrcr)
! = 0 (no scav), = 1 (full scav)
!  LOCALS
    REAL, DIMENSION(k0) :: poi_sv, qoi_sv, uoi_sv, voi_sv
    REAL, DIMENSION(k0) :: poi_sv_ad, qoi_sv_ad, uoi_sv_ad, voi_sv_ad
    REAL, DIMENSION(k0) :: poi, qoi, uoi, voi, dqq, bet, gam, cll
    REAL, DIMENSION(k0) :: poi_ad, qoi_ad, uoi_ad, voi_ad, dqq_ad, &
&   bet_ad, gam_ad, cll_ad
    REAL, DIMENSION(k0) :: poi_c, qoi_c
    REAL, DIMENSION(k0) :: poi_c_ad, qoi_c_ad
    REAL, DIMENSION(k0) :: prh, pri, ght, dpt, dpb, pki, dissk0, dissk1&
&   , clantnd
    REAL, DIMENSION(k0) :: ght_ad
    REAL, DIMENSION(k0) :: tcu, qcu, ucu, vcu, cln, rns, pol, dm
    REAL, DIMENSION(k0) :: ucu_ad, vcu_ad, rns_ad
    REAL, DIMENSION(k0) :: qst, ssl, rmf, rnn, rn1, rmfc, rmfp
    REAL, DIMENSION(k0) :: qst_ad, ssl_ad, rnn_ad, rmfp_ad
    REAL, DIMENSION(k0) :: gms, eta, gmh, eht, gm1, hcc, rmfd
    REAL, DIMENSION(k0) :: gms_ad, eta_ad, gmh_ad, eht_ad, gm1_ad, &
&   hcc_ad, rmfd_ad
    REAL, DIMENSION(k0) :: hol, hst, qol, zol, hcld, cll0, cllx, clli, &
&   cllb
    REAL, DIMENSION(k0) :: hol_ad, hst_ad, qol_ad, zol_ad, hcld_ad, &
&   cll0_ad
    REAL, DIMENSION(k0) :: wsp, lambdsv, bke, cvw, updfrc
    REAL, DIMENSION(k0) :: cvw_ad, updfrc_ad
    REAL, DIMENSION(k0) :: tau, rasal, mtkwi, updfrp, bk2, bk3, dll0, &
&   dllx
    REAL, DIMENSION(k0) :: tau_ad, rasal_ad, updfrp_ad, bk2_ad
    REAL, DIMENSION(itrcr) :: xht
    REAL, DIMENSION(k0, itrcr) :: xoi, xcu, xoi_sv
    REAL, DIMENSION(k0+1) :: prj, prs, qht, sht, zet, xyd, xyd0
    REAL, DIMENSION(k0+1) :: qht_ad, sht_ad, zet_ad
    INTEGER, DIMENSION(k0-1) :: rc
    INTEGER :: k, my_pe
    REAL, DIMENSION(idim, k0) :: lambdsv2
    REAL :: tx2, tx3, uht, vht, akm, acr, alm, tth, qqh, shtrg, wspbl, &
&   dqx
    REAL :: tx2_ad, tx3_ad, uht_ad, vht_ad, akm_ad, alm_ad, dqx_ad
!, BKE
    REAL :: wfn, tem, trg, trgexp, evp, wlq, qcc, mtkw_max
    REAL :: wfn_ad, tem_ad, trg_ad, wlq_ad, qcc_ad
    REAL :: shtrg_fac, sige_minhol, wfnog
    INTEGER :: i, ic, l, icl, itr, icl_c, n_dtl
    INTEGER :: ndtlexpon
    INTEGER, DIMENSION(:), ALLOCATABLE :: icl_v
!  RASE GLOBAL CONSTANTS
    REAL :: grav, cp, alhl, cpbg, alhi, cpi, gravi, ddt, lbcp, obg, afc
!!!!!!!!!
    REAL :: fricfac, dpth_bl, wupdrft, pblfrac, autorampb, co_zdep
    REAL :: rasal1, rasal2, rasal2i, co_t, rasncl, friclambda, sdqvt1, &
&   sdqv2
    REAL :: lambda_fac, strapping, acritfac, hmintrigger, lldisaggxp
    REAL :: lambmx_fac, diammn_min, rdtlexpon, cli_crit, sdqv3, &
&   maxdallowed_d, maxdallowed_s, maxdallowed_e
    REAL :: rhmn, rhmx, cldmicro, fdrop_dust, fdrop_soot, rasal_slope
    INTEGER :: kstrap
    REAL :: cld_radius, areal_frac, spect_mflx, cvw_cbase
!!!!!!!!!
    REAL, PARAMETER :: onepkap=1.+2./7., daylen=86400.0
!      REAL, PARAMETER :: PBLFRAC = 0.5
    REAL, PARAMETER :: rhmax=0.9999
!  LAMBDA LIMITS
    REAL :: lambda_min
    REAL :: lambda_max
!  TRIGGER PARAMETERS
! Density of liquid water in kg/m^3
    REAL, PARAMETER :: rho_w=1.0e3
    LOGICAL :: dyna_strapping, do_tracers, smooth_hst
!character(len=ESMF_MAXSTR)          :: CBL_STYLE
    REAL*8, DIMENSION(k0) :: tcu8, qcu8, pcu, flx8
    REAL*8, DIMENSION(k0, itrcr+2) :: rcu
!, dpd, tla
    REAL*8 :: cup
    LOGICAL :: revap, wrkfun, calkpb, crtfun, lprnt, dndrft
    REAL*8, DIMENSION(k0) :: toi8, qoi8, prsm8, phil8, qli8, qii8, &
&   trcfac
    REAL*8, DIMENSION(k0) :: alfind, alfint, alfinq, rhc_ls
    REAL*8, DIMENSION(k0+1) :: prs8, phih8
    REAL*8, DIMENSION(k0, itrcr+2) :: roi8
    REAL*8 :: fracbl, dt8, rasalf
    INTEGER :: kpbl
! no inhibition for =1.0
    REAL*8, SAVE :: max_neg_bouy=1.0
!!real*8 :: ALFINT = 0.5
!!real*8 :: ALFINQ = 0.5
! not used
    REAL*8, SAVE :: rhfacl=0.0
! no inhibition
    REAL*8, SAVE :: rhfacs=0.0
! 1 degree resolution
    REAL*8, SAVE :: garea=1.e10
!!real*8 :: ALFIND = 1.0
!!real*8 :: RHC_LS = 0.80
    REAL*8, SAVE :: dsfc=0.001
    REAL*8, SAVE :: cd=1.e-3
    REAL*8, SAVE :: wfnc=0.0
    REAL*8, SAVE :: tla=-1.0
    REAL*8, SAVE :: dpd=300.
!  SCAVANGING RELATED PARAMETERS
! layer thickness in km
    REAL :: delzkm
! fraction of tracer *not* scavenged
    REAL :: fnoscav
! Fraction scavenged per km
    REAL :: fscav_(itrcr)
! ************************AER_CLOUD *********************************************
!DONIF
    TYPE(AERPROPS), DIMENSION(idim, k0), INTENT(IN) :: aeroprops
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: cnv_ndrop, cnv_fice, &
&   cnv_nice
    REAL, DIMENSION(idim, k0), INTENT(OUT) :: ras_tau, ras_alpha
!DONIF
    REAL, DIMENSION(k0) :: cnvndrop, cnvnice, cnvfice
!AEROSOL VERTICAl ARRAY FOR ALL SPECIES
    TYPE(AERPROPS), DIMENSION(k0) :: aero
    REAL :: t_ice_all, t_ice_max, aseasalt, f_seasalt
    INTEGER, PARAMETER :: ndustmax=10
    INTEGER :: index
    TYPE(AERPROPS) :: aeraux, aer_base
    INTRINSIC PRESENT
    INTRINSIC INT
    INTRINSIC SQRT
    INTRINSIC SUM
    INTRINSIC ALLOCATED
    INTEGER :: ad_to
    INTEGER :: branch
! *********************************************************************
    IF (PRESENT(fscav)) THEN
      fscav_ = fscav
    ELSE
! NO SCAVENGING BY DEFAULT
      fscav_ = 0.0
    END IF
    IF (irun .GT. 0) THEN
      cnv_prc3 = 0.
!!LAMBDSV2 = 0.
!      SMOOTH_HST   = .TRUE.
      smooth_hst = .false.
      fricfac = rasparams%cufricfac
! MAT CO_AUTO is now passed in from outside
!     in order to allow this code to run over im*jm
!     columns
!CO_AUTO      = RASPARAMS(3)     !  ---  3
      cli_crit = rasparams%qc_crit_cn
      rasal1 = rasparams%rasal1
      rasncl = rasparams%rasncl
      diammn_min = rasparams%min_diameter
      friclambda = rasparams%cufriclambda
      rdtlexpon = rasparams%rdtlexpon
      sdqv2 = rasparams%sdqv2
      sdqv3 = rasparams%sdqv3
      sdqvt1 = rasparams%sdqvt1
      acritfac = rasparams%acritfac
      pblfrac = rasparams%pblfrac
      autorampb = rasparams%rasautorampb
      co_zdep = rasparams%autoc_cn_zdep
      maxdallowed_s = rasparams%maxdallowed_s
      maxdallowed_d = rasparams%maxdallowed_d
      maxdallowed_e = rasparams%maxdallowed_e
      rasal_slope = rasparams%rasal_slope
      rhmn = rasparams%ras_rhmin
      rhmx = rasparams%ras_rhfull
      cldmicro = rasparams%cldmicro
      do_tracers = PRESENT(xho) .AND. itrcr .GT. 0
      grav = gravo
      alhl = alhlo
      cp = cpo
      cpi = 1.0/cp
      alhi = 1.0/alhl
      gravi = 1.0/grav
      cpbg = cp*gravi
      ddt = daylen/dt
      lbcp = alhl*cpi
      DO i=1,irun
!===================AER_CLOUD
!            AERO =  AEROPROPS(I, :)
!            CNVFICE  =0.0
!            CNVNDROP =0.0
!            CNVNICE  =0.0
!!CALL FINDBASE
        k = kcbl(i)
        rc(icmin) = 0
        CALL FINDDTLS()
        IF (k .GT. 0) THEN
          CALL PUSHREAL8ARRAY(dpt, k0)
          CALL PUSHREAL8ARRAY(pol, k0)
          CALL PUSHREAL8ARRAY(prs, k0 + 1)
          CALL PUSHREAL8ARRAY(prj, k0 + 1)
          CALL PUSHREAL8ARRAY(prh, k0)
          CALL PUSHREAL8ARRAY(dpb, k0)
          CALL PUSHREAL8ARRAY(pki, k0)
          CALL PUSHREAL8ARRAY(dqq, k0)
          CALL PUSHREAL8ARRAY(tho, idim*k0)
          CALL STRAP(final=0)
          CALL HTEST()
          tau = 0.0
          rasal = 0.0
          DO icl_c=1,n_dtl
            CALL PUSHINTEGER4(icl)
            icl = icl_v(icl_c)
            IF (do_tracers) xcu(icmin:, :) = 0.
! This change makes cumulus friction
            ucu(icmin:) = 0.
! correct.
            vcu(icmin:) = 0.
            IF (icl .GT. icmin) THEN
              CALL PUSHREAL8ARRAY(hol, k0)
              CALL PUSHREAL8ARRAY(zol, k0)
              CALL PUSHREAL8ARRAY(zet, k0 + 1)
              CALL PUSHREAL8ARRAY(ssl, k0)
              CALL PUSHREAL8ARRAY(uoi, k0)
              CALL PUSHREAL8ARRAY(poi, k0)
              CALL PUSHREAL8ARRAY(gms, k0)
              CALL PUSHREAL8ARRAY(qst, k0)
              CALL PUSHREAL8ARRAY(rnn, k0)
              CALL PUSHREAL8ARRAY(gmh, k0)
              CALL PUSHREAL8ARRAY(sht, k0 + 1)
              CALL PUSHREAL8ARRAY(eta, k0)
              CALL PUSHREAL8ARRAY(hcld, k0)
              CALL PUSHREAL8ARRAY(rasal, k0)
              CALL PUSHREAL8ARRAY(bk2, k0)
              CALL PUSHREAL8ARRAY(voi, k0)
              CALL PUSHREAL8ARRAY(qol, k0)
              CALL PUSHREAL8ARRAY(qoi, k0)
              CALL PUSHREAL8ARRAY(qht, k0 + 1)
              CALL PUSHREAL8ARRAY(hst, k0)
              CALL PUSHREAL8ARRAY(cvw, k0)
              CALL PUSHREAL8ARRAY(hcc, k0)
              CALL PUSHREAL8ARRAY(eht, k0)
              CALL PUSHREAL8ARRAY(tau, k0)
              CALL CLOUDE(icl)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
          END DO
          CALL PUSHINTEGER4(icl_c - 1)
          IF (SUM(rmf(icmin:k)) .GT. 0.0) THEN
            CALL PUSHREAL8ARRAY(qoi, k0)
            CALL PUSHREAL8ARRAY(cnv_prc3, idim*k0)
            CALL RNEVP()
            CALL PUSHREAL8ARRAY(gam, k0)
            CALL PUSHREAL8ARRAY(dpt, k0)
            CALL PUSHREAL8ARRAY(pol, k0)
            CALL PUSHREAL8ARRAY(prs, k0 + 1)
            CALL PUSHREAL8ARRAY(rns, k0)
            CALL PUSHREAL8ARRAY(qst, k0)
            CALL PUSHREAL8ARRAY(prj, k0 + 1)
            CALL PUSHREAL8ARRAY(pri, k0)
            CALL PUSHREAL8ARRAY(prh, k0)
            CALL PUSHREAL8ARRAY(dpb, k0)
            CALL PUSHREAL8ARRAY(pki, k0)
            CALL PUSHREAL8ARRAY(bet, k0)
            CALL PUSHREAL8ARRAY(ght, k0)
            CALL PUSHREAL8ARRAY(dqq, k0)
            CALL PUSHREAL8ARRAY(gm1, k0)
            CALL PUSHREAL8ARRAY(tho, idim*k0)
            CALL PUSHREAL8ARRAY(mxdiam, idim)
            CALL STRAP(final=1)
            CALL PUSHCONTROL2B(0)
          ELSE
            CALL PUSHREAL8ARRAY(gam, k0)
            CALL PUSHREAL8ARRAY(dpt, k0)
            CALL PUSHREAL8ARRAY(pol, k0)
            CALL PUSHREAL8ARRAY(prs, k0 + 1)
            CALL PUSHREAL8ARRAY(qst, k0)
            CALL PUSHREAL8ARRAY(prj, k0 + 1)
            CALL PUSHREAL8ARRAY(pri, k0)
            CALL PUSHREAL8ARRAY(prh, k0)
            CALL PUSHREAL8ARRAY(dpb, k0)
            CALL PUSHREAL8ARRAY(pki, k0)
            CALL PUSHREAL8ARRAY(qoi, k0)
            CALL PUSHREAL8ARRAY(bet, k0)
            CALL PUSHREAL8ARRAY(ght, k0)
            CALL PUSHREAL8ARRAY(dqq, k0)
            CALL PUSHREAL8ARRAY(gm1, k0)
            CALL PUSHREAL8ARRAY(tho, idim*k0)
            CALL PUSHREAL8ARRAY(mxdiam, idim)
            CALL STRAP(final=2)
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHREAL8ARRAY(dpt, k0)
          CALL PUSHREAL8ARRAY(pol, k0)
          CALL PUSHREAL8ARRAY(prs, k0 + 1)
          CALL PUSHREAL8ARRAY(prj, k0 + 1)
          CALL PUSHREAL8ARRAY(prh, k0)
          CALL PUSHREAL8ARRAY(dpb, k0)
          CALL PUSHREAL8ARRAY(pki, k0)
          CALL PUSHREAL8ARRAY(dqq, k0)
          CALL PUSHREAL8ARRAY(tho, idim*k0)
          CALL STRAP(final=2)
          CALL PUSHCONTROL2B(2)
        END IF
      END DO
      eht_ad = 0.0_8
      gm1_ad = 0.0_8
      hcc_ad = 0.0_8
      cvw_ad = 0.0_8
      dqq_ad = 0.0_8
      ucu_ad = 0.0_8
      ght_ad = 0.0_8
      hst_ad = 0.0_8
      bet_ad = 0.0_8
      qoi_sv_ad = 0.0_8
      qht_ad = 0.0_8
      uoi_sv_ad = 0.0_8
      qoi_ad = 0.0_8
      qol_ad = 0.0_8
      voi_ad = 0.0_8
      bk2_ad = 0.0_8
      hcld_ad = 0.0_8
      eta_ad = 0.0_8
      sht_ad = 0.0_8
      gmh_ad = 0.0_8
      rnn_ad = 0.0_8
      qst_ad = 0.0_8
      gms_ad = 0.0_8
      updfrc_ad = 0.0_8
      poi_ad = 0.0_8
      rns_ad = 0.0_8
      poi_sv_ad = 0.0_8
      uoi_ad = 0.0_8
      vcu_ad = 0.0_8
      rmfd_ad = 0.0_8
      voi_sv_ad = 0.0_8
      ssl_ad = 0.0_8
      zet_ad = 0.0_8
      updfrp_ad = 0.0_8
      zol_ad = 0.0_8
      cll0_ad = 0.0_8
      cll_ad = 0.0_8
      rmfp_ad = 0.0_8
      gam_ad = 0.0_8
      DO 100 i=irun,1,-1
        CALL POPCONTROL2B(branch)
        IF (branch .EQ. 0) THEN
          k = kcbl(i)
          CALL POPREAL8ARRAY(mxdiam, idim)
          CALL POPREAL8ARRAY(tho, idim*k0)
          CALL POPREAL8ARRAY(gm1, k0)
          CALL POPREAL8ARRAY(dqq, k0)
          CALL POPREAL8ARRAY(ght, k0)
          CALL POPREAL8ARRAY(bet, k0)
          CALL POPREAL8ARRAY(pki, k0)
          CALL POPREAL8ARRAY(dpb, k0)
          CALL POPREAL8ARRAY(prh, k0)
          CALL POPREAL8ARRAY(pri, k0)
          CALL POPREAL8ARRAY(prj, k0 + 1)
          CALL POPREAL8ARRAY(qst, k0)
          CALL POPREAL8ARRAY(rns, k0)
          CALL POPREAL8ARRAY(prs, k0 + 1)
          CALL POPREAL8ARRAY(pol, k0)
          CALL POPREAL8ARRAY(dpt, k0)
          CALL POPREAL8ARRAY(gam, k0)
          CALL STRAP_ADM(final=1)
          CALL POPREAL8ARRAY(cnv_prc3, idim*k0)
          CALL POPREAL8ARRAY(qoi, k0)
          CALL RNEVP_ADM()
        ELSE IF (branch .EQ. 1) THEN
          k = kcbl(i)
          CALL POPREAL8ARRAY(mxdiam, idim)
          CALL POPREAL8ARRAY(tho, idim*k0)
          CALL POPREAL8ARRAY(gm1, k0)
          CALL POPREAL8ARRAY(dqq, k0)
          CALL POPREAL8ARRAY(ght, k0)
          CALL POPREAL8ARRAY(bet, k0)
          CALL POPREAL8ARRAY(qoi, k0)
          CALL POPREAL8ARRAY(pki, k0)
          CALL POPREAL8ARRAY(dpb, k0)
          CALL POPREAL8ARRAY(prh, k0)
          CALL POPREAL8ARRAY(pri, k0)
          CALL POPREAL8ARRAY(prj, k0 + 1)
          CALL POPREAL8ARRAY(qst, k0)
          CALL POPREAL8ARRAY(prs, k0 + 1)
          CALL POPREAL8ARRAY(pol, k0)
          CALL POPREAL8ARRAY(dpt, k0)
          CALL POPREAL8ARRAY(gam, k0)
          CALL STRAP_ADM(final=2)
        ELSE
          k = kcbl(i)
          CALL POPREAL8ARRAY(tho, idim*k0)
          CALL POPREAL8ARRAY(dqq, k0)
          CALL POPREAL8ARRAY(pki, k0)
          CALL POPREAL8ARRAY(dpb, k0)
          CALL POPREAL8ARRAY(prh, k0)
          CALL POPREAL8ARRAY(prj, k0 + 1)
          CALL POPREAL8ARRAY(prs, k0 + 1)
          CALL POPREAL8ARRAY(pol, k0)
          CALL POPREAL8ARRAY(dpt, k0)
          CALL STRAP_ADM(final=2)
          GOTO 100
        END IF
        tau_ad = 0.0_8
        rasal_ad = 0.0_8
        hol_ad = 0.0_8
        CALL POPINTEGER4(ad_to)
        DO icl_c=ad_to,1,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8ARRAY(tau, k0)
            CALL POPREAL8ARRAY(eht, k0)
            CALL POPREAL8ARRAY(hcc, k0)
            CALL POPREAL8ARRAY(cvw, k0)
            CALL POPREAL8ARRAY(hst, k0)
            CALL POPREAL8ARRAY(qht, k0 + 1)
            CALL POPREAL8ARRAY(qoi, k0)
            CALL POPREAL8ARRAY(qol, k0)
            CALL POPREAL8ARRAY(voi, k0)
            CALL POPREAL8ARRAY(bk2, k0)
            CALL POPREAL8ARRAY(rasal, k0)
            CALL POPREAL8ARRAY(hcld, k0)
            CALL POPREAL8ARRAY(eta, k0)
            CALL POPREAL8ARRAY(sht, k0 + 1)
            CALL POPREAL8ARRAY(gmh, k0)
            CALL POPREAL8ARRAY(rnn, k0)
            CALL POPREAL8ARRAY(qst, k0)
            CALL POPREAL8ARRAY(gms, k0)
            CALL POPREAL8ARRAY(poi, k0)
            CALL POPREAL8ARRAY(uoi, k0)
            CALL POPREAL8ARRAY(ssl, k0)
            CALL POPREAL8ARRAY(zet, k0 + 1)
            CALL POPREAL8ARRAY(zol, k0)
            CALL POPREAL8ARRAY(hol, k0)
            CALL CLOUDE_ADM(icl)
          END IF
          vcu_ad(icmin:k0) = 0.0_8
          ucu_ad(icmin:k0) = 0.0_8
          CALL POPINTEGER4(icl)
        END DO
        CALL HTEST_ADM()
        CALL POPREAL8ARRAY(tho, idim*k0)
        CALL POPREAL8ARRAY(dqq, k0)
        CALL POPREAL8ARRAY(pki, k0)
        CALL POPREAL8ARRAY(dpb, k0)
        CALL POPREAL8ARRAY(prh, k0)
        CALL POPREAL8ARRAY(prj, k0 + 1)
        CALL POPREAL8ARRAY(prs, k0 + 1)
        CALL POPREAL8ARRAY(pol, k0)
        CALL POPREAL8ARRAY(dpt, k0)
        CALL STRAP_ADM(final=0)
 100  CONTINUE
      cnv_prc3_ad = 0.0_8
      cnv_updfrc_ad = 0.0_8
    END IF

  CONTAINS
!  Differentiation of cloude in reverse (adjoint) mode (with options r8):
!   gradient     of useful results: tau eht gm1 hcc cvw dqq ucu
!                ght hst bet qht qoi qol voi bk2 rasal hcld eta
!                sht gmh rnn qst gms updfrc poi rns uoi vcu rmfd
!                ssl zet updfrp zol cll0 hol cll rmfp gam
!   with respect to varying inputs: tau eht gm1 hcc cvw dqq ucu
!                ght hst bet qht qoi qol voi bk2 rasal hcld eta
!                sht gmh rnn qst gms updfrc poi rns uoi vcu rmfd
!                ssl zet updfrp zol cll0 hol cll rmfp gam
!*********************************************************************
    SUBROUTINE CLOUDE_ADM(ic)
      IMPLICIT NONE
!=======================================
      INTEGER, INTENT(IN) :: ic
      REAL :: deep_fact, cu_diam, wscale
!, dQx
      REAL :: cli, te_a, c00_x, cli_crit_x, pete, toki, gmhx, hstx
      REAL :: cli_ad, te_a_ad, c00_x_ad, cli_crit_x_ad, toki_ad, gmhx_ad&
&     , hstx_ad
      REAL :: dt_lyr, rate, cvw_x, closs, f2, f3, f4, f5
      REAL :: dt_lyr_ad, rate_ad, cvw_x_ad, closs_ad, f2_ad
      INTEGER :: k700
!=============================AER_CLOUD local variables ====================
      REAL :: wbase, ndrop, nice, fp_d, ff_a, fp_i, fice, ndrop_amb, &
&     nsoot_amb, nsoot, nin, insoot, dcvw2, qice, dqice, dqig, fpice, &
&     dnice, dndrop, dsoot_amb, dsoot, qliq, dqliq, fprecip, aux, qt, &
&     maxnice, maxndrop, minnice, minndrop, ndrop_act, rimm, fndrim, &
&     tminusta, tparcel, alph_e, beta_e, rh_amb, ecrit
      REAL, DIMENSION(ndustmax) :: ndust, ndust_amb, indust, ddust_amb, &
&     ddust
      INTEGER :: inx, naux, index
      INTRINSIC AMIN1
      INTRINSIC MAX
      INTRINSIC MIN
      INTRINSIC AMAX1
      INTRINSIC SQRT
      INTRINSIC EXP
      REAL :: min1
      REAL :: min1_ad
      REAL :: max1
      REAL :: max1_ad
      REAL :: min2
      REAL :: max2
      REAL :: max2_ad
      LOGICAL, DIMENSION(k-ic+1) :: mask
      REAL :: temp_ad
      REAL :: temp_ad0
      REAL :: temp_ad1
      REAL :: temp_ad2
      REAL :: temp_ad3
      REAL :: temp_ad4
      REAL :: temp_ad5
      REAL :: temp_ad6
      REAL :: temp_ad7
      REAL :: temp
      REAL :: temp0
      REAL :: temp1
      REAL :: temp_ad8
      REAL :: temp_ad9
      REAL :: temp2
      REAL :: temp3
      REAL :: temp_ad10
      REAL :: temp_ad11
      REAL :: temp_ad12
      REAL :: temp4
      REAL :: temp5
      REAL :: temp_ad13
      REAL :: temp_ad14
      REAL :: temp_ad15
      REAL :: temp_ad16
      REAL :: temp_ad17
      REAL :: temp_ad18
      REAL :: temp_ad19
      REAL :: temp_ad20
      REAL :: temp_ad21
      REAL :: temp_ad22
      REAL :: temp_ad23
      REAL :: temp_ad24
      REAL :: temp_ad25
      REAL :: temp_ad26
      REAL :: temp_ad27
      REAL :: temp6
      REAL :: temp_ad28
      REAL :: temp_ad29
      REAL :: temp_ad30
      REAL :: temp_ad31
      REAL :: temp_ad32
      REAL :: temp_ad33
      REAL :: temp_ad34
      REAL :: temp_ad35
      REAL :: temp_ad36
      REAL :: temp_ad37
      REAL :: temp_ad38
      INTEGER :: branch
      REAL :: x4
      REAL :: x3
      REAL :: x2
      REAL :: x1
      REAL :: y1
!A little higher so there is ice at the freezing level
!AER_CLOUD=============================
      IF (1. .GT. (qoi(k)/qst(k)-rhmn)/(rhmx-rhmn)) THEN
        trg = (qoi(k)/qst(k)-rhmn)/(rhmx-rhmn)
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
        trg = 1.
      END IF
      IF (0.0 .LT. (autorampb-sige(ic))/0.2) THEN
        y1 = (autorampb-sige(ic))/0.2
      ELSE
        y1 = 0.0
      END IF
      IF (1.0 .GT. y1) THEN
        f4 = y1
      ELSE
        f4 = 1.0
      END IF
      IF (trg .LE. 1.0e-5) THEN
        trg_ad = 0.0_8
      ELSE
!  RECOMPUTE SOUNDING UP TO DETRAINMENT LEVEL
        poi_c = poi
        qoi_c = qoi
        poi_c(k) = poi_c(k) + tpert(i)
        qoi_c(k) = qoi_c(k) + qpert(i)
        zet(k+1) = 0.
        sht(k+1) = cp*poi_c(k)*prj(k+1)
        DO l=k,ic,-1
          IF (qst(l)*rhmax .GT. qoi_c(l)) THEN
            qol(l) = qoi_c(l)
            CALL PUSHCONTROL1B(0)
          ELSE
            qol(l) = qst(l)*rhmax
            CALL PUSHCONTROL1B(1)
          END IF
          IF (0.000 .LT. qol(l)) THEN
            CALL PUSHCONTROL1B(0)
            qol(l) = qol(l)
          ELSE
            qol(l) = 0.000
            CALL PUSHCONTROL1B(1)
          END IF
          ssl(l) = cp*prj(l+1)*poi_c(l) + grav*zet(l+1)
          hol(l) = ssl(l) + qol(l)*alhl
          hst(l) = ssl(l) + qst(l)*alhl
          tem = poi_c(l)*(prj(l+1)-prj(l))*cpbg
          zet(l) = zet(l+1) + tem
          zol(l) = zet(l+1) + (prj(l+1)-prh(l))*poi_c(l)*cpbg
        END DO
        DO l=ic+1,k
          tem = (prj(l)-prh(l-1))/(prh(l)-prh(l-1))
          sht(l) = ssl(l-1) + tem*(ssl(l)-ssl(l-1))
          qht(l) = .5*(qol(l)+qol(l-1))
        END DO
! SMOOTH HSTAR W/ 1-2-1 Filter
        IF (smooth_hst) THEN
! save for later
          hstx = hst(ic)
          DO l=k-1,ic+1,-1
            hst(l) = 0.25*(hst(l+1)+hst(l-1)) + 0.5*hst(l)
          END DO
          DO l=ic,ic
            hst(l) = 0.5*hst(l+1) + 0.5*hst(l)
          END DO
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!  CALCULATE LAMBDA, ETA, AND WORKFUNCTION
        lambda_min = .2/mxdiam(i)
        lambda_max = .2/diammn_min
!     LAMBDA_MIN = .2/(LAMBDA_FAC*DPTH_BL)
!     LAMBDA_MAX = .2/( MAX( LAMBMX_FAC*DPTH_BL , DIAMMN_MIN ) )
        IF (hol(k) .LE. hst(ic)) THEN
          trg_ad = 0.0_8
          hstx_ad = 0.0_8
        ELSE
!  LAMBDA CALCULATION: MS-A18
          tem = (hst(ic)-hol(ic))*(zol(ic)-zet(ic+1))
          DO l=ic+1,k-1
            tem = tem + (hst(ic)-hol(l))*(zet(l)-zet(l+1))
          END DO
          IF (tem .LE. 0.0) THEN
            trg_ad = 0.0_8
            tem_ad = 0.0_8
            hstx_ad = 0.0_8
          ELSE
            alm = (hol(k)-hst(ic))/tem
            IF (alm .GT. lambda_max) THEN
              trg_ad = 0.0_8
              alm_ad = 0.0_8
              hstx_ad = 0.0_8
            ELSE
!   ALPHA CALCULATION
              rasal2i = rasal2_2d(i)
              IF (zet(ic) .LT. 2000.) THEN
                rasal(ic) = rasal1
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
              IF (zet(ic) .GE. 2000.) THEN
                IF (1.0 .GT. (zet(ic)-2000.)/rasal_slope) THEN
                  min1 = (zet(ic)-2000.)/rasal_slope
                  CALL PUSHCONTROL1B(0)
                ELSE
                  CALL PUSHCONTROL1B(1)
                  min1 = 1.0
                END IF
                rasal(ic) = rasal1 + (rasal2i-rasal1)*min1
                CALL PUSHCONTROL1B(1)
              ELSE
                CALL PUSHCONTROL1B(0)
              END IF
              CALL PUSHREAL8(rasal(ic))
              rasal(ic) = dt/rasal(ic)
              IF (1.0 .GT. (alm/lambda_min)**2) THEN
                toki = (alm/lambda_min)**2
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
                toki = 1.0
              END IF
!   RAS relaxation timescale
              IF (k0 .GT. 96) THEN
!! AMM kluge to run 132 levels for now -- multiply time scale by ratio of number of levels
!! AMM between 900 and 30 mb in 72 and 132 level grids, 0.46
                tau(ic) = toki*trg*rasal(ic)*0.46
                CALL PUSHCONTROL1B(1)
              ELSE
                tau(ic) = toki*trg*rasal(ic)
                CALL PUSHCONTROL1B(0)
              END IF
!IF (TAU(IC) < 1.0E-5) THEN
!   RC(IC) = 6
!   RETURN
!ENDIF
!LAMBDSV(IC) = ALM
!  ETA CALCULATION: MS-A2
              DO l=ic+1,k
                eta(l) = 1.0 + alm*(zet(l)-zet(k))
              END DO
              eta(ic) = 1.0 + alm*(zol(ic)-zet(k))
!  WORKFUNCTION CALCULATION:  MS-A22
              wfn = 0.0
              hcc(k) = hol(k)
              DO l=k-1,ic+1,-1
                hcc(l) = hcc(l+1) + (eta(l)-eta(l+1))*hol(l)
                CALL PUSHREAL8(tem)
                tem = hcc(l+1)*dpb(l) + hcc(l)*dpt(l)
                eht(l) = eta(l+1)*dpb(l) + eta(l)*dpt(l)
                wfn = wfn + (tem-eht(l)*hst(l))*gam(l)
              END DO
              hcc(ic) = hst(ic)*eta(ic)
              wfn = wfn + (hcc(ic+1)-hst(ic)*eta(ic+1))*gam(ic)*dpb(ic)
!  VERTICAL VELOCITY/KE CALCULATION (ADDED 12/2001 JTB)
              bk2(k) = 0.0
              hcld(k) = hol(k)
              DO l=k-1,ic,-1
                CALL PUSHREAL8(hcld(l))
                hcld(l) = (eta(l+1)*hcld(l+1)+(eta(l)-eta(l+1))*hol(l))/&
&                 eta(l)
                CALL PUSHREAL8(tem)
                tem = (hcld(l)-hst(l))*(zet(l)-zet(l+1))/(1.0+lbcp*dqq(l&
&                 ))
                IF (cldmicro .LE. 0.0) THEN
                  IF (tem .LT. 0.0) THEN
                    CALL PUSHREAL8(max1)
                    max1 = 0.0
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    CALL PUSHREAL8(max1)
                    max1 = tem
                    CALL PUSHCONTROL1B(1)
                  END IF
                  bk2(l) = bk2(l+1) + grav*max1/(cp*prj(l+1)*poi(l))
                  IF (bk2(l) .LT. 0.0) THEN
                    CALL PUSHREAL8(max2)
                    max2 = 0.0
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    CALL PUSHREAL8(max2)
                    max2 = bk2(l)
                    CALL PUSHCONTROL1B(1)
                  END IF
                  cvw(l) = SQRT(2.0*max2)
                  CALL PUSHCONTROL1B(1)
                ELSE
                  CALL PUSHCONTROL1B(0)
                END IF
              END DO
              mask(1:k-ic+1) = cvw(ic:k) .LT. 1.00
              WHERE (mask(1:k-ic+1)) 
                cvw(ic:k) = 1.00
              ELSEWHERE
                cvw(ic:k) = cvw(ic:k)
              END WHERE
!  NOTE THIS "CENTRALIZES" A KLUGE PRESENT IN OTHER LOCATIONS.
!  CLEAN UP SOME TIME.      -JTB 12/04/03
!  TEST FOR CRITICAL WORK FUNCTION
              CALL ACRITN(pol(ic), prs(k), acr)
              IF (wfn .LE. acr) THEN
                wfn_ad = 0.0_8
                alm_ad = 0.0_8
                hstx_ad = 0.0_8
              ELSE
                wlq = qol(k)
                uht = uoi(k)
                vht = voi(k)
                rnn(k) = 0.
!print *, '========================================='
                DO l=k-1,ic,-1
                  CALL PUSHREAL8(tem)
                  tem = eta(l) - eta(l+1)
                  wlq = wlq + tem*qol(l)
                  uht = uht + tem*uoi(l)
                  vht = vht + tem*voi(l)
!!!! How much condensate (CLI) is present here?
                  IF (l .GT. ic) THEN
                    tx2 = 0.5*(qst(l)+qst(l-1))*eta(l)
                    CALL PUSHREAL8(tx3)
                    tx3 = 0.5*(hst(l)+hst(l-1))*eta(l)
                    qcc = tx2 + gm1(l)*(hcc(l)-tx3)
                    cll0(l) = wlq - qcc
                    CALL PUSHCONTROL1B(1)
                  ELSE
                    cll0(l) = wlq - qst(ic)*eta(ic)
                    CALL PUSHCONTROL1B(0)
                  END IF
                  IF (cll0(l) .LT. 0.00) THEN
                    cll0(l) = 0.00
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    CALL PUSHCONTROL1B(1)
                    cll0(l) = cll0(l)
                  END IF
! condensate (kg/kg)
                  cli = cll0(l)/eta(l)
! Temperature (K)
                  te_a = poi(l)*prh(l)
!=====================================================================
!            if (CLDMICRO .gt. 0.0) then  !AER_CLOUD MIcrophysics considering activation and nucleation
!recompute vertical velocity
!
!               Tparcel = TE_A
!               CVW(K) = 0.8  ! Assume a below cloud base  W of 0.8 m s-1
!               BK2(K)   = 0.0
!
!     
!               TEM     = (HCLD(L)-HST(L) )/ (1.0+LBCP*DQQ(L))  
!               TminusTa = max(min(TEM/CP, 5.0), 0.0) !limit DT to 5 K. According to Wei, JAS, 1998
!	     TEM =0.33*TminusTa*CO_AUTO(I)/TE_A !Bouyancy term, effciency =0.5 mwr Roode et al
!
!               BK2(L)  = BK2(L+1) + GRAV * TEM*(ZET(L)-ZET(L+1)) 
!               BK2(L) = BK2(L) - (ZET(L)-ZET(L+1))*(BK2(L+1)*ALM + CLI*GRAV)  !Account for drag from entrainment of stagnat air 
!and condesate loading
!               CVW(L) = max(SQRT(  2.0* MAX( BK2(L) , 0.0 )  ), 1.0) 
!
!
!	    CVW_X = MIN(CVW(L), 50.0)
!               DT_LYR  =  max(( ZET(L)-ZET(L+1) )/CVW_X, 1.0) !Sanity check
!               TEM   = ETA(L) - ETA(L+1)
!
!               Tparcel  =  TE_A + TminusTa
!
!
!
!!!!!!!!!!account for entrainment effects on activation !!!!!!!!!!!
!! Barahona and Nenes, JGR, 2007
!               alph_e = 2.8915e-8*Tparcel*Tparcel -2.1328e-5*Tparcel+4.2523e-3
!               beta_e = MAPL_ALHL*TminusTa/MAPL_RVAP/Tparcel/Tparcel
!               RH_AMB=QOI(L)/QST(L)
!               ECRIT  = max(1.0-RH_AMB -beta_e, 1.0e-6) 
!               ECRIT =  alph_e/ECRIT
!! print *, L, Tparcel, RH_AMB, ECRIT, ALM
!	           ECRIT =  ALM/ECRIT
!!Print *, ECRIT
!
!
!               if (L .eq. K-1) then
!
!                  FICE=0.0
!                  NICE=0.0
!                  NDROP=0.0
!                  NIN =0.0
!                  NDUST_AMB =0.0
!                  NSOOT_AMB = 0.0
!                  NSOOT=0.0
!                  NDUST= 0.0
!                  RATE=0.0
!                  FPRECIP=0.0
!
!                  AER_BASE%nmods = 0
!                  AER_BASE%num   = 0.0
!                  do INDEX = 1, AERO(L)%nmods
!                      if (AERO(L)%num(INDEX) > 0.1) then
!                          AER_BASE%nmods = AER_BASE%nmods + 1
!                          naux = AER_BASE%nmods
!
!                          AER_BASE%num(naux)   = AERO(L)%num(INDEX)
!                          AER_BASE%dpg(naux)   = max(AERO(L)%dpg(INDEX), 1.0e-9)
!                          AER_BASE%sig(naux)   = AERO(L)%sig(INDEX)
!                          AER_BASE%den(naux)   = AERO(L)%den(INDEX)
!                          AER_BASE%kap(naux)   = AERO(L)%kap(INDEX)
!                          AER_BASE%fdust(naux) = AERO(L)%fdust(INDEX)
!                          AER_BASE%fsoot(naux) = AERO(L)%fsoot(INDEX)
!                          AER_BASE%forg(naux)  = AERO(L)%forg(INDEX)
!                      end if
!                  end do
!
!!initial conditions
!                  call ARGact(Tparcel, CVW_X, NDROP_ACT, NDROP_AMB, NDUST_AMB, NSOOT_AMB, L,  .true., DDUST_AMB, DSOOT_AMB, ECRI
!T) !cloud droplet number and INsource at cloud base
!                  NDUST=NDUST_AMB
!                  NSOOT=NSOOT_AMB
!                  DDUST=DDUST_AMB
!                  DSOOT=DSOOT_AMB                                     
!
!               else 
!                  call ARGact(Tparcel, CVW_X, NDROP_ACT, NDROP_AMB, NDUST_AMB, NSOOT_AMB, L, .false., DDUST_AMB, DSOOT_AMB, ECRI
!T) !cloud droplet number above cloud base
!
!               end if
!
!               QT = CLI
!               RATE = 0.0
!               FPRECIP = 0.0
!
!               if (QT .gt. 0.0) then
!
!! if FICE is already >= 1.0 then the cloud is glaciated and there is no need to do anymore partitioning
!
!                  if (FICE .ge. 1.0) then
!
!
!                     CALL  Qremoval(RATE, FICE, FP_D, FP_I, Tparcel,  & 
!                           POL(L), QT,  NICE, NDROP, CVW_X, FPICE, &
!                           DT_LYR, RIMM, CO_AUTO(I)) 
!
!
!
!                     dNICE = -NICE*FP_I 
!                     NICE  =  (NICE +dNICE*DT_LYR)*ETA(L+1)/ETA(L) !ice
!
!                     MINNICE = max(QICE*(1.0-RATE*DT_LYR), 0.0)/4.0e-8!assuming maximum vol radius 250 microns
!                     MAXNICE = max(QICE*(1.0-RATE*DT_LYR), 0.0)/2.51e-12 !assuming minimum vol radius 10 microns
!
!                     NICE=MIN(max(NICE, MINNICE), MAXNICE)
!
!                     FICE = 1.0
!
!                  else 
!
!! Cloud is not completely glaciated do the whole thing
!! ALL these subroutines return tendencies
!
!
!                     CALL  INfreezing(QLIQ, NDROP, NIN, NDUST, NSOOT, INDUST, INSOOT, Tparcel, POL(L), CVW_X, DDUST, DSOOT)  !ca
!lculate the freezing fraction of the aerosol at this level
!
!                     NIN = min(NIN, NDROP/DT_LYR)
!
!                     call Qgrowth(Tparcel, POL(L), QICE, NICE, QT, NIN, dQIG, RIMM, FNDRIM)
!
!                     CALL  Qremoval(RATE, FICE, FP_D, FP_I, Tparcel,  & 
!                           POL(L), QT,  NICE, NDROP, CVW_X, FPICE, &
!                           DT_LYR,  RIMM, CO_AUTO(I)) 
!
!
!
!!ice number tendency: -precip + freezin
!                     dNICE = -NICE*FP_I  + NIN     
!                     NICE  =  (NICE +dNICE*DT_LYR)*ETA(L+1)/ETA(L) !ice
!                     NICE =max(NICE, 0.0)
!
!
!!ice mass tendency: growth - precip
!                     dQICE = -QICE*FPICE + dQIG
!                     QICE  =  min((QICE + dQICE*DT_LYR)*ETA(L+1)/ETA(L), QT) !ice
!                     QICE=max(min(QT, QICE), 0.0)
!
!
!! Liquid Tendency: source/evap -  precip
!!dQLIQ = max((CLI-QICE), -QLIQ)/DT_LYR -QLIQ*max(RATE-FPICE, 0.0)
!! dQLIQ = CLI*(1.0-RATE*DT_LYR)/DT_LYR -dQICE - QLIQ*max(RATE-FPICE, 0.0)
!!QLIQ  =  max((QLIQ + dQLIQ*DT_LYR)*ETA(L+1)/ETA(L), 0.0) !liquid. This is actually diagnostic
!                     QLIQ=max((QT-QICE), 0.0)
!
!
!!droplet number tendency: -precip - freezin + activation + activated entrained aerosol
!
!
!                     dNDROP =-NDROP*FP_D - NIN -  FNDRIM*NDROP/DT_LYR + max(NDROP_ACT-NDROP, 0.0)/DT_LYR          
!
!!dNDROP =-NDROP*FP_D - NIN -  FNDRIM*NDROP/DT_LYR + NDROP_ACT/DT_LYR
!
!                     NDROP =  (NDROP + dNDROP*DT_LYR)*ETA(L+1)/ETA(L) + &
!                           (ZET(L) - ZET(L+1))*ALM*MAX((NDROP_AMB-NDROP), 0.0)
!
!!Aerosol tendency: Entrainment - freezing
!
!                     NDUST = (NDUST - INDUST*DT_LYR)*ETA(L+1)/ETA(L) + &
!                           (ZET(L) - ZET(L+1))*ALM*MAX(NDUST_AMB-NDUST, 0.0) 
!
!                     NSOOT =  (NSOOT - INSOOT*DT_LYR)*ETA(L+1)/ETA(L)  + &     
!                           (ZET(L) - ZET(L+1))*ALM*MAX(NSOOT_AMB-NSOOT, 0.0)  
!
!
!                           
!!Update FICE and perform Sanity checks
!
!
!                     MINNDROP = (1.0-FICE)*QLIQ*max(1.0-RATE*DT_LYR, 0.0)/2.e-10    !assuming maximum vol radius 36 microns
!                     MAXNDROP = (1.0-FICE)*QLIQ*max(1.0-RATE*DT_LYR, 0.0)/3.35e-14 !assuming minimum vol radius 2 microns
!                     MINNICE = QICE/4.0e-8!assuming maximum vol radius 250 microns
!                     MAXNICE = QICE/2.51e-12 !assuming minimum vol radius 10 microns
!
!                     IF ((NICE .gt. MAXNICE) .or. (NICE .lt. MINNICE))   then    
!!print *, 'nilim', NICE*1e-6, MINNICE*1e-6, MAXNICE*1e-6
!                     END IF
!
!                     IF ((NDROP .gt. MAXNDROP) .or. (NDROP .lt. MINNDROP))      then 
!!print *, 'ndroplim', NDROP*1e-6, MINNDROP*1e-6, MAXNDROP*1e-6
!                     end if
!
!
!                     NSOOT=MAX(NSOOT, 0.0)
!                     NDUST=MAX(NDUST, 0.0)              
!
!                     NDROP=MIN(max(NDROP, MINNDROP), MAXNDROP)
!                     NICE=MIN(max(NICE, MINNICE), MAXNICE)
!
!                     FICE=max(min(QICE/QT, 1.0), 0.0)
!
!                     IF (FICE .ge. 1.0) THEN !Complete glaciation
!                        NICE=NICE+NDROP 
!                        NDROP = 0.0
!                        QICE  = QT
!                        QLIQ= 0.0
!                     END IF
!
!                     IF (Tparcel .LT. T_ICE_ALL) THEN !instantaneous freezing
!                        NICE=NICE+NDROP 
!                        NDROP = 0.0
!                        FICE  = 1.0
!                        QICE  = QT
!                        QLIQ=0.0
!                     END IF
!
!                     IF (Tparcel .GT. T_ICE_MAX) THEN !instantaneous melting
!                        NDROP=NICE+NDROP 
!                        NICE = 0.0
!                        FICE  = 0.0
!                        QICE  = 0.0
!                        QLIQ=QT
!                     END IF
!
!                  END IF
!
!               else 
!
!                  FICE =0.0 
!                  QICE = 0.0
!                  QLIQ = 0.0
!                  NICE= 0.0 
!                  NDROP = 0.0
!                  RATE =0.0
!               end if
!
!               FPRECIP= RATE*DT_LYR
!
!!RATE=RATE*F4
!! NDROP=NDROP*F4
!!NICE=NICE*(1.0-F4)
!
!!print *, TE_A, FICE, 'NICE', NICE*1e-6, 'NDROP', NDROP*1e-6, L
!!print *, 'FPI', FP_I*DT_LYR, 'FPD', FP_D*DT_LYR, 'FPICE', FPICE, 'FPRE', FPRECIP, QT, QLIQ
!
!            else !Bacmeister 2006 microphysics
                  CALL PUSHREAL8(f3)
                  CALL PUSHREAL8(f2)
                  CALL SUNDQ3_ICE(te_a, sdqv2, sdqv3, sdqvt1, f2, f3)
! * F5  ! F4 reduces AUTO for shallow clouds, F5 modifies auto for deep clouds
                  CALL PUSHREAL8(c00_x)
                  c00_x = co_auto(i)*f2*f3*f4
                  cli_crit_x = cli_crit/(f2*f3)
                  CALL PUSHREAL8(rate)
                  rate = c00_x*(1.0-EXP(-(cli**2/cli_crit_x**2)))
                  IF (cvw(l) .LT. 1.00) THEN
                    CALL PUSHREAL8(cvw_x)
                    cvw_x = 1.00
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    CALL PUSHREAL8(cvw_x)
                    cvw_x = cvw(l)
                    CALL PUSHCONTROL1B(1)
                  END IF
! really trust it at low values
! l.h.s. DT_LYR => time in layer (L,L+1)
                  dt_lyr = (zet(l)-zet(l+1))/cvw_x
                  closs = cll0(l)*rate*dt_lyr
                  IF (closs .GT. cll0(l)) THEN
                    closs = cll0(l)
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    closs = closs
                    CALL PUSHCONTROL1B(1)
                  END IF
                  IF (closs .GT. 0.) THEN
                    wlq = wlq - closs
                    rnn(l) = closs
                    CALL PUSHCONTROL1B(1)
                  ELSE
                    rnn(l) = 0.
                    CALL PUSHCONTROL1B(0)
                  END IF
                END DO
!AER_CLOUD=======================================
!            CNVNDROP(IC)=NDROP
!            CNVNICE(IC)=NICE
!            CNVFICE(IC)=FICE
                wlq = wlq - qst(ic)*eta(ic)
!     CALCULATE GAMMAS AND KERNEL
! MS-A30 (W/O GRAV)
                gms(k) = (sht(k)-ssl(k))*pri(k)
! MS-A31 (W/O GRAV)
                gmh(k) = gms(k) + (qht(k)-qol(k))*pri(k)*alhl
! MS-A37 (W/O GRAV)
                akm = gmh(k)*gam(k-1)*dpb(k-1)
                tx2 = gmh(k)
                DO l=k-1,ic+1,-1
                  gms(l) = (eta(l)*(sht(l)-ssl(l))+eta(l+1)*(ssl(l)-sht(&
&                   l+1)))*pri(l)
                  CALL PUSHREAL8(gmh(l))
                  gmh(l) = gms(l) + (eta(l)*(qht(l)-qol(l))+eta(l+1)*(&
&                   qol(l)-qht(l+1)))*alhl*pri(l)
                  CALL PUSHREAL8(tx2)
                  tx2 = tx2 + (eta(l)-eta(l+1))*gmh(l)
                  akm = akm - gms(l)*eht(l)*pki(l) + tx2*ght(l)
                END DO
                CALL PUSHREAL8(gms(ic))
                gms(ic) = eta(ic+1)*(ssl(ic)-sht(ic+1))*pri(ic)
                akm = akm - gms(ic)*eta(ic+1)*dpb(ic)*pki(ic)
                CALL PUSHREAL8(gmh(ic))
                gmh(ic) = gms(ic) + (eta(ic+1)*(qol(ic)-qht(ic+1))*alhl+&
&                 eta(ic)*(hst(ic)-hol(ic)))*pri(ic)
                IF (smooth_hst) THEN
                  gmhx = gms(ic) + (eta(ic+1)*(qol(ic)-qht(ic+1))*alhl+&
&                   eta(ic)*(hstx-hol(ic)))*pri(ic)
                  CALL PUSHCONTROL1B(0)
                ELSE
                  CALL PUSHCONTROL1B(1)
                END IF
!    CLOUD BASE MASS FLUX
                IF (akm .GE. 0.0 .OR. wlq .LT. 0.0) THEN
                  wlq_ad = 0.0_8
                  wfn_ad = 0.0_8
                  vht_ad = 0.0_8
                  akm_ad = 0.0_8
                  alm_ad = 0.0_8
                  uht_ad = 0.0_8
                  gmhx_ad = 0.0_8
                ELSE
! MS-A39 MASS-FLUX IN Pa/step
                  CALL PUSHREAL8(wfn)
                  wfn = -((wfn-acr)/akm)
! WMP Store the full mass-flux to use in efficiency diagnostic
                  IF (tau(ic)*wfn .GT. (prs(k+1)-prs(k))*(100.*pblfrac)&
&                 ) THEN
                    wfn = (prs(k+1)-prs(k))*(100.*pblfrac)
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    CALL PUSHREAL8(wfn)
                    wfn = tau(ic)*wfn
                    CALL PUSHCONTROL1B(1)
                  END IF
!! WMP RAS DIAGNOSTICS that make up TAU(IC)
! Fill the RAS timescale diagnostic
! Fill the RAS RH trigger diagnostic
! Fill the RAS Tokioka diagnostic
! Fill the RAS PBL fraction diagnostic
! Fill the RAS efficiency diagnostic
! RAS_EFFICIENCY(I) = WFN/RAS_EFFICIENCY(I)
!! WMP RAS DIAGNOSTICS
!    CUMULATIVE PRECIP AND CLOUD-BASE MASS FLUX FOR OUTPUT
                  CALL PUSHREAL8(tem)
                  tem = wfn*gravi
! (kg/m^2/step)
! (kg/m^2/step)
! (kg/m^2/step)
                  DO l=ic+1,k
! (kg/m^2/step)
                    rmfp(l) = tem*eta(l)
! (kg/m^2/step)
                    IF (cvw(l) .GT. 0.0) THEN
                      CALL PUSHCONTROL1B(0)
                    ELSE
                      CALL PUSHCONTROL1B(1)
                    END IF
                  END DO
!    THETA AND Q CHANGE DUE TO CLOUD TYPE IC
                  DO l=ic,k
! (kg/m^2/step)
                    CALL PUSHREAL8(gms(l))
                    gms(l) = gms(l)*wfn
                  END DO
                  IF (smooth_hst) THEN
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    CALL PUSHCONTROL1B(1)
                  END IF
                  IF (do_tracers) THEN
!*FRICFAC*0.5
                    CALL PUSHREAL8(wfn)
                    wfn = wfn*0.5*1.0
                    CALL PUSHCONTROL1B(0)
                  ELSE
!*FRICFAC*0.5
                    CALL PUSHREAL8(wfn)
                    wfn = wfn*0.5*1.0
                    CALL PUSHCONTROL1B(1)
                  END IF
!   CUMULUS FRICTION
                  IF (fricfac .LE. 0.0) THEN
                    wfn_ad = 0.0_8
                    vht_ad = 0.0_8
                    alm_ad = 0.0_8
                    uht_ad = 0.0_8
                  ELSE
                    CALL PUSHREAL8(wfn)
                    wfn = wfn*fricfac*EXP(-(alm/friclambda))
                    CALL PUSHREAL8(tem)
                    tem = wfn*pri(ic)
                    l = k + 1
                    DO l=k,ic,-1
                      vcu_ad(l) = vcu_ad(l) + voi_ad(l)
                      ucu_ad(l) = ucu_ad(l) + uoi_ad(l)
                    END DO
                    temp_ad33 = tem*vcu_ad(ic)
                    temp_ad34 = 2.*temp_ad33
                    temp_ad35 = -(eta(ic+1)*temp_ad33)
                    vht_ad = temp_ad34
                    voi_ad(ic) = voi_ad(ic) + temp_ad35 - (eta(ic)-eta(&
&                     ic+1))*temp_ad34
                    eta_ad(ic) = eta_ad(ic) - voi(ic)*temp_ad34
                    eta_ad(ic+1) = eta_ad(ic+1) + voi(ic)*temp_ad34 - (&
&                     voi(ic)+voi(ic+1))*temp_ad33
                    voi_ad(ic+1) = voi_ad(ic+1) + temp_ad35
                    tem_ad = (2.*(uht-uoi(ic)*(eta(ic)-eta(ic+1)))-(uoi(&
&                     ic)+uoi(ic+1))*eta(ic+1))*ucu_ad(ic) + (2.*(vht-&
&                     voi(ic)*(eta(ic)-eta(ic+1)))-(voi(ic)+voi(ic+1))*&
&                     eta(ic+1))*vcu_ad(ic)
                    temp_ad36 = tem*ucu_ad(ic)
                    temp_ad37 = 2.*temp_ad36
                    temp_ad38 = -(eta(ic+1)*temp_ad36)
                    uht_ad = temp_ad37
                    uoi_ad(ic) = uoi_ad(ic) + temp_ad38 - (eta(ic)-eta(&
&                     ic+1))*temp_ad37
                    eta_ad(ic) = eta_ad(ic) - uoi(ic)*temp_ad37
                    eta_ad(ic+1) = eta_ad(ic+1) + uoi(ic)*temp_ad37 - (&
&                     uoi(ic)+uoi(ic+1))*temp_ad36
                    uoi_ad(ic+1) = uoi_ad(ic+1) + temp_ad38
                    wfn_ad = pri(ic)*tem_ad
                    DO l=ic+1,k-1,1
                      tem = wfn*pri(l)
                      temp_ad29 = tem*vcu_ad(l)
                      temp_ad30 = eta(l+1)*temp_ad29
                      tem_ad = ((uoi(l-1)-uoi(l))*eta(l)+(uoi(l)-uoi(l+1&
&                       ))*eta(l+1))*ucu_ad(l) + ((voi(l-1)-voi(l))*eta(&
&                       l)+(voi(l)-voi(l+1))*eta(l+1))*vcu_ad(l)
                      voi_ad(l-1) = voi_ad(l-1) + eta(l)*temp_ad29
                      voi_ad(l) = voi_ad(l) + temp_ad30 - eta(l)*&
&                       temp_ad29
                      eta_ad(l) = eta_ad(l) + (voi(l-1)-voi(l))*&
&                       temp_ad29
                      voi_ad(l+1) = voi_ad(l+1) - temp_ad30
                      eta_ad(l+1) = eta_ad(l+1) + (voi(l)-voi(l+1))*&
&                       temp_ad29
                      temp_ad31 = tem*ucu_ad(l)
                      temp_ad32 = eta(l+1)*temp_ad31
                      uoi_ad(l-1) = uoi_ad(l-1) + eta(l)*temp_ad31
                      uoi_ad(l) = uoi_ad(l) + temp_ad32 - eta(l)*&
&                       temp_ad31
                      eta_ad(l) = eta_ad(l) + (uoi(l-1)-uoi(l))*&
&                       temp_ad31
                      uoi_ad(l+1) = uoi_ad(l+1) - temp_ad32
                      eta_ad(l+1) = eta_ad(l+1) + (uoi(l)-uoi(l+1))*&
&                       temp_ad31
                      wfn_ad = wfn_ad + pri(l)*tem_ad
                    END DO
                    tem = wfn*pri(k)
                    tem_ad = (uoi(k-1)-uoi(k))*ucu_ad(k) + (voi(k-1)-voi&
&                     (k))*vcu_ad(k)
                    voi_ad(k-1) = voi_ad(k-1) + tem*vcu_ad(k)
                    voi_ad(k) = voi_ad(k) - tem*vcu_ad(k)
                    uoi_ad(k-1) = uoi_ad(k-1) + tem*ucu_ad(k)
                    uoi_ad(k) = uoi_ad(k) - tem*ucu_ad(k)
                    CALL POPREAL8(tem)
                    wfn_ad = wfn_ad + pri(k)*tem_ad
                    CALL POPREAL8(wfn)
                    alm_ad = -(EXP(-(alm/friclambda))*wfn*fricfac*wfn_ad&
&                     /friclambda)
                    wfn_ad = fricfac*EXP(-(alm/friclambda))*wfn_ad
                  END IF
                  CALL POPCONTROL1B(branch)
                  IF (branch .EQ. 0) THEN
                    CALL POPREAL8(wfn)
                    wfn_ad = 0.5*wfn_ad
                  ELSE
                    CALL POPREAL8(wfn)
                    wfn_ad = 0.5*wfn_ad
                  END IF
                  CALL POPCONTROL1B(branch)
                  IF (branch .EQ. 0) THEN
                    dqx_ad = rns_ad(ic)/(pri(ic)*grav)
                    gmhx_ad = alhi*dqx_ad
                    gmh_ad(ic) = gmh_ad(ic) - alhi*dqx_ad
                    wfn_ad = wfn_ad + gmhx*gmhx_ad
                    gmhx_ad = wfn*gmhx_ad
                  ELSE
                    gmhx_ad = 0.0_8
                  END IF
                  tem_ad = 0.0_8
                  DO l=k,ic,-1
                    gms_ad(l) = gms_ad(l) + pki(l)*cpi*poi_ad(l) - alhi*&
&                     qoi_ad(l) + cpi*bet(l)*qst_ad(l)
                    bet_ad(l) = bet_ad(l) + cpi*gms(l)*qst_ad(l)
                    gmh_ad(l) = gmh_ad(l) + alhi*qoi_ad(l)
                    CALL POPREAL8(gms(l))
                    wfn_ad = wfn_ad + gmh(l)*gmh_ad(l) + gms(l)*gms_ad(l&
&                     )
                    gms_ad(l) = wfn*gms_ad(l)
                    gmh_ad(l) = wfn*gmh_ad(l)
                    rnn_ad(l) = rnn_ad(l) + tem*rns_ad(l)
                    tem_ad = tem_ad + rnn(l)*rns_ad(l)
                  END DO
                  DO l=k,ic+1,-1
                    updfrp_ad(l) = updfrp_ad(l) + updfrc_ad(l)
                    CALL POPCONTROL1B(branch)
                    IF (branch .EQ. 0) THEN
                      temp6 = daylen*prs(l)*cvw(l)
                      temp_ad28 = ddt*1000.*updfrp_ad(l)/temp6
                      rmfp_ad(l) = rmfp_ad(l) + temp_ad28
                      cvw_ad(l) = cvw_ad(l) - rmfp(l)*daylen*prs(l)*&
&                       temp_ad28/temp6
                      updfrp_ad(l) = 0.0_8
                    ELSE
                      updfrp_ad(l) = 0.0_8
                    END IF
                    tem_ad = tem_ad + eta(l)*rmfp_ad(l)
                    eta_ad(l) = eta_ad(l) + tem*rmfp_ad(l)
                    rmfp_ad(l) = 0.0_8
                  END DO
                  tem_ad = tem_ad + wlq*cll_ad(ic) + eta(ic)*rmfd_ad(ic)
                  eta_ad(ic) = eta_ad(ic) + tem*rmfd_ad(ic)
                  wlq_ad = tem*cll_ad(ic)
                  CALL POPREAL8(tem)
                  wfn_ad = wfn_ad + gravi*tem_ad
                  CALL POPCONTROL1B(branch)
                  IF (branch .EQ. 0) THEN
                    wfn_ad = 0.0_8
                  ELSE
                    CALL POPREAL8(wfn)
                    tau_ad(ic) = tau_ad(ic) + wfn*wfn_ad
                    wfn_ad = tau(ic)*wfn_ad
                  END IF
                  CALL POPREAL8(wfn)
                  akm_ad = (wfn-acr)*wfn_ad/akm**2
                  wfn_ad = -(wfn_ad/akm)
                END IF
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  temp_ad26 = pri(ic)*gmhx_ad
                  temp_ad27 = alhl*eta(ic+1)*temp_ad26
                  gms_ad(ic) = gms_ad(ic) + gmhx_ad
                  eta_ad(ic+1) = eta_ad(ic+1) + alhl*(qol(ic)-qht(ic+1))&
&                   *temp_ad26
                  qol_ad(ic) = qol_ad(ic) + temp_ad27
                  qht_ad(ic+1) = qht_ad(ic+1) - temp_ad27
                  eta_ad(ic) = eta_ad(ic) + (hstx-hol(ic))*temp_ad26
                  hstx_ad = eta(ic)*temp_ad26
                  hol_ad(ic) = hol_ad(ic) - eta(ic)*temp_ad26
                ELSE
                  hstx_ad = 0.0_8
                END IF
                temp_ad24 = -(dpb(ic)*pki(ic)*akm_ad)
                CALL POPREAL8(gmh(ic))
                temp_ad22 = pri(ic)*gmh_ad(ic)
                temp_ad23 = alhl*eta(ic+1)*temp_ad22
                gms_ad(ic) = gms_ad(ic) + eta(ic+1)*temp_ad24 + gmh_ad(&
&                 ic)
                eta_ad(ic+1) = eta_ad(ic+1) + alhl*(qol(ic)-qht(ic+1))*&
&                 temp_ad22
                qol_ad(ic) = qol_ad(ic) + temp_ad23
                qht_ad(ic+1) = qht_ad(ic+1) - temp_ad23
                eta_ad(ic) = eta_ad(ic) + (hst(ic)-hol(ic))*temp_ad22
                hst_ad(ic) = hst_ad(ic) + eta(ic)*temp_ad22
                hol_ad(ic) = hol_ad(ic) - eta(ic)*temp_ad22
                gmh_ad(ic) = 0.0_8
                eta_ad(ic+1) = eta_ad(ic+1) + pri(ic)*(ssl(ic)-sht(ic+1)&
&                 )*gms_ad(ic) + gms(ic)*temp_ad24
                CALL POPREAL8(gms(ic))
                temp_ad25 = pri(ic)*eta(ic+1)*gms_ad(ic)
                ssl_ad(ic) = ssl_ad(ic) + temp_ad25
                sht_ad(ic+1) = sht_ad(ic+1) - temp_ad25
                gms_ad(ic) = 0.0_8
                tx2_ad = 0.0_8
                DO l=ic+1,k-1,1
                  tx2_ad = tx2_ad + ght(l)*akm_ad
                  gmh_ad(l) = gmh_ad(l) + (eta(l)-eta(l+1))*tx2_ad
                  gms_ad(l) = gms_ad(l) + gmh_ad(l) - pki(l)*eht(l)*&
&                   akm_ad
                  eht_ad(l) = eht_ad(l) - pki(l)*gms(l)*akm_ad
                  ght_ad(l) = ght_ad(l) + tx2*akm_ad
                  CALL POPREAL8(tx2)
                  eta_ad(l) = eta_ad(l) + gmh(l)*tx2_ad
                  eta_ad(l+1) = eta_ad(l+1) - gmh(l)*tx2_ad
                  CALL POPREAL8(gmh(l))
                  temp_ad18 = alhl*pri(l)*gmh_ad(l)
                  temp_ad19 = eta(l+1)*temp_ad18
                  eta_ad(l) = eta_ad(l) + (qht(l)-qol(l))*temp_ad18
                  qht_ad(l) = qht_ad(l) + eta(l)*temp_ad18
                  qol_ad(l) = qol_ad(l) + temp_ad19 - eta(l)*temp_ad18
                  eta_ad(l+1) = eta_ad(l+1) + (qol(l)-qht(l+1))*&
&                   temp_ad18
                  qht_ad(l+1) = qht_ad(l+1) - temp_ad19
                  gmh_ad(l) = 0.0_8
                  temp_ad20 = pri(l)*gms_ad(l)
                  temp_ad21 = eta(l+1)*temp_ad20
                  eta_ad(l) = eta_ad(l) + (sht(l)-ssl(l))*temp_ad20
                  sht_ad(l) = sht_ad(l) + eta(l)*temp_ad20
                  ssl_ad(l) = ssl_ad(l) + temp_ad21 - eta(l)*temp_ad20
                  eta_ad(l+1) = eta_ad(l+1) + (ssl(l)-sht(l+1))*&
&                   temp_ad20
                  sht_ad(l+1) = sht_ad(l+1) - temp_ad21
                  gms_ad(l) = 0.0_8
                END DO
                temp_ad16 = dpb(k-1)*akm_ad
                gmh_ad(k) = gmh_ad(k) + gam(k-1)*temp_ad16 + tx2_ad
                gam_ad(k-1) = gam_ad(k-1) + gmh(k)*temp_ad16
                temp_ad17 = pri(k)*alhl*gmh_ad(k)
                gms_ad(k) = gms_ad(k) + gmh_ad(k)
                qht_ad(k) = qht_ad(k) + temp_ad17
                qol_ad(k) = qol_ad(k) - temp_ad17
                gmh_ad(k) = 0.0_8
                sht_ad(k) = sht_ad(k) + pri(k)*gms_ad(k)
                ssl_ad(k) = ssl_ad(k) - pri(k)*gms_ad(k)
                gms_ad(k) = 0.0_8
                qst_ad(ic) = qst_ad(ic) - eta(ic)*wlq_ad
                eta_ad(ic) = eta_ad(ic) - qst(ic)*wlq_ad
                f2_ad = 0.0_8
                DO l=ic,k-1,1
                  CALL POPCONTROL1B(branch)
                  IF (branch .EQ. 0) THEN
                    rnn_ad(l) = 0.0_8
                    closs_ad = 0.0_8
                  ELSE
                    closs_ad = rnn_ad(l) - wlq_ad
                    rnn_ad(l) = 0.0_8
                  END IF
                  closs_ad = closs_ad - cll0_ad(l)
                  CALL POPCONTROL1B(branch)
                  IF (branch .EQ. 0) THEN
                    dt_lyr = (zet(l)-zet(l+1))/cvw_x
                    cll0_ad(l) = cll0_ad(l) + closs_ad
                    closs_ad = 0.0_8
                  ELSE
                    dt_lyr = (zet(l)-zet(l+1))/cvw_x
                  END IF
                  cll0_ad(l) = cll0_ad(l) + rate*dt_lyr*closs_ad
                  rate_ad = cll0(l)*dt_lyr*closs_ad
                  dt_lyr_ad = cll0(l)*rate*closs_ad
                  temp_ad15 = dt_lyr_ad/cvw_x
                  zet_ad(l) = zet_ad(l) + temp_ad15
                  zet_ad(l+1) = zet_ad(l+1) - temp_ad15
                  cvw_x_ad = -((zet(l)-zet(l+1))*temp_ad15/cvw_x)
                  CALL POPCONTROL1B(branch)
                  IF (branch .EQ. 0) THEN
                    CALL POPREAL8(cvw_x)
                  ELSE
                    CALL POPREAL8(cvw_x)
                    cvw_ad(l) = cvw_ad(l) + cvw_x_ad
                  END IF
                  cli_crit_x = cli_crit/(f2*f3)
                  cli = cll0(l)/eta(l)
                  CALL POPREAL8(rate)
                  temp5 = cli_crit_x**2
                  temp4 = cli**2/temp5
                  temp_ad13 = EXP(-temp4)*c00_x*rate_ad/temp5
                  c00_x_ad = (1.0-EXP(-temp4))*rate_ad
                  cli_ad = 2*cli*temp_ad13
                  cli_crit_x_ad = -(temp4*2*cli_crit_x*temp_ad13)
                  f2_ad = f2_ad + f3*f4*co_auto(i)*c00_x_ad - cli_crit*&
&                   cli_crit_x_ad/(f3*f2**2)
                  CALL POPREAL8(c00_x)
                  te_a = poi(l)*prh(l)
                  CALL POPREAL8(f2)
                  CALL POPREAL8(f3)
                  CALL SUNDQ3_ICE_ADM(te_a, te_a_ad, sdqv2, sdqv3, &
&                               sdqvt1, f2, f2_ad, f3)
                  poi_ad(l) = poi_ad(l) + prh(l)*te_a_ad
                  temp_ad14 = cli_ad/eta(l)
                  cll0_ad(l) = cll0_ad(l) + temp_ad14
                  eta_ad(l) = eta_ad(l) - cll0(l)*temp_ad14/eta(l)
                  CALL POPCONTROL1B(branch)
                  IF (branch .EQ. 0) cll0_ad(l) = 0.0_8
                  CALL POPCONTROL1B(branch)
                  IF (branch .EQ. 0) THEN
                    wlq_ad = wlq_ad + cll0_ad(l)
                    qst_ad(ic) = qst_ad(ic) - eta(ic)*cll0_ad(l)
                    eta_ad(ic) = eta_ad(ic) - qst(ic)*cll0_ad(l)
                    cll0_ad(l) = 0.0_8
                  ELSE
                    wlq_ad = wlq_ad + cll0_ad(l)
                    qcc_ad = -cll0_ad(l)
                    cll0_ad(l) = 0.0_8
                    tx2_ad = qcc_ad
                    gm1_ad(l) = gm1_ad(l) + (hcc(l)-tx3)*qcc_ad
                    hcc_ad(l) = hcc_ad(l) + gm1(l)*qcc_ad
                    tx3_ad = -(gm1(l)*qcc_ad)
                    CALL POPREAL8(tx3)
                    temp_ad11 = 0.5*eta(l)*tx3_ad
                    hst_ad(l) = hst_ad(l) + temp_ad11
                    hst_ad(l-1) = hst_ad(l-1) + temp_ad11
                    eta_ad(l) = eta_ad(l) + 0.5*(qst(l)+qst(l-1))*tx2_ad&
&                     + 0.5*(hst(l)+hst(l-1))*tx3_ad
                    temp_ad12 = 0.5*eta(l)*tx2_ad
                    qst_ad(l) = qst_ad(l) + temp_ad12
                    qst_ad(l-1) = qst_ad(l-1) + temp_ad12
                  END IF
                  tem = eta(l) - eta(l+1)
                  tem_ad = uoi(l)*uht_ad + qol(l)*wlq_ad + voi(l)*vht_ad
                  voi_ad(l) = voi_ad(l) + tem*vht_ad
                  uoi_ad(l) = uoi_ad(l) + tem*uht_ad
                  qol_ad(l) = qol_ad(l) + tem*wlq_ad
                  CALL POPREAL8(tem)
                  eta_ad(l) = eta_ad(l) + tem_ad
                  eta_ad(l+1) = eta_ad(l+1) - tem_ad
                END DO
                cll0_ad(k) = 0.0_8
                rnn_ad(k) = 0.0_8
                voi_ad(k) = voi_ad(k) + vht_ad
                uoi_ad(k) = uoi_ad(k) + uht_ad
                qol_ad(k) = qol_ad(k) + wlq_ad
              END IF
              WHERE (mask(1:k-ic+1)) cvw_ad(ic:k) = 0.0_8
              DO l=ic,k-1,1
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  tem_ad = 0.0_8
                ELSE
                  IF (2.0*max2 .EQ. 0.0_8) THEN
                    max2_ad = 0.0
                  ELSE
                    max2_ad = cvw_ad(l)/SQRT(2.0*max2)
                  END IF
                  cvw_ad(l) = 0.0_8
                  CALL POPCONTROL1B(branch)
                  IF (branch .EQ. 0) THEN
                    CALL POPREAL8(max2)
                  ELSE
                    CALL POPREAL8(max2)
                    bk2_ad(l) = bk2_ad(l) + max2_ad
                  END IF
                  temp3 = cp*prj(l+1)
                  temp2 = temp3*poi(l)
                  temp_ad10 = grav*bk2_ad(l)/temp2
                  bk2_ad(l+1) = bk2_ad(l+1) + bk2_ad(l)
                  max1_ad = temp_ad10
                  poi_ad(l) = poi_ad(l) - max1*temp3*temp_ad10/temp2
                  bk2_ad(l) = 0.0_8
                  CALL POPCONTROL1B(branch)
                  IF (branch .EQ. 0) THEN
                    CALL POPREAL8(max1)
                    tem_ad = 0.0_8
                  ELSE
                    CALL POPREAL8(max1)
                    tem_ad = max1_ad
                  END IF
                END IF
                CALL POPREAL8(tem)
                temp1 = lbcp*dqq(l) + 1.0
                temp_ad8 = tem_ad/temp1
                temp0 = zet(l) - zet(l+1)
                temp = hcld(l) - hst(l)
                hcld_ad(l) = hcld_ad(l) + temp0*temp_ad8
                hst_ad(l) = hst_ad(l) - temp0*temp_ad8
                zet_ad(l) = zet_ad(l) + temp*temp_ad8
                zet_ad(l+1) = zet_ad(l+1) - temp*temp_ad8
                dqq_ad(l) = dqq_ad(l) - temp*temp0*lbcp*temp_ad8/temp1
                CALL POPREAL8(hcld(l))
                temp_ad9 = hcld_ad(l)/eta(l)
                eta_ad(l+1) = eta_ad(l+1) + (hcld(l+1)-hol(l))*temp_ad9
                hcld_ad(l+1) = hcld_ad(l+1) + eta(l+1)*temp_ad9
                eta_ad(l) = eta_ad(l) + (hol(l)-(eta(l+1)*hcld(l+1)+(eta&
&                 (l)-eta(l+1))*hol(l))/eta(l))*temp_ad9
                hol_ad(l) = hol_ad(l) + (eta(l)-eta(l+1))*temp_ad9
                hcld_ad(l) = 0.0_8
              END DO
              hol_ad(k) = hol_ad(k) + hcld_ad(k)
              hcld_ad(k) = 0.0_8
              bk2_ad(k) = 0.0_8
              temp_ad7 = dpb(ic)*gam(ic)*wfn_ad
              hcc_ad(ic+1) = hcc_ad(ic+1) + temp_ad7
              hst_ad(ic) = hst_ad(ic) + eta(ic)*hcc_ad(ic) - eta(ic+1)*&
&               temp_ad7
              eta_ad(ic+1) = eta_ad(ic+1) - hst(ic)*temp_ad7
              gam_ad(ic) = gam_ad(ic) + dpb(ic)*(hcc(ic+1)-hst(ic)*eta(&
&               ic+1))*wfn_ad
              eta_ad(ic) = eta_ad(ic) + hst(ic)*hcc_ad(ic)
              hcc_ad(ic) = 0.0_8
              DO l=ic+1,k-1,1
                temp_ad6 = gam(l)*wfn_ad
                tem_ad = temp_ad6
                eht_ad(l) = eht_ad(l) - hst(l)*temp_ad6
                hst_ad(l) = hst_ad(l) - eht(l)*temp_ad6
                gam_ad(l) = gam_ad(l) + (tem-eht(l)*hst(l))*wfn_ad
                eta_ad(l+1) = eta_ad(l+1) + dpb(l)*eht_ad(l)
                CALL POPREAL8(tem)
                hcc_ad(l+1) = hcc_ad(l+1) + dpb(l)*tem_ad
                hcc_ad(l) = hcc_ad(l) + dpt(l)*tem_ad
                hcc_ad(l+1) = hcc_ad(l+1) + hcc_ad(l)
                eta_ad(l) = eta_ad(l) + hol(l)*hcc_ad(l) + dpt(l)*eht_ad&
&                 (l)
                eht_ad(l) = 0.0_8
                eta_ad(l+1) = eta_ad(l+1) - hol(l)*hcc_ad(l)
                hol_ad(l) = hol_ad(l) + (eta(l)-eta(l+1))*hcc_ad(l)
                hcc_ad(l) = 0.0_8
              END DO
              hol_ad(k) = hol_ad(k) + hcc_ad(k)
              hcc_ad(k) = 0.0_8
              alm_ad = alm_ad + (zol(ic)-zet(k))*eta_ad(ic)
              zol_ad(ic) = zol_ad(ic) + alm*eta_ad(ic)
              zet_ad(k) = zet_ad(k) - alm*eta_ad(ic)
              eta_ad(ic) = 0.0_8
              DO l=k,ic+1,-1
                alm_ad = alm_ad + (zet(l)-zet(k))*eta_ad(l)
                zet_ad(l) = zet_ad(l) + alm*eta_ad(l)
                zet_ad(k) = zet_ad(k) - alm*eta_ad(l)
                eta_ad(l) = 0.0_8
              END DO
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                toki_ad = rasal(ic)*trg*tau_ad(ic)
                trg_ad = rasal(ic)*toki*tau_ad(ic)
                rasal_ad(ic) = rasal_ad(ic) + toki*trg*tau_ad(ic)
                tau_ad(ic) = 0.0_8
              ELSE
                temp_ad5 = 0.46*rasal(ic)*tau_ad(ic)
                toki_ad = trg*temp_ad5
                trg_ad = toki*temp_ad5
                rasal_ad(ic) = rasal_ad(ic) + 0.46*toki*trg*tau_ad(ic)
                tau_ad(ic) = 0.0_8
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) alm_ad = alm_ad + 2*alm*toki_ad/&
&                 lambda_min**2
              CALL POPREAL8(rasal(ic))
              rasal_ad(ic) = -(dt*rasal_ad(ic)/rasal(ic)**2)
              CALL POPCONTROL1B(branch)
              IF (branch .NE. 0) THEN
                min1_ad = (rasal2i-rasal1)*rasal_ad(ic)
                rasal_ad(ic) = 0.0_8
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) zet_ad(ic) = zet_ad(ic) + min1_ad/&
&                   rasal_slope
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) rasal_ad(ic) = 0.0_8
            END IF
            temp_ad4 = alm_ad/tem
            hol_ad(k) = hol_ad(k) + temp_ad4
            hst_ad(ic) = hst_ad(ic) - temp_ad4
            tem_ad = -((hol(k)-hst(ic))*temp_ad4/tem)
          END IF
          DO l=k-1,ic+1,-1
            temp_ad2 = (zet(l)-zet(l+1))*tem_ad
            temp_ad3 = (hst(ic)-hol(l))*tem_ad
            hst_ad(ic) = hst_ad(ic) + temp_ad2
            hol_ad(l) = hol_ad(l) - temp_ad2
            zet_ad(l) = zet_ad(l) + temp_ad3
            zet_ad(l+1) = zet_ad(l+1) - temp_ad3
          END DO
          temp_ad0 = (zol(ic)-zet(ic+1))*tem_ad
          temp_ad1 = (hst(ic)-hol(ic))*tem_ad
          hst_ad(ic) = hst_ad(ic) + temp_ad0
          hol_ad(ic) = hol_ad(ic) - temp_ad0
          zol_ad(ic) = zol_ad(ic) + temp_ad1
          zet_ad(ic+1) = zet_ad(ic+1) - temp_ad1
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          DO l=ic,ic,-1
            hst_ad(l+1) = hst_ad(l+1) + 0.5*hst_ad(l)
            hst_ad(l) = 0.5*hst_ad(l)
          END DO
          DO l=ic+1,k-1,1
            hst_ad(l+1) = hst_ad(l+1) + 0.25*hst_ad(l)
            hst_ad(l-1) = hst_ad(l-1) + 0.25*hst_ad(l)
            hst_ad(l) = 0.5*hst_ad(l)
          END DO
          hst_ad(ic) = hst_ad(ic) + hstx_ad
        END IF
        DO l=k,ic+1,-1
          qol_ad(l) = qol_ad(l) + .5*qht_ad(l)
          qol_ad(l-1) = qol_ad(l-1) + .5*qht_ad(l)
          qht_ad(l) = 0.0_8
          tem = (prj(l)-prh(l-1))/(prh(l)-prh(l-1))
          ssl_ad(l-1) = ssl_ad(l-1) + (1.0-tem)*sht_ad(l)
          ssl_ad(l) = ssl_ad(l) + tem*sht_ad(l)
          sht_ad(l) = 0.0_8
        END DO
        poi_c_ad = 0.0_8
        qoi_c_ad = 0.0_8
        DO l=ic,k,1
          ssl_ad(l) = ssl_ad(l) + hol_ad(l) + hst_ad(l)
          zet_ad(l+1) = zet_ad(l+1) + zet_ad(l) + zol_ad(l)
          tem_ad = zet_ad(l)
          poi_c_ad(l) = poi_c_ad(l) + (prj(l+1)-prj(l))*cpbg*tem_ad + &
&           prj(l+1)*cp*ssl_ad(l) + (prj(l+1)-prh(l))*cpbg*zol_ad(l)
          zol_ad(l) = 0.0_8
          zet_ad(l) = 0.0_8
          qst_ad(l) = qst_ad(l) + alhl*hst_ad(l)
          hst_ad(l) = 0.0_8
          qol_ad(l) = qol_ad(l) + alhl*hol_ad(l)
          hol_ad(l) = 0.0_8
          zet_ad(l+1) = zet_ad(l+1) + grav*ssl_ad(l)
          ssl_ad(l) = 0.0_8
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) qol_ad(l) = 0.0_8
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            qoi_c_ad(l) = qoi_c_ad(l) + qol_ad(l)
            qol_ad(l) = 0.0_8
          ELSE
            qst_ad(l) = qst_ad(l) + rhmax*qol_ad(l)
            qol_ad(l) = 0.0_8
          END IF
        END DO
        poi_c_ad(k) = poi_c_ad(k) + prj(k+1)*cp*sht_ad(k+1)
        sht_ad(k+1) = 0.0_8
        zet_ad(k+1) = 0.0_8
        qoi_ad = qoi_ad + qoi_c_ad
        poi_ad = poi_ad + poi_c_ad
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        temp_ad = trg_ad/((rhmx-rhmn)*qst(k))
        qoi_ad(k) = qoi_ad(k) + temp_ad
        qst_ad(k) = qst_ad(k) - qoi(k)*temp_ad/qst(k)
      END IF
    END SUBROUTINE CLOUDE_ADM
!*********************************************************************
    SUBROUTINE CLOUDE(ic)
      IMPLICIT NONE
      INTEGER, INTENT(IN) :: ic
      REAL :: deep_fact, cu_diam, wscale
!, dQx
      REAL :: cli, te_a, c00_x, cli_crit_x, pete, toki, gmhx, hstx
      REAL :: dt_lyr, rate, cvw_x, closs, f2, f3, f4, f5
      INTEGER :: k700
!=============================AER_CLOUD local variables ====================
      REAL :: wbase, ndrop, nice, fp_d, ff_a, fp_i, fice, ndrop_amb, &
&     nsoot_amb, nsoot, nin, insoot, dcvw2, qice, dqice, dqig, fpice, &
&     dnice, dndrop, dsoot_amb, dsoot, qliq, dqliq, fprecip, aux, qt, &
&     maxnice, maxndrop, minnice, minndrop, ndrop_act, rimm, fndrim, &
&     tminusta, tparcel, alph_e, beta_e, rh_amb, ecrit
      REAL, DIMENSION(ndustmax) :: ndust, ndust_amb, indust, ddust_amb, &
&     ddust
      INTEGER :: inx, naux, index
      INTRINSIC AMIN1
      INTRINSIC MAX
      INTRINSIC MIN
      INTRINSIC AMAX1
      INTRINSIC SQRT
      INTRINSIC EXP
      REAL :: min1
      REAL :: max1
      REAL :: min2
      REAL :: max2
      LOGICAL, DIMENSION(k-ic+1) :: mask
      REAL :: x4
      REAL :: x3
      REAL :: x2
      REAL :: x1
      REAL :: y1
!A little higher so there is ice at the freezing level
      t_ice_all = 238.0
      wbase = 1.0
      fice = 0.0
      nice = 0.0
      ndrop = 0.0
      ndrop_amb = 0.0
      ndrop_act = 0.0
      nin = 0.0
      ndust = 0.0
      nsoot = 0.0
      ndust_amb = 0.0
      nsoot_amb = 0.0
      dcvw2 = 0.0
      qice = 0.0
      qliq = 0.0
      fpice = 0.0
      indust = 0.0
      insoot = 0.0
      qt = 0.0
      fprecip = 0.0
      fndrim = 0.0
      rimm = 0.0
      tminusta = 0.0
      f_seasalt = 0.0
      aseasalt = 0.0
      CALL INIT_AER(aer_base)
!AER_CLOUD=============================
      alm = 0.
      IF (1. .GT. (qoi(k)/qst(k)-rhmn)/(rhmx-rhmn)) THEN
        trg = (qoi(k)/qst(k)-rhmn)/(rhmx-rhmn)
      ELSE
        trg = 1.
      END IF
      IF (0.0 .LT. (autorampb-sige(ic))/0.2) THEN
        y1 = (autorampb-sige(ic))/0.2
      ELSE
        y1 = 0.0
      END IF
      IF (1.0 .GT. y1) THEN
        f4 = y1
      ELSE
        f4 = 1.0
      END IF
! to 1 at SIG=AUTORAMPB-0.2
      IF (sige(ic) .GE. 0.5) THEN
        f5 = 1.0
      ELSE
        f5 = 1.0 - 2.*co_zdep*(0.5-sige(ic))
        IF (f5 .LT. 0.0) THEN
          f5 = 0.0
        ELSE
          f5 = f5
        END IF
      END IF
      IF (trg .LE. 1.0e-5) THEN
! TRIGGER  =========>>
        rc(ic) = 7
        RETURN
      ELSE
!  RECOMPUTE SOUNDING UP TO DETRAINMENT LEVEL
        poi_c = poi
        qoi_c = qoi
        poi_c(k) = poi_c(k) + tpert(i)
        qoi_c(k) = qoi_c(k) + qpert(i)
        zet(k+1) = 0.
        sht(k+1) = cp*poi_c(k)*prj(k+1)
        DO l=k,ic,-1
          IF (qst(l)*rhmax .GT. qoi_c(l)) THEN
            qol(l) = qoi_c(l)
          ELSE
            qol(l) = qst(l)*rhmax
          END IF
          IF (0.000 .LT. qol(l)) THEN
            qol(l) = qol(l)
          ELSE
            qol(l) = 0.000
          END IF
          ssl(l) = cp*prj(l+1)*poi_c(l) + grav*zet(l+1)
          hol(l) = ssl(l) + qol(l)*alhl
          hst(l) = ssl(l) + qst(l)*alhl
          tem = poi_c(l)*(prj(l+1)-prj(l))*cpbg
          zet(l) = zet(l+1) + tem
          zol(l) = zet(l+1) + (prj(l+1)-prh(l))*poi_c(l)*cpbg
        END DO
        DO l=ic+1,k
          tem = (prj(l)-prh(l-1))/(prh(l)-prh(l-1))
          sht(l) = ssl(l-1) + tem*(ssl(l)-ssl(l-1))
          qht(l) = .5*(qol(l)+qol(l-1))
        END DO
! SMOOTH HSTAR W/ 1-2-1 Filter
        IF (smooth_hst) THEN
! save for later
          hstx = hst(ic)
          DO l=k-1,ic+1,-1
            hst(l) = 0.25*(hst(l+1)+hst(l-1)) + 0.5*hst(l)
          END DO
          DO l=ic,ic
            hst(l) = 0.5*hst(l+1) + 0.5*hst(l)
          END DO
        END IF
!  CALCULATE LAMBDA, ETA, AND WORKFUNCTION
        lambda_min = .2/mxdiam(i)
        lambda_max = .2/diammn_min
!     LAMBDA_MIN = .2/(LAMBDA_FAC*DPTH_BL)
!     LAMBDA_MAX = .2/( MAX( LAMBMX_FAC*DPTH_BL , DIAMMN_MIN ) )
        IF (hol(k) .LE. hst(ic)) THEN
! CANNOT REACH IC LEVEL  ======>>
          rc(ic) = 1
          RETURN
        ELSE
!  LAMBDA CALCULATION: MS-A18
          tem = (hst(ic)-hol(ic))*(zol(ic)-zet(ic+1))
          DO l=ic+1,k-1
            tem = tem + (hst(ic)-hol(l))*(zet(l)-zet(l+1))
          END DO
          IF (tem .LE. 0.0) THEN
! NO VALID LAMBDA  ============>>
            rc(ic) = 2
            RETURN
          ELSE
            alm = (hol(k)-hst(ic))/tem
            IF (alm .GT. lambda_max) THEN
              rc(ic) = 3
              RETURN
            ELSE
!   ALPHA CALCULATION
              rasal2i = rasal2_2d(i)
              IF (zet(ic) .LT. 2000.) rasal(ic) = rasal1
              IF (zet(ic) .GE. 2000.) THEN
                IF (1.0 .GT. (zet(ic)-2000.)/rasal_slope) THEN
                  min1 = (zet(ic)-2000.)/rasal_slope
                ELSE
                  min1 = 1.0
                END IF
                rasal(ic) = rasal1 + (rasal2i-rasal1)*min1
              END IF
              rasal(ic) = dt/rasal(ic)
              IF (1.0 .GT. (alm/lambda_min)**2) THEN
                toki = (alm/lambda_min)**2
              ELSE
                toki = 1.0
              END IF
!   RAS relaxation timescale
              IF (k0 .GT. 96) THEN
!! AMM kluge to run 132 levels for now -- multiply time scale by ratio of number of levels
!! AMM between 900 and 30 mb in 72 and 132 level grids, 0.46
                tau(ic) = toki*trg*rasal(ic)*0.46
              ELSE
                tau(ic) = toki*trg*rasal(ic)
              END IF
!IF (TAU(IC) < 1.0E-5) THEN
!   RC(IC) = 6
!   RETURN
!ENDIF
!LAMBDSV(IC) = ALM
!  ETA CALCULATION: MS-A2
              DO l=ic+1,k
                eta(l) = 1.0 + alm*(zet(l)-zet(k))
              END DO
              eta(ic) = 1.0 + alm*(zol(ic)-zet(k))
!  WORKFUNCTION CALCULATION:  MS-A22
              wfn = 0.0
              hcc(k) = hol(k)
              DO l=k-1,ic+1,-1
                hcc(l) = hcc(l+1) + (eta(l)-eta(l+1))*hol(l)
                tem = hcc(l+1)*dpb(l) + hcc(l)*dpt(l)
                eht(l) = eta(l+1)*dpb(l) + eta(l)*dpt(l)
                wfn = wfn + (tem-eht(l)*hst(l))*gam(l)
              END DO
              hcc(ic) = hst(ic)*eta(ic)
              wfn = wfn + (hcc(ic+1)-hst(ic)*eta(ic+1))*gam(ic)*dpb(ic)
!  VERTICAL VELOCITY/KE CALCULATION (ADDED 12/2001 JTB)
              bk3(k) = 0.0
              bk2(k) = 0.0
              bke(k) = 0.0
              hcld(k) = hol(k)
              DO l=k-1,ic,-1
                hcld(l) = (eta(l+1)*hcld(l+1)+(eta(l)-eta(l+1))*hol(l))/&
&                 eta(l)
                tem = (hcld(l)-hst(l))*(zet(l)-zet(l+1))/(1.0+lbcp*dqq(l&
&                 ))
                IF (cldmicro .LE. 0.0) THEN
                  bke(l) = bke(l+1) + grav*tem/(cp*prj(l+1)*poi(l))
                  IF (tem .LT. 0.0) THEN
                    max1 = 0.0
                  ELSE
                    max1 = tem
                  END IF
                  bk2(l) = bk2(l+1) + grav*max1/(cp*prj(l+1)*poi(l))
                  IF (tem .GT. 0.0) THEN
                    min2 = 0.0
                  ELSE
                    min2 = tem
                  END IF
                  bk3(l) = bk3(l+1) + grav*min2/(cp*prj(l+1)*poi(l))
                  IF (bk2(l) .LT. 0.0) THEN
                    max2 = 0.0
                  ELSE
                    max2 = bk2(l)
                  END IF
                  cvw(l) = SQRT(2.0*max2)
                END IF
              END DO
              mask(1:k-ic+1) = cvw(ic:k) .LT. 1.00
              WHERE (mask(1:k-ic+1)) 
                WHERE (mask(1:k-ic+1)) 
                  cvw(ic:k) = 1.00
                ELSEWHERE
                  cvw(ic:k) = cvw(ic:k)
                END WHERE
              END WHERE
!  NOTE THIS "CENTRALIZES" A KLUGE PRESENT IN OTHER LOCATIONS.
!  CLEAN UP SOME TIME.      -JTB 12/04/03
!  TEST FOR CRITICAL WORK FUNCTION
              CALL ACRITN(pol(ic), prs(k), acr)
              IF (wfn .LE. acr) THEN
! SUB-CRITICAL WORK FUNCTION ======>>
                rc(ic) = 4
                RETURN
              ELSE
!  CLOUD TOP WATER AND MOMENTUM (TIMES ETA(IC)) MS-A16
! Tracer scavenging
! RAS loops over a series of plumes all having common cloud base level K
! and different detrainment levels IC.  The plumes operate sequentially
! on the grid box mean quantities (wind, moisture, tracer) and so each
! subsequent plume is seeing the effects of previous plumes.  We parameterize
! scavenging following Liu et al. [JGR, 2001], their equation 1:
!  AEROSOL FRACTION SCAVENGED = 1 - exp(-FSCAV*DZ)
! where FSCAV is a specified scavenging efficiency [km-1] and DZ is the
! distance [km] the tracer traverses in the plume from its entrainment
! level to its detrainment level.  We write the aerosol fraction surviving as:
!  FNOSCAV = exp(- FSCAV_(ITR) * DZ)
! The total scavenging is proportional to the convective mass flux, which
! is not explicitly solved for at this point.
                IF (do_tracers) THEN
                  DO itr=1,itrcr
!           Scavenging of the below cloud tracer
                    delzkm = (zet(ic)-zet(k))/1000.
                    x3 = EXP(-(fscav_(itr)*delzkm))
                    IF (x3 .GT. 1.) THEN
                      x1 = 1.
                    ELSE
                      x1 = x3
                    END IF
                    IF (x1 .LT. 0.) THEN
                      fnoscav = 0.
                    ELSE
                      fnoscav = x1
                    END IF
                    xht(itr) = xoi(k, itr)*fnoscav
                  END DO
                END IF
                wlq = qol(k)
                uht = uoi(k)
                vht = voi(k)
                rnn(k) = 0.
                cll0(k) = 0.
!print *, '========================================='
                DO l=k-1,ic,-1
                  tem = eta(l) - eta(l+1)
                  wlq = wlq + tem*qol(l)
                  uht = uht + tem*uoi(l)
                  vht = vht + tem*voi(l)
                  IF (do_tracers) THEN
                    DO itr=1,itrcr
!         Scavenging of the entrained tracer.  Updates transported tracer mass.
                      delzkm = (zet(ic)-zet(l+1))/1000.
                      x4 = EXP(-(fscav_(itr)*delzkm))
                      IF (x4 .GT. 1.) THEN
                        x2 = 1.
                      ELSE
                        x2 = x4
                      END IF
                      IF (x2 .LT. 0.) THEN
                        fnoscav = 0.
                      ELSE
                        fnoscav = x2
                      END IF
                      xht(itr) = xht(itr) + tem*xoi(l, itr)*fnoscav
                    END DO
                  END IF
!!!! How much condensate (CLI) is present here?
                  IF (l .GT. ic) THEN
                    tx2 = 0.5*(qst(l)+qst(l-1))*eta(l)
                    tx3 = 0.5*(hst(l)+hst(l-1))*eta(l)
                    qcc = tx2 + gm1(l)*(hcc(l)-tx3)
                    cll0(l) = wlq - qcc
                  ELSE
                    cll0(l) = wlq - qst(ic)*eta(ic)
                  END IF
                  IF (cll0(l) .LT. 0.00) THEN
                    cll0(l) = 0.00
                  ELSE
                    cll0(l) = cll0(l)
                  END IF
! condensate (kg/kg)
                  cli = cll0(l)/eta(l)
! Temperature (K)
                  te_a = poi(l)*prh(l)
!=====================================================================
!            if (CLDMICRO .gt. 0.0) then  !AER_CLOUD MIcrophysics considering activation and nucleation
!recompute vertical velocity
!
!               Tparcel = TE_A
!               CVW(K) = 0.8  ! Assume a below cloud base  W of 0.8 m s-1
!               BK2(K)   = 0.0
!
!     
!               TEM     = (HCLD(L)-HST(L) )/ (1.0+LBCP*DQQ(L))  
!               TminusTa = max(min(TEM/CP, 5.0), 0.0) !limit DT to 5 K. According to Wei, JAS, 1998
!	     TEM =0.33*TminusTa*CO_AUTO(I)/TE_A !Bouyancy term, effciency =0.5 mwr Roode et al
!
!               BK2(L)  = BK2(L+1) + GRAV * TEM*(ZET(L)-ZET(L+1)) 
!               BK2(L) = BK2(L) - (ZET(L)-ZET(L+1))*(BK2(L+1)*ALM + CLI*GRAV)  !Account for drag from entrainment of stagnat air 
!and condesate loading
!               CVW(L) = max(SQRT(  2.0* MAX( BK2(L) , 0.0 )  ), 1.0) 
!
!
!	    CVW_X = MIN(CVW(L), 50.0)
!               DT_LYR  =  max(( ZET(L)-ZET(L+1) )/CVW_X, 1.0) !Sanity check
!               TEM   = ETA(L) - ETA(L+1)
!
!               Tparcel  =  TE_A + TminusTa
!
!
!
!!!!!!!!!!account for entrainment effects on activation !!!!!!!!!!!
!! Barahona and Nenes, JGR, 2007
!               alph_e = 2.8915e-8*Tparcel*Tparcel -2.1328e-5*Tparcel+4.2523e-3
!               beta_e = MAPL_ALHL*TminusTa/MAPL_RVAP/Tparcel/Tparcel
!               RH_AMB=QOI(L)/QST(L)
!               ECRIT  = max(1.0-RH_AMB -beta_e, 1.0e-6) 
!               ECRIT =  alph_e/ECRIT
!! print *, L, Tparcel, RH_AMB, ECRIT, ALM
!	           ECRIT =  ALM/ECRIT
!!Print *, ECRIT
!
!
!               if (L .eq. K-1) then
!
!                  FICE=0.0
!                  NICE=0.0
!                  NDROP=0.0
!                  NIN =0.0
!                  NDUST_AMB =0.0
!                  NSOOT_AMB = 0.0
!                  NSOOT=0.0
!                  NDUST= 0.0
!                  RATE=0.0
!                  FPRECIP=0.0
!
!                  AER_BASE%nmods = 0
!                  AER_BASE%num   = 0.0
!                  do INDEX = 1, AERO(L)%nmods
!                      if (AERO(L)%num(INDEX) > 0.1) then
!                          AER_BASE%nmods = AER_BASE%nmods + 1
!                          naux = AER_BASE%nmods
!
!                          AER_BASE%num(naux)   = AERO(L)%num(INDEX)
!                          AER_BASE%dpg(naux)   = max(AERO(L)%dpg(INDEX), 1.0e-9)
!                          AER_BASE%sig(naux)   = AERO(L)%sig(INDEX)
!                          AER_BASE%den(naux)   = AERO(L)%den(INDEX)
!                          AER_BASE%kap(naux)   = AERO(L)%kap(INDEX)
!                          AER_BASE%fdust(naux) = AERO(L)%fdust(INDEX)
!                          AER_BASE%fsoot(naux) = AERO(L)%fsoot(INDEX)
!                          AER_BASE%forg(naux)  = AERO(L)%forg(INDEX)
!                      end if
!                  end do
!
!!initial conditions
!                  call ARGact(Tparcel, CVW_X, NDROP_ACT, NDROP_AMB, NDUST_AMB, NSOOT_AMB, L,  .true., DDUST_AMB, DSOOT_AMB, ECRI
!T) !cloud droplet number and INsource at cloud base
!                  NDUST=NDUST_AMB
!                  NSOOT=NSOOT_AMB
!                  DDUST=DDUST_AMB
!                  DSOOT=DSOOT_AMB                                     
!
!               else 
!                  call ARGact(Tparcel, CVW_X, NDROP_ACT, NDROP_AMB, NDUST_AMB, NSOOT_AMB, L, .false., DDUST_AMB, DSOOT_AMB, ECRI
!T) !cloud droplet number above cloud base
!
!               end if
!
!               QT = CLI
!               RATE = 0.0
!               FPRECIP = 0.0
!
!               if (QT .gt. 0.0) then
!
!! if FICE is already >= 1.0 then the cloud is glaciated and there is no need to do anymore partitioning
!
!                  if (FICE .ge. 1.0) then
!
!
!                     CALL  Qremoval(RATE, FICE, FP_D, FP_I, Tparcel,  & 
!                           POL(L), QT,  NICE, NDROP, CVW_X, FPICE, &
!                           DT_LYR, RIMM, CO_AUTO(I)) 
!
!
!
!                     dNICE = -NICE*FP_I 
!                     NICE  =  (NICE +dNICE*DT_LYR)*ETA(L+1)/ETA(L) !ice
!
!                     MINNICE = max(QICE*(1.0-RATE*DT_LYR), 0.0)/4.0e-8!assuming maximum vol radius 250 microns
!                     MAXNICE = max(QICE*(1.0-RATE*DT_LYR), 0.0)/2.51e-12 !assuming minimum vol radius 10 microns
!
!                     NICE=MIN(max(NICE, MINNICE), MAXNICE)
!
!                     FICE = 1.0
!
!                  else 
!
!! Cloud is not completely glaciated do the whole thing
!! ALL these subroutines return tendencies
!
!
!                     CALL  INfreezing(QLIQ, NDROP, NIN, NDUST, NSOOT, INDUST, INSOOT, Tparcel, POL(L), CVW_X, DDUST, DSOOT)  !ca
!lculate the freezing fraction of the aerosol at this level
!
!                     NIN = min(NIN, NDROP/DT_LYR)
!
!                     call Qgrowth(Tparcel, POL(L), QICE, NICE, QT, NIN, dQIG, RIMM, FNDRIM)
!
!                     CALL  Qremoval(RATE, FICE, FP_D, FP_I, Tparcel,  & 
!                           POL(L), QT,  NICE, NDROP, CVW_X, FPICE, &
!                           DT_LYR,  RIMM, CO_AUTO(I)) 
!
!
!
!!ice number tendency: -precip + freezin
!                     dNICE = -NICE*FP_I  + NIN     
!                     NICE  =  (NICE +dNICE*DT_LYR)*ETA(L+1)/ETA(L) !ice
!                     NICE =max(NICE, 0.0)
!
!
!!ice mass tendency: growth - precip
!                     dQICE = -QICE*FPICE + dQIG
!                     QICE  =  min((QICE + dQICE*DT_LYR)*ETA(L+1)/ETA(L), QT) !ice
!                     QICE=max(min(QT, QICE), 0.0)
!
!
!! Liquid Tendency: source/evap -  precip
!!dQLIQ = max((CLI-QICE), -QLIQ)/DT_LYR -QLIQ*max(RATE-FPICE, 0.0)
!! dQLIQ = CLI*(1.0-RATE*DT_LYR)/DT_LYR -dQICE - QLIQ*max(RATE-FPICE, 0.0)
!!QLIQ  =  max((QLIQ + dQLIQ*DT_LYR)*ETA(L+1)/ETA(L), 0.0) !liquid. This is actually diagnostic
!                     QLIQ=max((QT-QICE), 0.0)
!
!
!!droplet number tendency: -precip - freezin + activation + activated entrained aerosol
!
!
!                     dNDROP =-NDROP*FP_D - NIN -  FNDRIM*NDROP/DT_LYR + max(NDROP_ACT-NDROP, 0.0)/DT_LYR          
!
!!dNDROP =-NDROP*FP_D - NIN -  FNDRIM*NDROP/DT_LYR + NDROP_ACT/DT_LYR
!
!                     NDROP =  (NDROP + dNDROP*DT_LYR)*ETA(L+1)/ETA(L) + &
!                           (ZET(L) - ZET(L+1))*ALM*MAX((NDROP_AMB-NDROP), 0.0)
!
!!Aerosol tendency: Entrainment - freezing
!
!                     NDUST = (NDUST - INDUST*DT_LYR)*ETA(L+1)/ETA(L) + &
!                           (ZET(L) - ZET(L+1))*ALM*MAX(NDUST_AMB-NDUST, 0.0) 
!
!                     NSOOT =  (NSOOT - INSOOT*DT_LYR)*ETA(L+1)/ETA(L)  + &     
!                           (ZET(L) - ZET(L+1))*ALM*MAX(NSOOT_AMB-NSOOT, 0.0)  
!
!
!                           
!!Update FICE and perform Sanity checks
!
!
!                     MINNDROP = (1.0-FICE)*QLIQ*max(1.0-RATE*DT_LYR, 0.0)/2.e-10    !assuming maximum vol radius 36 microns
!                     MAXNDROP = (1.0-FICE)*QLIQ*max(1.0-RATE*DT_LYR, 0.0)/3.35e-14 !assuming minimum vol radius 2 microns
!                     MINNICE = QICE/4.0e-8!assuming maximum vol radius 250 microns
!                     MAXNICE = QICE/2.51e-12 !assuming minimum vol radius 10 microns
!
!                     IF ((NICE .gt. MAXNICE) .or. (NICE .lt. MINNICE))   then    
!!print *, 'nilim', NICE*1e-6, MINNICE*1e-6, MAXNICE*1e-6
!                     END IF
!
!                     IF ((NDROP .gt. MAXNDROP) .or. (NDROP .lt. MINNDROP))      then 
!!print *, 'ndroplim', NDROP*1e-6, MINNDROP*1e-6, MAXNDROP*1e-6
!                     end if
!
!
!                     NSOOT=MAX(NSOOT, 0.0)
!                     NDUST=MAX(NDUST, 0.0)              
!
!                     NDROP=MIN(max(NDROP, MINNDROP), MAXNDROP)
!                     NICE=MIN(max(NICE, MINNICE), MAXNICE)
!
!                     FICE=max(min(QICE/QT, 1.0), 0.0)
!
!                     IF (FICE .ge. 1.0) THEN !Complete glaciation
!                        NICE=NICE+NDROP 
!                        NDROP = 0.0
!                        QICE  = QT
!                        QLIQ= 0.0
!                     END IF
!
!                     IF (Tparcel .LT. T_ICE_ALL) THEN !instantaneous freezing
!                        NICE=NICE+NDROP 
!                        NDROP = 0.0
!                        FICE  = 1.0
!                        QICE  = QT
!                        QLIQ=0.0
!                     END IF
!
!                     IF (Tparcel .GT. T_ICE_MAX) THEN !instantaneous melting
!                        NDROP=NICE+NDROP 
!                        NICE = 0.0
!                        FICE  = 0.0
!                        QICE  = 0.0
!                        QLIQ=QT
!                     END IF
!
!                  END IF
!
!               else 
!
!                  FICE =0.0 
!                  QICE = 0.0
!                  QLIQ = 0.0
!                  NICE= 0.0 
!                  NDROP = 0.0
!                  RATE =0.0
!               end if
!
!               FPRECIP= RATE*DT_LYR
!
!!RATE=RATE*F4
!! NDROP=NDROP*F4
!!NICE=NICE*(1.0-F4)
!
!!print *, TE_A, FICE, 'NICE', NICE*1e-6, 'NDROP', NDROP*1e-6, L
!!print *, 'FPI', FP_I*DT_LYR, 'FPD', FP_D*DT_LYR, 'FPICE', FPICE, 'FPRE', FPRECIP, QT, QLIQ
!
!            else !Bacmeister 2006 microphysics
                  CALL SUNDQ3_ICE(te_a, sdqv2, sdqv3, sdqvt1, f2, f3)
! * F5  ! F4 reduces AUTO for shallow clouds, F5 modifies auto for deep clouds
                  c00_x = co_auto(i)*f2*f3*f4
                  cli_crit_x = cli_crit/(f2*f3)
                  rate = c00_x*(1.0-EXP(-(cli**2/cli_crit_x**2)))
                  IF (cvw(l) .LT. 1.00) THEN
                    cvw_x = 1.00
                  ELSE
                    cvw_x = cvw(l)
                  END IF
! really trust it at low values
! l.h.s. DT_LYR => time in layer (L,L+1)
                  dt_lyr = (zet(l)-zet(l+1))/cvw_x
                  closs = cll0(l)*rate*dt_lyr
                  IF (closs .GT. cll0(l)) THEN
                    closs = cll0(l)
                  ELSE
                    closs = closs
                  END IF
                  cll0(l) = cll0(l) - closs
                  dll0(l) = closs
                  IF (closs .GT. 0.) THEN
                    wlq = wlq - closs
                    rnn(l) = closs
                  ELSE
                    rnn(l) = 0.
                  END IF
                END DO
!AER_CLOUD=======================================
!            CNVNDROP(IC)=NDROP
!            CNVNICE(IC)=NICE
!            CNVFICE(IC)=FICE
                wlq = wlq - qst(ic)*eta(ic)
!     CALCULATE GAMMAS AND KERNEL
! MS-A30 (W/O GRAV)
                gms(k) = (sht(k)-ssl(k))*pri(k)
! MS-A31 (W/O GRAV)
                gmh(k) = gms(k) + (qht(k)-qol(k))*pri(k)*alhl
! MS-A37 (W/O GRAV)
                akm = gmh(k)*gam(k-1)*dpb(k-1)
                tx2 = gmh(k)
                DO l=k-1,ic+1,-1
                  gms(l) = (eta(l)*(sht(l)-ssl(l))+eta(l+1)*(ssl(l)-sht(&
&                   l+1)))*pri(l)
                  gmh(l) = gms(l) + (eta(l)*(qht(l)-qol(l))+eta(l+1)*(&
&                   qol(l)-qht(l+1)))*alhl*pri(l)
                  tx2 = tx2 + (eta(l)-eta(l+1))*gmh(l)
                  akm = akm - gms(l)*eht(l)*pki(l) + tx2*ght(l)
                END DO
                gms(ic) = eta(ic+1)*(ssl(ic)-sht(ic+1))*pri(ic)
                akm = akm - gms(ic)*eta(ic+1)*dpb(ic)*pki(ic)
                gmh(ic) = gms(ic) + (eta(ic+1)*(qol(ic)-qht(ic+1))*alhl+&
&                 eta(ic)*(hst(ic)-hol(ic)))*pri(ic)
                IF (smooth_hst) gmhx = gms(ic) + (eta(ic+1)*(qol(ic)-qht&
&                   (ic+1))*alhl+eta(ic)*(hstx-hol(ic)))*pri(ic)
!    CLOUD BASE MASS FLUX
                IF (akm .GE. 0.0 .OR. wlq .LT. 0.0) THEN
!  =========>
                  rc(ic) = 5
                  RETURN
                ELSE
! MS-A39 MASS-FLUX IN Pa/step
                  wfn = -((wfn-acr)/akm)
! WMP Store the full mass-flux to use in efficiency diagnostic
                  ras_wfn(i) = wfn
                  IF (tau(ic)*wfn .GT. (prs(k+1)-prs(k))*(100.*pblfrac)&
&                 ) THEN
                    wfn = (prs(k+1)-prs(k))*(100.*pblfrac)
                  ELSE
                    wfn = tau(ic)*wfn
                  END IF
!! WMP RAS DIAGNOSTICS that make up TAU(IC)
! Fill the RAS timescale diagnostic
                  ras_time(i) = rasal(ic)
! Fill the RAS RH trigger diagnostic
                  ras_trg(i) = trg
! Fill the RAS Tokioka diagnostic
                  ras_toki(i) = toki
! Fill the RAS PBL fraction diagnostic
                  ras_pbl(i) = (prs(k+1)-prs(k))*(100.*pblfrac)
! Fill the RAS efficiency diagnostic
! RAS_EFFICIENCY(I) = WFN/RAS_EFFICIENCY(I)
!! WMP RAS DIAGNOSTICS
!    CUMULATIVE PRECIP AND CLOUD-BASE MASS FLUX FOR OUTPUT
                  wfnog = wfn*gravi
                  tem = wfn*gravi
! (kg/m^2/step)
                  cll(ic) = cll(ic) + wlq*tem
! (kg/m^2/step)
                  rmf(ic) = rmf(ic) + tem
! (kg/m^2/step)
                  rmfd(ic) = rmfd(ic) + tem*eta(ic)
                  DO l=ic+1,k
! (kg/m^2/step)
                    rmfp(l) = tem*eta(l)
! (kg/m^2/step)
                    rmfc(l) = rmfc(l) + rmfp(l)
                    dllx(l) = dllx(l) + tem*dll0(l)
                    IF (cvw(l) .GT. 0.0) THEN
                      updfrp(l) = rmfp(l)*(ddt/daylen)*1000./(cvw(l)*prs&
&                       (l))
                    ELSE
                      updfrp(l) = 0.0
                    END IF
! current cloud; incloud condensate
                    clli(l) = cll0(l)/eta(l)
!  cumulative grid mean convective condensate
                    cllb(l) = cllb(l) + updfrp(l)*clli(l)
                    updfrc(l) = updfrc(l) + updfrp(l)
                  END DO
!    THETA AND Q CHANGE DUE TO CLOUD TYPE IC
                  DO l=ic,k
! (kg/m^2/step)
                    rns(l) = rns(l) + rnn(l)*tem
                    gmh(l) = gmh(l)*wfn
                    gms(l) = gms(l)*wfn
                    qoi(l) = qoi(l) + (gmh(l)-gms(l))*alhi
                    poi(l) = poi(l) + gms(l)*pki(l)*cpi
                    qst(l) = qst(l) + gms(l)*bet(l)*cpi
                  END DO
                  IF (smooth_hst) THEN
                    gmhx = gmhx*wfn
                    dqx = (gmhx-gmh(ic))*alhi
                    rns(ic) = rns(ic) + dqx/(pri(ic)*grav)
                  END IF
                  IF (do_tracers) THEN
!*FRICFAC*0.5
                    wfn = wfn*0.5*1.0
                    tem = wfn*pri(k)
                    DO itr=1,itrcr
                      xcu(k, itr) = xcu(k, itr) + tem*(xoi(k-1, itr)-xoi&
&                       (k, itr))
                    END DO
                    DO itr=1,itrcr
                      DO l=k-1,ic+1,-1
                        tem = wfn*pri(l)
                        xcu(l, itr) = xcu(l, itr) + tem*((xoi(l-1, itr)-&
&                         xoi(l, itr))*eta(l)+(xoi(l, itr)-xoi(l+1, itr)&
&                         )*eta(l+1))
                      END DO
                    END DO
                    tem = wfn*pri(ic)
                    DO itr=1,itrcr
                      xcu(ic, itr) = xcu(ic, itr) + (2.*(xht(itr)-xoi(ic&
&                       , itr)*(eta(ic)-eta(ic+1)))-(xoi(ic, itr)+xoi(ic&
&                       +1, itr))*eta(ic+1))*tem
                    END DO
                    DO itr=1,itrcr
                      DO l=ic,k
                        xoi(l, itr) = xoi(l, itr) + xcu(l, itr)
                      END DO
                    END DO
                  ELSE
!*FRICFAC*0.5
                    wfn = wfn*0.5*1.0
                  END IF
                  lambdsv(ic) = 1.000
!   CUMULUS FRICTION
                  IF (fricfac .LE. 0.0) THEN
                    rc(ic) = 0
!  NO CUMULUS FRICTION =========>>
                    RETURN
                  ELSE
                    wfn = wfn*fricfac*EXP(-(alm/friclambda))
                    tem = wfn*pri(k)
                    ucu(k) = ucu(k) + tem*(uoi(k-1)-uoi(k))
                    vcu(k) = vcu(k) + tem*(voi(k-1)-voi(k))
                    DO l=k-1,ic+1,-1
                      tem = wfn*pri(l)
                      ucu(l) = ucu(l) + tem*((uoi(l-1)-uoi(l))*eta(l)+(&
&                       uoi(l)-uoi(l+1))*eta(l+1))
                      vcu(l) = vcu(l) + tem*((voi(l-1)-voi(l))*eta(l)+(&
&                       voi(l)-voi(l+1))*eta(l+1))
                    END DO
                    tem = wfn*pri(ic)
                    ucu(ic) = ucu(ic) + (2.*(uht-uoi(ic)*(eta(ic)-eta(ic&
&                     +1)))-(uoi(ic)+uoi(ic+1))*eta(ic+1))*tem
                    vcu(ic) = vcu(ic) + (2.*(vht-voi(ic)*(eta(ic)-eta(ic&
&                     +1)))-(voi(ic)+voi(ic+1))*eta(ic+1))*tem
                    dissk0(ic) = eta(ic)*grav*wfnog*pri(ic)*0.5*((uht/&
&                     eta(ic)-uoi(ic))**2+(vht/eta(ic)-voi(ic))**2)
                    DO l=ic,k
                      uoi(l) = uoi(l) + ucu(l)
                      voi(l) = voi(l) + vcu(l)
                    END DO
                    rc(ic) = 0
                    RETURN
                  END IF
                END IF
              END IF
            END IF
          END IF
        END IF
      END IF
    END SUBROUTINE CLOUDE
    SUBROUTINE ACRITN(pl, plb, acr)
      IMPLICIT NONE
      REAL, INTENT(IN) :: pl, plb
      REAL, INTENT(OUT) :: acr
      INTEGER :: iwk
!!REAL, PARAMETER :: FACM=0.5
      REAL, PARAMETER :: ph(15)=(/150.0, 200.0, 250.0, 300.0, 350.0, &
&       400.0, 450.0, 500.0, 550.0, 600.0, 650.0, 700.0, 750.0, 800.0, &
&       850.0/)
!!*FACM
      REAL, PARAMETER :: a(15)=(/1.6851, 1.1686, 0.7663, 0.5255, 0.4100&
&       , 0.3677, 0.3151, 0.2216, 0.1521, 0.1082, 0.0750, 0.0664, 0.0553&
&       , 0.0445, 0.0633/)
      INTRINSIC INT
      iwk = INT(pl*0.02 - 0.999999999)
      IF (iwk .GT. 1 .AND. iwk .LE. 15) THEN
        acr = a(iwk-1) + (pl-ph(iwk-1))*.02*(a(iwk)-a(iwk-1))
      ELSE IF (iwk .GT. 15) THEN
        acr = a(15)
      ELSE
        acr = a(1)
      END IF
      acr = acritfac*acr*(plb-pl)
      RETURN
    END SUBROUTINE ACRITN
!  Differentiation of rnevp in reverse (adjoint) mode (with options r8):
!   gradient     of useful results: cnv_prc3 qoi poi rns zet
!   with respect to varying inputs: cnv_prc3 qoi poi rns zet
    SUBROUTINE RNEVP_ADM()
      IMPLICIT NONE
      INTEGER :: branch
      DO l=icmin,k
        tem = pri(l)*grav
        cnv_prc3(i, l) = rns(l)*tem
      END DO
!! If hst is smoothed then adjusted precips may be negative
      IF (smooth_hst) THEN
        DO l=icmin,k
          IF (cnv_prc3(i, l) .LT. 0.) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
        DO l=k,icmin,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) cnv_prc3_ad(i, l) = qoi_ad(l) - alhl*poi_ad&
&             (l)/(cp*prj(l+1))
        END DO
      END IF
      DO l=k,icmin,-1
        tem = pri(l)*grav
        rns_ad(l) = rns_ad(l) + tem*cnv_prc3_ad(i, l)
        cnv_prc3_ad(i, l) = 0.0_8
      END DO
      DO l=icmin,k,1
        zet_ad(l+1) = zet_ad(l+1) + zet_ad(l)
        tem_ad = zet_ad(l)
        zet_ad(l) = 0.0_8
        poi_ad(l) = poi_ad(l) + (prj(l+1)-prj(l))*cpbg*tem_ad
      END DO
      zet_ad(k+1) = 0.0_8
    END SUBROUTINE RNEVP_ADM
    SUBROUTINE RNEVP()
      IMPLICIT NONE
      zet(k+1) = 0
      DO l=k,icmin,-1
        tem = poi(l)*(prj(l+1)-prj(l))*cpbg
        zet(l) = zet(l+1) + tem
      END DO
      DO l=icmin,k
        tem = pri(l)*grav
        cnv_prc3(i, l) = rns(l)*tem
      END DO
!! If hst is smoothed then adjusted precips may be negative
      IF (smooth_hst) THEN
        DO l=icmin,k
          IF (cnv_prc3(i, l) .LT. 0.) THEN
            qoi(l) = qoi(l) + cnv_prc3(i, l)
            poi(l) = poi(l) - cnv_prc3(i, l)*(alhl/cp)/prj(l+1)
            cnv_prc3(i, l) = 0.
          END IF
        END DO
      END IF
      RETURN
    END SUBROUTINE RNEVP
!  Differentiation of htest in reverse (adjoint) mode (with options r8):
!   gradient     of useful results: hst qoi qol sht qst poi ssl
!                zet zol hol
!   with respect to varying inputs: hst qoi qol sht qst poi ssl
!                zet zol
    SUBROUTINE HTEST_ADM()
      IMPLICIT NONE
      REAL, DIMENSION(k0) :: hol1
      INTEGER :: lminhol
      REAL :: minhol
      INTRINSIC AMIN1
      INTRINSIC AMAX1
! HOL initialized here in order not to confuse Valgrind debugger
      INTEGER :: branch
      DO l=k,icmin,-1
        IF (qst(l)*rhmax .GT. qoi(l)) THEN
          qol(l) = qoi(l)
          CALL PUSHCONTROL1B(0)
        ELSE
          qol(l) = qst(l)*rhmax
          CALL PUSHCONTROL1B(1)
        END IF
        IF (0.000 .LT. qol(l)) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
      END DO
      DO l=icmin,k,1
        ssl_ad(l) = ssl_ad(l) + hol_ad(l) + hst_ad(l)
        zet_ad(l+1) = zet_ad(l+1) + zet_ad(l) + zol_ad(l)
        tem_ad = zet_ad(l)
        poi_ad(l) = poi_ad(l) + (prj(l+1)-prj(l))*cpbg*tem_ad + prj(l+1)&
&         *cp*ssl_ad(l) + (prj(l+1)-prh(l))*cpbg*zol_ad(l)
        zol_ad(l) = 0.0_8
        zet_ad(l) = 0.0_8
        qst_ad(l) = qst_ad(l) + alhl*hst_ad(l)
        hst_ad(l) = 0.0_8
        qol_ad(l) = qol_ad(l) + alhl*hol_ad(l)
        hol_ad(l) = 0.0_8
        zet_ad(l+1) = zet_ad(l+1) + grav*ssl_ad(l)
        ssl_ad(l) = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) qol_ad(l) = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          qoi_ad(l) = qoi_ad(l) + qol_ad(l)
          qol_ad(l) = 0.0_8
        ELSE
          qst_ad(l) = qst_ad(l) + rhmax*qol_ad(l)
          qol_ad(l) = 0.0_8
        END IF
      END DO
      poi_ad(k) = poi_ad(k) + prj(k+1)*cp*sht_ad(k+1)
      sht_ad(k+1) = 0.0_8
      zet_ad(k+1) = 0.0_8
    END SUBROUTINE HTEST_ADM
    SUBROUTINE HTEST()
      IMPLICIT NONE
      REAL, DIMENSION(k0) :: hol1
      INTEGER :: lminhol
      REAL :: minhol
      INTRINSIC AMIN1
      INTRINSIC AMAX1
! HOL initialized here in order not to confuse Valgrind debugger
      hol = 0.
      lminhol = k + 1
      minhol = -999999.
      zet(k+1) = 0
      sht(k+1) = cp*poi(k)*prj(k+1)
      DO l=k,icmin,-1
        IF (qst(l)*rhmax .GT. qoi(l)) THEN
          qol(l) = qoi(l)
        ELSE
          qol(l) = qst(l)*rhmax
        END IF
        IF (0.000 .LT. qol(l)) THEN
          qol(l) = qol(l)
        ELSE
          qol(l) = 0.000
        END IF
        ssl(l) = cp*prj(l+1)*poi(l) + grav*zet(l+1)
        hol(l) = ssl(l) + qol(l)*alhl
        hst(l) = ssl(l) + qst(l)*alhl
        tem = poi(l)*(prj(l+1)-prj(l))*cpbg
        zet(l) = zet(l+1) + tem
        zol(l) = zet(l+1) + (prj(l+1)-prh(l))*poi(l)*cpbg
      END DO
      hol1 = hol
      DO l=k-1,icmin+1,-1
        hol1(l) = 0.25*hol(l+1) + 0.50*hol(l) + 0.25*hol(l-1)
        IF (minhol .GE. hol1(l) .OR. minhol .LT. 0.) THEN
          minhol = hol1(l)
          lminhol = l
        END IF
      END DO
      sige_minhol = sige(lminhol)
    END SUBROUTINE HTEST
    SUBROUTINE FINDDTLS()
      IMPLICIT NONE
      REAL :: sigdt0, sigmax, sigmin
      INTEGER :: ll
      INTEGER, ALLOCATABLE :: the_seed(:)
      INTEGER :: seed_len
      INTRINSIC RANDOM_SEED
      INTRINSIC INT
      INTRINSIC MIN
      INTRINSIC ALLOCATED
      INTRINSIC RANDOM_NUMBER
      INTEGER :: x1
      seed_len = 0
      CALL RANDOM_SEED(size=seed_len)
      ALLOCATE(the_seed(seed_len))
      the_seed(1) = seedras(i, 1)*iras(i) + seedras(i, 2)*jras(i)
      the_seed(2) = seedras(i, 1)*jras(i) + seedras(i, 2)*iras(i)
      the_seed(1) = the_seed(1)*seedras(i, 1)/(seedras(i, 2)+10)
      the_seed(2) = the_seed(2)*seedras(i, 1)/(seedras(i, 2)+10)
      IF (the_seed(1) .EQ. 0) the_seed(1) = 5
      IF (the_seed(2) .EQ. 0) the_seed(2) = -5
! Gfortran uses longer seeds, so fill the rest with zero
      IF (seed_len .GT. 2) the_seed(3:) = 0
      CALL RANDOM_SEED(put=the_seed)
      sigmax = sige(k)
      sigmin = sige(icmin)
      IF (rasncl .LT. 0.0) THEN
!! NO SHALLOW CONV   N_DTL = 56 - ICMIN
        n_dtl = k - icmin
      ELSE
        x1 = INT(rasncl)
        IF (x1 .GT. k - icmin) THEN
          n_dtl = k - icmin
        ELSE
          n_dtl = x1
        END IF
      END IF
      IF (ALLOCATED(icl_v)) THEN
        DEALLOCATE(icl_v)
      END IF
      ALLOCATE(icl_v(n_dtl))
      IF (rasncl .LT. 0.0 .AND. rasncl .GE. -100.) THEN
        DO l=1,n_dtl
          icl_v(l) = icmin + l - 1
        END DO
      ELSE IF (rasncl .LT. -100.0) THEN
        DO l=1,n_dtl
          icl_v(l) = k - l
        END DO
      ELSE
!! NO SHALLOW CONV           ICL_V(L) = 56 - L
        DO l=1,n_dtl
          CALL RANDOM_NUMBER(sigdt0)
          sigdt0 = 1.00 - sigdt0**rdtlexpon
          sigdt0 = sigmin + sigdt0*(sigmax-sigmin)
          DO ll=icmin,k
            IF (sige(ll+1) .GE. sigdt0 .AND. sige(ll) .LT. sigdt0) icl_v&
&             (l) = ll
          END DO
        END DO
      END IF
      DEALLOCATE(the_seed)
    END SUBROUTINE FINDDTLS
!  Differentiation of strap in reverse (adjoint) mode (with options r8):
!   gradient     of useful results: clw tho qho vho cnv_updfrc
!                uho flxd gm1 cvw dqq ght bet qoi_sv uoi_sv qoi
!                voi qst updfrc poi rns poi_sv uoi rmfd voi_sv
!                updfrp cll0 cll rmfp gam
!   with respect to varying inputs: clw tho qho vho cnv_updfrc
!                uho flxd gm1 cvw dqq ght bet qoi_sv uoi_sv qoi
!                voi qst updfrc poi rns poi_sv uoi rmfd voi_sv
!                updfrp cll0 cll rmfp gam
    SUBROUTINE STRAP_ADM(final)
      IMPLICIT NONE
      INTEGER :: final
      REAL, DIMENSION(k0) :: wght, massf
      REAL :: wght0, prcbl
      INTEGER, PARAMETER :: nrands=1
      REAL :: rndu(nrands)
      INTEGER :: seedcbl(nrands)
! !DESCRIPTION:
!   {\tt STRAP} is called: FINAL=0, to compute cloud base layer CBL properties
!   given a value K for the index of the upper {\em EDGE} of the CBL; FINAL=1
!   to redistribute convective tendencies within CBL
      INTEGER :: kk
      INTRINSIC SQRT
      INTRINSIC MAX
      INTRINSIC ABS
      INTRINSIC PRESENT
      INTRINSIC ALLOCATED
      REAL :: abs0
      REAL :: abs1
      REAL :: arg1
      REAL :: arg1_ad
      LOGICAL :: mask
      REAL :: temp
      REAL :: temp0
      REAL :: temp1
      REAL :: temp_ad
      REAL :: temp_ad0
      REAL :: temp_ad1
      INTEGER :: branch
!  LOCAL VARIABLES FOR USE IN CLOUDE
!!IF (.NOT. PRESENT(FINAL)) THEN
      IF (final .EQ. 0) THEN
!!PRJ(ICMIN:K+1) = PKE(I,ICMIN:K+1)
        DO kk=icmin,k+1
          CALL PUSHREAL8(prj(kk))
          prj(kk) = pke(i, kk)
        END DO
! These initialized here in order not to confuse Valgrind debugger
        poi = 0.
! Do not believe it actually makes any difference.
        CALL PUSHREAL8ARRAY(prs(icmin:k0+1), k0 - icmin + 2)
        prs(icmin:k0+1) = ple(i, icmin:k0+1)
        poi(icmin:k) = tho(i, icmin:k)
        CALL PUSHREAL8ARRAY(dqq(icmin:k), k - icmin + 1)
        dqq(icmin:k) = dqs(i, icmin:k)
!!! Mass fraction of each layer below cloud base
!!! contributed to aggregate cloudbase layer (CBL)
        massf(:) = wgt0(i, :)
!!! RESET PRESSURE at bottom edge of CBL
        prcbl = prs(k)
        DO l=k,k0
          prcbl = prcbl + massf(l)*(prs(l+1)-prs(l))
        END DO
        CALL PUSHREAL8(prs(k+1))
        prs(k+1) = prcbl
        CALL PUSHREAL8(prj(k+1))
        prj(k+1) = (prs(k+1)/1000.)**(mapl_rgas/mapl_cp)
        DO l=k,icmin,-1
          CALL PUSHREAL8(pol(l))
          pol(l) = 0.5*(prs(l)+prs(l+1))
          CALL PUSHREAL8(prh(l))
          prh(l) = (prs(l+1)*prj(l+1)-prs(l)*prj(l))/(onepkap*(prs(l+1)-&
&           prs(l)))
          CALL PUSHREAL8(pki(l))
          pki(l) = 1.0/prh(l)
          CALL PUSHREAL8(dpt(l))
          dpt(l) = prh(l) - prj(l)
          CALL PUSHREAL8(dpb(l))
          dpb(l) = prj(l+1) - prh(l)
        END DO
!!!!! RECALCULATE PROFILE QUAN. IN LOWEST STRAPPED LAYER
        IF (k .LE. k0) THEN
          poi(k) = 0.
!! SPECIFY WEIGHTS GIVEN TO EACH LAYER WITHIN SUBCLOUD "SUPERLAYER"
          wght = 0.
          DO l=k,k0
            wght(l) = massf(l)*(ple(i, l+1)-ple(i, l))/(prs(k+1)-prs(k))
          END DO
          DO l=k,k0
            poi(k) = poi(k) + wght(l)*tho(i, l)
          END DO
          arg1 = poi(k)*prh(k)
          CALL PUSHREAL8(dqq(k))
          CALL PUSHREAL8(qst(k))
          dqq(k) = DQSAT(poi(k)*prh(k), pol(k), qsat=qst(k))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        mask = seedras(i, 1)/1000000. .LT. 1e-6
!!call congvec( npoints , seedcbl , rndu )
        DO l=k,icmin,-1
!*
!*
          IF (l .LT. k) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!    IF (PRESENT(FINAL)) THEN
      IF (final .EQ. 1) THEN
!======================AER_CLOUD=============
!               CNV_NDROP   (I,ICMIN:K-1)  =    CNVNDROP(ICMIN:K-1) !DONIF
!               CNV_NICE   (I,ICMIN:K-1)   =     CNVNICE(ICMIN:K-1) !DONIF
!               CNV_FICE   (I,ICMIN:K-1)   =     CNVFICE(ICMIN:K-1) !DONIF
!! De-strap tendencies from RAS
!! specify weighting "SHAPE"
        CALL PUSHREAL8ARRAY(wght, k0)
        wght = wgt1(i, :)
!! Scale properly by layer masses
        wght0 = 0.
        DO l=k,k0
          wght0 = wght0 + wght(l)*(ple(i, l+1)-ple(i, l))
        END DO
        wght0 = (prs(k+1)-prs(k))/wght0
        wght = wght0*wght
        l = k0 + 1
        IF (k .LT. k0) THEN
          CALL PUSHCONTROL2B(0)
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(2)
      END IF
      IF (final .EQ. 2) THEN
        clw_ad(i, :) = 0.0_8
        flxd_ad(i, :) = 0.0_8
      END IF
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        clw_ad(i, k:k0) = 0.0_8
        flxd_ad(i, k:k0) = 0.0_8
      ELSE IF (branch .NE. 1) THEN
        GOTO 100
      END IF
      clw_ad(i, 1:icmin-1) = 0.0_8
      flxd_ad(i, 1:icmin-1) = 0.0_8
      cll_ad(icmin:k) = cll_ad(icmin:k) + ddt*clw_ad(i, icmin:k)/daylen
      clw_ad(i, icmin:k) = 0.0_8
      rmfd_ad(icmin:k) = rmfd_ad(icmin:k) + ddt*flxd_ad(i, icmin:k)/&
&       daylen
      flxd_ad(i, icmin:k) = 0.0_8
      DO l=k0,k,-1
        voi_ad(k) = voi_ad(k) + wght(l)*vho_ad(i, l)
        voi_sv_ad(k) = voi_sv_ad(k) - wght(l)*vho_ad(i, l)
        uoi_ad(k) = uoi_ad(k) + wght(l)*uho_ad(i, l)
        uoi_sv_ad(k) = uoi_sv_ad(k) - wght(l)*uho_ad(i, l)
        qoi_ad(k) = qoi_ad(k) + wght(l)*qho_ad(i, l)
        qoi_sv_ad(k) = qoi_sv_ad(k) - wght(l)*qho_ad(i, l)
        poi_ad(k) = poi_ad(k) + wght(l)*tho_ad(i, l)
        poi_sv_ad(k) = poi_sv_ad(k) - wght(l)*tho_ad(i, l)
      END DO
      CALL POPREAL8ARRAY(wght, k0)
      updfrc_ad(icmin:k-1) = updfrc_ad(icmin:k-1) + cnv_updfrc_ad(i, &
&       icmin:k-1)
      cnv_updfrc_ad(i, icmin:k-1) = 0.0_8
      voi_ad(icmin:k-1) = voi_ad(icmin:k-1) + vho_ad(i, icmin:k-1)
      vho_ad(i, icmin:k-1) = 0.0_8
      uoi_ad(icmin:k-1) = uoi_ad(icmin:k-1) + uho_ad(i, icmin:k-1)
      uho_ad(i, icmin:k-1) = 0.0_8
      qoi_ad(icmin:k-1) = qoi_ad(icmin:k-1) + qho_ad(i, icmin:k-1)
      qho_ad(i, icmin:k-1) = 0.0_8
      poi_ad(icmin:k-1) = poi_ad(icmin:k-1) + tho_ad(i, icmin:k-1)
      tho_ad(i, icmin:k-1) = 0.0_8
 100  CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        voi_ad = voi_ad + voi_sv_ad
        uoi_ad = uoi_ad + uoi_sv_ad
        qoi_ad = qoi_ad + qoi_sv_ad
        poi_ad = poi_ad + poi_sv_ad
        DO l=icmin,k,1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            temp1 = alhl*(lbcp*dqq(l+1)+1.0)
            temp0 = alhl*(lbcp*dqq(l)+1.0)
            temp_ad = lbcp*0.5*gm1_ad(l+1)
            temp_ad0 = temp_ad/temp0
            temp_ad1 = temp_ad/temp1
            dqq_ad(l) = dqq_ad(l) + (1.0-alhl*dqq(l)*lbcp/temp0)*&
&             temp_ad0
            dqq_ad(l+1) = dqq_ad(l+1) + (1.0-alhl*dqq(l+1)*lbcp/temp1)*&
&             temp_ad1
            gm1_ad(l+1) = 0.0_8
            gam_ad(l) = gam_ad(l) + dpb(l)*ght_ad(l+1)
            gam_ad(l+1) = gam_ad(l+1) + dpt(l+1)*ght_ad(l+1)
            ght_ad(l+1) = 0.0_8
          END IF
          temp = lbcp*dqq(l) + 1.0
          dqq_ad(l) = dqq_ad(l) + pki(l)*bet_ad(l) - pki(l)*lbcp*gam_ad(&
&           l)/temp**2
          gam_ad(l) = 0.0_8
          bet_ad(l) = 0.0_8
        END DO
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          CALL POPREAL8(qst(k))
          CALL POPREAL8(dqq(k))
          CALL DQSAT_ADM(arg1, arg1_ad, pol(k), qsat=qst(k), qsat_ad=&
&                  qst_ad(k), dqsat_ad=dqq_ad(k))
          dqq_ad(k) = 0.0_8
          poi_ad(k) = poi_ad(k) + prh(k)*arg1_ad
          DO l=k0,k,-1
            vho_ad(i, l) = vho_ad(i, l) + wght(l)*voi_ad(k)
            uho_ad(i, l) = uho_ad(i, l) + wght(l)*uoi_ad(k)
            qho_ad(i, l) = qho_ad(i, l) + wght(l)*qoi_ad(k)
            tho_ad(i, l) = tho_ad(i, l) + wght(l)*poi_ad(k)
          END DO
          voi_ad(k) = 0.0_8
          uoi_ad(k) = 0.0_8
          qoi_ad(k) = 0.0_8
          poi_ad(k) = 0.0_8
        END IF
        DO l=icmin,k,1
          CALL POPREAL8(dpb(l))
          CALL POPREAL8(dpt(l))
          CALL POPREAL8(pki(l))
          CALL POPREAL8(prh(l))
          CALL POPREAL8(pol(l))
        END DO
        CALL POPREAL8(prj(k+1))
        CALL POPREAL8(prs(k+1))
        CALL POPREAL8ARRAY(dqq(icmin:k), k - icmin + 1)
        dqq_ad(icmin:k) = 0.0_8
        qst_ad(icmin:k) = 0.0_8
        vho_ad(i, icmin:k) = vho_ad(i, icmin:k) + voi_ad(icmin:k)
        uho_ad(i, icmin:k) = uho_ad(i, icmin:k) + uoi_ad(icmin:k)
        qho_ad(i, icmin:k) = qho_ad(i, icmin:k) + qoi_ad(icmin:k)
        tho_ad(i, icmin:k) = tho_ad(i, icmin:k) + poi_ad(icmin:k)
        CALL POPREAL8ARRAY(prs(icmin:k0+1), k0 - icmin + 2)
        DO kk=k+1,icmin,-1
          CALL POPREAL8(prj(kk))
        END DO
        cvw_ad = 0.0_8
        qoi_sv_ad = 0.0_8
        uoi_sv_ad = 0.0_8
        qoi_ad = 0.0_8
        voi_ad = 0.0_8
        updfrc_ad = 0.0_8
        poi_ad = 0.0_8
        rns_ad = 0.0_8
        poi_sv_ad = 0.0_8
        uoi_ad = 0.0_8
        rmfd_ad = 0.0_8
        voi_sv_ad = 0.0_8
        updfrp_ad = 0.0_8
        cll0_ad = 0.0_8
        cll_ad = 0.0_8
        rmfp_ad = 0.0_8
      END IF
    END SUBROUTINE STRAP_ADM
    SUBROUTINE STRAP(final)
      IMPLICIT NONE
      INTEGER :: final
      REAL, DIMENSION(k0) :: wght, massf
      REAL :: wght0, prcbl
      INTEGER, PARAMETER :: nrands=1
      REAL :: rndu(nrands)
      INTEGER :: seedcbl(nrands)
! !DESCRIPTION:
!   {\tt STRAP} is called: FINAL=0, to compute cloud base layer CBL properties
!   given a value K for the index of the upper {\em EDGE} of the CBL; FINAL=1
!   to redistribute convective tendencies within CBL
      INTEGER :: kk
      INTRINSIC SQRT
      INTRINSIC MAX
      INTRINSIC ABS
      INTRINSIC PRESENT
      INTRINSIC ALLOCATED
      REAL :: abs0
      REAL :: abs1
      REAL :: arg1
      LOGICAL :: mask
!  LOCAL VARIABLES FOR USE IN CLOUDE
!!IF (.NOT. PRESENT(FINAL)) THEN
      IF (final .EQ. 0) THEN
!!PRJ(ICMIN:K+1) = PKE(I,ICMIN:K+1)
        DO kk=icmin,k+1
          prj(kk) = pke(i, kk)
        END DO
! These initialized here in order not to confuse Valgrind debugger
        poi = 0.
! Do not believe it actually makes any difference.
        qoi = 0.
        uoi = 0.
        voi = 0.
        prs(icmin:k0+1) = ple(i, icmin:k0+1)
        poi(icmin:k) = tho(i, icmin:k)
        qoi(icmin:k) = qho(i, icmin:k)
        uoi(icmin:k) = uho(i, icmin:k)
        voi(icmin:k) = vho(i, icmin:k)
        wsp(icmin:k) = SQRT((uoi(icmin:k)-uoi(k))**2 + (voi(icmin:k)-voi&
&         (k))**2)
        qst(icmin:k) = qss(i, icmin:k)
        dqq(icmin:k) = dqs(i, icmin:k)
        IF (do_tracers) THEN
          DO itr=1,itrcr
            xoi(icmin:k, itr) = xho(i, icmin:k, itr)
          END DO
        END IF
!!! Mass fraction of each layer below cloud base
!!! contributed to aggregate cloudbase layer (CBL)
        massf(:) = wgt0(i, :)
!!! RESET PRESSURE at bottom edge of CBL
        prcbl = prs(k)
        DO l=k,k0
          prcbl = prcbl + massf(l)*(prs(l+1)-prs(l))
        END DO
        prs(k+1) = prcbl
        prj(k+1) = (prs(k+1)/1000.)**(mapl_rgas/mapl_cp)
        DO l=k,icmin,-1
          pol(l) = 0.5*(prs(l)+prs(l+1))
          prh(l) = (prs(l+1)*prj(l+1)-prs(l)*prj(l))/(onepkap*(prs(l+1)-&
&           prs(l)))
          pki(l) = 1.0/prh(l)
          dpt(l) = prh(l) - prj(l)
          dpb(l) = prj(l+1) - prh(l)
          pri(l) = .01/(prs(l+1)-prs(l))
        END DO
!!!!! RECALCULATE PROFILE QUAN. IN LOWEST STRAPPED LAYER
        IF (k .LE. k0) THEN
          poi(k) = 0.
          qoi(k) = 0.
          uoi(k) = 0.
          voi(k) = 0.
!! SPECIFY WEIGHTS GIVEN TO EACH LAYER WITHIN SUBCLOUD "SUPERLAYER"
          wght = 0.
          DO l=k,k0
            wght(l) = massf(l)*(ple(i, l+1)-ple(i, l))/(prs(k+1)-prs(k))
          END DO
          DO l=k,k0
            poi(k) = poi(k) + wght(l)*tho(i, l)
            qoi(k) = qoi(k) + wght(l)*qho(i, l)
            uoi(k) = uoi(k) + wght(l)*uho(i, l)
            voi(k) = voi(k) + wght(l)*vho(i, l)
          END DO
          IF (do_tracers) THEN
            xoi(k, :) = 0.
            DO itr=1,itrcr
              DO l=k,k0
                xoi(k, itr) = xoi(k, itr) + wght(l)*xho(i, l, itr)
              END DO
            END DO
          END IF
          arg1 = poi(k)*prh(k)
          dqq(k) = DQSAT(arg1, pol(k), qsat=qst(k))
        END IF
        mask = seedras(i, 1)/1000000. .LT. 1e-6
        WHERE (mask) 
          WHERE (mask) 
            rndu(:) = 1e-6
          ELSEWHERE
            rndu(:) = seedras(i, 1)/1000000.
          END WHERE
        END WHERE
!!call congvec( npoints , seedcbl , rndu )
        dpth_bl = zcbl(i)
        IF (maxdallowed_d .GE. 0.) THEN
          abs0 = maxdallowed_d
        ELSE
          abs0 = -maxdallowed_d
        END IF
        IF (maxdallowed_s .GE. 0.) THEN
          abs1 = maxdallowed_s
        ELSE
          abs1 = -maxdallowed_s
        END IF
        mxdiam(i) = cnv_fraction(i)*abs0 + (1-cnv_fraction(i))*abs1
        IF (maxdallowed_e .LT. 0) mxdiam(i) = mxdiam(i)*rndu(1)**&
&           maxdallowed_e
! Make MXDIAM stochastic
        DO l=k,icmin,-1
!*
          bet(l) = dqq(l)*pki(l)
!*
          gam(l) = pki(l)/(1.0+lbcp*dqq(l))
          IF (l .LT. k) THEN
            ght(l+1) = gam(l)*dpb(l) + gam(l+1)*dpt(l+1)
            gm1(l+1) = 0.5*lbcp*(dqq(l)/(alhl*(1.0+lbcp*dqq(l)))+dqq(l+1&
&             )/(alhl*(1.0+lbcp*dqq(l+1))))
          END IF
        END DO
        tcu(icmin:k) = -(poi(icmin:k)*prh(icmin:k))
        qcu(icmin:k) = -qoi(icmin:k)
        rns = 0.
        cll = 0.
        rmf = 0.
        rmfd = 0.
        rmfc = 0.
        rmfp = 0.
        cll0 = 0.
        dll0 = 0.
        cllx = 0.
        dllx = 0.
        clli = 0.
        cllb = 0.
        poi_sv = poi
        qoi_sv = qoi
        uoi_sv = uoi
        voi_sv = voi
        IF (do_tracers) xoi_sv = xoi
        lambdsv = 0.0
        cvw = 0.0
        updfrc = 0.0
        updfrp = 0.0
        dissk0 = 0.0
      END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!    IF (PRESENT(FINAL)) THEN
      IF (final .EQ. 1) THEN
        tho(i, icmin:k-1) = poi(icmin:k-1)
        qho(i, icmin:k-1) = qoi(icmin:k-1)
        uho(i, icmin:k-1) = uoi(icmin:k-1)
        vho(i, icmin:k-1) = voi(icmin:k-1)
        cnv_updfrc(i, icmin:k-1) = updfrc(icmin:k-1)
        cnv_cvw(i, icmin:k-1) = cvw(icmin:k-1)
        cnv_qc(i, icmin:k-1) = cllb(icmin:k-1)
!======================AER_CLOUD=============
!               CNV_NDROP   (I,ICMIN:K-1)  =    CNVNDROP(ICMIN:K-1) !DONIF
!               CNV_NICE   (I,ICMIN:K-1)   =     CNVNICE(ICMIN:K-1) !DONIF
!               CNV_FICE   (I,ICMIN:K-1)   =     CNVFICE(ICMIN:K-1) !DONIF
!! De-strap tendencies from RAS
!! specify weighting "SHAPE"
        wght = wgt1(i, :)
!! Scale properly by layer masses
        wght0 = 0.
        DO l=k,k0
          wght0 = wght0 + wght(l)*(ple(i, l+1)-ple(i, l))
        END DO
        wght0 = (prs(k+1)-prs(k))/wght0
        wght = wght0*wght
        DO l=k,k0
          tho(i, l) = tho(i, l) + wght(l)*(poi(k)-poi_sv(k))
          qho(i, l) = qho(i, l) + wght(l)*(qoi(k)-qoi_sv(k))
          uho(i, l) = uho(i, l) + wght(l)*(uoi(k)-uoi_sv(k))
          vho(i, l) = vho(i, l) + wght(l)*(voi(k)-voi_sv(k))
        END DO
        IF (do_tracers) THEN
          xho(i, icmin:k-1, :) = xoi(icmin:k-1, :)
          DO itr=1,itrcr
            DO l=k,k0
              xho(i, l, itr) = xho(i, l, itr) + wght(l)*(xoi(k, itr)-&
&               xoi_sv(k, itr))
            END DO
          END DO
        END IF
!  (KG/m^2/s @ CLOUD BASE)
        flx(i, icmin:k) = rmf(icmin:k)*ddt/daylen
!  (KG/m^2/s @ CLOUD TOP)
        flxd(i, icmin:k) = rmfd(icmin:k)*ddt/daylen
!  (KG/m^2/s @ CLOUD TOP)
        flxc(i, icmin:k) = rmfc(icmin:k)*ddt/daylen
!  (KG/m^2/s )
        clw(i, icmin:k) = cll(icmin:k)*ddt/daylen
        IF (PRESENT(disske)) disske(i, icmin:k-1) = dissk0(icmin:k-1)*&
&           ddt/daylen
        flx(i, 1:icmin-1) = 0.
        flxd(i, 1:icmin-1) = 0.
        flxc(i, 1:icmin-1) = 0.
        clw(i, 1:icmin-1) = 0.
        IF (k .LT. k0) THEN
          flx(i, k:k0) = 0.
          flxd(i, k:k0) = 0.
          flxc(i, k:k0) = 0.
          clw(i, k:k0) = 0.
        END IF
        irc(i, icmin:k-1) = rc(icmin:k-1)
        IF (ALLOCATED(icl_v)) THEN
          DEALLOCATE(icl_v)
        END IF
      END IF
      IF (final .EQ. 2) THEN
        flx(i, :) = 0.
        flxd(i, :) = 0.
        flxc(i, :) = 0.
        clw(i, :) = 0.
        irc(i, icmin:k-1) = rc(icmin:k-1)
      END IF
      RETURN
    END SUBROUTINE STRAP
  END SUBROUTINE RASE_ADM
!  Differentiation of sundq3_ice in reverse (adjoint) mode (with options r8):
!   gradient     of useful results: f2
!   with respect to varying inputs: temp f2
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE SUNDQ3_ICE_ADM(temp, temp_ad, rate2, rate3, te1, f2, f2_ad&
&   , f3)
    IMPLICIT NONE
    REAL, INTENT(IN) :: temp, rate2, rate3, te1
    REAL :: temp_ad
    REAL :: f2, f3
    REAL :: f2_ad
!,RATE2,RATE3,TE1
    REAL :: xx, yy, te0, te2, jump1
    INTEGER :: branch
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!  Ice - phase treatment totally invented
!!  Sharp increase in autoconversion in range
!!  ~~TE1 K ~< T < TE0 K .
!!  (JTB, 3/25/2003)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    te0 = 273.
    te2 = 200.
    jump1 = (rate2-1.0)/(te0-te1)**0.333
!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Ice - phase treatment  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IF (temp .GE. te0) THEN
      CALL PUSHREAL8(f2)
      f2 = 1.0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (temp .GE. te1 .AND. temp .LT. te0) THEN
      CALL PUSHREAL8(f2)
      f2 = 1.0 + jump1*(te0-temp)**0.3333
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (temp .LT. te1) THEN
      CALL PUSHREAL8(f2)
      f2 = rate2 + (rate3-rate2)*(te1-temp)/(te1-te2)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IF (f2 .GT. 27.0) f2_ad = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(f2)
      temp_ad = -((rate3-rate2)*f2_ad/(te1-te2))
      f2_ad = 0.0_8
    ELSE
      temp_ad = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(f2)
      temp_ad = temp_ad - 0.3333*(te0-temp)**(-0.6667)*jump1*f2_ad
      f2_ad = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(f2)
      f2_ad = 0.0_8
    END IF
  END SUBROUTINE SUNDQ3_ICE_ADM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  SUBROUTINE SUNDQ3_ICE(temp, rate2, rate3, te1, f2, f3)
    IMPLICIT NONE
    REAL, INTENT(IN) :: temp, rate2, rate3, te1
    REAL, INTENT(OUT) :: f2, f3
!,RATE2,RATE3,TE1
    REAL :: xx, yy, te0, te2, jump1
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!  Ice - phase treatment totally invented
!!  Sharp increase in autoconversion in range
!!  ~~TE1 K ~< T < TE0 K .
!!  (JTB, 3/25/2003)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    te0 = 273.
    te2 = 200.
    jump1 = (rate2-1.0)/(te0-te1)**0.333
!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Ice - phase treatment  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IF (temp .GE. te0) THEN
      f2 = 1.0
      f3 = 1.0
    END IF
    IF (temp .GE. te1 .AND. temp .LT. te0) THEN
      f2 = 1.0 + jump1*(te0-temp)**0.3333
      f3 = 1.0
    END IF
    IF (temp .LT. te1) THEN
      f2 = rate2 + (rate3-rate2)*(te1-temp)/(te1-te2)
      f3 = 1.0
    END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IF (f2 .GT. 27.0) f2 = 27.0
  END SUBROUTINE SUNDQ3_ICE
  SUBROUTINE CONGVEC(npoints, seed, ran)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npoints
    INTEGER, INTENT(INOUT) :: seed(npoints)
    REAL, INTENT(INOUT) :: ran(npoints)
! variables for RNG
    INTEGER :: irand, i2_16, overflow_32
    INTEGER, PARAMETER :: huge32=2147483647
    INTRINSIC MOD
    i2_16 = 65536
!i2_16=111
! Num. Recipes
    DO irand=1,npoints
! Marsaglia CONG algorithm
      seed(irand) = 1664525*seed(irand) + 1013904223
! mod 32 bit overflow
      seed(irand) = MOD(seed(irand), 2**32)
      ran(irand) = seed(irand)*0.931322574615479e-09
    END DO
  END SUBROUTINE CONGVEC
!==Subroutine Qremoval ============
!Physically based parameterization for removal of condensate (Barahona et al. GMD 2014)
!Written by Donifan Barahona according to DelGenio et al. 2005. J Climate with some modifications
!donifan.barahona@nasa.gov
!================================================================
  SUBROUTINE QREMOVAL(rate_q, fice_, f_nl, f_ni, te, pre, qc, ni, nl, &
&   vcnx, fpice_, dtl, rim, coauto)
    IMPLICIT NONE
!This calculations are needed since we do not have explicit microphysics in RAS. All Fs are tendencies
    REAL, INTENT(IN) :: fice_, te, pre, qc, vcnx, ni, nl, dtl, coauto
    REAL, INTENT(INOUT) :: rim
    REAL, INTENT(OUT) :: rate_q, f_nl, f_ni, fpice_
    REAL :: dc_r, dc_g, dc_i, lamr, lamg, lami, fqi, fqr, fqg, fpi, fpr&
&   , fpg, no, rho_r, rho_g, rho_i, qr, qg, qi, fqig, rho_a, psc, qpt, &
&   aux, vcn, ng, fni, fnr, fng, ni_, beta6, xs, prc, si, ai, ah, bh, tc&
&   , l, n
    REAL :: mui
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC EXP
    INTRINSIC LOG
    INTRINSIC SQRT
    REAL :: min1
    REAL :: min2
    REAL :: min3
    REAL :: x7
    REAL :: x6
    REAL :: x5
    REAL :: x4
    REAL :: x3
    REAL :: x2
    REAL :: x1
    vcn = 1.0
    IF (vcnx .GT. 10.0) THEN
      x1 = 10.0
    ELSE
      x1 = vcnx
    END IF
    IF (x1 .LT. 0.8) THEN
      vcn = 0.8
    ELSE
      vcn = x1
    END IF
!From detailed calculations
    ai = EXP(7.48416e-04*te*te - 4.38424e-01*te + 8.62639e+01)
    ai = 1.0/ai
!From Murphy and Koop 2005
    aux = 210368.0 + 131.438*te - 3.32373e6/te - 41729.1*LOG(te)
!Assumes a saturated environment
    si = EXP(-(aux/8.314/te)) - 1.0
    fqr = 0.0
    fpr = 0.0
    fqi = 0.0
    fpi = 0.0
    fqg = 0.0
    fpg = 0.0
    rate_q = 0.0
    fpice_ = 0.0
    xs = 0.8
!Some constants
!Kg/m3 rain
    rho_r = 1000.0
!Kg/m3 graupel
    rho_g = 500.0
!Kg/m3 ice/snow
    rho_i = 900.0
    rho_a = pre*100.0/mapl_rgas/te
    psc = (pre*273.0/1000.0/te)**0.54
    IF (te - 273.15 .LT. -80.0) THEN
      tc = -80.0
    ELSE
      tc = te - 273.15
    END IF
!fqi  = min(0.25*(1.0-exp((TE-273.15)/10.0)), 1.0) !From delGenio 2005
!fqg  = 1.0-fqi
    fqg = rim
    fqi = 1.0 - fqg
    ng = ni*fqg
    ni_ = ni - ng
    qr = qc*(1.0-fice_)
    qg = qc*fqg*fice_
    qi = qc*fqi*fice_
    IF ((vcn/842.0/psc)**1.25 .LT. 1e-6) THEN
      x2 = 1e-6
    ELSE
      x2 = (vcn/842.0/psc)**1.25
    END IF
    IF (x2 .GT. 1.e-4) THEN
      dc_r = 1.e-4
    ELSE
      dc_r = x2
    END IF
    IF (1.0e-3*(vcn/19.3/psc)**2.70 .LT. 1.e-6) THEN
      x3 = 1.e-6
    ELSE
      x3 = 1.0e-3*(vcn/19.3/psc)**2.70
    END IF
    IF (x3 .GT. 1.e-2) THEN
      dc_g = 1.e-2
    ELSE
      dc_g = x3
    END IF
    ah = 2.0*psc
    IF (tc .GT. 0.0) THEN
      min1 = 0.0
    ELSE
      min1 = tc
    END IF
    bh = 0.244 - 0.0049*min1
!
    bh = 1/bh
    dc_i = 0.01*(vcn/ah)**bh
    IF (dc_i .LT. 4.0e-6) THEN
      x4 = 4.0e-6
    ELSE
      x4 = dc_i
    END IF
    IF (x4 .GT. 5.e-4) THEN
      dc_i = 5.e-4
    ELSE
      dc_i = x4
    END IF
!rain===============Follow Liu 2006====================
    IF (qr .GT. 1.e-9 .AND. nl .GT. 1.0) THEN
      IF ((mapl_pi*rho_r*nl/rho_a/qr)**(1./3.) .GT. 1.0e8) THEN
        lamr = 1.0e8
      ELSE
        lamr = (mapl_pi*rho_r*nl/rho_a/qr)**(1./3.)
      END IF
      IF (dc_r*lamr .GT. 10.0) THEN
        x5 = 10.0
      ELSE
        x5 = dc_r*lamr
      END IF
      IF (x5 .LT. 0.1) THEN
        aux = 0.1
      ELSE
        aux = x5
      END IF
!g cm-3
      l = 1.0e-3*qr*rho_a
!cm-3
      n = nl*1.e-6*rho_a
! relative dispersion from Yangang Liu et al 2008 Environ. Res. Lett. 3 045021 doi:10.1088/1748-9326/3/4/045021
!Corrected
      xs = 0.070*(l/n)**(-0.140)
      IF (xs .GT. 1.7) THEN
        x6 = 1.7
      ELSE
        x6 = xs
      END IF
      IF (x6 .LT. 1.0001) THEN
        xs = 1.0001
      ELSE
        xs = x6
      END IF
      xs = xs*xs*xs
! from Eq. 2 (gives e^2)
      xs = (xs+SQRT(xs+8.0)*SQRT(xs)-4.0)/8.0
! Autoconvesion rate from Liu, Yangang, et al. Journal of the atmospheric sciences 63.3 (2006): 1103-1109.
      beta6 = (1.0+3.0*xs)*(1.0+4.0*xs)*(1.0+5.0*xs)/(1.0+xs)/(1.0+2.0*&
&       xs)
!xs =aux*aux*aux
!xs = max(min(1/xs, 20.0), 1.e-6)
!ratio of mean mass to critical mass
      xs = 1.03e16*(l*l)/(n*SQRT(n))
      IF (20.0 .GT. xs) THEN
        x7 = xs
      ELSE
        x7 = 20.0
      END IF
      IF (x7 .LT. 1.0e-6) THEN
        xs = 1.0e-6
      ELSE
        xs = x7
      END IF
      IF (xs*xs .GT. 20.0) THEN
        min2 = 20.0
      ELSE
        min2 = xs*xs
      END IF
!Using miu =2.0
      prc = 1.1e10*beta6*l*l*l*(1.0-EXP(-min2))/n
!return to mixing ratio
      prc = prc*1.0e3/rho_a
!COAUTO is a tuning factor that accounts for the increase in rain by accretion
      fpr = prc/qr
! NUmber autoconversion rate is approximated according to Liu, Yangang, et al. Geophysical Research Letters 34.16 (2007).
! Assumes e =  0.33. Replaces previous formulatin by Barahona et al. 2014 GMD
!xs= 9.7e-17*N*sqrt(N)/L/L !Eq. 8c
!fnr=fpr*6.0/(aux*aux*aux+3.0*aux*aux+6.0*aux + 6.)
! from Eqs. 13a and 13b
      fnr = fpr/(1.0+1./xs)
!print *, '====f===',xs, fpr, fnr
    ELSE
      fpr = 0.0
      fnr = 0.0
    END IF
!graupel
    IF (.false.) THEN
      IF (qg .GT. 1.e-9 .AND. ng .GT. 1.0) THEN
        IF ((mapl_pi*rho_g*ng/rho_a/qg)**(1./3.) .GT. 1.0e6) THEN
          lamg = 1.0e6
        ELSE
          lamg = (mapl_pi*rho_g*ng/rho_a/qg)**(1./3.)
        END IF
        aux = dc_g*lamg
!precipitated fraction
        fpg = EXP(-aux)*(aux*aux*aux+3.0*aux*aux+6.0*aux+6.)/6.0
        IF (fpg .GT. 1.0) THEN
          min3 = 1.0
        ELSE
          min3 = fpg
        END IF
        fpg = min3/dtl
        fng = EXP(-aux)/dtl
      ELSE
        fpg = 0.0
        fng = 0.0
      END IF
    ELSE IF (qg .GT. 1.e-9 .AND. ng .GT. 1.0) THEN
!use diffusion equation instead
      IF ((mapl_pi*rho_g*ng/rho_a/qg)**(1./3.) .GT. 1.0e6) THEN
        lamg = 1.0e6
      ELSE
        lamg = (mapl_pi*rho_g*ng/rho_a/qg)**(1./3.)
      END IF
      aux = dc_g*lamg
!fpi=exp(-aux)*(aux*aux*aux+3.0*aux*aux+6.0*aux + 6.)/6.0  !precipitated fraction
!fpi=min(fpi, 1.0)
!fni=exp(-aux)
!Assume that ice crystals only grow by diffusion
      fng = ai*si/dc_g/dc_g
!Only sizes with D<Dc can grow to Dc
      fng = fng*(1.0-EXP(-aux))
      fpg = fng*(aux*aux*aux+3.0*aux*aux+6.0*aux+6.)/6.0
    ELSE
      fpg = 0.0
      fng = 0.0
    END IF
!ice
    IF (qi .GT. 1.e-9 .AND. ni_ .GT. 1.0) THEN
      lami = (mapl_pi*rho_i*ni_/rho_a/qi)**(1./3.)
      aux = dc_i*lami
!fpi=exp(-aux)*(aux*aux*aux+3.0*aux*aux+6.0*aux + 6.)/6.0  !precipitated fraction
!fpi=min(fpi, 1.0)/DTL
!fni=exp(-aux)/DTL
!Assume that ice crystals only grow by diffusion
      fni = ai*si/dc_i/dc_i
!Only sizes with D<Dc can grow to Dc
      fni = fni*(1.0-EXP(-aux))
      fpi = fni*(aux*aux*aux+3.0*aux*aux+6.0*aux+6.)/6.0
    ELSE
      fpi = 0.0
      fni = 0.0
    END IF
    IF (fng .GT. 1.0/dtl) THEN
      fng = 1.0/dtl
    ELSE
      fng = fng
    END IF
    IF (fpg .GT. 1.0/dtl) THEN
      fpg = 1.0/dtl
    ELSE
      fpg = fpg
    END IF
    IF (fni .GT. 1.0/dtl) THEN
      fni = 1.0/dtl
    ELSE
      fni = fni
    END IF
    IF (fpi .GT. 1.0/dtl) THEN
      fpi = 1.0/dtl
    ELSE
      fpi = fpi
    END IF
    IF (fnr .GT. 1.0/dtl) THEN
      fnr = 1.0/dtl
    ELSE
      fnr = fnr
    END IF
    IF (fpr .GT. 1.0/dtl) THEN
      fpr = 1.0/dtl
    ELSE
      fpr = fpr
    END IF
    qpt = fpr*qr*(1.0-fice_) + fpg*qg*fice_ + fpi*qi*fice_
    f_nl = fnr
    f_ni = fqg*fng + fqi*fni
    fpice_ = fqi*fpi + fqg*fpg
    IF (qc .GT. 1e-10) rate_q = qpt/qc
    IF (rate_q .GT. 1.0/dtl) THEN
      rate_q = 1.0/dtl
    ELSE
      rate_q = rate_q
    END IF
    IF (fpice_ .GT. 1.0/dtl) THEN
      fpice_ = 1.0/dtl
    ELSE
      fpice_ = fpice_
    END IF
  END SUBROUTINE QREMOVAL
!=================================================================
  FUNCTION ICE_FRACTION(temp) RESULT (ICEFRCT)
    IMPLICIT NONE
    REAL, INTENT(IN) :: temp
    REAL :: icefrct, t_ice_all, t_ice_max
    INTRINSIC MIN
    INTRINSIC MAX
    t_ice_all = 238.0
    t_ice_max = 273.0
    icefrct = 0.00
    IF (temp .LE. t_ice_all) icefrct = 1.000
    IF (temp .GT. t_ice_all .AND. temp .LE. t_ice_max) icefrct = 1.00 - &
&       (temp-t_ice_all)/(t_ice_max-t_ice_all)
    IF (icefrct .GT. 1.00) THEN
      icefrct = 1.00
    ELSE
      icefrct = icefrct
    END IF
    IF (icefrct .LT. 0.00) THEN
      icefrct = 0.00
    ELSE
      icefrct = icefrct
    END IF
  END FUNCTION ICE_FRACTION
!*************************************************************
!Approximation to the error function
!*************************************************************
  REAL*8 FUNCTION ERFAPP(x)
    IMPLICIT NONE
    REAL, INTENT(IN) :: x
    REAL :: a
    INTRINSIC EXP
    INTRINSIC SQRT
    a = x*x*(1.27324d0+0.147d0*x*x)/(1d0+0.147d0*x*x)
    erfapp = SQRT(1d0 - EXP(-a))
    IF (x .LT. 0.0) erfapp = -erfapp
  END FUNCTION ERFAPP
END MODULE RAS_DIFF
