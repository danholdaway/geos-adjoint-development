module IRRAD_AD

IMPLICIT NONE

PRIVATE
PUBLIC :: irrad_b

contains

!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.9 (r5096) - 24 Feb 2014 16:53
!
!  Differentiation of irrad in reverse (adjoint) mode:
!   gradient     of useful results: flxu_dev dfdts_dev flxd_dev
!   with respect to varying inputs: flxu_dev ta_dev dfdts_dev flxd_dev
!   RW status of diff variables: flxu_dev:in-zero ta_dev:out dfdts_dev:in-zero
!                flxd_dev:in-zero
SUBROUTINE IRRAD_B(m, np, ta_dev, ta_devb, flxu_dev, flxu_devb, flxd_dev&
& , flxd_devb, dfdts_dev, dfdts_devb)
  IMPLICIT NONE
!----- INPUTS -----
  INTEGER, INTENT(IN) :: m, np
  REAL, DIMENSION(m, np), INTENT(IN) :: ta_dev
  REAL, DIMENSION(m, np) :: ta_devb
  REAL, DIMENSION(m, np + 1) :: flxu_dev
  REAL, DIMENSION(m, np+1) :: flxu_devb
  REAL, DIMENSION(m, np + 1) :: flxd_dev
  REAL, DIMENSION(m, np+1) :: flxd_devb
  REAL, DIMENSION(m, np + 1) :: dfdts_dev
  REAL, DIMENSION(m, np+1) :: dfdts_devb
  INTEGER :: i, j
  ta_devb = 0.0
  DO i=m,1,-1
    DO j=np,1,-1
      flxu_devb(i, j) = flxu_devb(i, j) + 0.5*dfdts_devb(i, j)
      flxd_devb(i, j) = flxd_devb(i, j) + 0.5*dfdts_devb(i, j)
      dfdts_devb(i, j) = 0.0
      ta_devb(i, j) = ta_devb(i, j) + (1e-8*2*ta_dev(i, j)+1e-6)*&
&       flxu_devb(i, j) + (1e-10*3*ta_dev(i, j)**2+1e-4)*flxd_devb(i, j)
      flxd_devb(i, j) = 0.0
      flxu_devb(i, j) = 0.0
    END DO
  END DO
  flxu_devb = 0.0
  dfdts_devb = 0.0
  flxd_devb = 0.0
END SUBROUTINE IRRAD_B


end module IRRAD_AD
