!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.9 (r5096) - 24 Feb 2014 16:53
!
!  Differentiation of irrad in reverse (adjoint) mode:
!   gradient     of useful results: flxu_dev dfdts_dev flxd_dev
!   with respect to varying inputs: wa_dev fcld_dev cwc_dev flxu_dev
!                ta_dev tb_dev dfdts_dev reff_dev flxd_dev oa_dev
!   RW status of diff variables: wa_dev:out fcld_dev:out cwc_dev:out
!                flxu_dev:in-out ta_dev:out tb_dev:out dfdts_dev:in-out
!                reff_dev:out flxd_dev:in-out oa_dev:out
!Number of soundings (IM*JM)
!Number of layers (LM)
!Pressure at level edges (Pa)
!d - Temperature (K)
!d - Specific humidity (g/g)
!d - Ozone (g/g)
!Surface air temperature (K)
!* Carbon dioxide (pppv)
!Option
!* Nitrous oxide (pppv)
!* Methane (pppv)
!* Trichlorofluoromethane (pppv)
!* Dichlorodifluoromethane (pppv)
!* Chlorodifluoromethane (pppv)
!Cloud water mixing ratio (kg/kg) 
!Cloud amount (fraction)
!Level index separating high and middle clouds
!Level index separating middle and low clouds
!Effective size of cloud particles (micron)
!Number of sub-grid surface types
!Fractional cover of sub-grid regions
!Land or ocean surface temperature
!Land or ocean surface emissivity
!Vegetation temperature
!Vegetation emissivity
!Vegetation reflectivity 
!Number of bands
!Number of bands in IRRAD calcs for Chou
!Aerosol optical thickness
!Aerosol single scattering albedo
!Aerosol asymmetry factor
!Outputs
!Upwelling flux, all-sky
!                    flcu_dev    , & !Upwelling flux, clear-sky
!                    flau_dev    , & !Upwelling flux, clear-sky no aerosol
!Downwelling flux, all-sky
!                    flcd_dev    , & !Downwelling flux, clear-sky
!                    flad_dev    , & !Downwelling flux, clear-sky no aerosol
!Sensitivity of net downward flux to surface temperature
!                    sfcem_dev   , & !Emission by the surface
!                    taudiag_dev , & !Optical depth for beam radiation
!Switch for overcast simplification
SUBROUTINE IRRAD_B(m, np, ple_dev, ta_dev, ta_devb, wa_dev, wa_devb, &
& oa_dev, oa_devb, tb_dev, tb_devb, co2, trace, n2o_dev, ch4_dev, &
& cfc11_dev, cfc12_dev, cfc22_dev, cwc_dev, cwc_devb, fcld_dev, &
& fcld_devb, ict, icb, reff_dev, reff_devb, ns, fs_dev, tg_dev, eg_dev, &
& tv_dev, ev_dev, rv_dev, na, nb, taua_dev, ssaa_dev, asya_dev, flxu_dev&
& , flxu_devb, flxd_dev, flxd_devb, dfdts_dev, dfdts_devb, overcastl, &
& aib_ir, awb_ir, aiw_ir, aww_ir, aig_ir, awg_ir, xkw, xke, mw, aw, bw, &
& pm, fkw, gkw, cb, dcb, w11, w12, w13, p11, p12, p13, dwe, dpe, c1, c2&
& , c3, oo1, oo2, oo3, h11, h12, h13, h21, h22, h23, h81, h82, h83)
  IMPLICIT NONE
!   end do
!Radiation constants, these need to be inputs for the autodiff tool
  REAL, INTENT(IN) :: aib_ir(3, 10), awb_ir(4, 10), aiw_ir(4, 10)
  REAL, INTENT(IN) :: aww_ir(4, 10), aig_ir(4, 10), awg_ir(4, 10)
  INTEGER, INTENT(IN) :: mw(9)
  REAL, INTENT(IN) :: xkw(9), xke(9), aw(9), bw(9), pm(9)
  REAL, INTENT(IN) :: fkw(6, 9), gkw(6, 3), cb(6, 10), dcb(5, 10)
  REAL, INTENT(IN) :: w11, w12, w13, p11, p12
  REAL, INTENT(IN) :: p13, dwe, dpe
  REAL, INTENT(IN) :: c1(26, 30), c2(26, 30), c3(26, 30)
  REAL, INTENT(IN) :: oo1(26, 21), oo2(26, 21), oo3(26, 21)
  REAL, INTENT(IN) :: h11(26, 31), h12(26, 31), h13(26, 31)
  REAL, INTENT(IN) :: h21(26, 31), h22(26, 31), h23(26, 31)
  REAL, INTENT(IN) :: h81(26, 31), h82(26, 31), h83(26, 31)
!----- INPUTS -----
  INTEGER, INTENT(IN) :: m, np, ict, icb, ns, na, nb
  LOGICAL, INTENT(IN) :: trace, overcastl
  REAL, INTENT(IN) :: co2
!Rank 2 inputs
  REAL, DIMENSION(m), INTENT(IN) :: tb_dev
  REAL, DIMENSION(m) :: tb_devb
!Rank 3 (Prognostic variables and tracers)
  REAL, DIMENSION(m, np), INTENT(IN) :: ta_dev, wa_dev, oa_dev, fcld_dev
  REAL, DIMENSION(m, np) :: ta_devb, wa_devb, oa_devb, fcld_devb
  REAL, DIMENSION(m, np), INTENT(IN) :: n2o_dev, ch4_dev, cfc11_dev, &
& cfc12_dev, cfc22_dev
  REAL, DIMENSION(m, np + 1), INTENT(IN) :: ple_dev
!Rank 3 (surface types)
  REAL, DIMENSION(m, ns), INTENT(IN) :: fs_dev, tg_dev, tv_dev
  REAL, DIMENSION(m, ns, 10), INTENT(IN) :: eg_dev, ev_dev, rv_dev
!Rank 3 (diagnostic cloud parts)
  REAL, DIMENSION(m, np, 4), INTENT(IN) :: cwc_dev, reff_dev
  REAL, DIMENSION(m, np, 4) :: cwc_devb, reff_devb
!Rank 3 (aerosols)
  REAL, DIMENSION(m, np, nb), INTENT(INOUT) :: taua_dev, ssaa_dev, &
& asya_dev
!----- OUPUTS -----
!REAL, DIMENSION(m), INTENT(OUT)         :: sfcem_dev
!, flcu_dev, flau_dev
  REAL, DIMENSION(m, np + 1), INTENT(INOUT) :: flxu_dev
  REAL, DIMENSION(m, np+1), INTENT(INOUT) :: flxu_devb
!, flcd_dev, flad_dev
  REAL, DIMENSION(m, np + 1), INTENT(INOUT) :: flxd_dev
  REAL, DIMENSION(m, np+1), INTENT(INOUT) :: flxd_devb
  REAL, DIMENSION(m, np + 1), INTENT(INOUT) :: dfdts_dev
  REAL, DIMENSION(m, np+1), INTENT(INOUT) :: dfdts_devb
!REAL, DIMENSION(m,np,10), INTENT(OUT)   :: taudiag_dev
!----- LOCALS -----
  REAL, PARAMETER :: cons_grav=9.80665
  INTEGER, PARAMETER :: nx1=26
  INTEGER, PARAMETER :: no1=21
  INTEGER, PARAMETER :: nc1=30
  INTEGER, PARAMETER :: nh1=31
!Temporary arrays
  REAL :: pa(0:np), dt(0:np)
  REAL :: dtb(0:np)
  REAL :: x1, x2, x3
  REAL :: x1b, x2b, x3b
  REAL :: dh2o(0:np), dcont(0:np), dco2(0:np), do3(0:np)
  REAL :: dh2ob(0:np), dcontb(0:np), dco2b(0:np), do3b(0:np)
  REAL :: dn2o(0:np), dch4(0:np)
  REAL :: df11(0:np), df12(0:np), df22(0:np)
  REAL :: th2o(6), tcon(3), tco2(6)
  REAL :: th2ob(6), tconb(3), tco2b(6)
  REAL :: tn2o(4), tch4(4), tcom(6)
  REAL :: tn2ob(4), tch4b(4), tcomb(6)
  REAL :: tf11, tf12, tf22
  REAL :: tf11b, tf12b, tf22b
  REAL :: blayer(0:np+1), blevel(0:np+1)
  REAL :: blayerb(0:np+1), blevelb(0:np+1)
  REAL :: cd(0:np+1), cu(0:np+1)
  REAL :: bd(0:np+1), bu(0:np+1)
  REAL :: bdb(0:np+1), bub(0:np+1)
  REAL :: ad(0:np+1), au(0:np+1)
  REAL :: bs, dbs, rflxs
  REAL :: dp(0:np)
  REAL :: taant
  REAL :: trant, tranal
  REAL :: trantb
  REAL :: transfc(0:np+1), trantcr(0:np+1), trantca(0:np+1)
  REAL :: transfcb(0:np+1)
  REAL :: flau(0:np+1), flad(0:np+1)
  REAL :: flcu(0:np+1), flcd(0:np+1)
  REAL :: flxu(0:np+1), flxd(0:np+1)
  REAL :: flxub(0:np+1), flxdb(0:np+1)
  REAL :: taerlyr(0:np)
!OVERCAST
  INTEGER :: ncld(3)
  INTEGER :: icx(0:np)
!OVERCAST
  INTEGER :: idx, rc
  INTEGER :: i, j, k, l, ip, iw, ibn, ik, iq, isb, k1, k2, ne
  REAL :: enn(0:np)
  REAL :: ennb(0:np)
  REAL :: cldhi, cldmd, cldlw, tcldlyr(0:np), fclr, fclr_above
  REAL :: cldhib, cldmdb, cldlwb, tcldlyrb(0:np), fclrb, fclr_aboveb
  REAL :: x, xx, yy, p1, a1, b1, fk1, a2, b2, fk2
  REAL :: xxb, yyb
  REAL :: w1, ff
  LOGICAL :: oznbnd, co2bnd, h2otable, conbnd, n2obnd
  LOGICAL :: ch4bnd, combnd, f11bnd, f12bnd, f22bnd, b10bnd
  LOGICAL :: do_aerosol
!Temp arrays and variables for consolidation of tables
  INTEGER, PARAMETER :: max_num_tables=17
  REAL :: exptbl(0:np, max_num_tables)
  REAL :: exptblb(0:np, max_num_tables)
  TYPE BAND_TABLE
      INTEGER :: start
      INTEGER :: end
  END TYPE BAND_TABLE
  TYPE(BAND_TABLE) :: h2oexp
  TYPE(BAND_TABLE) :: conexp
  TYPE(BAND_TABLE) :: co2exp
  TYPE(BAND_TABLE) :: n2oexp
  TYPE(BAND_TABLE) :: ch4exp
  TYPE(BAND_TABLE) :: comexp
  TYPE(BAND_TABLE) :: f11exp
  TYPE(BAND_TABLE) :: f12exp
  TYPE(BAND_TABLE) :: f22exp
!Variables for new getirtau routine
  REAL :: dp_pa(np)
  REAL :: taudiaglyr(np, 4)
  REAL :: fcld_col(np)
  REAL :: fcld_colb(np)
  REAL :: reff_col(np, 4)
  REAL :: reff_colb(np, 4)
  REAL :: cwc_col(np, 4)
  REAL :: cwc_colb(np, 4)
  REAL :: h2oexp_tmp(0:np, 5), conexp_tmp(0:np), co2exp_tmp(0:np, 6), &
& n2oexp_tmp(0:np, 2)
  REAL :: h2oexp_tmpb(0:np, 5), co2exp_tmpb(0:np, 6), n2oexp_tmpb(0:np, &
& 2)
  INTRINSIC MAX
  INTRINSIC EXP
  INTRINSIC MIN
  INTRINSIC ALOG
  INTEGER :: arg1
  INTEGER :: branch
  INTEGER :: ad_from
  INTEGER :: ad_count
  INTEGER :: i0
  REAL :: temp2
  REAL :: temp1
  REAL :: temp0
  REAL :: tempb2
  REAL :: tempb1
  REAL :: tempb0
  REAL :: tempb
  REAL :: temp
!BEGIN CALCULATIONS ...
  i = 1
!do i=1,m
!-----compute layer pressure (pa) and layer temperature minus 250K (dt)
  DO k=1,np
    pa(k) = 0.5*(ple_dev(i, k+1)+ple_dev(i, k))*0.01
    dp(k) = (ple_dev(i, k+1)-ple_dev(i, k))*0.01
! dp in Pascals for getirtau
    dp_pa(k) = ple_dev(i, k+1) - ple_dev(i, k)
    dt(k) = ta_dev(i, k) - 250.0
!-----compute layer absorber amount
!     dh2o : water vapor amount (g/cm^2)
!     dcont: scaled water vapor amount for continuum absorption
!            (g/cm^2)
!     dco2 : co2 amount (cm-atm)stp
!     do3  : o3 amount (cm-atm)stp
!     dn2o : n2o amount (cm-atm)stp
!     dch4 : ch4 amount (cm-atm)stp
!     df11 : cfc11 amount (cm-atm)stp
!     df12 : cfc12 amount (cm-atm)stp
!     df22 : cfc22 amount (cm-atm)stp
!     the factor 1.02 is equal to 1000/980
!     factors 789 and 476 are for unit conversion
!     the factor 0.001618 is equal to 1.02/(.622*1013.25) 
!     the factor 6.081 is equal to 1800/296
    dh2o(k) = 1.02*wa_dev(i, k)*dp(k)
    do3(k) = 476.*oa_dev(i, k)*dp(k)
    dco2(k) = 789.*co2*dp(k)
    dch4(k) = 789.*ch4_dev(i, k)*dp(k)
    dn2o(k) = 789.*n2o_dev(i, k)*dp(k)
    df11(k) = 789.*cfc11_dev(i, k)*dp(k)
    df12(k) = 789.*cfc12_dev(i, k)*dp(k)
    df22(k) = 789.*cfc22_dev(i, k)*dp(k)
    IF (dh2o(k) .LT. 1.e-10) THEN
      dh2o(k) = 1.e-10
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      dh2o(k) = dh2o(k)
    END IF
    IF (do3(k) .LT. 1.e-6) THEN
      do3(k) = 1.e-6
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      do3(k) = do3(k)
    END IF
    IF (dco2(k) .LT. 1.e-4) THEN
      dco2(k) = 1.e-4
    ELSE
      dco2(k) = dco2(k)
    END IF
!-----compute scaled water vapor amount for h2o continuum absorption
!     following eq. (4.21).
    xx = pa(k)*0.001618*wa_dev(i, k)*wa_dev(i, k)*dp(k)
    dcont(k) = xx*EXP(1800./ta_dev(i, k)-6.081)
!-----Fill the reff, cwc, and fcld for the column
    fcld_col(k) = fcld_dev(i, k)
    DO l=1,4
      reff_col(k, l) = reff_dev(i, k, l)
      cwc_col(k, l) = cwc_dev(i, k, l)
    END DO
  END DO
  IF (ple_dev(i, 1)*0.01 .LT. 0.005) THEN
    CALL PUSHREAL4(dp(0))
    dp(0) = 0.005
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHREAL4(dp(0))
    dp(0) = ple_dev(i, 1)*0.01
    CALL PUSHCONTROL1B(1)
  END IF
  CALL PUSHREAL4(pa(0))
  pa(0) = 0.5*dp(0)
  dt(0) = ta_dev(i, 1) - 250.0
  dh2o(0) = 1.02*wa_dev(i, 1)*dp(0)
  do3(0) = 476.*oa_dev(i, 1)*dp(0)
  dco2(0) = 789.*co2*dp(0)
  dch4(0) = 789.*ch4_dev(i, 1)*dp(0)
  dn2o(0) = 789.*n2o_dev(i, 1)*dp(0)
  df11(0) = 789.*cfc11_dev(i, 1)*dp(0)
  df12(0) = 789.*cfc12_dev(i, 1)*dp(0)
  df22(0) = 789.*cfc22_dev(i, 1)*dp(0)
  IF (dh2o(0) .LT. 1.e-10) THEN
    dh2o(0) = 1.e-10
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    dh2o(0) = dh2o(0)
  END IF
  IF (do3(0) .LT. 1.e-6) THEN
    do3(0) = 1.e-6
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    do3(0) = do3(0)
  END IF
  IF (dco2(0) .LT. 1.e-4) THEN
    dco2(0) = 1.e-4
  ELSE
    dco2(0) = dco2(0)
  END IF
  xx = pa(0)*0.001618*wa_dev(i, 1)*wa_dev(i, 1)*dp(0)
  dcont(0) = xx*EXP(1800./ta_dev(i, 1)-6.081)
!-----the surface (np+1) is treated as a layer filled with black clouds.
!     transfc is the transmittance between the surface and a pressure
!     level.
!     trantcr is the clear-sky transmittance between the surface and a
!     pressure level.
!sfcem_dev(i) =0.0
  transfc(np+1) = 1.0
  CALL PUSHINTEGER4(ibn)
  ad_count = 1
!do k=1,np
!   do l=1,10
!      taudiag_dev(i,k,l) = 0.0
!   end do
!end do
!-----integration over spectral bands
  DO ibn=1,10
    IF (ibn .EQ. 10 .AND. (.NOT.trace)) THEN
      GOTO 100
    ELSE
!-----if h2otable, compute h2o (line) transmittance using table look-up.
!     if conbnd,   compute h2o (continuum) transmittance in bands 2-7.
!     if co2bnd,   compute co2 transmittance in band 3.
!     if oznbnd,   compute  o3 transmittance in band 5.
!     if n2obnd,   compute n2o transmittance in bands 6 and 7.
!     if ch4bnd,   compute ch4 transmittance in bands 6 and 7.
!     if combnd,   compute co2-minor transmittance in bands 4 and 5.
!     if f11bnd,   compute cfc11 transmittance in bands 4 and 5.
!     if f12bnd,   compute cfc12 transmittance in bands 4 and 6.
!     if f22bnd,   compute cfc22 transmittance in bands 4 and 6.
!     if b10bnd,   compute flux reduction due to n2o in band 10.
      h2otable = (ibn .EQ. 1 .OR. ibn .EQ. 2) .OR. ibn .EQ. 8
      conbnd = ibn .GE. 2 .AND. ibn .LE. 7
      co2bnd = ibn .EQ. 3
      oznbnd = ibn .EQ. 5
      n2obnd = ibn .EQ. 6 .OR. ibn .EQ. 7
      ch4bnd = ibn .EQ. 6 .OR. ibn .EQ. 7
      combnd = ibn .EQ. 4 .OR. ibn .EQ. 5
      f11bnd = ibn .EQ. 4 .OR. ibn .EQ. 5
      f12bnd = ibn .EQ. 4 .OR. ibn .EQ. 6
      f22bnd = ibn .EQ. 4 .OR. ibn .EQ. 6
      b10bnd = ibn .EQ. 10
      do_aerosol = na .GT. 0
      CALL PUSHREAL4ARRAY(exptbl, (np+1)*17)
      exptbl = 0.0
!-----Control packing of the new exponential tables by band
      SELECT CASE  (ibn) 
      CASE (2) 
        CALL PUSHINTEGER4(conexp%start)
        conexp%start = 1
        CALL PUSHINTEGER4(conexp%end)
        conexp%end = 1
        CALL PUSHCONTROL4B(7)
      CASE (3) 
        CALL PUSHINTEGER4(h2oexp%start)
        h2oexp%start = 1
        CALL PUSHINTEGER4(h2oexp%end)
        h2oexp%end = 6
        CALL PUSHINTEGER4(conexp%start)
        conexp%start = 7
        CALL PUSHINTEGER4(conexp%end)
        conexp%end = 9
        CALL PUSHCONTROL4B(6)
      CASE (4) 
        CALL PUSHINTEGER4(h2oexp%start)
        h2oexp%start = 1
        CALL PUSHINTEGER4(h2oexp%end)
        h2oexp%end = 6
        CALL PUSHINTEGER4(conexp%start)
        conexp%start = 7
        CALL PUSHINTEGER4(conexp%end)
        conexp%end = 7
        CALL PUSHINTEGER4(comexp%start)
        comexp%start = 8
        CALL PUSHINTEGER4(comexp%end)
        comexp%end = 13
        CALL PUSHINTEGER4(f11exp%start)
        f11exp%start = 14
        CALL PUSHINTEGER4(f11exp%end)
        f11exp%end = 14
        CALL PUSHINTEGER4(f12exp%start)
        f12exp%start = 15
        CALL PUSHINTEGER4(f12exp%end)
        f12exp%end = 15
        CALL PUSHINTEGER4(f22exp%start)
        f22exp%start = 16
        CALL PUSHINTEGER4(f22exp%end)
        f22exp%end = 16
        CALL PUSHCONTROL4B(5)
      CASE (5) 
        CALL PUSHINTEGER4(h2oexp%start)
        h2oexp%start = 1
        CALL PUSHINTEGER4(h2oexp%end)
        h2oexp%end = 6
        CALL PUSHINTEGER4(conexp%start)
        conexp%start = 7
        CALL PUSHINTEGER4(conexp%end)
        conexp%end = 7
        CALL PUSHINTEGER4(comexp%start)
        comexp%start = 8
        CALL PUSHINTEGER4(comexp%end)
        comexp%end = 13
        CALL PUSHINTEGER4(f11exp%start)
        f11exp%start = 14
        CALL PUSHINTEGER4(f11exp%end)
        f11exp%end = 14
        CALL PUSHCONTROL4B(4)
      CASE (6) 
        CALL PUSHINTEGER4(h2oexp%start)
        h2oexp%start = 1
        CALL PUSHINTEGER4(h2oexp%end)
        h2oexp%end = 6
        CALL PUSHINTEGER4(conexp%start)
        conexp%start = 7
        CALL PUSHINTEGER4(conexp%end)
        conexp%end = 7
        CALL PUSHINTEGER4(n2oexp%start)
        n2oexp%start = 8
        CALL PUSHINTEGER4(n2oexp%end)
        n2oexp%end = 11
        CALL PUSHINTEGER4(ch4exp%start)
        ch4exp%start = 12
        CALL PUSHINTEGER4(ch4exp%end)
        ch4exp%end = 15
        CALL PUSHINTEGER4(f12exp%start)
        f12exp%start = 16
        CALL PUSHINTEGER4(f12exp%end)
        f12exp%end = 16
        CALL PUSHINTEGER4(f22exp%start)
        f22exp%start = 17
        CALL PUSHINTEGER4(f22exp%end)
        f22exp%end = 17
        CALL PUSHCONTROL4B(3)
      CASE (7) 
        CALL PUSHINTEGER4(h2oexp%start)
        h2oexp%start = 1
        CALL PUSHINTEGER4(h2oexp%end)
        h2oexp%end = 6
        CALL PUSHINTEGER4(conexp%start)
        conexp%start = 7
        CALL PUSHINTEGER4(conexp%end)
        conexp%end = 7
        CALL PUSHINTEGER4(n2oexp%start)
        n2oexp%start = 8
        CALL PUSHINTEGER4(n2oexp%end)
        n2oexp%end = 11
        CALL PUSHINTEGER4(ch4exp%start)
        ch4exp%start = 12
        CALL PUSHINTEGER4(ch4exp%end)
        ch4exp%end = 15
        CALL PUSHCONTROL4B(2)
      CASE (9) 
        CALL PUSHINTEGER4(h2oexp%start)
        h2oexp%start = 1
        CALL PUSHINTEGER4(h2oexp%end)
        h2oexp%end = 6
        CALL PUSHCONTROL4B(1)
      CASE (10) 
        CALL PUSHINTEGER4(h2oexp%start)
        h2oexp%start = 1
        CALL PUSHINTEGER4(h2oexp%end)
        h2oexp%end = 5
        CALL PUSHINTEGER4(conexp%start)
        conexp%start = 6
        CALL PUSHINTEGER4(conexp%end)
        conexp%end = 6
        CALL PUSHINTEGER4(co2exp%start)
        co2exp%start = 7
        CALL PUSHINTEGER4(co2exp%end)
        co2exp%end = 12
        CALL PUSHINTEGER4(n2oexp%start)
        n2oexp%start = 13
        CALL PUSHINTEGER4(n2oexp%end)
        n2oexp%end = 14
        CALL PUSHCONTROL4B(0)
      CASE DEFAULT
        CALL PUSHCONTROL4B(8)
      END SELECT
!-----blayer is the spectrally integrated planck flux of the mean layer
!     temperature derived from eq. (3.11)
!     The fitting for the planck flux is valid for the range 160-345 K.
      DO k=1,np
        CALL PLANCK(ibn, cb, ta_dev(i, k), blayer(k))
      END DO
!-----Index "0" is the layer above the top of the atmosphere.
      blayer(0) = blayer(1)
      CALL PUSHREAL4(blevel(0))
      blevel(0) = blayer(1)
!-----Surface emission and reflectivity. See Section 9.
!     bs and dbs include the effect of surface emissivity.
      CALL PUSHREAL4(rflxs)
      CALL PUSHREAL4(dbs)
      CALL SFCFLUX(ibn, m, i, cb, dcb, ns, fs_dev, tg_dev, eg_dev, &
&            tv_dev, ev_dev, rv_dev, bs, dbs, rflxs)
      blayer(np+1) = bs
!------interpolate Planck function at model levels (linear in p)
      DO k=2,np
        CALL PUSHREAL4(blevel(k))
        blevel(k) = (blayer(k-1)*dp(k)+blayer(k)*dp(k-1))/(dp(k-1)+dp(k)&
&         )
      END DO
!-----Extrapolate blevel(1) from blayer(2) and blayer(1)
      CALL PUSHREAL4(blevel(1))
      blevel(1) = blayer(1) + (blayer(1)-blayer(2))*dp(1)/(dp(1)+dp(2))
      CALL PUSHREAL4(blevel(0))
      blevel(0) = blevel(1)
!-----If the surface air temperature tb is known, compute blevel(np+1)
      CALL PUSHREAL4(blevel(np+1))
      CALL PLANCK(ibn, cb, tb_dev(i), blevel(np+1))
!-----if not, extrapolate blevel(np+1) from blayer(np-1) and blayer(np)
!        blevel(np+1)=blayer(np)+(blayer(np)-blayer(np-1))&
!                      *dp(np)/(dp(np)+dp(np-1))
!-----Compute cloud optical thickness following Eqs. (6.4a,b) and (6.7)
!     NOTE: dp_pa is only dims(1:np) as the 0'th level isn't needed in getirtau.
!           Plus, the pressures in getirtau *MUST* be in Pascals.
!     Slots for reff, hydrometeors and tauall are as follows:
!                 1         Cloud Ice
!                 2         Cloud Liquid
!                 3         Falling Liquid (Rain)
!                 4         Falling Ice (Snow)
      CALL PUSHREAL4ARRAY(enn, np + 1)
      CALL PUSHREAL4ARRAY(tcldlyr, np + 1)
      CALL GETIRTAU1(ibn, np, dp_pa, fcld_col, reff_col, cwc_col, &
&              taudiaglyr, tcldlyr, enn, aib_ir, awb_ir, aiw_ir, aww_ir&
&              , aig_ir, awg_ir, cons_grav)
!     The getirtau call returns results for a single band and column. Thus
!     we need to transfer the taudiag for that band/column to the overall array.
!do k=1,np
!   taudiag_dev(i,k,ibn) = taudiag_dev(i,k,ibn) + &
!         taudiaglyr(k,1) + taudiaglyr(k,2) + taudiaglyr(k,3) + taudiaglyr(k,4) 
!end do
!MAT-- icx and ncld only used when overcast=.false.
!Overcast
      IF (overcastl .EQ. .false.) THEN
        DO k=0,np
          CALL PUSHINTEGER4(icx(k))
          icx(k) = k
        END DO
        CALL PUSHINTEGER4ARRAY(ncld, 3)
        CALL PUSHINTEGER4ARRAY(icx, np + 1)
        CALL MKICX(np, ict, icb, enn, icx, ncld)
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!-----Compute optical thickness, single-scattering albedo and asymmetry
!     factor for a mixture of "na" aerosol types. Eqs. (7.1)-(7.3)
      IF (do_aerosol) THEN
        CALL PUSHREAL4(taerlyr(0))
        taerlyr(0) = 1.0
        DO k=1,np
!-----taerlyr is the aerosol diffuse transmittance
          CALL PUSHREAL4(taerlyr(k))
          taerlyr(k) = 1.0
          IF (taua_dev(i, k, ibn) .GT. 0.001) THEN
            IF (ssaa_dev(i, k, ibn) .GT. 0.001) THEN
              asya_dev(i, k, ibn) = asya_dev(i, k, ibn)/ssaa_dev(i, k, &
&               ibn)
              ssaa_dev(i, k, ibn) = ssaa_dev(i, k, ibn)/taua_dev(i, k, &
&               ibn)
!-----Parameterization of aerosol scattering following Eqs. (6.11)
!     and (6.12). 
              ff = .5 + (.3739+(0.0076+0.1185*asya_dev(i, k, ibn))*&
&               asya_dev(i, k, ibn))*asya_dev(i, k, ibn)
              taua_dev(i, k, ibn) = taua_dev(i, k, ibn)*(1.-ssaa_dev(i, &
&               k, ibn)*ff)
            END IF
            taerlyr(k) = EXP(-(1.66*taua_dev(i, k, ibn)))
          END IF
        END DO
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!-----Compute the exponential terms (Eq. 8.21) at each layer due to
!     water vapor line absorption when k-distribution is used
      IF (.NOT.h2otable .AND. (.NOT.b10bnd)) THEN
        CALL PUSHREAL4ARRAY(exptbl(:, h2oexp%start:h2oexp%end), (np+1)*(&
&                     h2oexp%end-h2oexp%start+1))
        CALL H2OEXPS(ibn, np, dh2o, pa, dt, xkw, aw, bw, pm, mw, exptbl(&
&              :, h2oexp%start:h2oexp%end))
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!-----compute the exponential terms (Eq. 4.24) at each layer due to
!     water vapor continuum absorption.
!     ne is the number of terms used in each band to compute water 
!     vapor continuum transmittance (Table 9).
      CALL PUSHINTEGER4(ne)
      ne = 0
      IF (conbnd) THEN
        ne = 1
        IF (ibn .EQ. 3) ne = 3
        CALL PUSHREAL4ARRAY(exptbl(:, conexp%start:conexp%end), (np+1)*(&
&                     conexp%end-conexp%start+1))
        CALL CONEXPS(ibn, np, dcont, xke, exptbl(:, conexp%start:conexp%&
&              end))
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!----- for trace gases 
      IF (trace) THEN
!-----compute the exponential terms at each layer due to n2o absorption
        IF (n2obnd) THEN
          CALL PUSHREAL4ARRAY(exptbl(:, n2oexp%start:n2oexp%end), (np+1)&
&                       *(n2oexp%end-n2oexp%start+1))
          CALL N2OEXPS(ibn, np, dn2o, pa, dt, exptbl(:, n2oexp%start:&
&                n2oexp%end))
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!-----compute the exponential terms at each layer due to ch4 absorption
        IF (ch4bnd) THEN
          CALL PUSHREAL4ARRAY(exptbl(:, ch4exp%start:ch4exp%end), (np+1)&
&                       *(ch4exp%end-ch4exp%start+1))
          CALL CH4EXPS(ibn, np, dch4, pa, dt, exptbl(:, ch4exp%start:&
&                ch4exp%end))
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!-----Compute the exponential terms due to co2 minor absorption
        IF (combnd) THEN
          CALL PUSHREAL4ARRAY(exptbl(:, comexp%start:comexp%end), (np+1)&
&                       *(comexp%end-comexp%start+1))
          CALL COMEXPS(ibn, np, dco2, dt, exptbl(:, comexp%start:comexp%&
&                end))
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!-----Compute the exponential terms due to cfc11 absorption.
!     The values of the parameters are given in Table 7.
        IF (f11bnd) THEN
          a1 = 1.26610e-3
          b1 = 3.55940e-6
          fk1 = 1.89736e+1
          a2 = 8.19370e-4
          b2 = 4.67810e-6
          fk2 = 1.01487e+1
          CALL CFCEXPS(ibn, np, a1, b1, fk1, a2, b2, fk2, df11, dt, &
&                exptbl(:, f11exp%start:f11exp%end))
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!-----Compute the exponential terms due to cfc12 absorption.
        IF (f12bnd) THEN
          a1 = 8.77370e-4
          b1 = -5.88440e-6
          fk1 = 1.58104e+1
          a2 = 8.62000e-4
          b2 = -4.22500e-6
          fk2 = 3.70107e+1
          CALL CFCEXPS(ibn, np, a1, b1, fk1, a2, b2, fk2, df12, dt, &
&                exptbl(:, f12exp%start:f12exp%end))
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!-----Compute the exponential terms due to cfc22 absorption.
        IF (f22bnd) THEN
          a1 = 9.65130e-4
          b1 = 1.31280e-5
          fk1 = 6.18536e+0
          a2 = -3.00010e-5
          b2 = 5.25010e-7
          fk2 = 3.27912e+1
          CALL CFCEXPS(ibn, np, a1, b1, fk1, a2, b2, fk2, df22, dt, &
&                exptbl(:, f22exp%start:f22exp%end))
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!-----Compute the exponential terms at each layer in band 10 due to
!     h2o line and continuum, co2, and n2o absorption
        IF (b10bnd) THEN
          CALL PUSHREAL4ARRAY(n2oexp_tmp, (np+1)*2)
          CALL PUSHREAL4ARRAY(co2exp_tmp, (np+1)*6)
          CALL PUSHREAL4ARRAY(h2oexp_tmp, (np+1)*5)
          CALL B10EXPS(np, dh2o, dcont, dco2, dn2o, pa, dt, h2oexp_tmp, &
&                exptbl(:, conexp%start:conexp%end), co2exp_tmp, &
&                n2oexp_tmp)
          exptbl(:, h2oexp%start:h2oexp%end) = h2oexp_tmp
!              exptbl(:,conexp%start:conexp%end) = conexp_tmp
          exptbl(:, co2exp%start:co2exp%end) = co2exp_tmp
          exptbl(:, n2oexp%start:n2oexp%end) = n2oexp_tmp
          CALL PUSHCONTROL2B(0)
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(2)
      END IF
!-----blayer(np+1) includes the effect of surface emissivity.
! ALT: this was undefined, check with Max if 0.0 is good value
      CALL PUSHREAL4(bu(0))
      bu(0) = 0.0
      CALL PUSHREAL4(bd(0))
      bd(0) = blayer(1)
      CALL PUSHREAL4(bu(np+1))
      bu(np+1) = blayer(np+1)
! ALT: this was undefined, check with Max if 0.0 is good value
! ALT: this was undefined, check with Max if 0.0 is good value
!-----do-loop 1500 is for computing upward (bu) and downward (bd)
!     emission of a layer following Eqs. (8.17), (8.18), (8.19).
!     Here, trant is the transmittance of the layer k2-1.
      DO k2=1,np+1
!-----for h2o line transmission
        IF (.NOT.h2otable) THEN
          th2o = 1.0
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!-----for h2o continuum transmission
        CALL PUSHREAL4ARRAY(tcon, 3)
        tcon = 1.0
        x1 = 0.0
        x2 = 0.0
        x3 = 0.0
        CALL PUSHREAL4(trant)
        trant = 1.0
        IF (h2otable) THEN
!-----Compute water vapor transmittance using table look-up.
!     The following values are taken from Table 8.
!bdc
!              w1=-8.0
!              p1=-2.0
!              dwe=0.3
!              dpe=0.2
          IF (ibn .EQ. 1) THEN
            CALL PUSHREAL4(trant)
            CALL PUSHREAL4(x3)
            CALL PUSHREAL4(x2)
            CALL PUSHREAL4(x1)
            CALL TABLUP(nx1, nh1, dh2o(k2-1), pa(k2-1), dt(k2-1), x1, x2&
&                 , x3, w11, p11, dwe, dpe, h11, h12, h13, trant)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (ibn .EQ. 2) THEN
            CALL PUSHREAL4(trant)
            CALL PUSHREAL4(x3)
            CALL PUSHREAL4(x2)
            CALL PUSHREAL4(x1)
            CALL TABLUP(nx1, nh1, dh2o(k2-1), pa(k2-1), dt(k2-1), x1, x2&
&                 , x3, w11, p11, dwe, dpe, h21, h22, h23, trant)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (ibn .EQ. 8) THEN
            CALL PUSHREAL4(trant)
            CALL PUSHREAL4(x3)
            CALL PUSHREAL4(x2)
            CALL PUSHREAL4(x1)
            CALL TABLUP(nx1, nh1, dh2o(k2-1), pa(k2-1), dt(k2-1), x1, x2&
&                 , x3, w11, p11, dwe, dpe, h81, h82, h83, trant)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
!bdc
!-----for water vapor continuum absorption
          IF (conbnd) THEN
! Only the first exp
            CALL PUSHREAL4(tcon(1))
            tcon(1) = tcon(1)*exptbl(k2-1, conexp%start)
            CALL PUSHREAL4(trant)
            trant = trant*tcon(1)
            CALL PUSHCONTROL2B(0)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE IF (.NOT.b10bnd) THEN
!-----compute water vapor transmittance using k-distribution
          arg1 = k2 - 1
          CALL PUSHREAL4(trant)
          CALL PUSHREAL4ARRAY(tcon, 3)
          CALL PUSHREAL4ARRAY(th2o, 6)
          CALL H2OKDIS(ibn, np, arg1, fkw, gkw, ne, exptbl(:, h2oexp%&
&                start:h2oexp%end), exptbl(:, conexp%start:conexp%end), &
&                th2o, tcon, trant)
          CALL PUSHCONTROL2B(2)
        ELSE
          CALL PUSHCONTROL2B(3)
        END IF
        IF (co2bnd) THEN
!-----Compute co2 transmittance using table look-up method.
!     The following values are taken from Table 8.
!              w1=-4.0
!              p1=-2.0
!              dwe=0.3
!              dpe=0.2
          CALL PUSHREAL4(trant)
          CALL PUSHREAL4(x3)
          CALL PUSHREAL4(x2)
          CALL PUSHREAL4(x1)
          CALL TABLUP(nx1, nc1, dco2(k2-1), pa(k2-1), dt(k2-1), x1, x2, &
&               x3, w12, p12, dwe, dpe, c1, c2, c3, trant)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!-----Always use table look-up to compute o3 transmittance.
!     The following values are taken from Table 8.
        IF (oznbnd) THEN
!              w1=-6.0
!              p1=-2.0
!              dwe=0.3
!              dpe=0.2
          CALL PUSHREAL4(trant)
          CALL PUSHREAL4(x3)
          CALL PUSHREAL4(x2)
          CALL PUSHREAL4(x1)
          CALL TABLUP(nx1, no1, do3(k2-1), pa(k2-1), dt(k2-1), x1, x2, &
&               x3, w13, p13, dwe, dpe, oo1, oo2, oo3, trant)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!-----include aerosol effect
        IF (do_aerosol) THEN
          trant = trant*taerlyr(k2-1)
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
!-----Compute upward (bu) and downward (bd) emission of the layer k2-1
!     following Eqs.(8.17) and (8.18).
!     The effect of clouds on the transmission of a layer is taken
!     into account, following Eq. (8.19).
!     trant is the total transmittance of the layer k2-1.
        CALL PUSHREAL4(xx)
        xx = (1.-enn(k2-1))*trant
        IF (0.9999 .GT. xx) THEN
          CALL PUSHREAL4(yy)
          yy = xx
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL4(yy)
          yy = 0.9999
          CALL PUSHCONTROL1B(1)
        END IF
        IF (0.00001 .LT. yy) THEN
          CALL PUSHCONTROL1B(0)
          yy = yy
        ELSE
          yy = 0.00001
          CALL PUSHCONTROL1B(1)
        END IF
        xx = (blevel(k2-1)-blevel(k2))/ALOG(yy)
        CALL PUSHREAL4(bd(k2-1))
        bd(k2-1) = (blevel(k2)-blevel(k2-1)*yy)/(1.0-yy) - xx
        CALL PUSHREAL4(bu(k2-1))
        bu(k2-1) = blevel(k2-1) + blevel(k2) - bd(k2-1)
      END DO
!-----initialize fluxes
      CALL PUSHREAL4ARRAY(flxd, np + 2)
      flxd = 0.0
!-----Compute upward and downward fluxes for each spectral band, ibn.
      DO k1=0,np
!-----initialization
!
!     cldlw, cldmd, and cldhi are the equivalent black-cloud fractions
!     of low, middle, and high troposphere.
!     tranal is the aerosol transmission function
        CALL PUSHREAL4(cldlw)
        cldlw = 0.0
        CALL PUSHREAL4(cldmd)
        cldmd = 0.0
        CALL PUSHREAL4(cldhi)
        cldhi = 0.0
        CALL PUSHREAL4(tranal)
        tranal = 1.0
!-----for h2o line transmission
        IF (.NOT.h2otable) THEN
          th2o = 1.0
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!-----for h2o continuum transmission
        CALL PUSHREAL4ARRAY(tcon, 3)
        tcon = 1.0
!----- for trace gases
        IF (trace) THEN
!-----for n2o transmission using k-distribution method.
          IF (n2obnd) THEN
            tn2o = 1.0
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
!-----for ch4 transmission using k-distribution method.
          IF (ch4bnd) THEN
            tch4 = 1.0
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
!-----for co2-minor transmission using k-distribution method.
          IF (combnd) THEN
            tcom = 1.0
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
!-----for cfc-11 transmission using k-distribution method.
          IF (f11bnd) THEN
            tf11 = 1.0
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
!-----for cfc-12 transmission using k-distribution method.
          IF (f12bnd) THEN
            tf12 = 1.0
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
!-----for cfc-22 transmission when using k-distribution method.
          IF (f22bnd) THEN
            tf22 = 1.0
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
!-----for the transmission in band 10 using k-distribution method.
          IF (b10bnd) THEN
            th2o = 1.0
            tco2 = 1.0
            tcon(1) = 1.0
            tn2o = 1.0
            CALL PUSHCONTROL2B(0)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
!----- end trace gases
        x1 = 0.0
        x2 = 0.0
        x3 = 0.0
!-----do-loop 3000 are for computing (a) transmittance, trant,
!     and (b) clear line-of-sight, fclr(k2), between levels k1 and k2.
        fclr_above = 1.0
        ad_from = k1 + 1
!MAT--Beginning of original 3000 loop
        DO k2=ad_from,np+1
          CALL PUSHREAL4(trant)
          trant = 1.0
          IF (h2otable) THEN
!-----Compute water vapor transmittance using table look-up.
!     The following values are taken from Table 8.
!                 w1=-8.0
!                 p1=-2.0
!                 dwe=0.3
!                 dpe=0.2
            IF (ibn .EQ. 1) THEN
              CALL PUSHREAL4(trant)
              CALL PUSHREAL4(x3)
              CALL PUSHREAL4(x2)
              CALL PUSHREAL4(x1)
              CALL TABLUP(nx1, nh1, dh2o(k2-1), pa(k2-1), dt(k2-1), x1, &
&                   x2, x3, w11, p11, dwe, dpe, h11, h12, h13, trant)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            IF (ibn .EQ. 2) THEN
              CALL PUSHREAL4(trant)
              CALL PUSHREAL4(x3)
              CALL PUSHREAL4(x2)
              CALL PUSHREAL4(x1)
              CALL TABLUP(nx1, nh1, dh2o(k2-1), pa(k2-1), dt(k2-1), x1, &
&                   x2, x3, w11, p11, dwe, dpe, h21, h22, h23, trant)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            IF (ibn .EQ. 8) THEN
              CALL PUSHREAL4(trant)
              CALL PUSHREAL4(x3)
              CALL PUSHREAL4(x2)
              CALL PUSHREAL4(x1)
              CALL TABLUP(nx1, nh1, dh2o(k2-1), pa(k2-1), dt(k2-1), x1, &
&                   x2, x3, w11, p11, dwe, dpe, h81, h82, h83, trant)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            IF (conbnd) THEN
! Only the first exp
              CALL PUSHREAL4(tcon(1))
              tcon(1) = tcon(1)*exptbl(k2-1, conexp%start)
              CALL PUSHREAL4(trant)
              trant = trant*tcon(1)
              CALL PUSHCONTROL2B(0)
            ELSE
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE IF (.NOT.b10bnd) THEN
!-----compute water vapor transmittance using k-distribution
            arg1 = k2 - 1
            CALL PUSHREAL4(trant)
            CALL PUSHREAL4ARRAY(tcon, 3)
            CALL PUSHREAL4ARRAY(th2o, 6)
            CALL H2OKDIS(ibn, np, arg1, fkw, gkw, ne, exptbl(:, h2oexp%&
&                  start:h2oexp%end), exptbl(:, conexp%start:conexp%end)&
&                  , th2o, tcon, trant)
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(3)
          END IF
          IF (co2bnd) THEN
!-----Compute co2 transmittance using table look-up method.
!     The following values are taken from Table 8.
!                 w1=-4.0
!                 p1=-2.0
!                 dwe=0.3
!                 dpe=0.2
            CALL PUSHREAL4(trant)
            CALL PUSHREAL4(x3)
            CALL PUSHREAL4(x2)
            CALL PUSHREAL4(x1)
            CALL TABLUP(nx1, nc1, dco2(k2-1), pa(k2-1), dt(k2-1), x1, x2&
&                 , x3, w12, p12, dwe, dpe, c1, c2, c3, trant)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
!-----Always use table look-up to compute o3 transmittance.
!     The following values are taken from Table 8.
          IF (oznbnd) THEN
!                 w1=-6.0
!                 p1=-2.0
!                 dwe=0.3
!                 dpe=0.2
            CALL PUSHREAL4(trant)
            CALL PUSHREAL4(x3)
            CALL PUSHREAL4(x2)
            CALL PUSHREAL4(x1)
            CALL TABLUP(nx1, no1, do3(k2-1), pa(k2-1), dt(k2-1), x1, x2&
&                 , x3, w13, p13, dwe, dpe, oo1, oo2, oo3, trant)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
!------ for trace gases 
          IF (trace) THEN
!-----compute n2o transmittance using k-distribution method
            IF (n2obnd) THEN
              arg1 = k2 - 1
              CALL PUSHREAL4(trant)
              CALL PUSHREAL4ARRAY(tn2o, 4)
              CALL N2OKDIS(ibn, np, arg1, exptbl(:, n2oexp%start:n2oexp%&
&                    end), tn2o, trant)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
!-----compute ch4 transmittance using k-distribution method
            IF (ch4bnd) THEN
              arg1 = k2 - 1
              CALL PUSHREAL4(trant)
              CALL PUSHREAL4ARRAY(tch4, 4)
              CALL CH4KDIS(ibn, np, arg1, exptbl(:, ch4exp%start:ch4exp%&
&                    end), tch4, trant)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
!-----compute co2-minor transmittance using k-distribution method
            IF (combnd) THEN
              arg1 = k2 - 1
              CALL PUSHREAL4(trant)
              CALL PUSHREAL4ARRAY(tcom, 6)
              CALL COMKDIS(ibn, np, arg1, exptbl(:, comexp%start:comexp%&
&                    end), tcom, trant)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
!-----compute cfc11 transmittance using k-distribution method
            IF (f11bnd) THEN
              arg1 = k2 - 1
              CALL PUSHREAL4(trant)
              CALL PUSHREAL4(tf11)
              CALL CFCKDIS(np, arg1, exptbl(:, f11exp%start:f11exp%end)&
&                    , tf11, trant)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
!-----compute cfc12 transmittance using k-distribution method
            IF (f12bnd) THEN
              arg1 = k2 - 1
              CALL PUSHREAL4(trant)
              CALL PUSHREAL4(tf12)
              CALL CFCKDIS(np, arg1, exptbl(:, f12exp%start:f12exp%end)&
&                    , tf12, trant)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
!-----compute cfc22 transmittance using k-distribution method
            IF (f22bnd) THEN
              arg1 = k2 - 1
              CALL PUSHREAL4(trant)
              CALL PUSHREAL4(tf22)
              CALL CFCKDIS(np, arg1, exptbl(:, f22exp%start:f22exp%end)&
&                    , tf22, trant)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
!-----Compute transmittance in band 10 using k-distribution method.
!     For band 10, trant is the change in transmittance due to n2o 
!     absorption.
            IF (b10bnd) THEN
              arg1 = k2 - 1
              CALL PUSHREAL4ARRAY(tn2o, 4)
              CALL PUSHREAL4ARRAY(tco2, 6)
              CALL PUSHREAL4ARRAY(tcon, 3)
              CALL PUSHREAL4ARRAY(th2o, 6)
              CALL B10KDIS(np, arg1, exptbl(:, h2oexp%start:h2oexp%end)&
&                    , exptbl(:, conexp%start:conexp%end), exptbl(:, &
&                    co2exp%start:co2exp%end), exptbl(:, n2oexp%start:&
&                    n2oexp%end), th2o, tcon, tco2, tn2o, trant)
              CALL PUSHCONTROL2B(0)
            ELSE
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B(2)
          END IF
!-----   end trace gases
!-----include aerosol effect
          IF (do_aerosol) THEN
            CALL PUSHREAL4(tranal)
            tranal = tranal*taerlyr(k2-1)
            trant = trant*tranal
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
!----- cloud overlapping 
!OVERCAST
          IF (overcastl .EQ. .false.) THEN
            IF (enn(k2-1) .GE. 0.001) THEN
              CALL PUSHREAL4(cldlw)
              CALL PUSHREAL4(cldmd)
              CALL PUSHREAL4(cldhi)
              CALL CLDOVLP(np, k1, k2, ict, icb, icx, ncld, enn, tcldlyr&
&                    , cldhi, cldmd, cldlw)
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            CALL PUSHREAL4(fclr)
            fclr = (1.0-cldhi)*(1.0-cldmd)*(1.0-cldlw)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHREAL4(fclr)
            fclr = fclr_above*tcldlyr(k2-1)
            CALL PUSHCONTROL1B(1)
          END IF
!Overcast
!MAT--End of original 3000 loop
!-----do-loop 4000 is for computing upward and downward fluxes
!     for each spectral band
!     flau, flad: clear-sky aerosol-free upward and downward fluxes
!     flcu, flcd: clear-sky upward and downward fluxes
!     flxu, flxd: all-sky   upward and downward fluxes
!MAT--Beginning of original 4000 loop
!-----The first terms on the rhs of Eqs. (8.15) and (8.16)
          IF (k2 .EQ. k1 + 1 .AND. ibn .NE. 10) THEN
            flxd(k2) = flxd(k2) + bd(k1)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
!-----The summation terms on the rhs of Eqs. (8.15) and (8.16).
!     Also see Eqs. (5.4) and (5.5) for Band 10.
          CALL PUSHREAL4(xx)
          IF (k1 .EQ. 0) THEN
!mjs  bd(-1) is not defined
            xx = -(trant*bd(k1))
            CALL PUSHCONTROL1B(0)
          ELSE
            xx = trant*(bd(k1-1)-bd(k1))
            CALL PUSHCONTROL1B(1)
          END IF
          flxd(k2) = flxd(k2) + xx*fclr
!MAT--End of original 4000 loop
          CALL PUSHREAL4(fclr_above)
          fclr_above = fclr
        END DO
        CALL PUSHINTEGER4(ad_from)
!-----Here, fclr and trant are, respectively, the clear line-of-sight 
!     and the transmittance between k1 and the surface.
        CALL PUSHREAL4(transfc(k1))
        transfc(k1) = trant*fclr
!-----compute the partial derivative of fluxes with respect to
!     surface temperature (Eq. 3.12). 
!     Note: upward flux is negative, and so is dfdts.
        IF (k1 .GT. 0) THEN
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
!-----For surface emission.
      IF (.NOT.b10bnd) THEN
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      CALL PUSHINTEGER4(ibn)
      ad_count = ad_count + 1
    END IF
  END DO
  CALL PUSHCONTROL1B(0)
  CALL PUSHINTEGER4(ad_count)
  GOTO 110
 100 CALL PUSHCONTROL1B(1)
  CALL PUSHINTEGER4(ad_count)
 110 CALL POPINTEGER4(ad_count)
  DO i0=1,ad_count
    IF (i0 .EQ. 1) THEN
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        ta_devb = 0.0
        tb_devb = 0.0
        dh2ob = 0.0
        dcontb = 0.0
        n2oexp_tmpb = 0.0
        dtb = 0.0
        reff_colb = 0.0
        blayerb = 0.0
        tn2ob = 0.0
        transfcb = 0.0
        bdb = 0.0
        h2oexp_tmpb = 0.0
        tcomb = 0.0
        tf11b = 0.0
        tf12b = 0.0
        trantb = 0.0
        bub = 0.0
        th2ob = 0.0
        tcldlyrb = 0.0
        tch4b = 0.0
        tf22b = 0.0
        ennb = 0.0
        fcld_colb = 0.0
        fclrb = 0.0
        cwc_colb = 0.0
        tco2b = 0.0
        co2exp_tmpb = 0.0
        do3b = 0.0
        blevelb = 0.0
      ELSE
        ta_devb = 0.0
        tb_devb = 0.0
        dh2ob = 0.0
        dcontb = 0.0
        n2oexp_tmpb = 0.0
        dtb = 0.0
        reff_colb = 0.0
        blayerb = 0.0
        tn2ob = 0.0
        transfcb = 0.0
        bdb = 0.0
        h2oexp_tmpb = 0.0
        tcomb = 0.0
        tf11b = 0.0
        tf12b = 0.0
        trantb = 0.0
        bub = 0.0
        th2ob = 0.0
        tcldlyrb = 0.0
        tch4b = 0.0
        tf22b = 0.0
        ennb = 0.0
        fcld_colb = 0.0
        fclrb = 0.0
        cwc_colb = 0.0
        tco2b = 0.0
        co2exp_tmpb = 0.0
        do3b = 0.0
        blevelb = 0.0
      END IF
    ELSE
      flxub = 0.0
      flxdb = 0.0
      DO k=np+1,1,-1
        flxdb(k) = flxdb(k) + flxd_devb(i, k)
        flxub(k) = flxub(k) + flxu_devb(i, k)
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        DO k=np+1,1,-1
          flxdb(np+1) = flxdb(np+1) - rflxs*transfc(k)*flxub(k)
          transfcb(k) = transfcb(k) - rflxs*flxd(np+1)*flxub(k)
        END DO
        blayerb(np+1) = blayerb(np+1) - flxub(np+1)
        flxub(np+1) = 0.0
      END IF
      exptblb = 0.0
      DO k1=np,0,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) transfcb(k1) = transfcb(k1) - dbs*dfdts_devb(&
&           i, k1)
        CALL POPREAL4(transfc(k1))
        trantb = trantb + fclr*transfcb(k1)
        fclrb = fclrb + trant*transfcb(k1)
        transfcb(k1) = 0.0
        cldhib = 0.0
        tconb = 0.0
        x1b = 0.0
        x2b = 0.0
        x3b = 0.0
        cldlwb = 0.0
        fclr_aboveb = 0.0
        cldmdb = 0.0
        CALL POPINTEGER4(ad_from)
        DO k2=np+1,ad_from,-1
          CALL POPREAL4(fclr_above)
          fclrb = fclrb + fclr_aboveb
          xxb = fclr*flxdb(k2)
          fclrb = fclrb + xx*flxdb(k2)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            trantb = trantb - bd(k1)*xxb
            bdb(k1) = bdb(k1) - trant*xxb
          ELSE
            trantb = trantb + (bd(k1-1)-bd(k1))*xxb
            bdb(k1-1) = bdb(k1-1) + trant*xxb
            bdb(k1) = bdb(k1) - trant*xxb
          END IF
          xx = trant*(bu(k2-1)-bu(k2))
          xxb = fclr*flxub(k1)
          fclrb = fclrb + xx*flxub(k1)
          CALL POPREAL4(xx)
          trantb = trantb + (bu(k2-1)-bu(k2))*xxb
          bub(k2-1) = bub(k2-1) + trant*xxb
          bub(k2) = bub(k2) - trant*xxb
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            bdb(k1) = bdb(k1) + flxdb(k2)
            bub(k1) = bub(k1) - flxub(k1)
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL4(fclr)
            cldhib = cldhib - (1.0-cldmd)*(1.0-cldlw)*fclrb
            cldmdb = cldmdb - (1.0-cldhi)*(1.0-cldlw)*fclrb
            cldlwb = cldlwb - (1.0-cldhi)*(1.0-cldmd)*fclrb
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL4(cldhi)
              CALL POPREAL4(cldmd)
              CALL POPREAL4(cldlw)
              CALL CLDOVLP_B(np, k1, k2, ict, icb, icx, ncld, enn, ennb&
&                      , tcldlyr, tcldlyrb, cldhi, cldhib, cldmd, cldmdb&
&                      , cldlw, cldlwb)
            END IF
            fclr_aboveb = 0.0
          ELSE
            CALL POPREAL4(fclr)
            fclr_aboveb = tcldlyr(k2-1)*fclrb
            tcldlyrb(k2-1) = tcldlyrb(k2-1) + fclr_above*fclrb
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            trantb = tranal*trantb
            CALL POPREAL4(tranal)
          END IF
          CALL POPCONTROL2B(branch)
          IF (branch .EQ. 0) THEN
            arg1 = k2 - 1
            CALL POPREAL4ARRAY(th2o, 6)
            CALL POPREAL4ARRAY(tcon, 3)
            CALL POPREAL4ARRAY(tco2, 6)
            CALL POPREAL4ARRAY(tn2o, 4)
            CALL B10KDIS_B(np, arg1, exptbl(:, h2oexp%start:h2oexp%end)&
&                    , exptblb(:, h2oexp%start:h2oexp%end), exptbl(:, &
&                    conexp%start:conexp%end), exptblb(:, conexp%start:&
&                    conexp%end), exptbl(:, co2exp%start:co2exp%end), &
&                    exptblb(:, co2exp%start:co2exp%end), exptbl(:, &
&                    n2oexp%start:n2oexp%end), exptblb(:, n2oexp%start:&
&                    n2oexp%end), th2o, th2ob, tcon, tconb, tco2, tco2b&
&                    , tn2o, tn2ob, trant, trantb)
            trantb = 0.0
          ELSE IF (branch .NE. 1) THEN
            GOTO 120
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            arg1 = k2 - 1
            CALL POPREAL4(tf22)
            CALL POPREAL4(trant)
            CALL CFCKDIS_B(np, arg1, exptbl(:, f22exp%start:f22exp%end)&
&                    , exptblb(:, f22exp%start:f22exp%end), tf22, tf22b&
&                    , trant, trantb)
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            arg1 = k2 - 1
            CALL POPREAL4(tf12)
            CALL POPREAL4(trant)
            CALL CFCKDIS_B(np, arg1, exptbl(:, f12exp%start:f12exp%end)&
&                    , exptblb(:, f12exp%start:f12exp%end), tf12, tf12b&
&                    , trant, trantb)
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            arg1 = k2 - 1
            CALL POPREAL4(tf11)
            CALL POPREAL4(trant)
            CALL CFCKDIS_B(np, arg1, exptbl(:, f11exp%start:f11exp%end)&
&                    , exptblb(:, f11exp%start:f11exp%end), tf11, tf11b&
&                    , trant, trantb)
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            arg1 = k2 - 1
            CALL POPREAL4ARRAY(tcom, 6)
            CALL POPREAL4(trant)
            CALL COMKDIS_B(ibn, np, arg1, exptbl(:, comexp%start:comexp%&
&                    end), exptblb(:, comexp%start:comexp%end), tcom, &
&                    tcomb, trant, trantb)
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            arg1 = k2 - 1
            CALL POPREAL4ARRAY(tch4, 4)
            CALL POPREAL4(trant)
            CALL CH4KDIS_B(ibn, np, arg1, exptbl(:, ch4exp%start:ch4exp%&
&                    end), exptblb(:, ch4exp%start:ch4exp%end), tch4, &
&                    tch4b, trant, trantb)
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            arg1 = k2 - 1
            CALL POPREAL4ARRAY(tn2o, 4)
            CALL POPREAL4(trant)
            CALL N2OKDIS_B(ibn, np, arg1, exptbl(:, n2oexp%start:n2oexp%&
&                    end), exptblb(:, n2oexp%start:n2oexp%end), tn2o, &
&                    tn2ob, trant, trantb)
          END IF
 120      CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL4(x1)
            CALL POPREAL4(x2)
            CALL POPREAL4(x3)
            CALL POPREAL4(trant)
            CALL TABLUP_B(nx1, no1, do3(k2-1), do3b(k2-1), pa(k2-1), dt(&
&                   k2-1), dtb(k2-1), x1, x1b, x2, x2b, x3, x3b, w13, &
&                   p13, dwe, dpe, oo1, oo2, oo3, trant, trantb)
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL4(x1)
            CALL POPREAL4(x2)
            CALL POPREAL4(x3)
            CALL POPREAL4(trant)
            dco2b = 0.0
            CALL TABLUP_B(nx1, nc1, dco2(k2-1), dco2b(k2-1), pa(k2-1), &
&                   dt(k2-1), dtb(k2-1), x1, x1b, x2, x2b, x3, x3b, w12&
&                   , p12, dwe, dpe, c1, c2, c3, trant, trantb)
          END IF
          CALL POPCONTROL2B(branch)
          IF (branch .LT. 2) THEN
            IF (branch .EQ. 0) THEN
              CALL POPREAL4(trant)
              tconb(1) = tconb(1) + trant*trantb
              trantb = tcon(1)*trantb
              CALL POPREAL4(tcon(1))
              exptblb(k2-1, conexp%start) = exptblb(k2-1, conexp%start) &
&               + tcon(1)*tconb(1)
              tconb(1) = exptbl(k2-1, conexp%start)*tconb(1)
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL4(x1)
              CALL POPREAL4(x2)
              CALL POPREAL4(x3)
              CALL POPREAL4(trant)
              CALL TABLUP_B(nx1, nh1, dh2o(k2-1), dh2ob(k2-1), pa(k2-1)&
&                     , dt(k2-1), dtb(k2-1), x1, x1b, x2, x2b, x3, x3b, &
&                     w11, p11, dwe, dpe, h81, h82, h83, trant, trantb)
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL4(x1)
              CALL POPREAL4(x2)
              CALL POPREAL4(x3)
              CALL POPREAL4(trant)
              CALL TABLUP_B(nx1, nh1, dh2o(k2-1), dh2ob(k2-1), pa(k2-1)&
&                     , dt(k2-1), dtb(k2-1), x1, x1b, x2, x2b, x3, x3b, &
&                     w11, p11, dwe, dpe, h21, h22, h23, trant, trantb)
            END IF
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL4(x1)
              CALL POPREAL4(x2)
              CALL POPREAL4(x3)
              CALL POPREAL4(trant)
              CALL TABLUP_B(nx1, nh1, dh2o(k2-1), dh2ob(k2-1), pa(k2-1)&
&                     , dt(k2-1), dtb(k2-1), x1, x1b, x2, x2b, x3, x3b, &
&                     w11, p11, dwe, dpe, h11, h12, h13, trant, trantb)
            END IF
          ELSE IF (branch .EQ. 2) THEN
            arg1 = k2 - 1
            CALL POPREAL4ARRAY(th2o, 6)
            CALL POPREAL4ARRAY(tcon, 3)
            CALL POPREAL4(trant)
            CALL H2OKDIS_B(ibn, np, arg1, fkw, gkw, ne, exptbl(:, h2oexp&
&                    %start:h2oexp%end), exptblb(:, h2oexp%start:h2oexp%&
&                    end), exptbl(:, conexp%start:conexp%end), exptblb(:&
&                    , conexp%start:conexp%end), th2o, th2ob, tcon, &
&                    tconb, trant, trantb)
          END IF
          CALL POPREAL4(trant)
          trantb = 0.0
          fclrb = 0.0
        END DO
        CALL POPCONTROL2B(branch)
        IF (branch .EQ. 0) THEN
          tn2ob = 0.0
          th2ob = 0.0
          tco2b = 0.0
        ELSE IF (branch .NE. 1) THEN
          GOTO 130
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) tf22b = 0.0
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) tf12b = 0.0
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) tf11b = 0.0
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) tcomb = 0.0
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) tch4b = 0.0
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) tn2ob = 0.0
 130    CALL POPREAL4ARRAY(tcon, 3)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) th2ob = 0.0
        CALL POPREAL4(tranal)
        CALL POPREAL4(cldhi)
        CALL POPREAL4(cldmd)
        CALL POPREAL4(cldlw)
      END DO
      CALL POPREAL4ARRAY(flxd, np + 2)
      DO k2=np+1,1,-1
        bdb(k2-1) = bdb(k2-1) - bub(k2-1)
        tempb1 = bdb(k2-1)/(1.0-yy)
        xxb = -bdb(k2-1)
        temp2 = ALOG(yy)
        tempb2 = xxb/temp2
        CALL POPREAL4(bu(k2-1))
        blevelb(k2-1) = blevelb(k2-1) + bub(k2-1)
        blevelb(k2) = blevelb(k2) + tempb1 + bub(k2-1)
        bub(k2-1) = 0.0
        CALL POPREAL4(bd(k2-1))
        blevelb(k2-1) = blevelb(k2-1) + tempb2 - yy*tempb1
        yyb = ((blevel(k2)-blevel(k2-1)*yy)/(1.0-yy)-blevel(k2-1))*&
&         tempb1 - (blevel(k2-1)-blevel(k2))*tempb2/(temp2*yy)
        bdb(k2-1) = 0.0
        blevelb(k2) = blevelb(k2) - tempb2
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) yyb = 0.0
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL4(yy)
          xxb = yyb
        ELSE
          CALL POPREAL4(yy)
          xxb = 0.0
        END IF
        CALL POPREAL4(xx)
        ennb(k2-1) = ennb(k2-1) - trant*xxb
        trantb = trantb + (1.-enn(k2-1))*xxb
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) trantb = taerlyr(k2-1)*trantb
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL4(x1)
          CALL POPREAL4(x2)
          CALL POPREAL4(x3)
          CALL POPREAL4(trant)
          x1b = 0.0
          x2b = 0.0
          x3b = 0.0
          CALL TABLUP_B(nx1, no1, do3(k2-1), do3b(k2-1), pa(k2-1), dt(k2&
&                 -1), dtb(k2-1), x1, x1b, x2, x2b, x3, x3b, w13, p13, &
&                 dwe, dpe, oo1, oo2, oo3, trant, trantb)
        ELSE
          x1b = 0.0
          x2b = 0.0
          x3b = 0.0
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL4(x1)
          CALL POPREAL4(x2)
          CALL POPREAL4(x3)
          CALL POPREAL4(trant)
          dco2b = 0.0
          CALL TABLUP_B(nx1, nc1, dco2(k2-1), dco2b(k2-1), pa(k2-1), dt(&
&                 k2-1), dtb(k2-1), x1, x1b, x2, x2b, x3, x3b, w12, p12&
&                 , dwe, dpe, c1, c2, c3, trant, trantb)
        END IF
        CALL POPCONTROL2B(branch)
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) THEN
            tconb = 0.0
            CALL POPREAL4(trant)
            tconb(1) = tconb(1) + trant*trantb
            trantb = tcon(1)*trantb
            CALL POPREAL4(tcon(1))
            exptblb(k2-1, conexp%start) = exptblb(k2-1, conexp%start) + &
&             tcon(1)*tconb(1)
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL4(x1)
            CALL POPREAL4(x2)
            CALL POPREAL4(x3)
            CALL POPREAL4(trant)
            CALL TABLUP_B(nx1, nh1, dh2o(k2-1), dh2ob(k2-1), pa(k2-1), &
&                   dt(k2-1), dtb(k2-1), x1, x1b, x2, x2b, x3, x3b, w11&
&                   , p11, dwe, dpe, h81, h82, h83, trant, trantb)
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL4(x1)
            CALL POPREAL4(x2)
            CALL POPREAL4(x3)
            CALL POPREAL4(trant)
            CALL TABLUP_B(nx1, nh1, dh2o(k2-1), dh2ob(k2-1), pa(k2-1), &
&                   dt(k2-1), dtb(k2-1), x1, x1b, x2, x2b, x3, x3b, w11&
&                   , p11, dwe, dpe, h21, h22, h23, trant, trantb)
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL4(x1)
            CALL POPREAL4(x2)
            CALL POPREAL4(x3)
            CALL POPREAL4(trant)
            CALL TABLUP_B(nx1, nh1, dh2o(k2-1), dh2ob(k2-1), pa(k2-1), &
&                   dt(k2-1), dtb(k2-1), x1, x1b, x2, x2b, x3, x3b, w11&
&                   , p11, dwe, dpe, h11, h12, h13, trant, trantb)
          END IF
        ELSE IF (branch .EQ. 2) THEN
          arg1 = k2 - 1
          CALL POPREAL4ARRAY(th2o, 6)
          CALL POPREAL4ARRAY(tcon, 3)
          CALL POPREAL4(trant)
          tconb = 0.0
          CALL H2OKDIS_B(ibn, np, arg1, fkw, gkw, ne, exptbl(:, h2oexp%&
&                  start:h2oexp%end), exptblb(:, h2oexp%start:h2oexp%end&
&                  ), exptbl(:, conexp%start:conexp%end), exptblb(:, &
&                  conexp%start:conexp%end), th2o, th2ob, tcon, tconb, &
&                  trant, trantb)
        END IF
        CALL POPREAL4(trant)
        CALL POPREAL4ARRAY(tcon, 3)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) th2ob = 0.0
        trantb = 0.0
      END DO
      CALL POPREAL4(bu(np+1))
      blayerb(np+1) = blayerb(np+1) + bub(np+1)
      bub(np+1) = 0.0
      CALL POPREAL4(bd(0))
      blayerb(1) = blayerb(1) + bdb(0)
      bdb(0) = 0.0
      CALL POPREAL4(bu(0))
      bub(0) = 0.0
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        n2oexp_tmpb = n2oexp_tmpb + exptblb(:, n2oexp%start:n2oexp%end)
        exptblb(:, n2oexp%start:n2oexp%end) = 0.0
        co2exp_tmpb = co2exp_tmpb + exptblb(:, co2exp%start:co2exp%end)
        exptblb(:, co2exp%start:co2exp%end) = 0.0
        h2oexp_tmpb = h2oexp_tmpb + exptblb(:, h2oexp%start:h2oexp%end)
        exptblb(:, h2oexp%start:h2oexp%end) = 0.0
        CALL POPREAL4ARRAY(h2oexp_tmp, (np+1)*5)
        CALL POPREAL4ARRAY(co2exp_tmp, (np+1)*6)
        CALL POPREAL4ARRAY(n2oexp_tmp, (np+1)*2)
        CALL B10EXPS_B(np, dh2o, dh2ob, dcont, dcontb, dco2, dn2o, pa, &
&                dt, dtb, h2oexp_tmp, h2oexp_tmpb, exptbl(:, conexp%&
&                start:conexp%end), exptblb(:, conexp%start:conexp%end)&
&                , co2exp_tmp, co2exp_tmpb, n2oexp_tmp, n2oexp_tmpb)
      ELSE IF (branch .NE. 1) THEN
        GOTO 140
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a1 = 9.65130e-4
        a2 = -3.00010e-5
        b1 = 1.31280e-5
        b2 = 5.25010e-7
        fk1 = 6.18536e+0
        fk2 = 3.27912e+1
        CALL CFCEXPS_B(ibn, np, a1, b1, fk1, a2, b2, fk2, df22, dt, dtb&
&                , exptbl(:, f22exp%start:f22exp%end), exptblb(:, f22exp&
&                %start:f22exp%end))
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a1 = 8.77370e-4
        a2 = 8.62000e-4
        b1 = -5.88440e-6
        b2 = -4.22500e-6
        fk1 = 1.58104e+1
        fk2 = 3.70107e+1
        CALL CFCEXPS_B(ibn, np, a1, b1, fk1, a2, b2, fk2, df12, dt, dtb&
&                , exptbl(:, f12exp%start:f12exp%end), exptblb(:, f12exp&
&                %start:f12exp%end))
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a1 = 1.26610e-3
        a2 = 8.19370e-4
        b1 = 3.55940e-6
        b2 = 4.67810e-6
        fk1 = 1.89736e+1
        fk2 = 1.01487e+1
        CALL CFCEXPS_B(ibn, np, a1, b1, fk1, a2, b2, fk2, df11, dt, dtb&
&                , exptbl(:, f11exp%start:f11exp%end), exptblb(:, f11exp&
&                %start:f11exp%end))
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL4ARRAY(exptbl(:, comexp%start:comexp%end), (np+1)*(&
&                    comexp%end-comexp%start+1))
        CALL COMEXPS_B(ibn, np, dco2, dt, dtb, exptbl(:, comexp%start:&
&                comexp%end), exptblb(:, comexp%start:comexp%end))
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL4ARRAY(exptbl(:, ch4exp%start:ch4exp%end), (np+1)*(&
&                    ch4exp%end-ch4exp%start+1))
        CALL CH4EXPS_B(ibn, np, dch4, pa, dt, dtb, exptbl(:, ch4exp%&
&                start:ch4exp%end), exptblb(:, ch4exp%start:ch4exp%end))
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL4ARRAY(exptbl(:, n2oexp%start:n2oexp%end), (np+1)*(&
&                    n2oexp%end-n2oexp%start+1))
        CALL N2OEXPS_B(ibn, np, dn2o, pa, dt, dtb, exptbl(:, n2oexp%&
&                start:n2oexp%end), exptblb(:, n2oexp%start:n2oexp%end))
      END IF
 140  CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL4ARRAY(exptbl(:, conexp%start:conexp%end), (np+1)*(&
&                    conexp%end-conexp%start+1))
        CALL CONEXPS_B(ibn, np, dcont, dcontb, xke, exptbl(:, conexp%&
&                start:conexp%end), exptblb(:, conexp%start:conexp%end))
      END IF
      CALL POPINTEGER4(ne)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL4ARRAY(exptbl(:, h2oexp%start:h2oexp%end), (np+1)*(&
&                    h2oexp%end-h2oexp%start+1))
        CALL H2OEXPS_B(ibn, np, dh2o, dh2ob, pa, dt, dtb, xkw, aw, bw, &
&                pm, mw, exptbl(:, h2oexp%start:h2oexp%end), exptblb(:, &
&                h2oexp%start:h2oexp%end))
        exptblb(:, h2oexp%start:h2oexp%end) = 0.0
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO k=np,1,-1
          CALL POPREAL4(taerlyr(k))
        END DO
        CALL POPREAL4(taerlyr(0))
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPINTEGER4ARRAY(icx, np + 1)
        CALL POPINTEGER4ARRAY(ncld, 3)
        DO k=np,0,-1
          CALL POPINTEGER4(icx(k))
        END DO
      END IF
      CALL POPREAL4ARRAY(tcldlyr, np + 1)
      CALL POPREAL4ARRAY(enn, np + 1)
      CALL GETIRTAU1_B(ibn, np, dp_pa, fcld_col, fcld_colb, reff_col, &
&                reff_colb, cwc_col, cwc_colb, taudiaglyr, tcldlyr, &
&                tcldlyrb, enn, ennb, aib_ir, awb_ir, aiw_ir, aww_ir, &
&                aig_ir, awg_ir, cons_grav)
      CALL POPREAL4(blevel(np+1))
      CALL PLANCK_B(ibn, cb, tb_dev(i), tb_devb(i), blevel(np+1), &
&             blevelb(np+1))
      blevelb(np+1) = 0.0
      CALL POPREAL4(blevel(0))
      blevelb(1) = blevelb(1) + blevelb(0)
      blevelb(0) = 0.0
      CALL POPREAL4(blevel(1))
      tempb0 = dp(1)*blevelb(1)/(dp(1)+dp(2))
      blayerb(1) = blayerb(1) + tempb0 + blevelb(1)
      blayerb(2) = blayerb(2) - tempb0
      blevelb(1) = 0.0
      DO k=np,2,-1
        CALL POPREAL4(blevel(k))
        tempb = blevelb(k)/(dp(k-1)+dp(k))
        blayerb(k-1) = blayerb(k-1) + dp(k)*tempb
        blayerb(k) = blayerb(k) + dp(k-1)*tempb
        blevelb(k) = 0.0
      END DO
      blayerb(np+1) = 0.0
      CALL POPREAL4(dbs)
      CALL POPREAL4(rflxs)
      CALL POPREAL4(blevel(0))
      blayerb(1) = blayerb(1) + blayerb(0) + blevelb(0)
      blevelb(0) = 0.0
      blayerb(0) = 0.0
      DO k=np,1,-1
        CALL PLANCK_B(ibn, cb, ta_dev(i, k), ta_devb(i, k), blayer(k), &
&               blayerb(k))
        blayerb(k) = 0.0
      END DO
      CALL POPCONTROL4B(branch)
      IF (branch .LT. 4) THEN
        IF (branch .LT. 2) THEN
          IF (branch .EQ. 0) THEN
            CALL POPINTEGER4(n2oexp%end)
            CALL POPINTEGER4(n2oexp%start)
            CALL POPINTEGER4(co2exp%end)
            CALL POPINTEGER4(co2exp%start)
            CALL POPINTEGER4(conexp%end)
            CALL POPINTEGER4(conexp%start)
            CALL POPINTEGER4(h2oexp%end)
            CALL POPINTEGER4(h2oexp%start)
          ELSE
            CALL POPINTEGER4(h2oexp%end)
            CALL POPINTEGER4(h2oexp%start)
          END IF
        ELSE IF (branch .EQ. 2) THEN
          CALL POPINTEGER4(ch4exp%end)
          CALL POPINTEGER4(ch4exp%start)
          CALL POPINTEGER4(n2oexp%end)
          CALL POPINTEGER4(n2oexp%start)
          CALL POPINTEGER4(conexp%end)
          CALL POPINTEGER4(conexp%start)
          CALL POPINTEGER4(h2oexp%end)
          CALL POPINTEGER4(h2oexp%start)
        ELSE
          CALL POPINTEGER4(f22exp%end)
          CALL POPINTEGER4(f22exp%start)
          CALL POPINTEGER4(f12exp%end)
          CALL POPINTEGER4(f12exp%start)
          CALL POPINTEGER4(ch4exp%end)
          CALL POPINTEGER4(ch4exp%start)
          CALL POPINTEGER4(n2oexp%end)
          CALL POPINTEGER4(n2oexp%start)
          CALL POPINTEGER4(conexp%end)
          CALL POPINTEGER4(conexp%start)
          CALL POPINTEGER4(h2oexp%end)
          CALL POPINTEGER4(h2oexp%start)
        END IF
      ELSE IF (branch .LT. 6) THEN
        IF (branch .EQ. 4) THEN
          CALL POPINTEGER4(f11exp%end)
          CALL POPINTEGER4(f11exp%start)
          CALL POPINTEGER4(comexp%end)
          CALL POPINTEGER4(comexp%start)
          CALL POPINTEGER4(conexp%end)
          CALL POPINTEGER4(conexp%start)
          CALL POPINTEGER4(h2oexp%end)
          CALL POPINTEGER4(h2oexp%start)
        ELSE
          CALL POPINTEGER4(f22exp%end)
          CALL POPINTEGER4(f22exp%start)
          CALL POPINTEGER4(f12exp%end)
          CALL POPINTEGER4(f12exp%start)
          CALL POPINTEGER4(f11exp%end)
          CALL POPINTEGER4(f11exp%start)
          CALL POPINTEGER4(comexp%end)
          CALL POPINTEGER4(comexp%start)
          CALL POPINTEGER4(conexp%end)
          CALL POPINTEGER4(conexp%start)
          CALL POPINTEGER4(h2oexp%end)
          CALL POPINTEGER4(h2oexp%start)
        END IF
      ELSE IF (branch .EQ. 6) THEN
        CALL POPINTEGER4(conexp%end)
        CALL POPINTEGER4(conexp%start)
        CALL POPINTEGER4(h2oexp%end)
        CALL POPINTEGER4(h2oexp%start)
      ELSE IF (branch .EQ. 7) THEN
        CALL POPINTEGER4(conexp%end)
        CALL POPINTEGER4(conexp%start)
      END IF
      CALL POPREAL4ARRAY(exptbl, (np+1)*17)
    END IF
    CALL POPINTEGER4(ibn)
  END DO
  DO k=np+1,1,-1
    dfdts_devb(i, k) = 0.0
    flxd_devb(i, k) = 0.0
    flxu_devb(i, k) = 0.0
  END DO
  xx = pa(0)*0.001618*wa_dev(i, 1)*wa_dev(i, 1)*dp(0)
  temp1 = 1800./ta_dev(i, 1)
  xxb = EXP(temp1-6.081)*dcontb(0)
  ta_devb(i, 1) = ta_devb(i, 1) - EXP(temp1-6.081)*xx*temp1*dcontb(0)/&
&   ta_dev(i, 1)
  dcontb(0) = 0.0
  wa_devb = 0.0
  wa_devb(i, 1) = wa_devb(i, 1) + pa(0)*0.001618*dp(0)*2*wa_dev(i, 1)*&
&   xxb
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) do3b(0) = 0.0
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) dh2ob(0) = 0.0
  oa_devb = 0.0
  oa_devb(i, 1) = oa_devb(i, 1) + dp(0)*476.*do3b(0)
  do3b(0) = 0.0
  wa_devb(i, 1) = wa_devb(i, 1) + dp(0)*1.02*dh2ob(0)
  dh2ob(0) = 0.0
  ta_devb(i, 1) = ta_devb(i, 1) + dtb(0)
  dtb(0) = 0.0
  CALL POPREAL4(pa(0))
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    CALL POPREAL4(dp(0))
  ELSE
    CALL POPREAL4(dp(0))
  END IF
  fcld_devb = 0.0
  cwc_devb = 0.0
  reff_devb = 0.0
  DO k=np,1,-1
    DO l=4,1,-1
      cwc_devb(i, k, l) = cwc_devb(i, k, l) + cwc_colb(k, l)
      cwc_colb(k, l) = 0.0
      reff_devb(i, k, l) = reff_devb(i, k, l) + reff_colb(k, l)
      reff_colb(k, l) = 0.0
    END DO
    fcld_devb(i, k) = fcld_devb(i, k) + fcld_colb(k)
    fcld_colb(k) = 0.0
    xx = pa(k)*0.001618*wa_dev(i, k)*wa_dev(i, k)*dp(k)
    temp0 = ta_dev(i, k)
    temp = 1800./temp0
    xxb = EXP(temp-6.081)*dcontb(k)
    ta_devb(i, k) = ta_devb(i, k) - EXP(temp-6.081)*xx*temp*dcontb(k)/&
&     temp0
    dcontb(k) = 0.0
    wa_devb(i, k) = wa_devb(i, k) + pa(k)*0.001618*dp(k)*2*wa_dev(i, k)*&
&     xxb
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) do3b(k) = 0.0
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) dh2ob(k) = 0.0
    oa_devb(i, k) = oa_devb(i, k) + dp(k)*476.*do3b(k)
    do3b(k) = 0.0
    wa_devb(i, k) = wa_devb(i, k) + dp(k)*1.02*dh2ob(k)
    dh2ob(k) = 0.0
    ta_devb(i, k) = ta_devb(i, k) + dtb(k)
    dtb(k) = 0.0
  END DO
END SUBROUTINE IRRAD_B

!  Differentiation of planck in reverse (adjoint) mode:
!   gradient     of useful results: t xlayer
!   with respect to varying inputs: t
!----------------------------------!
!      SUBROUTINES GO HERE         !
!----------------------------------!
SUBROUTINE PLANCK_B(ibn, cb, t, tb, xlayer, xlayerb)
  IMPLICIT NONE
! spectral band index
  INTEGER :: ibn
! Planck table coefficients
  REAL :: cb(6, 10)
! temperature (K)
  REAL :: t
  REAL :: tb
! planck flux (w/m2)
  REAL :: xlayer
  REAL :: xlayerb
  REAL :: temp1
  REAL :: temp0
  REAL :: tempb
  REAL :: temp
  temp1 = cb(5, ibn) + cb(6, ibn)*t
  temp0 = cb(4, ibn) + t*temp1
  temp = cb(3, ibn) + t*temp0
  tempb = t**2*xlayerb
  tb = tb + (t**2*cb(6, ibn)+t*temp1+temp0)*tempb + (2*(t*temp)+cb(2, &
&   ibn))*xlayerb
END SUBROUTINE PLANCK_B

!  Differentiation of h2oexps in reverse (adjoint) mode:
!   gradient     of useful results: dh2o dt h2oexp
!   with respect to varying inputs: dh2o dt
SUBROUTINE H2OEXPS_B(ib, np, dh2o, dh2ob, pa, dt, dtb, xkw, aw, bw, pm, &
& mw, h2oexp, h2oexpb)
  IMPLICIT NONE
  INTEGER :: ib, np, ik, k
!---- input parameters ------
  REAL :: dh2o(0:np), pa(0:np), dt(0:np)
  REAL :: dh2ob(0:np), dtb(0:np)
!---- output parameters -----
  REAL :: h2oexp(0:np, 6)
  REAL :: h2oexpb(0:np, 6)
!---- static data -----
  INTEGER :: mw(9)
  REAL :: xkw(9), aw(9), bw(9), pm(9)
!---- temporary arrays -----
  REAL :: xh
  REAL :: xhb
  INTRINSIC EXP
  INTEGER :: branch
  REAL :: tempb
  REAL :: temp
!    note that the 3 sub-bands in band 3 use the same set of xkw, aw,
!    and bw,  therefore, h2oexp for these sub-bands are identical.
  DO k=0,np
!-----xh is the scaled water vapor amount for line absorption
!     computed from Eq. (4.4).
    CALL PUSHREAL4(xh)
    xh = dh2o(k)*(pa(k)/500.)**pm(ib)*(1.+(aw(ib)+bw(ib)*dt(k))*dt(k))
!-----h2oexp is the water vapor transmittance of the layer k
!     due to line absorption
    h2oexp(k, 1) = EXP(-(xh*xkw(ib)))
!-----compute transmittances from Eq. (8.22)
    DO ik=2,6
      IF (mw(ib) .EQ. 6) THEN
        CALL PUSHREAL4(xh)
        xh = h2oexp(k, ik-1)*h2oexp(k, ik-1)
        CALL PUSHREAL4(h2oexp(k, ik))
        h2oexp(k, ik) = xh*xh*xh
        CALL PUSHCONTROL2B(3)
      ELSE IF (mw(ib) .EQ. 8) THEN
        CALL PUSHREAL4(xh)
        xh = h2oexp(k, ik-1)*h2oexp(k, ik-1)
        CALL PUSHREAL4(xh)
        xh = xh*xh
        CALL PUSHREAL4(h2oexp(k, ik))
        h2oexp(k, ik) = xh*xh
        CALL PUSHCONTROL2B(2)
      ELSE IF (mw(ib) .EQ. 9) THEN
        CALL PUSHREAL4(xh)
        xh = h2oexp(k, ik-1)*h2oexp(k, ik-1)*h2oexp(k, ik-1)
        CALL PUSHREAL4(h2oexp(k, ik))
        h2oexp(k, ik) = xh*xh*xh
        CALL PUSHCONTROL2B(1)
      ELSE
        CALL PUSHREAL4(xh)
        xh = h2oexp(k, ik-1)*h2oexp(k, ik-1)
        CALL PUSHREAL4(xh)
        xh = xh*xh
        CALL PUSHREAL4(xh)
        xh = xh*xh
        CALL PUSHREAL4(h2oexp(k, ik))
        h2oexp(k, ik) = xh*xh
        CALL PUSHCONTROL2B(0)
      END IF
    END DO
  END DO
  DO k=np,0,-1
    DO ik=6,2,-1
      CALL POPCONTROL2B(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          CALL POPREAL4(h2oexp(k, ik))
          xhb = 2*xh*h2oexpb(k, ik)
          h2oexpb(k, ik) = 0.0
          CALL POPREAL4(xh)
          xhb = 2*xh*xhb
          CALL POPREAL4(xh)
          xhb = 2*xh*xhb
          CALL POPREAL4(xh)
          h2oexpb(k, ik-1) = h2oexpb(k, ik-1) + 2*h2oexp(k, ik-1)*xhb
        ELSE
          CALL POPREAL4(h2oexp(k, ik))
          xhb = 3*xh**2*h2oexpb(k, ik)
          h2oexpb(k, ik) = 0.0
          CALL POPREAL4(xh)
          h2oexpb(k, ik-1) = h2oexpb(k, ik-1) + 3*h2oexp(k, ik-1)**2*xhb
        END IF
      ELSE IF (branch .EQ. 2) THEN
        CALL POPREAL4(h2oexp(k, ik))
        xhb = 2*xh*h2oexpb(k, ik)
        h2oexpb(k, ik) = 0.0
        CALL POPREAL4(xh)
        xhb = 2*xh*xhb
        CALL POPREAL4(xh)
        h2oexpb(k, ik-1) = h2oexpb(k, ik-1) + 2*h2oexp(k, ik-1)*xhb
      ELSE
        CALL POPREAL4(h2oexp(k, ik))
        xhb = 3*xh**2*h2oexpb(k, ik)
        h2oexpb(k, ik) = 0.0
        CALL POPREAL4(xh)
        h2oexpb(k, ik-1) = h2oexpb(k, ik-1) + 2*h2oexp(k, ik-1)*xhb
      END IF
    END DO
    xhb = -(EXP(-(xkw(ib)*xh))*xkw(ib)*h2oexpb(k, 1))
    h2oexpb(k, 1) = 0.0
    CALL POPREAL4(xh)
    temp = aw(ib) + bw(ib)*dt(k)
    tempb = (pa(k)/500.)**pm(ib)*xhb
    dh2ob(k) = dh2ob(k) + (temp*dt(k)+1.)*tempb
    dtb(k) = dtb(k) + (dh2o(k)*temp+dt(k)*dh2o(k)*bw(ib))*tempb
  END DO
END SUBROUTINE H2OEXPS_B

!  Differentiation of conexps in reverse (adjoint) mode:
!   gradient     of useful results: dcont conexp
!   with respect to varying inputs: dcont conexp
SUBROUTINE CONEXPS_B(ib, np, dcont, dcontb, xke, conexp, conexpb)
  IMPLICIT NONE
  INTEGER :: ib, np, k
!---- input parameters ------
  REAL :: dcont(0:np)
  REAL :: dcontb(0:np)
!---- updated parameters -----
  REAL :: conexp(0:np, 3)
  REAL :: conexpb(0:np, 3)
!---- static data -----
  REAL :: xke(9)
  INTRINSIC EXP
  INTEGER :: branch
  DO k=0,np
    conexp(k, 1) = EXP(-(dcont(k)*xke(ib)))
!-----The absorption coefficients for sub-bands 3b and 3a are, respectively,
!     two and four times the absorption coefficient for sub-band 3c (Table 9).
!     Note that conexp(3) is for sub-band 3a. 
    IF (ib .EQ. 3) THEN
      CALL PUSHREAL4(conexp(k, 2))
      conexp(k, 2) = conexp(k, 1)*conexp(k, 1)
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
  END DO
  DO k=np,0,-1
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      conexpb(k, 2) = conexpb(k, 2) + 2*conexp(k, 2)*conexpb(k, 3)
      conexpb(k, 3) = 0.0
      CALL POPREAL4(conexp(k, 2))
      conexpb(k, 1) = conexpb(k, 1) + 2*conexp(k, 1)*conexpb(k, 2)
      conexpb(k, 2) = 0.0
    END IF
    dcontb(k) = dcontb(k) - EXP(-(xke(ib)*dcont(k)))*xke(ib)*conexpb(k, &
&     1)
    conexpb(k, 1) = 0.0
  END DO
END SUBROUTINE CONEXPS_B

!  Differentiation of n2oexps in reverse (adjoint) mode:
!   gradient     of useful results: dt n2oexp
!   with respect to varying inputs: dt n2oexp
SUBROUTINE N2OEXPS_B(ib, np, dn2o, pa, dt, dtb, n2oexp, n2oexpb)
  IMPLICIT NONE
  INTEGER :: ib, k, np
!---- input parameters -----
  REAL :: dn2o(0:np), pa(0:np), dt(0:np)
  REAL :: dtb(0:np)
!---- output parameters -----
  REAL :: n2oexp(0:np, 4)
  REAL :: n2oexpb(0:np, 4)
!---- temporary arrays -----
  REAL :: xc, xc1, xc2
  REAL :: xcb, xc1b, xc2b
  INTRINSIC EXP
  INTEGER :: branch
  REAL :: tempb
!-----Scaling and absorption data are given in Table 5.
!     Transmittances are computed using Eqs. (8.21) and (8.22).
  DO k=0,np
!-----four exponential by powers of 21 for band 6.
    IF (ib .EQ. 6) THEN
      CALL PUSHREAL4(xc)
      xc = dn2o(k)*(1.+(1.9297e-3+4.3750e-6*dt(k))*dt(k))
      n2oexp(k, 1) = EXP(-(xc*6.31582e-2))
      xc = n2oexp(k, 1)*n2oexp(k, 1)*n2oexp(k, 1)
!-----four exponential by powers of 8 for band 7
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHREAL4(xc)
      xc = dn2o(k)*(pa(k)/500.0)**0.48*(1.+(1.3804e-3+7.4838e-6*dt(k))*&
&       dt(k))
      n2oexp(k, 1) = EXP(-(xc*5.35779e-2))
      xc = n2oexp(k, 1)*n2oexp(k, 1)
      CALL PUSHREAL4(xc)
      xc = xc*xc
      CALL PUSHREAL4(n2oexp(k, 2))
      n2oexp(k, 2) = xc*xc
      CALL PUSHREAL4(xc)
      xc = n2oexp(k, 2)*n2oexp(k, 2)
      CALL PUSHREAL4(xc)
      xc = xc*xc
      CALL PUSHREAL4(n2oexp(k, 3))
      n2oexp(k, 3) = xc*xc
      CALL PUSHREAL4(xc)
      xc = n2oexp(k, 3)*n2oexp(k, 3)
      CALL PUSHREAL4(xc)
      xc = xc*xc
      CALL PUSHCONTROL1B(0)
    END IF
  END DO
  DO k=np,0,-1
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      xcb = 2*xc*n2oexpb(k, 4)
      n2oexpb(k, 4) = 0.0
      CALL POPREAL4(xc)
      xcb = 2*xc*xcb
      CALL POPREAL4(xc)
      n2oexpb(k, 3) = n2oexpb(k, 3) + 2*n2oexp(k, 3)*xcb
      CALL POPREAL4(n2oexp(k, 3))
      xcb = 2*xc*n2oexpb(k, 3)
      n2oexpb(k, 3) = 0.0
      CALL POPREAL4(xc)
      xcb = 2*xc*xcb
      CALL POPREAL4(xc)
      n2oexpb(k, 2) = n2oexpb(k, 2) + 2*n2oexp(k, 2)*xcb
      CALL POPREAL4(n2oexp(k, 2))
      xcb = 2*xc*n2oexpb(k, 2)
      n2oexpb(k, 2) = 0.0
      CALL POPREAL4(xc)
      xcb = 2*xc*xcb
      n2oexpb(k, 1) = n2oexpb(k, 1) + 2*n2oexp(k, 1)*xcb
      xc = dn2o(k)*(pa(k)/500.0)**0.48*(1.+(1.3804e-3+7.4838e-6*dt(k))*&
&       dt(k))
      xcb = -(EXP(-(5.35779e-2*xc))*5.35779e-2*n2oexpb(k, 1))
      n2oexpb(k, 1) = 0.0
      CALL POPREAL4(xc)
      tempb = (pa(k)/500.0)**0.48*dn2o(k)*xcb
      dtb(k) = dtb(k) + (7.4838e-6*dt(k)+dt(k)*7.4838e-6+1.3804e-3)*&
&       tempb
    ELSE
      xc1 = xc*xc
      xc2 = xc1*xc1
      xc2b = xc*xc1*n2oexpb(k, 2)
      xc1b = 2*xc1*xc2b + xc2*xc*n2oexpb(k, 2)
      xcb = 2*xc*xc1b + xc2*xc1*n2oexpb(k, 2)
      n2oexpb(k, 2) = 0.0
      n2oexpb(k, 1) = n2oexpb(k, 1) + 3*n2oexp(k, 1)**2*xcb
      xc = dn2o(k)*(1.+(1.9297e-3+4.3750e-6*dt(k))*dt(k))
      xcb = -(EXP(-(6.31582e-2*xc))*6.31582e-2*n2oexpb(k, 1))
      n2oexpb(k, 1) = 0.0
      CALL POPREAL4(xc)
      dtb(k) = dtb(k) + (dn2o(k)*(4.3750e-6*dt(k)+1.9297e-3)+dt(k)*dn2o(&
&       k)*4.3750e-6)*xcb
    END IF
  END DO
END SUBROUTINE N2OEXPS_B

!  Differentiation of ch4exps in reverse (adjoint) mode:
!   gradient     of useful results: dt ch4exp
!   with respect to varying inputs: dt ch4exp
SUBROUTINE CH4EXPS_B(ib, np, dch4, pa, dt, dtb, ch4exp, ch4expb)
  IMPLICIT NONE
  INTEGER :: ib, np, k
!---- input parameters -----
  REAL :: dch4(0:np), pa(0:np), dt(0:np)
  REAL :: dtb(0:np)
!---- output parameters -----
  REAL :: ch4exp(0:np, 4)
  REAL :: ch4expb(0:np, 4)
!---- temporary arrays -----
  REAL :: xc
  REAL :: xcb
  INTRINSIC EXP
  INTEGER :: branch
  REAL :: tempb
!-----  Scaling and absorption data are given in Table 5 
  DO k=0,np
!-----four exponentials for band 6
    IF (ib .EQ. 6) THEN
      CALL PUSHREAL4(xc)
!-----four exponentials by powers of 12 for band 7
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHREAL4(xc)
      xc = dch4(k)*(pa(k)/500.0)**0.65*(1.+(5.9590e-4-2.2931e-6*dt(k))*&
&       dt(k))
      ch4exp(k, 1) = EXP(-(xc*6.29247e-2))
      xc = ch4exp(k, 1)*ch4exp(k, 1)*ch4exp(k, 1)
      CALL PUSHREAL4(xc)
      xc = xc*xc
      CALL PUSHREAL4(ch4exp(k, 2))
      ch4exp(k, 2) = xc*xc
      CALL PUSHREAL4(xc)
      xc = ch4exp(k, 2)*ch4exp(k, 2)*ch4exp(k, 2)
      CALL PUSHREAL4(xc)
      xc = xc*xc
      CALL PUSHREAL4(ch4exp(k, 3))
      ch4exp(k, 3) = xc*xc
      CALL PUSHREAL4(xc)
      xc = ch4exp(k, 3)*ch4exp(k, 3)*ch4exp(k, 3)
      CALL PUSHREAL4(xc)
      xc = xc*xc
      CALL PUSHCONTROL1B(0)
    END IF
  END DO
  DO k=np,0,-1
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      xcb = 2*xc*ch4expb(k, 4)
      ch4expb(k, 4) = 0.0
      CALL POPREAL4(xc)
      xcb = 2*xc*xcb
      CALL POPREAL4(xc)
      ch4expb(k, 3) = ch4expb(k, 3) + 3*ch4exp(k, 3)**2*xcb
      CALL POPREAL4(ch4exp(k, 3))
      xcb = 2*xc*ch4expb(k, 3)
      ch4expb(k, 3) = 0.0
      CALL POPREAL4(xc)
      xcb = 2*xc*xcb
      CALL POPREAL4(xc)
      ch4expb(k, 2) = ch4expb(k, 2) + 3*ch4exp(k, 2)**2*xcb
      CALL POPREAL4(ch4exp(k, 2))
      xcb = 2*xc*ch4expb(k, 2)
      ch4expb(k, 2) = 0.0
      CALL POPREAL4(xc)
      xcb = 2*xc*xcb
      ch4expb(k, 1) = ch4expb(k, 1) + 3*ch4exp(k, 1)**2*xcb
      xc = dch4(k)*(pa(k)/500.0)**0.65*(1.+(5.9590e-4-2.2931e-6*dt(k))*&
&       dt(k))
      xcb = -(EXP(-(6.29247e-2*xc))*6.29247e-2*ch4expb(k, 1))
      ch4expb(k, 1) = 0.0
      CALL POPREAL4(xc)
      tempb = (pa(k)/500.0)**0.65*dch4(k)*xcb
      dtb(k) = dtb(k) + (5.9590e-4-dt(k)*2.2931e-6-2.2931e-6*dt(k))*&
&       tempb
    ELSE
      xc = dch4(k)*(1.+(1.7007e-2+1.5826e-4*dt(k))*dt(k))
      xcb = -(EXP(-(5.80708e-3*xc))*5.80708e-3*ch4expb(k, 1))
      ch4expb(k, 1) = 0.0
      CALL POPREAL4(xc)
      dtb(k) = dtb(k) + (dch4(k)*(1.5826e-4*dt(k)+1.7007e-2)+dt(k)*dch4(&
&       k)*1.5826e-4)*xcb
    END IF
  END DO
END SUBROUTINE CH4EXPS_B

!  Differentiation of comexps in reverse (adjoint) mode:
!   gradient     of useful results: dt comexp
!   with respect to varying inputs: dt comexp
SUBROUTINE COMEXPS_B(ib, np, dcom, dt, dtb, comexp, comexpb)
  IMPLICIT NONE
  INTEGER :: ib, ik, np, k
!---- input parameters -----
  REAL :: dcom(0:np), dt(0:np)
  REAL :: dtb(0:np)
!---- output parameters -----
  REAL :: comexp(0:np, 6)
  REAL :: comexpb(0:np, 6)
!---- temporary arrays -----
  REAL :: xc
  REAL :: xcb
  INTRINSIC EXP
  INTEGER :: branch
!-----  Scaling and absorpton data are given in Table 6
  DO k=0,np
    IF (ib .EQ. 4) THEN
      CALL PUSHREAL4(xc)
      xc = dcom(k)*(1.+(3.5775e-2+4.0447e-4*dt(k))*dt(k))
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (ib .EQ. 5) THEN
      CALL PUSHREAL4(xc)
      xc = dcom(k)*(1.+(3.4268e-2+3.7401e-4*dt(k))*dt(k))
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    comexp(k, 1) = EXP(-(xc*1.922e-7))
    DO ik=2,6
      CALL PUSHREAL4(xc)
      xc = comexp(k, ik-1)*comexp(k, ik-1)
      CALL PUSHREAL4(xc)
      xc = xc*xc
      CALL PUSHREAL4(comexp(k, ik))
      comexp(k, ik) = xc*comexp(k, ik-1)
    END DO
  END DO
  xcb = 0.0
  DO k=np,0,-1
    DO ik=6,2,-1
      CALL POPREAL4(comexp(k, ik))
      xcb = xcb + comexp(k, ik-1)*comexpb(k, ik)
      comexpb(k, ik-1) = comexpb(k, ik-1) + xc*comexpb(k, ik)
      comexpb(k, ik) = 0.0
      CALL POPREAL4(xc)
      xcb = 2*xc*xcb
      CALL POPREAL4(xc)
      comexpb(k, ik-1) = comexpb(k, ik-1) + 2*comexp(k, ik-1)*xcb
      xcb = 0.0
    END DO
    xcb = xcb - EXP(-(1.922e-7*xc))*1.922e-7*comexpb(k, 1)
    comexpb(k, 1) = 0.0
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL4(xc)
      dtb(k) = dtb(k) + (dcom(k)*(3.7401e-4*dt(k)+3.4268e-2)+dt(k)*dcom(&
&       k)*3.7401e-4)*xcb
      xcb = 0.0
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL4(xc)
      dtb(k) = dtb(k) + (dcom(k)*(4.0447e-4*dt(k)+3.5775e-2)+dt(k)*dcom(&
&       k)*4.0447e-4)*xcb
      xcb = 0.0
    END IF
  END DO
END SUBROUTINE COMEXPS_B

!  Differentiation of cfcexps in reverse (adjoint) mode:
!   gradient     of useful results: dt cfcexp
!   with respect to varying inputs: dt cfcexp
SUBROUTINE CFCEXPS_B(ib, np, a1, b1, fk1, a2, b2, fk2, dcfc, dt, dtb, &
& cfcexp, cfcexpb)
  IMPLICIT NONE
  INTEGER :: ib, np, k
!---- input parameters -----
  REAL :: dcfc(0:np), dt(0:np)
  REAL :: dtb(0:np)
!---- output parameters -----
  REAL :: cfcexp(0:np)
  REAL :: cfcexpb(0:np)
!---- static data -----
  REAL :: a1, b1, fk1, a2, b2, fk2
!---- temporary arrays -----
  REAL :: xf
  REAL :: xfb
  INTRINSIC EXP
  INTEGER :: branch
  DO k=0,np
!-----compute the scaled cfc amount (xf) and exponential (cfcexp)
    IF (ib .EQ. 4) THEN
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
  END DO
  DO k=np,0,-1
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      xf = dcfc(k)*(1.+(a2+b2*dt(k))*dt(k))
      xfb = -(EXP(-(fk2*xf))*fk2*cfcexpb(k))
      cfcexpb(k) = 0.0
      dtb(k) = dtb(k) + (dcfc(k)*(a2+b2*dt(k))+dt(k)*dcfc(k)*b2)*xfb
    ELSE
      xf = dcfc(k)*(1.+(a1+b1*dt(k))*dt(k))
      xfb = -(EXP(-(fk1*xf))*fk1*cfcexpb(k))
      cfcexpb(k) = 0.0
      dtb(k) = dtb(k) + (dcfc(k)*(a1+b1*dt(k))+dt(k)*dcfc(k)*b1)*xfb
    END IF
  END DO
END SUBROUTINE CFCEXPS_B

!  Differentiation of b10exps in reverse (adjoint) mode:
!   gradient     of useful results: dh2o dcont dt co2exp h2oexp
!                n2oexp conexp
!   with respect to varying inputs: dh2o dcont dt co2exp h2oexp
!                n2oexp conexp
SUBROUTINE B10EXPS_B(np, dh2o, dh2ob, dcont, dcontb, dco2, dn2o, pa, dt&
& , dtb, h2oexp, h2oexpb, conexp, conexpb, co2exp, co2expb, n2oexp, &
& n2oexpb)
  IMPLICIT NONE
  INTEGER :: np, k
!---- input parameters -----
  REAL :: dh2o(0:np), dcont(0:np), dn2o(0:np)
  REAL :: dh2ob(0:np), dcontb(0:np)
  REAL :: dco2(0:np), pa(0:np), dt(0:np)
  REAL :: dtb(0:np)
!---- output parameters -----
  REAL :: h2oexp(0:np, 5), conexp(0:np), co2exp(0:np, 6), n2oexp(0:np, 2&
& )
  REAL :: h2oexpb(0:np, 5), conexpb(0:np), co2expb(0:np, 6), n2oexpb(0:&
& np, 2)
!---- temporary arrays -----
  REAL :: xx, xx1, xx2, xx3
  REAL :: xxb, xx1b, xx2b, xx3b
  INTRINSIC EXP
  REAL :: tempb2
  REAL :: tempb1
  REAL :: tempb0
  REAL :: tempb
  DO k=0,np
!-----Compute scaled h2o-line amount for Band 10 (Eq. 4.4 and Table 3).
    CALL PUSHREAL4(xx)
    xx = dh2o(k)*(pa(k)/500.0)*(1.+(0.0149+6.20e-5*dt(k))*dt(k))
!-----six exponentials by powers of 8
    h2oexp(k, 1) = EXP(-(xx*0.10624))
    xx = h2oexp(k, 1)*h2oexp(k, 1)
    CALL PUSHREAL4(xx)
    xx = xx*xx
    CALL PUSHREAL4(h2oexp(k, 2))
    h2oexp(k, 2) = xx*xx
    CALL PUSHREAL4(xx)
    xx = h2oexp(k, 2)*h2oexp(k, 2)
    CALL PUSHREAL4(xx)
    xx = xx*xx
    CALL PUSHREAL4(h2oexp(k, 3))
    h2oexp(k, 3) = xx*xx
    CALL PUSHREAL4(xx)
    xx = h2oexp(k, 3)*h2oexp(k, 3)
    CALL PUSHREAL4(xx)
    xx = xx*xx
    CALL PUSHREAL4(h2oexp(k, 4))
    h2oexp(k, 4) = xx*xx
    CALL PUSHREAL4(xx)
    xx = h2oexp(k, 4)*h2oexp(k, 4)
    CALL PUSHREAL4(xx)
    xx = xx*xx
!-----one exponential of h2o continuum for sub-band 3a (Table 9).
!-----Scaled co2 amount for the Band 10 (Eq. 4.4, Tables 3 and 6).
    CALL PUSHREAL4(xx)
    xx = dco2(k)*(pa(k)/300.0)**0.5*(1.+(0.0179+1.02e-4*dt(k))*dt(k))
!-----six exponentials by powers of 8
    co2exp(k, 1) = EXP(-(xx*2.656e-5))
    xx = co2exp(k, 1)*co2exp(k, 1)
    CALL PUSHREAL4(xx)
    xx = xx*xx
    CALL PUSHREAL4(co2exp(k, 2))
    co2exp(k, 2) = xx*xx
    CALL PUSHREAL4(xx)
    xx = co2exp(k, 2)*co2exp(k, 2)
    CALL PUSHREAL4(xx)
    xx = xx*xx
    CALL PUSHREAL4(co2exp(k, 3))
    co2exp(k, 3) = xx*xx
    CALL PUSHREAL4(xx)
    xx = co2exp(k, 3)*co2exp(k, 3)
    CALL PUSHREAL4(xx)
    xx = xx*xx
    CALL PUSHREAL4(co2exp(k, 4))
    co2exp(k, 4) = xx*xx
    CALL PUSHREAL4(xx)
    xx = co2exp(k, 4)*co2exp(k, 4)
    CALL PUSHREAL4(xx)
    xx = xx*xx
    CALL PUSHREAL4(co2exp(k, 5))
    co2exp(k, 5) = xx*xx
    CALL PUSHREAL4(xx)
    xx = co2exp(k, 5)*co2exp(k, 5)
    CALL PUSHREAL4(xx)
    xx = xx*xx
!-----Compute the scaled n2o amount for Band 10 (Table 5).
    CALL PUSHREAL4(xx)
    xx = dn2o(k)*(1.+(1.4476e-3+3.6656e-6*dt(k))*dt(k))
!-----Two exponentials by powers of 58
    n2oexp(k, 1) = EXP(-(xx*0.25238))
    xx = n2oexp(k, 1)*n2oexp(k, 1)
    CALL PUSHREAL4(xx1)
    xx1 = xx*xx
    CALL PUSHREAL4(xx1)
    xx1 = xx1*xx1
  END DO
  DO k=np,0,-1
    xx2 = xx1*xx1
    xx3 = xx2*xx2
    tempb = xx2*xx3*n2oexpb(k, 2)
    tempb0 = xx*xx1*n2oexpb(k, 2)
    xxb = xx1*tempb
    xx3b = xx2*tempb0
    xx2b = 2*xx2*xx3b + xx3*tempb0
    xx1b = 2*xx1*xx2b + xx*tempb
    n2oexpb(k, 2) = 0.0
    CALL POPREAL4(xx1)
    xx1b = 2*xx1*xx1b
    CALL POPREAL4(xx1)
    xxb = xxb + 2*xx*xx1b
    n2oexpb(k, 1) = n2oexpb(k, 1) + 2*n2oexp(k, 1)*xxb
    xx = dn2o(k)*(1.+(1.4476e-3+3.6656e-6*dt(k))*dt(k))
    xxb = -(EXP(-(0.25238*xx))*0.25238*n2oexpb(k, 1))
    n2oexpb(k, 1) = 0.0
    CALL POPREAL4(xx)
    dtb(k) = dtb(k) + (dn2o(k)*(3.6656e-6*dt(k)+1.4476e-3)+dt(k)*dn2o(k)&
&     *3.6656e-6)*xxb
    xxb = 2*xx*co2expb(k, 6)
    co2expb(k, 6) = 0.0
    CALL POPREAL4(xx)
    xxb = 2*xx*xxb
    CALL POPREAL4(xx)
    co2expb(k, 5) = co2expb(k, 5) + 2*co2exp(k, 5)*xxb
    CALL POPREAL4(co2exp(k, 5))
    xxb = 2*xx*co2expb(k, 5)
    co2expb(k, 5) = 0.0
    CALL POPREAL4(xx)
    xxb = 2*xx*xxb
    CALL POPREAL4(xx)
    co2expb(k, 4) = co2expb(k, 4) + 2*co2exp(k, 4)*xxb
    CALL POPREAL4(co2exp(k, 4))
    xxb = 2*xx*co2expb(k, 4)
    co2expb(k, 4) = 0.0
    CALL POPREAL4(xx)
    xxb = 2*xx*xxb
    CALL POPREAL4(xx)
    co2expb(k, 3) = co2expb(k, 3) + 2*co2exp(k, 3)*xxb
    CALL POPREAL4(co2exp(k, 3))
    xxb = 2*xx*co2expb(k, 3)
    co2expb(k, 3) = 0.0
    CALL POPREAL4(xx)
    xxb = 2*xx*xxb
    CALL POPREAL4(xx)
    co2expb(k, 2) = co2expb(k, 2) + 2*co2exp(k, 2)*xxb
    CALL POPREAL4(co2exp(k, 2))
    xxb = 2*xx*co2expb(k, 2)
    co2expb(k, 2) = 0.0
    CALL POPREAL4(xx)
    xxb = 2*xx*xxb
    co2expb(k, 1) = co2expb(k, 1) + 2*co2exp(k, 1)*xxb
    xx = dco2(k)*(pa(k)/300.0)**0.5*(1.+(0.0179+1.02e-4*dt(k))*dt(k))
    xxb = -(EXP(-(2.656e-5*xx))*2.656e-5*co2expb(k, 1))
    co2expb(k, 1) = 0.0
    CALL POPREAL4(xx)
    tempb1 = (pa(k)/300.0)**0.5*dco2(k)*xxb
    dcontb(k) = dcontb(k) - EXP(-(109.0*dcont(k)))*109.0*conexpb(k)
    conexpb(k) = 0.0
    xxb = 2*xx*h2oexpb(k, 5)
    h2oexpb(k, 5) = 0.0
    CALL POPREAL4(xx)
    xxb = 2*xx*xxb
    CALL POPREAL4(xx)
    h2oexpb(k, 4) = h2oexpb(k, 4) + 2*h2oexp(k, 4)*xxb
    CALL POPREAL4(h2oexp(k, 4))
    xxb = 2*xx*h2oexpb(k, 4)
    h2oexpb(k, 4) = 0.0
    CALL POPREAL4(xx)
    xxb = 2*xx*xxb
    CALL POPREAL4(xx)
    h2oexpb(k, 3) = h2oexpb(k, 3) + 2*h2oexp(k, 3)*xxb
    CALL POPREAL4(h2oexp(k, 3))
    xxb = 2*xx*h2oexpb(k, 3)
    h2oexpb(k, 3) = 0.0
    CALL POPREAL4(xx)
    xxb = 2*xx*xxb
    CALL POPREAL4(xx)
    h2oexpb(k, 2) = h2oexpb(k, 2) + 2*h2oexp(k, 2)*xxb
    CALL POPREAL4(h2oexp(k, 2))
    xxb = 2*xx*h2oexpb(k, 2)
    h2oexpb(k, 2) = 0.0
    CALL POPREAL4(xx)
    xxb = 2*xx*xxb
    h2oexpb(k, 1) = h2oexpb(k, 1) + 2*h2oexp(k, 1)*xxb
    xx = dh2o(k)*(pa(k)/500.0)*(1.+(0.0149+6.20e-5*dt(k))*dt(k))
    xxb = -(EXP(-(0.10624*xx))*0.10624*h2oexpb(k, 1))
    h2oexpb(k, 1) = 0.0
    CALL POPREAL4(xx)
    tempb2 = pa(k)*dh2o(k)*xxb/500.0
    dtb(k) = dtb(k) + (6.20e-5*dt(k)+dt(k)*6.20e-5+0.0149)*tempb2 + (&
&     1.02e-4*dt(k)+dt(k)*1.02e-4+0.0179)*tempb1
    dh2ob(k) = dh2ob(k) + ((6.20e-5*dt(k)+0.0149)*dt(k)+1.)*pa(k)*xxb/&
&     500.0
  END DO
END SUBROUTINE B10EXPS_B

!  Differentiation of tablup in reverse (adjoint) mode:
!   gradient     of useful results: s1 s2 s3 dt dw tran
!   with respect to varying inputs: s1 s2 s3 dt dw tran
SUBROUTINE TABLUP_B(nx1, nh1, dw, dwb, p, dt, dtb, s1, s1b, s2, s2b, s3&
& , s3b, w1, p1, dwe, dpe, coef1, coef2, coef3, tran, tranb)
  IMPLICIT NONE
  INTEGER :: nx1, nh1
!---- input parameters -----
  REAL :: w1, p1, dwe, dpe
  REAL :: dw, p, dt
  REAL :: dwb, dtb
  REAL :: coef1(nx1, nh1), coef2(nx1, nh1), coef3(nx1, nh1)
!---- update parameter -----
  REAL :: s1, s2, s3, tran
  REAL :: s1b, s2b, s3b, tranb
!---- temporary variables -----
  REAL :: we, pe, fw, fp, pa, pb, pc, ax, ba, bb, t1, ca, cb, t2
  REAL :: web, peb, fwb, fpb, pab, pbb, pcb, axb, bab, bbb, t1b, cab, &
& cbb, t2b
  REAL :: x1, x2, x3, xx, x1c
  REAL :: x1b, x2b, x3b, xxb, x1cb
  INTEGER :: iw, ip
  INTRINSIC LOG10
  INTRINSIC REAL
  INTRINSIC MIN
  INTRINSIC INT
  INTRINSIC MAX
  INTEGER :: branch
  REAL :: tempb0
  REAL :: tempb
  REAL :: y2
  REAL :: y1
!-----Compute effective pressure (x2) and temperature (x3) following 
!     Eqs. (8.28) and (8.29)
  s1 = s1 + dw
  s2 = s2 + p*dw
  s3 = s3 + dt*dw
  x1 = s1
  x1c = 1.0/s1
  x2 = s2*x1c
  x3 = s3*x1c
!-----normalize we and pe
!       we=(log10(x1)-w1)/dwe
!       pe=(log10(x2)-p1)/dpe
  we = (LOG10(x1)-w1)*dwe
  pe = (LOG10(x2)-p1)*dpe
  y1 = REAL(nh1 - 1)
  IF (we .GT. y1) THEN
    we = y1
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    we = we
  END IF
  y2 = REAL(nx1 - 1)
  IF (pe .GT. y2) THEN
    pe = y2
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    pe = pe
  END IF
!-----assign iw and ip and compute the distance of we and pe 
!     from iw and ip.
  iw = INT(we + 1.0)
  IF (iw .GT. nh1 - 1) THEN
    iw = nh1 - 1
  ELSE
    iw = iw
  END IF
  IF (iw .LT. 2) THEN
    iw = 2
  ELSE
    iw = iw
  END IF
  fw = we - REAL(iw - 1)
  ip = INT(pe + 1.0)
  IF (ip .GT. nx1 - 1) THEN
    ip = nx1 - 1
  ELSE
    ip = ip
  END IF
  IF (ip .LT. 1) THEN
    ip = 1
  ELSE
    ip = ip
  END IF
  fp = pe - REAL(ip - 1)
!-----linear interpolation in pressure
!       pa = coef1(ip,iw-1)*(1.-fp)+coef1(ip+1,iw-1)*fp
!       pb = coef1(ip,  iw)*(1.-fp)+coef1(ip+1,  iw)*fp
!       pc = coef1(ip,iw+1)*(1.-fp)+coef1(ip+1,iw+1)*fp
  pa = coef1(ip, iw-1) + (coef1(ip+1, iw-1)-coef1(ip, iw-1))*fp
  pb = coef1(ip, iw) + (coef1(ip+1, iw)-coef1(ip, iw))*fp
  pc = coef1(ip, iw+1) + (coef1(ip+1, iw+1)-coef1(ip, iw+1))*fp
!-----quadratic interpolation in absorber amount for coef1
!       ax = (-pa*(1.-fw)+pc*(1.+fw)) *fw*0.5 + pb*(1.-fw*fw)
  ax = ((pc+pa)*fw+(pc-pa))*fw*0.5 + pb*(1.-fw*fw)
!-----linear interpolation in absorber amount for coef2 and coef3
!       ba = coef2(ip,  iw)*(1.-fp)+coef2(ip+1,  iw)*fp
!       bb = coef2(ip,iw+1)*(1.-fp)+coef2(ip+1,iw+1)*fp
!       t1 = ba*(1.-fw) + bb*fw
  ba = coef2(ip, iw) + (coef2(ip+1, iw)-coef2(ip, iw))*fp
  bb = coef2(ip, iw+1) + (coef2(ip+1, iw+1)-coef2(ip, iw+1))*fp
  t1 = ba + (bb-ba)*fw
!       ca = coef3(ip,  iw)*(1.-fp)+coef3(ip+1,  iw)*fp
!       cb = coef3(ip,iw+1)*(1.-fp)+coef3(ip+1,iw+1)*fp
!       t2 = ca*(1.-fw) + cb*fw
  ca = coef3(ip, iw) + (coef3(ip+1, iw)-coef3(ip, iw))*fp
  cb = coef3(ip, iw+1) + (coef3(ip+1, iw+1)-coef3(ip, iw+1))*fp
  t2 = ca + (cb-ca)*fw
!-----update the total transmittance between levels k1 and k2
  xx = ax + (t1+t2*x3)*x3
  IF (xx .GT. 0.9999999) THEN
    xx = 0.9999999
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    xx = xx
  END IF
  IF (xx .LT. 0.0000001) THEN
    xx = 0.0000001
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    xx = xx
  END IF
  xxb = tran*tranb
  tranb = xx*tranb
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) xxb = 0.0
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) xxb = 0.0
  tempb = x3*xxb
  axb = xxb
  t1b = tempb
  t2b = x3*tempb
  x3b = (t1+t2*x3)*xxb + t2*tempb
  cab = (1.0-fw)*t2b
  cbb = fw*t2b
  bab = (1.0-fw)*t1b
  bbb = fw*t1b
  tempb0 = 0.5*fw*axb
  fwb = (bb-ba)*t1b + (0.5*((pc+pa)*fw+pc-pa)-pb*2*fw)*axb + (pc+pa)*&
&   tempb0 + (cb-ca)*t2b
  pcb = (fw+1.0)*tempb0
  pab = (fw-1.0)*tempb0
  pbb = (1.-fw**2)*axb
  fpb = (coef3(ip+1, iw)-coef3(ip, iw))*cab + (coef2(ip+1, iw)-coef2(ip&
&   , iw))*bab + (coef1(ip+1, iw)-coef1(ip, iw))*pbb + (coef1(ip+1, iw-1&
&   )-coef1(ip, iw-1))*pab + (coef1(ip+1, iw+1)-coef1(ip, iw+1))*pcb + (&
&   coef2(ip+1, iw+1)-coef2(ip, iw+1))*bbb + (coef3(ip+1, iw+1)-coef3(ip&
&   , iw+1))*cbb
  peb = fpb
  web = fwb
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) peb = 0.0
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) web = 0.0
  x2b = dpe*peb/(x2*LOG(10.0))
  x1b = dwe*web/(x1*LOG(10.0))
  s3b = s3b + x1c*x3b
  x1cb = s2*x2b + s3*x3b
  s2b = s2b + x1c*x2b
  s1b = s1b + x1b - x1cb/s1**2
  dtb = dtb + dw*s3b
  dwb = dwb + p*s2b + s1b + dt*s3b
END SUBROUTINE TABLUP_B

!  Differentiation of h2okdis in reverse (adjoint) mode:
!   gradient     of useful results: tran tcon h2oexp th2o conexp
!   with respect to varying inputs: tcon h2oexp th2o conexp
SUBROUTINE H2OKDIS_B(ib, np, k, fkw, gkw, ne, h2oexp, h2oexpb, conexp, &
& conexpb, th2o, th2ob, tcon, tconb, tran, tranb)
  IMPLICIT NONE
!---- input parameters ------
  INTEGER :: ib, ne, np, k
  REAL :: h2oexp(0:np, 6), conexp(0:np, 3)
  REAL :: h2oexpb(0:np, 6), conexpb(0:np, 3)
  REAL :: fkw(6, 9), gkw(6, 3)
!---- updated parameters -----
  REAL :: th2o(6), tcon(3), tran
  REAL :: th2ob(6), tconb(3), tranb
!---- temporary arrays -----
  REAL :: trnth2o
  REAL :: trnth2ob
  INTEGER :: i
  REAL :: tempb2
  REAL :: tempb1
  REAL :: tempb0
  REAL :: tempb
!-----tco2 are the six exp factors between levels k1 and k2 
!     tran is the updated total transmittance between levels k1 and k2
!-----th2o is the 6 exp factors between levels k1 and k2 due to
!     h2o line absorption. 
!-----tcon is the 3 exp factors between levels k1 and k2 due to
!     h2o continuum absorption.
!-----trnth2o is the total transmittance between levels k1 and k2 due
!     to both line and continuum absorption.
!-----Compute th2o following Eq. (8.23).
  CALL PUSHREAL4(th2o(1))
  th2o(1) = th2o(1)*h2oexp(k, 1)
  CALL PUSHREAL4(th2o(2))
  th2o(2) = th2o(2)*h2oexp(k, 2)
  CALL PUSHREAL4(th2o(3))
  th2o(3) = th2o(3)*h2oexp(k, 3)
  CALL PUSHREAL4(th2o(4))
  th2o(4) = th2o(4)*h2oexp(k, 4)
  CALL PUSHREAL4(th2o(5))
  th2o(5) = th2o(5)*h2oexp(k, 5)
  CALL PUSHREAL4(th2o(6))
  th2o(6) = th2o(6)*h2oexp(k, 6)
  IF (ne .EQ. 0) THEN
    trnth2ob = tran*tranb
    th2ob(1) = th2ob(1) + fkw(1, ib)*trnth2ob
    th2ob(2) = th2ob(2) + fkw(2, ib)*trnth2ob
    th2ob(3) = th2ob(3) + fkw(3, ib)*trnth2ob
    th2ob(4) = th2ob(4) + fkw(4, ib)*trnth2ob
    th2ob(5) = th2ob(5) + fkw(5, ib)*trnth2ob
    th2ob(6) = th2ob(6) + fkw(6, ib)*trnth2ob
  ELSE IF (ne .EQ. 1) THEN
!-----Compute trnh2o following Eqs. (8.25) and (4.27).
    CALL PUSHREAL4(tcon(1))
    tcon(1) = tcon(1)*conexp(k, 1)
    trnth2ob = tran*tranb
    tempb = tcon(1)*trnth2ob
    th2ob(1) = th2ob(1) + fkw(1, ib)*tempb
    th2ob(2) = th2ob(2) + fkw(2, ib)*tempb
    th2ob(3) = th2ob(3) + fkw(3, ib)*tempb
    th2ob(4) = th2ob(4) + fkw(4, ib)*tempb
    th2ob(5) = th2ob(5) + fkw(5, ib)*tempb
    th2ob(6) = th2ob(6) + fkw(6, ib)*tempb
    tconb(1) = tconb(1) + (fkw(1, ib)*th2o(1)+fkw(2, ib)*th2o(2)+fkw(3, &
&     ib)*th2o(3)+fkw(4, ib)*th2o(4)+fkw(5, ib)*th2o(5)+fkw(6, ib)*th2o(&
&     6))*trnth2ob
    CALL POPREAL4(tcon(1))
    conexpb(k, 1) = conexpb(k, 1) + tcon(1)*tconb(1)
    tconb(1) = conexp(k, 1)*tconb(1)
  ELSE
!-----For band 3. This band is divided into 3 subbands.
    CALL PUSHREAL4(tcon(1))
    tcon(1) = tcon(1)*conexp(k, 1)
    CALL PUSHREAL4(tcon(2))
    tcon(2) = tcon(2)*conexp(k, 2)
    CALL PUSHREAL4(tcon(3))
    tcon(3) = tcon(3)*conexp(k, 3)
!-----Compute trnh2o following Eqs. (4.29) and (8.25).
    trnth2ob = tran*tranb
    tempb0 = tcon(1)*trnth2ob
    tempb1 = tcon(2)*trnth2ob
    tempb2 = tcon(3)*trnth2ob
    th2ob(1) = th2ob(1) + gkw(1, 3)*tempb2 + gkw(1, 2)*tempb1 + gkw(1, 1&
&     )*tempb0
    th2ob(2) = th2ob(2) + gkw(2, 3)*tempb2 + gkw(2, 2)*tempb1 + gkw(2, 1&
&     )*tempb0
    th2ob(3) = th2ob(3) + gkw(3, 3)*tempb2 + gkw(3, 2)*tempb1 + gkw(3, 1&
&     )*tempb0
    th2ob(4) = th2ob(4) + gkw(4, 3)*tempb2 + gkw(4, 2)*tempb1 + gkw(4, 1&
&     )*tempb0
    th2ob(5) = th2ob(5) + gkw(5, 3)*tempb2 + gkw(5, 2)*tempb1 + gkw(5, 1&
&     )*tempb0
    th2ob(6) = th2ob(6) + gkw(6, 3)*tempb2 + gkw(6, 2)*tempb1 + gkw(6, 1&
&     )*tempb0
    tconb(1) = tconb(1) + (gkw(1, 1)*th2o(1)+gkw(2, 1)*th2o(2)+gkw(3, 1)&
&     *th2o(3)+gkw(4, 1)*th2o(4)+gkw(5, 1)*th2o(5)+gkw(6, 1)*th2o(6))*&
&     trnth2ob
    tconb(2) = tconb(2) + (gkw(1, 2)*th2o(1)+gkw(2, 2)*th2o(2)+gkw(3, 2)&
&     *th2o(3)+gkw(4, 2)*th2o(4)+gkw(5, 2)*th2o(5)+gkw(6, 2)*th2o(6))*&
&     trnth2ob
    tconb(3) = tconb(3) + (gkw(1, 3)*th2o(1)+gkw(2, 3)*th2o(2)+gkw(3, 3)&
&     *th2o(3)+gkw(4, 3)*th2o(4)+gkw(5, 3)*th2o(5)+gkw(6, 3)*th2o(6))*&
&     trnth2ob
    CALL POPREAL4(tcon(3))
    conexpb(k, 3) = conexpb(k, 3) + tcon(3)*tconb(3)
    tconb(3) = conexp(k, 3)*tconb(3)
    CALL POPREAL4(tcon(2))
    conexpb(k, 2) = conexpb(k, 2) + tcon(2)*tconb(2)
    tconb(2) = conexp(k, 2)*tconb(2)
    CALL POPREAL4(tcon(1))
    conexpb(k, 1) = conexpb(k, 1) + tcon(1)*tconb(1)
    tconb(1) = conexp(k, 1)*tconb(1)
  END IF
  CALL POPREAL4(th2o(6))
  h2oexpb(k, 6) = h2oexpb(k, 6) + th2o(6)*th2ob(6)
  th2ob(6) = h2oexp(k, 6)*th2ob(6)
  CALL POPREAL4(th2o(5))
  h2oexpb(k, 5) = h2oexpb(k, 5) + th2o(5)*th2ob(5)
  th2ob(5) = h2oexp(k, 5)*th2ob(5)
  CALL POPREAL4(th2o(4))
  h2oexpb(k, 4) = h2oexpb(k, 4) + th2o(4)*th2ob(4)
  th2ob(4) = h2oexp(k, 4)*th2ob(4)
  CALL POPREAL4(th2o(3))
  h2oexpb(k, 3) = h2oexpb(k, 3) + th2o(3)*th2ob(3)
  th2ob(3) = h2oexp(k, 3)*th2ob(3)
  CALL POPREAL4(th2o(2))
  h2oexpb(k, 2) = h2oexpb(k, 2) + th2o(2)*th2ob(2)
  th2ob(2) = h2oexp(k, 2)*th2ob(2)
  CALL POPREAL4(th2o(1))
  h2oexpb(k, 1) = h2oexpb(k, 1) + th2o(1)*th2ob(1)
  th2ob(1) = h2oexp(k, 1)*th2ob(1)
END SUBROUTINE H2OKDIS_B

!  Differentiation of n2okdis in reverse (adjoint) mode:
!   gradient     of useful results: tran tn2o n2oexp
!   with respect to varying inputs: tran tn2o n2oexp
SUBROUTINE N2OKDIS_B(ib, np, k, n2oexp, n2oexpb, tn2o, tn2ob, tran, &
& tranb)
  IMPLICIT NONE
  INTEGER :: ib, np, k
!---- input parameters -----
  REAL :: n2oexp(0:np, 4)
  REAL :: n2oexpb(0:np, 4)
!---- updated parameters -----
  REAL :: tn2o(4), tran
  REAL :: tn2ob(4), tranb
!---- temporary arrays -----
  REAL :: xc
  REAL :: xcb
  INTEGER :: branch
!-----tn2o is computed from Eq. (8.23). 
!     xc is the total n2o transmittance computed from (8.25)
!     The k-distribution functions are given in Table 5.
!-----band 6
  IF (ib .EQ. 6) THEN
    CALL PUSHREAL4(tn2o(1))
    tn2o(1) = tn2o(1)*n2oexp(k, 1)
    xc = 0.940414*tn2o(1)
    CALL PUSHREAL4(tn2o(2))
    tn2o(2) = tn2o(2)*n2oexp(k, 2)
    xc = xc + 0.059586*tn2o(2)
!-----band 7
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHREAL4(tn2o(1))
    tn2o(1) = tn2o(1)*n2oexp(k, 1)
    xc = 0.561961*tn2o(1)
    CALL PUSHREAL4(tn2o(2))
    tn2o(2) = tn2o(2)*n2oexp(k, 2)
    xc = xc + 0.138707*tn2o(2)
    CALL PUSHREAL4(tn2o(3))
    tn2o(3) = tn2o(3)*n2oexp(k, 3)
    xc = xc + 0.240670*tn2o(3)
    CALL PUSHREAL4(tn2o(4))
    tn2o(4) = tn2o(4)*n2oexp(k, 4)
    xc = xc + 0.058662*tn2o(4)
    CALL PUSHCONTROL1B(1)
  END IF
  xcb = tran*tranb
  tranb = xc*tranb
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    tn2ob(2) = tn2ob(2) + 0.059586*xcb
    CALL POPREAL4(tn2o(2))
    n2oexpb(k, 2) = n2oexpb(k, 2) + tn2o(2)*tn2ob(2)
    tn2ob(2) = n2oexp(k, 2)*tn2ob(2)
    tn2ob(1) = tn2ob(1) + 0.940414*xcb
    CALL POPREAL4(tn2o(1))
    n2oexpb(k, 1) = n2oexpb(k, 1) + tn2o(1)*tn2ob(1)
    tn2ob(1) = n2oexp(k, 1)*tn2ob(1)
  ELSE
    tn2ob(4) = tn2ob(4) + 0.058662*xcb
    CALL POPREAL4(tn2o(4))
    n2oexpb(k, 4) = n2oexpb(k, 4) + tn2o(4)*tn2ob(4)
    tn2ob(4) = n2oexp(k, 4)*tn2ob(4)
    tn2ob(3) = tn2ob(3) + 0.240670*xcb
    CALL POPREAL4(tn2o(3))
    n2oexpb(k, 3) = n2oexpb(k, 3) + tn2o(3)*tn2ob(3)
    tn2ob(3) = n2oexp(k, 3)*tn2ob(3)
    tn2ob(2) = tn2ob(2) + 0.138707*xcb
    CALL POPREAL4(tn2o(2))
    n2oexpb(k, 2) = n2oexpb(k, 2) + tn2o(2)*tn2ob(2)
    tn2ob(2) = n2oexp(k, 2)*tn2ob(2)
    tn2ob(1) = tn2ob(1) + 0.561961*xcb
    CALL POPREAL4(tn2o(1))
    n2oexpb(k, 1) = n2oexpb(k, 1) + tn2o(1)*tn2ob(1)
    tn2ob(1) = n2oexp(k, 1)*tn2ob(1)
  END IF
END SUBROUTINE N2OKDIS_B

!  Differentiation of ch4kdis in reverse (adjoint) mode:
!   gradient     of useful results: tran ch4exp tch4
!   with respect to varying inputs: tran ch4exp tch4
SUBROUTINE CH4KDIS_B(ib, np, k, ch4exp, ch4expb, tch4, tch4b, tran, &
& tranb)
  IMPLICIT NONE
  INTEGER :: ib, np, k
!---- input parameters -----
  REAL :: ch4exp(0:np, 4)
  REAL :: ch4expb(0:np, 4)
!---- updated parameters -----
  REAL :: tch4(4), tran
  REAL :: tch4b(4), tranb
!---- temporary arrays -----
  REAL :: xc
  REAL :: xcb
  INTEGER :: branch
!-----tch4 is computed from Eq. (8.23). 
!     xc is the total ch4 transmittance computed from (8.25)
!     The k-distribution functions are given in Table 5.
!-----band 6
  IF (ib .EQ. 6) THEN
    CALL PUSHREAL4(tch4(1))
    tch4(1) = tch4(1)*ch4exp(k, 1)
    xc = tch4(1)
!-----band 7
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHREAL4(tch4(1))
    tch4(1) = tch4(1)*ch4exp(k, 1)
    xc = 0.610650*tch4(1)
    CALL PUSHREAL4(tch4(2))
    tch4(2) = tch4(2)*ch4exp(k, 2)
    xc = xc + 0.280212*tch4(2)
    CALL PUSHREAL4(tch4(3))
    tch4(3) = tch4(3)*ch4exp(k, 3)
    xc = xc + 0.107349*tch4(3)
    CALL PUSHREAL4(tch4(4))
    tch4(4) = tch4(4)*ch4exp(k, 4)
    xc = xc + 0.001789*tch4(4)
    CALL PUSHCONTROL1B(1)
  END IF
  xcb = tran*tranb
  tranb = xc*tranb
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    tch4b(1) = tch4b(1) + xcb
    CALL POPREAL4(tch4(1))
    ch4expb(k, 1) = ch4expb(k, 1) + tch4(1)*tch4b(1)
    tch4b(1) = ch4exp(k, 1)*tch4b(1)
  ELSE
    tch4b(4) = tch4b(4) + 0.001789*xcb
    CALL POPREAL4(tch4(4))
    ch4expb(k, 4) = ch4expb(k, 4) + tch4(4)*tch4b(4)
    tch4b(4) = ch4exp(k, 4)*tch4b(4)
    tch4b(3) = tch4b(3) + 0.107349*xcb
    CALL POPREAL4(tch4(3))
    ch4expb(k, 3) = ch4expb(k, 3) + tch4(3)*tch4b(3)
    tch4b(3) = ch4exp(k, 3)*tch4b(3)
    tch4b(2) = tch4b(2) + 0.280212*xcb
    CALL POPREAL4(tch4(2))
    ch4expb(k, 2) = ch4expb(k, 2) + tch4(2)*tch4b(2)
    tch4b(2) = ch4exp(k, 2)*tch4b(2)
    tch4b(1) = tch4b(1) + 0.610650*xcb
    CALL POPREAL4(tch4(1))
    ch4expb(k, 1) = ch4expb(k, 1) + tch4(1)*tch4b(1)
    tch4b(1) = ch4exp(k, 1)*tch4b(1)
  END IF
END SUBROUTINE CH4KDIS_B

!  Differentiation of comkdis in reverse (adjoint) mode:
!   gradient     of useful results: tran tcom comexp
!   with respect to varying inputs: tran tcom comexp
SUBROUTINE COMKDIS_B(ib, np, k, comexp, comexpb, tcom, tcomb, tran, &
& tranb)
  IMPLICIT NONE
  INTEGER :: ib, np, k
!---- input parameters -----
  REAL :: comexp(0:np, 6)
  REAL :: comexpb(0:np, 6)
!---- updated parameters -----
  REAL :: tcom(6), tran
  REAL :: tcomb(6), tranb
!---- temporary arrays -----
  REAL :: xc
  REAL :: xcb
  INTEGER :: branch
!-----tcom is computed from Eq. (8.23). 
!     xc is the total co2 transmittance computed from (8.25)
!     The k-distribution functions are given in Table 6.
!-----band 4
  IF (ib .EQ. 4) THEN
    CALL PUSHREAL4(tcom(1))
    tcom(1) = tcom(1)*comexp(k, 1)
    xc = 0.12159*tcom(1)
    CALL PUSHREAL4(tcom(2))
    tcom(2) = tcom(2)*comexp(k, 2)
    xc = xc + 0.24359*tcom(2)
    CALL PUSHREAL4(tcom(3))
    tcom(3) = tcom(3)*comexp(k, 3)
    xc = xc + 0.24981*tcom(3)
    CALL PUSHREAL4(tcom(4))
    tcom(4) = tcom(4)*comexp(k, 4)
    xc = xc + 0.26427*tcom(4)
    CALL PUSHREAL4(tcom(5))
    tcom(5) = tcom(5)*comexp(k, 5)
    xc = xc + 0.07807*tcom(5)
    CALL PUSHREAL4(tcom(6))
    tcom(6) = tcom(6)*comexp(k, 6)
    xc = xc + 0.04267*tcom(6)
!-----band 5
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHREAL4(tcom(1))
    tcom(1) = tcom(1)*comexp(k, 1)
    xc = 0.06869*tcom(1)
    CALL PUSHREAL4(tcom(2))
    tcom(2) = tcom(2)*comexp(k, 2)
    xc = xc + 0.14795*tcom(2)
    CALL PUSHREAL4(tcom(3))
    tcom(3) = tcom(3)*comexp(k, 3)
    xc = xc + 0.19512*tcom(3)
    CALL PUSHREAL4(tcom(4))
    tcom(4) = tcom(4)*comexp(k, 4)
    xc = xc + 0.33446*tcom(4)
    CALL PUSHREAL4(tcom(5))
    tcom(5) = tcom(5)*comexp(k, 5)
    xc = xc + 0.17199*tcom(5)
    CALL PUSHREAL4(tcom(6))
    tcom(6) = tcom(6)*comexp(k, 6)
    xc = xc + 0.08179*tcom(6)
    CALL PUSHCONTROL1B(1)
  END IF
  xcb = tran*tranb
  tranb = xc*tranb
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    tcomb(6) = tcomb(6) + 0.04267*xcb
    CALL POPREAL4(tcom(6))
    comexpb(k, 6) = comexpb(k, 6) + tcom(6)*tcomb(6)
    tcomb(6) = comexp(k, 6)*tcomb(6)
    tcomb(5) = tcomb(5) + 0.07807*xcb
    CALL POPREAL4(tcom(5))
    comexpb(k, 5) = comexpb(k, 5) + tcom(5)*tcomb(5)
    tcomb(5) = comexp(k, 5)*tcomb(5)
    tcomb(4) = tcomb(4) + 0.26427*xcb
    CALL POPREAL4(tcom(4))
    comexpb(k, 4) = comexpb(k, 4) + tcom(4)*tcomb(4)
    tcomb(4) = comexp(k, 4)*tcomb(4)
    tcomb(3) = tcomb(3) + 0.24981*xcb
    CALL POPREAL4(tcom(3))
    comexpb(k, 3) = comexpb(k, 3) + tcom(3)*tcomb(3)
    tcomb(3) = comexp(k, 3)*tcomb(3)
    tcomb(2) = tcomb(2) + 0.24359*xcb
    CALL POPREAL4(tcom(2))
    comexpb(k, 2) = comexpb(k, 2) + tcom(2)*tcomb(2)
    tcomb(2) = comexp(k, 2)*tcomb(2)
    tcomb(1) = tcomb(1) + 0.12159*xcb
    CALL POPREAL4(tcom(1))
    comexpb(k, 1) = comexpb(k, 1) + tcom(1)*tcomb(1)
    tcomb(1) = comexp(k, 1)*tcomb(1)
  ELSE
    tcomb(6) = tcomb(6) + 0.08179*xcb
    CALL POPREAL4(tcom(6))
    comexpb(k, 6) = comexpb(k, 6) + tcom(6)*tcomb(6)
    tcomb(6) = comexp(k, 6)*tcomb(6)
    tcomb(5) = tcomb(5) + 0.17199*xcb
    CALL POPREAL4(tcom(5))
    comexpb(k, 5) = comexpb(k, 5) + tcom(5)*tcomb(5)
    tcomb(5) = comexp(k, 5)*tcomb(5)
    tcomb(4) = tcomb(4) + 0.33446*xcb
    CALL POPREAL4(tcom(4))
    comexpb(k, 4) = comexpb(k, 4) + tcom(4)*tcomb(4)
    tcomb(4) = comexp(k, 4)*tcomb(4)
    tcomb(3) = tcomb(3) + 0.19512*xcb
    CALL POPREAL4(tcom(3))
    comexpb(k, 3) = comexpb(k, 3) + tcom(3)*tcomb(3)
    tcomb(3) = comexp(k, 3)*tcomb(3)
    tcomb(2) = tcomb(2) + 0.14795*xcb
    CALL POPREAL4(tcom(2))
    comexpb(k, 2) = comexpb(k, 2) + tcom(2)*tcomb(2)
    tcomb(2) = comexp(k, 2)*tcomb(2)
    tcomb(1) = tcomb(1) + 0.06869*xcb
    CALL POPREAL4(tcom(1))
    comexpb(k, 1) = comexpb(k, 1) + tcom(1)*tcomb(1)
    tcomb(1) = comexp(k, 1)*tcomb(1)
  END IF
END SUBROUTINE COMKDIS_B

!  Differentiation of cfckdis in reverse (adjoint) mode:
!   gradient     of useful results: tran tcfc cfcexp
!   with respect to varying inputs: tran tcfc cfcexp
SUBROUTINE CFCKDIS_B(np, k, cfcexp, cfcexpb, tcfc, tcfcb, tran, tranb)
  IMPLICIT NONE
!---- input parameters -----
  INTEGER :: k, np
  REAL :: cfcexp(0:np)
  REAL :: cfcexpb(0:np)
!---- updated parameters -----
  REAL :: tcfc, tran
  REAL :: tcfcb, tranb
!-----tcfc is the exp factors between levels k1 and k2. 
  CALL PUSHREAL4(tcfc)
  tcfc = tcfc*cfcexp(k)
  tcfcb = tcfcb + tran*tranb
  tranb = tcfc*tranb
  CALL POPREAL4(tcfc)
  cfcexpb(k) = cfcexpb(k) + tcfc*tcfcb
  tcfcb = cfcexp(k)*tcfcb
END SUBROUTINE CFCKDIS_B

!  Differentiation of b10kdis in reverse (adjoint) mode:
!   gradient     of useful results: tran tn2o co2exp tcon h2oexp
!                n2oexp th2o tco2 conexp
!   with respect to varying inputs: tn2o co2exp tcon h2oexp n2oexp
!                th2o tco2 conexp
SUBROUTINE B10KDIS_B(np, k, h2oexp, h2oexpb, conexp, conexpb, co2exp, &
& co2expb, n2oexp, n2oexpb, th2o, th2ob, tcon, tconb, tco2, tco2b, tn2o&
& , tn2ob, tran, tranb)
  IMPLICIT NONE
  INTEGER :: np, k
!---- input parameters -----
  REAL :: h2oexp(0:np, 5), conexp(0:np), co2exp(0:np, 6), n2oexp(0:np, 2&
& )
  REAL :: h2oexpb(0:np, 5), conexpb(0:np), co2expb(0:np, 6), n2oexpb(0:&
& np, 2)
!---- updated parameters -----
  REAL :: th2o(6), tcon(3), tco2(6), tn2o(4), tran
  REAL :: th2ob(6), tconb(3), tco2b(6), tn2ob(4), tranb
!---- temporary arrays -----
  REAL :: xx
  REAL :: xxb
!-----For h2o line. The k-distribution functions are given in Table 4.
  CALL PUSHREAL4(th2o(1))
  th2o(1) = th2o(1)*h2oexp(k, 1)
  xx = 0.3153*th2o(1)
  CALL PUSHREAL4(th2o(2))
  th2o(2) = th2o(2)*h2oexp(k, 2)
  xx = xx + 0.4604*th2o(2)
  CALL PUSHREAL4(th2o(3))
  th2o(3) = th2o(3)*h2oexp(k, 3)
  xx = xx + 0.1326*th2o(3)
  CALL PUSHREAL4(th2o(4))
  th2o(4) = th2o(4)*h2oexp(k, 4)
  xx = xx + 0.0798*th2o(4)
  CALL PUSHREAL4(th2o(5))
  th2o(5) = th2o(5)*h2oexp(k, 5)
  xx = xx + 0.0119*th2o(5)
  tran = xx
!-----For h2o continuum. Note that conexp(k,3) is for subband 3a.
  CALL PUSHREAL4(tcon(1))
  tcon(1) = tcon(1)*conexp(k)
  CALL PUSHREAL4(tran)
  tran = tran*tcon(1)
!-----For co2 (Table 6)
  CALL PUSHREAL4(tco2(1))
  tco2(1) = tco2(1)*co2exp(k, 1)
  xx = 0.2673*tco2(1)
  CALL PUSHREAL4(tco2(2))
  tco2(2) = tco2(2)*co2exp(k, 2)
  xx = xx + 0.2201*tco2(2)
  CALL PUSHREAL4(tco2(3))
  tco2(3) = tco2(3)*co2exp(k, 3)
  xx = xx + 0.2106*tco2(3)
  CALL PUSHREAL4(tco2(4))
  tco2(4) = tco2(4)*co2exp(k, 4)
  xx = xx + 0.2409*tco2(4)
  CALL PUSHREAL4(tco2(5))
  tco2(5) = tco2(5)*co2exp(k, 5)
  xx = xx + 0.0196*tco2(5)
  CALL PUSHREAL4(tco2(6))
  tco2(6) = tco2(6)*co2exp(k, 6)
  xx = xx + 0.0415*tco2(6)
  CALL PUSHREAL4(tran)
  tran = tran*xx
!-----For n2o (Table 5)
  CALL PUSHREAL4(tn2o(1))
  tn2o(1) = tn2o(1)*n2oexp(k, 1)
  CALL PUSHREAL4(xx)
  xx = 0.970831*tn2o(1)
  CALL PUSHREAL4(tn2o(2))
  tn2o(2) = tn2o(2)*n2oexp(k, 2)
  xx = xx + 0.029169*tn2o(2)
  xxb = tran*tranb
  tranb = (xx-1.0)*tranb
  tn2ob(2) = tn2ob(2) + 0.029169*xxb
  CALL POPREAL4(tn2o(2))
  n2oexpb(k, 2) = n2oexpb(k, 2) + tn2o(2)*tn2ob(2)
  tn2ob(2) = n2oexp(k, 2)*tn2ob(2)
  CALL POPREAL4(xx)
  tn2ob(1) = tn2ob(1) + 0.970831*xxb
  CALL POPREAL4(tn2o(1))
  n2oexpb(k, 1) = n2oexpb(k, 1) + tn2o(1)*tn2ob(1)
  tn2ob(1) = n2oexp(k, 1)*tn2ob(1)
  CALL POPREAL4(tran)
  xxb = tran*tranb
  tranb = xx*tranb
  tco2b(6) = tco2b(6) + 0.0415*xxb
  CALL POPREAL4(tco2(6))
  co2expb(k, 6) = co2expb(k, 6) + tco2(6)*tco2b(6)
  tco2b(6) = co2exp(k, 6)*tco2b(6)
  tco2b(5) = tco2b(5) + 0.0196*xxb
  CALL POPREAL4(tco2(5))
  co2expb(k, 5) = co2expb(k, 5) + tco2(5)*tco2b(5)
  tco2b(5) = co2exp(k, 5)*tco2b(5)
  tco2b(4) = tco2b(4) + 0.2409*xxb
  CALL POPREAL4(tco2(4))
  co2expb(k, 4) = co2expb(k, 4) + tco2(4)*tco2b(4)
  tco2b(4) = co2exp(k, 4)*tco2b(4)
  tco2b(3) = tco2b(3) + 0.2106*xxb
  CALL POPREAL4(tco2(3))
  co2expb(k, 3) = co2expb(k, 3) + tco2(3)*tco2b(3)
  tco2b(3) = co2exp(k, 3)*tco2b(3)
  tco2b(2) = tco2b(2) + 0.2201*xxb
  CALL POPREAL4(tco2(2))
  co2expb(k, 2) = co2expb(k, 2) + tco2(2)*tco2b(2)
  tco2b(2) = co2exp(k, 2)*tco2b(2)
  tco2b(1) = tco2b(1) + 0.2673*xxb
  CALL POPREAL4(tco2(1))
  co2expb(k, 1) = co2expb(k, 1) + tco2(1)*tco2b(1)
  tco2b(1) = co2exp(k, 1)*tco2b(1)
  CALL POPREAL4(tran)
  tconb(1) = tconb(1) + tran*tranb
  tranb = tcon(1)*tranb
  CALL POPREAL4(tcon(1))
  conexpb(k) = conexpb(k) + tcon(1)*tconb(1)
  tconb(1) = conexp(k)*tconb(1)
  xxb = tranb
  th2ob(5) = th2ob(5) + 0.0119*xxb
  CALL POPREAL4(th2o(5))
  h2oexpb(k, 5) = h2oexpb(k, 5) + th2o(5)*th2ob(5)
  th2ob(5) = h2oexp(k, 5)*th2ob(5)
  th2ob(4) = th2ob(4) + 0.0798*xxb
  CALL POPREAL4(th2o(4))
  h2oexpb(k, 4) = h2oexpb(k, 4) + th2o(4)*th2ob(4)
  th2ob(4) = h2oexp(k, 4)*th2ob(4)
  th2ob(3) = th2ob(3) + 0.1326*xxb
  CALL POPREAL4(th2o(3))
  h2oexpb(k, 3) = h2oexpb(k, 3) + th2o(3)*th2ob(3)
  th2ob(3) = h2oexp(k, 3)*th2ob(3)
  th2ob(2) = th2ob(2) + 0.4604*xxb
  CALL POPREAL4(th2o(2))
  h2oexpb(k, 2) = h2oexpb(k, 2) + th2o(2)*th2ob(2)
  th2ob(2) = h2oexp(k, 2)*th2ob(2)
  th2ob(1) = th2ob(1) + 0.3153*xxb
  CALL POPREAL4(th2o(1))
  h2oexpb(k, 1) = h2oexpb(k, 1) + th2o(1)*th2ob(1)
  th2ob(1) = h2oexp(k, 1)*th2ob(1)
END SUBROUTINE B10KDIS_B

!  Differentiation of cldovlp in reverse (adjoint) mode:
!   gradient     of useful results: cldhi ett cldlw enn cldmd
!   with respect to varying inputs: cldhi ett cldlw enn cldmd
!mjs
SUBROUTINE CLDOVLP_B(np, k1, k2, ict, icb, icx, ncld, enn, ennb, ett, &
& ettb, cldhi, cldhib, cldmd, cldmdb, cldlw, cldlwb)
  IMPLICIT NONE
  INTEGER, INTENT(IN) :: np, k1, k2, ict, icb, icx(0:np), ncld(3)
  REAL, INTENT(IN) :: enn(0:np), ett(0:np)
  REAL :: ennb(0:np), ettb(0:np)
  REAL, INTENT(INOUT) :: cldhi, cldmd, cldlw
  REAL, INTENT(INOUT) :: cldhib
  INTEGER :: i, j, k, km, kx
  INTEGER :: branch
  REAL, INTENT(INOUT) :: cldmdb
  REAL, INTENT(INOUT) :: cldlwb
  km = k2 - 1
  IF (km .LT. ict) THEN
! do high clouds
    kx = ncld(1)
    IF (kx .EQ. 1 .OR. cldhi .EQ. 0.) THEN
      ennb(km) = ennb(km) + cldhib
    ELSE
!if ( (kx.lt.1 .or. kx.gt.1)  .and. abs(cldhi) .gt. 0.) then
      CALL PUSHREAL4(cldhi)
      cldhi = 0.0
      IF (kx .NE. 0) THEN
        DO k=ict-kx,ict-1
          j = icx(k)
          IF (j .GE. k1 .AND. j .LE. km) THEN
            CALL PUSHREAL4(cldhi)
            cldhi = enn(j) + ett(j)*cldhi
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
        DO k=ict-1,ict-kx,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            j = icx(k)
            CALL POPREAL4(cldhi)
            ennb(j) = ennb(j) + cldhib
            ettb(j) = ettb(j) + cldhi*cldhib
            cldhib = ett(j)*cldhib
          END IF
        END DO
      END IF
      CALL POPREAL4(cldhi)
    END IF
    cldhib = 0.0
  ELSE IF (km .GE. ict .AND. km .LT. icb) THEN
! do middle clouds
    kx = ncld(2)
    IF (kx .EQ. 1 .OR. cldmd .EQ. 0.) THEN
      ennb(km) = ennb(km) + cldmdb
    ELSE
!if ( (kx.lt.1 .or. kx.gt.1)  .and. abs(cldhi) .gt. 0.) then
      CALL PUSHREAL4(cldmd)
      cldmd = 0.0
      IF (kx .NE. 0) THEN
        DO k=icb-kx,icb-1
          j = icx(k)
          IF (j .GE. k1 .AND. j .LE. km) THEN
            CALL PUSHREAL4(cldmd)
            cldmd = enn(j) + ett(j)*cldmd
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
        DO k=icb-1,icb-kx,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            j = icx(k)
            CALL POPREAL4(cldmd)
            ennb(j) = ennb(j) + cldmdb
            ettb(j) = ettb(j) + cldmd*cldmdb
            cldmdb = ett(j)*cldmdb
          END IF
        END DO
      END IF
      CALL POPREAL4(cldmd)
    END IF
    cldmdb = 0.0
  ELSE
! do low clouds
    kx = ncld(3)
    IF (kx .EQ. 1 .OR. cldlw .EQ. 0.) THEN
      ennb(km) = ennb(km) + cldlwb
    ELSE
!if ( (kx.lt.1 .or. kx.gt.1)  .and. abs(cldhi) .gt. 0.) then
      CALL PUSHREAL4(cldlw)
      cldlw = 0.0
      IF (kx .NE. 0) THEN
        DO k=np+1-kx,np
          j = icx(k)
          IF (j .GE. k1 .AND. j .LE. km) THEN
            CALL PUSHREAL4(cldlw)
            cldlw = enn(j) + ett(j)*cldlw
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
        DO k=np,np+1-kx,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) THEN
            j = icx(k)
            CALL POPREAL4(cldlw)
            ennb(j) = ennb(j) + cldlwb
            ettb(j) = ettb(j) + cldlw*cldlwb
            cldlwb = ett(j)*cldlwb
          END IF
        END DO
      END IF
      CALL POPREAL4(cldlw)
    END IF
    cldlwb = 0.0
  END IF
END SUBROUTINE CLDOVLP_B

!  Differentiation of getirtau1 in reverse (adjoint) mode:
!   gradient     of useful results: hydromets tcldlyr fcld enn
!                reff
!   with respect to varying inputs: hydromets tcldlyr fcld enn
!                reff
SUBROUTINE GETIRTAU1_B(ib, nlevs, dp, fcld, fcldb, reff, reffb, &
& hydromets, hydrometsb, taudiag, tcldlyr, tcldlyrb, enn, ennb, aib_ir1&
& , awb_ir1, aiw_ir1, aww_ir1, aig_ir1, awg_ir1, cons_grav)
  IMPLICIT NONE
! !INPUT PARAMETERS:
!  Band number
  INTEGER, INTENT(IN) :: ib
!  Number of levels
  INTEGER, INTENT(IN) :: nlevs
!  Delta pressure in Pa
  REAL, INTENT(IN) :: dp(nlevs)
!  Cloud fraction (used sometimes)
  REAL, INTENT(IN) :: fcld(nlevs)
  REAL :: fcldb(nlevs)
!  Effective radius (microns)
  REAL, INTENT(IN) :: reff(nlevs, 4)
  REAL :: reffb(nlevs, 4)
!  Hydrometeors (kg/kg)
  REAL, INTENT(IN) :: hydromets(nlevs, 4)
  REAL :: hydrometsb(nlevs, 4)
  REAL, INTENT(IN) :: aib_ir1(3, 10), awb_ir1(4, 10), aiw_ir1(4, 10)
  REAL, INTENT(IN) :: aww_ir1(4, 10), aig_ir1(4, 10), awg_ir1(4, 10)
  REAL, INTENT(IN) :: cons_grav
! !OUTPUT PARAMETERS:
!  Optical depth for beam radiation
  REAL, INTENT(OUT) :: taudiag(nlevs, 4)
!  Flux transmissivity?
  REAL :: tcldlyr(0:nlevs)
  REAL :: tcldlyrb(0:nlevs)
!  Flux transmissivity of a cloud layer?
  REAL :: enn(0:nlevs)
  REAL :: ennb(0:nlevs)
! !DESCRIPTION:
!  Compute in-cloud or grid mean optical depths for infrared wavelengths
!  Slots for reff, hydrometeors and tauall are as follows:
!                 1         Cloud Ice
!                 2         Cloud Liquid
!                 3         Falling Liquid (Rain)
!                 4         Falling Ice (Snow)
!
!  In the below calculations, the constants used in the tau calculation are in 
!  m$^2$ g$^{-1}$ and m$^2$ g$^{-1}$ $\mu$m. Thus, we must convert the kg contained in the 
!  pressure (Pa = kg m$^{-1}$ s$^{-2}$) to grams.
!
! !REVISION HISTORY: 
!    2011.11.18   MAT moved to Radiation_Shared and revised arg list, units
!
!EOP
!------------------------------------------------------------------------------
!BOC
  INTEGER :: k
  REAL :: taucld1, taucld2, taucld3, taucld4
  REAL :: taucld1b, taucld2b, taucld3b, taucld4b
  REAL :: g1, g2, g3, g4, gg
  REAL :: g1b, g2b, g3b, g4b, ggb
  REAL :: w1, w2, w3, w4, ww
  REAL :: w1b, w2b, w3b, w4b, wwb
  REAL :: ff, tauc
  REAL :: ffb, taucb
  REAL :: reff_snow
  REAL :: reff_snowb
  INTRINSIC MIN
  INTRINSIC ABS
  INTRINSIC MAX
  INTRINSIC EXP
!-----Compute cloud optical thickness following Eqs. (6.4a,b) and (6.7)
!     Rain optical thickness is set to 0.00307 /(gm/m**2).
!     It is for a specific drop size distribution provided by Q. Fu.
  INTEGER :: branch
  REAL :: temp3
  REAL :: temp2
  REAL :: temp1
  REAL :: temp0
  REAL :: tempb9
  REAL :: tempb8
  REAL :: tempb7
  REAL :: tempb6
  REAL :: tempb5
  REAL :: tempb4
  REAL :: tempb3
  REAL :: tempb2
  REAL :: tempb1
  REAL :: tempb0
  REAL :: tempb12
  REAL :: tempb11
  REAL :: tempb10
  REAL :: temp16
  REAL :: temp15
  REAL :: temp14
  REAL :: temp13
  REAL :: temp12
  REAL :: temp11
  REAL :: temp10
  REAL :: max1b
  REAL :: tempb
  REAL :: abs0
  REAL :: temp
  REAL :: max1
  REAL :: temp9
  REAL :: temp8
  REAL :: temp7
  REAL :: temp6
  REAL :: temp5
  REAL :: temp4
  DO k=1,nlevs
    IF (reff(k, 1) .LE. 0.0) THEN
      CALL PUSHREAL4(taucld1)
      taucld1 = 0.0
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHREAL4(taucld1)
      taucld1 = dp(k)*1.0e3/cons_grav*hydromets(k, 1)*(aib_ir1(1, ib)+&
&       aib_ir1(2, ib)/reff(k, 1)**aib_ir1(3, ib))
      CALL PUSHCONTROL1B(0)
    END IF
    CALL PUSHREAL4(taucld2)
    taucld2 = dp(k)*1.0e3/cons_grav*hydromets(k, 2)*(awb_ir1(1, ib)+(&
&     awb_ir1(2, ib)+(awb_ir1(3, ib)+awb_ir1(4, ib)*reff(k, 2))*reff(k, &
&     2))*reff(k, 2))
    taucld3 = 0.00307*(dp(k)*1.0e3/cons_grav*hydromets(k, 3))
    IF (reff(k, 4) .GT. 112.0) THEN
      CALL PUSHREAL4(reff_snow)
      reff_snow = 112.0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL4(reff_snow)
      reff_snow = reff(k, 4)
      CALL PUSHCONTROL1B(1)
    END IF
    IF (reff_snow .LE. 0.0) THEN
      CALL PUSHREAL4(taucld4)
      taucld4 = 0.0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL4(taucld4)
      taucld4 = dp(k)*1.0e3/cons_grav*hydromets(k, 4)*(aib_ir1(1, ib)+&
&       aib_ir1(2, ib)/reff_snow**aib_ir1(3, ib))
      CALL PUSHCONTROL1B(1)
    END IF
!-----Compute cloud single-scattering albedo and asymmetry factor for
!     a mixture of ice particles and liquid drops following 
!     Eqs. (6.5), (6.6), (6.15) and (6.16).
!     Single-scattering albedo and asymmetry factor of rain are set
!     to 0.54 and 0.95, respectively, based on the information provided
!     by Prof. Qiang Fu.
    CALL PUSHREAL4(tauc)
    tauc = taucld1 + taucld2 + taucld3 + taucld4
    IF (tauc .GT. 0.02 .AND. fcld(k) .GT. 0.01) THEN
      CALL PUSHREAL4(w1)
      w1 = taucld1*(aiw_ir1(1, ib)+(aiw_ir1(2, ib)+(aiw_ir1(3, ib)+&
&       aiw_ir1(4, ib)*reff(k, 1))*reff(k, 1))*reff(k, 1))
      CALL PUSHREAL4(w2)
      w2 = taucld2*(aww_ir1(1, ib)+(aww_ir1(2, ib)+(aww_ir1(3, ib)+&
&       aww_ir1(4, ib)*reff(k, 2))*reff(k, 2))*reff(k, 2))
      w3 = taucld3*0.54
      CALL PUSHREAL4(w4)
      w4 = taucld4*(aiw_ir1(1, ib)+(aiw_ir1(2, ib)+(aiw_ir1(3, ib)+&
&       aiw_ir1(4, ib)*reff_snow)*reff_snow)*reff_snow)
      ww = (w1+w2+w3+w4)/tauc
      CALL PUSHREAL4(g1)
      g1 = w1*(aig_ir1(1, ib)+(aig_ir1(2, ib)+(aig_ir1(3, ib)+aig_ir1(4&
&       , ib)*reff(k, 1))*reff(k, 1))*reff(k, 1))
      CALL PUSHREAL4(g2)
      g2 = w2*(awg_ir1(1, ib)+(awg_ir1(2, ib)+(awg_ir1(3, ib)+awg_ir1(4&
&       , ib)*reff(k, 2))*reff(k, 2))*reff(k, 2))
      g3 = w3*0.95
      CALL PUSHREAL4(g4)
      g4 = w4*(aig_ir1(1, ib)+(aig_ir1(2, ib)+(aig_ir1(3, ib)+aig_ir1(4&
&       , ib)*reff_snow)*reff_snow)*reff_snow)
      IF (w1 + w2 + w3 + w4 .GE. 0.) THEN
        abs0 = w1 + w2 + w3 + w4
      ELSE
        abs0 = -(w1+w2+w3+w4)
      END IF
      IF (abs0 .GT. 0.0) THEN
        CALL PUSHREAL4(gg)
        gg = (g1+g2+g3+g4)/(w1+w2+w3+w4)
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHREAL4(gg)
        gg = 0.5
        CALL PUSHCONTROL1B(0)
      END IF
!-----Parameterization of LW scattering following Eqs. (6.11)
!     and (6.12). 
      ff = 0.5 + (0.3739+(0.0076+0.1185*gg)*gg)*gg
      IF (1. - ww*ff .LT. 0.0) THEN
        CALL PUSHREAL4(max1)
        max1 = 0.0
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHREAL4(max1)
        max1 = 1. - ww*ff
        CALL PUSHCONTROL1B(1)
      END IF
!ALT: temporary protection against negative cloud optical thickness
      CALL PUSHREAL4(tauc)
      tauc = max1*tauc
!-----compute cloud diffuse transmittance. It is approximated by using 
!     a diffusivity factor of 1.66.
      CALL PUSHREAL4(tcldlyr(k))
      tcldlyr(k) = EXP(-(1.66*tauc))
! N in the documentation (6.13)
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
  END DO
  DO k=nlevs,1,-1
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      ennb(k) = 0.0
      tcldlyrb(k) = 0.0
      reff_snowb = 0.0
      taucld1b = 0.0
      taucld2b = 0.0
      taucld3b = 0.0
      taucld4b = 0.0
      taucb = 0.0
    ELSE
      fcldb(k) = fcldb(k) + (1.0-tcldlyr(k))*ennb(k)
      tcldlyrb(k) = tcldlyrb(k) - fcld(k)*ennb(k)
      ennb(k) = 0.0
      CALL POPREAL4(tcldlyr(k))
      taucb = -(EXP(-(1.66*tauc))*1.66*tcldlyrb(k))
      tcldlyrb(k) = 0.0
      CALL POPREAL4(tauc)
      max1b = tauc*taucb
      taucb = max1*taucb
      taucld3 = 0.00307*(dp(k)*1.0e3/cons_grav*hydromets(k, 3))
      w3 = taucld3*0.54
      ww = (w1+w2+w3+w4)/tauc
      ff = 0.5 + (0.3739+(0.0076+0.1185*gg)*gg)*gg
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL4(max1)
        wwb = 0.0
        ffb = 0.0
      ELSE
        CALL POPREAL4(max1)
        wwb = -(ff*max1b)
        ffb = -(ww*max1b)
      END IF
      ggb = ((0.1185*gg+0.0076)*gg+gg*(0.1185*gg+0.0076)+gg**2*0.1185+&
&       0.3739)*ffb
      g3 = w3*0.95
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL4(gg)
        w1b = 0.0
        w2b = 0.0
        w3b = 0.0
        w4b = 0.0
        g1b = 0.0
        g2b = 0.0
        g3b = 0.0
        g4b = 0.0
      ELSE
        CALL POPREAL4(gg)
        tempb11 = ggb/(w1+w2+w3+w4)
        tempb12 = -((g1+g2+g3+g4)*tempb11/(w1+w2+w3+w4))
        g1b = tempb11
        g2b = tempb11
        g3b = tempb11
        g4b = tempb11
        w1b = tempb12
        w2b = tempb12
        w3b = tempb12
        w4b = tempb12
      END IF
      tempb5 = wwb/tauc
      CALL POPREAL4(g4)
      temp16 = aig_ir1(3, ib) + aig_ir1(4, ib)*reff_snow
      temp15 = aig_ir1(2, ib) + temp16*reff_snow
      tempb4 = w4*g4b
      w4b = w4b + tempb5 + (aig_ir1(1, ib)+temp15*reff_snow)*g4b
      w3b = w3b + tempb5 + 0.95*g3b
      CALL POPREAL4(g2)
      temp14 = awg_ir1(3, ib) + awg_ir1(4, ib)*reff(k, 2)
      temp13 = awg_ir1(2, ib) + temp14*reff(k, 2)
      tempb7 = w2*reff(k, 2)*g2b
      w2b = w2b + tempb5 + (awg_ir1(1, ib)+temp13*reff(k, 2))*g2b
      reffb(k, 2) = reffb(k, 2) + w2*temp13*g2b + (temp14+reff(k, 2)*&
&       awg_ir1(4, ib))*tempb7
      CALL POPREAL4(g1)
      temp12 = aig_ir1(3, ib) + aig_ir1(4, ib)*reff(k, 1)
      temp11 = aig_ir1(2, ib) + temp12*reff(k, 1)
      tempb8 = w1*reff(k, 1)*g1b
      w1b = w1b + tempb5 + (aig_ir1(1, ib)+temp11*reff(k, 1))*g1b
      reffb(k, 1) = reffb(k, 1) + w1*temp11*g1b + (temp12+reff(k, 1)*&
&       aig_ir1(4, ib))*tempb8
      taucb = taucb - (w1+w2+w3+w4)*tempb5/tauc
      CALL POPREAL4(w4)
      temp10 = aiw_ir1(3, ib) + aiw_ir1(4, ib)*reff_snow
      temp9 = aiw_ir1(2, ib) + temp10*reff_snow
      tempb6 = taucld4*w4b
      reff_snowb = (temp9+reff_snow*temp10+reff_snow**2*aiw_ir1(4, ib))*&
&       tempb6 + (temp15+reff_snow*temp16+reff_snow**2*aig_ir1(4, ib))*&
&       tempb4
      taucld4b = (aiw_ir1(1, ib)+temp9*reff_snow)*w4b
      taucld3b = 0.54*w3b
      CALL POPREAL4(w2)
      temp8 = aww_ir1(3, ib) + aww_ir1(4, ib)*reff(k, 2)
      temp7 = aww_ir1(2, ib) + temp8*reff(k, 2)
      tempb9 = taucld2*reff(k, 2)*w2b
      taucld2b = (aww_ir1(1, ib)+temp7*reff(k, 2))*w2b
      reffb(k, 2) = reffb(k, 2) + taucld2*temp7*w2b + (temp8+reff(k, 2)*&
&       aww_ir1(4, ib))*tempb9
      CALL POPREAL4(w1)
      temp6 = aiw_ir1(3, ib) + aiw_ir1(4, ib)*reff(k, 1)
      temp5 = aiw_ir1(2, ib) + temp6*reff(k, 1)
      tempb10 = taucld1*reff(k, 1)*w1b
      taucld1b = (aiw_ir1(1, ib)+temp5*reff(k, 1))*w1b
      reffb(k, 1) = reffb(k, 1) + taucld1*temp5*w1b + (temp6+reff(k, 1)*&
&       aiw_ir1(4, ib))*tempb10
    END IF
    CALL POPREAL4(tauc)
    taucld1b = taucld1b + taucb
    taucld2b = taucld2b + taucb
    taucld3b = taucld3b + taucb
    taucld4b = taucld4b + taucb
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL4(taucld4)
    ELSE
      CALL POPREAL4(taucld4)
      temp4 = reff_snow**aib_ir1(3, ib)
      temp3 = aib_ir1(2, ib)/temp4
      tempb3 = dp(k)*1.0e3*taucld4b
      hydrometsb(k, 4) = hydrometsb(k, 4) + (aib_ir1(1, ib)+temp3)*&
&       tempb3/cons_grav
      IF (.NOT.(reff_snow .LE. 0.0 .AND. (aib_ir1(3, ib) .EQ. 0.0 .OR. &
&         aib_ir1(3, ib) .NE. INT(aib_ir1(3, ib))))) reff_snowb = &
&         reff_snowb - temp3*hydromets(k, 4)*aib_ir1(3, ib)*reff_snow**(&
&         aib_ir1(3, ib)-1)*tempb3/(temp4*cons_grav)
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL4(reff_snow)
    ELSE
      CALL POPREAL4(reff_snow)
      reffb(k, 4) = reffb(k, 4) + reff_snowb
    END IF
    hydrometsb(k, 3) = hydrometsb(k, 3) + dp(k)*1.0e3*0.00307*taucld3b/&
&     cons_grav
    CALL POPREAL4(taucld2)
    temp2 = awb_ir1(3, ib) + awb_ir1(4, ib)*reff(k, 2)
    temp1 = awb_ir1(2, ib) + temp2*reff(k, 2)
    tempb0 = dp(k)*1.0e3*taucld2b
    tempb1 = hydromets(k, 2)*tempb0/cons_grav
    tempb2 = reff(k, 2)*tempb1
    hydrometsb(k, 2) = hydrometsb(k, 2) + (awb_ir1(1, ib)+temp1*reff(k, &
&     2))*tempb0/cons_grav
    reffb(k, 2) = reffb(k, 2) + temp1*tempb1 + (temp2+reff(k, 2)*awb_ir1&
&     (4, ib))*tempb2
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL4(taucld1)
      temp0 = reff(k, 1)**aib_ir1(3, ib)
      temp = aib_ir1(2, ib)/temp0
      tempb = dp(k)*1.0e3*taucld1b
      hydrometsb(k, 1) = hydrometsb(k, 1) + (aib_ir1(1, ib)+temp)*tempb/&
&       cons_grav
      IF (.NOT.(reff(k, 1) .LE. 0.0 .AND. (aib_ir1(3, ib) .EQ. 0.0 .OR. &
&         aib_ir1(3, ib) .NE. INT(aib_ir1(3, ib))))) reffb(k, 1) = reffb&
&         (k, 1) - temp*hydromets(k, 1)*aib_ir1(3, ib)*reff(k, 1)**(&
&         aib_ir1(3, ib)-1)*tempb/(temp0*cons_grav)
    ELSE
      CALL POPREAL4(taucld1)
    END IF
  END DO
  ennb(0) = 0.0
  tcldlyrb(0) = 0.0
END SUBROUTINE GETIRTAU1_B

