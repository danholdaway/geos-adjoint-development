!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.9 (r5096) - 24 Feb 2014 16:53
!
!  Differentiation of radiation_driver in forward (tangent) mode:
!   variations   of useful results: ptt
!   with respect to varying inputs: ptt
!   RW status of diff variables: ptt:in-out
SUBROUTINE RADIATION_DRIVER_D(im, jm, lm, runalarm, dt, ut, ptt, pttd, &
& qvt, o3t, cflst, cfcnt, qilst, qllst, qicnt, qlcnt, ps, ts, emis, delt&
& , cosz, slr, rgbuv, rgfuv, rgbir, rgfir, sc, taua_irt, ssaa_irt, &
& asya_irt, taua_sot, ssaa_sot, asya_sot, mapl_p00, mapl_rgas, mapl_cp, &
& mapl_p00, mapl_kappa, mapl_grav, aib_ir, awb_ir, aiw_ir, aww_ir, &
& aig_ir, awg_ir, xkw, xke, mw, aw, bw, pm, fkw, gkw, cb, dcb, w11, w12&
& , w13, p11, p12, p13, dwe, dpe, c1, c2, c3, oo1, oo2, oo3, h11, h12, &
& h13, h21, h22, h23, h81, h82, h83, wk_uv, zk_uv, ry_uv, xk_ir, ry_ir, &
& cah, coa, aig_uv, awg_uv, arg_uv, aib_uv, awb_uv, arb_uv, aib_nir, &
& awb_nir, arb_nir, aia_nir, awa_nir, ara_nir, aig_nir, awg_nir, arg_nir&
& , caib, caif, hk, hk_ir_temp, hk_uv_temp, hk_uv_old, hk_ir_old)
  IMPLICIT NONE
!In
  INTEGER, INTENT(IN) :: im, jm, lm, runalarm
  REAL, INTENT(IN) :: sc, dt
  REAL, DIMENSION(im, jm, lm), INTENT(IN) :: ut, qvt, o3t, cflst, cfcnt&
& , qilst, qllst, qicnt, qlcnt
  REAL, DIMENSION(im, jm), INTENT(IN) :: ps, ts
  REAL, DIMENSION(im, jm), INTENT(IN) :: emis, delt, cosz, slr, rgbuv, &
& rgfuv, rgbir, rgfir
  REAL, DIMENSION(im, jm, lm, 10), INTENT(IN) :: taua_irt, ssaa_irt, &
& asya_irt
  REAL, DIMENSION(im, jm, lm, 8), INTENT(IN) :: taua_sot, ssaa_sot, &
& asya_sot
  REAL, INTENT(IN) :: mapl_p00, mapl_rgas, mapl_cp, mapl_p00, mapl_kappa&
& , mapl_grav
  REAL, INTENT(IN) :: aib_ir(3, 10), awb_ir(4, 10), aiw_ir(4, 10)
  REAL, INTENT(IN) :: aww_ir(4, 10), aig_ir(4, 10), awg_ir(4, 10)
  INTEGER, INTENT(IN) :: mw(9)
  REAL, INTENT(IN) :: xkw(9), xke(9), aw(9), bw(9), pm(9)
  REAL, INTENT(IN) :: fkw(6, 9), gkw(6, 3), cb(6, 10), dcb(5, 10)
  REAL, INTENT(IN) :: w11, w12, w13, p11, p12
  REAL, INTENT(IN) :: p13, dwe, dpe
  REAL, INTENT(IN) :: c1(26, 30), c2(26, 30), c3(26, 30)
  REAL, INTENT(IN) :: oo1(26, 21), oo2(26, 21), oo3(26, 21)
  REAL, INTENT(IN) :: h11(26, 31), h12(26, 31), h13(26, 31)
  REAL, INTENT(IN) :: h21(26, 31), h22(26, 31), h23(26, 31)
  REAL, INTENT(IN) :: h81(26, 31), h82(26, 31), h83(26, 31)
  REAL, INTENT(IN) :: wk_uv(5), zk_uv(5), ry_uv(5)
  REAL, INTENT(IN) :: xk_ir(10), ry_ir(3)
  REAL, INTENT(IN) :: cah(43, 37), coa(62, 101)
  REAL, INTENT(IN) :: aig_uv(3), awg_uv(3), arg_uv(3)
  REAL, INTENT(IN) :: aib_uv, awb_uv(2), arb_uv(2)
  REAL, INTENT(IN) :: aib_nir, awb_nir(3, 2), arb_nir(3, 2)
  REAL, INTENT(IN) :: aia_nir(3, 3), awa_nir(3, 3), ara_nir(3, 3)
  REAL, INTENT(IN) :: aig_nir(3, 3), awg_nir(3, 3), arg_nir(3, 3)
  REAL, INTENT(IN) :: caib(11, 9, 11), caif(9, 11)
  REAL, INTENT(IN) :: hk(8), hk_ir_temp(3, 10), hk_uv_temp(5)
  REAL, INTENT(IN) :: hk_uv_old(5), hk_ir_old(3, 10)
!Inouts
  REAL, DIMENSION(im, jm, lm), INTENT(INOUT) :: ptt
  REAL, DIMENSION(im, jm, lm), INTENT(INOUT) :: pttd
!Locals
  INTEGER :: i, j, k, l
  REAL :: co2
  INTEGER :: levs925, lcldmh, lcldlm
  LOGICAL, PARAMETER :: trace=.true., overcast=.false.
  INTEGER, PARAMETER :: na=0, ns=1
  INTEGER, PARAMETER :: nbchou_ir=10
  INTEGER, PARAMETER :: nbchou_so=8
  REAL, DIMENSION(im, jm, lm) :: ptt1, tt, ple, pleso, plof, pif, deltap&
& , tt_out, dtdt
  REAL, DIMENSION(im, jm, lm) :: ptt1d, ttd, pled, tt_outd, dtdtd
  REAL, DIMENSION(im, jm, lm) :: o3mmt
  REAL, DIMENSION(im, jm, lm) :: n2ot, ch4t, cfc11t, cfc12t, cfc22t
  REAL, DIMENSION(im, jm, lm) :: rad_qlt, rad_qit, rad_cft, rad_rlt, &
& rad_rit
  REAL, DIMENSION(im, jm, lm, 4) :: cwct, refft
  REAL, DIMENSION(im, jm, 1) :: fst, tgt, tvt
  REAL, DIMENSION(im, jm, 1, 10) :: egt, evt, rvt
  REAL, DIMENSION(im, jm, lm) :: flwut, flwdt, flxnt, flwt_int, fswt_int
  REAL, DIMENSION(im, jm, lm) :: flwutd, flwdtd, flwt_intd
  REAL, DIMENSION(im, jm, lm) :: flwavet, fswavet, dfdtst_int
  REAL, DIMENSION(im, jm, lm) :: flwavetd, dfdtst_intd
  REAL, DIMENSION(im, jm) :: t2mt, tempor, cosztmp
  REAL, DIMENSION(0:lm) :: ak, bk, pref
  REAL, DIMENSION(im, jm, lm) :: pwx1
  REAL :: pwy1
  REAL :: pwr1
!Compute pref from ak and bk
  ak = 1.0
  bk = 1.0
  DO l=0,lm
    pref(l) = ak(l+1) + bk(l+1)*mapl_p00
  END DO
!Pressure at the half levels from Ps
  DO l=0,lm
    pled(:, :, l) = 0.0
    ple(:, :, l) = ak(l+1) + bk(l+1)*ps(:, :)
  END DO
  deltap = ple(:, :, 1:lm) - ple(:, :, 0:lm-1)
!Pressure (hPa) and Exner pressure at the full levels
  plof(:, :, 1:lm) = 0.01*0.5*(ple(:, :, 0:lm-1)+ple(:, :, 1:lm))
  pwx1 = plof(:, :, 1:lm)/1000.
  pwy1 = mapl_rgas/mapl_cp
  pif(:, :, 1:lm) = pwx1**pwy1
!Potential temperature with p0=10000
!Place in holder so as not to overwrite
  pwr1 = mapl_p00**mapl_kappa
  ptt1d = pwr1*pttd
  ptt1 = ptt*pwr1
!Temperature
!Save input for later.
  ttd = pif*ptt1d
  tt = ptt1*pif
  IF (runalarm .EQ. 1) THEN
!Initialize the fluxes
    flwut = 0.0
    flwdt = 0.0
    dfdtst_int = 0.0
    dfdtst_intd = 0.0
    flwdtd = 0.0
    flwutd = 0.0
    DO i=1,im
      DO j=1,jm
        CALL IRRAD_D(1, lm, tt, ttd, flwut, flwutd, flwdt, flwdtd, &
&              dfdtst_int, dfdtst_intd)
      END DO
    END DO
    flwt_intd = flwutd + flwdtd
    flwt_int = flwut + flwdt
    flwavetd = 0.0
  ELSE
    dfdtst_intd = 0.0
    flwavetd = 0.0
    flwt_intd = 0.0
  END IF
  DO l=0,lm
    flwavetd(:, :, l) = flwt_intd(:, :, l) + delt*dfdtst_intd(:, :, l)
    flwavet(:, :, l) = flwt_int(:, :, l) + dfdtst_int(:, :, l)*delt
  END DO
!Tangent of fluxes to DTDt (mass-weighted)
  dtdtd = mapl_grav*(flwavetd(:, :, 0:lm-1)-flwavetd(:, :, 1:lm))/&
&   mapl_cp
  dtdt = (flwavet(:, :, 0:lm-1)-flwavet(:, :, 1:lm))*(mapl_grav/mapl_cp)
!Tangent of mass-weighted DTDt to updated temperature
  tt_outd = ttd + dt*dtdtd/deltap
  tt_out = tt + dt*dtdt/deltap
!Tangent of temperature to potential temperature
  ptt1d = tt_outd/pif
  ptt1 = tt_out/pif
!Tangent of potential temperature to P0 = 1
  pwr1 = mapl_p00**mapl_kappa
  pttd = ptt1d/pwr1
  ptt = ptt1/pwr1
END SUBROUTINE RADIATION_DRIVER_D

!  Differentiation of irrad in forward (tangent) mode:
!   variations   of useful results: flxu_dev dfdts_dev flxd_dev
!   with respect to varying inputs: ta_dev
SUBROUTINE IRRAD_D(m, np, ta_dev, ta_devd, flxu_dev, flxu_devd, flxd_dev&
& , flxd_devd, dfdts_dev, dfdts_devd)
  IMPLICIT NONE
!----- INPUTS -----
  INTEGER, INTENT(IN) :: m, np
  REAL, DIMENSION(m, np), INTENT(IN) :: ta_dev
  REAL, DIMENSION(m, np), INTENT(IN) :: ta_devd
  REAL, DIMENSION(m, np + 1), INTENT(OUT) :: flxu_dev
  REAL, DIMENSION(m, np+1), INTENT(OUT) :: flxu_devd
  REAL, DIMENSION(m, np + 1), INTENT(OUT) :: flxd_dev
  REAL, DIMENSION(m, np+1), INTENT(OUT) :: flxd_devd
  REAL, DIMENSION(m, np + 1), INTENT(OUT) :: dfdts_dev
  REAL, DIMENSION(m, np+1), INTENT(OUT) :: dfdts_devd
  INTEGER :: i, j
  flxu_dev = 0.0
  flxd_dev = 0.0
  dfdts_dev = 0.0
  flxu_devd = 0.0
  dfdts_devd = 0.0
  flxd_devd = 0.0
  DO i=1,m
    DO j=1,np
      flxu_devd(i, j) = 1e-6*ta_devd(i, j) + 1e-8*2*ta_dev(i, j)*ta_devd&
&       (i, j)
      flxu_dev(i, j) = ta_dev(i, j)*1e-6 + 1e-8*ta_dev(i, j)**2
      flxd_devd(i, j) = 1e-4*ta_devd(i, j) + 1e-10*3*ta_dev(i, j)**2*&
&       ta_devd(i, j)
      flxd_dev(i, j) = ta_dev(i, j)*1e-4 + 1e-10*ta_dev(i, j)**3
      dfdts_devd(i, j) = 0.5*(flxu_devd(i, j)+flxd_devd(i, j))
      dfdts_dev(i, j) = 0.5*(flxu_dev(i, j)+flxd_dev(i, j))
    END DO
  END DO
END SUBROUTINE IRRAD_D

