!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.9 (r5096) - 24 Feb 2014 16:53
!
!  Differentiation of radiation_driver in reverse (adjoint) mode:
!   gradient     of useful results: ptt
!   with respect to varying inputs: ptt
!   RW status of diff variables: ptt:in-out
SUBROUTINE RADIATION_DRIVER_B(im, jm, lm, runalarm, dt, ut, ptt, pttb, &
& qvt, o3t, cflst, cfcnt, qilst, qllst, qicnt, qlcnt, ps, ts, emis, delt&
& , cosz, slr, rgbuv, rgfuv, rgbir, rgfir, sc, taua_irt, ssaa_irt, &
& asya_irt, taua_sot, ssaa_sot, asya_sot, mapl_p00, mapl_rgas, mapl_cp, &
& mapl_p00, mapl_kappa, mapl_grav, aib_ir, awb_ir, aiw_ir, aww_ir, &
& aig_ir, awg_ir, xkw, xke, mw, aw, bw, pm, fkw, gkw, cb, dcb, w11, w12&
& , w13, p11, p12, p13, dwe, dpe, c1, c2, c3, oo1, oo2, oo3, h11, h12, &
& h13, h21, h22, h23, h81, h82, h83, wk_uv, zk_uv, ry_uv, xk_ir, ry_ir, &
& cah, coa, aig_uv, awg_uv, arg_uv, aib_uv, awb_uv, arb_uv, aib_nir, &
& awb_nir, arb_nir, aia_nir, awa_nir, ara_nir, aig_nir, awg_nir, arg_nir&
& , caib, caif, hk, hk_ir_temp, hk_uv_temp, hk_uv_old, hk_ir_old)
  IMPLICIT NONE
!In
  INTEGER, INTENT(IN) :: im, jm, lm, runalarm
  REAL, INTENT(IN) :: sc, dt
  REAL, DIMENSION(im, jm, lm), INTENT(IN) :: ut, qvt, o3t, cflst, cfcnt&
& , qilst, qllst, qicnt, qlcnt
  REAL, DIMENSION(im, jm), INTENT(IN) :: ps, ts
  REAL, DIMENSION(im, jm), INTENT(IN) :: emis, delt, cosz, slr, rgbuv, &
& rgfuv, rgbir, rgfir
  REAL, DIMENSION(im, jm, lm, 10), INTENT(IN) :: taua_irt, ssaa_irt, &
& asya_irt
  REAL, DIMENSION(im, jm, lm, 8), INTENT(IN) :: taua_sot, ssaa_sot, &
& asya_sot
  REAL, INTENT(IN) :: mapl_p00, mapl_rgas, mapl_cp, mapl_p00, mapl_kappa&
& , mapl_grav
  REAL, INTENT(IN) :: aib_ir(3, 10), awb_ir(4, 10), aiw_ir(4, 10)
  REAL, INTENT(IN) :: aww_ir(4, 10), aig_ir(4, 10), awg_ir(4, 10)
  INTEGER, INTENT(IN) :: mw(9)
  REAL, INTENT(IN) :: xkw(9), xke(9), aw(9), bw(9), pm(9)
  REAL, INTENT(IN) :: fkw(6, 9), gkw(6, 3), cb(6, 10), dcb(5, 10)
  REAL, INTENT(IN) :: w11, w12, w13, p11, p12
  REAL, INTENT(IN) :: p13, dwe, dpe
  REAL, INTENT(IN) :: c1(26, 30), c2(26, 30), c3(26, 30)
  REAL, INTENT(IN) :: oo1(26, 21), oo2(26, 21), oo3(26, 21)
  REAL, INTENT(IN) :: h11(26, 31), h12(26, 31), h13(26, 31)
  REAL, INTENT(IN) :: h21(26, 31), h22(26, 31), h23(26, 31)
  REAL, INTENT(IN) :: h81(26, 31), h82(26, 31), h83(26, 31)
  REAL, INTENT(IN) :: wk_uv(5), zk_uv(5), ry_uv(5)
  REAL, INTENT(IN) :: xk_ir(10), ry_ir(3)
  REAL, INTENT(IN) :: cah(43, 37), coa(62, 101)
  REAL, INTENT(IN) :: aig_uv(3), awg_uv(3), arg_uv(3)
  REAL, INTENT(IN) :: aib_uv, awb_uv(2), arb_uv(2)
  REAL, INTENT(IN) :: aib_nir, awb_nir(3, 2), arb_nir(3, 2)
  REAL, INTENT(IN) :: aia_nir(3, 3), awa_nir(3, 3), ara_nir(3, 3)
  REAL, INTENT(IN) :: aig_nir(3, 3), awg_nir(3, 3), arg_nir(3, 3)
  REAL, INTENT(IN) :: caib(11, 9, 11), caif(9, 11)
  REAL, INTENT(IN) :: hk(8), hk_ir_temp(3, 10), hk_uv_temp(5)
  REAL, INTENT(IN) :: hk_uv_old(5), hk_ir_old(3, 10)
!Inouts
  REAL, DIMENSION(im, jm, lm), INTENT(INOUT) :: ptt
  REAL, DIMENSION(im, jm, lm), INTENT(INOUT) :: pttb
!Locals
  INTEGER :: i, j, k, l
  REAL :: co2
  INTEGER :: levs925, lcldmh, lcldlm
  LOGICAL, PARAMETER :: trace=.true., overcast=.false.
  INTEGER, PARAMETER :: na=0, ns=1
  INTEGER, PARAMETER :: nbchou_ir=10
  INTEGER, PARAMETER :: nbchou_so=8
  REAL, DIMENSION(im, jm, lm) :: ptt1, tt, ple, pleso, plof, pif, deltap&
& , tt_out, dtdt
  REAL, DIMENSION(im, jm, lm) :: ptt1b, ttb, tt_outb, dtdtb
  REAL, DIMENSION(im, jm, lm) :: o3mmt
  REAL, DIMENSION(im, jm, lm) :: n2ot, ch4t, cfc11t, cfc12t, cfc22t
  REAL, DIMENSION(im, jm, lm) :: rad_qlt, rad_qit, rad_cft, rad_rlt, &
& rad_rit
  REAL, DIMENSION(im, jm, lm, 4) :: cwct, refft
  REAL, DIMENSION(im, jm, 1) :: fst, tgt, tvt
  REAL, DIMENSION(im, jm, 1, 10) :: egt, evt, rvt
  REAL, DIMENSION(im, jm, lm) :: flwut, flwdt, flxnt, flwt_int, fswt_int
  REAL, DIMENSION(im, jm, lm) :: flwutb, flwdtb, flwt_intb
  REAL, DIMENSION(im, jm, lm) :: flwavet, fswavet, dfdtst_int
  REAL, DIMENSION(im, jm, lm) :: flwavetb, dfdtst_intb
  REAL, DIMENSION(im, jm) :: t2mt, tempor, cosztmp
  REAL, DIMENSION(0:lm) :: ak, bk, pref
  INTEGER :: branch
  REAL :: tempb(im, jm, lm)
!Compute pref from ak and bk
  ak = 1.0
  bk = 1.0
!Pressure at the half levels from Ps
  DO l=0,lm
    ple(:, :, l) = ak(l+1) + bk(l+1)*ps(:, :)
  END DO
  deltap = ple(:, :, 1:lm) - ple(:, :, 0:lm-1)
!Pressure (hPa) and Exner pressure at the full levels
  plof(:, :, 1:lm) = 0.01*0.5*(ple(:, :, 0:lm-1)+ple(:, :, 1:lm))
  pif(:, :, 1:lm) = (plof(:, :, 1:lm)/1000.)**(mapl_rgas/mapl_cp)
!Potential temperature with p0=10000
!Place in holder so as not to overwrite
  ptt1 = ptt*mapl_p00**mapl_kappa
!Temperature
!Save input for later.
  tt = ptt1*pif
  IF (runalarm .EQ. 1) THEN
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  ptt1b = 0.0
  ptt1b = pttb/mapl_p00**mapl_kappa
  tt_outb = 0.0
  tt_outb = ptt1b/pif
  ttb = 0.0
  dtdtb = 0.0
  ttb = tt_outb
  dtdtb = dt*tt_outb/deltap
  flwavetb = 0.0
  tempb = mapl_grav*dtdtb/mapl_cp
  flwavetb(:, :, 0:lm-1) = flwavetb(:, :, 0:lm-1) + tempb
  flwavetb(:, :, 1:lm) = -tempb
  dfdtst_intb = 0.0
  flwt_intb = 0.0
  DO l=lm,0,-1
    flwt_intb(:, :, l) = flwt_intb(:, :, l) + flwavetb(:, :, l)
    dfdtst_intb(:, :, l) = dfdtst_intb(:, :, l) + delt*flwavetb(:, :, l)
    flwavetb(:, :, l) = 0.0
  END DO
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) THEN
    flwdtb = 0.0
    flwutb = 0.0
    flwutb = flwt_intb
    flwdtb = flwt_intb
    DO i=im,1,-1
      DO j=jm,1,-1
        CALL IRRAD_B(1, lm, tt, ttb, flwut, flwutb, flwdt, flwdtb, &
&              dfdtst_int, dfdtst_intb)
        dfdtst_intb = 0.0
        flwdtb = 0.0
        flwutb = 0.0
      END DO
    END DO
  END IF
  ptt1b = 0.0
  ptt1b = pif*ttb
  pttb = 0.0
  pttb = mapl_p00**mapl_kappa*ptt1b
END SUBROUTINE RADIATION_DRIVER_B

!  Differentiation of irrad in reverse (adjoint) mode:
!   gradient     of useful results: flxu_dev ta_dev dfdts_dev flxd_dev
!   with respect to varying inputs: ta_dev
SUBROUTINE IRRAD_B(m, np, ta_dev, ta_devb, flxu_dev, flxu_devb, flxd_dev&
& , flxd_devb, dfdts_dev, dfdts_devb)
  IMPLICIT NONE
!----- INPUTS -----
  INTEGER, INTENT(IN) :: m, np
  REAL, DIMENSION(m, np), INTENT(IN) :: ta_dev
  REAL, DIMENSION(m, np) :: ta_devb
  REAL, DIMENSION(m, np + 1) :: flxu_dev
  REAL, DIMENSION(m, np+1) :: flxu_devb
  REAL, DIMENSION(m, np + 1) :: flxd_dev
  REAL, DIMENSION(m, np+1) :: flxd_devb
  REAL, DIMENSION(m, np + 1) :: dfdts_dev
  REAL, DIMENSION(m, np+1) :: dfdts_devb
  INTEGER :: i, j
  DO i=m,1,-1
    DO j=np,1,-1
      flxu_devb(i, j) = flxu_devb(i, j) + 0.5*dfdts_devb(i, j)
      flxd_devb(i, j) = flxd_devb(i, j) + 0.5*dfdts_devb(i, j)
      dfdts_devb(i, j) = 0.0
      ta_devb(i, j) = ta_devb(i, j) + (1e-8*2*ta_dev(i, j)+1e-6)*&
&       flxu_devb(i, j) + (1e-10*3*ta_dev(i, j)**2+1e-4)*flxd_devb(i, j)
      flxd_devb(i, j) = 0.0
      flxu_devb(i, j) = 0.0
    END DO
  END DO
END SUBROUTINE IRRAD_B

