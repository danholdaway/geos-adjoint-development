!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
! Module: ConvectionMod --- mimic the convective scavenging algorithm from the
!                                 offline GOCART CTM
MODULE CONVECTIONMOD_B
  IMPLICIT NONE
! USES
!  use Chem_Mod
!  use m_die
! PUBLIC
! Description
! TC is tracer mixing ratio (Mass Mixing Ratio)
! Note that I change the sense of this so that rather than calling all aerosols
! at once (as in offline CTM) I call separately from each component (DU, SS, etc.)
! Assumption is that H2O2 passed in is in units of mass mixing ratio
! Parameters
! conversion rate of cloud condensate to precipation [s-1]
  REAL*8, PARAMETER :: kc=5.0e-3
  LOGICAL, PARAMETER :: lsadirect=.false.

CONTAINS
  SUBROUTINE ZFLIP(varin, varout, km)
    IMPLICIT NONE
! reorder a variable in the vertical
    REAL*8, DIMENSION(:, :, :) :: varin, varout
    INTEGER*4 :: km, k
    DO k=1,km
      varout(:, :, k) = varin(:, :, km-k+1)
    END DO
  END SUBROUTINE ZFLIP
!  Differentiation of convection in reverse (adjoint) mode:
!   gradient     of useful results: bcnv tc
!   with respect to varying inputs: bcnv tc
!   RW status of diff variables: h2o2:(loc) bcnv:in-out tc:in-out
! ----------------------------------------------------------------------------------
! OMIT sulfate stuff for now
  SUBROUTINE CONVECTION_ADM(i1, i2, j1, j2, km, n1, n2, dt_30m, &
&   aero_type, kin, tc, tc_ad, cldmas, dtrain, area, delz, delp, vud, &
&   airmass, airmol, tmpu, ple, bcnv, bcnv_ad, h2o2, h2o2_ad)
    IMPLICIT NONE
!  tcnv(:,:,:) = tcnv(:,:,:) + bcnv(:,:,:)
    INTEGER, INTENT(IN) :: i1, i2, j1, j2, km, n1, n2, dt_30m
    CHARACTER(len=*) :: aero_type
    REAL*8, INTENT(INOUT) :: tc(i1:i2, j1:j2, km, n1:n2)
    REAL*8, INTENT(INOUT) :: tc_ad(i1:i2, j1:j2, km, n1:n2)
!  REAL*8,    INTENT(INOUT) :: cldscv(i1:i2,j1:j2,km,n1:n2), cldso2(i1:i2,j1:j2,km)
!  REAL*8,    INTENT(INOUT) :: cldso4(i1:i2,j1:j2,km), cldmsa(i1:i2,j1:j2,km)
    REAL*8 :: cldscv(i1:i2, j1:j2, km, n1:n2), cldso2(i1:i2, j1:j2, km)
    REAL*8 :: cldso4(i1:i2, j1:j2, km), cldmsa(i1:i2, j1:j2, km)
!  REAL*8,    INTENT(INOUT) :: tcnv(i1:i2,j1:j2,n1:n2)
!  REAL*8,    INTENT(INOUT) :: wet_conv_in(i1:i2,j1:j2,km,n1:n2)
    REAL*8, INTENT(INOUT) :: airmass(i1:i2, j1:j2, km)
    REAL*8, DIMENSION(i1:i2, j1:j2, km), INTENT(IN) :: vud
    REAL*8, DIMENSION(i1:i2, j1:j2, km+1), INTENT(IN) :: cldmas
    REAL*8, DIMENSION(i1:i2, j1:j2, km), INTENT(IN) :: dtrain
    REAL*8, DIMENSION(i1:i2, j1:j2), INTENT(IN) :: area
    REAL*8, DIMENSION(i1:i2, j1:j2, km), INTENT(IN) :: delz, delp
    REAL*8, DIMENSION(i1:i2, j1:j2, km), INTENT(IN) :: airmol
    REAL*8, DIMENSION(i1:i2, j1:j2, km), INTENT(IN) :: tmpu
    REAL*8, DIMENSION(i1:i2, j1:j2, km+1), INTENT(IN) :: ple
    REAL*8 :: bcnv(i1:i2, j1:j2, n1:n2)
    REAL*8 :: bcnv_ad(i1:i2, j1:j2, n1:n2)
    REAL*8, INTENT(INOUT), OPTIONAL :: h2o2(i1:i2, j1:j2, km)
    REAL*8, INTENT(INOUT), OPTIONAL :: h2o2_ad(i1:i2, j1:j2, km)
! true for aerosol
    LOGICAL, INTENT(INOUT) :: kin
    REAL*8 :: tc1(i1:i2, j1:j2, km, n1:n2), f(i1:i2, j1:j2, km, n1:n2)
    REAL*8 :: tc1_ad(i1:i2, j1:j2, km, n1:n2), f_ad(i1:i2, j1:j2, km, n1&
&   :n2)
    REAL*8 :: cldmas_tmp(i1:i2, j1:j2, km), so2loss
    REAL*8 :: so2loss_ad
! epsilon: A very small positive number   [unitless]
    REAL*8, PARAMETER :: epsilon=1.0e-32
! universal gas constant [L*atm/moles/K]
    REAL*8, PARAMETER :: r=8.2057d-2
    REAL*8, PARAMETER :: inv_t0=1d0/298d0
! 0.6*SQRT(0.9) for ice to gas ratio
    REAL*8, PARAMETER :: conv_nh3=5.69209978831d-1
    REAL*8 :: kg, kstar298, h298_r, i2g, l2g, c_tot, f_l, f_i
    INTEGER :: n, i, j, l, nso2, nso4, nmsa
    REAL*8, DIMENSION(i1:i2, j1:j2, km) :: c_h2o
    REAL*8, DIMENSION(i1:i2, j1:j2, km) :: cldliq
    REAL*8, DIMENSION(i1:i2, j1:j2, km) :: cldice
    INTRINSIC TRIM
    INTRINSIC EXP
    INTRINSIC MIN
    INTRINSIC MAX
    LOGICAL, DIMENSION(i1:i2, j1:j2, km) :: mask
    LOGICAL, DIMENSION(i1:i2, j1:j2, km) :: mask0
    LOGICAL, DIMENSION(i1:i2, j1:j2, km) :: mask1
    LOGICAL, DIMENSION(i1:i2, j1:j2, km) :: mask2
    LOGICAL, DIMENSION(i1:i2, j1:j2, km) :: mask3
    REAL*8 :: temp
    REAL*8 :: temp0
    REAL*8 :: temp_ad
    REAL*8 :: temp_ad0
    REAL*8 :: temp_ad1
    REAL*8 :: temp_ad2
    INTEGER :: branch
!  Initialize local variables
!  --------------------------
!  c_h2o, cldliq, and cldice are respectively intended to be the
!  water mixing ratio (liquid or vapor?, in or out of cloud?)
!  cloud liquid water mixing ratio
!  cloud ice water mixing ratio
    c_h2o = 10d0**(-(2663.5d0/tmpu(:, :, :))+12.537d0)/(ple(:, :, 1:km)+&
&     ple(:, :, 2:km+1))/2d0
    cldliq = 0.d0
    mask = tmpu .GT. 248.
    WHERE (mask) cldliq = 1.d-6*((tmpu-248.d0)/20.d0)
    mask0 = tmpu .GE. 268.
    WHERE (mask0) cldliq = 1.d-6
    cldice = 1.d-6 - cldliq
! executable statements
    tc1(:, :, :, :) = tc(:, :, :, :)
!if (MAPL_AM_I_ROOT()) print *, 'hbian convection tmpu =', tmpu(i1,j1,1), tmpu(i1,j1,km)
! compute the fraction of tracer scavenged in convective cloud updrafts
    f = 0.0
    DO n=n1,n2
! treat NH3 as a gas tracer
      IF (TRIM(aero_type) .EQ. 'nitrate' .AND. n .EQ. n1) kin = .false.
! treat others as aerosol
      IF (TRIM(aero_type) .EQ. 'nitrate' .AND. n .GT. n1) kin = .true.
      IF (kin) THEN
        CALL PUSHREAL8ARRAY(f(:, :, :, n), (i2-i1+1)*(j2-j1+1)*km)
        CALL F_AEROSOL(i1, i2, j1, j2, km, kc, f(:, :, :, n), delz, vud)
        CALL PUSHCONTROL1B(0)
      ELSE
! gas tracer NH3
        IF (TRIM(aero_type) .EQ. 'nitrate' .AND. n .EQ. n1) THEN
! values adopted in Umich/IMPACT and GMI, effective Herry's law coefficient at pH = 5
          kstar298 = 1.05d6
          h298_r = -4.2d3
        END IF
        DO l=2,km
          DO j=j1,j2
            DO i=i1,i2
! ice to gas ratio
              IF (c_h2o(i, j, l) .GT. 0.d0) THEN
                i2g = cldice(i, j, l)/c_h2o(i, j, l)*conv_nh3
              ELSE
                i2g = 0.d0
              END IF
              l2g = cldliq(i, j, l)*r*tmpu(i, j, l)*kstar298*EXP(-(&
&               h298_r*(1d0/tmpu(i, j, l)-inv_t0)))
! fraction of NH3 in liquid & ice phases
              c_tot = 1d0 + l2g + i2g
              f_l = l2g/c_tot
              f_i = i2g/c_tot
! compute kg, the retention factor for liquid NH3 is 0 at T < 248K and
! 0.05 at 248K < T < 268K
              IF (tmpu(i, j, l) .GE. 268d0) THEN
                CALL PUSHCONTROL1B(0)
                kg = kc*(f_l+f_i)
              ELSE IF (248d0 .LT. tmpu(i, j, l) .AND. tmpu(i, j, l) .LT.&
&                 268d0) THEN
                CALL PUSHCONTROL1B(1)
                kg = kc*(0.05*f_l+f_i)
              ELSE
                CALL PUSHCONTROL1B(1)
                kg = kc*f_i
              END IF
              IF (kg .GT. 0.d0 .AND. vud(i, j, l) .GT. 1.e-14) THEN
                CALL PUSHREAL8(f(i, j, l, n))
                f(i, j, l, n) = 1.0 - EXP(-(kg*delz(i, j, l)/vud(i, j, l&
&                 )))
                CALL PUSHCONTROL1B(1)
              ELSE
                CALL PUSHCONTROL1B(0)
              END IF
            END DO
          END DO
        END DO
        CALL PUSHCONTROL1B(1)
      END IF
! sulfur
!    Special treatment for DMS and SO2 if aero_type is "sulfur"
      IF (TRIM(aero_type) .EQ. 'sulfur') THEN
!        if(.not.present(h2o2)) call die ('GOCARTConvectionMod.F90', &
!                                         'missing required H2O2 for sulfur')
! DMS
        IF (n .EQ. n1) THEN
          CALL PUSHREAL8ARRAY(f(:, :, :, n1), (i2-i1+1)*(j2-j1+1)*km)
          f(:, :, :, n1) = 0.0
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
! SO2
!if(n .eq. n1+1)  f(:,:,:,n1+1) = 0.0  ! SO2 for now is not scavenged
!#ifdef PRC
        IF (n .EQ. n1 + 1) THEN
! SO2 requires special handling
!==============================================================
! Coupled full chemistry/aerosol simulation:
! Use the wet scavenging formula of Chin et al [1996],
! such that a soluble fraction of SO2 is limited by the
! availability of H2O2 in the precipitating grid box.
! Scavenge the soluble SO2 at the same rate as the sulfate.
! Update H2O2_sav and SO2_sav for use in RAINOUT, WASHOUT
!==============================================================
          DO l=2,km
            DO j=j1,j2
              DO i=i1,i2
! Make sure to deplete H2O2s the same as SO2s.
! (dkh, rjp, bmy, 11/17/05)
! based on GEOS-Chem. tq, 01/09
                IF (tc1(i, j, l, n) .GT. epsilon) THEN
                  IF (h2o2(i, j, l) .GT. tc1(i, j, l, n)) THEN
                    CALL PUSHREAL8(so2loss)
                    so2loss = tc1(i, j, l, n)
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    CALL PUSHREAL8(so2loss)
                    so2loss = h2o2(i, j, l)
                    CALL PUSHCONTROL1B(1)
                  END IF
                  CALL PUSHREAL8(f(i, j, l, n))
                  f(i, j, l, n) = f(i, j, l, n)*so2loss/tc1(i, j, l, n)
                  IF (f(i, j, l, n) .LT. 0.0) THEN
                    f(i, j, l, n) = 0.0
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    CALL PUSHCONTROL1B(1)
                    f(i, j, l, n) = f(i, j, l, n)
                  END IF
! update saved h2o2 concentration
                  h2o2(i, j, l) = h2o2(i, j, l) - tc1(i, j, l, n)*f(i, j&
&                   , l, n)
                  IF (h2o2(i, j, l) .LT. epsilon) THEN
                    h2o2(i, j, l) = epsilon
                    CALL PUSHCONTROL2B(1)
                  ELSE
                    CALL PUSHCONTROL2B(2)
                    h2o2(i, j, l) = h2o2(i, j, l)
                  END IF
                ELSE
! set f = 0 if so2 < epsilon (dkh, rjp, bmy, 11/17/05)
                  CALL PUSHREAL8(f(i, j, l, n))
                  f(i, j, l, n) = 0.d0
                  CALL PUSHCONTROL2B(0)
                END IF
              END DO
            END DO
          END DO
          CALL PUSHCONTROL2B(2)
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
    END DO
!#endif
! n
! if tracer is type "carbon" then set coefficient to 0 for hydrophobic
! implementing QQ Wang's change by Huisheng Bian (4/24/2015)
! not scavenging  BCn1 (hydrophobic) when T > 258 K
    IF (TRIM(aero_type) .EQ. 'OC') THEN
      CALL PUSHREAL8ARRAY(f(:, :, :, n1), (i2-i1+1)*(j2-j1+1)*km)
      f(:, :, :, n1) = 0d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! suppress scavenging most aerosols at cold T except BCn1 (hydrophobic), dust, and HNO3
    IF (TRIM(aero_type) .EQ. 'BC') THEN
      mask1 = tmpu .GE. 258.d0
      CALL PUSHREAL8ARRAY(f(:, :, :, n1), (i2-i1+1)*(j2-j1+1)*km)
      WHERE (mask1) f(:, :, :, n1) = 0.d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (TRIM(aero_type) .EQ. 'BC') THEN
      mask2 = tmpu .LT. 258.d0
      CALL PUSHREAL8ARRAY(f(:, :, :, n2), (i2-i1+1)*(j2-j1+1)*km)
      WHERE (mask2) f(:, :, :, n2) = 0.d0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (((((((TRIM(aero_type) .EQ. 'OC' .OR. TRIM(aero_type) .EQ. &
&       'sea_salt') .OR. TRIM(aero_type) .EQ. 'sulfur') .OR. TRIM(&
&       aero_type) .EQ. 'seasalt') .OR. TRIM(aero_type) .EQ. 'sulfate') &
&       .OR. TRIM(aero_type) .EQ. 'nitrate') .OR. TRIM(aero_type) .EQ. &
&       'NH3') .OR. TRIM(aero_type) .EQ. 'NH4a') THEN
      DO n=n1,n2
        mask3 = tmpu .LT. 258.d0
        CALL PUSHREAL8ARRAY(f(:, :, :, n), (i2-i1+1)*(j2-j1+1)*km)
        WHERE (mask3) f(:, :, :, n) = 0.d0
      END DO
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! re-index for routine cldcnv
    cldmas_tmp(:, :, 1:km) = cldmas(:, :, 2:km+1)
! internal time step for the convection routine is 300s
    CALL PUSHREAL8ARRAY(tc, (i2-i1+1)*(j2-j1+1)*km*(n2-n1+1))
    CALL CLDCNV(i1, i2, j1, j2, km, n1, n2, dt_30m, aero_type, tc, f, &
&         airmass, area, cldmas_tmp, dtrain, delz, delp)
! -- Mass balance
    SELECT CASE  (TRIM(aero_type)) 
    CASE ('sulfur') 
      DO n=n1,n2
        DO i=i1,i2
          DO j=j1,j2
            DO l=1,km
              IF (tc(i, j, l, n) .LT. 0.0) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
            END DO
          END DO
        END DO
      END DO
      tc1_ad = 0.0_8
      DO n=n2,n1,-1
        DO i=i2,i1,-1
          DO j=j2,j1,-1
            DO l=km,1,-1
              temp_ad0 = airmass(i, j, l)*bcnv_ad(i, j, n)
              tc_ad(i, j, l, n) = tc_ad(i, j, l, n) + temp_ad0
              tc1_ad(i, j, l, n) = tc1_ad(i, j, l, n) - temp_ad0
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) tc_ad(i, j, l, n) = 0.0_8
            END DO
            bcnv_ad(i, j, n) = 0.0_8
          END DO
        END DO
      END DO
    CASE ('co') 
      DO n=n1,n2
        DO i=i1,i2
          DO j=j1,j2
            DO l=1,km
              IF (tc(i, j, l, n) .LT. 0.0) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
            END DO
          END DO
        END DO
      END DO
      tc1_ad = 0.0_8
      DO n=n2,n1,-1
        DO i=i2,i1,-1
          DO j=j2,j1,-1
            DO l=km,1,-1
              temp_ad1 = airmol(i, j, l)*bcnv_ad(i, j, n)
              tc_ad(i, j, l, n) = tc_ad(i, j, l, n) + temp_ad1
              tc1_ad(i, j, l, n) = tc1_ad(i, j, l, n) - temp_ad1
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) tc_ad(i, j, l, n) = 0.0_8
            END DO
          END DO
        END DO
      END DO
      bcnv_ad = 0.0_8
    CASE DEFAULT
!!$     DO n = n1, n2
!!$        DO l = 1,km
!!$           DO j = j1, j2
!!$              DO i = i1, i2
!!$                 wet_conv_in(i,j,l,n) = wet_conv_in(i,j,l,n) + &
!!$                      (tc(i,j,l,n) - tc1(i,j,l,n)) * airmass(i,j,l)
!!$              END DO
!!$           END DO
!!$        END DO
!!$     END DO
      DO n=n1,n2
        DO i=i1,i2
          DO j=j1,j2
            DO l=1,km
              IF (tc(i, j, l, n) .LT. 0.0) THEN
                CALL PUSHCONTROL1B(0)
              ELSE
                CALL PUSHCONTROL1B(1)
              END IF
            END DO
          END DO
        END DO
      END DO
      tc1_ad = 0.0_8
      DO n=n2,n1,-1
        DO i=i2,i1,-1
          DO j=j2,j1,-1
            DO l=km,1,-1
              temp_ad2 = airmass(i, j, l)*bcnv_ad(i, j, n)
              tc_ad(i, j, l, n) = tc_ad(i, j, l, n) + temp_ad2
              tc1_ad(i, j, l, n) = tc1_ad(i, j, l, n) - temp_ad2
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) tc_ad(i, j, l, n) = 0.0_8
            END DO
            bcnv_ad(i, j, n) = 0.0_8
          END DO
        END DO
      END DO
    END SELECT
    CALL POPREAL8ARRAY(tc, (i2-i1+1)*(j2-j1+1)*km*(n2-n1+1))
    CALL CLDCNV_ADM(i1, i2, j1, j2, km, n1, n2, dt_30m, aero_type, tc, &
&             tc_ad, f, f_ad, airmass, area, cldmas_tmp, dtrain, delz, &
&             delp)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO n=n2,n1,-1
        mask3 = tmpu .LT. 258.d0
        CALL POPREAL8ARRAY(f(:, :, :, n), (i2-i1+1)*(j2-j1+1)*km)
        WHERE (mask3) f_ad(:, :, :, n) = 0.0_8
      END DO
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8ARRAY(f(:, :, :, n2), (i2-i1+1)*(j2-j1+1)*km)
      WHERE (mask2) f_ad(:, :, :, n2) = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8ARRAY(f(:, :, :, n1), (i2-i1+1)*(j2-j1+1)*km)
      WHERE (mask1) f_ad(:, :, :, n1) = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8ARRAY(f(:, :, :, n1), (i2-i1+1)*(j2-j1+1)*km)
      f_ad(:, :, :, n1) = 0.0_8
    END IF
    h2o2_ad = 0.0_8
    DO n=n2,n1,-1
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .NE. 1) THEN
          DO l=km,2,-1
            DO j=j2,j1,-1
              DO 100 i=i2,i1,-1
                CALL POPCONTROL2B(branch)
                IF (branch .LT. 2) THEN
                  IF (branch .EQ. 0) THEN
                    CALL POPREAL8(f(i, j, l, n))
                    f_ad(i, j, l, n) = 0.0_8
                    GOTO 100
                  ELSE
                    h2o2_ad(i, j, l) = 0.0_8
                  END IF
                END IF
                tc1_ad(i, j, l, n) = tc1_ad(i, j, l, n) - f(i, j, l, n)*&
&                 h2o2_ad(i, j, l)
                f_ad(i, j, l, n) = f_ad(i, j, l, n) - tc1(i, j, l, n)*&
&                 h2o2_ad(i, j, l)
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) f_ad(i, j, l, n) = 0.0_8
                CALL POPREAL8(f(i, j, l, n))
                temp0 = tc1(i, j, l, n)
                temp_ad = f_ad(i, j, l, n)/temp0
                temp = f(i, j, l, n)
                so2loss_ad = temp*temp_ad
                tc1_ad(i, j, l, n) = tc1_ad(i, j, l, n) - temp*so2loss*&
&                 temp_ad/temp0
                f_ad(i, j, l, n) = so2loss*temp_ad
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  CALL POPREAL8(so2loss)
                  tc1_ad(i, j, l, n) = tc1_ad(i, j, l, n) + so2loss_ad
                ELSE
                  CALL POPREAL8(so2loss)
                  h2o2_ad(i, j, l) = h2o2_ad(i, j, l) + so2loss_ad
                END IF
 100          CONTINUE
            END DO
          END DO
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8ARRAY(f(:, :, :, n1), (i2-i1+1)*(j2-j1+1)*km)
          f_ad(:, :, :, n1) = 0.0_8
        END IF
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8ARRAY(f(:, :, :, n), (i2-i1+1)*(j2-j1+1)*km)
        CALL F_AEROSOL_ADM(i1, i2, j1, j2, km, kc, f(:, :, :, n), f_ad(:&
&                    , :, :, n), delz, vud)
      ELSE
        DO l=km,2,-1
          DO j=j2,j1,-1
            DO i=i2,i1,-1
              CALL POPCONTROL1B(branch)
              IF (branch .NE. 0) THEN
                CALL POPREAL8(f(i, j, l, n))
                f_ad(i, j, l, n) = 0.0_8
              END IF
              CALL POPCONTROL1B(branch)
            END DO
          END DO
        END DO
      END IF
    END DO
    tc_ad = tc_ad + tc1_ad
  END SUBROUTINE CONVECTION_ADM
! ----------------------------------------------------------------------------------
! OMIT sulfate stuff for now
  SUBROUTINE CONVECTION(i1, i2, j1, j2, km, n1, n2, dt_30m, aero_type, &
&   kin, tc, cldmas, dtrain, area, delz, delp, vud, airmass, airmol, &
&   tmpu, ple, bcnv, h2o2)
    IMPLICIT NONE
!  tcnv(:,:,:) = tcnv(:,:,:) + bcnv(:,:,:)
    INTEGER, INTENT(IN) :: i1, i2, j1, j2, km, n1, n2, dt_30m
    CHARACTER(len=*) :: aero_type
    REAL*8, INTENT(INOUT) :: tc(i1:i2, j1:j2, km, n1:n2)
!  REAL*8,    INTENT(INOUT) :: cldscv(i1:i2,j1:j2,km,n1:n2), cldso2(i1:i2,j1:j2,km)
!  REAL*8,    INTENT(INOUT) :: cldso4(i1:i2,j1:j2,km), cldmsa(i1:i2,j1:j2,km)
    REAL*8 :: cldscv(i1:i2, j1:j2, km, n1:n2), cldso2(i1:i2, j1:j2, km)
    REAL*8 :: cldso4(i1:i2, j1:j2, km), cldmsa(i1:i2, j1:j2, km)
!  REAL*8,    INTENT(INOUT) :: tcnv(i1:i2,j1:j2,n1:n2)
!  REAL*8,    INTENT(INOUT) :: wet_conv_in(i1:i2,j1:j2,km,n1:n2)
    REAL*8, INTENT(INOUT) :: airmass(i1:i2, j1:j2, km)
    REAL*8, DIMENSION(i1:i2, j1:j2, km), INTENT(IN) :: vud
    REAL*8, DIMENSION(i1:i2, j1:j2, km+1), INTENT(IN) :: cldmas
    REAL*8, DIMENSION(i1:i2, j1:j2, km), INTENT(IN) :: dtrain
    REAL*8, DIMENSION(i1:i2, j1:j2), INTENT(IN) :: area
    REAL*8, DIMENSION(i1:i2, j1:j2, km), INTENT(IN) :: delz, delp
    REAL*8, DIMENSION(i1:i2, j1:j2, km), INTENT(IN) :: airmol
    REAL*8, DIMENSION(i1:i2, j1:j2, km), INTENT(IN) :: tmpu
    REAL*8, DIMENSION(i1:i2, j1:j2, km+1), INTENT(IN) :: ple
    REAL*8, INTENT(OUT) :: bcnv(i1:i2, j1:j2, n1:n2)
    REAL*8, INTENT(INOUT), OPTIONAL :: h2o2(i1:i2, j1:j2, km)
! true for aerosol
    LOGICAL, INTENT(INOUT) :: kin
    REAL*8 :: tc1(i1:i2, j1:j2, km, n1:n2), f(i1:i2, j1:j2, km, n1:n2)
    REAL*8 :: cldmas_tmp(i1:i2, j1:j2, km), so2loss
! epsilon: A very small positive number   [unitless]
    REAL*8, PARAMETER :: epsilon=1.0e-32
! universal gas constant [L*atm/moles/K]
    REAL*8, PARAMETER :: r=8.2057d-2
    REAL*8, PARAMETER :: inv_t0=1d0/298d0
! 0.6*SQRT(0.9) for ice to gas ratio
    REAL*8, PARAMETER :: conv_nh3=5.69209978831d-1
    REAL*8 :: kg, kstar298, h298_r, i2g, l2g, c_tot, f_l, f_i
    INTEGER :: n, i, j, l, nso2, nso4, nmsa
    REAL*8, DIMENSION(i1:i2, j1:j2, km) :: c_h2o
    REAL*8, DIMENSION(i1:i2, j1:j2, km) :: cldliq
    REAL*8, DIMENSION(i1:i2, j1:j2, km) :: cldice
    INTRINSIC TRIM
    INTRINSIC EXP
    INTRINSIC MIN
    INTRINSIC MAX
    LOGICAL, DIMENSION(i1:i2, j1:j2, km) :: mask
    LOGICAL, DIMENSION(i1:i2, j1:j2, km) :: mask0
    LOGICAL, DIMENSION(i1:i2, j1:j2, km) :: mask1
    LOGICAL, DIMENSION(i1:i2, j1:j2, km) :: mask2
    LOGICAL, DIMENSION(i1:i2, j1:j2, km) :: mask3
!  Initialize local variables
!  --------------------------
!  c_h2o, cldliq, and cldice are respectively intended to be the
!  water mixing ratio (liquid or vapor?, in or out of cloud?)
!  cloud liquid water mixing ratio
!  cloud ice water mixing ratio
    c_h2o = 10d0**(-(2663.5d0/tmpu(:, :, :))+12.537d0)/(ple(:, :, 1:km)+&
&     ple(:, :, 2:km+1))/2d0
    cldliq = 0.d0
    mask = tmpu .GT. 248.
    WHERE (mask) cldliq = 1.d-6*((tmpu-248.d0)/20.d0)
    mask0 = tmpu .GE. 268.
    WHERE (mask0) cldliq = 1.d-6
    cldice = 1.d-6 - cldliq
! executable statements
    tc1(:, :, :, :) = tc(:, :, :, :)
!if (MAPL_AM_I_ROOT()) print *, 'hbian convection tmpu =', tmpu(i1,j1,1), tmpu(i1,j1,km)
! compute the fraction of tracer scavenged in convective cloud updrafts
    f = 0.0
    kg = 0d0
    DO n=n1,n2
! treat NH3 as a gas tracer
      IF (TRIM(aero_type) .EQ. 'nitrate' .AND. n .EQ. n1) kin = .false.
! treat others as aerosol
      IF (TRIM(aero_type) .EQ. 'nitrate' .AND. n .GT. n1) kin = .true.
      IF (kin) THEN
        CALL F_AEROSOL(i1, i2, j1, j2, km, kc, f(:, :, :, n), delz, vud)
      ELSE
! gas tracer NH3
        IF (TRIM(aero_type) .EQ. 'nitrate' .AND. n .EQ. n1) THEN
! values adopted in Umich/IMPACT and GMI, effective Herry's law coefficient at pH = 5
          kstar298 = 1.05d6
          h298_r = -4.2d3
        END IF
        DO l=2,km
          DO j=j1,j2
            DO i=i1,i2
! ice to gas ratio
              IF (c_h2o(i, j, l) .GT. 0.d0) THEN
                i2g = cldice(i, j, l)/c_h2o(i, j, l)*conv_nh3
              ELSE
                i2g = 0.d0
              END IF
              l2g = cldliq(i, j, l)*r*tmpu(i, j, l)*kstar298*EXP(-(&
&               h298_r*(1d0/tmpu(i, j, l)-inv_t0)))
! fraction of NH3 in liquid & ice phases
              c_tot = 1d0 + l2g + i2g
              f_l = l2g/c_tot
              f_i = i2g/c_tot
! compute kg, the retention factor for liquid NH3 is 0 at T < 248K and
! 0.05 at 248K < T < 268K
              IF (tmpu(i, j, l) .GE. 268d0) THEN
                kg = kc*(f_l+f_i)
              ELSE IF (248d0 .LT. tmpu(i, j, l) .AND. tmpu(i, j, l) .LT.&
&                 268d0) THEN
                kg = kc*(0.05*f_l+f_i)
              ELSE
                kg = kc*f_i
              END IF
              IF (kg .GT. 0.d0 .AND. vud(i, j, l) .GT. 1.e-14) f(i, j, l&
&               , n) = 1.0 - EXP(-(kg*delz(i, j, l)/vud(i, j, l)))
            END DO
          END DO
        END DO
      END IF
! sulfur
!    Special treatment for DMS and SO2 if aero_type is "sulfur"
      IF (TRIM(aero_type) .EQ. 'sulfur') THEN
!        if(.not.present(h2o2)) call die ('GOCARTConvectionMod.F90', &
!                                         'missing required H2O2 for sulfur')
! DMS
        IF (n .EQ. n1) f(:, :, :, n1) = 0.0
! SO2
!if(n .eq. n1+1)  f(:,:,:,n1+1) = 0.0  ! SO2 for now is not scavenged
!#ifdef PRC
        IF (n .EQ. n1 + 1) THEN
! SO2 requires special handling
!==============================================================
! Coupled full chemistry/aerosol simulation:
! Use the wet scavenging formula of Chin et al [1996],
! such that a soluble fraction of SO2 is limited by the
! availability of H2O2 in the precipitating grid box.
! Scavenge the soluble SO2 at the same rate as the sulfate.
! Update H2O2_sav and SO2_sav for use in RAINOUT, WASHOUT
!==============================================================
          DO l=2,km
            DO j=j1,j2
              DO i=i1,i2
! Make sure to deplete H2O2s the same as SO2s.
! (dkh, rjp, bmy, 11/17/05)
! based on GEOS-Chem. tq, 01/09
                IF (tc1(i, j, l, n) .GT. epsilon) THEN
                  IF (h2o2(i, j, l) .GT. tc1(i, j, l, n)) THEN
                    so2loss = tc1(i, j, l, n)
                  ELSE
                    so2loss = h2o2(i, j, l)
                  END IF
                  f(i, j, l, n) = f(i, j, l, n)*so2loss/tc1(i, j, l, n)
                  IF (f(i, j, l, n) .LT. 0.0) THEN
                    f(i, j, l, n) = 0.0
                  ELSE
                    f(i, j, l, n) = f(i, j, l, n)
                  END IF
! update saved h2o2 concentration
                  h2o2(i, j, l) = h2o2(i, j, l) - tc1(i, j, l, n)*f(i, j&
&                   , l, n)
                  IF (h2o2(i, j, l) .LT. epsilon) THEN
                    h2o2(i, j, l) = epsilon
                  ELSE
                    h2o2(i, j, l) = h2o2(i, j, l)
                  END IF
                ELSE
! set f = 0 if so2 < epsilon (dkh, rjp, bmy, 11/17/05)
                  f(i, j, l, n) = 0.d0
                END IF
              END DO
            END DO
          END DO
        END IF
      END IF
    END DO
!#endif
! n
! if tracer is type "carbon" then set coefficient to 0 for hydrophobic
! implementing QQ Wang's change by Huisheng Bian (4/24/2015)
! not scavenging  BCn1 (hydrophobic) when T > 258 K
    IF (TRIM(aero_type) .EQ. 'OC') f(:, :, :, n1) = 0d0
! suppress scavenging most aerosols at cold T except BCn1 (hydrophobic), dust, and HNO3
    IF (TRIM(aero_type) .EQ. 'BC') THEN
      mask1 = tmpu .GE. 258.d0
      WHERE (mask1) f(:, :, :, n1) = 0.d0
    END IF
    IF (TRIM(aero_type) .EQ. 'BC') THEN
      mask2 = tmpu .LT. 258.d0
      WHERE (mask2) f(:, :, :, n2) = 0.d0
    END IF
    IF (((((((TRIM(aero_type) .EQ. 'OC' .OR. TRIM(aero_type) .EQ. &
&       'sea_salt') .OR. TRIM(aero_type) .EQ. 'sulfur') .OR. TRIM(&
&       aero_type) .EQ. 'seasalt') .OR. TRIM(aero_type) .EQ. 'sulfate') &
&       .OR. TRIM(aero_type) .EQ. 'nitrate') .OR. TRIM(aero_type) .EQ. &
&       'NH3') .OR. TRIM(aero_type) .EQ. 'NH4a') THEN
      DO n=n1,n2
        mask3 = tmpu .LT. 258.d0
        WHERE (mask3) f(:, :, :, n) = 0.d0
      END DO
    END IF
! re-index for routine cldcnv
    cldmas_tmp(:, :, 1:km) = cldmas(:, :, 2:km+1)
! internal time step for the convection routine is 300s
    CALL CLDCNV(i1, i2, j1, j2, km, n1, n2, dt_30m, aero_type, tc, f, &
&         airmass, area, cldmas_tmp, dtrain, delz, delp)
! -- Mass balance
    SELECT CASE  (TRIM(aero_type)) 
    CASE ('sulfur') 
      nso2 = n1 + 1
      nso4 = n1 + 2
      nmsa = n1 + 3
      cldso2 = 0.0d0
      cldso4 = 0.0d0
      cldmsa = 0.0d0
      DO l=1,km
        DO j=j1,j2
          DO i=i1,i2
            cldso2(i, j, l) = cldso2(i, j, l) + (tc(i, j, l, nso2)-tc1(i&
&             , j, l, nso2))*airmass(i, j, l)
            cldso4(i, j, l) = cldso4(i, j, l) + (tc(i, j, l, nso4)-tc1(i&
&             , j, l, nso4))*airmass(i, j, l)
            cldmsa(i, j, l) = cldmsa(i, j, l) + (tc(i, j, l, nmsa)-tc1(i&
&             , j, l, nmsa))*airmass(i, j, l)
          END DO
        END DO
      END DO
      DO n=n1,n2
        DO i=i1,i2
          DO j=j1,j2
            bcnv(i, j, n) = 0.0
            DO l=1,km
              IF (tc(i, j, l, n) .LT. 0.0) tc(i, j, l, n) = 1.0e-32
! kg tracer
              bcnv(i, j, n) = bcnv(i, j, n) + (tc(i, j, l, n)-tc1(i, j, &
&               l, n))*airmass(i, j, l)
            END DO
          END DO
        END DO
      END DO
    CASE ('co') 
      cldscv = 0.0d0
      DO n=n1,n2
        DO l=1,km
          DO j=j1,j2
            DO i=i1,i2
!                wet_conv_in(i,j,l,n) = wet_conv_in(i,j,l,n) + &
              cldscv(i, j, l, n) = cldscv(i, j, l, n) + (tc(i, j, l, n)-&
&               tc1(i, j, l, n))*airmol(i, j, l)
            END DO
          END DO
        END DO
      END DO
      bcnv(:, :, :) = 0.0
      DO n=n1,n2
        DO i=i1,i2
          DO j=j1,j2
            DO l=1,km
              IF (tc(i, j, l, n) .LT. 0.0) tc(i, j, l, n) = 1.0e-32
              bcnv(i, j, n) = bcnv(i, j, n) + (tc(i, j, l, n)-tc1(i, j, &
&               l, n))*airmol(i, j, l)
            END DO
          END DO
        END DO
      END DO
    CASE DEFAULT
!!$     DO n = n1, n2
!!$        DO l = 1,km
!!$           DO j = j1, j2
!!$              DO i = i1, i2
!!$                 wet_conv_in(i,j,l,n) = wet_conv_in(i,j,l,n) + &
!!$                      (tc(i,j,l,n) - tc1(i,j,l,n)) * airmass(i,j,l)
!!$              END DO
!!$           END DO
!!$        END DO
!!$     END DO
      DO n=n1,n2
        DO i=i1,i2
          DO j=j1,j2
            bcnv(i, j, n) = 0.0
            DO l=1,km
              IF (tc(i, j, l, n) .LT. 0.0) tc(i, j, l, n) = 1.0e-32
              bcnv(i, j, n) = bcnv(i, j, n) + (tc(i, j, l, n)-tc1(i, j, &
&               l, n))*airmass(i, j, l)
            END DO
          END DO
        END DO
      END DO
    END SELECT
  END SUBROUTINE CONVECTION
! ----------------------------------------------------------------------------------
! set_vud
  SUBROUTINE SET_VUD(i1, i2, j1, j2, km, frlake, frocean, frseaice, &
&   cldmas, qccu, airmass, delz, area, vud)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: i1, i2, j1, j2, km
    REAL*8, DIMENSION(i1:i2, j1:j2), INTENT(IN) :: frlake, frocean, &
&   frseaice
    REAL*8, DIMENSION(i1:i2, j1:j2), INTENT(IN) :: area
    REAL*8, DIMENSION(i1:i2, j1:j2, km), INTENT(IN) :: qccu, airmass, &
&   delz
    REAL*8, DIMENSION(i1:i2, j1:j2, km+1), INTENT(IN) :: cldmas
    REAL*8, INTENT(OUT) :: vud(i1:i2, j1:j2, km)
! maximum updraft velocity [m/s]
    REAL*8, PARAMETER :: max_vud=100
    REAL*8 :: water(i1:i2, j1:j2), dvud(i1:i2, j1:j2, km)
    INTEGER :: i, j, k
    REAL*8, PARAMETER :: tiny=1.0e-14
    LOGICAL, DIMENSION(i1:i2, j1:j2) :: mask
    LOGICAL, DIMENSION(i1:i2, j1:j2) :: mask0
    LOGICAL, DIMENSION(i1:i2, j1:j2, km) :: mask1
! executable statements
!==============================================================
! Compute vud -- 5 m/s over oceans, 10 m/s over land
! Assume vud is the same at all altitudes; the array can be 2-D
!==============================================================
!    WHERE ((frlake + frocean - frseaice) >= 0.5) ! water
!       dvud = 5.0
!    ELSEWHERE ! land (including permanent ice) and sea ice
!       dvud = 10.0
!    END WHERE
    water = frlake + frocean - frseaice
    mask = water .LT. 0.0
    WHERE (mask) water = 0.0
    mask0 = water .GT. 1.0
    WHERE (mask0) water = 1.0
! Compute updraft velocity as a weighted average over water and land+ice.
    DO k=1,km
!    dvud(:,:,k) = water(:,:)*5.0 + MAX((1.0-water(:,:)),0.0)*10.0
      dvud(:, :, k) = water(:, :)*5.0 + (1.0-water(:, :))*10.0
    END DO
! compute updraft velocity from cldmas=rho*vud
    DO k=1,km-1
      DO j=j1,j2
        DO i=i1,i2
          IF (qccu(i, j, k) .GE. tiny) THEN
            vud(i, j, k) = cldmas(i, j, k+1)/(qccu(i, j, k)*airmass(i, j&
&             , k))*area(i, j)*delz(i, j, k)
          ELSE
            vud(i, j, k) = dvud(i, j, k)
          END IF
        END DO
      END DO
    END DO
    vud(:, :, km) = 0.0
! What should be used as threshold value here? 100 m/s?
!   WHERE (vud > max_vud) vud = max_vud
    mask1 = vud .GT. max_vud
    WHERE (mask1) vud = dvud
  END SUBROUTINE SET_VUD
! ----------------------------------------------------------------------------------
!  SUBROUTINE COMPUTE_F( i1, i2 ,j1 ,j2, km, n, aero_type, F, bxheight, vud, tc1, h2o2, kc)
  SUBROUTINE COMPUTE_F(i1, i2, j1, j2, km, n, aero_type, f, bxheight, &
&   vud, tc1, kc)
    IMPLICIT NONE
! Return to calling program
! Arguments
    INTEGER, INTENT(IN) :: i1, i2, j1, j2, km
    CHARACTER(len=*) :: aero_type
    INTEGER, INTENT(IN) :: n
    REAL*8, INTENT(IN) :: bxheight(i1:i2, j1:j2, km), vud(i1:i2, j1:j2, &
&   km)
    REAL*8, INTENT(IN) :: kc
!  REAL*8,    INTENT(INOUT) :: tc1(i1:i2,j1:j2,km), h2o2(i1:i2,j1:j2,km)
    REAL*8, INTENT(INOUT) :: tc1(i1:i2, j1:j2, km)
    REAL*8, INTENT(OUT) :: f(i1:i2, j1:j2, km)
! Local variables
    INTEGER :: i, j, l, nn
    REAL*8 :: l2g, i2g, c_tot, f_l, f_i, k, tmp, so2loss
! Kc is the conversion rate from cloud condensate to precip [s^-1]
!  REAL*8, PARAMETER    :: KC   = 5.0E-3
! CONV = 0.6 * SQRT( 1.9 ), used for the ice to gas ratio for H2O2
    REAL*8, PARAMETER :: conv=8.27042925126e-1
!  epsilon: A very small positive number   [unitless]
    REAL*8, PARAMETER :: epsilon=1.0e-32
    INTRINSIC TRIM
!=================================================================
! COMPUTE_F begins here!
!
! For aerosol tracers, compute F with internal routine F_AEROSOL.
!
! ISOL = tracer index for the ND38 diagnostic.  Values are:
!
! Tracer   Rn-Pb-Be run   Fullchem run   Offline sulfate run
! ------   ------------   ------------   -------------------
!  210Pb         1              -                -
!  7Be           2              -                -
!  HNO3          -              1                -
!  H2O2          -              2                7
!  CH2O          -              3                -
!  MP            -              4                -
!  SO2           -              5                1
!  SO4           -              6                2
!  MSA           -              7                3
!  NH3           -              8                4
!  NH4           -              9                5
!  NIT           -             10                6
!=================================================================
    SELECT CASE  (TRIM(aero_type)) 
    CASE ('sulfur') 
      f = 0.0
    CASE ('carbon') 
! PRC rewrite this a bit
!     IF ( n == n2 ) THEN
!----------------------------
! HYDROPHILIC (aerosol)
!----------------------------
      CALL F_AEROSOL(i1, i2, j1, j2, km, kc, f, bxheight, vud)
    CASE ('dust') 
!     ELSE IF ( n == n1 ) THEN
!        !----------------------------
!        ! HYDROPHOBIC (aerosol)
!        !----------------------------
!        ! Force not to be lost in convective updraft for now
!        F    = 0.0
!     END IF
!----------------------------
! DUST (aerosol) (all dust bins)
!----------------------------
      CALL F_AEROSOL(i1, i2, j1, j2, km, kc, f, bxheight, vud)
    CASE ('sea_salt') 
!----------------------------
! seasalt aerosol (accum mode and coarse mode)
!----------------------------
      CALL F_AEROSOL(i1, i2, j1, j2, km, kc, f, bxheight, vud)
    CASE ('co') 
      IF (lsadirect) THEN
        CALL F_AEROSOL(i1, i2, j1, j2, km, kc, f, bxheight, vud)
      ELSE
!----------------------------
! ALL CO ARE HYDROPHOBIC
!----------------------------
! Force not to be lost in convective updraft for now
        f = 0.0
      END IF
    END SELECT
  END SUBROUTINE COMPUTE_F
!  Differentiation of f_aerosol in reverse (adjoint) mode:
!   gradient     of useful results: f
!   with respect to varying inputs: f
! ----------------------------------------------------------------------------------
  SUBROUTINE F_AEROSOL_ADM(i1, i2, j1, j2, km, kc, f, f_ad, bxheight, &
&   vud)
    IMPLICIT NONE
! Return to calling program
! Arguments
    INTEGER, INTENT(IN) :: i1, i2, j1, j2, km
    REAL*8, INTENT(IN) :: kc
    REAL*8, INTENT(IN) :: bxheight(i1:i2, j1:j2, km), vud(i1:i2, j1:j2, &
&   km)
    REAL*8 :: f(i1:i2, j1:j2, km)
    REAL*8 :: f_ad(i1:i2, j1:j2, km)
! Local variables
    INTEGER :: i, j, l
    REAL*8 :: tmp
    INTRINSIC EXP
    INTEGER :: branch
!=================================================================
! F_AEROSOL begins here!
!
! Aerosol tracers are 100% in the cloud condensate phase, so
! we set K = Kc, and compute F accordingly (cf Jacob et al 2000 )
!=================================================================
! Turn off scavenging in the first level by setting F = 0
!!!  f(:,:,1) = 0.0
! Apply scavenging in levels 2 and higher
!!  DO l = 2, km
    DO l=1,km-1
      DO j=j1,j2
        DO i=i1,i2
! Distance between grid box centers [m]
!           tmp = 0.5 * ( bxheight(i,j,l-1) + bxheight(i,j,l) )
! (Eq. 2, Jacob et al, 2000, with K = Kc)
!           f(i,j,l) = 1.0 - EXP( -kc * tmp / vud(i,j,l) )
          IF (vud(i, j, l) .GT. 1.e-14) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
    END DO
    DO l=km-1,1,-1
      DO j=j2,j1,-1
        DO i=i2,i1,-1
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) f_ad(i, j, l) = 0.0_8
        END DO
      END DO
    END DO
  END SUBROUTINE F_AEROSOL_ADM
! ----------------------------------------------------------------------------------
  SUBROUTINE F_AEROSOL(i1, i2, j1, j2, km, kc, f, bxheight, vud)
    IMPLICIT NONE
! Return to calling program
! Arguments
    INTEGER, INTENT(IN) :: i1, i2, j1, j2, km
    REAL*8, INTENT(IN) :: kc
    REAL*8, INTENT(IN) :: bxheight(i1:i2, j1:j2, km), vud(i1:i2, j1:j2, &
&   km)
    REAL*8, INTENT(OUT) :: f(i1:i2, j1:j2, km)
! Local variables
    INTEGER :: i, j, l
    REAL*8 :: tmp
    INTRINSIC EXP
!=================================================================
! F_AEROSOL begins here!
!
! Aerosol tracers are 100% in the cloud condensate phase, so
! we set K = Kc, and compute F accordingly (cf Jacob et al 2000 )
!=================================================================
! Turn off scavenging in the first level by setting F = 0
!!!  f(:,:,1) = 0.0
! Apply scavenging in levels 2 and higher
!!  DO l = 2, km
    DO l=1,km-1
      DO j=j1,j2
        DO i=i1,i2
! Distance between grid box centers [m]
!           tmp = 0.5 * ( bxheight(i,j,l-1) + bxheight(i,j,l) )
! (Eq. 2, Jacob et al, 2000, with K = Kc)
!           f(i,j,l) = 1.0 - EXP( -kc * tmp / vud(i,j,l) )
          IF (vud(i, j, l) .GT. 1.e-14) f(i, j, l) = 1.0 - EXP(-(kc*&
&             bxheight(i, j, l)/vud(i, j, l)))
        END DO
      END DO
    END DO
  END SUBROUTINE F_AEROSOL
!  Differentiation of cldcnv in reverse (adjoint) mode:
!   gradient     of useful results: q
!   with respect to varying inputs: f q
! ----------------------------------------------------------------------------------
  SUBROUTINE CLDCNV_ADM(i1, i2, j1, j2, km, n1, n2, dt_conv, aero_type, &
&   q, q_ad, f, f_ad, airmass, area, cldmas, dtrn, delz, delp)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: i1, i2, j1, j2, km, n1, n2, dt_conv
    CHARACTER(len=255) :: aero_type
    REAL*8, DIMENSION(i1:i2, j1:j2, km), INTENT(IN) :: airmass, cldmas, &
&   dtrn
    REAL*8, INTENT(IN) :: delz(i1:i2, j1:j2, km), delp(i1:i2, j1:j2, km)&
&   , area(i1:i2, j1:j2)
    REAL*8, INTENT(IN) :: f(i1:i2, j1:j2, km, n1:n2)
    REAL*8 :: f_ad(i1:i2, j1:j2, km, n1:n2)
!  REAL*8, INTENT(INOUT) :: q(i1:i2,j1:j2,km,n1:n2), h2o2(i1:i2,j1:j2,km)
    REAL*8, INTENT(INOUT) :: q(i1:i2, j1:j2, km, n1:n2)
    REAL*8, INTENT(INOUT) :: q_ad(i1:i2, j1:j2, km, n1:n2)
    REAL*8 :: bmass(i1:i2, j1:j2, km), qb(i1:i2, j1:j2), mb(i1:i2, j1:j2&
&   ), qc(i1:i2, j1:j2)
    REAL*8 :: qb_ad(i1:i2, j1:j2), qc_ad(i1:i2, j1:j2)
    REAL*8 :: tdt, qc_pres, cmout, entrn, delq, dq
    REAL*8 :: qc_pres_ad, delq_ad
    REAL*8 :: term_1, term_2, term_3, term_4, tsum
    REAL*8 :: term_1_ad, term_2_ad, term_3_ad, term_4_ad, tsum_ad
    INTEGER :: nsteps, ktop, jump, js, jn, ic, istep, i, j, k
    REAL*8, PARAMETER :: tiny=1.0e-14
    INTRINSIC MAX
    INTRINSIC REAL
    REAL*8 :: temp_ad
    REAL*8 :: temp_ad0
    REAL*8 :: temp_ad1
    INTEGER :: branch
! executable statements
! ============================================================================
!   Define active convective region,from J = JS(outh) to J = JN(orth),
!   and to level K = KTOP.
!
!   Polar regions are too cold to have moist convection.
!   (Dry convection should be done elsewhere.)
! ============================================================================
    ktop = km - 1
!  jump = (jmx - 1)/20
!  js = 1 + jump
!  jn = jmx - js + 1
!write(*,*) js, jn
!write(*,*) minval(q), maxval(q)
!write(*,*) minval(delp), maxval(delp)
! ============================================================================
!   Internal time step for convective mixing is 300 sec.
! ============================================================================
! Use fixed internal convection time step of 300s
! nstep: number of internal time steps to reach dt_conv, which is the external
! time interval for the convection process
    nsteps = dt_conv/300
    IF (nsteps .LT. 1) THEN
      nsteps = 1
    ELSE
      nsteps = nsteps
    END IF
    tdt = REAL(dt_conv)/REAL(nsteps)
! ============================================================================
!   Compute air mass of each grid box (I,J,K).
! ============================================================================
    DO k=1,km
      DO j=j1,j2
        DO i=i1,i2
          bmass(i, j, k) = airmass(i, j, k)/area(i, j)
        END DO
      END DO
    END DO
tracer_loop:DO ic=n1,n2
time_loop:DO istep=1,nsteps
! ============================================================================
!   (1) Below cloud base
!
!   If Cloud Mass Flux exists at (I,J,2), then compute QB.
!   QB is "weighted average" mixing ratio below the cloud base.
!   QB is used to compute QC, which is defined as:
!
!   QC =  ( Total mass of tracer below cloud base +
!           Subsidence into cloud base from above )
!        -------------------------------------------------------
!                 Total air mass below cloud base
!
!   MB is the total mass of air below the cloud base.
! ============================================================================
j_loop_1:DO j=j1,j2
 i_loop_1:DO i=i1,i2
            IF (cldmas(i, j, 2) .GT. tiny) THEN
              qb(i, j) = (q(i, j, 1, ic)*delp(i, j, 1)+q(i, j, 2, ic)*&
&               delp(i, j, 2))/(delp(i, j, 1)+delp(i, j, 2))
! alternative:
! use delz as weight
!                 qb(i,j) = (q(i,j,1,ic)*delz(i,j,1) + &
!                            q(i,j,2,ic)*delz(i,j,2)) / &
!                            (delz(i,j,1) + delz(i,j,2))
              CALL PUSHREAL8(mb(i, j))
              mb(i, j) = bmass(i, j, 1) + bmass(i, j, 2)
              CALL PUSHREAL8(qc(i, j))
              qc(i, j) = (mb(i, j)*qb(i, j)+cldmas(i, j, 2)*q(i, j, 3, &
&               ic)*tdt)/(mb(i, j)+cldmas(i, j, 2)*tdt)
! ============================================================================
!   Compute net change in mixing ratio.
!
!   DQ = QB - QC is the total mass to be transported out of the cloud base.
!   Changes below cloud base are proportional to the background mass.
!
!   Subtract DQ from Q(*,*,K=1,*) and from Q(*,*,K=2,*), but do not make
!   Q(*,*,K=1,*) or Q(*,*,K=2,*) negative.
! ============================================================================
! modification for now based on GEOS-CHEM
! should be revisited ...
!                 dq = qb(i,j) - qc(i,j)
!                 IF (dq > q(i,j,1,ic) .OR. dq > q(i,j,2,ic)) THEN
!                    q(i,j,2,ic) = qc(i,j)
!                    q(i,j,1,ic) = qc(i,j)
!                 ELSE
!                    q(i,j,2,ic) = q(i,j,2,ic) - dq
!                    q(i,j,1,ic) = q(i,j,1,ic) - dq
!                 END IF
              q(i, j, 2, ic) = qc(i, j)
              q(i, j, 1, ic) = qc(i, j)
! ============================================================================
!   If there is no Cloud mass flux, set QC = Q(K=3) at this I,J location
! ============================================================================
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHREAL8(qc(i, j))
              qc(i, j) = q(i, j, 3, ic)
              CALL PUSHCONTROL1B(0)
            END IF
          END DO i_loop_1
        END DO j_loop_1
! ============================================================================
!   (2) Cloud interior mixing
! ============================================================================
 k_loop:DO k=3,ktop
 j_loop_2:DO j=j1,j2
   i_loop_2:DO i=i1,i2
! ============================================================================
!   If there is cloud mass flux at this location, do the convective
!   transport.
!
!   QC_PRES = amount of QC preserved against wet scavenging
!   CMOUT = air mass flowing out of cloud at level K
!   ENTRN = air mass flowing into cloud at level K
!
!   If Entrainment >= 0 then compute the new value of QC(I,J):
!
!                  CLDMAS(K-1)*QC_PRES + ENTRN(K)*Q(K)
!      QC(I,J) =  ---------------------------------------
!                     CLDMAS(I,J,K) + DTRN(I,J,K)
!
!              =   tracer mass coming in from below      (i.e. level K-1) +
!                  tracer mass coming in from this level (i.e. level K)
!                 -----------------------------------------------------------
!                             total mass coming into cloud
!
!   Entrainment must be >= 0 (since we cannot have a negative flux of air
!   into the cloud).  This condition is strong enough to ensure that
!   CMOUT > 0 and will prevent floating-point exception.
! ============================================================================
              IF (cldmas(i, j, k-1) .GT. tiny) THEN
! Soluble species are scavenged during entrainment.
                qc_pres = qc(i, j)*(1.0-f(i, j, k, ic))
                cmout = cldmas(i, j, k) + dtrn(i, j, k)
                entrn = cmout - cldmas(i, j, k-1)
                IF (entrn .GE. 0.0) THEN
                  CALL PUSHREAL8(qc(i, j))
                  qc(i, j) = (cldmas(i, j, k-1)*qc_pres+entrn*q(i, j, k&
&                   , ic))/cmout
                  CALL PUSHCONTROL1B(0)
                ELSE
                  CALL PUSHCONTROL1B(1)
                END IF
! ============================================================================
!   The cumulus transport above the cloud base is done as follows:
!      C_k-1  = cloud air mass flux from level k-1 to level k
!      C_k    = cloud air mass flux from level k to level k+1
!      QC_k-1 = mixing ratio of tracer INSIDE CLOUD in level k-1
!      QC_k   = mixing ratio of tracer INSIDE CLOUD in level k
!      Q_k    = mixing ratio of tracer in level k
!      Q_k+1  = mixing ratio of tracer in level k+1
!
!                        (       Cloud        )
!                        (                    )
!                        (                    )3)      C_k * Q_k+1
!             k+1        (         ^          )            |
!            ------------(---------|----------)------------|--------
!                        (         |          )            V
!                        (2)   C_k * QC_k     )
!                        (                    )
!             k          (                    )
!                        (         ^          )4)    C_k-1 * Q_k
!                        (         |          )            |
!            ------------(---------|----------)------------|----------
!             k-1        (         |          )            |
!                        (1) C_k-1 * QC_k-1   )            V
!                        (         * AP       )
!                        (                    )
!                        (                    )
!
!   There are 4 terms that contribute to mass flow in and out of level k:
!
!   1) C_k-1 * QC_PRES = tracer convected from level k-1 to level k
!   2) C_k   * QC_k    = tracer convected from level k   to level k+1
!   3) C_k   * Q_k+1   = tracer subsiding from level k+1 to level k
!   4) C_k-1 * Q_k     = tracer subsiding from level k   to level k-1
!
!   Therefore the change in tracer concentration is given by
!      DELQ = (Term 1) - (Term 2) + (Term 3) - (Term 4)
!
!   and Q(I,J,K,IC) = Q(I,J,K,IC) + DELQ
!
! ============================================================================
                term_1 = cldmas(i, j, k-1)*qc_pres
                term_2 = -(cldmas(i, j, k)*qc(i, j))
                term_3 = cldmas(i, j, k)*q(i, j, k+1, ic)
                term_4 = -(cldmas(i, j, k-1)*q(i, j, k, ic))
                tsum = term_1 + term_2 + term_3 + term_4
                delq = tdt/bmass(i, j, k)*tsum
                q(i, j, k, ic) = q(i, j, k, ic) + delq
! prevent concentrations from being negative
                IF (q(i, j, k, ic) .LT. 1.0e-32) THEN
                  q(i, j, k, ic) = 1.0e-32
                  CALL PUSHCONTROL3B(4)
                ELSE
                  CALL PUSHCONTROL3B(3)
                END IF
              ELSE
! ============================================================================
!   No cloud transport if cloud mass flux < TINY; Change Qc to q
! ============================================================================
                CALL PUSHREAL8(qc(i, j))
                qc(i, j) = q(i, j, k, ic)
!--------------------------------------------------
! FIX FOR GEOS-5 MET FIELDS!
!
! Bug fix for the cloud base layer, which is not
! necessarily in the boundary layer, and for
! GEOS-5, there could be "secondary convection
! plumes - one in the PBL and another one not.
!
! NOTE: TERM_2 and TERM_3 are the same terms as described
! in the above section.
!
! (swu, 08/13/2007)
!--------------------------------------------------
                IF (cldmas(i, j, k) .GT. tiny) THEN
! Tracer convected from K -> K+1
                  term_2 = -(cldmas(i, j, k)*qc(i, j))
! Tracer subsiding from K+1 -> K
                  term_3 = cldmas(i, j, k)*q(i, j, k+1, ic)
! Change in tracer concentration
                  delq = tdt/bmass(i, j, k)*(term_2+term_3)
! Add change in tracer to Q array
                  q(i, j, k, ic) = q(i, j, k, ic) + delq
! prevent concentrations from being negative
                  IF (q(i, j, k, ic) .LT. 1.0e-32) THEN
                    q(i, j, k, ic) = 1.0e-32
                    CALL PUSHCONTROL3B(2)
                  ELSE
                    CALL PUSHCONTROL3B(1)
                  END IF
                ELSE
                  CALL PUSHCONTROL3B(0)
                END IF
              END IF
            END DO i_loop_2
          END DO j_loop_2
        END DO k_loop
      END DO time_loop
    END DO tracer_loop
    f_ad = 0.0_8
    qb_ad = 0.0_8
    qc_ad = 0.0_8
    DO ic=n2,n1,-1
      DO istep=nsteps,1,-1
        DO k=ktop,3,-1
          DO j=j2,j1,-1
            DO 110 i=i2,i1,-1
              CALL POPCONTROL3B(branch)
              IF (branch .LT. 2) THEN
                IF (branch .EQ. 0) GOTO 100
              ELSE IF (branch .EQ. 2) THEN
                q_ad(i, j, k, ic) = 0.0_8
              ELSE
                IF (branch .NE. 3) q_ad(i, j, k, ic) = 0.0_8
                delq_ad = q_ad(i, j, k, ic)
                tsum_ad = tdt*delq_ad/bmass(i, j, k)
                term_1_ad = tsum_ad
                term_2_ad = tsum_ad
                term_3_ad = tsum_ad
                term_4_ad = tsum_ad
                q_ad(i, j, k, ic) = q_ad(i, j, k, ic) - cldmas(i, j, k-1&
&                 )*term_4_ad
                q_ad(i, j, k+1, ic) = q_ad(i, j, k+1, ic) + cldmas(i, j&
&                 , k)*term_3_ad
                qc_ad(i, j) = qc_ad(i, j) - cldmas(i, j, k)*term_2_ad
                qc_pres_ad = cldmas(i, j, k-1)*term_1_ad
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  cmout = cldmas(i, j, k) + dtrn(i, j, k)
                  entrn = cmout - cldmas(i, j, k-1)
                  CALL POPREAL8(qc(i, j))
                  qc_pres_ad = qc_pres_ad + cldmas(i, j, k-1)*qc_ad(i, j&
&                   )/cmout
                  q_ad(i, j, k, ic) = q_ad(i, j, k, ic) + entrn*qc_ad(i&
&                   , j)/cmout
                  qc_ad(i, j) = 0.0_8
                END IF
                qc_ad(i, j) = qc_ad(i, j) + (1.0-f(i, j, k, ic))*&
&                 qc_pres_ad
                f_ad(i, j, k, ic) = f_ad(i, j, k, ic) - qc(i, j)*&
&                 qc_pres_ad
                GOTO 110
              END IF
              delq_ad = q_ad(i, j, k, ic)
              temp_ad1 = tdt*delq_ad/bmass(i, j, k)
              term_2_ad = temp_ad1
              term_3_ad = temp_ad1
              q_ad(i, j, k+1, ic) = q_ad(i, j, k+1, ic) + cldmas(i, j, k&
&               )*term_3_ad
              qc_ad(i, j) = qc_ad(i, j) - cldmas(i, j, k)*term_2_ad
 100          CALL POPREAL8(qc(i, j))
              q_ad(i, j, k, ic) = q_ad(i, j, k, ic) + qc_ad(i, j)
              qc_ad(i, j) = 0.0_8
 110        CONTINUE
          END DO
        END DO
        DO j=j2,j1,-1
          DO i=i2,i1,-1
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL8(qc(i, j))
              q_ad(i, j, 3, ic) = q_ad(i, j, 3, ic) + qc_ad(i, j)
              qc_ad(i, j) = 0.0_8
            ELSE
              qc_ad(i, j) = qc_ad(i, j) + q_ad(i, j, 1, ic)
              q_ad(i, j, 1, ic) = 0.0_8
              qc_ad(i, j) = qc_ad(i, j) + q_ad(i, j, 2, ic)
              q_ad(i, j, 2, ic) = 0.0_8
              CALL POPREAL8(qc(i, j))
              temp_ad = qc_ad(i, j)/(mb(i, j)+cldmas(i, j, 2)*tdt)
              qb_ad(i, j) = qb_ad(i, j) + mb(i, j)*temp_ad
              q_ad(i, j, 3, ic) = q_ad(i, j, 3, ic) + cldmas(i, j, 2)*&
&               tdt*temp_ad
              qc_ad(i, j) = 0.0_8
              CALL POPREAL8(mb(i, j))
              temp_ad0 = qb_ad(i, j)/(delp(i, j, 1)+delp(i, j, 2))
              q_ad(i, j, 1, ic) = q_ad(i, j, 1, ic) + delp(i, j, 1)*&
&               temp_ad0
              q_ad(i, j, 2, ic) = q_ad(i, j, 2, ic) + delp(i, j, 2)*&
&               temp_ad0
              qb_ad(i, j) = 0.0_8
            END IF
          END DO
        END DO
      END DO
    END DO
  END SUBROUTINE CLDCNV_ADM
! ----------------------------------------------------------------------------------
  SUBROUTINE CLDCNV(i1, i2, j1, j2, km, n1, n2, dt_conv, aero_type, q, f&
&   , airmass, area, cldmas, dtrn, delz, delp)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: i1, i2, j1, j2, km, n1, n2, dt_conv
    CHARACTER(len=255) :: aero_type
    REAL*8, DIMENSION(i1:i2, j1:j2, km), INTENT(IN) :: airmass, cldmas, &
&   dtrn
    REAL*8, INTENT(IN) :: delz(i1:i2, j1:j2, km), delp(i1:i2, j1:j2, km)&
&   , area(i1:i2, j1:j2)
    REAL*8, INTENT(IN) :: f(i1:i2, j1:j2, km, n1:n2)
!  REAL*8, INTENT(INOUT) :: q(i1:i2,j1:j2,km,n1:n2), h2o2(i1:i2,j1:j2,km)
    REAL*8, INTENT(INOUT) :: q(i1:i2, j1:j2, km, n1:n2)
    REAL*8 :: bmass(i1:i2, j1:j2, km), qb(i1:i2, j1:j2), mb(i1:i2, j1:j2&
&   ), qc(i1:i2, j1:j2)
    REAL*8 :: tdt, qc_pres, cmout, entrn, delq, dq
    REAL*8 :: term_1, term_2, term_3, term_4, tsum
    INTEGER :: nsteps, ktop, jump, js, jn, ic, istep, i, j, k
    REAL*8, PARAMETER :: tiny=1.0e-14
    INTRINSIC MAX
    INTRINSIC REAL
! executable statements
! ============================================================================
!   Define active convective region,from J = JS(outh) to J = JN(orth),
!   and to level K = KTOP.
!
!   Polar regions are too cold to have moist convection.
!   (Dry convection should be done elsewhere.)
! ============================================================================
    ktop = km - 1
!  jump = (jmx - 1)/20
!  js = 1 + jump
!  jn = jmx - js + 1
!write(*,*) js, jn
!write(*,*) minval(q), maxval(q)
!write(*,*) minval(delp), maxval(delp)
! ============================================================================
!   Internal time step for convective mixing is 300 sec.
! ============================================================================
! Use fixed internal convection time step of 300s
! nstep: number of internal time steps to reach dt_conv, which is the external
! time interval for the convection process
    nsteps = dt_conv/300
    IF (nsteps .LT. 1) THEN
      nsteps = 1
    ELSE
      nsteps = nsteps
    END IF
    tdt = REAL(dt_conv)/REAL(nsteps)
! ============================================================================
!   Compute air mass of each grid box (I,J,K).
! ============================================================================
    DO k=1,km
      DO j=j1,j2
        DO i=i1,i2
          bmass(i, j, k) = airmass(i, j, k)/area(i, j)
        END DO
      END DO
    END DO
tracer_loop:DO ic=n1,n2
time_loop:DO istep=1,nsteps
! ============================================================================
!   (1) Below cloud base
!
!   If Cloud Mass Flux exists at (I,J,2), then compute QB.
!   QB is "weighted average" mixing ratio below the cloud base.
!   QB is used to compute QC, which is defined as:
!
!   QC =  ( Total mass of tracer below cloud base +
!           Subsidence into cloud base from above )
!        -------------------------------------------------------
!                 Total air mass below cloud base
!
!   MB is the total mass of air below the cloud base.
! ============================================================================
j_loop_1:DO j=j1,j2
 i_loop_1:DO i=i1,i2
            IF (cldmas(i, j, 2) .GT. tiny) THEN
              qb(i, j) = (q(i, j, 1, ic)*delp(i, j, 1)+q(i, j, 2, ic)*&
&               delp(i, j, 2))/(delp(i, j, 1)+delp(i, j, 2))
! alternative:
! use delz as weight
!                 qb(i,j) = (q(i,j,1,ic)*delz(i,j,1) + &
!                            q(i,j,2,ic)*delz(i,j,2)) / &
!                            (delz(i,j,1) + delz(i,j,2))
              mb(i, j) = bmass(i, j, 1) + bmass(i, j, 2)
              qc(i, j) = (mb(i, j)*qb(i, j)+cldmas(i, j, 2)*q(i, j, 3, &
&               ic)*tdt)/(mb(i, j)+cldmas(i, j, 2)*tdt)
! ============================================================================
!   Compute net change in mixing ratio.
!
!   DQ = QB - QC is the total mass to be transported out of the cloud base.
!   Changes below cloud base are proportional to the background mass.
!
!   Subtract DQ from Q(*,*,K=1,*) and from Q(*,*,K=2,*), but do not make
!   Q(*,*,K=1,*) or Q(*,*,K=2,*) negative.
! ============================================================================
! modification for now based on GEOS-CHEM
! should be revisited ...
!                 dq = qb(i,j) - qc(i,j)
!                 IF (dq > q(i,j,1,ic) .OR. dq > q(i,j,2,ic)) THEN
!                    q(i,j,2,ic) = qc(i,j)
!                    q(i,j,1,ic) = qc(i,j)
!                 ELSE
!                    q(i,j,2,ic) = q(i,j,2,ic) - dq
!                    q(i,j,1,ic) = q(i,j,1,ic) - dq
!                 END IF
              q(i, j, 2, ic) = qc(i, j)
              q(i, j, 1, ic) = qc(i, j)
! ============================================================================
!   If there is no Cloud mass flux, set QC = Q(K=3) at this I,J location
! ============================================================================
            ELSE
              qc(i, j) = q(i, j, 3, ic)
            END IF
          END DO i_loop_1
        END DO j_loop_1
! ============================================================================
!   (2) Cloud interior mixing
! ============================================================================
 k_loop:DO k=3,ktop
 j_loop_2:DO j=j1,j2
   i_loop_2:DO i=i1,i2
! ============================================================================
!   If there is cloud mass flux at this location, do the convective
!   transport.
!
!   QC_PRES = amount of QC preserved against wet scavenging
!   CMOUT = air mass flowing out of cloud at level K
!   ENTRN = air mass flowing into cloud at level K
!
!   If Entrainment >= 0 then compute the new value of QC(I,J):
!
!                  CLDMAS(K-1)*QC_PRES + ENTRN(K)*Q(K)
!      QC(I,J) =  ---------------------------------------
!                     CLDMAS(I,J,K) + DTRN(I,J,K)
!
!              =   tracer mass coming in from below      (i.e. level K-1) +
!                  tracer mass coming in from this level (i.e. level K)
!                 -----------------------------------------------------------
!                             total mass coming into cloud
!
!   Entrainment must be >= 0 (since we cannot have a negative flux of air
!   into the cloud).  This condition is strong enough to ensure that
!   CMOUT > 0 and will prevent floating-point exception.
! ============================================================================
              IF (cldmas(i, j, k-1) .GT. tiny) THEN
! Soluble species are scavenged during entrainment.
                qc_pres = qc(i, j)*(1.0-f(i, j, k, ic))
                cmout = cldmas(i, j, k) + dtrn(i, j, k)
                entrn = cmout - cldmas(i, j, k-1)
                IF (entrn .GE. 0.0) qc(i, j) = (cldmas(i, j, k-1)*&
&                   qc_pres+entrn*q(i, j, k, ic))/cmout
! ============================================================================
!   The cumulus transport above the cloud base is done as follows:
!      C_k-1  = cloud air mass flux from level k-1 to level k
!      C_k    = cloud air mass flux from level k to level k+1
!      QC_k-1 = mixing ratio of tracer INSIDE CLOUD in level k-1
!      QC_k   = mixing ratio of tracer INSIDE CLOUD in level k
!      Q_k    = mixing ratio of tracer in level k
!      Q_k+1  = mixing ratio of tracer in level k+1
!
!                        (       Cloud        )
!                        (                    )
!                        (                    )3)      C_k * Q_k+1
!             k+1        (         ^          )            |
!            ------------(---------|----------)------------|--------
!                        (         |          )            V
!                        (2)   C_k * QC_k     )
!                        (                    )
!             k          (                    )
!                        (         ^          )4)    C_k-1 * Q_k
!                        (         |          )            |
!            ------------(---------|----------)------------|----------
!             k-1        (         |          )            |
!                        (1) C_k-1 * QC_k-1   )            V
!                        (         * AP       )
!                        (                    )
!                        (                    )
!
!   There are 4 terms that contribute to mass flow in and out of level k:
!
!   1) C_k-1 * QC_PRES = tracer convected from level k-1 to level k
!   2) C_k   * QC_k    = tracer convected from level k   to level k+1
!   3) C_k   * Q_k+1   = tracer subsiding from level k+1 to level k
!   4) C_k-1 * Q_k     = tracer subsiding from level k   to level k-1
!
!   Therefore the change in tracer concentration is given by
!      DELQ = (Term 1) - (Term 2) + (Term 3) - (Term 4)
!
!   and Q(I,J,K,IC) = Q(I,J,K,IC) + DELQ
!
! ============================================================================
                term_1 = cldmas(i, j, k-1)*qc_pres
                term_2 = -(cldmas(i, j, k)*qc(i, j))
                term_3 = cldmas(i, j, k)*q(i, j, k+1, ic)
                term_4 = -(cldmas(i, j, k-1)*q(i, j, k, ic))
                tsum = term_1 + term_2 + term_3 + term_4
                delq = tdt/bmass(i, j, k)*tsum
                q(i, j, k, ic) = q(i, j, k, ic) + delq
! prevent concentrations from being negative
                IF (q(i, j, k, ic) .LT. 1.0e-32) q(i, j, k, ic) = &
&                   1.0e-32
              ELSE
! ============================================================================
!   No cloud transport if cloud mass flux < TINY; Change Qc to q
! ============================================================================
                qc(i, j) = q(i, j, k, ic)
!--------------------------------------------------
! FIX FOR GEOS-5 MET FIELDS!
!
! Bug fix for the cloud base layer, which is not
! necessarily in the boundary layer, and for
! GEOS-5, there could be "secondary convection
! plumes - one in the PBL and another one not.
!
! NOTE: TERM_2 and TERM_3 are the same terms as described
! in the above section.
!
! (swu, 08/13/2007)
!--------------------------------------------------
                IF (cldmas(i, j, k) .GT. tiny) THEN
! Tracer convected from K -> K+1
                  term_2 = -(cldmas(i, j, k)*qc(i, j))
! Tracer subsiding from K+1 -> K
                  term_3 = cldmas(i, j, k)*q(i, j, k+1, ic)
! Change in tracer concentration
                  delq = tdt/bmass(i, j, k)*(term_2+term_3)
! Add change in tracer to Q array
                  q(i, j, k, ic) = q(i, j, k, ic) + delq
! prevent concentrations from being negative
                  IF (q(i, j, k, ic) .LT. 1.0e-32) q(i, j, k, ic) = &
&                     1.0e-32
                END IF
              END IF
            END DO i_loop_2
          END DO j_loop_2
        END DO k_loop
      END DO time_loop
    END DO tracer_loop
  END SUBROUTINE CLDCNV
END MODULE CONVECTIONMOD_B
