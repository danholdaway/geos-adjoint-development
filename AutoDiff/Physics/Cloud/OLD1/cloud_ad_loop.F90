MODULE CLOUD_AD

USE cloudmod
USE cloud_tl, only: LS_CLOUD_D

IMPLICIT NONE

PRIVATE
PUBLIC CLOUD_B

CONTAINS
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.7 (r4786) - 21 Feb 2013 15:53
!
!  Differentiation of cloud in reverse (adjoint) mode:
!   gradient     of useful results: th qi_con cnv_prc3 q cf_ls
!                cf_con ql_ls ql_con qi_ls
!   with respect to varying inputs: th qi_con cnv_prc3 q cnv_dqldt
!                cf_ls cnv_updf cf_con cnv_mfd ql_ls ql_con qi_ls
!   RW status of diff variables: th:in-out qi_con:in-out cnv_prc3:in-out
!                q:in-out cnv_dqldt:out cf_ls:in-out cnv_updf:out
!                cf_con:in-out cnv_mfd:out ql_ls:in-out ql_con:in-out
!                qi_ls:in-out
SUBROUTINE CLOUD_B(dt, im, jm, lm, th, thb, q, qb, ple, kh, cnv_dqldt, &
&  cnv_dqldtb, cnv_mfd, cnv_mfdb, cnv_prc3, cnv_prc3b, cnv_updf, &
&  cnv_updfb, qi_ls, qi_lsb, ql_ls, ql_lsb, qi_con, qi_conb, ql_con, &
&  ql_conb, cf_ls, cf_lsb, cf_con, cf_conb, frland, physparams, estblx, &
&  khu, khl, cons_runiv, cons_kappa, cons_airmw, cons_h2omw, cons_grav, &
&  cons_alhl, cons_alhf, cons_pi, cons_rgas, cons_cp, cons_vireps, &
&  cons_alhs, cons_tice, cons_rvap, cons_p00)
  IMPLICIT NONE
!INPUTS
  INTEGER, INTENT(IN) :: im, jm, lm
  REAL*4, INTENT(IN) :: dt, frland(im, jm), physparams(:)
  REAL*4, DIMENSION(im, jm, lm), INTENT(IN) :: cnv_dqldt, cnv_mfd, &
&  cnv_updf
  REAL*4, DIMENSION(im, jm, lm) :: cnv_dqldtb, cnv_mfdb, cnv_updfb
  REAL*4, INTENT(IN) :: estblx(:)
  REAL*4, DIMENSION(im, jm, 0:lm), INTENT(IN) :: ple, kh
  INTEGER, DIMENSION(im, jm), INTENT(IN) :: khu, khl
!MAPL_CONSTANTS REDEFINED FOR USE IN AUTODIFF TOOL
  REAL*4, INTENT(IN) :: cons_runiv, cons_kappa, cons_airmw
  REAL*4, INTENT(IN) :: cons_h2omw, cons_grav, cons_alhl
  REAL*4, INTENT(IN) :: cons_alhf, cons_pi, cons_rgas
  REAL*4, INTENT(IN) :: cons_cp, cons_vireps, cons_alhs
  REAL*4, INTENT(IN) :: cons_tice, cons_rvap, cons_p00
!PROGNOSTICS
  REAL*4, DIMENSION(im, jm, lm), INTENT(INOUT) :: th, q
  REAL*4, DIMENSION(im, jm, lm), INTENT(INOUT) :: thb
  REAL*4, DIMENSION(im, jm, lm), INTENT(INOUT) :: qi_ls, ql_ls, qi_con, &
&  ql_con, cf_con, cf_ls
  REAL*4, DIMENSION(im, jm, lm), INTENT(INOUT) :: qi_lsb
  REAL*4, DIMENSION(im, jm, lm), INTENT(INOUT) :: cnv_prc3
  REAL*4, DIMENSION(im, jm, lm), INTENT(INOUT) :: cnv_prc3b
!OUTPUTS (DIAGNOSTICS)
!LOCALS
  INTEGER :: i, j, k, l
  REAL*4, DIMENSION(im, jm, lm) :: ph, pih, mass, imass, t, dzet, qddf3&
&  , rh, dp, dm
  REAL*4, DIMENSION(im, jm, lm) :: tb, dzetb, qddf3b
  REAL*4, DIMENSION(im, jm, lm + 1) :: zet
  REAL*4, DIMENSION(im, jm, lm+1) :: zetb
  REAL*4, DIMENSION(im, jm, 0:lm) :: p, pi
  REAL*4, DIMENSION(im, jm, lm) :: qs, dqsdt, dqs
  REAL*4, DIMENSION(im, jm, lm) :: qsb
  REAL*4, DIMENSION(im, jm) :: vmip
  REAL*4, DIMENSION(im, jm) :: vmipb
!Precip amounts and fall rate
  REAL*4 :: cf_tot
  REAL*4 :: cf_totb
  REAL*4 :: alpha, alhx3, rhcrit
  REAL*4 :: alhx3b
!Microphyiscal constants
  REAL*4 :: aa, bb
  REAL*4 :: aab, bbb
  REAL*4, PARAMETER :: pi_0=4.*ATAN(1.)
!Density of liquid water in kg/m^3
  REAL*4, PARAMETER :: rho_w=1.0e3
  REAL*4 :: t_ice_max
!PHYSPARAMS constants
  REAL*4 :: cnv_beta, anv_beta, ls_beta, rh00, c_00, lwcrit, c_acc, &
&  c_ev_r, c_ev_s, cldvol2frc
  REAL*4 :: rhsup_ice, shr_evap_fac, min_cld_water, cld_evp_eff, &
&  ls_sdqv2, ls_sdqv3, ls_sdqvt1
  REAL*4 :: anv_sdqv2, anv_sdqv3, anv_sdqvt1, anv_to_ls, n_warm, n_ice, &
&  n_anvil, n_pbl
  REAL*4 :: anv_icefall_c, ls_icefall_c, revap_off_p, cnvenvfc, wrhodep&
&  , t_ice_all, cnviceparam
  REAL*4 :: cnvddrfc, anvddrfc, lsddrfc, minrhcrit, maxrhcrit, &
&  turnrhcrit, maxrhcritland
  REAL*4 :: min_rl, min_ri, max_rl, max_ri, ri_anv
  INTEGER :: nsmax, disable_rad, icefrpwr, tanhrhcrit, fr_ls_wat, &
&  fr_ls_ice, fr_an_wat, fr_an_ice, pdfflag
  REAL*4 :: lsenvfc, anvenvfc
  REAL*4 :: qrn_cu, qsn_cu, qrn_an, qsn_an, qrn_ls, qsn_ls, qrn_cu_1d
  REAL*4 :: qsn_cub, qrn_anb, qsn_anb, qrn_lsb, qsn_lsb, qrn_cu_1db
  REAL*4 :: qt_tmpi_1, qt_tmpi_2, qlt_tmp, qit_tmp
  REAL*4 :: qt_tmpi_1b, qt_tmpi_2b, qlt_tmpb, qit_tmpb
  REAL*4 :: prn_above_cu_new, prn_above_an_new, prn_above_ls_new
  REAL*4 :: prn_above_cu_newb, prn_above_an_newb, prn_above_ls_newb
  REAL*4 :: prn_above_cu_old, prn_above_an_old, prn_above_ls_old
  REAL*4 :: prn_above_cu_oldb, prn_above_an_oldb, prn_above_ls_oldb
  REAL*4 :: psn_above_cu_new, psn_above_an_new, psn_above_ls_new
  REAL*4 :: psn_above_cu_newb, psn_above_an_newb, psn_above_ls_newb
  REAL*4 :: psn_above_cu_old, psn_above_an_old, psn_above_ls_old
  REAL*4 :: psn_above_cu_oldb, psn_above_an_oldb, psn_above_ls_oldb
  REAL*4 :: evap_dd_cu_above_new, evap_dd_an_above_new, &
&  evap_dd_ls_above_new
  REAL*4 :: evap_dd_cu_above_newb, evap_dd_an_above_newb, &
&  evap_dd_ls_above_newb
  REAL*4 :: evap_dd_cu_above_old, evap_dd_an_above_old, &
&  evap_dd_ls_above_old
  REAL*4 :: evap_dd_cu_above_oldb, evap_dd_an_above_oldb, &
&  evap_dd_ls_above_oldb
  REAL*4 :: subl_dd_cu_above_new, subl_dd_an_above_new, &
&  subl_dd_ls_above_new
  REAL*4 :: subl_dd_cu_above_newb, subl_dd_an_above_newb, &
&  subl_dd_ls_above_newb
  REAL*4 :: subl_dd_cu_above_old, subl_dd_an_above_old, &
&  subl_dd_ls_above_old
  REAL*4 :: subl_dd_cu_above_oldb, subl_dd_an_above_oldb, &
&  subl_dd_ls_above_oldb
  REAL*4 :: area_ls_prc1, area_upd_prc1, area_anv_prc1
  REAL*4 :: area_ls_prc1b, area_upd_prc1b, area_anv_prc1b
  REAL*4 :: tot_prec_upd, tot_prec_anv, tot_prec_ls, area_upd_prc, &
&  area_anv_prc, area_ls_prc
  REAL*4 :: tot_prec_updb, tot_prec_anvb, tot_prec_lsb, area_upd_prcb, &
&  area_anv_prcb, area_ls_prcb
  REAL*4 :: qtmp2
  REAL*4 :: rhexcess, tpw, negtpw
  INTEGER :: branch
  REAL*4, DIMENSION(im, jm, lm), INTENT(INOUT) :: qb
  REAL*4, DIMENSION(im, jm, lm), INTENT(INOUT) :: ql_lsb
  REAL*4, DIMENSION(im, jm, lm), INTENT(INOUT) :: ql_conb
  REAL*4, DIMENSION(im, jm, lm), INTENT(INOUT) :: qi_conb
  REAL*4, DIMENSION(im, jm, lm), INTENT(INOUT) :: cf_conb
  REAL*4, DIMENSION(im, jm, lm), INTENT(INOUT) :: cf_lsb
  REAL*4 :: temp0
  REAL*4 :: tempb8
  REAL*4 :: tempb7
  REAL*4 :: tempb6
  REAL*4 :: tempb5
  REAL*4 :: tempb4
  REAL*4 :: tempb3
  REAL*4 :: tempb2
  REAL*4 :: tempb1
  REAL*4 :: tempb0
  REAL*4 :: temp0b
  INTRINSIC MAX
  INTRINSIC SUM
  REAL*4 :: tempb
  REAL*4 :: temp0b1
  REAL*4 :: temp0b0
  INTRINSIC INT
  INTRINSIC ATAN
  REAL*4 :: temp1b
  LOGICAL :: mask(im, jm, lm)
  REAL*4 :: temp
  REAL*4 :: temp1b0
!FILTERINGINSERT1

  !LS_CLOUD FILTERING
  integer :: ii, kk1, kk2
  real(8) :: xx(8) 
  real(8) :: ttraj, qtraj, qi_lstraj, qi_contraj, ql_lstraj, ql_contraj, cf_lstraj, cf_contraj, phtraj 
  real(8) :: tpert, qpert, qi_lspert, qi_conpert, ql_lspert, ql_conpert, cf_lspert, cf_conpert
  real(8) :: tpert_in, qpert_in, qi_lspert_in, qi_conpert_in, ql_lspert_in, ql_conpert_in
  real(8) :: cf_lspert_in, cf_conpert_in
  real(8) :: Jacobian(8,8)
  real(8) :: filt_lsc, filt_lscT, filt_T, filt_ql
  real(8), parameter :: cfls_T_filt = 0.25e-3
  real(8), parameter :: cfls_q_filt = 1.0
  real(8) :: t_p_prelsc, q_p_prelsc
  real(8) :: qi_ls_p_prelsc, qi_con_p_prelsc, ql_ls_p_prelsc, ql_con_p_prelsc
  real(8) :: cf_ls_p_prelsc, cf_con_p_prelsc
  real(8), dimension(im, jm, lm) :: tp_in, ql_lsp_in, ql_conp_in

  filt_T = 0.5
  filt_ql = 0.5
  Jacobian = 0.0

!Get Constants from CLOUDPARAMS
! Area factor for convective rain showers (non-dim)
  cnv_beta = physparams(1)
! Area factor for anvil rain showers (non-dim)
  anv_beta = physparams(2)
! Area factor for Large Scale rain showers (non-dim)
  ls_beta = physparams(3)
! Critical relative humidity
  rh00 = physparams(4)
  c_00 = physparams(5)
  lwcrit = physparams(6)
  c_acc = physparams(7)
  c_ev_r = physparams(8)
  c_ev_s = physparams(56)
  cld_evp_eff = physparams(13)
  ls_sdqv2 = physparams(15)
  ls_sdqv3 = physparams(16)
  ls_sdqvt1 = physparams(17)
  anv_sdqv2 = physparams(18)
  anv_sdqv3 = physparams(19)
  anv_sdqvt1 = physparams(20)
  anv_icefall_c = physparams(28)
  ls_icefall_c = physparams(29)
  revap_off_p = physparams(30)
  cnvenvfc = physparams(31)
  wrhodep = physparams(32)
  t_ice_all = physparams(33) + cons_tice
  icefrpwr = INT(physparams(35) + .001)
  cnvddrfc = physparams(36)
  anvddrfc = physparams(37)
  lsddrfc = physparams(38)
  minrhcrit = physparams(42)
  maxrhcrit = physparams(43)
  turnrhcrit = physparams(45)
  maxrhcritland = physparams(46)
  pdfflag = INT(physparams(57))
  t_ice_max = cons_tice
!Initialize the saving of downdraft values.
  prn_above_cu_new = 0.
  prn_above_an_new = 0.
  prn_above_ls_new = 0.
  psn_above_cu_new = 0.
  psn_above_an_new = 0.
  psn_above_ls_new = 0.
  evap_dd_cu_above_new = 0.
  evap_dd_an_above_new = 0.
  evap_dd_ls_above_new = 0.
  subl_dd_cu_above_new = 0.
  subl_dd_an_above_new = 0.
  subl_dd_ls_above_new = 0.
!Convert to hPa and average pressure to temperature levels
  p = ple*0.01
  ph = 0.5*(p(:, :, 0:lm-1)+p(:, :, 1:lm))
!Calculate Exner Pressure at temperature levels
  pi = (p/1000.)**(cons_rgas/cons_cp)
  pih = (ph/1000.)**(cons_rgas/cons_cp)
!Calculate temperature
  t = th*pih
!Compute QS and DQSDT
  CALL DQSAT_BAC(dqsdt, qs, t, ph, im, jm, lm, estblx, cons_h2omw, &
&           cons_airmw)
!Relative humidity
!Compute layer mass and 1/mass
  mass = (p(:, :, 1:lm)-p(:, :, 0:lm-1))*100./cons_grav
  imass = 1/mass
!Level thickness
  dzet(:, :, 1:lm) = th(:, :, 1:lm)*(pi(:, :, 1:lm)-pi(:, :, 0:lm-1))*&
&    cons_cp/cons_grav
!Level heights
  zet(:, :, lm+1) = 0.0
  DO k=lm,1,-1
    zet(:, :, k) = zet(:, :, k+1) + dzet(:, :, k)
  END DO
  mask(:, :, 1:lm) = zet(:, :, 1:lm) .LT. 3000.
  WHERE (mask(:, :, 1:lm)) 
    qddf3 = -((zet(:, :, 1:lm)-3000.)*zet(:, :, 1:lm)*mass)
  ELSEWHERE
    qddf3 = 0.
  END WHERE
  DO i=1,im
    DO j=1,jm
      vmip(i, j) = SUM(qddf3(i, j, :))
    END DO
  END DO
  DO k=1,lm
    CALL PUSHREAL4ARRAY(qddf3(:, :, k), im*jm)
    qddf3(:, :, k) = qddf3(:, :, k)/vmip
  END DO
!Begin loop over all grid boxes.
  DO i=1,im
    DO j=1,jm
      DO k=1,lm
        IF (k .EQ. 1) THEN
          CALL PUSHREAL4(tot_prec_upd)
          tot_prec_upd = 0.
          CALL PUSHREAL4(tot_prec_anv)
          tot_prec_anv = 0.
          CALL PUSHREAL4(tot_prec_ls)
          tot_prec_ls = 0.
          CALL PUSHREAL4(area_upd_prc)
          area_upd_prc = 0.
          CALL PUSHREAL4(area_anv_prc)
          area_anv_prc = 0.
          CALL PUSHREAL4(area_ls_prc)
          area_ls_prc = 0.
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
!Initialize precips, except QRN_CU which comes from RAS 
        qrn_ls = 0.
        qrn_an = 0.
        qsn_ls = 0.
        qsn_an = 0.
        qsn_cu = 0.
!Ras Rain         
        qrn_cu_1d = cnv_prc3(i, j, k)
        CALL PUSHREAL4(cf_con(i, j, k))
        CALL PUSHREAL4(qi_con(i, j, k))
        CALL PUSHREAL4(ql_con(i, j, k))
        CALL PUSHREAL4(cf_ls(i, j, k))
        CALL PUSHREAL4(qi_ls(i, j, k))
        CALL PUSHREAL4(ql_ls(i, j, k))
        CALL PUSHREAL4(t(i, j, k))
!Tidy up where fractions or cloud is too low
        CALL CLOUD_TIDY(q(i, j, k), t(i, j, k), ql_ls(i, j, k), qi_ls(i&
&                  , j, k), cf_ls(i, j, k), ql_con(i, j, k), qi_con(i, j&
&                  , k), cf_con(i, j, k), cons_alhl, cons_alhs, cons_cp)
        CALL PUSHREAL4(qi_ls(i, j, k))
        CALL PUSHREAL4(ql_ls(i, j, k))
        CALL PUSHREAL4(t(i, j, k))
!Phase changes for large scale cloud.
        CALL MELTFREEZE(dt, t(i, j, k), ql_ls(i, j, k), qi_ls(i, j, k), &
&                  t_ice_all, t_ice_max, icefrpwr, cons_alhl, cons_alhs, &
&                  cons_cp)
        CALL PUSHREAL4(qi_con(i, j, k))
        CALL PUSHREAL4(ql_con(i, j, k))
        CALL PUSHREAL4(t(i, j, k))
!Phase changes for convective cloud.
        CALL MELTFREEZE(dt, t(i, j, k), ql_con(i, j, k), qi_con(i, j, k)&
&                  , t_ice_all, t_ice_max, icefrpwr, cons_alhl, cons_alhs&
&                  , cons_cp)
        CALL PUSHREAL4(cf_con(i, j, k))
        CALL PUSHREAL4(qi_con(i, j, k))
        CALL PUSHREAL4(ql_con(i, j, k))
        CALL PUSHREAL4(q(i, j, k))
        CALL PUSHREAL4(t(i, j, k))
!STAGE 1 - Compute convective clouds from RAS diagnostics
        CALL CONVEC_SRC(dt, mass(i, j, k), imass(i, j, k), t(i, j, k), q&
&                  (i, j, k), cnv_dqldt(i, j, k), cnv_mfd(i, j, k), &
&                  ql_con(i, j, k), qi_con(i, j, k), cf_con(i, j, k), qs(&
&                  i, j, k), cons_alhs, cons_alhl, cons_cp, t_ice_all, &
&                  t_ice_max, icefrpwr)
        CALL PUSHREAL4(alpha)
!STAGE 2a - Get PDF attributes
        CALL PDF_WIDTH(ph(i, j, k), frland(i, j), maxrhcrit, &
&                 maxrhcritland, turnrhcrit, minrhcrit, pi_0, alpha)
        IF (alpha .LT. 1.0 - rh00) THEN
          alpha = 1.0 - rh00
        ELSE
          alpha = alpha
        END IF
        CALL PUSHREAL4(rhcrit)
        rhcrit = 1.0 - alpha
        CALL PUSHREAL4(cf_con(i, j, k))
        CALL PUSHREAL4(cf_ls(i, j, k))
        CALL PUSHREAL4(qi_con(i, j, k))
        CALL PUSHREAL4(qi_ls(i, j, k))
        CALL PUSHREAL4(ql_con(i, j, k))
        CALL PUSHREAL4(ql_ls(i, j, k))
        CALL PUSHREAL4(q(i, j, k))
        CALL PUSHREAL4(t(i, j, k))
!STAGE 2b - Use PDF to compute large scale cloud effects and diagnostics,
!           also update convection clouds
        CALL LS_CLOUD(dt, alpha, pdfflag, ph(i, j, k), t(i, j, k), q(i, &
&                j, k), ql_ls(i, j, k), ql_con(i, j, k), qi_ls(i, j, k), &
&                qi_con(i, j, k), cf_ls(i, j, k), cf_con(i, j, k), &
&                cons_alhl, cons_alhf, cons_alhs, cons_cp, cons_h2omw, &
&                cons_airmw, t_ice_all, t_ice_max, icefrpwr, estblx)
        CALL PUSHREAL4(cf_tot)
!Clean up where too much overall cloud.
        cf_tot = cf_ls(i, j, k) + cf_con(i, j, k)
        IF (cf_tot .GT. 1.00) THEN
          CALL PUSHREAL4(cf_ls(i, j, k))
          cf_ls(i, j, k) = cf_ls(i, j, k)*(1.00/cf_tot)
          CALL PUSHREAL4(cf_con(i, j, k))
          cf_con(i, j, k) = cf_con(i, j, k)*(1.00/cf_tot)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHREAL4(cf_con(i, j, k))
        CALL PUSHREAL4(ql_con(i, j, k))
        CALL PUSHREAL4(q(i, j, k))
        CALL PUSHREAL4(t(i, j, k))
!STAGE 3 - Evap, Sublimation and Autoconversion
!Evaporation and sublimation of anvil cloud
        CALL EVAP_CNV(dt, rhcrit, ph(i, j, k), t(i, j, k), q(i, j, k), &
&                ql_con(i, j, k), qi_con(i, j, k), cf_con(i, j, k), cf_ls&
&                (i, j, k), qs(i, j, k), rho_w, cld_evp_eff, cons_h2omw, &
&                cons_airmw, cons_alhl, cons_rvap, cons_rgas, cons_pi, &
&                cons_cp)
        CALL PUSHREAL4(cf_con(i, j, k))
        CALL PUSHREAL4(qi_con(i, j, k))
        CALL PUSHREAL4(q(i, j, k))
        CALL PUSHREAL4(t(i, j, k))
        CALL SUBL_CNV(dt, rhcrit, ph(i, j, k), t(i, j, k), q(i, j, k), &
&                ql_con(i, j, k), qi_con(i, j, k), cf_con(i, j, k), cf_ls&
&                (i, j, k), qs(i, j, k), rho_w, cld_evp_eff, cons_h2omw, &
&                cons_airmw, cons_alhl, cons_rvap, cons_rgas, cons_pi, &
&                cons_cp, cons_alhs)
        CALL PUSHREAL4(cf_ls(i, j, k))
        CALL PUSHREAL4(ql_ls(i, j, k))
!Autoconversion
        CALL AUTOCONVERSION_LS(dt, ql_ls(i, j, k), qrn_ls, t(i, j, k), &
&                         ph(i, j, k), cf_ls(i, j, k), ls_sdqv2, ls_sdqv3&
&                         , ls_sdqvt1, c_00, lwcrit, dzet(i, j, k))
        CALL PUSHREAL4(ql_con(i, j, k))
        CALL AUTOCONVERSION_CNV(dt, ql_con(i, j, k), qrn_an, t(i, j, k)&
&                          , ph(i, j, k), cf_con(i, j, k), anv_sdqv2, &
&                          anv_sdqv3, anv_sdqvt1, c_00, lwcrit, dzet(i, j&
&                          , k))
        CALL PUSHREAL4(qi_con(i, j, k))
!STAGE 4 - Fall and Re-evaporation of precip
        CALL ICE_SETTLEFALL_CNV(wrhodep, qi_con(i, j, k), ph(i, j, k), t&
&                          (i, j, k), cf_con(i, j, k), cons_rgas, kh(i, j&
&                          , k-1), khu(i, j), khl(i, j), k, dt, dzet(i, j&
&                          , k), qsn_an, anv_icefall_c)
        CALL PUSHREAL4(cf_ls(i, j, k))
        CALL PUSHREAL4(qi_ls(i, j, k))
        CALL ICE_SETTLEFALL_LS(wrhodep, qi_ls(i, j, k), ph(i, j, k), t(i&
&                         , j, k), cf_ls(i, j, k), cons_rgas, kh(i, j, k-&
&                         1), khu(i, j), khl(i, j), k, dt, dzet(i, j, k)&
&                         , qsn_ls, ls_icefall_c)
!"Freeze" out any conv. precip, not done in RAS. This is
! precip w/ large particles, so freezing is strict.
        IF (t(i, j, k) .LT. cons_tice) THEN
          qsn_cu = qrn_cu_1d
          qrn_cu_1d = 0.
          CALL PUSHREAL4(t(i, j, k))
          t(i, j, k) = t(i, j, k) + qsn_cu*(cons_alhs-cons_alhl)/cons_cp
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHREAL4(area_ls_prc1)
!Area
        area_ls_prc1 = 0.0
        CALL PUSHREAL4(area_upd_prc1)
        area_upd_prc1 = 0.0
        CALL PUSHREAL4(area_anv_prc1)
        area_anv_prc1 = 0.0
        CALL PUSHREAL4(tot_prec_upd)
        tot_prec_upd = tot_prec_upd + (qrn_cu_1d+qsn_cu)*mass(i, j, k)
        CALL PUSHREAL4(area_upd_prc)
        area_upd_prc = area_upd_prc + cnv_updf(i, j, k)*(qrn_cu_1d+&
&          qsn_cu)*mass(i, j, k)
        CALL PUSHREAL4(tot_prec_anv)
        tot_prec_anv = tot_prec_anv + (qrn_an+qsn_an)*mass(i, j, k)
        CALL PUSHREAL4(area_anv_prc)
        area_anv_prc = area_anv_prc + cf_con(i, j, k)*(qrn_an+qsn_an)*&
&          mass(i, j, k)
        CALL PUSHREAL4(tot_prec_ls)
        tot_prec_ls = tot_prec_ls + (qrn_ls+qsn_ls)*mass(i, j, k)
        CALL PUSHREAL4(area_ls_prc)
        area_ls_prc = area_ls_prc + cf_ls(i, j, k)*(qrn_ls+qsn_ls)*mass(&
&          i, j, k)
        IF (tot_prec_anv .GT. 0.0) THEN
          IF (area_anv_prc/tot_prec_anv .LT. 1.e-6) THEN
            CALL PUSHCONTROL2B(2)
            area_anv_prc1 = 1.e-6
          ELSE
            area_anv_prc1 = area_anv_prc/tot_prec_anv
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
        IF (tot_prec_upd .GT. 0.0) THEN
          IF (area_upd_prc/tot_prec_upd .LT. 1.e-6) THEN
            CALL PUSHCONTROL2B(2)
            area_upd_prc1 = 1.e-6
          ELSE
            area_upd_prc1 = area_upd_prc/tot_prec_upd
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
        IF (tot_prec_ls .GT. 0.0) THEN
          IF (area_ls_prc/tot_prec_ls .LT. 1.e-6) THEN
            CALL PUSHCONTROL2B(2)
            area_ls_prc1 = 1.e-6
          ELSE
            area_ls_prc1 = area_ls_prc/tot_prec_ls
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
        area_ls_prc1 = ls_beta*area_ls_prc1
        area_upd_prc1 = cnv_beta*area_upd_prc1
        area_anv_prc1 = anv_beta*area_anv_prc1
        IF (k .EQ. lm) THEN
! We have accumulated over the whole column
          IF (tot_prec_anv .GT. 0.0) THEN
            IF (area_anv_prc/tot_prec_anv .LT. 1.e-6) THEN
              CALL PUSHREAL4(area_anv_prc)
              area_anv_prc = 1.e-6
              CALL PUSHCONTROL2B(2)
            ELSE
              CALL PUSHREAL4(area_anv_prc)
              area_anv_prc = area_anv_prc/tot_prec_anv
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B(0)
          END IF
          IF (tot_prec_upd .GT. 0.0) THEN
            IF (area_upd_prc/tot_prec_upd .LT. 1.e-6) THEN
              CALL PUSHREAL4(area_upd_prc)
              area_upd_prc = 1.e-6
              CALL PUSHCONTROL2B(2)
            ELSE
              CALL PUSHREAL4(area_upd_prc)
              area_upd_prc = area_upd_prc/tot_prec_upd
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B(0)
          END IF
          IF (tot_prec_ls .GT. 0.0) THEN
            IF (area_ls_prc/tot_prec_ls .LT. 1.e-6) THEN
              CALL PUSHREAL4(area_ls_prc)
              area_ls_prc = 1.e-6
              CALL PUSHCONTROL2B(2)
            ELSE
              CALL PUSHREAL4(area_ls_prc)
              area_ls_prc = area_ls_prc/tot_prec_ls
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B(0)
          END IF
          CALL PUSHREAL4(area_ls_prc)
          area_ls_prc = ls_beta*area_ls_prc
          CALL PUSHREAL4(area_upd_prc)
          area_upd_prc = cnv_beta*area_upd_prc
          CALL PUSHREAL4(area_anv_prc)
          area_anv_prc = anv_beta*area_anv_prc
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHREAL4(alhx3)
!Get micro-physical constants
        CALL CONS_ALHX(t(i, j, k), alhx3, t_ice_max, t_ice_all, &
&                 cons_alhs, cons_alhl)
        CALL PUSHREAL4(bb)
        CALL PUSHREAL4(aa)
        CALL CONS_MICROPHYS(t(i, j, k), ph(i, j, k), qs(i, j, k), aa, bb&
&                      , cons_h2omw, cons_airmw, cons_rvap, alhx3)
        CALL PUSHREAL4(qlt_tmp)
!Precip Scheme Expects Total Cloud Liquid
        qlt_tmp = ql_ls(i, j, k) + ql_con(i, j, k)
        CALL PUSHREAL4(qit_tmp)
        qit_tmp = qi_ls(i, j, k) + qi_con(i, j, k)
        CALL PUSHREAL4(prn_above_cu_old)
        prn_above_cu_old = prn_above_cu_new
        CALL PUSHREAL4(psn_above_cu_old)
        psn_above_cu_old = psn_above_cu_new
        CALL PUSHREAL4(evap_dd_cu_above_old)
        evap_dd_cu_above_old = evap_dd_cu_above_new
        CALL PUSHREAL4(subl_dd_cu_above_old)
        subl_dd_cu_above_old = subl_dd_cu_above_new
        CALL PUSHREAL4(q(i, j, k))
        CALL PUSHREAL4(t(i, j, k))
        CALL PUSHREAL4(qlt_tmp)
        CALL PUSHREAL4(qsn_cu)
        CALL PUSHREAL4(qrn_cu_1d)
!Precip and Evap for Convection
        CALL PRECIPANDEVAP(k, lm, dt, frland(i, j), rhcrit, qrn_cu_1d, &
&                     qsn_cu, qlt_tmp, qit_tmp, t(i, j, k), q(i, j, k), &
&                     mass(i, j, k), imass(i, j, k), ph(i, j, k), dzet(i&
&                     , j, k), qddf3(i, j, k), aa, bb, area_upd_prc1, &
&                     prn_above_cu_old, prn_above_cu_new, &
&                     psn_above_cu_old, psn_above_cu_new, &
&                     evap_dd_cu_above_old, evap_dd_cu_above_new, &
&                     subl_dd_cu_above_old, subl_dd_cu_above_new, &
&                     cnvenvfc, cnvddrfc, cons_alhf, cons_alhs, cons_alhl&
&                     , cons_cp, cons_tice, cons_h2omw, cons_airmw, &
&                     revap_off_p, c_acc, c_ev_r, c_ev_s, rho_w, estblx)
        CALL PUSHREAL4(prn_above_an_old)
        prn_above_an_old = prn_above_an_new
        CALL PUSHREAL4(psn_above_an_old)
        psn_above_an_old = psn_above_an_new
        CALL PUSHREAL4(evap_dd_an_above_old)
        evap_dd_an_above_old = evap_dd_an_above_new
        CALL PUSHREAL4(subl_dd_an_above_old)
        subl_dd_an_above_old = subl_dd_an_above_new
!Precip and Evap for Anvil
        anvenvfc = 1.0
        CALL PUSHREAL4(q(i, j, k))
        CALL PUSHREAL4(t(i, j, k))
        CALL PUSHREAL4(qlt_tmp)
        CALL PUSHREAL4(qsn_an)
        CALL PUSHREAL4(qrn_an)
        CALL PRECIPANDEVAP(k, lm, dt, frland(i, j), rhcrit, qrn_an, &
&                     qsn_an, qlt_tmp, qit_tmp, t(i, j, k), q(i, j, k), &
&                     mass(i, j, k), imass(i, j, k), ph(i, j, k), dzet(i&
&                     , j, k), qddf3(i, j, k), aa, bb, area_anv_prc1, &
&                     prn_above_an_old, prn_above_an_new, &
&                     psn_above_an_old, psn_above_an_new, &
&                     evap_dd_an_above_old, evap_dd_an_above_new, &
&                     subl_dd_an_above_old, subl_dd_an_above_new, &
&                     anvenvfc, anvddrfc, cons_alhf, cons_alhs, cons_alhl&
&                     , cons_cp, cons_tice, cons_h2omw, cons_airmw, &
&                     revap_off_p, c_acc, c_ev_r, c_ev_s, rho_w, estblx)
        CALL PUSHREAL4(prn_above_ls_old)
        prn_above_ls_old = prn_above_ls_new
        CALL PUSHREAL4(psn_above_ls_old)
        psn_above_ls_old = psn_above_ls_new
        CALL PUSHREAL4(evap_dd_ls_above_old)
        evap_dd_ls_above_old = evap_dd_ls_above_new
        CALL PUSHREAL4(subl_dd_ls_above_old)
        subl_dd_ls_above_old = subl_dd_ls_above_new
!Precip and Evap for Large Scale
        lsenvfc = 1.0
        CALL PUSHREAL4(q(i, j, k))
        CALL PUSHREAL4(t(i, j, k))
        CALL PUSHREAL4(qlt_tmp)
        CALL PUSHREAL4(qsn_ls)
        CALL PUSHREAL4(qrn_ls)
        CALL PRECIPANDEVAP(k, lm, dt, frland(i, j), rhcrit, qrn_ls, &
&                     qsn_ls, qlt_tmp, qit_tmp, t(i, j, k), q(i, j, k), &
&                     mass(i, j, k), imass(i, j, k), ph(i, j, k), dzet(i&
&                     , j, k), qddf3(i, j, k), aa, bb, area_ls_prc1, &
&                     prn_above_ls_old, prn_above_ls_new, &
&                     psn_above_ls_old, psn_above_ls_new, &
&                     evap_dd_ls_above_old, evap_dd_ls_above_new, &
&                     subl_dd_ls_above_old, subl_dd_ls_above_new, lsenvfc&
&                     , lsddrfc, cons_alhf, cons_alhs, cons_alhl, cons_cp&
&                     , cons_tice, cons_h2omw, cons_airmw, revap_off_p, &
&                     c_acc, c_ev_r, c_ev_s, rho_w, estblx)
        IF (ql_ls(i, j, k) + ql_con(i, j, k) .GT. 0.00) THEN
          CALL PUSHREAL4(qt_tmpi_1)
          qt_tmpi_1 = 1./(ql_ls(i, j, k)+ql_con(i, j, k))
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL4(qt_tmpi_1)
          qt_tmpi_1 = 0.0
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHREAL4(ql_ls(i, j, k))
        ql_ls(i, j, k) = ql_ls(i, j, k)*qlt_tmp*qt_tmpi_1
        CALL PUSHREAL4(ql_con(i, j, k))
        ql_con(i, j, k) = ql_con(i, j, k)*qlt_tmp*qt_tmpi_1
        IF (qi_ls(i, j, k) + qi_con(i, j, k) .GT. 0.00) THEN
          CALL PUSHREAL4(qt_tmpi_2)
          qt_tmpi_2 = 1./(qi_ls(i, j, k)+qi_con(i, j, k))
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL4(qt_tmpi_2)
          qt_tmpi_2 = 0.0
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHREAL4(qi_ls(i, j, k))
        qi_ls(i, j, k) = qi_ls(i, j, k)*qit_tmp*qt_tmpi_2
        CALL PUSHREAL4(qi_con(i, j, k))
        qi_con(i, j, k) = qi_con(i, j, k)*qit_tmp*qt_tmpi_2
!Ras Rain
        cnv_prc3(i, j, k) = qrn_cu_1d
      END DO
    END DO
  END DO
  tb = 0.0_4
  tb = thb/pih
  cnv_dqldtb = 0.0_4
  cnv_updfb = 0.0_4
  cnv_mfdb = 0.0_4
  prn_above_cu_newb = 0.0_4
  psn_above_cu_newb = 0.0_4
  evap_dd_an_above_newb = 0.0_4
  area_upd_prcb = 0.0_4
  qsb = 0.0_4
  prn_above_ls_newb = 0.0_4
  evap_dd_ls_above_newb = 0.0_4
  evap_dd_cu_above_newb = 0.0_4
  psn_above_ls_newb = 0.0_4
  tot_prec_lsb = 0.0_4
  area_ls_prcb = 0.0_4
  tot_prec_updb = 0.0_4
  prn_above_an_newb = 0.0_4
  area_anv_prcb = 0.0_4
  psn_above_an_newb = 0.0_4
  alhx3b = 0.0_4
  subl_dd_an_above_newb = 0.0_4
  qddf3b = 0.0_4
  tot_prec_anvb = 0.0_4
  dzetb = 0.0_4
  subl_dd_ls_above_newb = 0.0_4
  subl_dd_cu_above_newb = 0.0_4
  DO i=im,1,-1
    DO j=jm,1,-1
      DO k=lm,1,-1
        cnv_prc3b(i, j, k) = 0.0_4
        CALL POPREAL4(qi_con(i, j, k))
        temp1b = qi_con(i, j, k)*qi_conb(i, j, k)
        qi_conb(i, j, k) = qit_tmp*qt_tmpi_2*qi_conb(i, j, k)
        CALL POPREAL4(qi_ls(i, j, k))
        temp1b0 = qi_ls(i, j, k)*qi_lsb(i, j, k)
        qit_tmpb = qt_tmpi_2*temp1b0 + qt_tmpi_2*temp1b
        qt_tmpi_2b = qit_tmp*temp1b0 + qit_tmp*temp1b
        qi_lsb(i, j, k) = qit_tmp*qt_tmpi_2*qi_lsb(i, j, k)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL4(qt_tmpi_2)
          temp0 = qi_ls(i, j, k) + qi_con(i, j, k)
          temp0b1 = -(qt_tmpi_2b/temp0**2)
          qi_lsb(i, j, k) = qi_lsb(i, j, k) + temp0b1
          qi_conb(i, j, k) = qi_conb(i, j, k) + temp0b1
        ELSE
          CALL POPREAL4(qt_tmpi_2)
        END IF
        CALL POPREAL4(ql_con(i, j, k))
        temp0b = ql_con(i, j, k)*ql_conb(i, j, k)
        ql_conb(i, j, k) = qlt_tmp*qt_tmpi_1*ql_conb(i, j, k)
        CALL POPREAL4(ql_ls(i, j, k))
        temp0b0 = ql_ls(i, j, k)*ql_lsb(i, j, k)
        qlt_tmpb = qt_tmpi_1*temp0b0 + qt_tmpi_1*temp0b
        qt_tmpi_1b = qlt_tmp*temp0b0 + qlt_tmp*temp0b
        ql_lsb(i, j, k) = qlt_tmp*qt_tmpi_1*ql_lsb(i, j, k)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL4(qt_tmpi_1)
          temp = ql_ls(i, j, k) + ql_con(i, j, k)
          tempb8 = -(qt_tmpi_1b/temp**2)
          ql_lsb(i, j, k) = ql_lsb(i, j, k) + tempb8
          ql_conb(i, j, k) = ql_conb(i, j, k) + tempb8
        ELSE
          CALL POPREAL4(qt_tmpi_1)
        END IF
        lsenvfc = 1.0
        CALL POPREAL4(qrn_ls)
        CALL POPREAL4(qsn_ls)
        CALL POPREAL4(qlt_tmp)
        CALL POPREAL4(t(i, j, k))
        CALL POPREAL4(q(i, j, k))
        aab = 0.0_4
        bbb = 0.0_4
        CALL PRECIPANDEVAP_B(k, lm, dt, frland(i, j), rhcrit, qrn_ls, &
&                       qrn_lsb, qsn_ls, qsn_lsb, qlt_tmp, qlt_tmpb, &
&                       qit_tmp, t(i, j, k), tb(i, j, k), q(i, j, k), qb(&
&                       i, j, k), mass(i, j, k), imass(i, j, k), ph(i, j&
&                       , k), dzet(i, j, k), dzetb(i, j, k), qddf3(i, j, &
&                       k), qddf3b(i, j, k), aa, aab, bb, bbb, &
&                       area_ls_prc1, area_ls_prc1b, prn_above_ls_old, &
&                       prn_above_ls_oldb, prn_above_ls_new, &
&                       prn_above_ls_newb, psn_above_ls_old, &
&                       psn_above_ls_oldb, psn_above_ls_new, &
&                       psn_above_ls_newb, evap_dd_ls_above_old, &
&                       evap_dd_ls_above_oldb, evap_dd_ls_above_new, &
&                       evap_dd_ls_above_newb, subl_dd_ls_above_old, &
&                       subl_dd_ls_above_oldb, subl_dd_ls_above_new, &
&                       subl_dd_ls_above_newb, lsenvfc, lsddrfc, &
&                       cons_alhf, cons_alhs, cons_alhl, cons_cp, &
&                       cons_tice, cons_h2omw, cons_airmw, revap_off_p, &
&                       c_acc, c_ev_r, c_ev_s, rho_w, estblx)
        CALL POPREAL4(subl_dd_ls_above_old)
        subl_dd_ls_above_newb = subl_dd_ls_above_oldb
        CALL POPREAL4(evap_dd_ls_above_old)
        evap_dd_ls_above_newb = evap_dd_ls_above_oldb
        CALL POPREAL4(psn_above_ls_old)
        psn_above_ls_newb = psn_above_ls_oldb
        CALL POPREAL4(prn_above_ls_old)
        prn_above_ls_newb = prn_above_ls_oldb
        anvenvfc = 1.0
        CALL POPREAL4(qrn_an)
        CALL POPREAL4(qsn_an)
        CALL POPREAL4(qlt_tmp)
        CALL POPREAL4(t(i, j, k))
        CALL POPREAL4(q(i, j, k))
        CALL PRECIPANDEVAP_B(k, lm, dt, frland(i, j), rhcrit, qrn_an, &
&                       qrn_anb, qsn_an, qsn_anb, qlt_tmp, qlt_tmpb, &
&                       qit_tmp, t(i, j, k), tb(i, j, k), q(i, j, k), qb(&
&                       i, j, k), mass(i, j, k), imass(i, j, k), ph(i, j&
&                       , k), dzet(i, j, k), dzetb(i, j, k), qddf3(i, j, &
&                       k), qddf3b(i, j, k), aa, aab, bb, bbb, &
&                       area_anv_prc1, area_anv_prc1b, prn_above_an_old, &
&                       prn_above_an_oldb, prn_above_an_new, &
&                       prn_above_an_newb, psn_above_an_old, &
&                       psn_above_an_oldb, psn_above_an_new, &
&                       psn_above_an_newb, evap_dd_an_above_old, &
&                       evap_dd_an_above_oldb, evap_dd_an_above_new, &
&                       evap_dd_an_above_newb, subl_dd_an_above_old, &
&                       subl_dd_an_above_oldb, subl_dd_an_above_new, &
&                       subl_dd_an_above_newb, anvenvfc, anvddrfc, &
&                       cons_alhf, cons_alhs, cons_alhl, cons_cp, &
&                       cons_tice, cons_h2omw, cons_airmw, revap_off_p, &
&                       c_acc, c_ev_r, c_ev_s, rho_w, estblx)
        CALL POPREAL4(subl_dd_an_above_old)
        subl_dd_an_above_newb = subl_dd_an_above_oldb
        CALL POPREAL4(evap_dd_an_above_old)
        evap_dd_an_above_newb = evap_dd_an_above_oldb
        CALL POPREAL4(psn_above_an_old)
        psn_above_an_newb = psn_above_an_oldb
        CALL POPREAL4(prn_above_an_old)
        prn_above_an_newb = prn_above_an_oldb
        CALL POPREAL4(qrn_cu_1d)
        CALL POPREAL4(qsn_cu)
        CALL POPREAL4(qlt_tmp)
        CALL POPREAL4(t(i, j, k))
        CALL POPREAL4(q(i, j, k))
        CALL PRECIPANDEVAP_B(k, lm, dt, frland(i, j), rhcrit, qrn_cu_1d&
&                       , qrn_cu_1db, qsn_cu, qsn_cub, qlt_tmp, qlt_tmpb&
&                       , qit_tmp, t(i, j, k), tb(i, j, k), q(i, j, k), &
&                       qb(i, j, k), mass(i, j, k), imass(i, j, k), ph(i&
&                       , j, k), dzet(i, j, k), dzetb(i, j, k), qddf3(i, &
&                       j, k), qddf3b(i, j, k), aa, aab, bb, bbb, &
&                       area_upd_prc1, area_upd_prc1b, prn_above_cu_old, &
&                       prn_above_cu_oldb, prn_above_cu_new, &
&                       prn_above_cu_newb, psn_above_cu_old, &
&                       psn_above_cu_oldb, psn_above_cu_new, &
&                       psn_above_cu_newb, evap_dd_cu_above_old, &
&                       evap_dd_cu_above_oldb, evap_dd_cu_above_new, &
&                       evap_dd_cu_above_newb, subl_dd_cu_above_old, &
&                       subl_dd_cu_above_oldb, subl_dd_cu_above_new, &
&                       subl_dd_cu_above_newb, cnvenvfc, cnvddrfc, &
&                       cons_alhf, cons_alhs, cons_alhl, cons_cp, &
&                       cons_tice, cons_h2omw, cons_airmw, revap_off_p, &
&                       c_acc, c_ev_r, c_ev_s, rho_w, estblx)
        CALL POPREAL4(subl_dd_cu_above_old)
        subl_dd_cu_above_newb = subl_dd_cu_above_oldb
        CALL POPREAL4(evap_dd_cu_above_old)
        evap_dd_cu_above_newb = evap_dd_cu_above_oldb
        CALL POPREAL4(psn_above_cu_old)
        psn_above_cu_newb = psn_above_cu_oldb
        CALL POPREAL4(prn_above_cu_old)
        prn_above_cu_newb = prn_above_cu_oldb
        CALL POPREAL4(qit_tmp)
        qi_lsb(i, j, k) = qi_lsb(i, j, k) + qit_tmpb
        qi_conb(i, j, k) = qi_conb(i, j, k) + qit_tmpb
        CALL POPREAL4(qlt_tmp)
        ql_lsb(i, j, k) = ql_lsb(i, j, k) + qlt_tmpb
        ql_conb(i, j, k) = ql_conb(i, j, k) + qlt_tmpb
        CALL POPREAL4(aa)
        CALL POPREAL4(bb)
        CALL CONS_MICROPHYS_B(t(i, j, k), tb(i, j, k), ph(i, j, k), qs(i&
&                        , j, k), qsb(i, j, k), aa, aab, bb, bbb, &
&                        cons_h2omw, cons_airmw, cons_rvap, alhx3, alhx3b&
&                       )
        CALL POPREAL4(alhx3)
        CALL CONS_ALHX_B(t(i, j, k), tb(i, j, k), alhx3, alhx3b, &
&                   t_ice_max, t_ice_all, cons_alhs, cons_alhl)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL4(area_anv_prc)
          area_anv_prcb = anv_beta*area_anv_prcb
          CALL POPREAL4(area_upd_prc)
          area_upd_prcb = cnv_beta*area_upd_prcb
          CALL POPREAL4(area_ls_prc)
          area_ls_prcb = ls_beta*area_ls_prcb
          CALL POPCONTROL2B(branch)
          IF (branch .NE. 0) THEN
            IF (branch .EQ. 1) THEN
              CALL POPREAL4(area_ls_prc)
              tot_prec_lsb = tot_prec_lsb - area_ls_prc*area_ls_prcb/&
&                tot_prec_ls**2
              area_ls_prcb = area_ls_prcb/tot_prec_ls
            ELSE
              CALL POPREAL4(area_ls_prc)
              area_ls_prcb = 0.0_4
            END IF
          END IF
          CALL POPCONTROL2B(branch)
          IF (branch .NE. 0) THEN
            IF (branch .EQ. 1) THEN
              CALL POPREAL4(area_upd_prc)
              tot_prec_updb = tot_prec_updb - area_upd_prc*area_upd_prcb&
&                /tot_prec_upd**2
              area_upd_prcb = area_upd_prcb/tot_prec_upd
            ELSE
              CALL POPREAL4(area_upd_prc)
              area_upd_prcb = 0.0_4
            END IF
          END IF
          CALL POPCONTROL2B(branch)
          IF (branch .NE. 0) THEN
            IF (branch .EQ. 1) THEN
              CALL POPREAL4(area_anv_prc)
              tot_prec_anvb = tot_prec_anvb - area_anv_prc*area_anv_prcb&
&                /tot_prec_anv**2
              area_anv_prcb = area_anv_prcb/tot_prec_anv
            ELSE
              CALL POPREAL4(area_anv_prc)
              area_anv_prcb = 0.0_4
            END IF
          END IF
        END IF
        area_anv_prc1b = anv_beta*area_anv_prc1b
        area_upd_prc1b = cnv_beta*area_upd_prc1b
        area_ls_prc1b = ls_beta*area_ls_prc1b
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            area_ls_prcb = area_ls_prcb + area_ls_prc1b/tot_prec_ls
            tot_prec_lsb = tot_prec_lsb - area_ls_prc*area_ls_prc1b/&
&              tot_prec_ls**2
          END IF
        END IF
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            area_upd_prcb = area_upd_prcb + area_upd_prc1b/tot_prec_upd
            tot_prec_updb = tot_prec_updb - area_upd_prc*area_upd_prc1b/&
&              tot_prec_upd**2
          END IF
        END IF
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            area_anv_prcb = area_anv_prcb + area_anv_prc1b/tot_prec_anv
            tot_prec_anvb = tot_prec_anvb - area_anv_prc*area_anv_prc1b/&
&              tot_prec_anv**2
          END IF
        END IF
        tempb7 = mass(i, j, k)*tot_prec_updb
        tempb4 = mass(i, j, k)*tot_prec_anvb
        tempb1 = mass(i, j, k)*tot_prec_lsb
        CALL POPREAL4(area_ls_prc)
        tempb = mass(i, j, k)*area_ls_prcb
        tempb0 = cf_ls(i, j, k)*tempb
        cf_lsb(i, j, k) = cf_lsb(i, j, k) + (qrn_ls+qsn_ls)*tempb
        qrn_lsb = qrn_lsb + tempb1 + tempb0
        qsn_lsb = qsn_lsb + tempb1 + tempb0
        CALL POPREAL4(tot_prec_ls)
        CALL POPREAL4(area_anv_prc)
        tempb2 = mass(i, j, k)*area_anv_prcb
        tempb3 = cf_con(i, j, k)*tempb2
        cf_conb(i, j, k) = cf_conb(i, j, k) + (qrn_an+qsn_an)*tempb2
        qrn_anb = qrn_anb + tempb4 + tempb3
        qsn_anb = qsn_anb + tempb4 + tempb3
        CALL POPREAL4(tot_prec_anv)
        CALL POPREAL4(area_upd_prc)
        tempb5 = mass(i, j, k)*area_upd_prcb
        tempb6 = cnv_updf(i, j, k)*tempb5
        cnv_updfb(i, j, k) = cnv_updfb(i, j, k) + (qrn_cu_1d+qsn_cu)*&
&          tempb5
        qrn_cu_1db = qrn_cu_1db + tempb7 + tempb6
        qsn_cub = qsn_cub + tempb7 + tempb6
        CALL POPREAL4(tot_prec_upd)
        CALL POPREAL4(area_anv_prc1)
        CALL POPREAL4(area_upd_prc1)
        CALL POPREAL4(area_ls_prc1)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL4(t(i, j, k))
          qsn_cub = qsn_cub + (cons_alhs-cons_alhl)*tb(i, j, k)/cons_cp
          qrn_cu_1db = qsn_cub
        END IF
        CALL POPREAL4(qi_ls(i, j, k))
        CALL POPREAL4(cf_ls(i, j, k))
        CALL ICE_SETTLEFALL_LS_B(wrhodep, qi_ls(i, j, k), qi_lsb(i, j, k&
&                           ), ph(i, j, k), t(i, j, k), tb(i, j, k), &
&                           cf_ls(i, j, k), cf_lsb(i, j, k), cons_rgas, &
&                           kh(i, j, k-1), khu(i, j), khl(i, j), k, dt, &
&                           dzet(i, j, k), dzetb(i, j, k), qsn_ls, &
&                           qsn_lsb, ls_icefall_c)
        CALL POPREAL4(qi_con(i, j, k))
        CALL ICE_SETTLEFALL_CNV_B(wrhodep, qi_con(i, j, k), qi_conb(i, j&
&                            , k), ph(i, j, k), t(i, j, k), tb(i, j, k), &
&                            cf_con(i, j, k), cf_conb(i, j, k), cons_rgas&
&                            , kh(i, j, k-1), khu(i, j), khl(i, j), k, dt&
&                            , dzet(i, j, k), dzetb(i, j, k), qsn_an, &
&                            qsn_anb, anv_icefall_c)
        CALL POPREAL4(ql_con(i, j, k))
        CALL AUTOCONVERSION_CNV_B(dt, ql_con(i, j, k), ql_conb(i, j, k)&
&                            , qrn_an, qrn_anb, t(i, j, k), tb(i, j, k), &
&                            ph(i, j, k), cf_con(i, j, k), cf_conb(i, j, &
&                            k), anv_sdqv2, anv_sdqv3, anv_sdqvt1, c_00, &
&                            lwcrit, dzet(i, j, k))
        CALL POPREAL4(ql_ls(i, j, k))
        CALL POPREAL4(cf_ls(i, j, k))
        CALL AUTOCONVERSION_LS_B(dt, ql_ls(i, j, k), ql_lsb(i, j, k), &
&                           qrn_ls, qrn_lsb, t(i, j, k), tb(i, j, k), ph(&
&                           i, j, k), cf_ls(i, j, k), cf_lsb(i, j, k), &
&                           ls_sdqv2, ls_sdqv3, ls_sdqvt1, c_00, lwcrit, &
&                           dzet(i, j, k))
        CALL POPREAL4(t(i, j, k))
        CALL POPREAL4(q(i, j, k))
        CALL POPREAL4(qi_con(i, j, k))
        CALL POPREAL4(cf_con(i, j, k))
        CALL SUBL_CNV_B(dt, rhcrit, ph(i, j, k), t(i, j, k), tb(i, j, k)&
&                  , q(i, j, k), qb(i, j, k), ql_con(i, j, k), ql_conb(i&
&                  , j, k), qi_con(i, j, k), qi_conb(i, j, k), cf_con(i, &
&                  j, k), cf_conb(i, j, k), cf_ls(i, j, k), qs(i, j, k), &
&                  qsb(i, j, k), rho_w, cld_evp_eff, cons_h2omw, &
&                  cons_airmw, cons_alhl, cons_rvap, cons_rgas, cons_pi, &
&                  cons_cp, cons_alhs)
        CALL POPREAL4(t(i, j, k))
        CALL POPREAL4(q(i, j, k))
        CALL POPREAL4(ql_con(i, j, k))
        CALL POPREAL4(cf_con(i, j, k))
        CALL EVAP_CNV_B(dt, rhcrit, ph(i, j, k), t(i, j, k), tb(i, j, k)&
&                  , q(i, j, k), qb(i, j, k), ql_con(i, j, k), ql_conb(i&
&                  , j, k), qi_con(i, j, k), qi_conb(i, j, k), cf_con(i, &
&                  j, k), cf_conb(i, j, k), cf_ls(i, j, k), qs(i, j, k), &
&                  qsb(i, j, k), rho_w, cld_evp_eff, cons_h2omw, &
&                  cons_airmw, cons_alhl, cons_rvap, cons_rgas, cons_pi, &
&                  cons_cp)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL4(cf_con(i, j, k))
          CALL POPREAL4(cf_ls(i, j, k))
          cf_totb = -(cf_ls(i, j, k)*cf_lsb(i, j, k)/cf_tot**2) - cf_con&
&            (i, j, k)*cf_conb(i, j, k)/cf_tot**2
          cf_conb(i, j, k) = cf_conb(i, j, k)/cf_tot
          cf_lsb(i, j, k) = cf_lsb(i, j, k)/cf_tot
        ELSE
          cf_totb = 0.0_4
        END IF
        CALL POPREAL4(cf_tot)
        cf_lsb(i, j, k) = cf_lsb(i, j, k) + cf_totb
        cf_conb(i, j, k) = cf_conb(i, j, k) + cf_totb
        CALL POPREAL4(t(i, j, k))
        CALL POPREAL4(q(i, j, k))
        CALL POPREAL4(ql_ls(i, j, k))
        CALL POPREAL4(ql_con(i, j, k))
        CALL POPREAL4(qi_ls(i, j, k))
        CALL POPREAL4(qi_con(i, j, k))
        CALL POPREAL4(cf_ls(i, j, k))
        CALL POPREAL4(cf_con(i, j, k))

!COMPUTE THE JACOBIAN OF LS_CLOUD AND USE RESULTS TO FILTER 'BAD' POINTS 
DO ii = 1,1
   xx = 0.0
   xx(ii) = 1.0

   !Store seperate trajectory so as not to overwrite
   ttraj      = t(i,j,k)
   qtraj      = q(i,j,k)
   qi_lstraj  = qi_ls(i,j,k)
   qi_contraj = qi_con(i,j,k)
   ql_lstraj  = ql_ls(i,j,k)
   ql_contraj = ql_con(i,j,k)
   cf_lstraj  = cf_ls(i,j,k)
   cf_contraj = cf_con(i,j,k)
   phtraj     = ph(i,j,k)

   tpert      = xx(1)
   qpert      = xx(2)
   qi_lspert  = xx(3)
   qi_conpert = xx(4)
   ql_lspert  = xx(5)
   ql_conpert = xx(6)
   cf_lspert  = xx(7)
   cf_conpert = xx(8)

   tpert_in      = tpert
   qpert_in      = qpert
   qi_lspert_in  = qi_lspert
   qi_conpert_in = qi_conpert
   ql_lspert_in  = ql_lspert
   ql_conpert_in = ql_conpert
   cf_lspert_in  = cf_lspert
   cf_conpert_in = cf_conpert

   CALL LS_CLOUD_D(dt, alpha, pdfflag, phtraj, ttraj, tpert, qtraj, qpert, &
                  ql_lstraj, ql_lspert, ql_contraj, ql_conpert, &
                  qi_lstraj, qi_lspert, qi_contraj, qi_conpert, &
                  cf_lstraj, cf_lspert, cf_contraj, cf_conpert, &
                  cons_alhl, cons_alhf, cons_alhs, cons_cp, &
                  t_ice_all, t_ice_max, icefrpwr, estblx)

      Jacobian(1,ii) = (tpert-tpert_in)/DT
      Jacobian(2,ii) = (qpert-qpert_in)/DT
      Jacobian(3,ii) = (qi_lspert-qi_lspert_in)/DT
      Jacobian(4,ii) = (qi_conpert-qi_conpert_in)/DT
      Jacobian(5,ii) = (ql_lspert-ql_lspert_in)/DT
      Jacobian(6,ii) = (ql_conpert-ql_conpert_in)/DT
      Jacobian(7,ii) = (cf_lspert-cf_lspert_in)/DT
      Jacobian(8,ii) = (cf_conpert-cf_conpert_in)/DT

endDO

  !Pick level of filtering based on length of integration
  if (filt_strat == 12) then

     !Set the filtering coefficients 
     filt_lsc = 1.0
     filt_lscT = 0.01

     !Filtering - 50% of points
     if ( ( abs(Jacobian(3,1)) .gt. 5.2200e-10 ) .or. & !qi not required
          ( abs(Jacobian(5,1)) .gt. 7.3000e-08 )      & !ql 50%
                                                        !cf not required
        ) then
        filt_lsc = 0.1
     endif

     !Filtering - 40% of points
     if ( ( abs(Jacobian(3,1)) .gt. 2.0000e-09 ) .or. & !qi 40%
          ( abs(Jacobian(5,1)) .gt. 9.3100e-08 )      & !ql 40%
                                                     !cf not required
        ) then
        filt_lsc = 0.01
     endif

     !Filtering - 10% of points (most filtered i.e. biggest problems expected)
     if ( ( abs(Jacobian(3,1)) .gt. 1.4100e-08 ) .or. & !qi 10%
          ( abs(Jacobian(5,1)) .gt. 2.1700e-07 ) .or. & !ql 10%
          ( abs(Jacobian(7,1)) .gt. 0.0011     )      & !cf 10%
        ) then
        filt_lsc = 0.001
     endif

  elseif (filt_strat == 24) then

     !Set the filtering coefficients 
     filt_lsc = 0.1
     filt_lscT = 0.01

     !Filtering - 50% of points
     if ( ( abs(Jacobian(3,1)) .gt. 5.2200e-10 ) .or. & !qi not required
          ( abs(Jacobian(5,1)) .gt. 7.3000e-08 )      & !ql 50%
                                                        !cf not required
        ) then
        filt_lsc = 0.1
     endif

     !Filtering - 40% of points
     if ( ( abs(Jacobian(3,1)) .gt. 2.0000e-09 ) .or. & !qi 40%
          ( abs(Jacobian(5,1)) .gt. 9.3100e-08 )      & !ql 40%
                                                     !cf not required
        ) then
        filt_lsc = 0.01
     endif

     !Filtering - 10% of points (most filtered i.e. biggest problems expected)
     if ( ( abs(Jacobian(3,1)) .gt. 1.4100e-08 ) .or. & !qi 10%
          ( abs(Jacobian(5,1)) .gt. 2.1700e-07 ) .or. & !ql 10%
          ( abs(Jacobian(7,1)) .gt. 0.0011     )      & !cf 10%
        ) then
        filt_lsc = 0.001
     endif

  endif

!Adjoint of filtering
t_p_prelsc = (1.0-filt_lscT) * tb(i,j,k)
q_p_prelsc = (1.0-filt_lsc) * qb(i,j,k)
qi_ls_p_prelsc = (1.0-filt_lsc) * qi_lsb(i,j,k)
qi_con_p_prelsc = (1.0-filt_lsc) * qi_conb(i,j,k)
ql_ls_p_prelsc = (1.0-filt_lsc) * ql_lsb(i,j,k)
ql_con_p_prelsc = (1.0-filt_lsc) * ql_conb(i,j,k)
cf_ls_p_prelsc = (1.0-filt_lsc) * cf_lsb(i,j,k)
cf_con_p_prelsc = (1.0-filt_lsc) * cf_conb(i,j,k)

tb(i,j,k)      = filt_lscT* tb(i,j,k)
qb(i,j,k)      = filt_lsc * qb(i,j,k)
qi_lsb(i,j,k)  = filt_lsc * qi_lsb(i,j,k)
qi_conb(i,j,k) = filt_lsc * qi_conb(i,j,k)
ql_lsb(i,j,k)  = filt_lsc * ql_lsb(i,j,k)
ql_conb(i,j,k) = filt_lsc * ql_conb(i,j,k)
cf_lsb(i,j,k)  = filt_lsc * cf_lsb(i,j,k)
cf_conb(i,j,k) = filt_lsc * cf_conb(i,j,k)

        CALL LS_CLOUD_B(dt, alpha, pdfflag, ph(i, j, k), t(i, j, k), tb(&
&                  i, j, k), q(i, j, k), qb(i, j, k), ql_ls(i, j, k), &
&                  ql_lsb(i, j, k), ql_con(i, j, k), ql_conb(i, j, k), &
&                  qi_ls(i, j, k), qi_lsb(i, j, k), qi_con(i, j, k), &
&                  qi_conb(i, j, k), cf_ls(i, j, k), cf_lsb(i, j, k), &
&                  cf_con(i, j, k), cf_conb(i, j, k), cons_alhl, &
&                  cons_alhf, cons_alhs, cons_cp, cons_h2omw, cons_airmw&
&                  , t_ice_all, t_ice_max, icefrpwr, estblx)
        CALL POPREAL4(rhcrit)
        CALL POPREAL4(alpha)
        CALL POPREAL4(t(i, j, k))
        CALL POPREAL4(q(i, j, k))
        CALL POPREAL4(ql_con(i, j, k))
        CALL POPREAL4(qi_con(i, j, k))
        CALL POPREAL4(cf_con(i, j, k))
        CALL CONVEC_SRC_B(dt, mass(i, j, k), imass(i, j, k), t(i, j, k)&
&                    , tb(i, j, k), q(i, j, k), qb(i, j, k), cnv_dqldt(i&
&                    , j, k), cnv_dqldtb(i, j, k), cnv_mfd(i, j, k), &
&                    cnv_mfdb(i, j, k), ql_con(i, j, k), ql_conb(i, j, k)&
&                    , qi_con(i, j, k), qi_conb(i, j, k), cf_con(i, j, k)&
&                    , cf_conb(i, j, k), qs(i, j, k), qsb(i, j, k), &
&                    cons_alhs, cons_alhl, cons_cp, t_ice_all, t_ice_max&
&                    , icefrpwr)
        CALL POPREAL4(t(i, j, k))
        CALL POPREAL4(ql_con(i, j, k))
        CALL POPREAL4(qi_con(i, j, k))
        CALL MELTFREEZE_B(dt, t(i, j, k), tb(i, j, k), ql_con(i, j, k), &
&                    ql_conb(i, j, k), qi_con(i, j, k), qi_conb(i, j, k)&
&                    , t_ice_all, t_ice_max, icefrpwr, cons_alhl, &
&                    cons_alhs, cons_cp)
        CALL POPREAL4(t(i, j, k))
        CALL POPREAL4(ql_ls(i, j, k))
        CALL POPREAL4(qi_ls(i, j, k))
        CALL MELTFREEZE_B(dt, t(i, j, k), tb(i, j, k), ql_ls(i, j, k), &
&                    ql_lsb(i, j, k), qi_ls(i, j, k), qi_lsb(i, j, k), &
&                    t_ice_all, t_ice_max, icefrpwr, cons_alhl, cons_alhs&
&                    , cons_cp)
        CALL POPREAL4(t(i, j, k))
        CALL POPREAL4(ql_ls(i, j, k))
        CALL POPREAL4(qi_ls(i, j, k))
        CALL POPREAL4(cf_ls(i, j, k))
        CALL POPREAL4(ql_con(i, j, k))
        CALL POPREAL4(qi_con(i, j, k))
        CALL POPREAL4(cf_con(i, j, k))
        CALL CLOUD_TIDY_B(q(i, j, k), qb(i, j, k), t(i, j, k), tb(i, j, &
&                    k), ql_ls(i, j, k), ql_lsb(i, j, k), qi_ls(i, j, k)&
&                    , qi_lsb(i, j, k), cf_ls(i, j, k), cf_lsb(i, j, k), &
&                    ql_con(i, j, k), ql_conb(i, j, k), qi_con(i, j, k), &
&                    qi_conb(i, j, k), cf_con(i, j, k), cf_conb(i, j, k)&
&                    , cons_alhl, cons_alhs, cons_cp)
        cnv_prc3b(i, j, k) = cnv_prc3b(i, j, k) + qrn_cu_1db
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          CALL POPREAL4(area_ls_prc)
          CALL POPREAL4(area_anv_prc)
          CALL POPREAL4(area_upd_prc)
          CALL POPREAL4(tot_prec_ls)
          CALL POPREAL4(tot_prec_anv)
          CALL POPREAL4(tot_prec_upd)
          area_upd_prcb = 0.0_4
          tot_prec_lsb = 0.0_4
          area_ls_prcb = 0.0_4
          tot_prec_updb = 0.0_4
          area_anv_prcb = 0.0_4
          tot_prec_anvb = 0.0_4
        END IF
      END DO
    END DO
  END DO
  vmipb = 0.0_4
  DO k=lm,1,-1
    CALL POPREAL4ARRAY(qddf3(:, :, k), im*jm)
    vmipb = vmipb - qddf3(:, :, k)*qddf3b(:, :, k)/vmip**2
    qddf3b(:, :, k) = qddf3b(:, :, k)/vmip
  END DO
  DO i=im,1,-1
    DO j=jm,1,-1
      qddf3b(i, j, :) = qddf3b(i, j, :) + vmipb(i, j)
      vmipb(i, j) = 0.0_4
    END DO
  END DO
  WHERE (.NOT.mask(:, :, 1:lm)) qddf3b = 0.0_4
  zetb = 0.0_4
  WHERE (mask(:, :, 1:lm)) zetb(:, :, 1:lm) = zetb(:, :, 1:lm) - (zet(:&
&      , :, 1:lm)-3000.)*mass*qddf3b - zet(:, :, 1:lm)*mass*qddf3b
  DO k=1,lm,1
    zetb(:, :, k+1) = zetb(:, :, k+1) + zetb(:, :, k)
    dzetb(:, :, k) = dzetb(:, :, k) + zetb(:, :, k)
    zetb(:, :, k) = 0.0_4
  END DO
  CALL DQSAT_BAC_B(dqsdt, qs, qsb, t, tb, ph, im, jm, lm, estblx, &
&             cons_h2omw, cons_airmw)
  thb = 0.0_4
  thb(:, :, 1:lm) = pih*tb + (pi(:, :, 1:lm)-pi(:, :, 0:lm-1))*cons_cp*&
&    dzetb(:, :, 1:lm)/cons_grav
END SUBROUTINE CLOUD_B

!  Differentiation of cloud_tidy in reverse (adjoint) mode:
!   gradient     of useful results: af qv qla qlc qia qic cf te
!   with respect to varying inputs: af qv qla qlc qia qic cf te
!SUBROUTINES
SUBROUTINE CLOUD_TIDY_B(qv, qvb, te, teb, qlc, qlcb, qic, qicb, cf, cfb&
&  , qla, qlab, qia, qiab, af, afb, cons_alhl, cons_alhs, cons_cp)
  IMPLICIT NONE
  REAL*4, INTENT(INOUT) :: te, qv, qlc, cf, qla, af, qic, qia
  REAL*4 :: teb, qvb, qlcb, cfb, qlab, afb, qicb, qiab
  REAL*4, INTENT(IN) :: cons_alhl, cons_alhs, cons_cp
  INTEGER :: branch
!Fix if Anvil cloud fraction too small
  IF (af .LT. 1.e-5) THEN
    CALL PUSHREAL4(qla)
    qla = 0.
    CALL PUSHREAL4(qia)
    qia = 0.
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
!Fix if LS cloud fraction too small
  IF (cf .LT. 1.e-5) THEN
    CALL PUSHREAL4(qlc)
    qlc = 0.
    CALL PUSHREAL4(qic)
    qic = 0.
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
!LS LIQUID too small
  IF (qlc .LT. 1.e-8) THEN
    CALL PUSHREAL4(qlc)
    qlc = 0.
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
!LS ICE too small
  IF (qic .LT. 1.e-8) THEN
    CALL PUSHREAL4(qic)
    qic = 0.
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
!Anvil LIQUID too small
  IF (qla .LT. 1.e-8) THEN
    CALL PUSHREAL4(qla)
    qla = 0.
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
!Anvil ICE too small
  IF (qia .LT. 1.e-8) THEN
    CALL PUSHREAL4(qia)
    qia = 0.
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
!Fix ALL cloud quants if Anvil cloud LIQUID+ICE too small
  IF (qla + qia .LT. 1.e-8) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
!Ditto if LS cloud LIQUID+ICE too small
  IF (qlc + qic .LT. 1.e-8) THEN
    qlcb = qvb - cons_alhl*teb/cons_cp
    qicb = qvb - cons_alhs*teb/cons_cp
    cfb = 0.0_4
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    qlab = qvb - cons_alhl*teb/cons_cp
    qiab = qvb - cons_alhs*teb/cons_cp
    afb = 0.0_4
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    CALL POPREAL4(qia)
    qiab = qvb - cons_alhs*teb/cons_cp
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    CALL POPREAL4(qla)
    qlab = qvb - cons_alhl*teb/cons_cp
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    CALL POPREAL4(qic)
    qicb = qvb - cons_alhs*teb/cons_cp
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    CALL POPREAL4(qlc)
    qlcb = qvb - cons_alhl*teb/cons_cp
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    CALL POPREAL4(qic)
    CALL POPREAL4(qlc)
    qlcb = qvb - cons_alhl*teb/cons_cp
    qicb = qvb - cons_alhs*teb/cons_cp
    cfb = 0.0_4
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    CALL POPREAL4(qia)
    CALL POPREAL4(qla)
    qlab = qvb - cons_alhl*teb/cons_cp
    qiab = qvb - cons_alhs*teb/cons_cp
    afb = 0.0_4
  END IF
END SUBROUTINE CLOUD_TIDY_B

!  Differentiation of meltfreeze in reverse (adjoint) mode:
!   gradient     of useful results: qi ql te
!   with respect to varying inputs: qi ql te
SUBROUTINE MELTFREEZE_B(dt, te, teb, ql, qlb, qi, qib, t_ice_all, &
&  t_ice_max, icefrpwr, cons_alhl, cons_alhs, cons_cp)
  IMPLICIT NONE
!Inputs
  REAL*4, INTENT(IN) :: dt, t_ice_all, t_ice_max
  INTEGER, INTENT(IN) :: icefrpwr
  REAL*4, INTENT(IN) :: cons_alhl, cons_alhs, cons_cp
!Prognostic
  REAL*4, INTENT(INOUT) :: te, ql, qi
  REAL*4 :: teb, qlb, qib
!Locals
  REAL*4 :: fqi, dqil
  REAL*4 :: fqib, dqilb
  REAL*4, PARAMETER :: taufrz=1000.
  INTEGER :: branch
  INTRINSIC EXP
  INTRINSIC MAX
  INTRINSIC MIN
  REAL*4 :: temp
  dqil = 0.0
  CALL GET_ICE_FRACTION(te, t_ice_all, t_ice_max, icefrpwr, fqi)
!Freeze liquid
  IF (te .LE. t_ice_max) THEN
    dqil = ql*(1.0-EXP(-(dt*fqi/taufrz)))
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (0. .LT. dqil) THEN
    CALL PUSHCONTROL1B(0)
    dqil = dqil
  ELSE
    dqil = 0.
    CALL PUSHCONTROL1B(1)
  END IF
  CALL PUSHREAL4(qi)
  qi = qi + dqil
  CALL PUSHREAL4(te)
  te = te + (cons_alhs-cons_alhl)*dqil/cons_cp
  dqil = 0.
!Melt ice instantly above 0^C
  IF (te .GT. t_ice_max) THEN
    dqil = -qi
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (0. .GT. dqil) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  dqilb = qib - qlb + (cons_alhs-cons_alhl)*teb/cons_cp
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) dqilb = 0.0_4
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) qib = qib - dqilb
  CALL POPREAL4(te)
  dqilb = qib - qlb + (cons_alhs-cons_alhl)*teb/cons_cp
  CALL POPREAL4(qi)
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) dqilb = 0.0_4
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    fqib = 0.0_4
  ELSE
    temp = -(dt*fqi/taufrz)
    qlb = qlb + (1.0-EXP(temp))*dqilb
    fqib = dt*EXP(temp)*ql*dqilb/taufrz
  END IF
  CALL GET_ICE_FRACTION_B(te, teb, t_ice_all, t_ice_max, icefrpwr, fqi, &
&                    fqib)
END SUBROUTINE MELTFREEZE_B

!  Differentiation of convec_src in reverse (adjoint) mode:
!   gradient     of useful results: af qs qv qla qia dcf dmf te
!   with respect to varying inputs: af qs qv qla qia dcf dmf te
SUBROUTINE CONVEC_SRC_B(dt, mass, imass, te, teb, qv, qvb, dcf, dcfb, &
&  dmf, dmfb, qla, qlab, qia, qiab, af, afb, qs, qsb, cons_alhs, &
&  cons_alhl, cons_cp, t_ice_all, t_ice_max, icefrpwr)
  IMPLICIT NONE
!Inputs
  REAL*4, INTENT(IN) :: dt, t_ice_all, t_ice_max
  INTEGER, INTENT(IN) :: icefrpwr
  REAL*4, INTENT(IN) :: mass, imass, qs
  REAL*4 :: qsb
  REAL*4, INTENT(IN) :: dmf, dcf
  REAL*4 :: dmfb, dcfb
  REAL*4, INTENT(IN) :: cons_alhs, cons_alhl, cons_cp
!Prognostic
  REAL*4, INTENT(INOUT) :: te, qv
  REAL*4 :: teb, qvb
  REAL*4, INTENT(INOUT) :: qla, qia, af
  REAL*4 :: qlab, qiab, afb
!Locals
!Minimum allowed env RH
  REAL*4, PARAMETER :: minrhx=0.001
  REAL*4 :: tend, qvx, fqi
  REAL*4 :: tendb, fqib
  INTEGER :: branch
  REAL*4 :: tempb0
  REAL*4 :: tempb
  INTRINSIC MIN
!Namelist
!DT         - Timestep
!MASS       - Level Mass
!iMASS      - 1/Level Mass
!TE         - Temperature
!QV         - Specific Humidity
!DCF        - CNV_DQL from RAS
!DMF        - CNV_MFD from RAS
!QLA        - Convective cloud liquid water
!QIA        - Convective cloud liquid ice
!AF         - Convective cloud fraction
!QS         - Qsat
!Zero out locals
!Addition of condensate from RAS
  CALL GET_ICE_FRACTION(te, t_ice_all, t_ice_max, icefrpwr, fqi)
!Convective condensation has never frozen so latent heat of fusion
!Compute Tiedtke-style anvil fraction
  tend = dmf*imass
  CALL PUSHREAL4(af)
  af = af + tend*dt
  IF (af .GT. 0.99) THEN
    af = 0.99
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    af = af
  END IF
! Check for funny (tiny, negative) external QV, resulting from assumed QV=QSAT within anvil.
! Simply constrain AF assume condensate just gets "packed" in     
  IF (af .LT. 1.0) THEN
    qvx = (qv-qs*af)/(1.-af)
  ELSE
    qvx = qs
  END IF
!If saturated over critial value and there is Anvil
  IF (qvx - minrhx*qs .LT. 0.0 .AND. af .GT. 0.) THEN
    af = (qv-minrhx*qs)/(qs*(1.0-minrhx))
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (af .LT. 0.) THEN
    qlab = qvb - cons_alhl*teb/cons_cp
    qiab = qvb - cons_alhs*teb/cons_cp
    afb = 0.0_4
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    tempb0 = afb/((1.0-minrhx)*qs)
    qvb = qvb + tempb0
    qsb = qsb + (-((qv-minrhx*qs)/qs)-minrhx)*tempb0
    afb = 0.0_4
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) afb = 0.0_4
  CALL POPREAL4(af)
  tendb = dt*afb
  dmfb = dmfb + imass*tendb
  tend = dcf*imass
  tempb = (cons_alhs-cons_alhl)*dt*teb/cons_cp
  fqib = dt*tend*qiab - tend*dt*qlab + tend*tempb
  tendb = dt*fqi*qiab + dt*(1.0-fqi)*qlab + fqi*tempb
  CALL GET_ICE_FRACTION_B(te, teb, t_ice_all, t_ice_max, icefrpwr, fqi, &
&                    fqib)
  dcfb = dcfb + imass*tendb
END SUBROUTINE CONVEC_SRC_B

!  Differentiation of ls_cloud in reverse (adjoint) mode:
!   gradient     of useful results: qai qal af qv qci qcl cf te
!   with respect to varying inputs: qai qal af qv qci qcl cf te
SUBROUTINE LS_CLOUD_B(dt, alpha, pdfshape, pl, te, teb, qv, qvb, qcl, &
&  qclb, qal, qalb, qci, qcib, qai, qaib, cf, cfb, af, afb, cons_alhl, &
&  cons_alhf, cons_alhs, cons_cp, cons_h2omw, cons_airmw, t_ice_all, &
&  t_ice_max, icefrpwr, estblx)
  IMPLICIT NONE
!Inputs
  REAL*4, INTENT(IN) :: dt, alpha, pl, t_ice_all, t_ice_max
  INTEGER, INTENT(IN) :: pdfshape
  INTEGER, INTENT(IN) :: icefrpwr
  REAL*4, INTENT(IN) :: cons_alhl, cons_alhf, cons_alhs, cons_cp, &
&  cons_h2omw, cons_airmw
  REAL*4, INTENT(IN) :: estblx(:)
!Prognostic
  REAL*4, INTENT(INOUT) :: te, qv, qcl, qci, qal, qai, cf, af
  REAL*4 :: teb, qvb, qclb, qcib, qalb, qaib, cfb, afb
!Locals
  INTEGER :: n
  REAL*4 :: qco, cfo, qao, qt, qmx, qmn, dq
  REAL*4 :: qcob, cfob, qaob, qtb
  REAL*4 :: teo, qsx, dqsx, qs, dqs, tmparr
  REAL*4 :: teob, qsxb, dqsxb, dqsb, tmparrb
  REAL*4 :: qcx, qvx, cfx, qax, qc, qa, fqi, fqi_a, dqai, dqal, dqci, &
&  dqcl
  REAL*4 :: qcxb, qvxb, cfxb, qaxb, qcb, qab, fqib, dqaib, dqalb, dqcib&
&  , dqclb
  REAL*4 :: ten, qsp, cfp, qvp, qcp
  REAL*4 :: tenb, qcpb
  REAL*4 :: tep, qsn, cfn, qvn, qcn
  REAL*4 :: tepb, qsnb, cfnb, qcnb
  REAL*4 :: alhx, sigmaqt1, sigmaqt2
  REAL*4 :: alhxb, sigmaqt1b, sigmaqt2b
  REAL*4, DIMENSION(1) :: dqsx1, qsx1, teo1, pl1
  INTEGER :: branch
  REAL*4 :: temp1
  REAL*4 :: temp0
  REAL*4 :: tempb1
  REAL*4 :: tempb0
  REAL*4 :: temp0b
  INTRINSIC MAX
  REAL*4 :: temp2b2
  REAL*4 :: temp2b1
  REAL*4 :: temp2b0
  REAL*4 :: tempb
  REAL*4 :: temp0b0
  REAL*4 :: temp2b
  REAL*4 :: temp
!Namelist
!DT      - Timestep 
!ALPHA   - PDF half width
!PL      - Pressure (hPa)
!TE      - Temperature
!QV      - Specific humidity
!QCl     - Convective cloud liquid water
!QAl     - Large scale cloud liquid water
!QCi     - Convective cloud liquid ice
!QAi     - Large scale cloud liquid ice
!CF      - Large scale cloud fraction
!AF      - Convective cloud fraction
  qc = qcl + qci
  qa = qal + qai
  teo = te
  CALL DQSATS_BAC(dqsx, qsx, teo, pl, estblx, cons_h2omw, cons_airmw)
  IF (af .LT. 1.0) THEN
    tmparr = 1./(1.-af)
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    tmparr = 0.0
  END IF
  cfx = cf*tmparr
  qcx = qc*tmparr
  qvx = (qv-qsx*af)*tmparr
  IF (af .GE. 1.0) THEN
    qvx = qsx*1.e-4
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (af .GT. 0.) THEN
    qax = qa/af
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    qax = 0.
  END IF
  qt = qcx + qvx
  ten = teo
  cfn = cfx
  qcn = qcx
!Begin iteration
  DO n=1,4
    CALL PUSHREAL4(qcp)
    qcp = qcn
    CALL PUSHREAL4(qsn)
    CALL PUSHREAL4(dqs)
    CALL DQSATS_BAC(dqs, qsn, ten, pl, estblx, cons_h2omw, cons_airmw)
    CALL PUSHREAL4(tep)
    tep = ten
    CALL PUSHREAL4(fqi)
    CALL GET_ICE_FRACTION(tep, t_ice_all, t_ice_max, icefrpwr, fqi)
    CALL PUSHREAL4(sigmaqt1)
    sigmaqt1 = alpha*qsn
    CALL PUSHREAL4(sigmaqt2)
    sigmaqt2 = alpha*qsn
    IF (pdfshape .EQ. 2) THEN
!For triangular, symmetric: sigmaqt1 = sigmaqt2 = alpha*qsn (alpha is half width)
!For triangular, skewed r : sigmaqt1 < sigmaqt2
      sigmaqt1 = alpha*qsn
      sigmaqt2 = alpha*qsn
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL4(cfn)
!Compute cloud fraction
    CALL PDFFRAC(pdfshape, qt, sigmaqt1, sigmaqt2, qsn, cfn)
    CALL PUSHREAL4(qcn)
!Compute cloud condensate
    CALL PDFCONDENSATE(pdfshape, qt, sigmaqt1, sigmaqt2, qsn, qcn)
!Adjustments to anvil condensate due to the assumption of a stationary TOTAL 
!water PDF subject to a varying QSAT value during the iteration
    IF (af .GT. 0.) THEN
      CALL PUSHREAL4(qao)
! + QSx - QS 
      qao = qax
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL4(qao)
      qao = 0.
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL4(alhx)
    alhx = (1.0-fqi)*cons_alhl + fqi*cons_alhs
    IF (pdfshape .EQ. 1) THEN
      CALL PUSHREAL4(qcn)
      qcn = qcp + (qcn-qcp)/(1.-(cfn*(alpha-1.)-qcn/qsn)*dqs*alhx/&
&        cons_cp)
      CALL PUSHCONTROL2B(0)
    ELSE IF (pdfshape .EQ. 2) THEN
!This next line needs correcting - need proper d(del qc)/dT derivative for triangular
!for now, just use relaxation of 1/2.
      IF (n .NE. 4) THEN
        qcn = qcp + (qcn-qcp)*0.5
        CALL PUSHCONTROL2B(1)
      ELSE
        CALL PUSHCONTROL2B(2)
      END IF
    ELSE
      CALL PUSHCONTROL2B(3)
    END IF
    CALL PUSHREAL4(ten)
    ten = tep + (1.0-fqi)*(cons_alhl/cons_cp)*((qcn-qcp)*(1.-af)+(qao-&
&      qax)*af) + fqi*(cons_alhs/cons_cp)*((qcn-qcp)*(1.-af)+(qao-qax)*af&
&      )
  END DO
! qsat iteration
  cfo = cfn
  qco = qcn
! Update prognostic variables. QCo, QAo become updated grid means.
  IF (af .LT. 1.0) THEN
    CALL PUSHREAL4(cf)
    cf = cfo*(1.-af)
    CALL PUSHREAL4(qco)
    qco = qco*(1.-af)
    CALL PUSHREAL4(qao)
    qao = qao*af
    CALL PUSHCONTROL2B(0)
  ELSE
    CALL PUSHREAL4(cf)
!Grid box filled with anvil
! Special case AF=1, i.e., box filled with anvil. Note: no guarantee QV_box > QS_box
! Remove any other cloud
    cf = 0.
    CALL PUSHREAL4(qao)
! Add any LS condensate to anvil type
    qao = qa + qc
! Remove same from LS   
    qco = 0.
! Total water
    qt = qao + qv
    IF (qt - qsx .LT. 0.) THEN
      qao = 0.
      CALL PUSHCONTROL2B(2)
    ELSE
      qao = qt - qsx
      CALL PUSHCONTROL2B(1)
    END IF
  END IF
!Partition new condensate into ice and liquid taking care to keep both >=0 separately. 
!New condensate can be less than old, so Delta can be < 0.
  qcx = qco - qc
  dqcl = (1.0-fqi)*qcx
  dqci = fqi*qcx
!Large Scale Partition
  IF (qcl + dqcl .LT. 0.) THEN
    dqci = dqci + (qcl+dqcl)
!== dQCl - (QCl+dQCl)
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (qci + dqci .LT. 0.) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  CALL PUSHREAL4(qax)
  qax = qao - qa
! (1.0-fQi)*QAx
  dqal = qax
!  fQi  * QAx
  dqai = 0.
!Convective partition
  IF (qal + dqal .LT. 0.) THEN
    dqai = dqai + (qal+dqal)
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (qai + dqai .LT. 0.) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
! Clean-up cloud if fractions are too small
  IF (af .LT. 1.e-5) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (cf .LT. 1.e-5) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
!Update specific humidity
!Update temperature
!Take care of situations where QS moves past QA during QSAT iteration (QAo negative). 
!"Evaporate" offending QA
  IF (qao .LE. 0.) THEN
    qaib = qvb - cons_alhs*teb/cons_cp
    qalb = qvb - cons_alhl*teb/cons_cp
    afb = 0.0_4
  END IF
  temp2b1 = teb/cons_cp
  temp2b2 = cons_alhl*temp2b1
  dqaib = qaib - qvb + cons_alhf*temp2b1 + temp2b2
  dqcib = qcib - qvb + cons_alhf*temp2b1 + temp2b2
  dqalb = qalb - qvb + temp2b2
  dqclb = qclb - qvb + temp2b2
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    qclb = qclb - dqclb
    qcib = qcib - dqcib
    dqcib = 0.0_4
    dqclb = 0.0_4
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    qalb = qalb - dqalb
    qaib = qaib - dqaib
    dqaib = 0.0_4
    dqalb = 0.0_4
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    qaib = qaib + dqalb - dqaib
    dqaib = dqalb
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    qalb = qalb + dqaib - dqalb
    dqalb = dqaib
  END IF
  qaxb = dqalb
  CALL POPREAL4(qax)
  qaob = qaxb
  qab = -qaxb
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    qcib = qcib + dqclb - dqcib
    dqcib = dqclb
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    qclb = qclb + dqcib - dqclb
    dqclb = dqcib
  END IF
  fqib = qcx*dqcib - qcx*dqclb
  qcxb = (1.0-fqi)*dqclb + fqi*dqcib
  qcob = qcxb
  qcb = -qcxb
  CALL POPCONTROL2B(branch)
  IF (branch .EQ. 0) THEN
    CALL POPREAL4(qao)
    CALL POPREAL4(qco)
    afb = afb + qao*qaob - cfo*cfb - qco*qcob
    qaob = af*qaob
    qcob = (1.-af)*qcob
    CALL POPREAL4(cf)
    cfob = (1.-af)*cfb
    qsxb = 0.0_4
  ELSE
    IF (branch .EQ. 1) THEN
      qtb = qaob
      qsxb = -qaob
    ELSE
      qtb = 0.0_4
      qsxb = 0.0_4
    END IF
    qaob = qtb
    qvb = qvb + qtb
    CALL POPREAL4(qao)
    qab = qab + qaob
    qcb = qcb + qaob
    CALL POPREAL4(cf)
    qaob = 0.0_4
    cfob = 0.0_4
    qcob = 0.0_4
  END IF
  qcnb = qcob
  cfnb = cfob
  qcx = qc*tmparr
  qt = qcx + qvx
  tenb = 0.0_4
  qtb = 0.0_4
  qaxb = 0.0_4
  DO n=4,1,-1
    CALL POPREAL4(ten)
    temp2b = cons_alhl*(1.0-fqi)*tenb/cons_cp
    temp2b0 = cons_alhs*fqi*tenb/cons_cp
    tepb = tenb
    fqib = fqib + (((qcn-qcp)*(1.-af)+(qao-qax)*af)*cons_alhs/cons_cp-((&
&      qcn-qcp)*(1.-af)+(qao-qax)*af)*cons_alhl/cons_cp)*tenb
    qcnb = qcnb + (1.-af)*temp2b0 + (1.-af)*temp2b
    qcpb = -((1.-af)*temp2b0) - (1.-af)*temp2b
    afb = afb + (qao-qax-qcn+qcp)*temp2b0 + (qao-qax-qcn+qcp)*temp2b
    qaob = qaob + af*temp2b0 + af*temp2b
    qaxb = qaxb - af*temp2b0 - af*temp2b
    CALL POPCONTROL2B(branch)
    IF (branch .LT. 2) THEN
      IF (branch .EQ. 0) THEN
        CALL POPREAL4(qcn)
        temp0 = dqs*alhx/cons_cp
        temp1 = (alpha-1.)*cfn - qcn/qsn
        temp = -(temp1*temp0) + 1.
        tempb0 = qcnb/temp
        tempb1 = -((qcn-qcp)*tempb0/temp)
        temp0b = temp0*tempb1/qsn
        temp0b0 = -(temp1*tempb1/cons_cp)
        qcpb = qcpb + qcnb - tempb0
        cfnb = cfnb - temp0*(alpha-1.)*tempb1
        qsnb = -(qcn*temp0b/qsn)
        dqsb = alhx*temp0b0
        alhxb = dqs*temp0b0
        qcnb = temp0b + tempb0
        GOTO 100
      ELSE
        qcpb = qcpb + 0.5*qcnb
        qcnb = 0.5*qcnb
      END IF
    END IF
    dqsb = 0.0_4
    alhxb = 0.0_4
    qsnb = 0.0_4
 100 CALL POPREAL4(alhx)
    fqib = fqib + (cons_alhs-cons_alhl)*alhxb
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL4(qao)
      qaxb = qaxb + qaob
    ELSE
      CALL POPREAL4(qao)
    END IF
    CALL POPREAL4(qcn)
    CALL PDFCONDENSATE_B(pdfshape, qt, qtb, sigmaqt1, sigmaqt1b, &
&                   sigmaqt2, sigmaqt2b, qsn, qsnb, qcn, qcnb)
    CALL POPREAL4(cfn)
    CALL PDFFRAC_B(pdfshape, qt, qtb, sigmaqt1, sigmaqt1b, sigmaqt2, &
&             sigmaqt2b, qsn, qsnb, cfn, cfnb)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qsnb = qsnb + alpha*sigmaqt1b + alpha*sigmaqt2b
      sigmaqt1b = 0.0_4
      sigmaqt2b = 0.0_4
    END IF
    CALL POPREAL4(sigmaqt2)
    qsnb = qsnb + alpha*sigmaqt1b + alpha*sigmaqt2b
    CALL POPREAL4(sigmaqt1)
    CALL POPREAL4(fqi)
    CALL GET_ICE_FRACTION_B(tep, tepb, t_ice_all, t_ice_max, icefrpwr, &
&                      fqi, fqib)
    CALL POPREAL4(tep)
    tenb = tepb
    CALL POPREAL4(dqs)
    CALL POPREAL4(qsn)
    CALL DQSATS_BAC_B(dqs, dqsb, qsn, qsnb, ten, tenb, pl, estblx, &
&                cons_h2omw, cons_airmw)
    CALL POPREAL4(qcp)
    qcnb = qcpb
    qaob = 0.0_4
    fqib = 0.0_4
  END DO
  qcxb = qtb + qcnb
  cfxb = cfnb
  teob = tenb
  qvxb = qtb
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    qab = qab + qaxb/af
    afb = afb - qa*qaxb/af**2
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    qsxb = qsxb + 1.e-4*qvxb
    qvxb = 0.0_4
  END IF
  tempb = tmparr*qvxb
  qvb = qvb + tempb
  qsxb = qsxb - af*tempb
  afb = afb - qsx*tempb
  tmparrb = qc*qcxb + cf*cfxb + (qv-qsx*af)*qvxb
  qcb = qcb + tmparr*qcxb
  cfb = tmparr*cfxb
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) afb = afb + tmparrb/(1.-af)**2
  dqsxb = 0.0_4
  CALL DQSATS_BAC_B(dqsx, dqsxb, qsx, qsxb, teo, teob, pl, estblx, &
&              cons_h2omw, cons_airmw)
  teb = teb + teob
  qalb = qalb + qab
  qaib = qaib + qab
  qclb = qclb + qcb
  qcib = qcib + qcb
END SUBROUTINE LS_CLOUD_B

!  Differentiation of pdffrac in reverse (adjoint) mode:
!   gradient     of useful results: qtmean sigmaqt1 sigmaqt2 qstar
!                clfrac
!   with respect to varying inputs: qtmean sigmaqt1 sigmaqt2 qstar
!                clfrac
SUBROUTINE PDFFRAC_B(flag, qtmean, qtmeanb, sigmaqt1, sigmaqt1b, &
&  sigmaqt2, sigmaqt2b, qstar, qstarb, clfrac, clfracb)
  IMPLICIT NONE
!Inputs
  INTEGER, INTENT(IN) :: flag
  REAL*4, INTENT(IN) :: qtmean, sigmaqt1, sigmaqt2, qstar
  REAL*4 :: qtmeanb, sigmaqt1b, sigmaqt2b, qstarb
!Prognostic
  REAL*4, INTENT(INOUT) :: clfrac
  REAL*4 :: clfracb
!LOCALS
  REAL :: qtmode, qtmin, qtmax
  REAL :: qtmodeb, qtminb, qtmaxb
  INTEGER :: branch
  REAL :: temp0
  REAL*4 :: min1
  REAL :: tempb2
  REAL*4 :: tempb1
  REAL*4 :: tempb0
  REAL*4 :: temp0b
  REAL*4 :: min1b
  REAL*4 :: tempb
  REAL :: temp0b1
  REAL*4 :: temp0b0
  INTRINSIC MIN
  REAL :: temp
  IF (flag .EQ. 1) THEN
!Tophat PDF
    IF (qtmean + sigmaqt1 .GE. qstar) THEN
      IF (sigmaqt1 .GT. 0.) THEN
        IF (qtmean + sigmaqt1 - qstar .GT. 2.*sigmaqt1) THEN
          min1 = 2.*sigmaqt1
          CALL PUSHCONTROL1B(0)
        ELSE
          min1 = qtmean + sigmaqt1 - qstar
          CALL PUSHCONTROL1B(1)
        END IF
        tempb = clfracb/(2.*sigmaqt1)
        min1b = tempb
        sigmaqt1b = sigmaqt1b - min1*tempb/sigmaqt1
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          sigmaqt1b = sigmaqt1b + 2.*min1b
        ELSE
          qtmeanb = qtmeanb + min1b
          sigmaqt1b = sigmaqt1b + min1b
          qstarb = qstarb - min1b
        END IF
      END IF
    END IF
    clfracb = 0.0_4
  ELSE IF (flag .EQ. 2) THEN
!Triangular PDF
    qtmode = qtmean + (sigmaqt1-sigmaqt2)/3.
    IF (qtmode - sigmaqt1 .GT. 0.) THEN
      CALL PUSHCONTROL1B(0)
      qtmin = 0.
    ELSE
      qtmin = qtmode - sigmaqt1
      CALL PUSHCONTROL1B(1)
    END IF
    qtmax = qtmode + sigmaqt2
    IF (qtmax .LT. qstar) THEN
      clfracb = 0.0_4
      qtmaxb = 0.0
      qtminb = 0.0
      qtmodeb = 0.0
    ELSE IF (qtmode .LE. qstar .AND. qstar .LT. qtmax) THEN
      temp = (qtmax-qtmin)*(qtmax-qtmode)
      tempb0 = clfracb/temp
      tempb1 = 2*(qtmax-qstar)*tempb0
      tempb2 = -((qtmax-qstar)**2*tempb0/temp)
      qtmaxb = (2*qtmax-qtmin-qtmode)*tempb2 + tempb1
      qstarb = qstarb - tempb1
      qtminb = -((qtmax-qtmode)*tempb2)
      qtmodeb = -((qtmax-qtmin)*tempb2)
      clfracb = 0.0_4
    ELSE IF (qtmin .LE. qstar .AND. qstar .LT. qtmode) THEN
      temp0 = (qtmax-qtmin)*(qtmode-qtmin)
      temp0b = -(clfracb/temp0)
      temp0b0 = 2*(qstar-qtmin)*temp0b
      temp0b1 = -((qstar-qtmin)**2*temp0b/temp0)
      qstarb = qstarb + temp0b0
      qtminb = (2*qtmin-qtmax-qtmode)*temp0b1 - temp0b0
      qtmaxb = (qtmode-qtmin)*temp0b1
      qtmodeb = (qtmax-qtmin)*temp0b1
      clfracb = 0.0_4
    ELSE
      IF (qstar .LE. qtmin) clfracb = 0.0_4
      qtmaxb = 0.0
      qtminb = 0.0
      qtmodeb = 0.0
    END IF
    qtmodeb = qtmodeb + qtmaxb
    sigmaqt2b = sigmaqt2b + qtmaxb
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      qtmodeb = qtmodeb + qtminb
      sigmaqt1b = sigmaqt1b - qtminb
    END IF
    qtmeanb = qtmeanb + qtmodeb
    sigmaqt1b = sigmaqt1b + qtmodeb/3.
    sigmaqt2b = sigmaqt2b - qtmodeb/3.
  END IF
END SUBROUTINE PDFFRAC_B

!  Differentiation of pdfcondensate in reverse (adjoint) mode:
!   gradient     of useful results: qtmean4 qstar4 condensate4
!   with respect to varying inputs: qtmean4 qstar4 sigmaqt14 sigmaqt24
SUBROUTINE PDFCONDENSATE_B(flag, qtmean4, qtmean4b, sigmaqt14, &
&  sigmaqt14b, sigmaqt24, sigmaqt24b, qstar4, qstar4b, condensate4, &
&  condensate4b)
  IMPLICIT NONE
!Inputs
  INTEGER, INTENT(IN) :: flag
  REAL*4, INTENT(IN) :: qtmean4, sigmaqt14, sigmaqt24, qstar4
  REAL*4 :: qtmean4b, sigmaqt14b, sigmaqt24b, qstar4b
!Prognostic
  REAL*4, INTENT(INOUT) :: condensate4
  REAL*4 :: condensate4b
!Locals
  REAL*8 :: qtmode, qtmin, qtmax, consta, constb, cloudf
  REAL*8 :: qtmodeb, qtminb, qtmaxb, constab, constbb, cloudfb
  REAL*8 :: term1, term2, term3
  REAL*8 :: term1b, term2b, term3b
  REAL*8 :: qtmean, sigmaqt1, sigmaqt2, qstar, condensate
  REAL*8 :: qtmeanb, sigmaqt1b, sigmaqt2b, qstarb, condensateb
  INTEGER :: branch
  REAL*8 :: temp2
  REAL*8 :: temp1
  REAL*8 :: temp0
  REAL*8 :: min1
  REAL*8 :: temp0b
  REAL*8 :: tempb0
  REAL*8 :: min1b
  REAL*8 :: temp3b
  REAL*8 :: temp2b1
  REAL*8 :: temp2b0
  INTRINSIC REAL
  REAL*8 :: tempb
  REAL*8 :: temp0b1
  REAL*8 :: temp0b0
  REAL*8 :: temp2b
  INTRINSIC DBLE
  INTRINSIC MIN
  REAL*8 :: temp1b
  REAL*8 :: temp
  REAL*8 :: temp1b0
  qtmean = DBLE(qtmean4)
  sigmaqt1 = DBLE(sigmaqt14)
  sigmaqt2 = DBLE(sigmaqt24)
  qstar = DBLE(qstar4)
  IF (flag .EQ. 1) THEN
    IF (qtmean + sigmaqt1 .LT. qstar) THEN
      condensate = 0.d0
      CALL PUSHCONTROL4B(0)
    ELSE IF (qstar .GT. qtmean - sigmaqt1) THEN
      IF (sigmaqt1 .GT. 0.d0) THEN
        IF (qtmean + sigmaqt1 - qstar .GT. 2.d0*sigmaqt1) THEN
          min1 = 2.d0*sigmaqt1
          CALL PUSHCONTROL1B(0)
        ELSE
          min1 = qtmean + sigmaqt1 - qstar
          CALL PUSHCONTROL1B(1)
        END IF
        condensate = min1**2/(4.d0*sigmaqt1)
        CALL PUSHCONTROL4B(1)
      ELSE
        condensate = qtmean - qstar
        CALL PUSHCONTROL4B(2)
      END IF
    ELSE
      condensate = qtmean - qstar
      CALL PUSHCONTROL4B(3)
    END IF
  ELSE IF (flag .EQ. 2) THEN
    qtmode = qtmean + (sigmaqt1-sigmaqt2)/3.d0
    IF (qtmode - sigmaqt1 .GT. 0.d0) THEN
      qtmin = 0.d0
      CALL PUSHCONTROL1B(0)
    ELSE
      qtmin = qtmode - sigmaqt1
      CALL PUSHCONTROL1B(1)
    END IF
    qtmax = qtmode + sigmaqt2
    IF (qtmax .LT. qstar) THEN
      condensate = 0.d0
      CALL PUSHCONTROL4B(4)
    ELSE IF (qtmode .LE. qstar .AND. qstar .LT. qtmax) THEN
      constb = 2.d0/((qtmax-qtmin)*(qtmax-qtmode))
      cloudf = (qtmax-qstar)*(qtmax-qstar)/((qtmax-qtmin)*(qtmax-qtmode)&
&        )
      term1 = qstar*qstar*qstar/3.d0
      term2 = qtmax*qstar*qstar/2.d0
      term3 = qtmax*qtmax*qtmax/6.d0
      condensate = constb*(term1-term2+term3) - qstar*cloudf
      CALL PUSHCONTROL4B(5)
    ELSE IF (qtmin .LE. qstar .AND. qstar .LT. qtmode) THEN
      consta = 2.d0/((qtmax-qtmin)*(qtmode-qtmin))
      cloudf = 1.d0 - (qstar-qtmin)*(qstar-qtmin)/((qtmax-qtmin)*(qtmode&
&        -qtmin))
      term1 = qstar*qstar*qstar/3.d0
      term2 = qtmin*qstar*qstar/2.d0
      term3 = qtmin*qtmin*qtmin/6.d0
      condensate = qtmean - consta*(term1-term2+term3) - qstar*cloudf
      CALL PUSHCONTROL4B(6)
    ELSE IF (qstar .LE. qtmin) THEN
      condensate = qtmean - qstar
      CALL PUSHCONTROL4B(7)
    ELSE
      CALL PUSHCONTROL4B(8)
    END IF
  ELSE
    CALL PUSHCONTROL4B(9)
  END IF
  condensateb = condensate4b
  CALL POPCONTROL4B(branch)
  IF (branch .LT. 5) THEN
    IF (branch .LT. 2) THEN
      IF (branch .EQ. 0) THEN
        qtmeanb = 0.0_8
        sigmaqt1b = 0.0_8
        qstarb = 0.0_8
      ELSE
        tempb = condensateb/(4.d0*sigmaqt1)
        min1b = 2*min1*tempb
        sigmaqt1b = -(min1**2*tempb/sigmaqt1)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          sigmaqt1b = sigmaqt1b + 2.d0*min1b
          qtmeanb = 0.0_8
          qstarb = 0.0_8
        ELSE
          qtmeanb = min1b
          sigmaqt1b = sigmaqt1b + min1b
          qstarb = -min1b
        END IF
      END IF
    ELSE IF (branch .EQ. 2) THEN
      qtmeanb = condensateb
      qstarb = -condensateb
      sigmaqt1b = 0.0_8
    ELSE IF (branch .EQ. 3) THEN
      qtmeanb = condensateb
      qstarb = -condensateb
      sigmaqt1b = 0.0_8
    ELSE
      qtmeanb = 0.0_8
      qtmaxb = 0.0_8
      qstarb = 0.0_8
      qtminb = 0.0_8
      qtmodeb = 0.0_8
      GOTO 100
    END IF
    sigmaqt2b = 0.0_8
    GOTO 110
  ELSE IF (branch .LT. 7) THEN
    IF (branch .EQ. 5) THEN
      cloudfb = -(qstar*condensateb)
      temp0 = (qtmax-qtmin)*(qtmax-qtmode)
      temp0b1 = cloudfb/temp0
      temp0b = 2*(qtmax-qstar)*temp0b1
      temp1b = constb*condensateb
      constbb = (term1-term2+term3)*condensateb
      term1b = temp1b
      term2b = -temp1b
      term3b = temp1b
      qstarb = qtmax*2*qstar*term2b/2.d0 - temp0b + 3*qstar**2*term1b/&
&        3.d0 - cloudf*condensateb
      temp0b0 = -((qtmax-qstar)**2*temp0b1/temp0)
      temp = (qtmax-qtmin)*(qtmax-qtmode)
      tempb0 = -(2.d0*constbb/temp**2)
      qtmaxb = qstar**2*term2b/2.d0 + (2*qtmax-qtmin-qtmode)*tempb0 + (2&
&        *qtmax-qtmin-qtmode)*temp0b0 + temp0b + 3*qtmax**2*term3b/6.d0
      qtminb = -((qtmax-qtmode)*tempb0) - (qtmax-qtmode)*temp0b0
      qtmodeb = -((qtmax-qtmin)*tempb0) - (qtmax-qtmin)*temp0b0
      qtmeanb = 0.0_8
    ELSE
      cloudfb = -(qstar*condensateb)
      temp2 = (qtmax-qtmin)*(qtmode-qtmin)
      temp2b1 = -(cloudfb/temp2)
      temp2b = 2*(qstar-qtmin)*temp2b1
      temp3b = -(consta*condensateb)
      qtmeanb = condensateb
      constab = -((term1-term2+term3)*condensateb)
      term1b = temp3b
      term2b = -temp3b
      term3b = temp3b
      qstarb = qtmin*2*qstar*term2b/2.d0 + temp2b + 3*qstar**2*term1b/&
&        3.d0 - cloudf*condensateb
      temp2b0 = -((qstar-qtmin)**2*temp2b1/temp2)
      temp1 = (qtmax-qtmin)*(qtmode-qtmin)
      temp1b0 = -(2.d0*constab/temp1**2)
      qtminb = qstar**2*term2b/2.d0 + (2*qtmin-qtmax-qtmode)*temp1b0 + (&
&        2*qtmin-qtmax-qtmode)*temp2b0 - temp2b + 3*qtmin**2*term3b/6.d0
      qtmaxb = (qtmode-qtmin)*temp1b0 + (qtmode-qtmin)*temp2b0
      qtmodeb = (qtmax-qtmin)*temp1b0 + (qtmax-qtmin)*temp2b0
    END IF
  ELSE
    IF (branch .EQ. 7) THEN
      qtmeanb = condensateb
      qstarb = -condensateb
    ELSE IF (branch .EQ. 8) THEN
      qtmeanb = 0.0_8
      qstarb = 0.0_8
    ELSE
      qtmeanb = 0.0_8
      sigmaqt1b = 0.0_8
      sigmaqt2b = 0.0_8
      qstarb = 0.0_8
      GOTO 110
    END IF
    qtmaxb = 0.0_8
    qtminb = 0.0_8
    qtmodeb = 0.0_8
  END IF
 100 qtmodeb = qtmodeb + qtmaxb
  sigmaqt2b = qtmaxb
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    sigmaqt1b = 0.0_8
  ELSE
    qtmodeb = qtmodeb + qtminb
    sigmaqt1b = -qtminb
  END IF
  qtmeanb = qtmeanb + qtmodeb
  sigmaqt1b = sigmaqt1b + qtmodeb/3.d0
  sigmaqt2b = sigmaqt2b - qtmodeb/3.d0
 110 qstar4b = qstar4b + qstarb
  sigmaqt24b = sigmaqt2b
  sigmaqt14b = sigmaqt1b
  qtmean4b = qtmean4b + qtmeanb
END SUBROUTINE PDFCONDENSATE_B

!  Differentiation of evap_cnv in reverse (adjoint) mode:
!   gradient     of useful results: f qi ql qs qv te
!   with respect to varying inputs: f qi ql qs qv te
SUBROUTINE EVAP_CNV_B(dt, rhcr, pl, te, teb, qv, qvb, ql, qlb, qi, qib, &
&  f, fb, xf, qs, qsb, rho_w, cld_evp_eff, cons_h2omw, cons_airmw, &
&  cons_alhl, cons_rvap, cons_rgas, cons_pi, cons_cp)
  IMPLICIT NONE
!Inputs
  REAL*4, INTENT(IN) :: dt, rhcr, pl, xf, qs, rho_w, cld_evp_eff
  REAL*4 :: qsb
  REAL*4, INTENT(IN) :: cons_h2omw, cons_airmw, cons_alhl, cons_rvap, &
&  cons_rgas, cons_pi, cons_cp
!Prognostics
  REAL*4, INTENT(INOUT) :: te, qv, ql, qi, f
  REAL*4 :: teb, qvb, qlb, qib, fb
!Locals
  REAL*4 :: es, radius, k1, k2, teff, qcm, evap, rhx, qc, a_eff, epsilon
  REAL*4 :: esb, radiusb, k1b, k2b, teffb, qcmb, evapb, rhxb, qcb
  REAL*4, PARAMETER :: k_cond=2.4e-2
  REAL*4, PARAMETER :: diffu=2.2e-5
  REAL*4, PARAMETER :: nn=50.*1.0e6
  INTEGER :: branch
  REAL*4 :: temp3
  REAL*4 :: temp2
  REAL*4 :: temp1
  REAL*4 :: temp0
  REAL*4 :: temp3b
  REAL*4 :: tempb
  REAL*4 :: temp2b
  REAL*4 :: temp3b1
  REAL*4 :: temp3b0
  INTRINSIC MIN
  REAL*4 :: temp1b
  REAL*4 :: temp
  epsilon = cons_h2omw/cons_airmw
  a_eff = cld_evp_eff
!EVAPORATION OF CLOUD WATER.
! (100 <-^ convert from mbar to Pa)
  es = 100.*pl*qs/(epsilon+(1.0-epsilon)*qs)
  IF (qv/qs .GT. 1.00) THEN
    CALL PUSHCONTROL1B(0)
    rhx = 1.00
  ELSE
    rhx = qv/qs
    CALL PUSHCONTROL1B(1)
  END IF
  k1 = cons_alhl**2*rho_w/(k_cond*cons_rvap*te**2)
  k2 = cons_rvap*te*rho_w/(diffu*(1000./pl)*es)
!Here DIFFU is given for 1000 mb so 1000./PR accounts for increased diffusivity at lower pressure. 
  IF (f .GT. 0. .AND. ql .GT. 0.) THEN
    qcm = ql/f
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    qcm = 0.
  END IF
  CALL LDRADIUS(pl, te, qcm, nn, rho_w, radius, cons_rgas, cons_pi)
  IF (rhx .LT. rhcr .AND. radius .GT. 0.0) THEN
! / (1.00 - RHx)
    teff = (rhcr-rhx)/((k1+k2)*radius**2)
    CALL PUSHCONTROL1B(1)
  ELSE
! -999.
    teff = 0.0
    CALL PUSHCONTROL1B(0)
  END IF
  evap = a_eff*ql*dt*teff
  IF (evap .GT. ql) THEN
    evap = ql
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    evap = evap
  END IF
  qc = ql + qi
  IF (qc .GT. 0.) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  evapb = qvb - qlb - cons_alhl*teb/cons_cp
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    temp3 = f/qc
    temp3b1 = (qc-evap)*fb/qc
    qcb = temp3*fb - temp3*temp3b1
    evapb = evapb - temp3*fb
    fb = temp3b1
  ELSE
    qcb = 0.0_4
  END IF
  qlb = qlb + qcb
  qib = qib + qcb
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    qlb = qlb + evapb
    evapb = 0.0_4
  END IF
  temp3b0 = a_eff*dt*evapb
  qlb = qlb + teff*temp3b0
  teffb = ql*temp3b0
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    radiusb = 0.0_4
    k1b = 0.0_4
    k2b = 0.0_4
    rhxb = 0.0_4
  ELSE
    temp2 = (k1+k2)*radius**2
    temp2b = -((rhcr-rhx)*teffb/temp2**2)
    temp3b = radius**2*temp2b
    rhxb = -(teffb/temp2)
    k1b = temp3b
    k2b = temp3b
    radiusb = (k1+k2)*2*radius*temp2b
  END IF
  CALL LDRADIUS_B(pl, te, teb, qcm, qcmb, nn, rho_w, radius, radiusb, &
&            cons_rgas, cons_pi)
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    qlb = qlb + qcmb/f
    fb = fb - ql*qcmb/f**2
  END IF
  temp0 = k_cond*cons_rvap*te**2
  temp1 = 1000.*diffu*es
  temp1b = cons_rvap*rho_w*pl*k2b/temp1
  teb = teb + temp1b - k_cond*cons_rvap*cons_alhl**2*rho_w*2*te*k1b/&
&    temp0**2
  esb = -(te*diffu*1000.*temp1b/temp1)
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) THEN
    qvb = qvb + rhxb/qs
    qsb = qsb - qv*rhxb/qs**2
  END IF
  temp = epsilon + (-epsilon+1.0)*qs
  tempb = pl*100.*esb/temp
  qsb = qsb + (1.0_4-qs*(1.0-epsilon)/temp)*tempb
END SUBROUTINE EVAP_CNV_B

!  Differentiation of subl_cnv in reverse (adjoint) mode:
!   gradient     of useful results: f qi ql qs qv te
!   with respect to varying inputs: f qi ql qs qv te
SUBROUTINE SUBL_CNV_B(dt, rhcr, pl, te, teb, qv, qvb, ql, qlb, qi, qib, &
&  f, fb, xf, qs, qsb, rho_w, cld_evp_eff, cons_h2omw, cons_airmw, &
&  cons_alhl, cons_rvap, cons_rgas, cons_pi, cons_cp, cons_alhs)
  IMPLICIT NONE
!INPUTS
  REAL*4, INTENT(IN) :: dt, rhcr, pl, xf, qs, rho_w, cld_evp_eff
  REAL*4 :: qsb
  REAL*4, INTENT(IN) :: cons_h2omw, cons_airmw, cons_alhl, cons_rvap, &
&  cons_rgas, cons_pi, cons_cp, cons_alhs
!PROGNOSTIC
  REAL*4, INTENT(INOUT) :: te, qv, ql, qi, f
  REAL*4 :: teb, qvb, qlb, qib, fb
!LOCALS
  REAL*4 :: es, radius, k1, k2, teff, qcm, subl, rhx, qc, a_eff, nn, &
&  epsilon
  REAL*4 :: esb, radiusb, k1b, k2b, teffb, qcmb, sublb, rhxb, qcb
  REAL*4, PARAMETER :: k_cond=2.4e-2
  REAL*4, PARAMETER :: diffu=2.2e-5
  INTEGER :: branch
  REAL*4 :: temp3
  REAL*4 :: temp2
  REAL*4 :: temp1
  REAL*4 :: temp0
  REAL*4 :: temp3b
  REAL*4 :: tempb
  REAL*4 :: temp2b
  REAL*4 :: temp3b1
  REAL*4 :: temp3b0
  INTRINSIC MIN
  REAL*4 :: temp1b
  REAL*4 :: temp
  epsilon = cons_h2omw/cons_airmw
  a_eff = cld_evp_eff
  nn = 5.*1.0e6
! (100 s <-^ convert from mbar to Pa)
  es = 100.*pl*qs/(epsilon+(1.0-epsilon)*qs)
  IF (qv/qs .GT. 1.00) THEN
    CALL PUSHCONTROL1B(0)
    rhx = 1.00
  ELSE
    rhx = qv/qs
    CALL PUSHCONTROL1B(1)
  END IF
  k1 = cons_alhl**2*rho_w/(k_cond*cons_rvap*te**2)
  k2 = cons_rvap*te*rho_w/(diffu*(1000./pl)*es)
!Here DIFFU is given for 1000 mb so 1000./PR accounts for increased diffusivity at lower pressure.
  IF (f .GT. 0. .AND. qi .GT. 0.) THEN
    qcm = qi/f
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    qcm = 0.
  END IF
  CALL LDRADIUS(pl, te, qcm, nn, rho_w, radius, cons_rgas, cons_pi)
  IF (rhx .LT. rhcr .AND. radius .GT. 0.0) THEN
! / (1.00 - RHx)
    teff = (rhcr-rhx)/((k1+k2)*radius**2)
    CALL PUSHCONTROL1B(1)
  ELSE
! -999.
    teff = 0.0
    CALL PUSHCONTROL1B(0)
  END IF
  subl = a_eff*qi*dt*teff
  IF (subl .GT. qi) THEN
    subl = qi
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    subl = subl
  END IF
  qc = ql + qi
  IF (qc .GT. 0.) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  sublb = qvb - qib - cons_alhs*teb/cons_cp
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    temp3 = f/qc
    temp3b1 = (qc-subl)*fb/qc
    qcb = temp3*fb - temp3*temp3b1
    sublb = sublb - temp3*fb
    fb = temp3b1
  ELSE
    qcb = 0.0_4
  END IF
  qlb = qlb + qcb
  qib = qib + qcb
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    qib = qib + sublb
    sublb = 0.0_4
  END IF
  temp3b0 = a_eff*dt*sublb
  qib = qib + teff*temp3b0
  teffb = qi*temp3b0
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    radiusb = 0.0_4
    k1b = 0.0_4
    k2b = 0.0_4
    rhxb = 0.0_4
  ELSE
    temp2 = (k1+k2)*radius**2
    temp2b = -((rhcr-rhx)*teffb/temp2**2)
    temp3b = radius**2*temp2b
    rhxb = -(teffb/temp2)
    k1b = temp3b
    k2b = temp3b
    radiusb = (k1+k2)*2*radius*temp2b
  END IF
  CALL LDRADIUS_B(pl, te, teb, qcm, qcmb, nn, rho_w, radius, radiusb, &
&            cons_rgas, cons_pi)
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    qib = qib + qcmb/f
    fb = fb - qi*qcmb/f**2
  END IF
  temp0 = k_cond*cons_rvap*te**2
  temp1 = 1000.*diffu*es
  temp1b = cons_rvap*rho_w*pl*k2b/temp1
  teb = teb + temp1b - k_cond*cons_rvap*cons_alhl**2*rho_w*2*te*k1b/&
&    temp0**2
  esb = -(te*diffu*1000.*temp1b/temp1)
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) THEN
    qvb = qvb + rhxb/qs
    qsb = qsb - qv*rhxb/qs**2
  END IF
  temp = epsilon + (-epsilon+1.0)*qs
  tempb = pl*100.*esb/temp
  qsb = qsb + (1.0_4-qs*(1.0-epsilon)/temp)*tempb
END SUBROUTINE SUBL_CNV_B

!  Differentiation of ldradius in reverse (adjoint) mode:
!   gradient     of useful results: radius te
!   with respect to varying inputs: qcl te
SUBROUTINE LDRADIUS_B(pl, te, teb, qcl, qclb, nn, rho_w, radius, radiusb&
&  , cons_rgas, cons_pi)
  IMPLICIT NONE
!Inputs
  REAL*4, INTENT(IN) :: te, pl, nn, qcl, rho_w
  REAL*4 :: teb, qclb
  REAL*4, INTENT(IN) :: cons_rgas, cons_pi
!Outputs      
  REAL*4 :: radius
  REAL*4 :: radiusb
!Locals
  REAL*4 :: muu, rho
  REAL*4 :: muub, rhob
  rho = 100.*pl/(cons_rgas*te)
  muu = qcl*rho
  radius = muu/(nn*rho_w*(4./3.)*cons_pi)
! Equiv. Spherical Cloud Particle Radius in m
  IF (radius .LE. 0.0 .AND. (1.0/3. .EQ. 0.0 .OR. 1.0/3. .NE. INT(1.0/3.&
&      ))) THEN
    radiusb = 0.0
  ELSE
    radiusb = radius**(1.0/3.-1)*radiusb/3.
  END IF
  muub = 3.*radiusb/(nn*4.*rho_w*cons_pi)
  qclb = rho*muub
  rhob = qcl*muub
  teb = teb - pl*100.*rhob/(cons_rgas*te**2)
END SUBROUTINE LDRADIUS_B

!  Differentiation of autoconversion_ls in reverse (adjoint) mode:
!   gradient     of useful results: f qc qp te
!   with respect to varying inputs: f qc te
SUBROUTINE AUTOCONVERSION_LS_B(dt, qc, qcb, qp, qpb, te, teb, pl, f, fb&
&  , sundqv2, sundqv3, sundqt1, c_00, lwcrit, dzet)
  IMPLICIT NONE
!Inputs
  REAL*4, INTENT(IN) :: dt, te, pl, dzet, sundqv2, sundqv3, sundqt1, &
&  c_00, lwcrit
  REAL*4 :: teb
!Prognostic
  REAL*4, INTENT(INOUT) :: qc, qp, f
  REAL*4 :: qcb, qpb, fb
!Locals
  REAL*4 :: acf0, acf, c00x, iqccrx, f2, f3, rate, dqp, qcm, dqfac
  REAL*4 :: c00xb, iqccrxb, f2b, f3b, rateb, dqpb, qcmb, dqfacb
  INTEGER :: branch
  INTRINSIC EXP
  REAL*4 :: temp0b
  INTRINSIC MAX
  REAL*4 :: x4
  REAL*4 :: x3
  REAL*4 :: x2
  REAL*4 :: x1
  REAL*4 :: x2b
  REAL*4 :: tempb
  REAL*4 :: temp0b0
  REAL*4 :: x1b
  REAL*4 :: x4b
  INTRINSIC MIN
  REAL*4 :: temp
!Zero Locals
  f2 = 0.0
  f3 = 0.0
  CALL PUSHREAL4(f2)
  CALL CONS_SUNDQ3(te, sundqv2, sundqv3, sundqt1, f2, f3)
  c00x = c_00*f2*f3
  iqccrx = f2*f3/lwcrit
  IF (f .GT. 0. .AND. qc .GT. 0.) THEN
    qcm = qc/f
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    qcm = 0.
  END IF
  rate = c00x*(1.0-EXP(-((qcm*iqccrx)**2)))
  CALL PUSHREAL4(f3)
!Temporary kluge until we can figure a better to make thicker low clouds.
  f3 = 1.0
!Implement ramps for gradual change in autoconv
!Thicken low high lat clouds
  IF (pl .GE. 775. .AND. te .LE. 275.) f3 = 0.2
!F3 = max(-0.016 * PL + 13.4, 0.2)
  IF (pl .GE. 825. .AND. te .LE. 282.) f3 = 0.2
!F3 = max(0.11 * TE - 30.02, 0.2)
  IF (pl .GE. 775. .AND. pl .LT. 825. .AND. te .LE. 282. .AND. te .GT. &
&      275.) f3 = 0.2
!F3 = min(max(-0.016*PL + 0.11 * TE - 16.85, 0.2),1.)
  IF (pl .GE. 825. .AND. te .LE. 275.) f3 = 0.2
  IF (pl .LE. 775. .OR. te .GT. 282.) f3 = 1.
!Thin-out low tropical clouds
  IF (pl .GE. 950. .AND. te .GE. 285.) THEN
    IF (0.2*te - 56 .GT. 2.) THEN
      CALL PUSHCONTROL2B(2)
      f3 = 2.
    ELSE
      f3 = 0.2*te - 56
      CALL PUSHCONTROL2B(1)
    END IF
  ELSE
    CALL PUSHCONTROL2B(0)
  END IF
  IF (pl .GE. 925. .AND. te .GE. 290.) THEN
    IF (0.04*pl - 36. .GT. 2.) THEN
      CALL PUSHCONTROL1B(1)
      f3 = 2.
    ELSE
      CALL PUSHCONTROL1B(1)
      f3 = 0.04*pl - 36.
    END IF
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (pl .GE. 925. .AND. pl .LT. 950. .AND. te .GT. 285. .AND. te .LT. &
&      290.) THEN
    IF (0.04*pl + 0.2*te - 94. .GT. 2.) THEN
      CALL PUSHCONTROL1B(0)
      x1 = 2.
    ELSE
      x1 = 0.04*pl + 0.2*te - 94.
      CALL PUSHCONTROL1B(1)
    END IF
    IF (x1 .LT. 1.) THEN
      f3 = 1.
      CALL PUSHCONTROL2B(2)
    ELSE
      f3 = x1
      CALL PUSHCONTROL2B(1)
    END IF
  ELSE
    CALL PUSHCONTROL2B(0)
  END IF
  IF (pl .GE. 950. .AND. te .GE. 290.) THEN
    f3 = 2.
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (f3 .LT. 0.1) THEN
    f3 = 0.1
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    f3 = f3
  END IF
  CALL PUSHREAL4(rate)
  rate = f3*rate
  dqp = qc*(1.0-EXP(-(rate*dt)))
  IF (dqp .LT. 0.0) THEN
    dqp = 0.0
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    dqp = dqp
  END IF
!Wipe-out warm fogs
  dqfac = 0.
  IF (pl .GE. 975. .AND. te .GE. 280.) THEN
    IF (0.2*te - 56. .GT. 1.) THEN
      CALL PUSHCONTROL1B(0)
      x2 = 1.
    ELSE
      x2 = 0.2*te - 56.
      CALL PUSHCONTROL1B(1)
    END IF
    IF (x2 .LT. 0.) THEN
      dqfac = 0.
      CALL PUSHCONTROL2B(2)
    ELSE
      dqfac = x2
      CALL PUSHCONTROL2B(1)
    END IF
  ELSE
    CALL PUSHCONTROL2B(0)
  END IF
  IF (pl .GE. 950. .AND. te .GE. 285.) THEN
    IF (0.04*pl - 38. .GT. 1.) THEN
      CALL PUSHCONTROL1B(1)
      x3 = 1.
    ELSE
      CALL PUSHCONTROL1B(1)
      x3 = 0.04*pl - 38.
    END IF
    IF (x3 .LT. 0.) THEN
      dqfac = 0.
    ELSE
      dqfac = x3
    END IF
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (pl .GE. 950. .AND. pl .LT. 975. .AND. te .GT. 280. .AND. te .LT. &
&      285.) THEN
    IF (0.04*pl + 0.2*te - 95. .GT. 1.) THEN
      CALL PUSHCONTROL1B(0)
      x4 = 1.
    ELSE
      x4 = 0.04*pl + 0.2*te - 95.
      CALL PUSHCONTROL1B(1)
    END IF
    IF (x4 .LT. 0.) THEN
      dqfac = 0.
      CALL PUSHCONTROL2B(2)
    ELSE
      dqfac = x4
      CALL PUSHCONTROL2B(1)
    END IF
  ELSE
    CALL PUSHCONTROL2B(0)
  END IF
  IF (pl .GE. 975. .AND. te .GE. 285.) THEN
    dqfac = 1.
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (dqp .LT. dqfac*qc) THEN
    dqp = dqfac*qc
    CALL PUSHCONTROL1B(0)
  ELSE
    dqp = dqp
    CALL PUSHCONTROL1B(1)
  END IF
  CALL PUSHREAL4(qc)
  qc = qc - dqp
!IF LARGE SCALE THEN
  IF (qc + dqp .GT. 0.) THEN
    temp0b = fb/(qc+dqp)
    temp0b0 = -(qc*f*temp0b/(qc+dqp))
    qcb = qcb + temp0b0 + f*temp0b
    dqpb = temp0b0
    fb = qc*temp0b
  ELSE
    dqpb = 0.0_4
  END IF
  dqpb = dqpb + qpb - qcb
  CALL POPREAL4(qc)
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    dqfacb = qc*dqpb
    qcb = qcb + dqfac*dqpb
    dqpb = 0.0_4
  ELSE
    dqfacb = 0.0_4
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) dqfacb = 0.0_4
  CALL POPCONTROL2B(branch)
  IF (branch .NE. 0) THEN
    IF (branch .EQ. 1) THEN
      x4b = dqfacb
    ELSE
      x4b = 0.0_4
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) teb = teb + 0.2*x4b
    dqfacb = 0.0_4
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) dqfacb = 0.0_4
  CALL POPCONTROL2B(branch)
  IF (branch .NE. 0) THEN
    IF (branch .EQ. 1) THEN
      x2b = dqfacb
    ELSE
      x2b = 0.0_4
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) teb = teb + 0.2*x2b
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) dqpb = 0.0_4
  qcb = qcb + (1.0-EXP(-(dt*rate)))*dqpb
  rateb = EXP(-(dt*rate))*qc*dt*dqpb
  CALL POPREAL4(rate)
  f3b = rate*rateb
  rateb = f3*rateb
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) f3b = 0.0_4
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) f3b = 0.0_4
  CALL POPCONTROL2B(branch)
  IF (branch .NE. 0) THEN
    IF (branch .EQ. 1) THEN
      x1b = f3b
    ELSE
      x1b = 0.0_4
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) teb = teb + 0.2*x1b
    f3b = 0.0_4
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) f3b = 0.0_4
  CALL POPCONTROL2B(branch)
  IF (branch .NE. 0) THEN
    IF (branch .EQ. 1) teb = teb + 0.2*f3b
  END IF
  CALL POPREAL4(f3)
  temp = qcm*iqccrx
  tempb = EXP(-(temp**2))*c00x*2*temp*rateb
  c00xb = (1.0-EXP(-(temp**2)))*rateb
  qcmb = iqccrx*tempb
  iqccrxb = qcm*tempb
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    qcb = qcb + qcmb/f
    fb = fb - qc*qcmb/f**2
  END IF
  f2b = c_00*f3*c00xb + f3*iqccrxb/lwcrit
  CALL POPREAL4(f2)
  CALL CONS_SUNDQ3_B(te, teb, sundqv2, sundqv3, sundqt1, f2, f2b, f3)
END SUBROUTINE AUTOCONVERSION_LS_B

!  Differentiation of autoconversion_cnv in reverse (adjoint) mode:
!   gradient     of useful results: f qc qp te
!   with respect to varying inputs: f qc te
SUBROUTINE AUTOCONVERSION_CNV_B(dt, qc, qcb, qp, qpb, te, teb, pl, f, fb&
&  , sundqv2, sundqv3, sundqt1, c_00, lwcrit, dzet)
  IMPLICIT NONE
!Inputs
  REAL*4, INTENT(IN) :: dt, te, pl, dzet, sundqv2, sundqv3, sundqt1, &
&  c_00, lwcrit
  REAL*4 :: teb
!Prognostic
  REAL*4, INTENT(INOUT) :: qc, qp, f
  REAL*4 :: qcb, qpb, fb
!Locals
  REAL*4 :: acf0, acf, c00x, iqccrx, f2, f3, rate, dqp, qcm, dqfac
  REAL*4 :: c00xb, iqccrxb, f2b, f3b, rateb, dqpb, qcmb, dqfacb
  INTEGER :: branch
  INTRINSIC EXP
  INTRINSIC MAX
  REAL*4 :: x4
  REAL*4 :: x3
  REAL*4 :: x2
  REAL*4 :: x1
  REAL*4 :: x2b
  REAL*4 :: tempb
  REAL*4 :: x1b
  REAL*4 :: x4b
  INTRINSIC MIN
  REAL*4 :: temp
!Zero Locals
  f2 = 0.0
  f3 = 0.0
  CALL PUSHREAL4(f2)
  CALL CONS_SUNDQ3(te, sundqv2, sundqv3, sundqt1, f2, f3)
  c00x = c_00*f2*f3
  iqccrx = f2*f3/lwcrit
  IF (f .GT. 0. .AND. qc .GT. 0.) THEN
    qcm = qc/f
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    qcm = 0.
  END IF
  rate = c00x*(1.0-EXP(-((qcm*iqccrx)**2)))
  CALL PUSHREAL4(f3)
!Temporary kluge until we can figure a better to make thicker low clouds.
  f3 = 1.0
!Implement ramps for gradual change in autoconv
!Thicken low high lat clouds
  IF (pl .GE. 775. .AND. te .LE. 275.) f3 = 0.2
!F3 = max(-0.016 * PL + 13.4, 0.2)
  IF (pl .GE. 825. .AND. te .LE. 282.) f3 = 0.2
!F3 = max(0.11 * TE - 30.02, 0.2)
  IF (pl .GE. 775. .AND. pl .LT. 825. .AND. te .LE. 282. .AND. te .GT. &
&      275.) f3 = 0.2
!F3 = min(max(-0.016*PL + 0.11 * TE - 16.85, 0.2),1.)
  IF (pl .GE. 825. .AND. te .LE. 275.) f3 = 0.2
  IF (pl .LE. 775. .OR. te .GT. 282.) f3 = 1.
!Thin-out low tropical clouds
  IF (pl .GE. 950. .AND. te .GE. 285.) THEN
    IF (0.2*te - 56 .GT. 2.) THEN
      CALL PUSHCONTROL2B(2)
      f3 = 2.
    ELSE
      f3 = 0.2*te - 56
      CALL PUSHCONTROL2B(1)
    END IF
  ELSE
    CALL PUSHCONTROL2B(0)
  END IF
  IF (pl .GE. 925. .AND. te .GE. 290.) THEN
    IF (0.04*pl - 36. .GT. 2.) THEN
      CALL PUSHCONTROL1B(1)
      f3 = 2.
    ELSE
      CALL PUSHCONTROL1B(1)
      f3 = 0.04*pl - 36.
    END IF
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (pl .GE. 925. .AND. pl .LT. 950. .AND. te .GT. 285. .AND. te .LT. &
&      290.) THEN
    IF (0.04*pl + 0.2*te - 94. .GT. 2.) THEN
      CALL PUSHCONTROL1B(0)
      x1 = 2.
    ELSE
      x1 = 0.04*pl + 0.2*te - 94.
      CALL PUSHCONTROL1B(1)
    END IF
    IF (x1 .LT. 1.) THEN
      f3 = 1.
      CALL PUSHCONTROL2B(2)
    ELSE
      f3 = x1
      CALL PUSHCONTROL2B(1)
    END IF
  ELSE
    CALL PUSHCONTROL2B(0)
  END IF
  IF (pl .GE. 950. .AND. te .GE. 290.) THEN
    f3 = 2.
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (f3 .LT. 0.1) THEN
    f3 = 0.1
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    f3 = f3
  END IF
  CALL PUSHREAL4(rate)
  rate = f3*rate
  dqp = qc*(1.0-EXP(-(rate*dt)))
  IF (dqp .LT. 0.0) THEN
    dqp = 0.0
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    dqp = dqp
  END IF
!Wipe-out warm fogs
  dqfac = 0.
  IF (pl .GE. 975. .AND. te .GE. 280.) THEN
    IF (0.2*te - 56. .GT. 1.) THEN
      CALL PUSHCONTROL1B(0)
      x2 = 1.
    ELSE
      x2 = 0.2*te - 56.
      CALL PUSHCONTROL1B(1)
    END IF
    IF (x2 .LT. 0.) THEN
      dqfac = 0.
      CALL PUSHCONTROL2B(2)
    ELSE
      dqfac = x2
      CALL PUSHCONTROL2B(1)
    END IF
  ELSE
    CALL PUSHCONTROL2B(0)
  END IF
  IF (pl .GE. 950. .AND. te .GE. 285.) THEN
    IF (0.04*pl - 38. .GT. 1.) THEN
      CALL PUSHCONTROL1B(1)
      x3 = 1.
    ELSE
      CALL PUSHCONTROL1B(1)
      x3 = 0.04*pl - 38.
    END IF
    IF (x3 .LT. 0.) THEN
      dqfac = 0.
    ELSE
      dqfac = x3
    END IF
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (pl .GE. 950. .AND. pl .LT. 975. .AND. te .GT. 280. .AND. te .LT. &
&      285.) THEN
    IF (0.04*pl + 0.2*te - 95. .GT. 1.) THEN
      CALL PUSHCONTROL1B(0)
      x4 = 1.
    ELSE
      x4 = 0.04*pl + 0.2*te - 95.
      CALL PUSHCONTROL1B(1)
    END IF
    IF (x4 .LT. 0.) THEN
      dqfac = 0.
      CALL PUSHCONTROL2B(2)
    ELSE
      dqfac = x4
      CALL PUSHCONTROL2B(1)
    END IF
  ELSE
    CALL PUSHCONTROL2B(0)
  END IF
  IF (pl .GE. 975. .AND. te .GE. 285.) THEN
    dqfac = 1.
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (dqp .LT. dqfac*qc) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  dqpb = qpb - qcb
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    dqfacb = qc*dqpb
    qcb = qcb + dqfac*dqpb
    dqpb = 0.0_4
  ELSE
    dqfacb = 0.0_4
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) dqfacb = 0.0_4
  CALL POPCONTROL2B(branch)
  IF (branch .NE. 0) THEN
    IF (branch .EQ. 1) THEN
      x4b = dqfacb
    ELSE
      x4b = 0.0_4
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) teb = teb + 0.2*x4b
    dqfacb = 0.0_4
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) dqfacb = 0.0_4
  CALL POPCONTROL2B(branch)
  IF (branch .NE. 0) THEN
    IF (branch .EQ. 1) THEN
      x2b = dqfacb
    ELSE
      x2b = 0.0_4
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) teb = teb + 0.2*x2b
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) dqpb = 0.0_4
  qcb = qcb + (1.0-EXP(-(dt*rate)))*dqpb
  rateb = EXP(-(dt*rate))*qc*dt*dqpb
  CALL POPREAL4(rate)
  f3b = rate*rateb
  rateb = f3*rateb
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) f3b = 0.0_4
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) f3b = 0.0_4
  CALL POPCONTROL2B(branch)
  IF (branch .NE. 0) THEN
    IF (branch .EQ. 1) THEN
      x1b = f3b
    ELSE
      x1b = 0.0_4
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) teb = teb + 0.2*x1b
    f3b = 0.0_4
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) f3b = 0.0_4
  CALL POPCONTROL2B(branch)
  IF (branch .NE. 0) THEN
    IF (branch .EQ. 1) teb = teb + 0.2*f3b
  END IF
  CALL POPREAL4(f3)
  temp = qcm*iqccrx
  tempb = EXP(-(temp**2))*c00x*2*temp*rateb
  c00xb = (1.0-EXP(-(temp**2)))*rateb
  qcmb = iqccrx*tempb
  iqccrxb = qcm*tempb
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    qcb = qcb + qcmb/f
    fb = fb - qc*qcmb/f**2
  END IF
  f2b = c_00*f3*c00xb + f3*iqccrxb/lwcrit
  CALL POPREAL4(f2)
  CALL CONS_SUNDQ3_B(te, teb, sundqv2, sundqv3, sundqt1, f2, f2b, f3)
END SUBROUTINE AUTOCONVERSION_CNV_B

!  Differentiation of get_ice_fraction in reverse (adjoint) mode:
!   gradient     of useful results: temp icefrct
!   with respect to varying inputs: temp
SUBROUTINE GET_ICE_FRACTION_B(temp, tempb, t_ice_all, t_ice_max, &
&  icefrpwr, icefrct, icefrctb)
  IMPLICIT NONE
!Inputs
  REAL*4, INTENT(IN) :: temp, t_ice_all, t_ice_max
  REAL*4 :: tempb
  INTEGER, INTENT(IN) :: icefrpwr
!Outputs
  REAL*4 :: icefrct
  REAL*4 :: icefrctb
  INTEGER :: branch
  INTRINSIC MAX
  INTRINSIC MIN
  CALL PUSHREAL4(icefrct)
  icefrct = 0.00
  IF (temp .LE. t_ice_all) THEN
    CALL PUSHCONTROL2B(2)
    icefrct = 1.000
  ELSE IF (temp .GT. t_ice_all .AND. temp .LE. t_ice_max) THEN
    icefrct = 1.00 - (temp-t_ice_all)/(t_ice_max-t_ice_all)
    CALL PUSHCONTROL2B(1)
  ELSE
    CALL PUSHCONTROL2B(0)
  END IF
  IF (icefrct .GT. 1.00) THEN
    icefrct = 1.00
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    icefrct = icefrct
  END IF
  IF (icefrct .LT. 0.00) THEN
    icefrct = 0.00
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    icefrct = icefrct
  END IF
  IF (icefrct .LE. 0.0 .AND. (icefrpwr .EQ. 0.0 .OR. icefrpwr .NE. INT(&
&      icefrpwr))) THEN
    icefrctb = 0.0
  ELSE
    icefrctb = icefrpwr*icefrct**(icefrpwr-1)*icefrctb
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) icefrctb = 0.0_4
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) icefrctb = 0.0_4
  CALL POPCONTROL2B(branch)
  IF (branch .NE. 0) THEN
    IF (branch .EQ. 1) tempb = tempb - icefrctb/(t_ice_max-t_ice_all)
  END IF
  CALL POPREAL4(icefrct)
END SUBROUTINE GET_ICE_FRACTION_B

!  Differentiation of cons_sundq3 in reverse (adjoint) mode:
!   gradient     of useful results: temp f2
!   with respect to varying inputs: temp
SUBROUTINE CONS_SUNDQ3_B(temp, tempb, rate2, rate3, te1, f2, f2b, f3)
  IMPLICIT NONE
!Inputs
  REAL*4, INTENT(IN) :: rate2, rate3, te1, temp
  REAL*4 :: tempb
!Outputs
  REAL*4 :: f2, f3
  REAL*4 :: f2b
!Locals
  REAL*4, PARAMETER :: te0=273.
  REAL*4, PARAMETER :: te2=200.
  REAL*4 :: jump1
  INTEGER :: branch
  INTRINSIC ABS
  REAL*4 :: abs0
  INTRINSIC MIN
  jump1 = (rate2-1.0)/(te0-te1)**0.333
!Ice - phase treatment 
  IF (temp .GE. te0) f2 = 1.0
  IF (temp .GE. te1 .AND. temp .LT. te0) THEN
    IF (te0 - temp .GE. 0.) THEN
      abs0 = te0 - temp
    ELSE
      abs0 = -(te0-temp)
    END IF
    IF (abs0 .GT. 0.0) THEN
!Linearisation security
      f2 = 1.0 + jump1*(te0-temp)**0.3333
      CALL PUSHCONTROL2B(0)
    ELSE
      CALL PUSHCONTROL2B(1)
      f2 = 1.0
    END IF
  ELSE
    CALL PUSHCONTROL2B(2)
  END IF
  IF (temp .LT. te1) THEN
    f2 = rate2 + (rate3-rate2)*(te1-temp)/(te1-te2)
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  IF (f2 .GT. 27.0) f2b = 0.0_4
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) THEN
    tempb = tempb - (rate3-rate2)*f2b/(te1-te2)
    f2b = 0.0_4
  END IF
  CALL POPCONTROL2B(branch)
  IF (branch .EQ. 0) tempb = tempb - 0.3333*(te0-temp)**(-0.6667)*jump1*&
&      f2b
END SUBROUTINE CONS_SUNDQ3_B

!  Differentiation of cons_microphys in reverse (adjoint) mode:
!   gradient     of useful results: aa temp bb q_sat alhx3
!   with respect to varying inputs: temp q_sat alhx3
SUBROUTINE CONS_MICROPHYS_B(temp, tempb, pr, q_sat, q_satb, aa, aab, bb&
&  , bbb, cons_h2omw, cons_airmw, cons_rvap, alhx3, alhx3b)
  IMPLICIT NONE
!Inputs
  REAL*4, INTENT(IN) :: temp, q_sat, pr, alhx3
  REAL*4 :: tempb, q_satb, alhx3b
  REAL*4, INTENT(IN) :: cons_h2omw, cons_airmw, cons_rvap
!Outputs
  REAL*4 :: aa, bb
  REAL*4 :: aab, bbb
!Locals
  REAL*4, PARAMETER :: k_cond=2.4e-2
  REAL*4, PARAMETER :: diffu=2.2e-5
  REAL*4 :: e_sat, epsi
  REAL*4 :: e_satb
  REAL*4 :: temp2
  REAL*4 :: temp1
  REAL*4 :: temp0
  REAL*4 :: temp0b
  REAL*4 :: temp2b
  epsi = cons_h2omw/cons_airmw
! (100 converts from mbar to Pa)
  e_sat = 100.*pr*q_sat/(epsi+(1.0-epsi)*q_sat)
  temp1 = k_cond*cons_rvap*temp**2
  temp2 = 1000.*diffu*e_sat
  temp2b = cons_rvap*pr*bbb/temp2
  tempb = tempb + temp2b - k_cond*cons_rvap*alhx3**2*2*temp*aab/temp1**2
  e_satb = -(temp*diffu*1000.*temp2b/temp2)
  alhx3b = alhx3b + 2*alhx3*aab/temp1
  temp0 = epsi + (-epsi+1.0)*q_sat
  temp0b = pr*100.*e_satb/temp0
  q_satb = q_satb + (1.0_4-q_sat*(1.0-epsi)/temp0)*temp0b
END SUBROUTINE CONS_MICROPHYS_B

!  Differentiation of cons_alhx in reverse (adjoint) mode:
!   gradient     of useful results: t alhx3
!   with respect to varying inputs: t alhx3
SUBROUTINE CONS_ALHX_B(t, tb, alhx3, alhx3b, t_ice_max, t_ice_all, &
&  cons_alhs, cons_alhl)
  IMPLICIT NONE
!Inputs
  REAL*4, INTENT(IN) :: t, t_ice_max, t_ice_all
  REAL*4 :: tb
  REAL*4, INTENT(IN) :: cons_alhs, cons_alhl
!Outputs
  REAL*4 :: alhx3
  REAL*4 :: alhx3b
  INTEGER :: branch
  IF (t .LT. t_ice_all) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (t .GT. t_ice_max) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  IF (t .LE. t_ice_max .AND. t .GE. t_ice_all) THEN
    tb = tb + (cons_alhl-cons_alhs)*alhx3b/(t_ice_max-t_ice_all)
    alhx3b = 0.0_4
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) alhx3b = 0.0_4
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) alhx3b = 0.0_4
END SUBROUTINE CONS_ALHX_B

!  Differentiation of ice_settlefall_cnv in reverse (adjoint) mode:
!   gradient     of useful results: f qi qp dz te
!   with respect to varying inputs: f qi dz te
SUBROUTINE ICE_SETTLEFALL_CNV_B(wxr, qi, qib, pl, te, teb, f, fb, &
&  cons_rgas, kh, khu, khl, k, dt, dz, dzb, qp, qpb, anv_icefall_c)
  IMPLICIT NONE
!Inputs
  REAL*4, INTENT(IN) :: wxr, pl, te, kh, dz, dt, anv_icefall_c
  REAL*4 :: teb, dzb
  REAL*4, INTENT(IN) :: cons_rgas
  INTEGER, INTENT(IN) :: khu, khl, k
  REAL*4, INTENT(INOUT) :: qi, f, qp
  REAL*4 :: qib, fb, qpb
!Locals
  REAL*4 :: rho, xim, lxim, qixp, vf
  REAL*4 :: rhob, ximb, lximb, qixpb, vfb
  INTEGER :: branch
  REAL*4 :: tempb0
  INTRINSIC MAX
  REAL*4 :: tempb
  INTRINSIC LOG10
  INTRINSIC MIN
  REAL*4 :: max1
! 1000 TAKES TO g m^-3 ; 100 takes mb TO Pa
  rho = 1000.*100.*pl/(cons_rgas*te)
  IF (f .GT. 0. .AND. qi .GT. 0.) THEN
    xim = qi/f*rho
    CALL PUSHCONTROL1B(0)
  ELSE
    xim = 0.
    CALL PUSHCONTROL1B(1)
  END IF
  IF (xim .GT. 0.) THEN
    lxim = LOG10(xim)
    CALL PUSHCONTROL1B(0)
  ELSE
    lxim = 0.0
    CALL PUSHCONTROL1B(1)
  END IF
  vf = 128.6 + 53.2*lxim + 5.5*lxim**2
!VF = VF*100./MAX(PL,10.) ! Reduce/increase fall speeds for high/low pressure (NOT in LC98!!! ) 
! Assume unmodified they represent situation at 100 mb
  IF (wxr .GT. 0.) THEN
    IF (pl .LT. 10.) THEN
      max1 = 10.
    ELSE
      max1 = pl
    END IF
    vf = vf*(100./max1)**wxr
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  vf = vf/100.
  IF (kh .GT. 2.0) THEN
    vf = 0.01*vf
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
!if ( (k .ge. KHu + 1) .and. (k .le. KHl + 1)  ) then
!   VF = 0.01 * VF
!end if
  vf = anv_icefall_c*vf
  qixp = qi*(vf*dt/dz)
  IF (qixp .GT. qi) THEN
    qixp = qi
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    qixp = qixp
  END IF
  IF (qixp .LT. 0.0) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  qixpb = qpb - qib
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) qixpb = 0.0_4
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    qib = qib + qixpb
    qixpb = 0.0_4
  END IF
  tempb0 = dt*qixpb/dz
  qib = qib + vf*tempb0
  vfb = qi*tempb0
  dzb = dzb - qi*vf*tempb0/dz
  vfb = anv_icefall_c*vfb
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) vfb = 0.01*vfb
  vfb = vfb/100.
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) vfb = (100./max1)**wxr*vfb
  lximb = (5.5*2*lxim+53.2)*vfb
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    ximb = lximb/(xim*LOG(10.0))
  ELSE
    ximb = 0.0_4
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    tempb = ximb/f
    qib = qib + rho*tempb
    rhob = qi*tempb
    fb = fb - qi*rho*tempb/f
  ELSE
    rhob = 0.0_4
  END IF
  teb = teb - pl*100.*1000.*rhob/(cons_rgas*te**2)
END SUBROUTINE ICE_SETTLEFALL_CNV_B

!  Differentiation of ice_settlefall_ls in reverse (adjoint) mode:
!   gradient     of useful results: f qi qp dz te
!   with respect to varying inputs: f qi dz te
SUBROUTINE ICE_SETTLEFALL_LS_B(wxr, qi, qib, pl, te, teb, f, fb, &
&  cons_rgas, kh, khu, khl, k, dt, dz, dzb, qp, qpb, ls_icefall_c)
  IMPLICIT NONE
!Inputs
  REAL*4, INTENT(IN) :: wxr, pl, te, kh, dz, dt, ls_icefall_c
  REAL*4 :: teb, dzb
  REAL*4, INTENT(IN) :: cons_rgas
  INTEGER, INTENT(IN) :: khu, khl, k
  REAL*4, INTENT(INOUT) :: qi, f, qp
  REAL*4 :: qib, fb, qpb
!Locals
  REAL*4 :: rho, xim, lxim, qixp, vf
  REAL*4 :: rhob, ximb, qixpb, vfb
  INTEGER :: branch
  REAL*4 :: tempb2
  REAL*4 :: tempb1
  REAL*4 :: tempb0
  INTRINSIC MAX
  INTRINSIC ABS
  REAL*4 :: tempb
  INTRINSIC LOG10
  REAL*4 :: abs0
  INTRINSIC MIN
  REAL*4 :: max1
! 1000 TAKES TO g m^-3 ; 100 takes mb TO Pa
  rho = 1000.*100.*pl/(cons_rgas*te)
  IF (f .GT. 0. .AND. qi .GT. 0.) THEN
    xim = qi/f*rho
    CALL PUSHCONTROL1B(0)
  ELSE
    xim = 0.
    CALL PUSHCONTROL1B(1)
  END IF
  IF (xim .GE. 0.) THEN
    abs0 = xim
  ELSE
    abs0 = -xim
  END IF
  IF (abs0 .GT. 0.0) THEN
!Linearisation security
    vf = 109.0*xim**0.16
    CALL PUSHCONTROL1B(0)
  ELSE
    vf = 0.0
    CALL PUSHCONTROL1B(1)
  END IF
!VF = VF*100./MAX(PL,10.) ! Reduce/increase fall speeds for high/low pressure (NOT in LC98!!! ) 
! Assume unmodified they represent situation at 100 mb
  IF (wxr .GT. 0.) THEN
    IF (pl .LT. 10.) THEN
      max1 = 10.
    ELSE
      max1 = pl
    END IF
    vf = vf*(100./max1)**wxr
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  vf = vf/100.
  IF (kh .GT. 2.0) THEN
    vf = 0.01*vf
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
!if ( (k .ge. KHu + 1) .and. (k .le. KHl + 1)  ) then
!   VF = 0.01 * VF
!end if
  vf = ls_icefall_c*vf
  qixp = qi*(vf*dt/dz)
  IF (qixp .GT. qi) THEN
    qixp = qi
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    qixp = qixp
  END IF
  IF (qixp .LT. 0.0) THEN
    qixp = 0.0
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    qixp = qixp
  END IF
  CALL PUSHREAL4(qi)
  qi = qi - qixp
  IF (qi + qixp .GT. 0.) THEN
    tempb1 = fb/(qi+qixp)
    tempb2 = -(qi*f*tempb1/(qi+qixp))
    qib = qib + tempb2 + f*tempb1
    qixpb = tempb2
    fb = qi*tempb1
  ELSE
    qixpb = 0.0_4
  END IF
  CALL POPREAL4(qi)
  qixpb = qixpb + qpb - qib
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) qixpb = 0.0_4
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    qib = qib + qixpb
    qixpb = 0.0_4
  END IF
  tempb0 = dt*qixpb/dz
  qib = qib + vf*tempb0
  vfb = qi*tempb0
  dzb = dzb - qi*vf*tempb0/dz
  vfb = ls_icefall_c*vfb
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) vfb = 0.01*vfb
  vfb = vfb/100.
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) vfb = (100./max1)**wxr*vfb
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    ximb = 109.0*0.16*xim**(-0.84)*vfb
  ELSE
    ximb = 0.0_4
  END IF
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    tempb = ximb/f
    qib = qib + rho*tempb
    rhob = qi*tempb
    fb = fb - qi*rho*tempb/f
  ELSE
    rhob = 0.0_4
  END IF
  teb = teb - pl*100.*1000.*rhob/(cons_rgas*te**2)
END SUBROUTINE ICE_SETTLEFALL_LS_B

!  Differentiation of precipandevap in reverse (adjoint) mode:
!   gradient     of useful results: evap_dd_above_out aa qv bb
!                subl_dd_above_out qcl pfi_above_out dze qddf3
!                pfl_above_out te
!   with respect to varying inputs: aa area pfl_above_in qv pfi_above_in
!                bb evap_dd_above_in qcl qpi qpl subl_dd_above_in
!                dze qddf3 te
SUBROUTINE PRECIPANDEVAP_B(k, lm, dt, frland, rhcr3, qpl, qplb, qpi, &
&  qpib, qcl, qclb, qci, te, teb, qv, qvb, mass, imass, pl, dze, dzeb, &
&  qddf3, qddf3b, aa, aab, bb, bbb, area, areab, pfl_above_in, &
&  pfl_above_inb, pfl_above_out, pfl_above_outb, pfi_above_in, &
&  pfi_above_inb, pfi_above_out, pfi_above_outb, evap_dd_above_in, &
&  evap_dd_above_inb, evap_dd_above_out, evap_dd_above_outb, &
&  subl_dd_above_in, subl_dd_above_inb, subl_dd_above_out, &
&  subl_dd_above_outb, envfc, ddrfc, cons_alhf, cons_alhs, cons_alhl, &
&  cons_cp, cons_tice, cons_h2omw, cons_airmw, revap_off_p, c_acc, c_ev_r&
&  , c_ev_s, rho_w, estblx)
  IMPLICIT NONE
!Inputs
  INTEGER, INTENT(IN) :: k, lm
  REAL*4, INTENT(IN) :: dt, mass, imass, pl, aa, bb, rhcr3, dze, qddf3, &
&  area, frland, envfc, ddrfc
  REAL*4 :: aab, bbb, dzeb, qddf3b, areab
  REAL*4, INTENT(IN) :: cons_alhf, cons_alhs, cons_alhl, cons_cp, &
&  cons_tice, cons_h2omw, cons_airmw
  REAL*4, INTENT(IN) :: revap_off_p
  REAL*4, INTENT(IN) :: c_acc, c_ev_r, c_ev_s, rho_w
  REAL*4, INTENT(IN) :: estblx(:)
!Prognostics
  REAL*4, INTENT(INOUT) :: qv, qpl, qpi, qcl, qci, te
  REAL*4 :: qvb, qplb, qpib, qclb, teb
  REAL*4, INTENT(INOUT) :: pfl_above_in, pfl_above_out, pfi_above_in, &
&  pfi_above_out
  REAL*4 :: pfl_above_inb, pfl_above_outb, pfi_above_inb, pfi_above_outb
  REAL*4, INTENT(INOUT) :: evap_dd_above_in, evap_dd_above_out, &
&  subl_dd_above_in, subl_dd_above_out
  REAL*4 :: evap_dd_above_inb, evap_dd_above_outb, subl_dd_above_inb, &
&  subl_dd_above_outb
!Locals
  INTEGER :: ns, nsmx, itr, l
  REAL*4 :: pfi, pfl, qs, dqs, envfrac, tko, qko, qstko, dqstko, rh_box&
&  , t_ed, qplko, qpiko
  REAL*4 :: pfib, pflb, qsb, dqsb, tkob, qkob, qstkob, dqstkob, rh_boxb&
&  , t_edb
  REAL*4 :: ifactor, rainrat0, snowrat0, fallrn, fallsn, vesn, vern, &
&  nrain, nsnow, efactor
  REAL*4 :: ifactorb, rainrat0b, snowrat0b, fallrnb, fallsnb, vesnb, &
&  vernb, efactorb
  REAL*4 :: tinlayerrn, diamrn, droprad, tinlayersn, diamsn, flakrad
  REAL*4 :: tinlayerrnb, diamrnb, dropradb, tinlayersnb, diamsnb, &
&  flakradb
  REAL*4 :: evap, subl, accr, mltfrz, evapx, sublx, evap_dd, subl_dd, &
&  ddfract, landseaf
  REAL*4 :: evapb, sublb, accrb, mltfrzb, evapxb, sublxb, evap_ddb, &
&  subl_ddb
  REAL*4 :: tau_frz, tau_mlt
!m/s
  REAL*4, PARAMETER :: trmv_l=1.0
  LOGICAL, PARAMETER :: taneff=.false.
!Fraction of precip falling through "environment" vs through cloud
  REAL*4, PARAMETER :: b_sub=1.00
  INTEGER :: branch
  REAL*4 :: temp3
  REAL*4 :: temp2
  REAL*4 :: temp1
  REAL*4 :: temp0
  INTRINSIC EXP
  REAL*4 :: tempb7
  REAL*4 :: tempb6
  REAL*4 :: tempb5
  REAL*4 :: tempb4
  REAL*4 :: tempb3
  REAL*4 :: tempb2
  REAL*4 :: tempb1
  REAL*4 :: tempb0
  INTRINSIC MAX
  REAL*4 :: tempb
  REAL*4 :: temp2b
  INTRINSIC MIN
  REAL*4 :: temp
  REAL*4 :: temp4
  envfrac = envfc
  IF (area .GT. 0.) THEN
    ifactor = 1./area
    CALL PUSHCONTROL1B(1)
  ELSE
    ifactor = 1.00
    CALL PUSHCONTROL1B(0)
  END IF
  IF (ifactor .LT. 1.) THEN
    ifactor = 1.
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
    ifactor = ifactor
  END IF
!Start at top of precip column:
!
!   a) Accrete                   
!   b) Evaporate/Sublimate  
!   c) Rain/Snow-out to next level down 
!   d) return to (a)
!Update saturated humidity
  CALL DQSATS_BAC(dqs, qs, te, pl, estblx, cons_h2omw, cons_airmw)
  ddfract = ddrfc
  IF (k .EQ. 1) THEN
    evap_dd = 0.
    subl_dd = 0.
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHREAL4(qpl)
    qpl = qpl + pfl_above_in*imass
    CALL PUSHREAL4(qpi)
    qpi = qpi + pfi_above_in*imass
    accr = b_sub*c_acc*(qpl*mass)*qcl
    IF (accr .GT. qcl) THEN
      accr = qcl
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      accr = accr
    END IF
    CALL PUSHREAL4(qpl)
    qpl = qpl + accr
    CALL PUSHREAL4(qcl)
    qcl = qcl - accr
!Accretion of liquid condensate by falling ice/snow
    accr = b_sub*c_acc*(qpi*mass)*qcl
    IF (accr .GT. qcl) THEN
      accr = qcl
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      accr = accr
    END IF
    CALL PUSHREAL4(qpi)
    qpi = qpi + accr
    CALL PUSHREAL4(te)
!! Liquid freezes when accreted by snow
    te = te + cons_alhf*accr/cons_cp
    rainrat0 = ifactor*qpl*mass/dt
    snowrat0 = ifactor*qpi*mass/dt
    CALL PUSHREAL4(diamrn)
    CALL MARSHPALM(rainrat0, pl, diamrn, nrain, fallrn, vern)
    CALL PUSHREAL4(diamsn)
    CALL MARSHPALM(snowrat0, pl, diamsn, nsnow, fallsn, vesn)
    tinlayerrn = dze/(fallrn+0.01)
    tinlayersn = dze/(fallsn+0.01)
!Melting of Frozen precipitation      
! time scale for freezing (s). 
    tau_frz = 5000.
    IF (te .GT. cons_tice .AND. te .LE. cons_tice + 5.) THEN
      mltfrz = tinlayersn*qpi*(te-cons_tice)/tau_frz
      IF (qpi .GT. mltfrz) THEN
        CALL PUSHCONTROL1B(0)
        mltfrz = mltfrz
      ELSE
        mltfrz = qpi
        CALL PUSHCONTROL1B(1)
      END IF
      CALL PUSHREAL4(te)
      te = te - cons_alhf*mltfrz/cons_cp
      CALL PUSHREAL4(qpl)
      qpl = qpl + mltfrz
      CALL PUSHREAL4(qpi)
      qpi = qpi - mltfrz
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (te .GT. cons_tice + 5.) THEN
! Go Ahead and melt any snow/hail left above 5 C 
      mltfrz = qpi
      te = te - cons_alhf*mltfrz/cons_cp
      CALL PUSHREAL4(qpl)
      qpl = qpl + mltfrz
      CALL PUSHREAL4(qpi)
      qpi = qpi - mltfrz
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (k .GE. lm - 1) THEN
      IF (te .GT. cons_tice + 0.) THEN
! Go Ahead and melt any snow/hail left above 0 C in lowest layers 
        mltfrz = qpi
        te = te - cons_alhf*mltfrz/cons_cp
        CALL PUSHREAL4(qpl)
        qpl = qpl + mltfrz
        CALL PUSHREAL4(qpi)
        qpi = qpi - mltfrz
        CALL PUSHCONTROL2B(0)
      ELSE
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(2)
    END IF
!Freezing of liquid precipitation      
    IF (te .LE. cons_tice) THEN
      te = te + cons_alhf*qpl/cons_cp
      CALL PUSHREAL4(qpi)
      qpi = qpl + qpi
      CALL PUSHREAL4(qpl)
      qpl = 0.
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
!In the exp below, evaporation time scale is determined "microphysically" from temp, 
!press, and drop size. In this context C_EV becomes a dimensionless fudge-fraction. 
!Also remember that these microphysics are still only for liquid.
    qko = qv
    tko = te
    DO itr=1,3
      dqstko = dqs
      CALL PUSHREAL4(qstko)
      qstko = qs + dqstko*(tko-te)
      IF (qstko .LT. 1.0e-7) THEN
        qstko = 1.0e-7
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
        qstko = qstko
      END IF
      CALL PUSHREAL4(rh_box)
      rh_box = qko/qstko
      IF (rh_box .LT. rhcr3) THEN
        CALL PUSHREAL4(efactor)
        efactor = rho_w*(aa+bb)/(rhcr3-rh_box)
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHREAL4(efactor)
        efactor = 9.99e9
        CALL PUSHCONTROL1B(1)
      END IF
      landseaf = 1.00
!Rain falling
      IF (rh_box .LT. rhcr3 .AND. diamrn .GT. 0.00 .AND. pl .GT. 100. &
&          .AND. pl .LT. revap_off_p) THEN
        droprad = 0.5*diamrn
        CALL PUSHREAL4(t_ed)
        t_ed = efactor*droprad**2
        CALL PUSHREAL4(t_ed)
        t_ed = t_ed*(1.0+dqstko*cons_alhl/cons_cp)
        evap = qpl*(1.0-EXP(-(c_ev_r*vern*landseaf*envfrac*tinlayerrn/&
&          t_ed)))
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
        evap = 0.0
      END IF
!Snow falling
      IF (rh_box .LT. rhcr3 .AND. diamsn .GT. 0.00 .AND. pl .GT. 100. &
&          .AND. pl .LT. revap_off_p) THEN
        flakrad = 0.5*diamsn
        CALL PUSHREAL4(t_ed)
        t_ed = efactor*flakrad**2
        CALL PUSHREAL4(t_ed)
        t_ed = t_ed*(1.0+dqstko*cons_alhs/cons_cp)
        subl = qpi*(1.0-EXP(-(c_ev_s*vesn*landseaf*envfrac*tinlayersn/&
&          t_ed)))
        CALL PUSHCONTROL1B(0)
      ELSE
        subl = 0.0
        CALL PUSHCONTROL1B(1)
      END IF
      IF (itr .EQ. 1) THEN
        evapx = evap
        sublx = subl
        CALL PUSHCONTROL1B(0)
      ELSE
        evap = (evap+evapx)/2.0
        subl = (subl+sublx)/2.0
        CALL PUSHCONTROL1B(1)
      END IF
      CALL PUSHREAL4(qko)
      qko = qv + evap + subl
      CALL PUSHREAL4(tko)
      tko = te - evap*cons_alhl/cons_cp - subl*cons_alhs/cons_cp
    END DO
!Put some re-evap/re-subl precip in to a \quote{downdraft} to be applied later
    evap_dd = evap_dd_above_in + ddfract*evap*mass
    subl_dd = subl_dd_above_in + ddfract*subl*mass
    CALL PUSHCONTROL1B(1)
  END IF
  sublb = qvb - cons_alhs*teb/cons_cp
  evapb = qvb - cons_alhl*teb/cons_cp
  subl_ddb = qddf3*sublb/mass + subl_dd_above_outb
  evap_ddb = qddf3*evapb/mass + evap_dd_above_outb
  pfib = pfi_above_outb
  pflb = pfl_above_outb
  qddf3b = qddf3b + evap_dd*evapb/mass + subl_dd*sublb/mass
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    qpib = mass*pfib
    qplb = mass*pflb
    pfl_above_inb = 0.0_4
    pfi_above_inb = 0.0_4
    evap_dd_above_inb = 0.0_4
    subl_dd_above_inb = 0.0_4
    dqsb = 0.0_4
    qsb = 0.0_4
    ifactorb = 0.0_4
  ELSE
    qpib = mass*pfib
    qplb = mass*pflb
    evapb = qvb - cons_alhl*teb/cons_cp
    sublb = qvb - cons_alhs*teb/cons_cp
    sublb = ddfract*mass*subl_ddb - qpib + (1.0_4-ddfract)*sublb
    subl_dd_above_inb = subl_ddb
    evapb = ddfract*mass*evap_ddb - qplb + (1.0_4-ddfract)*evapb
    evap_dd_above_inb = evap_ddb
    tkob = 0.0_4
    sublxb = 0.0_4
    dqsb = 0.0_4
    qsb = 0.0_4
    qkob = 0.0_4
    diamrnb = 0.0_4
    vernb = 0.0_4
    tinlayerrnb = 0.0_4
    diamsnb = 0.0_4
    evapxb = 0.0_4
    vesnb = 0.0_4
    tinlayersnb = 0.0_4
    DO itr=3,1,-1
      CALL POPREAL4(tko)
      teb = teb + tkob
      evapb = evapb + qkob - cons_alhl*tkob/cons_cp
      sublb = sublb + qkob - cons_alhs*tkob/cons_cp
      CALL POPREAL4(qko)
      qvb = qvb + qkob
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        sublb = sublb + sublxb
        evapb = evapb + evapxb
        sublxb = 0.0_4
        evapxb = 0.0_4
      ELSE
        sublxb = sublxb + sublb/2.0
        sublb = sublb/2.0
        evapxb = evapxb + evapb/2.0
        evapb = evapb/2.0
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        landseaf = 1.00
        temp2 = vesn*tinlayersn/t_ed
        temp4 = c_ev_s*landseaf*envfrac
        temp3 = -(temp4*temp2)
        temp2b = temp4*EXP(temp3)*qpi*sublb/t_ed
        qpib = qpib + (1.0-EXP(temp3))*sublb
        vesnb = vesnb + tinlayersn*temp2b
        tinlayersnb = tinlayersnb + vesn*temp2b
        t_edb = -(temp2*temp2b)
        dqstko = dqs
        flakrad = 0.5*diamsn
        CALL POPREAL4(t_ed)
        dqstkob = cons_alhs*t_ed*t_edb/cons_cp
        t_edb = (cons_alhs*(dqstko/cons_cp)+1.0)*t_edb
        CALL POPREAL4(t_ed)
        efactorb = flakrad**2*t_edb
        flakradb = efactor*2*flakrad*t_edb
        diamsnb = diamsnb + 0.5*flakradb
      ELSE
        landseaf = 1.00
        dqstko = dqs
        dqstkob = 0.0_4
        efactorb = 0.0_4
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        temp = vern*tinlayerrn/t_ed
        temp1 = c_ev_r*landseaf*envfrac
        temp0 = -(temp1*temp)
        tempb7 = temp1*EXP(temp0)*qpl*evapb/t_ed
        qplb = qplb + (1.0-EXP(temp0))*evapb
        vernb = vernb + tinlayerrn*tempb7
        tinlayerrnb = tinlayerrnb + vern*tempb7
        t_edb = -(temp*tempb7)
        droprad = 0.5*diamrn
        CALL POPREAL4(t_ed)
        dqstkob = dqstkob + cons_alhl*t_ed*t_edb/cons_cp
        t_edb = (cons_alhl*(dqstko/cons_cp)+1.0)*t_edb
        CALL POPREAL4(t_ed)
        efactorb = efactorb + droprad**2*t_edb
        dropradb = efactor*2*droprad*t_edb
        diamrnb = diamrnb + 0.5*dropradb
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL4(efactor)
        tempb6 = rho_w*efactorb/(rhcr3-rh_box)
        aab = aab + tempb6
        bbb = bbb + tempb6
        rh_boxb = (aa+bb)*tempb6/(rhcr3-rh_box)
      ELSE
        CALL POPREAL4(efactor)
        rh_boxb = 0.0_4
      END IF
      CALL POPREAL4(rh_box)
      qkob = rh_boxb/qstko
      qstkob = -(qko*rh_boxb/qstko**2)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) qstkob = 0.0_4
      CALL POPREAL4(qstko)
      qsb = qsb + qstkob
      dqstkob = dqstkob + (tko-te)*qstkob
      tkob = dqstko*qstkob
      teb = teb - dqstko*qstkob
      dqsb = dqsb + dqstkob
      evapb = 0.0_4
      sublb = 0.0_4
    END DO
    teb = teb + tkob
    qvb = qvb + qkob
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL4(qpl)
      CALL POPREAL4(qpi)
      qplb = cons_alhf*teb/cons_cp + qpib
    END IF
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL4(qpi)
      mltfrzb = qplb - cons_alhf*teb/cons_cp - qpib
      CALL POPREAL4(qpl)
      qpib = qpib + mltfrzb
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL4(qpi)
      mltfrzb = qplb - cons_alhf*teb/cons_cp - qpib
      CALL POPREAL4(qpl)
      qpib = qpib + mltfrzb
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL4(qpi)
      mltfrzb = qplb - cons_alhf*teb/cons_cp - qpib
      CALL POPREAL4(qpl)
      CALL POPREAL4(te)
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        qpib = qpib + mltfrzb
        mltfrzb = 0.0_4
      END IF
      tempb5 = (te-cons_tice)*mltfrzb/tau_frz
      tinlayersnb = tinlayersnb + qpi*tempb5
      qpib = qpib + tinlayersn*tempb5
      teb = teb + tinlayersn*qpi*mltfrzb/tau_frz
    END IF
    tempb2 = tinlayerrnb/(fallrn+0.01)
    tempb1 = tinlayersnb/(fallsn+0.01)
    dzeb = dzeb + tempb2 + tempb1
    fallsnb = -(dze*tempb1/(fallsn+0.01))
    fallrnb = -(dze*tempb2/(fallrn+0.01))
    CALL POPREAL4(diamsn)
    CALL MARSHPALM_B(snowrat0, snowrat0b, pl, diamsn, diamsnb, nsnow, &
&               fallsn, fallsnb, vesn, vesnb)
    CALL POPREAL4(diamrn)
    CALL MARSHPALM_B(rainrat0, rainrat0b, pl, diamrn, diamrnb, nrain, &
&               fallrn, fallrnb, vern, vernb)
    tempb3 = mass*snowrat0b/dt
    qpib = qpib + ifactor*tempb3
    tempb4 = mass*rainrat0b/dt
    ifactorb = qpl*tempb4 + qpi*tempb3
    qplb = qplb + ifactor*tempb4
    CALL POPREAL4(te)
    accrb = qpib - qclb + cons_alhf*teb/cons_cp
    CALL POPREAL4(qpi)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qclb = qclb + accrb
      accrb = 0.0_4
    END IF
    tempb0 = b_sub*c_acc*mass*accrb
    qpib = qpib + qcl*tempb0
    qclb = qclb + qpi*tempb0
    CALL POPREAL4(qcl)
    accrb = qplb - qclb
    CALL POPREAL4(qpl)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qclb = qclb + accrb
      accrb = 0.0_4
    END IF
    tempb = b_sub*c_acc*mass*accrb
    qplb = qplb + qcl*tempb
    qclb = qclb + qpl*tempb
    CALL POPREAL4(qpi)
    pfi_above_inb = imass*qpib
    CALL POPREAL4(qpl)
    pfl_above_inb = imass*qplb
  END IF
  CALL DQSATS_BAC_B(dqs, dqsb, qs, qsb, te, teb, pl, estblx, cons_h2omw&
&              , cons_airmw)
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) ifactorb = 0.0_4
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    areab = 0.0_4
  ELSE
    areab = -(ifactorb/area**2)
  END IF
END SUBROUTINE PRECIPANDEVAP_B

!  Differentiation of marshpalm in reverse (adjoint) mode:
!   gradient     of useful results: diam3 w ve
!   with respect to varying inputs: rain
SUBROUTINE MARSHPALM_B(rain, rainb, pr, diam3, diam3b, ntotal, w, wb, ve&
&  , veb)
  IMPLICIT NONE
!Inputs
! in kg m^-2 s^-1, mbar
  REAL*4, INTENT(IN) :: rain, pr
  REAL*4 :: rainb
!Outputs
  REAL*4 :: diam3, ntotal, w, ve
  REAL*4 :: diam3b, wb, veb
!Locals
  INTEGER :: iqd
!cm^-3
  REAL*4, PARAMETER :: n0=0.08
  REAL*4 :: rain_day, slopr, diam1
  REAL*4 :: rain_dayb
  REAL*4 :: rx(8), d3x(8)
  INTEGER :: branch
  INTRINSIC MAX
  INTRINSIC SQRT
!Marshall-Palmer sizes at different rain-rates: avg(D^3)
!RX = (/ 0.   , 5.   , 20.  , 80.  , 320. , 1280., 5120., 20480. /)  ! rain per in mm/day
  rx(1) = 0.
  rx(2) = 5.
  rx(3) = 20.
  rx(4) = 80.
  rx(5) = 320.
  rx(6) = 1280.
  rx(7) = 5120.
  rx(8) = 20480.
!D3X= (/ 0.019, 0.032, 0.043, 0.057, 0.076, 0.102, 0.137, 0.183  /)
  d3x(1) = 0.019
  d3x(2) = 0.032
  d3x(3) = 0.043
  d3x(4) = 0.057
  d3x(5) = 0.076
  d3x(6) = 0.102
  d3x(7) = 0.137
  d3x(8) = 0.183
  rain_day = rain*3600.*24.
  IF (rain_day .LE. 0.00) diam3 = 0.00
  DO iqd=1,7
    IF (rain_day .LE. rx(iqd+1) .AND. rain_day .GT. rx(iqd)) THEN
      CALL PUSHREAL4(slopr)
      slopr = (d3x(iqd+1)-d3x(iqd))/(rx(iqd+1)-rx(iqd))
      diam3 = d3x(iqd) + (rain_day-rx(iqd))*slopr
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
  END DO
  IF (rain_day .GE. rx(8)) THEN
    diam3 = d3x(8)
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  diam3 = 0.664*diam3
  w = (2483.8*diam3+80.)*SQRT(1000./pr)
  IF (0.99*w/100. .LT. 1.000) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    CALL PUSHCONTROL1B(1)
  END IF
  wb = wb/100.
  diam3b = diam3b/100.
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) wb = wb + 0.99*veb/100.
  diam3b = diam3b + SQRT(1000./pr)*2483.8*wb
  diam3b = 0.664*diam3b
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) diam3b = 0.0_4
  rain_dayb = 0.0_4
  DO iqd=7,1,-1
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      rain_dayb = rain_dayb + slopr*diam3b
      CALL POPREAL4(slopr)
      diam3b = 0.0_4
    END IF
  END DO
  rainb = 24.*3600.*rain_dayb
END SUBROUTINE MARSHPALM_B

!  Differentiation of dqsat_bac in reverse (adjoint) mode:
!   gradient     of useful results: temp qssi
!   with respect to varying inputs: temp
SUBROUTINE DQSAT_BAC_B(dqsi, qssi, qssib, temp, tempb, plo, im, jm, lm, &
&  estblx, cons_h2omw, cons_airmw)
  IMPLICIT NONE
!Inputs
  INTEGER :: im, jm, lm
  REAL*4, DIMENSION(im, jm, lm) :: temp, plo
  REAL*4, DIMENSION(im, jm, lm) :: tempb
  REAL*4 :: estblx(:)
  REAL*4 :: cons_h2omw, cons_airmw
!Outputs
  REAL*4, DIMENSION(im, jm, lm) :: dqsi, qssi
  REAL*4, DIMENSION(im, jm, lm) :: qssib
!Locals
  REAL*4, PARAMETER :: max_mixing_ratio=1.0
  REAL*4 :: esfac
  INTEGER :: i, j, k
  REAL*4 :: tl, tt, ti, dqsat, qsat, dqq, qq, pl, pp, dd
  REAL*4 :: tlb, ttb, tib, qsatb, qqb, ddb
  INTEGER :: it
  INTEGER, PARAMETER :: degsubs=100
  REAL*4, PARAMETER :: tmintbl=150.0, tmaxtbl=333.0
  INTEGER, PARAMETER :: tablesize=NINT(tmaxtbl-tmintbl)*degsubs+1
  INTEGER :: branch
  REAL*4 :: temp0
  INTRINSIC NINT
  INTRINSIC INT
  esfac = cons_h2omw/cons_airmw
  DO k=1,lm
    DO j=1,jm
      DO i=1,im
        tl = temp(i, j, k)
        pl = plo(i, j, k)
        pp = pl*100.0
        IF (tl .LE. tmintbl) THEN
          ti = tmintbl
          CALL PUSHCONTROL2B(0)
        ELSE IF (tl .GE. tmaxtbl - .001) THEN
          ti = tmaxtbl - .001
          CALL PUSHCONTROL2B(1)
        ELSE
          ti = tl
          CALL PUSHCONTROL2B(2)
        END IF
        tt = (ti-tmintbl)*degsubs + 1
        it = INT(tt)
        CALL PUSHREAL4(dqq)
        dqq = estblx(it+1) - estblx(it)
        CALL PUSHREAL4(qq)
        qq = (tt-it)*dqq + estblx(it)
        IF (pp .LE. qq) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
      END DO
    END DO
  END DO
  DO k=lm,1,-1
    DO j=jm,1,-1
      DO i=im,1,-1
        qsatb = qssib(i, j, k)
        qssib(i, j, k) = 0.0_4
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          qqb = 0.0_4
        ELSE
          pl = plo(i, j, k)
          pp = pl*100.0
          dd = 1.0/(pp-(1.0-esfac)*qq)
          ddb = esfac*qq*qsatb
          temp0 = pp - (-esfac+1.0)*qq
          qqb = (1.0-esfac)*ddb/temp0**2 + esfac*dd*qsatb
        END IF
        CALL POPREAL4(qq)
        ttb = dqq*qqb
        CALL POPREAL4(dqq)
        tib = degsubs*ttb
        CALL POPCONTROL2B(branch)
        IF (branch .EQ. 0) THEN
          tlb = 0.0_4
        ELSE IF (branch .EQ. 1) THEN
          tlb = 0.0_4
        ELSE
          tlb = tib
        END IF
        tempb(i, j, k) = tempb(i, j, k) + tlb
      END DO
    END DO
  END DO
END SUBROUTINE DQSAT_BAC_B

!  Differentiation of dqsats_bac in reverse (adjoint) mode:
!   gradient     of useful results: temp dqsi qssi
!   with respect to varying inputs: temp
SUBROUTINE DQSATS_BAC_B(dqsi, dqsib, qssi, qssib, temp, tempb, plo, &
&  estblx, cons_h2omw, cons_airmw)
  IMPLICIT NONE
!Inputs
  REAL*4 :: temp, plo
  REAL*4 :: tempb
  REAL*4 :: estblx(:)
  REAL*4 :: cons_h2omw, cons_airmw
!Outputs
  REAL*4 :: dqsi, qssi
  REAL*4 :: dqsib, qssib
!Locals
  REAL*4, PARAMETER :: max_mixing_ratio=1.0
  REAL*4 :: esfac
  REAL*4 :: tl, tt, ti, dqsat, qsat, dqq, qq, pl, pp, dd
  REAL*4 :: tlb, ttb, tib, dqsatb, qsatb, qqb, ddb
  INTEGER :: it
  INTEGER, PARAMETER :: degsubs=100
  REAL*4, PARAMETER :: tmintbl=150.0, tmaxtbl=333.0
  INTEGER, PARAMETER :: tablesize=NINT(tmaxtbl-tmintbl)*degsubs+1
  INTEGER :: branch
  REAL*4 :: temp0
  INTRINSIC NINT
  INTRINSIC INT
  esfac = cons_h2omw/cons_airmw
  tl = temp
  pl = plo
  pp = pl*100.0
  IF (tl .LE. tmintbl) THEN
    ti = tmintbl
    CALL PUSHCONTROL2B(0)
  ELSE IF (tl .GE. tmaxtbl - .001) THEN
    ti = tmaxtbl - .001
    CALL PUSHCONTROL2B(1)
  ELSE
    ti = tl
    CALL PUSHCONTROL2B(2)
  END IF
  tt = (ti-tmintbl)*degsubs + 1
  it = INT(tt)
  dqq = estblx(it+1) - estblx(it)
  qq = (tt-it)*dqq + estblx(it)
  IF (pp .LE. qq) THEN
    CALL PUSHCONTROL1B(0)
  ELSE
    dd = 1.0/(pp-(1.0-esfac)*qq)
    CALL PUSHCONTROL1B(1)
  END IF
  qsatb = qssib
  dqsatb = dqsib
  CALL POPCONTROL1B(branch)
  IF (branch .EQ. 0) THEN
    qqb = 0.0_4
  ELSE
    temp0 = pp - (-esfac+1.0)*qq
    ddb = esfac*qq*qsatb + esfac*degsubs*dqq*pp*2*dd*dqsatb
    qqb = (1.0-esfac)*ddb/temp0**2 + esfac*dd*qsatb
  END IF
  ttb = dqq*qqb
  tib = degsubs*ttb
  CALL POPCONTROL2B(branch)
  IF (branch .EQ. 0) THEN
    tlb = 0.0_4
  ELSE IF (branch .EQ. 1) THEN
    tlb = 0.0_4
  ELSE
    tlb = tib
  END IF
  tempb = tempb + tlb
END SUBROUTINE DQSATS_BAC_B

END MODULE CLOUD_AD
