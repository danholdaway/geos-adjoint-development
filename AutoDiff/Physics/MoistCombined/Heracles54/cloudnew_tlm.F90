!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.11 (r5903) - 14 Dec 2015 10:32
!
! $Id: cloudnew.F90,v 1.40.2.7.2.2.10.1.4.1.4.8.2.1.2.3.6.10.24.1.4.1.2.1.2.1.12.3.4.5.12.1.2.42.2.18.2.12.2.16.2.4.8.1.42.3.10.1
!.46.2.2.2.16.1.6.4.12.1.2.1 2016-09-08 17:43:05 ltakacs Exp $
! $Name: drh-GEOSadas-5_16_0_H54 $
MODULE CLOUDNEW_D
!#ifndef _CUDA
!   use GEOS_UtilsMod,     only: QSAT=>GEOS_Qsat, DQSAT=>GEOS_DQsat
  USE CLDPARAMS
!#else
!   use cudafor
!   ! NOTE: GPUs use the QSAT and DQSAT at the end of this module
!#endif
  USE MAPL_CONSTANTSMOD, ONLY : mapl8_tice, mapl8_cp, mapl8_grav, &
& mapl8_alhs, mapl8_alhl, mapl8_alhf, mapl8_rgas, mapl8_h2omw, &
& mapl8_airmw, mapl8_rvap, mapl8_pi, mapl8_r8, mapl8_r4
!   use MAPL_BaseMod,      only: MAPL_UNDEF
  USE QSAT_UTIL_D
  IMPLICIT NONE
!#ifndef _CUDA
  PRIVATE 
  PUBLIC progno_cloud, pre_progno_cloud
  PUBLIC progno_cloud_tlm, pre_progno_cloud_tlm
!PUBLIC ICE_FRACTION
  PUBLIC t_cloud_ctl
!#endif
  TYPE T_CLOUD_CTL
      REAL*8 :: sclmfdfr
      REAL*8 :: rsub_radius
  END TYPE T_CLOUD_CTL
!#ifdef _CUDA
!
!   ! Inputs
!   ! ------
!
!   real(8), allocatable, dimension(:,:), device :: PP_dev
!   real(8), allocatable, dimension(:,:), device :: EXNP_dev
!   real(8), allocatable, dimension(:,:), device :: PPE_dev
!   real(8), allocatable, dimension(:,:), device :: KH_dev
!   real(8), allocatable, dimension(:  ), device :: FRLAND_dev
!   real(8), allocatable, dimension(:,:), device :: RMFDTR_dev
!   real(8), allocatable, dimension(:,:), device :: QLWDTR_dev
!   real(8), allocatable, dimension(:,:), device :: U_dev
!   real(8), allocatable, dimension(:,:), device :: V_dev
!   real(8), allocatable, dimension(:,:), device :: QST3_dev
!   real(8), allocatable, dimension(:,:), device :: DZET_dev
!   real(8), allocatable, dimension(:,:), device :: QDDF3_dev
!   real(8), allocatable, dimension(:  ), device :: TEMPOR_dev
!   real(8), allocatable, dimension(:  ), device :: CNV_FRACTION_dev
!
!   ! Inoutputs
!   ! ---------
!
!   real(8), allocatable, dimension(:,:), device :: TH_dev
!   real(8), allocatable, dimension(:,:), device :: Q_dev
!   real(8), allocatable, dimension(:,:), device :: QRN_CU_dev
!   real(8), allocatable, dimension(:,:), device :: CNV_UPDFRC_dev ! on edges, but dims=1:LM
!   real(8), allocatable, dimension(:,:), device :: QLW_LS_dev  
!   real(8), allocatable, dimension(:,:), device :: QLW_AN_dev
!   real(8), allocatable, dimension(:,:), device :: QIW_LS_dev  
!   real(8), allocatable, dimension(:,:), device :: QIW_AN_dev
!   real(8), allocatable, dimension(:,:), device :: ANVFRC_dev
!   real(8), allocatable, dimension(:,:), device :: CLDFRC_dev
!
!   ! Outputs
!   ! -------
!
!   real(8), allocatable, dimension(:,:), device :: RAD_CLDFRC_dev
!   real(8), allocatable, dimension(:,:), device :: RAD_QL_dev
!   real(8), allocatable, dimension(:,:), device :: RAD_QI_dev
!   real(8), allocatable, dimension(:,:), device :: RAD_QR_dev
!   real(8), allocatable, dimension(:,:), device :: RAD_QS_dev
!   real(8), allocatable, dimension(:,:), device :: QPLS_dev
!   real(8), allocatable, dimension(:,:), device :: CLDREFFL_dev
!   real(8), allocatable, dimension(:,:), device :: CLDREFFI_dev
!   real(8), allocatable, dimension(:  ), device :: PRELS_dev
!   real(8), allocatable, dimension(:  ), device :: PRECU_dev
!   real(8), allocatable, dimension(:  ), device :: PREAN_dev
!   real(8), allocatable, dimension(:  ), device :: LSARF_dev
!   real(8), allocatable, dimension(:  ), device :: CUARF_dev
!   real(8), allocatable, dimension(:  ), device :: ANARF_dev
!   real(8), allocatable, dimension(:  ), device :: SNRLS_dev
!   real(8), allocatable, dimension(:  ), device :: SNRCU_dev
!   real(8), allocatable, dimension(:  ), device :: SNRAN_dev
!
!   real(8), allocatable, dimension(:,:), device :: PFL_CN_dev
!   real(8), allocatable, dimension(:,:), device :: PFI_CN_dev
!   real(8), allocatable, dimension(:,:), device :: PFL_AN_dev
!   real(8), allocatable, dimension(:,:), device :: PFI_AN_dev
!   real(8), allocatable, dimension(:,:), device :: PFL_LS_dev
!   real(8), allocatable, dimension(:,:), device :: PFI_LS_dev
!
!   real(8), allocatable, dimension(:,:), device :: RHX_dev
!   real(8), allocatable, dimension(:,:), device :: REV_LS_dev
!   real(8), allocatable, dimension(:,:), device :: REV_AN_dev
!   real(8), allocatable, dimension(:,:), device :: REV_CN_dev
!   real(8), allocatable, dimension(:,:), device :: RSU_LS_dev
!   real(8), allocatable, dimension(:,:), device :: RSU_AN_dev
!   real(8), allocatable, dimension(:,:), device :: RSU_CN_dev
!   real(8), allocatable, dimension(:,:), device :: ACLL_CN_dev
!   real(8), allocatable, dimension(:,:), device :: ACIL_CN_dev
!   real(8), allocatable, dimension(:,:), device :: ACLL_AN_dev
!   real(8), allocatable, dimension(:,:), device :: ACIL_AN_dev
!   real(8), allocatable, dimension(:,:), device :: ACLL_LS_dev
!   real(8), allocatable, dimension(:,:), device :: ACIL_LS_dev
!   real(8), allocatable, dimension(:,:), device :: PDFL_dev
!   real(8), allocatable, dimension(:,:), device :: PDFI_dev
!   real(8), allocatable, dimension(:,:), device :: FIXL_dev
!   real(8), allocatable, dimension(:,:), device :: FIXI_dev                          
!   real(8), allocatable, dimension(:,:), device :: AUT_dev
!   real(8), allocatable, dimension(:,:), device :: EVAPC_dev
!   real(8), allocatable, dimension(:,:), device :: SDM_dev
!   real(8), allocatable, dimension(:,:), device :: SUBLC_dev 
!   real(8), allocatable, dimension(:,:), device :: FRZ_TT_dev
!   real(8), allocatable, dimension(:,:), device :: FRZ_PP_dev
!   real(8), allocatable, dimension(:,:), device :: DCNVL_dev
!   real(8), allocatable, dimension(:,:), device :: DCNVi_dev
!   real(8), allocatable, dimension(:,:), device :: ALPHT_dev
!   real(8), allocatable, dimension(:,:), device :: ALPH1_dev
!   real(8), allocatable, dimension(:,:), device :: ALPH2_dev
!   real(8), allocatable, dimension(:,:), device :: CFPDF_dev
!   real(8), allocatable, dimension(:,:), device :: RHCLR_dev
!   real(8), allocatable, dimension(:,:), device :: DQRL_dev
!   real(8), allocatable, dimension(:,:), device :: VFALLICE_AN_dev
!   real(8), allocatable, dimension(:,:), device :: VFALLICE_LS_dev
!   real(8), allocatable, dimension(:,:), device :: VFALLWAT_AN_dev
!   real(8), allocatable, dimension(:,:), device :: VFALLWAT_LS_dev
!   real(8), allocatable, dimension(:,:), device :: VFALLSN_AN_dev
!   real(8), allocatable, dimension(:,:), device :: VFALLSN_LS_dev
!   real(8), allocatable, dimension(:,:), device :: VFALLSN_CN_dev
!   real(8), allocatable, dimension(:,:), device :: VFALLRN_AN_dev
!   real(8), allocatable, dimension(:,:), device :: VFALLRN_LS_dev
!   real(8), allocatable, dimension(:,:), device :: VFALLRN_CN_dev
!
!   real(8), allocatable, dimension(:,:), device :: LIQANMOVE_dev
!   real(8), allocatable, dimension(:,:), device :: ICEANMOVE_dev
!   real(8), allocatable, dimension(:,:), device :: DANCLD_dev
!   real(8), allocatable, dimension(:,:), device :: DLSCLD_dev
!   real(8), allocatable, dimension(:,:), device :: CURAINMOVE_dev
!   real(8), allocatable, dimension(:,:), device :: CUSNOWMOVE_dev
!
!   ! Constants passed in from CLDPARAMS (from MAPL_GetResource)
!   real(8),    constant :: CNV_BETA
!   real(8),    constant :: ANV_BETA
!   real(8),    constant :: LS_BETA
!   real(8),    constant :: RH00
!   real(8),    constant :: C_00
!   real(8),    constant :: LWCRIT
!   real(8),    constant :: C_ACC
!   real(8),    constant :: C_EV_R
!   real(8),    constant :: C_EV_S
!   real(8),    constant :: CLDVOL2FRC
!   real(8),    constant :: RHSUP_ICE
!   real(8),    constant :: SHR_EVAP_FAC
!   real(8),    constant :: MIN_CLD_WATER
!   real(8),    constant :: CLD_EVP_EFF
!   integer, constant :: NSMAX
!   real(8),    constant :: LS_SDQV2
!   real(8),    constant :: LS_SDQV3
!   real(8),    constant :: LS_SDQVT1
!   real(8),    constant :: ANV_SDQV2
!   real(8),    constant :: ANV_SDQV3
!   real(8),    constant :: ANV_SDQVT1
!   real(8),    constant :: ANV_TO_LS
!   real(8),    constant :: N_WARM
!   real(8),    constant :: N_ICE
!   real(8),    constant :: N_ANVIL
!   real(8),    constant :: N_PBL
!   integer, constant :: DISABLE_RAD
!   integer, constant :: ICE_SETTLE
!   real(8),    constant :: ANV_ICEFALL_C
!   real(8),    constant :: LS_ICEFALL_C
!   real(8),    constant :: REVAP_OFF_P
!   real(8),    constant :: CNVENVFC
!   real(8),    constant :: WRHODEP
!   real(8),    constant :: T_ICE_ALL
!   real(8),    constant :: CNVICEPARAM
!   integer, constant :: ICEFRPWR
!   real(8),    constant :: CNVDDRFC
!   real(8),    constant :: ANVDDRFC
!   real(8),    constant :: LSDDRFC
!   integer, constant :: TANHRHCRIT
!   real(8),    constant :: MINRHCRIT
!   real(8),    constant :: MAXRHCRIT
!   real(8),    constant :: TURNRHCRIT
!   real(8),    constant :: MAXRHCRITLAND
!   integer, constant :: FR_LS_WAT
!   integer, constant :: FR_LS_ICE
!   integer, constant :: FR_AN_WAT
!   integer, constant :: FR_AN_ICE
!   real(8),    constant :: MIN_RL
!   real(8),    constant :: MIN_RI
!   real(8),    constant :: MAX_RL
!   real(8),    constant :: MAX_RI
!   real(8),    constant :: RI_ANV
!   integer, constant :: PDFFLAG
!
!   ! Parameters for Internal DQSAT
!   ! -----------------------------
!
!   real(8), parameter :: ESFAC            = MAPL8_H2OMW/MAPL8_AIRMW
!   real(8), parameter :: MAX_MIXING_RATIO = 1.
!   real(8), parameter :: ZEROC            = MAPL8_TICE
!
!   real(8), parameter :: TMINTBL   =  150.0
!   real(8), parameter :: TMAXTBL   =  333.0
!   real(8), parameter :: DEGSUBS   =  100
!   real(8), parameter :: ERFAC     = (DEGSUBS/ESFAC)
!   real(8), parameter :: DELTA_T   =  1.0 / DEGSUBS
!   real(8), parameter :: TABLESIZE =  nint(TMAXTBL-TMINTBL)*DEGSUBS + 1
!   real(8), parameter :: TMIX      = -20.
!
!   real(8), parameter :: TMINSTR = -95.
!   real(8), parameter :: TSTARR1 = -75.
!   real(8), parameter :: TSTARR2 = -65.
!   real(8), parameter :: TSTARR3 = -50.
!   real(8), parameter :: TSTARR4 = -40.
!   real(8), parameter :: TMAXSTR = +60.
!
!   real(kind=MAPL_R8), parameter :: B6 = 6.136820929E-11*100.0
!   real(kind=MAPL_R8), parameter :: B5 = 2.034080948E-8 *100.0
!   real(kind=MAPL_R8), parameter :: B4 = 3.031240396E-6 *100.0
!   real(kind=MAPL_R8), parameter :: B3 = 2.650648471E-4 *100.0
!   real(kind=MAPL_R8), parameter :: B2 = 1.428945805E-2 *100.0
!   real(kind=MAPL_R8), parameter :: B1 = 4.436518521E-1 *100.0
!   real(kind=MAPL_R8), parameter :: B0 = 6.107799961E+0 *100.0
!   real(kind=MAPL_R8), parameter :: BI6= 1.838826904E-10*100.0
!   real(kind=MAPL_R8), parameter :: BI5= 4.838803174E-8 *100.0
!   real(kind=MAPL_R8), parameter :: BI4= 5.824720280E-6 *100.0
!   real(kind=MAPL_R8), parameter :: BI3= 4.176223716E-4 *100.0
!   real(kind=MAPL_R8), parameter :: BI2= 1.886013408E-2 *100.0
!   real(kind=MAPL_R8), parameter :: BI1= 5.034698970E-1 *100.0
!   real(kind=MAPL_R8), parameter :: BI0= 6.109177956E+0 *100.0
!   real(kind=MAPL_R8), parameter :: S16= 0.516000335E-11*100.0
!   real(kind=MAPL_R8), parameter :: S15= 0.276961083E-8 *100.0
!   real(kind=MAPL_R8), parameter :: S14= 0.623439266E-6 *100.0
!   real(kind=MAPL_R8), parameter :: S13= 0.754129933E-4 *100.0
!   real(kind=MAPL_R8), parameter :: S12= 0.517609116E-2 *100.0
!   real(kind=MAPL_R8), parameter :: S11= 0.191372282E+0 *100.0
!   real(kind=MAPL_R8), parameter :: S10= 0.298152339E+1 *100.0
!   real(kind=MAPL_R8), parameter :: S26= 0.314296723E-10*100.0
!   real(kind=MAPL_R8), parameter :: S25= 0.132243858E-7 *100.0
!   real(kind=MAPL_R8), parameter :: S24= 0.236279781E-5 *100.0
!   real(kind=MAPL_R8), parameter :: S23= 0.230325039E-3 *100.0
!   real(kind=MAPL_R8), parameter :: S22= 0.129690326E-1 *100.0
!   real(kind=MAPL_R8), parameter :: S21= 0.401390832E+0 *100.0
!   real(kind=MAPL_R8), parameter :: S20= 0.535098336E+1 *100.0
!
!   real(kind=MAPL_R8), parameter :: DI(0:3) = (/ 57518.5606E08, 2.01889049, 3.56654, 20.947031 /)
!   real(kind=MAPL_R8), parameter :: CI(0:3) = (/ 9.550426, -5723.265, 3.53068, -.00728332 /)
!   real(kind=MAPL_R8), parameter :: DL(1:6) = (/ -7.902980, 5.02808, -1.3816, 11.344, 8.1328, -3.49149 /)
!   real(kind=MAPL_R8), parameter :: LOGPS   = 3.005714898  ! log10(1013.246)
!   real(kind=MAPL_R8), parameter :: TS      = 373.16
!   real(kind=MAPL_R8), parameter :: CL(0:9) = (/54.842763, -6763.22, -4.21000, .000367, &
!                                       .0415, 218.8,  53.878000, -1331.22, -9.44523, .014025  /)
!
!   real(8), parameter :: TMINLQU = MAPL8_TICE - 40.0
!   real(8), parameter :: TMINICE = MAPL8_TICE + -95.
!
!#else
!! Some parameters set by CLDPARAMS 
  REAL*8 :: cnv_beta
  REAL*8 :: anv_beta
  REAL*8 :: ls_beta
  REAL*8 :: rh00
  REAL*8 :: c_00
  REAL*8 :: lwcrit
  REAL*8 :: c_acc
  REAL*8 :: c_ev_r
  REAL*8 :: c_ev_s
  REAL*8 :: cldvol2frc
  REAL*8 :: rhsup_ice
  REAL*8 :: shr_evap_fac
  REAL*8 :: min_cld_water
  REAL*8 :: cld_evp_eff
  INTEGER :: nsmax
  REAL*8 :: ls_sdqv2
  REAL*8 :: ls_sdqv3
  REAL*8 :: ls_sdqvt1
  REAL*8 :: anv_sdqv2
  REAL*8 :: anv_sdqv3
  REAL*8 :: anv_sdqvt1
  REAL*8 :: anv_to_ls
  REAL*8 :: n_warm
  REAL*8 :: n_ice
  REAL*8 :: n_anvil
  REAL*8 :: n_pbl
  INTEGER :: disable_rad
  INTEGER :: ice_settle
  REAL*8 :: anv_icefall_c
  REAL*8 :: ls_icefall_c
  REAL*8 :: revap_off_p
  REAL*8 :: cnvenvfc
  REAL*8 :: wrhodep
  REAL*8 :: t_ice_all
  REAL*8 :: cnviceparam
  INTEGER :: icefrpwr
  REAL*8 :: cnvddrfc
  REAL*8 :: anvddrfc
  REAL*8 :: lsddrfc
  INTEGER :: tanhrhcrit
  REAL*8 :: minrhcrit
  REAL*8 :: maxrhcrit
  REAL*8 :: turnrhcrit
  REAL*8 :: min_ri, max_ri, min_rl, max_rl, ri_anv
  INTEGER :: fr_ls_wat, fr_ls_ice, fr_an_wat, fr_an_ice
  REAL*8 :: maxrhcritland
  INTEGER :: pdfflag
  INTEGER :: ktop
!#endif
! -7.0+MAPL8_TICE
  REAL*8, PARAMETER :: t_ice_max=mapl8_tice
! Density of liquid water in kg/m^3
  REAL*8, PARAMETER :: rho_w=1.0e3
  REAL*8, PARAMETER :: min_cld_frac=1.0e-8
! There are two PIs in this routine: PI_0 and MAPL8_PI
  REAL*8, PARAMETER :: pi_0=4.*ATAN(1.)

CONTAINS
!  Differentiation of progno_cloud in forward (tangent) mode (with options r8):
!   variations   of useful results: qiw_an_dev qlw_an_dev anvfrc_dev
!                q_dev qiw_ls_dev qlw_ls_dev cldfrc_dev th_dev
!   with respect to varying inputs: qddf3_dev qiw_an_dev qlw_an_dev
!                cnv_updfrc_dev dzet_dev qst3_dev anvfrc_dev qrn_cu_dev
!                u_dev q_dev v_dev qiw_ls_dev qlwdtr_dev qlw_ls_dev
!                rmfdtr_dev cldfrc_dev th_dev
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! GPU The GPU main routine call is smaller due to CUDA limit on
!     number of arguments permitted in call. Most inputs and outputs
!     are USE-associated in the GridComp
!#ifdef _CUDA
!   attributes(global) subroutine progno_cloud(IRUN,LM,DT,SCLMFDFR)
!#else
!!! first vars are (in) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!         LATS_dev         , &
!         RAD_CLDFRC_dev   , &
!         RAD_QL_dev       , &
!         RAD_QI_dev       , &
!         RAD_QR_dev       , &
!         RAD_QS_dev       , &
!         QPLS_dev         , &
!         CLDREFFL_dev     , &
!         CLDREFFI_dev     , &
!         PRELS_dev        , &
!         PRECU_dev        , &
!         PREAN_dev        , &
!         LSARF_dev        , &
!         CUARF_dev        , &
!         ANARF_dev        , &
!         SNRLS_dev        , &
!         SNRCU_dev        , &
!         SNRAN_dev        , &
!, &
  SUBROUTINE PROGNO_CLOUD_TLM(irun, lm, dt, pp_dev, ppe_dev, exnp_dev, &
&   frland_dev, kh_dev, rmfdtr_dev, rmfdtr_dev_tl, qlwdtr_dev, &
&   qlwdtr_dev_tl, qrn_cu_dev, qrn_cu_dev_tl, cnv_updfrc_dev, &
&   cnv_updfrc_dev_tl, u_dev, u_dev_tl, v_dev, v_dev_tl, th_dev, &
&   th_dev_tl, q_dev, q_dev_tl, qlw_ls_dev, qlw_ls_dev_tl, qlw_an_dev, &
&   qlw_an_dev_tl, qiw_ls_dev, qiw_ls_dev_tl, qiw_an_dev, qiw_an_dev_tl&
&   , anvfrc_dev, anvfrc_dev_tl, cldfrc_dev, cldfrc_dev_tl, cldparams, &
&   sclmfdfr, qst3_dev, qst3_dev_tl, dzet_dev, dzet_dev_tl, qddf3_dev, &
&   qddf3_dev_tl, cnv_fraction_dev)
    IMPLICIT NONE
!#ifndef _CUDA
!#else
!      end if RUN_LOOP
!#endif
!#ifdef _CUDA
!      integer, intent(in   ), value :: IRUN
!      integer, intent(in   ), value :: LM
!      real(8), intent(in   ), value :: DT
!      real(8), intent(in   ), value :: SCLMFDFR   ! CLOUD_CTL%SCLMFDFR
!#else
    TYPE(CLDPARAM_TYPE), INTENT(IN) :: cldparams
! IM*JM
    INTEGER, INTENT(IN) :: irun
! LM
    INTEGER, INTENT(IN) :: lm
! DT_MOIST
    REAL*8, INTENT(IN) :: dt
!      real(8), intent(in   ), dimension(IRUN)      :: LATS_dev    ! LATS
! PLO
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: pp_dev
! CNV_PLE
    REAL*8, DIMENSION(irun, 0:lm), INTENT(IN) :: ppe_dev
! PK
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: exnp_dev
! FRLAND
    REAL*8, DIMENSION(irun), INTENT(IN) :: frland_dev
! KH
    REAL*8, DIMENSION(irun, 0:lm), INTENT(IN) :: kh_dev
! CNV_MFD
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: rmfdtr_dev
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: rmfdtr_dev_tl
! CNV_DQLDT
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: qlwdtr_dev
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: qlwdtr_dev_tl
! CNV_PRC3 IS THIS INTENT IN?
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qrn_cu_dev
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qrn_cu_dev_tl
! CNV_UPDF
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: cnv_updfrc_dev
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: cnv_updfrc_dev_tl
! U1
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: u_dev
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: u_dev_tl
! V1
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: v_dev
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: v_dev_tl
! TH1
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: th_dev
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: th_dev_tl
! Q1
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: q_dev
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: q_dev_tl
! QLLS
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qlw_ls_dev
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qlw_ls_dev_tl
! QLCN
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qlw_an_dev
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qlw_an_dev_tl
! QILS
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qiw_ls_dev
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qiw_ls_dev_tl
! QICN
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qiw_an_dev
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qiw_an_dev_tl
! CLCN
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: anvfrc_dev
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: anvfrc_dev_tl
! CLLS
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: cldfrc_dev
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: cldfrc_dev_tl
!      real(8), intent(  out), dimension(IRUN,  LM) :: RAD_CLDFRC_dev ! RAD_CF
!      real(8), intent(  out), dimension(IRUN,  LM) :: RAD_QL_dev ! RAD_QL
!      real(8), intent(  out), dimension(IRUN,  LM) :: RAD_QI_dev ! RAD_QI
!      real(8), intent(  out), dimension(IRUN,  LM) :: RAD_QR_dev ! QRAIN
!      real(8), intent(  out), dimension(IRUN,  LM) :: RAD_QS_dev ! QSNOW
!      real(8), intent(  out), dimension(IRUN,  LM) :: QPLS_dev ! QPLS
!      real(8), intent(  out), dimension(IRUN,  LM) :: CLDREFFL_dev ! CLDREFFL
!      real(8), intent(  out), dimension(IRUN,  LM) :: CLDREFFI_dev ! CLDREFFI
!      real(8), intent(  out), dimension(IRUN     ) :: PRELS_dev ! LS_PRC2
!      real(8), intent(  out), dimension(IRUN     ) :: PRECU_dev ! CN_PRC2
!      real(8), intent(  out), dimension(IRUN     ) :: PREAN_dev ! AN_PRC2
!      real(8), intent(  out), dimension(IRUN     ) :: LSARF_dev ! LS_ARFX
!      real(8), intent(  out), dimension(IRUN     ) :: CUARF_dev ! CN_ARFX
!      real(8), intent(  out), dimension(IRUN     ) :: ANARF_dev ! AN_ARFX
!      real(8), intent(  out), dimension(IRUN     ) :: SNRLS_dev ! LS_SNR
!      real(8), intent(  out), dimension(IRUN     ) :: SNRCU_dev ! CN_SNR
!      real(8), intent(  out), dimension(IRUN     ) :: SNRAN_dev ! AN_SNR
! CLOUD_CTL%SCLMFDFR
    REAL*8, INTENT(IN) :: sclmfdfr
! QST3
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: qst3_dev
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: qst3_dev_tl
! DZET
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: dzet_dev
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: dzet_dev_tl
! QDDF3
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: qddf3_dev
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: qddf3_dev_tl
! CNV_FRACTION
    REAL*8, DIMENSION(irun), INTENT(IN) :: cnv_fraction_dev
!      real(8), intent(  out), dimension(IRUN,  LM) :: RHX_dev    ! RHX
!      real(8), intent(  out), dimension(IRUN,  LM) :: REV_LS_dev ! REV_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: REV_AN_dev ! REV_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: REV_CN_dev ! REV_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: RSU_LS_dev ! RSU_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: RSU_AN_dev ! RSU_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: RSU_CN_dev ! RSU_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACLL_CN_dev ! ACLL_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACIL_CN_dev ! ACIL_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACLL_AN_dev ! ACLL_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACIL_AN_dev ! ACIL_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACLL_LS_dev ! ACLL_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACIL_LS_dev ! ACIL_LS
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFL_CN_dev ! PFL_CN
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFI_CN_dev ! PFI_CN
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFL_AN_dev ! PFL_AN
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFI_AN_dev ! PFI_AN
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFL_LS_dev ! PFL_LS
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFI_LS_dev ! PFI_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: PDFL_dev ! DlPDF
!      real(8), intent(  out), dimension(IRUN,  LM) :: PDFI_dev ! DiPDF
!      real(8), intent(  out), dimension(IRUN,  LM) :: FIXL_dev ! DlFIX
!      real(8), intent(  out), dimension(IRUN,  LM) :: FIXI_dev ! DiFIX                  
!      real(8), intent(  out), dimension(IRUN,  LM) :: AUT_dev   ! AUT
!      real(8), intent(  out), dimension(IRUN,  LM) :: EVAPC_dev ! EVAPC
!      real(8), intent(  out), dimension(IRUN,  LM) :: SDM_dev   ! SDM
!      real(8), intent(  out), dimension(IRUN,  LM) :: SUBLC_dev ! SUBLC
!      real(8), intent(  out), dimension(IRUN,  LM) :: FRZ_TT_dev ! FRZ_TT
!      real(8), intent(  out), dimension(IRUN,  LM) :: FRZ_PP_dev ! FRZ_PP
!      real(8), intent(  out), dimension(IRUN,  LM) :: DCNVL_dev ! DCNVL
!      real(8), intent(  out), dimension(IRUN,  LM) :: DCNVi_dev ! DCNVi
!      real(8), intent(  out), dimension(IRUN,  LM) :: ALPHT_dev ! ALPHT
!      real(8), intent(  out), dimension(IRUN,  LM) :: ALPH1_dev ! ALPH1
!      real(8), intent(  out), dimension(IRUN,  LM) :: ALPH2_dev ! ALPH2
!      real(8), intent(  out), dimension(IRUN,  LM) :: CFPDF_dev ! CFPDF
!      real(8), intent(  out), dimension(IRUN,  LM) :: RHCLR_dev ! RHCLR
!      real(8), intent(  out), dimension(IRUN,  LM) :: DQRL_dev ! DQRL
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLICE_AN_dev ! VFALLICE_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLICE_LS_dev ! VFALLICE_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLWAT_AN_dev ! VFALLWAT_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLWAT_LS_dev ! VFALLWAT_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLSN_AN_dev ! VFALLSN_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLSN_LS_dev ! VFALLSN_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLSN_CN_dev ! VFALLSN_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLRN_AN_dev ! VFALLRN_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLRN_LS_dev ! VFALLRN_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLRN_CN_dev ! VFALLRN_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: LIQANMOVE_dev  ! LIQANMOVE
!      real(8), intent(  out), dimension(IRUN,  LM) :: ICEANMOVE_dev  ! ICEANMOVE
!      real(8), intent(  out), dimension(IRUN,  LM) :: DANCLD_dev     ! DANCLD
!      real(8), intent(  out), dimension(IRUN,  LM) :: DLSCLD_dev     ! DLSCLD
!      real(8), intent(  out), dimension(IRUN,  LM) :: CURAINMOVE_dev ! CURAINMOVE
!      real(8), intent(  out), dimension(IRUN,  LM) :: CUSNOWMOVE_dev ! CUSNOWMOVE
!      real(8), intent(in   ), dimension(IRUN     ) :: TEMPOR_dev  ! TEMPOR
!#endif
! GPU The GPUs need to know how big local arrays are during compile-time
!     as the GPUs cannot allocate memory themselves. This command resets
!     this a priori size to LM for the CPU.
!#ifndef GPU_MAXLEVS
!#define GPU_MAXLEVS LM
!#endif
    INTEGER :: i, j, k, l
    INTEGER :: fraction_removal1, fraction_removal2, fraction_removal3
    REAL*8 :: mass, imass
    REAL*8 :: totfrc
    REAL*8 :: totfrc_tl
    REAL*8 :: qrn_ls, qrn_an, qrn_cu_1d
    REAL*8 :: qrn_ls_tl, qrn_an_tl, qrn_cu_1d_tl
    REAL*8 :: qsn_ls, qsn_an, qsn_cu
    REAL*8 :: qsn_ls_tl, qsn_an_tl, qsn_cu_tl
!      real(8) :: QRN_ALL, QSN_ALL
    REAL*8 :: qtmp1, qtmp2, qtmp3
    REAL*8 :: qtmp1_tl, qtmp2_tl, qtmp3_tl
    REAL*8 :: temp
    REAL*8 :: temp_tl
    REAL*8 :: rhcrit
    REAL*8 :: rhcrit_tl
    REAL*8 :: aa3, bb3, alpha
    REAL*8 :: aa3_tl, bb3_tl, alpha_tl
    REAL*8 :: vfall, vfallrn, vfallsn
    REAL*8 :: vfall_tl
    REAL*8 :: tot_prec_upd
    REAL*8 :: tot_prec_upd_tl
    REAL*8 :: tot_prec_anv
    REAL*8 :: tot_prec_anv_tl
    REAL*8 :: tot_prec_ls
    REAL*8 :: tot_prec_ls_tl
    REAL*8 :: area_upd_prc
    REAL*8 :: area_upd_prc_tl
    REAL*8 :: area_anv_prc
    REAL*8 :: area_anv_prc_tl
    REAL*8 :: area_ls_prc
    REAL*8 :: area_ls_prc_tl
    REAL*8 :: area_upd_prc_tolayer
    REAL*8 :: area_upd_prc_tolayer_tl
    REAL*8 :: area_anv_prc_tolayer
    REAL*8 :: area_anv_prc_tolayer_tl
    REAL*8 :: area_ls_prc_tolayer
    REAL*8 :: area_ls_prc_tolayer_tl
    REAL*8 :: u_above, u_below
    REAL*8 :: u_above_tl, u_below_tl
    REAL*8 :: v_above, v_below
    REAL*8 :: v_above_tl, v_below_tl
    REAL*8 :: dzet_above, dzet_below
    REAL*8 :: dzet_above_tl, dzet_below_tl
    REAL*8 :: prn_cu_above, psn_cu_above
    REAL*8 :: prn_cu_above_tl, psn_cu_above_tl
    REAL*8 :: prn_ls_above, psn_ls_above
    REAL*8 :: prn_ls_above_tl, psn_ls_above_tl
    REAL*8 :: prn_an_above, psn_an_above
    REAL*8 :: prn_an_above_tl, psn_an_above_tl
    REAL*8 :: evap_dd_cu_above, subl_dd_cu_above
    REAL*8 :: evap_dd_cu_above_tl, subl_dd_cu_above_tl
    REAL*8 :: evap_dd_ls_above, subl_dd_ls_above
    REAL*8 :: evap_dd_ls_above_tl, subl_dd_ls_above_tl
    REAL*8 :: evap_dd_an_above, subl_dd_an_above
    REAL*8 :: evap_dd_an_above_tl, subl_dd_an_above_tl
    LOGICAL :: use_autoconv_timescale
    REAL*8 :: tropical, extratropical
    REAL*8 :: lsenvfc, anvenvfc, envfc, ddrfc, beta
    REAL*8 :: sdqv2, sdqv3, sdqvt1
    REAL*8 :: lspdfliqnew, lspdficenew, lspdffracnew
    INTRINSIC INT
    INTRINSIC NINT
    INTRINSIC MAX
! These are in constant memory in CUDA and are set in the GridComp
!#ifndef _CUDA
! Area factor for convective rain showers (non-dim)
    cnv_beta = cldparams%cnv_beta
! Area factor for anvil rain showers (non-dim)
    anv_beta = cldparams%anv_beta
! Area factor for Large Scale rain showers (non-dim)
    ls_beta = cldparams%ls_beta
! Critical relative humidity
    rh00 = cldparams%rh_crit
    c_00 = cldparams%autoc_ls
    lwcrit = cldparams%qc_crit_ls
    c_acc = cldparams%accretion
    c_ev_r = cldparams%rain_revap_fac
    c_ev_s = cldparams%snow_revap_fac
    cldvol2frc = cldparams%vol_to_frac
    rhsup_ice = cldparams%supersat
    shr_evap_fac = cldparams%shear_evap_fac
    min_cld_water = cldparams%min_allow_ccw
    cld_evp_eff = cldparams%ccw_evap_eff
    nsmax = INT(cldparams%nsub_autoconv)
    ls_sdqv2 = cldparams%ls_sund_inter
    ls_sdqv3 = cldparams%ls_sund_cold
    ls_sdqvt1 = cldparams%ls_sund_temp1
    anv_sdqv2 = cldparams%anv_sund_inter
    anv_sdqv3 = cldparams%anv_sund_cold
    anv_sdqvt1 = cldparams%anv_sund_temp1
    anv_to_ls = cldparams%anv_to_ls_time
    n_warm = cldparams%nccn_warm
    n_ice = cldparams%nccn_ice
    n_anvil = cldparams%nccn_anvil
    n_pbl = cldparams%nccn_pbl
    disable_rad = INT(cldparams%disable_rad)
    ice_settle = NINT(cldparams%ice_settle)
    anv_icefall_c = cldparams%anv_icefall
    ls_icefall_c = cldparams%ls_icefall
    revap_off_p = cldparams%revap_off_p
    cnvenvfc = cldparams%cnv_envf
    wrhodep = cldparams%wrhodep
    t_ice_all = cldparams%ice_ramp + mapl8_tice
    cnviceparam = cldparams%cnv_iceparam
    icefrpwr = INT(cldparams%cnv_icefrpwr + .001)
    cnvddrfc = cldparams%cnv_ddrf
    anvddrfc = cldparams%anv_ddrf
    lsddrfc = cldparams%ls_ddrf
    tanhrhcrit = INT(cldparams%tanhrhcrit)
    minrhcrit = cldparams%minrhcrit
    maxrhcrit = cldparams%maxrhcrit
    turnrhcrit = cldparams%turnrhcrit
    maxrhcritland = cldparams%maxrhcritland
    fr_ls_wat = INT(cldparams%fr_ls_wat)
    fr_ls_ice = INT(cldparams%fr_ls_ice)
    fr_an_wat = INT(cldparams%fr_an_wat)
    fr_an_ice = INT(cldparams%fr_an_ice)
    min_rl = cldparams%min_rl
    min_ri = cldparams%min_ri
    max_rl = cldparams%max_rl
    max_ri = cldparams%max_ri
    ri_anv = cldparams%ri_anv
    pdfflag = INT(cldparams%pdfshape)
    ktop = INT(cldparams%ktop)
!#endif
    use_autoconv_timescale = .false.
    evap_dd_ls_above_tl = 0.0_8
    prn_ls_above_tl = 0.0_8
    subl_dd_ls_above_tl = 0.0_8
    area_upd_prc_tl = 0.0_8
    tot_prec_ls_tl = 0.0_8
    psn_an_above_tl = 0.0_8
    evap_dd_cu_above_tl = 0.0_8
    prn_cu_above_tl = 0.0_8
    subl_dd_cu_above_tl = 0.0_8
    psn_ls_above_tl = 0.0_8
    area_ls_prc_tl = 0.0_8
    tot_prec_upd_tl = 0.0_8
    area_anv_prc_tl = 0.0_8
    psn_cu_above_tl = 0.0_8
    tot_prec_anv_tl = 0.0_8
    evap_dd_an_above_tl = 0.0_8
    prn_an_above_tl = 0.0_8
    subl_dd_an_above_tl = 0.0_8
!#ifdef _CUDA
!      i = (blockidx%x - 1) * blockdim%x + threadidx%x
!
!      RUN_LOOP: IF ( I <= IRUN ) THEN
!#else
run_loop:DO i=1,irun
!#endif
k_loop:DO k=ktop,lm
        IF (k .EQ. ktop) THEN
          tot_prec_upd = 0.
          tot_prec_anv = 0.
          tot_prec_ls = 0.
          area_upd_prc = 0.
          area_anv_prc = 0.
          area_ls_prc = 0.
          area_upd_prc_tl = 0.0_8
          tot_prec_ls_tl = 0.0_8
          area_ls_prc_tl = 0.0_8
          tot_prec_upd_tl = 0.0_8
          area_anv_prc_tl = 0.0_8
          tot_prec_anv_tl = 0.0_8
        END IF
!! ZERO DIAGNOSTIC OUTPUTS BEFORE SHOWERS !!
!               PRELS_dev(I) = 0.
!               PRECU_dev(I) = 0.
!               PREAN_dev(I) = 0.
!               SNRCU_dev(I) = 0. 
!               SNRLS_dev(I) = 0. 
!               SNRAN_dev(I) = 0. 
!               LSARF_dev(I) = 0.
!               CUARF_dev(I) = 0.
!               ANARF_dev(I) = 0.
!Zero out/initialize precips, except QRN_CU which comes from RAS 
        qrn_ls = 0.
        qrn_an = 0.
        qrn_cu_1d = 0.
        qsn_ls = 0.
        qsn_an = 0.
        qsn_cu = 0.
        vfall = 0.
!            RAD_QL_dev(I,K)     = 0.
!            RAD_QI_dev(I,K)     = 0.
!            RAD_QR_dev(I,K)     = 0.
!            RAD_QS_dev(I,K)     = 0.
!            QPLS_dev(I,K)       = 0.
!            RAD_CLDFRC_dev(I,K) = 0.
!            CLDREFFL_dev(I,K)   = 0.
!            CLDREFFI_dev(I,K)   = 0.
!            PFL_CN_dev(I,K) = 0.
!            PFI_CN_dev(I,K) = 0.
!            PFL_AN_dev(I,K) = 0.
!            PFI_AN_dev(I,K) = 0.
!            PFL_LS_dev(I,K) = 0.
!            PFI_LS_dev(I,K) = 0.
!            IF (K == KTOP) THEN
!               PFL_CN_dev(I,0) = 0.
!               PFI_CN_dev(I,0) = 0.
!               PFL_AN_dev(I,0) = 0.
!               PFI_AN_dev(I,0) = 0.
!               PFL_LS_dev(I,0) = 0.
!               PFI_LS_dev(I,0) = 0.
!            END IF
! Initialize other diagnostics 
!            RHX_dev(I,K) = MAPL8_UNDEF
!            REV_LS_dev(I,K) = MAPL8_UNDEF
!            REV_AN_dev(I,K) = MAPL8_UNDEF
!            REV_CN_dev(I,K) = MAPL8_UNDEF
!            RSU_LS_dev(I,K) = MAPL8_UNDEF
!            RSU_AN_dev(I,K) = MAPL8_UNDEF
!            RSU_CN_dev(I,K) = MAPL8_UNDEF
!            ACLL_CN_dev(I,K) = MAPL8_UNDEF
!            ACIL_CN_dev(I,K) = MAPL8_UNDEF
!            ACLL_AN_dev(I,K) = MAPL8_UNDEF
!            ACIL_AN_dev(I,K) = MAPL8_UNDEF
!            ACLL_LS_dev(I,K) = MAPL8_UNDEF
!            ACIL_LS_dev(I,K) = MAPL8_UNDEF
!            PDFL_dev(I,K) = MAPL8_UNDEF
!            PDFI_dev(I,K) = MAPL8_UNDEF
!            FIXL_dev(I,K) = MAPL8_UNDEF
!            FIXI_dev(I,K) = MAPL8_UNDEF
!            AUT_dev(I,K) = MAPL8_UNDEF
!            EVAPC_dev(I,K) = MAPL8_UNDEF
!            SDM_dev(I,K) = MAPL8_UNDEF
!            SUBLC_dev(I,K) = MAPL8_UNDEF
!            FRZ_TT_dev(I,K) = MAPL8_UNDEF
!            FRZ_PP_dev(I,K) = MAPL8_UNDEF
!            DCNVL_dev(I,K) = MAPL8_UNDEF
!            DCNVi_dev(I,K) = MAPL8_UNDEF
!            ALPHT_dev(I,K) = MAPL8_UNDEF
!            ALPH1_dev(I,K) = MAPL8_UNDEF
!            ALPH2_dev(I,K) = MAPL8_UNDEF
!            CFPDF_dev(I,K) = MAPL8_UNDEF
!            RHCLR_dev(I,K) = MAPL8_UNDEF
!            DQRL_dev(I,K) = MAPL8_UNDEF
!            VFALLICE_AN_dev(I,K) = MAPL8_UNDEF
!            VFALLICE_LS_dev(I,K) = MAPL8_UNDEF
!            VFALLWAT_AN_dev(I,K) = MAPL8_UNDEF
!            VFALLWAT_LS_dev(I,K) = MAPL8_UNDEF
!            VFALLSN_AN_dev(I,K) = MAPL8_UNDEF
!            VFALLSN_LS_dev(I,K) = MAPL8_UNDEF
!            VFALLSN_CN_dev(I,K) = MAPL8_UNDEF
!            VFALLRN_AN_dev(I,K) = MAPL8_UNDEF
!            VFALLRN_LS_dev(I,K) = MAPL8_UNDEF
!            VFALLRN_CN_dev(I,K) = MAPL8_UNDEF
! Copy QRN_CU into a temp scalar
        qrn_cu_1d_tl = qrn_cu_dev_tl(i, k)
        qrn_cu_1d = qrn_cu_dev(i, k)
! layer-mass (kg/m**2)
        mass = (ppe_dev(i, k)-ppe_dev(i, k-1))*100./mapl8_grav
        imass = 1.0/mass
        temp_tl = exnp_dev(i, k)*th_dev_tl(i, k)
        temp = exnp_dev(i, k)*th_dev(i, k)
!            FRZ_PP_dev(I,K) = 0.00
!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Total Condensate Source
!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            FIXL_dev(I,K) = QLW_AN_dev(I,K) + QLW_LS_dev(I,K)
!            FIXI_dev(I,K) = QIW_AN_dev(I,K) + QIW_LS_dev(I,K)
        CALL FIX_UP_CLOUDS_TLM(q_dev(i, k), q_dev_tl(i, k), temp, &
&                        temp_tl, qlw_ls_dev(i, k), qlw_ls_dev_tl(i, k)&
&                        , qiw_ls_dev(i, k), qiw_ls_dev_tl(i, k), &
&                        cldfrc_dev(i, k), cldfrc_dev_tl(i, k), &
&                        qlw_an_dev(i, k), qlw_an_dev_tl(i, k), &
&                        qiw_an_dev(i, k), qiw_an_dev_tl(i, k), &
&                        anvfrc_dev(i, k), anvfrc_dev_tl(i, k))
!            FIXL_dev(I,K) = -( QLW_AN_dev(I,K) + QLW_LS_dev(I,K) - FIXL_dev(I,K) ) / DT 
!            FIXI_dev(I,K) = -( QIW_AN_dev(I,K) + QIW_LS_dev(I,K) - FIXI_dev(I,K) ) / DT 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            FRZ_TT_dev(I,K) = QIW_AN_dev(I,K) + QIW_LS_dev(I,K)
        CALL MELTFRZ_TLM(dt, temp, temp_tl, qlw_ls_dev(i, k), &
&                  qlw_ls_dev_tl(i, k), qiw_ls_dev(i, k), qiw_ls_dev_tl(&
&                  i, k))
        CALL MELTFRZ_TLM(dt, temp, temp_tl, qlw_an_dev(i, k), &
&                  qlw_an_dev_tl(i, k), qiw_an_dev(i, k), qiw_an_dev_tl(&
&                  i, k))
!            FRZ_TT_dev(I,K) = ( QIW_AN_dev(I,K) + QIW_LS_dev(I,K) - FRZ_TT_dev(I,K) ) / DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            DCNVi_dev(I,K) = QIW_AN_dev(I,K)
!            DCNVL_dev(I,K) = QLW_AN_dev(I,K)
        CALL CNVSRC_TLM(dt, cnviceparam, sclmfdfr, mass, imass, pp_dev(i&
&                 , k), temp, temp_tl, q_dev(i, k), q_dev_tl(i, k), &
&                 qlwdtr_dev(i, k), qlwdtr_dev_tl(i, k), rmfdtr_dev(i, k&
&                 ), rmfdtr_dev_tl(i, k), qlw_an_dev(i, k), &
&                 qlw_an_dev_tl(i, k), qiw_an_dev(i, k), qiw_an_dev_tl(i&
&                 , k), cldfrc_dev(i, k), anvfrc_dev(i, k), &
&                 anvfrc_dev_tl(i, k), qst3_dev(i, k), qst3_dev_tl(i, k)&
&                )
!            DCNVi_dev(I,K) = ( QIW_AN_dev(I,K) - DCNVi_dev(I,K) ) / DT
!            DCNVL_dev(I,K) = ( QLW_AN_dev(I,K) - DCNVL_dev(I,K) ) / DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            PDFL_dev(I,K) = QLW_LS_dev(I,K)+QLW_AN_dev(I,K)
!            PDFI_dev(I,K) = QIW_LS_dev(I,K)+QIW_AN_dev(I,K)
        IF (k .EQ. ktop .OR. k .EQ. lm) THEN
          u_above = 0.0
          u_below = 0.0
          v_above = 0.0
          v_below = 0.0
          dzet_above = 0.0
          dzet_below = 0.0
          v_below_tl = 0.0_8
          u_above_tl = 0.0_8
          dzet_above_tl = 0.0_8
          u_below_tl = 0.0_8
          dzet_below_tl = 0.0_8
          v_above_tl = 0.0_8
        ELSE
          u_above_tl = u_dev_tl(i, k-1)
          u_above = u_dev(i, k-1)
          u_below_tl = u_dev_tl(i, k+1)
          u_below = u_dev(i, k+1)
          v_above_tl = v_dev_tl(i, k-1)
          v_above = v_dev(i, k-1)
          v_below_tl = v_dev_tl(i, k+1)
          v_below = v_dev(i, k+1)
          dzet_above_tl = dzet_dev_tl(i, k-1)
          dzet_above = dzet_dev(i, k-1)
          dzet_below_tl = dzet_dev_tl(i, k+1)
          dzet_below = dzet_dev(i, k+1)
        END IF
!                  ALPHT_dev(I,K), ALPH1_dev(I,K),!ALPH2_dev(I,K), & 
        CALL PDF_SPREAD_TLM(k, lm, u_dev(i, k), u_dev_tl(i, k), u_above&
&                     , u_above_tl, u_below, u_below_tl, v_dev(i, k), &
&                     v_dev_tl(i, k), v_above, v_above_tl, v_below, &
&                     v_below_tl, kh_dev(i, k-1), dzet_above, &
&                     dzet_above_tl, dzet_below, dzet_below_tl, &
&                     cnv_updfrc_dev(i, k), pp_dev(i, k), alpha, &
&                     alpha_tl, frland_dev(i))
        IF (alpha .LT. 1.0 - rh00) THEN
          alpha = 1.0 - rh00
          alpha_tl = 0.0_8
        ELSE
          alpha = alpha
        END IF
        rhcrit_tl = -alpha_tl
        rhcrit = 1.0 - alpha
        lspdfliqnew = qlw_ls_dev(i, k)
        lspdficenew = qiw_ls_dev(i, k)
        lspdffracnew = cldfrc_dev(i, k)
        CALL HYSTPDF_TLM(dt, alpha, alpha_tl, pdfflag, pp_dev(i, k), &
&                  q_dev(i, k), q_dev_tl(i, k), qlw_ls_dev(i, k), &
&                  qlw_ls_dev_tl(i, k), qlw_an_dev(i, k), qlw_an_dev_tl(&
&                  i, k), qiw_ls_dev(i, k), qiw_ls_dev_tl(i, k), &
&                  qiw_an_dev(i, k), qiw_an_dev_tl(i, k), temp, temp_tl&
&                  , cldfrc_dev(i, k), cldfrc_dev_tl(i, k), anvfrc_dev(i&
&                  , k), anvfrc_dev_tl(i, k))
        lspdfliqnew = qlw_ls_dev(i, k) - lspdfliqnew
        lspdficenew = qiw_ls_dev(i, k) - lspdficenew
        lspdffracnew = cldfrc_dev(i, k) - lspdffracnew
!            RHX_dev(I,K)   = Q_dev(I,K)/QSAT( TEMP, PP_dev(I,K) )
!            CFPDF_dev(I,K) = CLDFRC_dev(I,K)
!            PDFL_dev(I,K)  = ( QLW_LS_dev(I,K) + QLW_AN_dev(I,K) - PDFL_dev(I,K) ) / DT 
!            PDFI_dev(I,K)  = ( QIW_LS_dev(I,K) + QIW_AN_dev(I,K) - PDFI_dev(I,K) ) / DT 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        totfrc_tl = cldfrc_dev_tl(i, k) + anvfrc_dev_tl(i, k)
        totfrc = cldfrc_dev(i, k) + anvfrc_dev(i, k)
        IF (totfrc .GT. 1.00) THEN
          cldfrc_dev_tl(i, k) = cldfrc_dev_tl(i, k)/totfrc - cldfrc_dev(&
&           i, k)*totfrc_tl/totfrc**2
          cldfrc_dev(i, k) = cldfrc_dev(i, k)*(1.00/totfrc)
          anvfrc_dev_tl(i, k) = anvfrc_dev_tl(i, k)/totfrc - anvfrc_dev(&
&           i, k)*totfrc_tl/totfrc**2
          anvfrc_dev(i, k) = anvfrc_dev(i, k)*(1.00/totfrc)
        END IF
        totfrc = cldfrc_dev(i, k) + anvfrc_dev(i, k)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! CONDENSATE/FRACTION SOURCES FINISHED. NOW LOSE CLOUD CONDENSATE !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Total Condensate Sink
!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!       E  V  A  P  O  R  A  T  I  O  N
!!                A  N  D 
!!       S  U  B  L  I  M  A  T  I  O  N
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            EVAPC_dev(I,K) = QLW_LS_dev(I,K)+QLW_AN_dev(I,K)
!            SUBLC_dev(I,K) = QIW_LS_dev(I,K)+QIW_AN_dev(I,K)
! 'Anvil' partition from RAS/Parameterized not done in hystpdf
        CALL EVAP3_TLM(dt, rhcrit, rhcrit_tl, pp_dev(i, k), temp, &
&                temp_tl, q_dev(i, k), q_dev_tl(i, k), qlw_an_dev(i, k)&
&                , qlw_an_dev_tl(i, k), qiw_an_dev(i, k), qiw_an_dev_tl(&
&                i, k), anvfrc_dev(i, k), anvfrc_dev_tl(i, k), &
&                cldfrc_dev(i, k), qst3_dev(i, k), qst3_dev_tl(i, k))
        CALL SUBL3_TLM(dt, rhcrit, rhcrit_tl, pp_dev(i, k), temp, &
&                temp_tl, q_dev(i, k), q_dev_tl(i, k), qlw_an_dev(i, k)&
&                , qlw_an_dev_tl(i, k), qiw_an_dev(i, k), qiw_an_dev_tl(&
&                i, k), anvfrc_dev(i, k), anvfrc_dev_tl(i, k), &
&                cldfrc_dev(i, k), qst3_dev(i, k), qst3_dev_tl(i, k))
!            EVAPC_dev(I,K) = ( EVAPC_dev(I,K) - (QLW_LS_dev(I,K)+QLW_AN_dev(I,K)) ) / DT
!            SUBLC_dev(I,K) = ( SUBLC_dev(I,K) - (QIW_LS_dev(I,K)+QIW_AN_dev(I,K)) ) / DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!       A U T O C O N V E R S I  O  N
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!           FRACTION_REMOVAL = 0 -> none
!                              1 -> constant in-cloud QC
!                              2 -> trim high edge of PDF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            AUT_dev(I,K) = QLW_LS_dev(I,K)+QLW_AN_dev(I,K)
        fraction_removal1 = fr_ls_wat
        CALL AUTOCON3_TLM(dt, qlw_ls_dev(i, k), qlw_ls_dev_tl(i, k), &
&                   qrn_ls, qrn_ls_tl, temp, temp_tl, pp_dev(i, k), &
&                   kh_dev(i, k-1), cldfrc_dev(i, k), cldfrc_dev_tl(i, k&
&                   ), ls_sdqv2, ls_sdqv3, ls_sdqvt1, dzet_dev(i, k), &
&                   vfall, fraction_removal1)
!            VFALLWAT_LS_dev(I,K) = VFALL
        fraction_removal2 = fr_an_wat
        CALL AUTOCON3_TLM(dt, qlw_an_dev(i, k), qlw_an_dev_tl(i, k), &
&                   qrn_an, qrn_an_tl, temp, temp_tl, pp_dev(i, k), &
&                   kh_dev(i, k), anvfrc_dev(i, k), anvfrc_dev_tl(i, k)&
&                   , anv_sdqv2, anv_sdqv3, anv_sdqvt1, dzet_dev(i, k), &
&                   vfall, fraction_removal2)
!            VFALLWAT_AN_dev(I,K) = VFALL
!            AUT_dev(I,K) = ( AUT_dev(I,K) - ( QLW_AN_dev(I,K) + QLW_LS_dev(I,K) ) )/DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Ice cloud settling
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            SDM_dev(I,K) = QIW_AN_dev(I,K)+QIW_LS_dev(I,K)
! Parameterized (RAS) Ice Fall
! ----------------------------
! WMP: Adjustments to resolved scale ice fall speed options                            
        IF (cnv_fraction_dev(i) .GE. 0.5) THEN
          fraction_removal3 = fr_an_ice
        ELSE
          fraction_removal3 = fr_ls_ice
        END IF
        SELECT CASE  (ice_settle) 
        CASE (0) 
! MERRA-2 Formulation
          tropical = anv_icefall_c*1.0
          extratropical = anv_icefall_c*0.0
        CASE (1) 
          tropical = cnv_fraction_dev(i)
          extratropical = 1.0 - tropical
          tropical = anv_icefall_c*tropical
          extratropical = ls_icefall_c*extratropical
        END SELECT
        CALL SETTLE_VEL_TLM(wrhodep, qiw_an_dev(i, k), qiw_an_dev_tl(i, &
&                     k), pp_dev(i, k), temp, temp_tl, anvfrc_dev(i, k)&
&                     , anvfrc_dev_tl(i, k), kh_dev(i, k-1), vfall, &
&                     vfall_tl, extratropical, tropical)
!            VFALLICE_AN_dev(I,K) = VFALL
        CALL ICEFALL_TLM(qiw_an_dev(i, k), qiw_an_dev_tl(i, k), dzet_dev&
&                  (i, k), dzet_dev_tl(i, k), qsn_an, qsn_an_tl, vfall, &
&                  vfall_tl, anvfrc_dev(i, k), anvfrc_dev_tl(i, k), dt, &
&                  fraction_removal3)
! Resolved Scale Ice Fall
! -----------------------
! WMP: Adjustments to resolved scale ice fall speed options 
        SELECT CASE  (ice_settle) 
        CASE (0) 
! MERRA-2 Formulation
          tropical = ls_icefall_c*0.0
          extratropical = ls_icefall_c*1.0
        CASE (1) 
          tropical = cnv_fraction_dev(i)
          extratropical = 1.0 - tropical
          tropical = anv_icefall_c*tropical
          extratropical = ls_icefall_c*extratropical
        END SELECT
        CALL SETTLE_VEL_TLM(wrhodep, qiw_ls_dev(i, k), qiw_ls_dev_tl(i, &
&                     k), pp_dev(i, k), temp, temp_tl, cldfrc_dev(i, k)&
&                     , cldfrc_dev_tl(i, k), kh_dev(i, k-1), vfall, &
&                     vfall_tl, extratropical, tropical)
!            VFALLICE_LS_dev(I,K) = VFALL
        CALL ICEFALL_TLM(qiw_ls_dev(i, k), qiw_ls_dev_tl(i, k), dzet_dev&
&                  (i, k), dzet_dev_tl(i, k), qsn_ls, qsn_ls_tl, vfall, &
&                  vfall_tl, cldfrc_dev(i, k), cldfrc_dev_tl(i, k), dt, &
&                  fraction_removal3)
!            SDM_dev(I,K) = ( SDM_dev(I,K) - (QIW_LS_dev(I,K) + QIW_AN_dev(I,K)) )/DT
!            DQRL_dev(I,K) = ( QRN_LS + QRN_AN + QSN_LS + QSN_AN ) / DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Add in convective rain 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! CU-FREEZE 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Also "freeze" out any conv. precip that needs
! to be since this isnt done in RAS. This is
! precip w/ large particles, so freezing is 
! strict. Check up on this!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        qtmp2 = 0.
        IF (temp .LT. mapl8_tice) THEN
          qtmp2 = qrn_cu_1d
          qsn_cu_tl = qrn_cu_1d_tl
          qsn_cu = qrn_cu_1d
          qrn_cu_1d = 0.
          temp_tl = temp_tl + (mapl8_alhs-mapl8_alhl)*qsn_cu_tl/mapl8_cp
          temp = temp + qsn_cu*(mapl8_alhs-mapl8_alhl)/mapl8_cp
          qrn_cu_1d_tl = 0.0_8
        ELSE
          qsn_cu_tl = 0.0_8
        END IF
!            FRZ_PP_dev(I,K) = FRZ_PP_dev(I,K) +  QTMP2/DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!----------------------------------------------------------------------------------------------
! Column will now be swept from top-down for precip accumulation/accretion/re-evaporation
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        area_ls_prc_tolayer = 0.0
        area_upd_prc_tolayer = 0.0
        area_anv_prc_tolayer = 0.0
        tot_prec_upd_tl = tot_prec_upd_tl + mass*(qrn_cu_1d_tl+qsn_cu_tl&
&         )
        tot_prec_upd = tot_prec_upd + (qrn_cu_1d+qsn_cu)*mass
        area_upd_prc_tl = area_upd_prc_tl + mass*(cnv_updfrc_dev_tl(i, k&
&         )*(qrn_cu_1d+qsn_cu)+cnv_updfrc_dev(i, k)*(qrn_cu_1d_tl+&
&         qsn_cu_tl))
        area_upd_prc = area_upd_prc + cnv_updfrc_dev(i, k)*(qrn_cu_1d+&
&         qsn_cu)*mass
        tot_prec_anv_tl = tot_prec_anv_tl + mass*(qrn_an_tl+qsn_an_tl)
        tot_prec_anv = tot_prec_anv + (qrn_an+qsn_an)*mass
        area_anv_prc_tl = area_anv_prc_tl + mass*(anvfrc_dev_tl(i, k)*(&
&         qrn_an+qsn_an)+anvfrc_dev(i, k)*(qrn_an_tl+qsn_an_tl))
        area_anv_prc = area_anv_prc + anvfrc_dev(i, k)*(qrn_an+qsn_an)*&
&         mass
        tot_prec_ls_tl = tot_prec_ls_tl + mass*(qrn_ls_tl+qsn_ls_tl)
        tot_prec_ls = tot_prec_ls + (qrn_ls+qsn_ls)*mass
        area_ls_prc_tl = area_ls_prc_tl + mass*(cldfrc_dev_tl(i, k)*(&
&         qrn_ls+qsn_ls)+cldfrc_dev(i, k)*(qrn_ls_tl+qsn_ls_tl))
        area_ls_prc = area_ls_prc + cldfrc_dev(i, k)*(qrn_ls+qsn_ls)*&
&         mass
        IF (tot_prec_anv .GT. 0.0) THEN
          IF (area_anv_prc/tot_prec_anv .LT. 1.e-6) THEN
            area_anv_prc_tolayer = 1.e-6
            area_anv_prc_tolayer_tl = 0.0_8
          ELSE
            area_anv_prc_tolayer_tl = (area_anv_prc_tl*tot_prec_anv-&
&             area_anv_prc*tot_prec_anv_tl)/tot_prec_anv**2
            area_anv_prc_tolayer = area_anv_prc/tot_prec_anv
          END IF
        ELSE
          area_anv_prc_tolayer_tl = 0.0_8
        END IF
        IF (tot_prec_upd .GT. 0.0) THEN
          IF (area_upd_prc/tot_prec_upd .LT. 1.e-6) THEN
            area_upd_prc_tolayer = 1.e-6
            area_upd_prc_tolayer_tl = 0.0_8
          ELSE
            area_upd_prc_tolayer_tl = (area_upd_prc_tl*tot_prec_upd-&
&             area_upd_prc*tot_prec_upd_tl)/tot_prec_upd**2
            area_upd_prc_tolayer = area_upd_prc/tot_prec_upd
          END IF
        ELSE
          area_upd_prc_tolayer_tl = 0.0_8
        END IF
        IF (tot_prec_ls .GT. 0.0) THEN
          IF (area_ls_prc/tot_prec_ls .LT. 1.e-6) THEN
            area_ls_prc_tolayer = 1.e-6
            area_ls_prc_tolayer_tl = 0.0_8
          ELSE
            area_ls_prc_tolayer_tl = (area_ls_prc_tl*tot_prec_ls-&
&             area_ls_prc*tot_prec_ls_tl)/tot_prec_ls**2
            area_ls_prc_tolayer = area_ls_prc/tot_prec_ls
          END IF
        ELSE
          area_ls_prc_tolayer_tl = 0.0_8
        END IF
        area_ls_prc_tolayer_tl = ls_beta*area_ls_prc_tolayer_tl
        area_ls_prc_tolayer = ls_beta*area_ls_prc_tolayer
        area_upd_prc_tolayer_tl = cnv_beta*area_upd_prc_tolayer_tl
        area_upd_prc_tolayer = cnv_beta*area_upd_prc_tolayer
        area_anv_prc_tolayer_tl = anv_beta*area_anv_prc_tolayer_tl
        area_anv_prc_tolayer = anv_beta*area_anv_prc_tolayer
        IF (k .EQ. lm) THEN
! Weve accumulated over the whole column
          IF (tot_prec_anv .GT. 0.0) THEN
            IF (area_anv_prc/tot_prec_anv .LT. 1.e-6) THEN
              area_anv_prc = 1.e-6
              area_anv_prc_tl = 0.0_8
            ELSE
              area_anv_prc_tl = (area_anv_prc_tl*tot_prec_anv-&
&               area_anv_prc*tot_prec_anv_tl)/tot_prec_anv**2
              area_anv_prc = area_anv_prc/tot_prec_anv
            END IF
          END IF
          IF (tot_prec_upd .GT. 0.0) THEN
            IF (area_upd_prc/tot_prec_upd .LT. 1.e-6) THEN
              area_upd_prc = 1.e-6
              area_upd_prc_tl = 0.0_8
            ELSE
              area_upd_prc_tl = (area_upd_prc_tl*tot_prec_upd-&
&               area_upd_prc*tot_prec_upd_tl)/tot_prec_upd**2
              area_upd_prc = area_upd_prc/tot_prec_upd
            END IF
          END IF
          IF (tot_prec_ls .GT. 0.0) THEN
            IF (area_ls_prc/tot_prec_ls .LT. 1.e-6) THEN
              area_ls_prc = 1.e-6
              area_ls_prc_tl = 0.0_8
            ELSE
              area_ls_prc_tl = (area_ls_prc_tl*tot_prec_ls-area_ls_prc*&
&               tot_prec_ls_tl)/tot_prec_ls**2
              area_ls_prc = area_ls_prc/tot_prec_ls
            END IF
          END IF
          area_ls_prc_tl = ls_beta*area_ls_prc_tl
          area_ls_prc = ls_beta*area_ls_prc
          area_upd_prc_tl = cnv_beta*area_upd_prc_tl
          area_upd_prc = cnv_beta*area_upd_prc
          area_anv_prc_tl = anv_beta*area_anv_prc_tl
          area_anv_prc = anv_beta*area_anv_prc
!! "couple" to diagnostic areal(8) fraction output 
!! Intensity factor in PRECIP3 is floored at
!! 1.0. So this is fair.
!               LSARF_dev(I) = MIN( AREA_LS_PRC,  1.0 )
!               CUARF_dev(I) = MIN( AREA_UPD_PRC, 1.0 )
!               ANARF_dev(I) = MIN( AREA_ANV_PRC, 1.0 )
        END IF
!            QRN_ALL = 0.
!            QSN_ALL = 0.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! GET SOME MICROPHYSICAL QUANTITIES 
        CALL MICRO_AA_BB_3_TLM(temp, temp_tl, pp_dev(i, k), qst3_dev(i, &
&                        k), qst3_dev_tl(i, k), aa3, aa3_tl, bb3, bb3_tl&
&                       )
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        qtmp1_tl = qlw_ls_dev_tl(i, k) + qlw_an_dev_tl(i, k)
        qtmp1 = qlw_ls_dev(i, k) + qlw_an_dev(i, k)
        qtmp2_tl = qiw_ls_dev_tl(i, k) + qiw_an_dev_tl(i, k)
        qtmp2 = qiw_ls_dev(i, k) + qiw_an_dev(i, k)
! CNVENVFC passed in as argument (default=0.8)
! Unlike CNVENVFC which is from PHYSPARAMS, this is set to 1.
        anvenvfc = 1.00
! Unlike CNVENVFC which is from PHYSPARAMS, this is set to 1.
        lsenvfc = 1.00
! Apply convective fractions
        envfc = cnvenvfc*cnv_fraction_dev(i) + lsenvfc*(1.0-&
&         cnv_fraction_dev(i))
! Convective
! ----------
!                  PRECU_dev(I)    , & 
!                  SNRCU_dev(I)    , & 
!                  REV_CN_dev(I,K) , &
!                  RSU_CN_dev(I,K) , &
!                  ACLL_CN_dev(I,K), &
!                  ACIL_CN_dev(I,K), &
!                  PFL_CN_dev(I,K) , &
!                  PFI_CN_dev(I,K) , &
!                  VFALLRN         , &
!                  VFALLSN         , &
!                  FRZ_PP_dev(I,K) , &
        CALL PRECIP3_TLM(k, lm, dt, frland_dev(i), rhcrit, rhcrit_tl, &
&                  qrn_cu_1d, qrn_cu_1d_tl, qsn_cu, qsn_cu_tl, qtmp1, &
&                  qtmp1_tl, qtmp2, temp, temp_tl, q_dev(i, k), q_dev_tl&
&                  (i, k), mass, imass, pp_dev(i, k), dzet_dev(i, k), &
&                  dzet_dev_tl(i, k), qddf3_dev(i, k), qddf3_dev_tl(i, k&
&                  ), aa3, aa3_tl, bb3, bb3_tl, area_upd_prc_tolayer, &
&                  area_upd_prc_tolayer_tl, prn_cu_above, &
&                  prn_cu_above_tl, psn_cu_above, psn_cu_above_tl, &
&                  evap_dd_cu_above, evap_dd_cu_above_tl, &
&                  subl_dd_cu_above, subl_dd_cu_above_tl, envfc, &
&                  cnvddrfc)
!            VFALLSN_CN_dev(I,K) = VFALLSN
!            VFALLRN_CN_dev(I,K) = VFALLRN
!            if (.not.use_autoconv_timescale) then
!               if (VFALLSN.NE.0.) then
!                  QSN_ALL = QSN_ALL + PFI_CN_dev(I,K)/VFALLSN
!               end if
!               if (VFALLRN.NE.0.) then
!                  QRN_ALL = QRN_ALL + PFL_CN_dev(I,K)/VFALLRN
!               end if
!            end if
! Anvil
! -----
!                  PREAN_dev(I)    , & 
!                  SNRAN_dev(I)    , &
!                  REV_AN_dev(I,K) , &
!                  RSU_AN_dev(I,K) , &
!                  ACLL_AN_dev(I,K), &
!                  ACIL_AN_dev(I,K), &
!                  PFL_AN_dev(I,K) , &
!                  PFI_AN_dev(I,K) , &
!                  VFALLRN         , &
!                  VFALLSN         , &
!                  FRZ_PP_dev(I,K) , &
        CALL PRECIP3_TLM(k, lm, dt, frland_dev(i), rhcrit, rhcrit_tl, &
&                  qrn_an, qrn_an_tl, qsn_an, qsn_an_tl, qtmp1, qtmp1_tl&
&                  , qtmp2, temp, temp_tl, q_dev(i, k), q_dev_tl(i, k), &
&                  mass, imass, pp_dev(i, k), dzet_dev(i, k), &
&                  dzet_dev_tl(i, k), qddf3_dev(i, k), qddf3_dev_tl(i, k&
&                  ), aa3, aa3_tl, bb3, bb3_tl, area_anv_prc_tolayer, &
&                  area_anv_prc_tolayer_tl, prn_an_above, &
&                  prn_an_above_tl, psn_an_above, psn_an_above_tl, &
&                  evap_dd_an_above, evap_dd_an_above_tl, &
&                  subl_dd_an_above, subl_dd_an_above_tl, envfc, &
&                  anvddrfc)
!            VFALLSN_AN_dev(I,K) = VFALLSN
!            VFALLRN_AN_dev(I,K) = VFALLRN
!            if (.not.use_autoconv_timescale) then
!               if (VFALLSN.NE.0.) then
!                  QSN_ALL = QSN_ALL + PFI_AN_dev(I,K)/VFALLSN
!               end if
!               if (VFALLRN.NE.0.) then
!                  QRN_ALL = QRN_ALL + PFL_AN_dev(I,K)/VFALLRN
!               end if
!            end if
! Largescale
! ----------
!                  PRELS_dev(I)    , & 
!                  SNRLS_dev(I)    , &
!                  REV_LS_dev(I,K) , &
!                  RSU_LS_dev(I,K) , &    
!                  ACLL_LS_dev(I,K), &
!                  ACIL_LS_dev(I,K), &
!                  PFL_LS_dev(I,K) , &
!                  PFI_LS_dev(I,K) , &
!                  VFALLRN         , &
!                  VFALLSN         , &
!                  FRZ_PP_dev(I,K) , &
        CALL PRECIP3_TLM(k, lm, dt, frland_dev(i), rhcrit, rhcrit_tl, &
&                  qrn_ls, qrn_ls_tl, qsn_ls, qsn_ls_tl, qtmp1, qtmp1_tl&
&                  , qtmp2, temp, temp_tl, q_dev(i, k), q_dev_tl(i, k), &
&                  mass, imass, pp_dev(i, k), dzet_dev(i, k), &
&                  dzet_dev_tl(i, k), qddf3_dev(i, k), qddf3_dev_tl(i, k&
&                  ), aa3, aa3_tl, bb3, bb3_tl, area_ls_prc_tolayer, &
&                  area_ls_prc_tolayer_tl, prn_ls_above, prn_ls_above_tl&
&                  , psn_ls_above, psn_ls_above_tl, evap_dd_ls_above, &
&                  evap_dd_ls_above_tl, subl_dd_ls_above, &
&                  subl_dd_ls_above_tl, envfc, lsddrfc)
!            VFALLSN_LS_dev(I,K) = VFALLSN
!            VFALLRN_LS_dev(I,K) = VFALLRN
!            if (.not.use_autoconv_timescale) then
!               if (VFALLSN.NE.0.) then
!                  QSN_ALL = QSN_ALL + PFI_LS_dev(I,K)/VFALLSN
!               end if
!               if (VFALLRN.NE.0.) then
!                  QRN_ALL = QRN_ALL + PFL_LS_dev(I,K)/VFALLRN
!               end if
!               if (VFALLRN.NE.0. .AND. VFALLSN.NE.0.) then
!                  QPLS_dev(I,K) = QPLS_dev(I,K) + PFL_LS_dev(I,K)/VFALLRN + PFI_LS_dev(I,K)/VFALLSN
!               end if 
!            end if
        IF (qlw_ls_dev(i, k) + qlw_an_dev(i, k) .GT. 0.00) THEN
          qtmp3_tl = -((qlw_ls_dev_tl(i, k)+qlw_an_dev_tl(i, k))/(&
&           qlw_ls_dev(i, k)+qlw_an_dev(i, k))**2)
          qtmp3 = 1./(qlw_ls_dev(i, k)+qlw_an_dev(i, k))
        ELSE
          qtmp3 = 0.0
          qtmp3_tl = 0.0_8
        END IF
        qlw_ls_dev_tl(i, k) = qlw_ls_dev_tl(i, k)*qtmp1*qtmp3 + &
&         qlw_ls_dev(i, k)*(qtmp1_tl*qtmp3+qtmp1*qtmp3_tl)
        qlw_ls_dev(i, k) = qlw_ls_dev(i, k)*qtmp1*qtmp3
        qlw_an_dev_tl(i, k) = qlw_an_dev_tl(i, k)*qtmp1*qtmp3 + &
&         qlw_an_dev(i, k)*(qtmp1_tl*qtmp3+qtmp1*qtmp3_tl)
        qlw_an_dev(i, k) = qlw_an_dev(i, k)*qtmp1*qtmp3
        IF (qiw_ls_dev(i, k) + qiw_an_dev(i, k) .GT. 0.00) THEN
          qtmp3_tl = -((qiw_ls_dev_tl(i, k)+qiw_an_dev_tl(i, k))/(&
&           qiw_ls_dev(i, k)+qiw_an_dev(i, k))**2)
          qtmp3 = 1./(qiw_ls_dev(i, k)+qiw_an_dev(i, k))
        ELSE
          qtmp3 = 0.0
          qtmp3_tl = 0.0_8
        END IF
        qiw_ls_dev_tl(i, k) = qiw_ls_dev_tl(i, k)*qtmp2*qtmp3 + &
&         qiw_ls_dev(i, k)*(qtmp2_tl*qtmp3+qtmp2*qtmp3_tl)
        qiw_ls_dev(i, k) = qiw_ls_dev(i, k)*qtmp2*qtmp3
        qiw_an_dev_tl(i, k) = qiw_an_dev_tl(i, k)*qtmp2*qtmp3 + &
&         qiw_an_dev(i, k)*(qtmp2_tl*qtmp3+qtmp2*qtmp3_tl)
        qiw_an_dev(i, k) = qiw_an_dev(i, k)*qtmp2*qtmp3
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        th_dev_tl(i, k) = temp_tl/exnp_dev(i, k)
        th_dev(i, k) = temp/exnp_dev(i, k)
!            QRN_ALL = QRN_ALL / (100.*PP_dev(I,K) / (MAPL8_RGAS*TEMP ))
!            QSN_ALL = QSN_ALL / (100.*PP_dev(I,K) / (MAPL8_RGAS*TEMP ))
!            RHCLR_dev(I,K) = MIN( CLDFRC_dev(I,K) + ANVFRC_dev(I,K), 1.00 )
!            IF ( RHCLR_dev(I,K) < 1.00 ) THEN
!               RHCLR_dev(I,K) = ( MIN( Q_dev(I,K)/QSAT(TEMP,PP_dev(I,K)),1.0 ) - RHCLR_dev(I,K) ) / &
!                                     (1. - RHCLR_dev(I,K))
!               IF ( RHCLR_dev(I,K) < 0.00 ) THEN
!                  RHCLR_dev(I,K) = MAPL8_UNDEF
!               END IF
!            ELSE
!               RHCLR_dev(I,K) = MAPL8_UNDEF
!            END IF
!            IF (DISABLE_RAD==1) THEN
!               RAD_QL_dev(I,K)     = 0.
!               RAD_QI_dev(I,K)     = 0.
!               RAD_QR_dev(I,K)     = 0.
!               RAD_QS_dev(I,K)     = 0.
!               RAD_CLDFRC_dev(I,K) = 0.
!               CLDREFFL_dev(I,K)   = 0.
!               CLDREFFI_dev(I,K)   = 0.
!            ELSE
!               call RADCOUPLE ( TEMP, PP_dev(I,K), CLDFRC_dev(I,K), ANVFRC_dev(I,K), &
!                     QLW_LS_dev(I,K), QIW_LS_dev(I,K), QLW_AN_dev(I,K), QIW_AN_dev(I,K), QRN_ALL, QSN_ALL, & 
!                     RAD_QL_dev(I,K), RAD_QI_dev(I,K), RAD_QR_dev(I,K), RAD_QS_dev(I,K), RAD_CLDFRC_dev(I,K), & 
!                     CLDREFFL_dev(I,K), CLDREFFI_dev(I,K), CLDVOL2FRC,N_ANVIL*1.e6,N_ICE*1.e6,N_WARM*1.e6, &
!                     TEMPOR_dev(I))
!            END IF
        qrn_cu_dev_tl(i, k) = 0.0_8
        qrn_cu_dev(i, k) = qrn_cu_1d
      END DO k_loop
    END DO run_loop
  END SUBROUTINE PROGNO_CLOUD_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! GPU The GPU main routine call is smaller due to CUDA limit on
!     number of arguments permitted in call. Most inputs and outputs
!     are USE-associated in the GridComp
!#ifdef _CUDA
!   attributes(global) subroutine progno_cloud(IRUN,LM,DT,SCLMFDFR)
!#else
!!! first vars are (in) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!         LATS_dev         , &
!         RAD_CLDFRC_dev   , &
!         RAD_QL_dev       , &
!         RAD_QI_dev       , &
!         RAD_QR_dev       , &
!         RAD_QS_dev       , &
!         QPLS_dev         , &
!         CLDREFFL_dev     , &
!         CLDREFFI_dev     , &
!         PRELS_dev        , &
!         PRECU_dev        , &
!         PREAN_dev        , &
!         LSARF_dev        , &
!         CUARF_dev        , &
!         ANARF_dev        , &
!         SNRLS_dev        , &
!         SNRCU_dev        , &
!         SNRAN_dev        , &
!, &
  SUBROUTINE PROGNO_CLOUD(irun, lm, dt, pp_dev, ppe_dev, exnp_dev, &
&   frland_dev, kh_dev, rmfdtr_dev, qlwdtr_dev, qrn_cu_dev, &
&   cnv_updfrc_dev, u_dev, v_dev, th_dev, q_dev, qlw_ls_dev, qlw_an_dev&
&   , qiw_ls_dev, qiw_an_dev, anvfrc_dev, cldfrc_dev, cldparams, &
&   sclmfdfr, qst3_dev, dzet_dev, qddf3_dev, cnv_fraction_dev)
    IMPLICIT NONE
!#ifndef _CUDA
!#else
!      end if RUN_LOOP
!#endif
!#ifdef _CUDA
!      integer, intent(in   ), value :: IRUN
!      integer, intent(in   ), value :: LM
!      real(8), intent(in   ), value :: DT
!      real(8), intent(in   ), value :: SCLMFDFR   ! CLOUD_CTL%SCLMFDFR
!#else
    TYPE(CLDPARAM_TYPE), INTENT(IN) :: cldparams
! IM*JM
    INTEGER, INTENT(IN) :: irun
! LM
    INTEGER, INTENT(IN) :: lm
! DT_MOIST
    REAL*8, INTENT(IN) :: dt
!      real(8), intent(in   ), dimension(IRUN)      :: LATS_dev    ! LATS
! PLO
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: pp_dev
! CNV_PLE
    REAL*8, DIMENSION(irun, 0:lm), INTENT(IN) :: ppe_dev
! PK
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: exnp_dev
! FRLAND
    REAL*8, DIMENSION(irun), INTENT(IN) :: frland_dev
! KH
    REAL*8, DIMENSION(irun, 0:lm), INTENT(IN) :: kh_dev
! CNV_MFD
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: rmfdtr_dev
! CNV_DQLDT
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: qlwdtr_dev
! CNV_PRC3 IS THIS INTENT IN?
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qrn_cu_dev
! CNV_UPDF
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: cnv_updfrc_dev
! U1
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: u_dev
! V1
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: v_dev
! TH1
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: th_dev
! Q1
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: q_dev
! QLLS
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qlw_ls_dev
! QLCN
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qlw_an_dev
! QILS
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qiw_ls_dev
! QICN
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qiw_an_dev
! CLCN
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: anvfrc_dev
! CLLS
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: cldfrc_dev
!      real(8), intent(  out), dimension(IRUN,  LM) :: RAD_CLDFRC_dev ! RAD_CF
!      real(8), intent(  out), dimension(IRUN,  LM) :: RAD_QL_dev ! RAD_QL
!      real(8), intent(  out), dimension(IRUN,  LM) :: RAD_QI_dev ! RAD_QI
!      real(8), intent(  out), dimension(IRUN,  LM) :: RAD_QR_dev ! QRAIN
!      real(8), intent(  out), dimension(IRUN,  LM) :: RAD_QS_dev ! QSNOW
!      real(8), intent(  out), dimension(IRUN,  LM) :: QPLS_dev ! QPLS
!      real(8), intent(  out), dimension(IRUN,  LM) :: CLDREFFL_dev ! CLDREFFL
!      real(8), intent(  out), dimension(IRUN,  LM) :: CLDREFFI_dev ! CLDREFFI
!      real(8), intent(  out), dimension(IRUN     ) :: PRELS_dev ! LS_PRC2
!      real(8), intent(  out), dimension(IRUN     ) :: PRECU_dev ! CN_PRC2
!      real(8), intent(  out), dimension(IRUN     ) :: PREAN_dev ! AN_PRC2
!      real(8), intent(  out), dimension(IRUN     ) :: LSARF_dev ! LS_ARFX
!      real(8), intent(  out), dimension(IRUN     ) :: CUARF_dev ! CN_ARFX
!      real(8), intent(  out), dimension(IRUN     ) :: ANARF_dev ! AN_ARFX
!      real(8), intent(  out), dimension(IRUN     ) :: SNRLS_dev ! LS_SNR
!      real(8), intent(  out), dimension(IRUN     ) :: SNRCU_dev ! CN_SNR
!      real(8), intent(  out), dimension(IRUN     ) :: SNRAN_dev ! AN_SNR
! CLOUD_CTL%SCLMFDFR
    REAL*8, INTENT(IN) :: sclmfdfr
! QST3
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: qst3_dev
! DZET
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: dzet_dev
! QDDF3
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: qddf3_dev
! CNV_FRACTION
    REAL*8, DIMENSION(irun), INTENT(IN) :: cnv_fraction_dev
!      real(8), intent(  out), dimension(IRUN,  LM) :: RHX_dev    ! RHX
!      real(8), intent(  out), dimension(IRUN,  LM) :: REV_LS_dev ! REV_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: REV_AN_dev ! REV_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: REV_CN_dev ! REV_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: RSU_LS_dev ! RSU_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: RSU_AN_dev ! RSU_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: RSU_CN_dev ! RSU_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACLL_CN_dev ! ACLL_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACIL_CN_dev ! ACIL_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACLL_AN_dev ! ACLL_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACIL_AN_dev ! ACIL_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACLL_LS_dev ! ACLL_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACIL_LS_dev ! ACIL_LS
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFL_CN_dev ! PFL_CN
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFI_CN_dev ! PFI_CN
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFL_AN_dev ! PFL_AN
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFI_AN_dev ! PFI_AN
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFL_LS_dev ! PFL_LS
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFI_LS_dev ! PFI_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: PDFL_dev ! DlPDF
!      real(8), intent(  out), dimension(IRUN,  LM) :: PDFI_dev ! DiPDF
!      real(8), intent(  out), dimension(IRUN,  LM) :: FIXL_dev ! DlFIX
!      real(8), intent(  out), dimension(IRUN,  LM) :: FIXI_dev ! DiFIX                  
!      real(8), intent(  out), dimension(IRUN,  LM) :: AUT_dev   ! AUT
!      real(8), intent(  out), dimension(IRUN,  LM) :: EVAPC_dev ! EVAPC
!      real(8), intent(  out), dimension(IRUN,  LM) :: SDM_dev   ! SDM
!      real(8), intent(  out), dimension(IRUN,  LM) :: SUBLC_dev ! SUBLC
!      real(8), intent(  out), dimension(IRUN,  LM) :: FRZ_TT_dev ! FRZ_TT
!      real(8), intent(  out), dimension(IRUN,  LM) :: FRZ_PP_dev ! FRZ_PP
!      real(8), intent(  out), dimension(IRUN,  LM) :: DCNVL_dev ! DCNVL
!      real(8), intent(  out), dimension(IRUN,  LM) :: DCNVi_dev ! DCNVi
!      real(8), intent(  out), dimension(IRUN,  LM) :: ALPHT_dev ! ALPHT
!      real(8), intent(  out), dimension(IRUN,  LM) :: ALPH1_dev ! ALPH1
!      real(8), intent(  out), dimension(IRUN,  LM) :: ALPH2_dev ! ALPH2
!      real(8), intent(  out), dimension(IRUN,  LM) :: CFPDF_dev ! CFPDF
!      real(8), intent(  out), dimension(IRUN,  LM) :: RHCLR_dev ! RHCLR
!      real(8), intent(  out), dimension(IRUN,  LM) :: DQRL_dev ! DQRL
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLICE_AN_dev ! VFALLICE_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLICE_LS_dev ! VFALLICE_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLWAT_AN_dev ! VFALLWAT_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLWAT_LS_dev ! VFALLWAT_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLSN_AN_dev ! VFALLSN_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLSN_LS_dev ! VFALLSN_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLSN_CN_dev ! VFALLSN_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLRN_AN_dev ! VFALLRN_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLRN_LS_dev ! VFALLRN_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLRN_CN_dev ! VFALLRN_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: LIQANMOVE_dev  ! LIQANMOVE
!      real(8), intent(  out), dimension(IRUN,  LM) :: ICEANMOVE_dev  ! ICEANMOVE
!      real(8), intent(  out), dimension(IRUN,  LM) :: DANCLD_dev     ! DANCLD
!      real(8), intent(  out), dimension(IRUN,  LM) :: DLSCLD_dev     ! DLSCLD
!      real(8), intent(  out), dimension(IRUN,  LM) :: CURAINMOVE_dev ! CURAINMOVE
!      real(8), intent(  out), dimension(IRUN,  LM) :: CUSNOWMOVE_dev ! CUSNOWMOVE
!      real(8), intent(in   ), dimension(IRUN     ) :: TEMPOR_dev  ! TEMPOR
!#endif
! GPU The GPUs need to know how big local arrays are during compile-time
!     as the GPUs cannot allocate memory themselves. This command resets
!     this a priori size to LM for the CPU.
!#ifndef GPU_MAXLEVS
!#define GPU_MAXLEVS LM
!#endif
    INTEGER :: i, j, k, l
    INTEGER :: fraction_removal1, fraction_removal2, fraction_removal3
    REAL*8 :: mass, imass
    REAL*8 :: totfrc
    REAL*8 :: qrn_ls, qrn_an, qrn_cu_1d
    REAL*8 :: qsn_ls, qsn_an, qsn_cu
!      real(8) :: QRN_ALL, QSN_ALL
    REAL*8 :: qtmp1, qtmp2, qtmp3
    REAL*8 :: temp
    REAL*8 :: rhcrit
    REAL*8 :: aa3, bb3, alpha
    REAL*8 :: vfall, vfallrn, vfallsn
    REAL*8 :: tot_prec_upd
    REAL*8 :: tot_prec_anv
    REAL*8 :: tot_prec_ls
    REAL*8 :: area_upd_prc
    REAL*8 :: area_anv_prc
    REAL*8 :: area_ls_prc
    REAL*8 :: area_upd_prc_tolayer
    REAL*8 :: area_anv_prc_tolayer
    REAL*8 :: area_ls_prc_tolayer
    REAL*8 :: u_above, u_below
    REAL*8 :: v_above, v_below
    REAL*8 :: dzet_above, dzet_below
    REAL*8 :: prn_cu_above, psn_cu_above
    REAL*8 :: prn_ls_above, psn_ls_above
    REAL*8 :: prn_an_above, psn_an_above
    REAL*8 :: evap_dd_cu_above, subl_dd_cu_above
    REAL*8 :: evap_dd_ls_above, subl_dd_ls_above
    REAL*8 :: evap_dd_an_above, subl_dd_an_above
    LOGICAL :: use_autoconv_timescale
    REAL*8 :: tropical, extratropical
    REAL*8 :: lsenvfc, anvenvfc, envfc, ddrfc, beta
    REAL*8 :: sdqv2, sdqv3, sdqvt1
    REAL*8 :: lspdfliqnew, lspdficenew, lspdffracnew
    INTRINSIC INT
    INTRINSIC NINT
    INTRINSIC MAX
! These are in constant memory in CUDA and are set in the GridComp
!#ifndef _CUDA
! Area factor for convective rain showers (non-dim)
    cnv_beta = cldparams%cnv_beta
! Area factor for anvil rain showers (non-dim)
    anv_beta = cldparams%anv_beta
! Area factor for Large Scale rain showers (non-dim)
    ls_beta = cldparams%ls_beta
! Critical relative humidity
    rh00 = cldparams%rh_crit
    c_00 = cldparams%autoc_ls
    lwcrit = cldparams%qc_crit_ls
    c_acc = cldparams%accretion
    c_ev_r = cldparams%rain_revap_fac
    c_ev_s = cldparams%snow_revap_fac
    cldvol2frc = cldparams%vol_to_frac
    rhsup_ice = cldparams%supersat
    shr_evap_fac = cldparams%shear_evap_fac
    min_cld_water = cldparams%min_allow_ccw
    cld_evp_eff = cldparams%ccw_evap_eff
    nsmax = INT(cldparams%nsub_autoconv)
    ls_sdqv2 = cldparams%ls_sund_inter
    ls_sdqv3 = cldparams%ls_sund_cold
    ls_sdqvt1 = cldparams%ls_sund_temp1
    anv_sdqv2 = cldparams%anv_sund_inter
    anv_sdqv3 = cldparams%anv_sund_cold
    anv_sdqvt1 = cldparams%anv_sund_temp1
    anv_to_ls = cldparams%anv_to_ls_time
    n_warm = cldparams%nccn_warm
    n_ice = cldparams%nccn_ice
    n_anvil = cldparams%nccn_anvil
    n_pbl = cldparams%nccn_pbl
    disable_rad = INT(cldparams%disable_rad)
    ice_settle = NINT(cldparams%ice_settle)
    anv_icefall_c = cldparams%anv_icefall
    ls_icefall_c = cldparams%ls_icefall
    revap_off_p = cldparams%revap_off_p
    cnvenvfc = cldparams%cnv_envf
    wrhodep = cldparams%wrhodep
    t_ice_all = cldparams%ice_ramp + mapl8_tice
    cnviceparam = cldparams%cnv_iceparam
    icefrpwr = INT(cldparams%cnv_icefrpwr + .001)
    cnvddrfc = cldparams%cnv_ddrf
    anvddrfc = cldparams%anv_ddrf
    lsddrfc = cldparams%ls_ddrf
    tanhrhcrit = INT(cldparams%tanhrhcrit)
    minrhcrit = cldparams%minrhcrit
    maxrhcrit = cldparams%maxrhcrit
    turnrhcrit = cldparams%turnrhcrit
    maxrhcritland = cldparams%maxrhcritland
    fr_ls_wat = INT(cldparams%fr_ls_wat)
    fr_ls_ice = INT(cldparams%fr_ls_ice)
    fr_an_wat = INT(cldparams%fr_an_wat)
    fr_an_ice = INT(cldparams%fr_an_ice)
    min_rl = cldparams%min_rl
    min_ri = cldparams%min_ri
    max_rl = cldparams%max_rl
    max_ri = cldparams%max_ri
    ri_anv = cldparams%ri_anv
    pdfflag = INT(cldparams%pdfshape)
    ktop = INT(cldparams%ktop)
!#endif
    use_autoconv_timescale = .false.
!#ifdef _CUDA
!      i = (blockidx%x - 1) * blockdim%x + threadidx%x
!
!      RUN_LOOP: IF ( I <= IRUN ) THEN
!#else
run_loop:DO i=1,irun
!#endif
k_loop:DO k=ktop,lm
        IF (k .EQ. ktop) THEN
          tot_prec_upd = 0.
          tot_prec_anv = 0.
          tot_prec_ls = 0.
          area_upd_prc = 0.
          area_anv_prc = 0.
          area_ls_prc = 0.
        END IF
!! ZERO DIAGNOSTIC OUTPUTS BEFORE SHOWERS !!
!               PRELS_dev(I) = 0.
!               PRECU_dev(I) = 0.
!               PREAN_dev(I) = 0.
!               SNRCU_dev(I) = 0. 
!               SNRLS_dev(I) = 0. 
!               SNRAN_dev(I) = 0. 
!               LSARF_dev(I) = 0.
!               CUARF_dev(I) = 0.
!               ANARF_dev(I) = 0.
!Zero out/initialize precips, except QRN_CU which comes from RAS 
        qrn_ls = 0.
        qrn_an = 0.
        qrn_cu_1d = 0.
        qsn_ls = 0.
        qsn_an = 0.
        qsn_cu = 0.
        vfall = 0.
!            RAD_QL_dev(I,K)     = 0.
!            RAD_QI_dev(I,K)     = 0.
!            RAD_QR_dev(I,K)     = 0.
!            RAD_QS_dev(I,K)     = 0.
!            QPLS_dev(I,K)       = 0.
!            RAD_CLDFRC_dev(I,K) = 0.
!            CLDREFFL_dev(I,K)   = 0.
!            CLDREFFI_dev(I,K)   = 0.
!            PFL_CN_dev(I,K) = 0.
!            PFI_CN_dev(I,K) = 0.
!            PFL_AN_dev(I,K) = 0.
!            PFI_AN_dev(I,K) = 0.
!            PFL_LS_dev(I,K) = 0.
!            PFI_LS_dev(I,K) = 0.
!            IF (K == KTOP) THEN
!               PFL_CN_dev(I,0) = 0.
!               PFI_CN_dev(I,0) = 0.
!               PFL_AN_dev(I,0) = 0.
!               PFI_AN_dev(I,0) = 0.
!               PFL_LS_dev(I,0) = 0.
!               PFI_LS_dev(I,0) = 0.
!            END IF
! Initialize other diagnostics 
!            RHX_dev(I,K) = MAPL8_UNDEF
!            REV_LS_dev(I,K) = MAPL8_UNDEF
!            REV_AN_dev(I,K) = MAPL8_UNDEF
!            REV_CN_dev(I,K) = MAPL8_UNDEF
!            RSU_LS_dev(I,K) = MAPL8_UNDEF
!            RSU_AN_dev(I,K) = MAPL8_UNDEF
!            RSU_CN_dev(I,K) = MAPL8_UNDEF
!            ACLL_CN_dev(I,K) = MAPL8_UNDEF
!            ACIL_CN_dev(I,K) = MAPL8_UNDEF
!            ACLL_AN_dev(I,K) = MAPL8_UNDEF
!            ACIL_AN_dev(I,K) = MAPL8_UNDEF
!            ACLL_LS_dev(I,K) = MAPL8_UNDEF
!            ACIL_LS_dev(I,K) = MAPL8_UNDEF
!            PDFL_dev(I,K) = MAPL8_UNDEF
!            PDFI_dev(I,K) = MAPL8_UNDEF
!            FIXL_dev(I,K) = MAPL8_UNDEF
!            FIXI_dev(I,K) = MAPL8_UNDEF
!            AUT_dev(I,K) = MAPL8_UNDEF
!            EVAPC_dev(I,K) = MAPL8_UNDEF
!            SDM_dev(I,K) = MAPL8_UNDEF
!            SUBLC_dev(I,K) = MAPL8_UNDEF
!            FRZ_TT_dev(I,K) = MAPL8_UNDEF
!            FRZ_PP_dev(I,K) = MAPL8_UNDEF
!            DCNVL_dev(I,K) = MAPL8_UNDEF
!            DCNVi_dev(I,K) = MAPL8_UNDEF
!            ALPHT_dev(I,K) = MAPL8_UNDEF
!            ALPH1_dev(I,K) = MAPL8_UNDEF
!            ALPH2_dev(I,K) = MAPL8_UNDEF
!            CFPDF_dev(I,K) = MAPL8_UNDEF
!            RHCLR_dev(I,K) = MAPL8_UNDEF
!            DQRL_dev(I,K) = MAPL8_UNDEF
!            VFALLICE_AN_dev(I,K) = MAPL8_UNDEF
!            VFALLICE_LS_dev(I,K) = MAPL8_UNDEF
!            VFALLWAT_AN_dev(I,K) = MAPL8_UNDEF
!            VFALLWAT_LS_dev(I,K) = MAPL8_UNDEF
!            VFALLSN_AN_dev(I,K) = MAPL8_UNDEF
!            VFALLSN_LS_dev(I,K) = MAPL8_UNDEF
!            VFALLSN_CN_dev(I,K) = MAPL8_UNDEF
!            VFALLRN_AN_dev(I,K) = MAPL8_UNDEF
!            VFALLRN_LS_dev(I,K) = MAPL8_UNDEF
!            VFALLRN_CN_dev(I,K) = MAPL8_UNDEF
! Copy QRN_CU into a temp scalar
        qrn_cu_1d = qrn_cu_dev(i, k)
! layer-mass (kg/m**2)
        mass = (ppe_dev(i, k)-ppe_dev(i, k-1))*100./mapl8_grav
        imass = 1.0/mass
        temp = exnp_dev(i, k)*th_dev(i, k)
!            FRZ_PP_dev(I,K) = 0.00
!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Total Condensate Source
!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            FIXL_dev(I,K) = QLW_AN_dev(I,K) + QLW_LS_dev(I,K)
!            FIXI_dev(I,K) = QIW_AN_dev(I,K) + QIW_LS_dev(I,K)
        CALL FIX_UP_CLOUDS(q_dev(i, k), temp, qlw_ls_dev(i, k), &
&                    qiw_ls_dev(i, k), cldfrc_dev(i, k), qlw_an_dev(i, k&
&                    ), qiw_an_dev(i, k), anvfrc_dev(i, k))
!            FIXL_dev(I,K) = -( QLW_AN_dev(I,K) + QLW_LS_dev(I,K) - FIXL_dev(I,K) ) / DT 
!            FIXI_dev(I,K) = -( QIW_AN_dev(I,K) + QIW_LS_dev(I,K) - FIXI_dev(I,K) ) / DT 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            FRZ_TT_dev(I,K) = QIW_AN_dev(I,K) + QIW_LS_dev(I,K)
        CALL MELTFRZ(dt, temp, qlw_ls_dev(i, k), qiw_ls_dev(i, k))
        CALL MELTFRZ(dt, temp, qlw_an_dev(i, k), qiw_an_dev(i, k))
!            FRZ_TT_dev(I,K) = ( QIW_AN_dev(I,K) + QIW_LS_dev(I,K) - FRZ_TT_dev(I,K) ) / DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            DCNVi_dev(I,K) = QIW_AN_dev(I,K)
!            DCNVL_dev(I,K) = QLW_AN_dev(I,K)
        CALL CNVSRC(dt, cnviceparam, sclmfdfr, mass, imass, pp_dev(i, k)&
&             , temp, q_dev(i, k), qlwdtr_dev(i, k), rmfdtr_dev(i, k), &
&             qlw_an_dev(i, k), qiw_an_dev(i, k), cldfrc_dev(i, k), &
&             anvfrc_dev(i, k), qst3_dev(i, k))
!            DCNVi_dev(I,K) = ( QIW_AN_dev(I,K) - DCNVi_dev(I,K) ) / DT
!            DCNVL_dev(I,K) = ( QLW_AN_dev(I,K) - DCNVL_dev(I,K) ) / DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            PDFL_dev(I,K) = QLW_LS_dev(I,K)+QLW_AN_dev(I,K)
!            PDFI_dev(I,K) = QIW_LS_dev(I,K)+QIW_AN_dev(I,K)
        IF (k .EQ. ktop .OR. k .EQ. lm) THEN
          u_above = 0.0
          u_below = 0.0
          v_above = 0.0
          v_below = 0.0
          dzet_above = 0.0
          dzet_below = 0.0
        ELSE
          u_above = u_dev(i, k-1)
          u_below = u_dev(i, k+1)
          v_above = v_dev(i, k-1)
          v_below = v_dev(i, k+1)
          dzet_above = dzet_dev(i, k-1)
          dzet_below = dzet_dev(i, k+1)
        END IF
!                  ALPHT_dev(I,K), ALPH1_dev(I,K),!ALPH2_dev(I,K), & 
        CALL PDF_SPREAD(k, lm, u_dev(i, k), u_above, u_below, v_dev(i, k&
&                 ), v_above, v_below, kh_dev(i, k-1), dzet_above, &
&                 dzet_below, cnv_updfrc_dev(i, k), pp_dev(i, k), alpha&
&                 , frland_dev(i))
        IF (alpha .LT. 1.0 - rh00) THEN
          alpha = 1.0 - rh00
        ELSE
          alpha = alpha
        END IF
        rhcrit = 1.0 - alpha
        lspdfliqnew = qlw_ls_dev(i, k)
        lspdficenew = qiw_ls_dev(i, k)
        lspdffracnew = cldfrc_dev(i, k)
        CALL HYSTPDF(dt, alpha, pdfflag, pp_dev(i, k), q_dev(i, k), &
&              qlw_ls_dev(i, k), qlw_an_dev(i, k), qiw_ls_dev(i, k), &
&              qiw_an_dev(i, k), temp, cldfrc_dev(i, k), anvfrc_dev(i, k&
&              ))
        lspdfliqnew = qlw_ls_dev(i, k) - lspdfliqnew
        lspdficenew = qiw_ls_dev(i, k) - lspdficenew
        lspdffracnew = cldfrc_dev(i, k) - lspdffracnew
!            RHX_dev(I,K)   = Q_dev(I,K)/QSAT( TEMP, PP_dev(I,K) )
!            CFPDF_dev(I,K) = CLDFRC_dev(I,K)
!            PDFL_dev(I,K)  = ( QLW_LS_dev(I,K) + QLW_AN_dev(I,K) - PDFL_dev(I,K) ) / DT 
!            PDFI_dev(I,K)  = ( QIW_LS_dev(I,K) + QIW_AN_dev(I,K) - PDFI_dev(I,K) ) / DT 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        totfrc = cldfrc_dev(i, k) + anvfrc_dev(i, k)
        IF (totfrc .GT. 1.00) THEN
          cldfrc_dev(i, k) = cldfrc_dev(i, k)*(1.00/totfrc)
          anvfrc_dev(i, k) = anvfrc_dev(i, k)*(1.00/totfrc)
        END IF
        totfrc = cldfrc_dev(i, k) + anvfrc_dev(i, k)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! CONDENSATE/FRACTION SOURCES FINISHED. NOW LOSE CLOUD CONDENSATE !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Total Condensate Sink
!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!       E  V  A  P  O  R  A  T  I  O  N
!!                A  N  D 
!!       S  U  B  L  I  M  A  T  I  O  N
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            EVAPC_dev(I,K) = QLW_LS_dev(I,K)+QLW_AN_dev(I,K)
!            SUBLC_dev(I,K) = QIW_LS_dev(I,K)+QIW_AN_dev(I,K)
! 'Anvil' partition from RAS/Parameterized not done in hystpdf
        CALL EVAP3(dt, rhcrit, pp_dev(i, k), temp, q_dev(i, k), &
&            qlw_an_dev(i, k), qiw_an_dev(i, k), anvfrc_dev(i, k), &
&            cldfrc_dev(i, k), qst3_dev(i, k))
        CALL SUBL3(dt, rhcrit, pp_dev(i, k), temp, q_dev(i, k), &
&            qlw_an_dev(i, k), qiw_an_dev(i, k), anvfrc_dev(i, k), &
&            cldfrc_dev(i, k), qst3_dev(i, k))
!            EVAPC_dev(I,K) = ( EVAPC_dev(I,K) - (QLW_LS_dev(I,K)+QLW_AN_dev(I,K)) ) / DT
!            SUBLC_dev(I,K) = ( SUBLC_dev(I,K) - (QIW_LS_dev(I,K)+QIW_AN_dev(I,K)) ) / DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!       A U T O C O N V E R S I  O  N
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!           FRACTION_REMOVAL = 0 -> none
!                              1 -> constant in-cloud QC
!                              2 -> trim high edge of PDF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            AUT_dev(I,K) = QLW_LS_dev(I,K)+QLW_AN_dev(I,K)
        fraction_removal1 = fr_ls_wat
        CALL AUTOCON3(dt, qlw_ls_dev(i, k), qrn_ls, temp, pp_dev(i, k), &
&               kh_dev(i, k-1), cldfrc_dev(i, k), ls_sdqv2, ls_sdqv3, &
&               ls_sdqvt1, dzet_dev(i, k), vfall, fraction_removal1)
!            VFALLWAT_LS_dev(I,K) = VFALL
        fraction_removal2 = fr_an_wat
        CALL AUTOCON3(dt, qlw_an_dev(i, k), qrn_an, temp, pp_dev(i, k), &
&               kh_dev(i, k), anvfrc_dev(i, k), anv_sdqv2, anv_sdqv3, &
&               anv_sdqvt1, dzet_dev(i, k), vfall, fraction_removal2)
!            VFALLWAT_AN_dev(I,K) = VFALL
!            AUT_dev(I,K) = ( AUT_dev(I,K) - ( QLW_AN_dev(I,K) + QLW_LS_dev(I,K) ) )/DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Ice cloud settling
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            SDM_dev(I,K) = QIW_AN_dev(I,K)+QIW_LS_dev(I,K)
! Parameterized (RAS) Ice Fall
! ----------------------------
! WMP: Adjustments to resolved scale ice fall speed options                            
        IF (cnv_fraction_dev(i) .GE. 0.5) THEN
          fraction_removal3 = fr_an_ice
        ELSE
          fraction_removal3 = fr_ls_ice
        END IF
        SELECT CASE  (ice_settle) 
        CASE (0) 
! MERRA-2 Formulation
          tropical = anv_icefall_c*1.0
          extratropical = anv_icefall_c*0.0
        CASE (1) 
          tropical = cnv_fraction_dev(i)
          extratropical = 1.0 - tropical
          tropical = anv_icefall_c*tropical
          extratropical = ls_icefall_c*extratropical
        END SELECT
        CALL SETTLE_VEL(wrhodep, qiw_an_dev(i, k), pp_dev(i, k), temp, &
&                 anvfrc_dev(i, k), kh_dev(i, k-1), vfall, extratropical&
&                 , tropical)
!            VFALLICE_AN_dev(I,K) = VFALL
        CALL ICEFALL(qiw_an_dev(i, k), dzet_dev(i, k), qsn_an, vfall, &
&              anvfrc_dev(i, k), dt, fraction_removal3)
! Resolved Scale Ice Fall
! -----------------------
! WMP: Adjustments to resolved scale ice fall speed options 
        SELECT CASE  (ice_settle) 
        CASE (0) 
! MERRA-2 Formulation
          tropical = ls_icefall_c*0.0
          extratropical = ls_icefall_c*1.0
        CASE (1) 
          tropical = cnv_fraction_dev(i)
          extratropical = 1.0 - tropical
          tropical = anv_icefall_c*tropical
          extratropical = ls_icefall_c*extratropical
        END SELECT
        CALL SETTLE_VEL(wrhodep, qiw_ls_dev(i, k), pp_dev(i, k), temp, &
&                 cldfrc_dev(i, k), kh_dev(i, k-1), vfall, extratropical&
&                 , tropical)
!            VFALLICE_LS_dev(I,K) = VFALL
        CALL ICEFALL(qiw_ls_dev(i, k), dzet_dev(i, k), qsn_ls, vfall, &
&              cldfrc_dev(i, k), dt, fraction_removal3)
!            SDM_dev(I,K) = ( SDM_dev(I,K) - (QIW_LS_dev(I,K) + QIW_AN_dev(I,K)) )/DT
!            DQRL_dev(I,K) = ( QRN_LS + QRN_AN + QSN_LS + QSN_AN ) / DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Add in convective rain 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! CU-FREEZE 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Also "freeze" out any conv. precip that needs
! to be since this isnt done in RAS. This is
! precip w/ large particles, so freezing is 
! strict. Check up on this!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        qtmp2 = 0.
        IF (temp .LT. mapl8_tice) THEN
          qtmp2 = qrn_cu_1d
          qsn_cu = qrn_cu_1d
          qrn_cu_1d = 0.
          temp = temp + qsn_cu*(mapl8_alhs-mapl8_alhl)/mapl8_cp
        END IF
!            FRZ_PP_dev(I,K) = FRZ_PP_dev(I,K) +  QTMP2/DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!----------------------------------------------------------------------------------------------
! Column will now be swept from top-down for precip accumulation/accretion/re-evaporation
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        area_ls_prc_tolayer = 0.0
        area_upd_prc_tolayer = 0.0
        area_anv_prc_tolayer = 0.0
        tot_prec_upd = tot_prec_upd + (qrn_cu_1d+qsn_cu)*mass
        area_upd_prc = area_upd_prc + cnv_updfrc_dev(i, k)*(qrn_cu_1d+&
&         qsn_cu)*mass
        tot_prec_anv = tot_prec_anv + (qrn_an+qsn_an)*mass
        area_anv_prc = area_anv_prc + anvfrc_dev(i, k)*(qrn_an+qsn_an)*&
&         mass
        tot_prec_ls = tot_prec_ls + (qrn_ls+qsn_ls)*mass
        area_ls_prc = area_ls_prc + cldfrc_dev(i, k)*(qrn_ls+qsn_ls)*&
&         mass
        IF (tot_prec_anv .GT. 0.0) THEN
          IF (area_anv_prc/tot_prec_anv .LT. 1.e-6) THEN
            area_anv_prc_tolayer = 1.e-6
          ELSE
            area_anv_prc_tolayer = area_anv_prc/tot_prec_anv
          END IF
        END IF
        IF (tot_prec_upd .GT. 0.0) THEN
          IF (area_upd_prc/tot_prec_upd .LT. 1.e-6) THEN
            area_upd_prc_tolayer = 1.e-6
          ELSE
            area_upd_prc_tolayer = area_upd_prc/tot_prec_upd
          END IF
        END IF
        IF (tot_prec_ls .GT. 0.0) THEN
          IF (area_ls_prc/tot_prec_ls .LT. 1.e-6) THEN
            area_ls_prc_tolayer = 1.e-6
          ELSE
            area_ls_prc_tolayer = area_ls_prc/tot_prec_ls
          END IF
        END IF
        area_ls_prc_tolayer = ls_beta*area_ls_prc_tolayer
        area_upd_prc_tolayer = cnv_beta*area_upd_prc_tolayer
        area_anv_prc_tolayer = anv_beta*area_anv_prc_tolayer
        IF (k .EQ. lm) THEN
! Weve accumulated over the whole column
          IF (tot_prec_anv .GT. 0.0) THEN
            IF (area_anv_prc/tot_prec_anv .LT. 1.e-6) THEN
              area_anv_prc = 1.e-6
            ELSE
              area_anv_prc = area_anv_prc/tot_prec_anv
            END IF
          END IF
          IF (tot_prec_upd .GT. 0.0) THEN
            IF (area_upd_prc/tot_prec_upd .LT. 1.e-6) THEN
              area_upd_prc = 1.e-6
            ELSE
              area_upd_prc = area_upd_prc/tot_prec_upd
            END IF
          END IF
          IF (tot_prec_ls .GT. 0.0) THEN
            IF (area_ls_prc/tot_prec_ls .LT. 1.e-6) THEN
              area_ls_prc = 1.e-6
            ELSE
              area_ls_prc = area_ls_prc/tot_prec_ls
            END IF
          END IF
          area_ls_prc = ls_beta*area_ls_prc
          area_upd_prc = cnv_beta*area_upd_prc
          area_anv_prc = anv_beta*area_anv_prc
!! "couple" to diagnostic areal(8) fraction output 
!! Intensity factor in PRECIP3 is floored at
!! 1.0. So this is fair.
!               LSARF_dev(I) = MIN( AREA_LS_PRC,  1.0 )
!               CUARF_dev(I) = MIN( AREA_UPD_PRC, 1.0 )
!               ANARF_dev(I) = MIN( AREA_ANV_PRC, 1.0 )
        END IF
!            QRN_ALL = 0.
!            QSN_ALL = 0.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! GET SOME MICROPHYSICAL QUANTITIES 
        CALL MICRO_AA_BB_3(temp, pp_dev(i, k), qst3_dev(i, k), aa3, bb3)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        qtmp1 = qlw_ls_dev(i, k) + qlw_an_dev(i, k)
        qtmp2 = qiw_ls_dev(i, k) + qiw_an_dev(i, k)
! CNVENVFC passed in as argument (default=0.8)
! Unlike CNVENVFC which is from PHYSPARAMS, this is set to 1.
        anvenvfc = 1.00
! Unlike CNVENVFC which is from PHYSPARAMS, this is set to 1.
        lsenvfc = 1.00
! Apply convective fractions
        envfc = cnvenvfc*cnv_fraction_dev(i) + lsenvfc*(1.0-&
&         cnv_fraction_dev(i))
! Convective
! ----------
!                  PRECU_dev(I)    , & 
!                  SNRCU_dev(I)    , & 
!                  REV_CN_dev(I,K) , &
!                  RSU_CN_dev(I,K) , &
!                  ACLL_CN_dev(I,K), &
!                  ACIL_CN_dev(I,K), &
!                  PFL_CN_dev(I,K) , &
!                  PFI_CN_dev(I,K) , &
!                  VFALLRN         , &
!                  VFALLSN         , &
!                  FRZ_PP_dev(I,K) , &
        CALL PRECIP3(k, lm, dt, frland_dev(i), rhcrit, qrn_cu_1d, qsn_cu&
&              , qtmp1, qtmp2, temp, q_dev(i, k), mass, imass, pp_dev(i&
&              , k), dzet_dev(i, k), qddf3_dev(i, k), aa3, bb3, &
&              area_upd_prc_tolayer, prn_cu_above, psn_cu_above, &
&              evap_dd_cu_above, subl_dd_cu_above, envfc, cnvddrfc)
!            VFALLSN_CN_dev(I,K) = VFALLSN
!            VFALLRN_CN_dev(I,K) = VFALLRN
!            if (.not.use_autoconv_timescale) then
!               if (VFALLSN.NE.0.) then
!                  QSN_ALL = QSN_ALL + PFI_CN_dev(I,K)/VFALLSN
!               end if
!               if (VFALLRN.NE.0.) then
!                  QRN_ALL = QRN_ALL + PFL_CN_dev(I,K)/VFALLRN
!               end if
!            end if
! Anvil
! -----
!                  PREAN_dev(I)    , & 
!                  SNRAN_dev(I)    , &
!                  REV_AN_dev(I,K) , &
!                  RSU_AN_dev(I,K) , &
!                  ACLL_AN_dev(I,K), &
!                  ACIL_AN_dev(I,K), &
!                  PFL_AN_dev(I,K) , &
!                  PFI_AN_dev(I,K) , &
!                  VFALLRN         , &
!                  VFALLSN         , &
!                  FRZ_PP_dev(I,K) , &
        CALL PRECIP3(k, lm, dt, frland_dev(i), rhcrit, qrn_an, qsn_an, &
&              qtmp1, qtmp2, temp, q_dev(i, k), mass, imass, pp_dev(i, k&
&              ), dzet_dev(i, k), qddf3_dev(i, k), aa3, bb3, &
&              area_anv_prc_tolayer, prn_an_above, psn_an_above, &
&              evap_dd_an_above, subl_dd_an_above, envfc, anvddrfc)
!            VFALLSN_AN_dev(I,K) = VFALLSN
!            VFALLRN_AN_dev(I,K) = VFALLRN
!            if (.not.use_autoconv_timescale) then
!               if (VFALLSN.NE.0.) then
!                  QSN_ALL = QSN_ALL + PFI_AN_dev(I,K)/VFALLSN
!               end if
!               if (VFALLRN.NE.0.) then
!                  QRN_ALL = QRN_ALL + PFL_AN_dev(I,K)/VFALLRN
!               end if
!            end if
! Largescale
! ----------
!                  PRELS_dev(I)    , & 
!                  SNRLS_dev(I)    , &
!                  REV_LS_dev(I,K) , &
!                  RSU_LS_dev(I,K) , &    
!                  ACLL_LS_dev(I,K), &
!                  ACIL_LS_dev(I,K), &
!                  PFL_LS_dev(I,K) , &
!                  PFI_LS_dev(I,K) , &
!                  VFALLRN         , &
!                  VFALLSN         , &
!                  FRZ_PP_dev(I,K) , &
        CALL PRECIP3(k, lm, dt, frland_dev(i), rhcrit, qrn_ls, qsn_ls, &
&              qtmp1, qtmp2, temp, q_dev(i, k), mass, imass, pp_dev(i, k&
&              ), dzet_dev(i, k), qddf3_dev(i, k), aa3, bb3, &
&              area_ls_prc_tolayer, prn_ls_above, psn_ls_above, &
&              evap_dd_ls_above, subl_dd_ls_above, envfc, lsddrfc)
!            VFALLSN_LS_dev(I,K) = VFALLSN
!            VFALLRN_LS_dev(I,K) = VFALLRN
!            if (.not.use_autoconv_timescale) then
!               if (VFALLSN.NE.0.) then
!                  QSN_ALL = QSN_ALL + PFI_LS_dev(I,K)/VFALLSN
!               end if
!               if (VFALLRN.NE.0.) then
!                  QRN_ALL = QRN_ALL + PFL_LS_dev(I,K)/VFALLRN
!               end if
!               if (VFALLRN.NE.0. .AND. VFALLSN.NE.0.) then
!                  QPLS_dev(I,K) = QPLS_dev(I,K) + PFL_LS_dev(I,K)/VFALLRN + PFI_LS_dev(I,K)/VFALLSN
!               end if 
!            end if
        IF (qlw_ls_dev(i, k) + qlw_an_dev(i, k) .GT. 0.00) THEN
          qtmp3 = 1./(qlw_ls_dev(i, k)+qlw_an_dev(i, k))
        ELSE
          qtmp3 = 0.0
        END IF
        qlw_ls_dev(i, k) = qlw_ls_dev(i, k)*qtmp1*qtmp3
        qlw_an_dev(i, k) = qlw_an_dev(i, k)*qtmp1*qtmp3
        IF (qiw_ls_dev(i, k) + qiw_an_dev(i, k) .GT. 0.00) THEN
          qtmp3 = 1./(qiw_ls_dev(i, k)+qiw_an_dev(i, k))
        ELSE
          qtmp3 = 0.0
        END IF
        qiw_ls_dev(i, k) = qiw_ls_dev(i, k)*qtmp2*qtmp3
        qiw_an_dev(i, k) = qiw_an_dev(i, k)*qtmp2*qtmp3
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        th_dev(i, k) = temp/exnp_dev(i, k)
!            QRN_ALL = QRN_ALL / (100.*PP_dev(I,K) / (MAPL8_RGAS*TEMP ))
!            QSN_ALL = QSN_ALL / (100.*PP_dev(I,K) / (MAPL8_RGAS*TEMP ))
!            RHCLR_dev(I,K) = MIN( CLDFRC_dev(I,K) + ANVFRC_dev(I,K), 1.00 )
!            IF ( RHCLR_dev(I,K) < 1.00 ) THEN
!               RHCLR_dev(I,K) = ( MIN( Q_dev(I,K)/QSAT(TEMP,PP_dev(I,K)),1.0 ) - RHCLR_dev(I,K) ) / &
!                                     (1. - RHCLR_dev(I,K))
!               IF ( RHCLR_dev(I,K) < 0.00 ) THEN
!                  RHCLR_dev(I,K) = MAPL8_UNDEF
!               END IF
!            ELSE
!               RHCLR_dev(I,K) = MAPL8_UNDEF
!            END IF
!            IF (DISABLE_RAD==1) THEN
!               RAD_QL_dev(I,K)     = 0.
!               RAD_QI_dev(I,K)     = 0.
!               RAD_QR_dev(I,K)     = 0.
!               RAD_QS_dev(I,K)     = 0.
!               RAD_CLDFRC_dev(I,K) = 0.
!               CLDREFFL_dev(I,K)   = 0.
!               CLDREFFI_dev(I,K)   = 0.
!            ELSE
!               call RADCOUPLE ( TEMP, PP_dev(I,K), CLDFRC_dev(I,K), ANVFRC_dev(I,K), &
!                     QLW_LS_dev(I,K), QIW_LS_dev(I,K), QLW_AN_dev(I,K), QIW_AN_dev(I,K), QRN_ALL, QSN_ALL, & 
!                     RAD_QL_dev(I,K), RAD_QI_dev(I,K), RAD_QR_dev(I,K), RAD_QS_dev(I,K), RAD_CLDFRC_dev(I,K), & 
!                     CLDREFFL_dev(I,K), CLDREFFI_dev(I,K), CLDVOL2FRC,N_ANVIL*1.e6,N_ICE*1.e6,N_WARM*1.e6, &
!                     TEMPOR_dev(I))
!            END IF
        qrn_cu_dev(i, k) = qrn_cu_1d
      END DO k_loop
    END DO run_loop
  END SUBROUTINE PROGNO_CLOUD
!  Differentiation of pdf_spread in forward (tangent) mode (with options r8):
!   variations   of useful results: alpha
!   with respect to varying inputs: v_below u_above u v u_below
!                dz_above dz_below v_above
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!              P R O C E S S   S U B R O U T I N E S                 !!
!!                         * * * * *                                  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!              P R O C E S S   S U B R O U T I N E S                 !!
!!                         * * * * *                                  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!              P R O C E S S   S U B R O U T I N E S                 !!
!!                         * * * * *                                  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
!         ALPHT_DIAG, ALPH1_DIAG, ALPH2_DIAG,&
  SUBROUTINE PDF_SPREAD_TLM(k, lm, u, u_tl, u_above, u_above_tl, u_below&
&   , u_below_tl, v, v_tl, v_above, v_above_tl, v_below, v_below_tl, kh&
&   , dz_above, dz_above_tl, dz_below, dz_below_tl, updf, pp, alpha, &
&   alpha_tl, frland)
    IMPLICIT NONE
!      ALPHT_DIAG = ALPHA
    INTEGER, INTENT(IN) :: k, lm
    REAL*8, INTENT(IN) :: u, u_above, u_below
    REAL*8, INTENT(IN) :: u_tl, u_above_tl, u_below_tl
    REAL*8, INTENT(IN) :: v, v_above, v_below
    REAL*8, INTENT(IN) :: v_tl, v_above_tl, v_below_tl
    REAL*8, INTENT(IN) :: dz_above, dz_below
    REAL*8, INTENT(IN) :: dz_above_tl, dz_below_tl
    REAL*8, INTENT(IN) :: updf, pp
    REAL*8, INTENT(IN) :: kh
    REAL*8, INTENT(OUT) :: alpha
    REAL*8, INTENT(OUT) :: alpha_tl
!      real(8),    intent(out) :: ALPH1_DIAG, ALPH2_DIAG, ALPHT_DIAG
    REAL*8, INTENT(IN) :: frland
    REAL*8 :: a1, a2, a3
    REAL*8 :: a1_tl, a2_tl, a3_tl
    REAL*8 :: tempmaxrh
    INTRINSIC TAN
    INTRINSIC ATAN
    INTRINSIC MIN
    INTRINSIC SQRT
    INTRINSIC ABS
    REAL*8 :: arg1
    REAL*8 :: arg1_tl
    REAL*8 :: arg2
    REAL*8 :: result1
    REAL*8 :: result1_tl
! end of slingo ritter if-sequence
! alpha is the 1/2*width so RH_crit=1.0-alpha
    IF (tanhrhcrit .EQ. 1) THEN
!  Use Slingo-Ritter (1985) formulation for critical relative humidity
!  array a1 holds the critical rh, ranges from 0.8 to 1
      tempmaxrh = maxrhcrit
      IF (frland .GT. 0.05) tempmaxrh = maxrhcritland
      a1 = 1.0
      IF (pp .LE. turnrhcrit) THEN
        a1 = minrhcrit
      ELSE
        arg1 = 20.*pi_0/21. - 0.5*pi_0
        arg2 = (2.*(pp-turnrhcrit)/(1020.-turnrhcrit)-1.)*TAN(arg1)
        a1 = minrhcrit + (tempmaxrh-minrhcrit)/19.*((ATAN(arg2)+0.5*pi_0&
&         )*21./pi_0-1.)
      END IF
      IF (a1 .GT. 1.) THEN
        a1 = 1.
      ELSE
        a1 = a1
      END IF
      alpha = 1. - a1
      alpha_tl = 0.0_8
    ELSE
! 0.1% RH SLOP
      alpha = 0.001
!! DIRECTIONAL SHEAR == ABS( e_normal dot [U_z,V_z] ) 
      a1 = 0.
! inverse of wind mag 
      arg1_tl = 2*u*u_tl + 2*v*v_tl
      arg1 = u**2 + v**2 + 0.01
      IF (arg1 .EQ. 0.0_8) THEN
        result1_tl = 0.0_8
      ELSE
        result1_tl = arg1_tl/(2.0*SQRT(arg1))
      END IF
      result1 = SQRT(arg1)
      a3_tl = -(result1_tl/result1**2)
      a3 = 1./result1
! x-component of unit normal to (U,V) 
      a2_tl = v_tl*a3 + v*a3_tl
      a2 = v*a3
      IF (k .GT. 1 .AND. k .LT. lm) THEN
        a1_tl = ((a2_tl*(u_above-u_below)+a2*(u_above_tl-u_below_tl))*(&
&         dz_above+dz_below)-a2*(u_above-u_below)*(dz_above_tl+&
&         dz_below_tl))/(dz_above+dz_below)**2
        a1 = a2*(u_above-u_below)/(dz_above+dz_below)
      ELSE
        a1_tl = 0.0_8
      END IF
! y-component of unit normal to (U,V) 
      a2_tl = -(u_tl*a3+u*a3_tl)
      a2 = -(u*a3)
      IF (k .GT. 1 .AND. k .LT. lm) THEN
        a1_tl = ((a2_tl*(v_above-v_below)+a2*(v_above_tl-v_below_tl))*(&
&         dz_above+dz_below)-a2*(v_above-v_below)*(dz_above_tl+&
&         dz_below_tl))/(dz_above+dz_below)**2 + a1_tl
        a1 = a2*(v_above-v_below)/(dz_above+dz_below) + a1
      END IF
      IF (a1 .GE. 0.) THEN
        a1 = a1
      ELSE
        a1_tl = -a1_tl
        a1 = -a1
      END IF
      alpha_tl = 10.*a1_tl
      alpha = alpha + 10.*a1
!         ALPH1_DIAG = 10.*A1
!! Total shear = SQRT( [U_z,V_z] dot [U_z,V_z] )
      a1 = 0.
      IF (k .GT. 1 .AND. k .LT. lm) THEN
        a1_tl = 2*(u_above-u_below)*((u_above_tl-u_below_tl)*(dz_above+&
&         dz_below)-(u_above-u_below)*(dz_above_tl+dz_below_tl))/(&
&         dz_above+dz_below)**3 + 2*(v_above-v_below)*((v_above_tl-&
&         v_below_tl)*(dz_above+dz_below)-(v_above-v_below)*(dz_above_tl&
&         +dz_below_tl))/(dz_above+dz_below)**3
        a1 = ((u_above-u_below)/(dz_above+dz_below))**2 + ((v_above-&
&         v_below)/(dz_above+dz_below))**2
      ELSE
        a1_tl = 0.0_8
      END IF
! A1 is now magnitude of TOTAL shear at layers in (m/s) /m.  Thus, A1=.001  ==> 1 m/s/km
      IF (a1 .EQ. 0.0_8) THEN
        a1_tl = 0.0_8
      ELSE
        a1_tl = a1_tl/(2.0*SQRT(a1))
      END IF
      a1 = SQRT(a1)
      alpha_tl = alpha_tl + 3.33*a1_tl
      alpha = alpha + 3.33*a1
!! KH values ~100 m+2 s-1 typical of strong PBLs
      alpha = alpha + 0.002*kh
!         ALPH2_DIAG = 0.002*KH
    END IF
    IF (alpha .GT. 0.25) THEN
      alpha = 0.25
      alpha_tl = 0.0_8
    ELSE
      alpha = alpha
    END IF
  END SUBROUTINE PDF_SPREAD_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!              P R O C E S S   S U B R O U T I N E S                 !!
!!                         * * * * *                                  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!              P R O C E S S   S U B R O U T I N E S                 !!
!!                         * * * * *                                  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!              P R O C E S S   S U B R O U T I N E S                 !!
!!                         * * * * *                                  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
!         ALPHT_DIAG, ALPH1_DIAG, ALPH2_DIAG,&
  SUBROUTINE PDF_SPREAD(k, lm, u, u_above, u_below, v, v_above, v_below&
&   , kh, dz_above, dz_below, updf, pp, alpha, frland)
    IMPLICIT NONE
!      ALPHT_DIAG = ALPHA
    INTEGER, INTENT(IN) :: k, lm
    REAL*8, INTENT(IN) :: u, u_above, u_below
    REAL*8, INTENT(IN) :: v, v_above, v_below
    REAL*8, INTENT(IN) :: dz_above, dz_below
    REAL*8, INTENT(IN) :: updf, pp
    REAL*8, INTENT(IN) :: kh
    REAL*8, INTENT(OUT) :: alpha
!      real(8),    intent(out) :: ALPH1_DIAG, ALPH2_DIAG, ALPHT_DIAG
    REAL*8, INTENT(IN) :: frland
    REAL*8 :: a1, a2, a3
    REAL*8 :: tempmaxrh
    INTRINSIC TAN
    INTRINSIC ATAN
    INTRINSIC MIN
    INTRINSIC SQRT
    INTRINSIC ABS
    REAL*8 :: arg1
    REAL*8 :: arg2
    REAL*8 :: result1
! end of slingo ritter if-sequence
! alpha is the 1/2*width so RH_crit=1.0-alpha
    IF (tanhrhcrit .EQ. 1) THEN
!  Use Slingo-Ritter (1985) formulation for critical relative humidity
!  array a1 holds the critical rh, ranges from 0.8 to 1
      tempmaxrh = maxrhcrit
      IF (frland .GT. 0.05) tempmaxrh = maxrhcritland
      a1 = 1.0
      IF (pp .LE. turnrhcrit) THEN
        a1 = minrhcrit
      ELSE
        arg1 = 20.*pi_0/21. - 0.5*pi_0
        arg2 = (2.*(pp-turnrhcrit)/(1020.-turnrhcrit)-1.)*TAN(arg1)
        a1 = minrhcrit + (tempmaxrh-minrhcrit)/19.*((ATAN(arg2)+0.5*pi_0&
&         )*21./pi_0-1.)
      END IF
      IF (a1 .GT. 1.) THEN
        a1 = 1.
      ELSE
        a1 = a1
      END IF
      alpha = 1. - a1
    ELSE
! 0.1% RH SLOP
      alpha = 0.001
!! DIRECTIONAL SHEAR == ABS( e_normal dot [U_z,V_z] ) 
      a1 = 0.
! inverse of wind mag 
      arg1 = u**2 + v**2 + 0.01
      result1 = SQRT(arg1)
      a3 = 1./result1
! x-component of unit normal to (U,V) 
      a2 = v*a3
      IF (k .GT. 1 .AND. k .LT. lm) a1 = a2*(u_above-u_below)/(dz_above+&
&         dz_below)
! y-component of unit normal to (U,V) 
      a2 = -(u*a3)
      IF (k .GT. 1 .AND. k .LT. lm) a1 = a2*(v_above-v_below)/(dz_above+&
&         dz_below) + a1
      IF (a1 .GE. 0.) THEN
        a1 = a1
      ELSE
        a1 = -a1
      END IF
      alpha = alpha + 10.*a1
!         ALPH1_DIAG = 10.*A1
!! Total shear = SQRT( [U_z,V_z] dot [U_z,V_z] )
      a1 = 0.
      IF (k .GT. 1 .AND. k .LT. lm) a1 = ((u_above-u_below)/(dz_above+&
&         dz_below))**2 + ((v_above-v_below)/(dz_above+dz_below))**2
! A1 is now magnitude of TOTAL shear at layers in (m/s) /m.  Thus, A1=.001  ==> 1 m/s/km
      a1 = SQRT(a1)
      alpha = alpha + 3.33*a1
!! KH values ~100 m+2 s-1 typical of strong PBLs
      alpha = alpha + 0.002*kh
!         ALPH2_DIAG = 0.002*KH
    END IF
    IF (alpha .GT. 0.25) THEN
      alpha = 0.25
    ELSE
      alpha = alpha
    END IF
  END SUBROUTINE PDF_SPREAD
!  Differentiation of fix_up_clouds in forward (tangent) mode (with options r8):
!   variations   of useful results: af qv qla qlc qia qic cf te
!   with respect to varying inputs: af qv qla qlc qia qic cf te
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE FIX_UP_CLOUDS_TLM(qv, qv_tl, te, te_tl, qlc, qlc_tl, qic, &
&   qic_tl, cf, cf_tl, qla, qla_tl, qia, qia_tl, af, af_tl)
    IMPLICIT NONE
    REAL*8, INTENT(INOUT) :: te, qv, qlc, cf, qla, af, qic, qia
    REAL*8, INTENT(INOUT) :: te_tl, qv_tl, qlc_tl, cf_tl, qla_tl, af_tl&
&   , qic_tl, qia_tl
! Fix if Anvil cloud fraction too small
    IF (af .LT. 1.e-5) THEN
      qv_tl = qv_tl + qla_tl + qia_tl
      qv = qv + qla + qia
      te_tl = te_tl - mapl8_alhl*qla_tl/mapl8_cp - mapl8_alhs*qia_tl/&
&       mapl8_cp
      te = te - mapl8_alhl/mapl8_cp*qla - mapl8_alhs/mapl8_cp*qia
      af = 0.
      qla = 0.
      qia = 0.
      af_tl = 0.0_8
      qla_tl = 0.0_8
      qia_tl = 0.0_8
    END IF
! Fix if LS cloud fraction too small
    IF (cf .LT. 1.e-5) THEN
      qv_tl = qv_tl + qlc_tl + qic_tl
      qv = qv + qlc + qic
      te_tl = te_tl - mapl8_alhl*qlc_tl/mapl8_cp - mapl8_alhs*qic_tl/&
&       mapl8_cp
      te = te - mapl8_alhl/mapl8_cp*qlc - mapl8_alhs/mapl8_cp*qic
      cf = 0.
      qlc = 0.
      qic = 0.
      qlc_tl = 0.0_8
      qic_tl = 0.0_8
      cf_tl = 0.0_8
    END IF
! LS LIQUID too small
    IF (qlc .LT. 1.e-8) THEN
      qv_tl = qv_tl + qlc_tl
      qv = qv + qlc
      te_tl = te_tl - mapl8_alhl*qlc_tl/mapl8_cp
      te = te - mapl8_alhl/mapl8_cp*qlc
      qlc = 0.
      qlc_tl = 0.0_8
    END IF
! LS ICE too small
    IF (qic .LT. 1.e-8) THEN
      qv_tl = qv_tl + qic_tl
      qv = qv + qic
      te_tl = te_tl - mapl8_alhs*qic_tl/mapl8_cp
      te = te - mapl8_alhs/mapl8_cp*qic
      qic = 0.
      qic_tl = 0.0_8
    END IF
! Anvil LIQUID too small
    IF (qla .LT. 1.e-8) THEN
      qv_tl = qv_tl + qla_tl
      qv = qv + qla
      te_tl = te_tl - mapl8_alhl*qla_tl/mapl8_cp
      te = te - mapl8_alhl/mapl8_cp*qla
      qla = 0.
      qla_tl = 0.0_8
    END IF
! Anvil ICE too small
    IF (qia .LT. 1.e-8) THEN
      qv_tl = qv_tl + qia_tl
      qv = qv + qia
      te_tl = te_tl - mapl8_alhs*qia_tl/mapl8_cp
      te = te - mapl8_alhs/mapl8_cp*qia
      qia = 0.
      qia_tl = 0.0_8
    END IF
! Fix ALL cloud quants if Anvil cloud LIQUID+ICE too small
    IF (qla + qia .LT. 1.e-8) THEN
      qv_tl = qv_tl + qla_tl + qia_tl
      qv = qv + qla + qia
      te_tl = te_tl - mapl8_alhl*qla_tl/mapl8_cp - mapl8_alhs*qia_tl/&
&       mapl8_cp
      te = te - mapl8_alhl/mapl8_cp*qla - mapl8_alhs/mapl8_cp*qia
      af = 0.
      qla = 0.
      qia = 0.
      af_tl = 0.0_8
      qla_tl = 0.0_8
      qia_tl = 0.0_8
    END IF
! Ditto if LS cloud LIQUID+ICE too small
    IF (qlc + qic .LT. 1.e-8) THEN
      qv_tl = qv_tl + qlc_tl + qic_tl
      qv = qv + qlc + qic
      te_tl = te_tl - mapl8_alhl*qlc_tl/mapl8_cp - mapl8_alhs*qic_tl/&
&       mapl8_cp
      te = te - mapl8_alhl/mapl8_cp*qlc - mapl8_alhs/mapl8_cp*qic
      cf = 0.
      qlc = 0.
      qic = 0.
      qlc_tl = 0.0_8
      qic_tl = 0.0_8
      cf_tl = 0.0_8
    END IF
  END SUBROUTINE FIX_UP_CLOUDS_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE FIX_UP_CLOUDS(qv, te, qlc, qic, cf, qla, qia, af)
    IMPLICIT NONE
    REAL*8, INTENT(INOUT) :: te, qv, qlc, cf, qla, af, qic, qia
! Fix if Anvil cloud fraction too small
    IF (af .LT. 1.e-5) THEN
      qv = qv + qla + qia
      te = te - mapl8_alhl/mapl8_cp*qla - mapl8_alhs/mapl8_cp*qia
      af = 0.
      qla = 0.
      qia = 0.
    END IF
! Fix if LS cloud fraction too small
    IF (cf .LT. 1.e-5) THEN
      qv = qv + qlc + qic
      te = te - mapl8_alhl/mapl8_cp*qlc - mapl8_alhs/mapl8_cp*qic
      cf = 0.
      qlc = 0.
      qic = 0.
    END IF
! LS LIQUID too small
    IF (qlc .LT. 1.e-8) THEN
      qv = qv + qlc
      te = te - mapl8_alhl/mapl8_cp*qlc
      qlc = 0.
    END IF
! LS ICE too small
    IF (qic .LT. 1.e-8) THEN
      qv = qv + qic
      te = te - mapl8_alhs/mapl8_cp*qic
      qic = 0.
    END IF
! Anvil LIQUID too small
    IF (qla .LT. 1.e-8) THEN
      qv = qv + qla
      te = te - mapl8_alhl/mapl8_cp*qla
      qla = 0.
    END IF
! Anvil ICE too small
    IF (qia .LT. 1.e-8) THEN
      qv = qv + qia
      te = te - mapl8_alhs/mapl8_cp*qia
      qia = 0.
    END IF
! Fix ALL cloud quants if Anvil cloud LIQUID+ICE too small
    IF (qla + qia .LT. 1.e-8) THEN
      qv = qv + qla + qia
      te = te - mapl8_alhl/mapl8_cp*qla - mapl8_alhs/mapl8_cp*qia
      af = 0.
      qla = 0.
      qia = 0.
    END IF
! Ditto if LS cloud LIQUID+ICE too small
    IF (qlc + qic .LT. 1.e-8) THEN
      qv = qv + qlc + qic
      te = te - mapl8_alhl/mapl8_cp*qlc - mapl8_alhs/mapl8_cp*qic
      cf = 0.
      qlc = 0.
      qic = 0.
    END IF
  END SUBROUTINE FIX_UP_CLOUDS
!  Differentiation of meltfrz in forward (tangent) mode (with options r8):
!   variations   of useful results: qi ql te
!   with respect to varying inputs: qi ql te
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE MELTFRZ_TLM(dt, te, te_tl, ql, ql_tl, qi, qi_tl)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: dt
    REAL*8, INTENT(INOUT) :: te, ql, qi
    REAL*8, INTENT(INOUT) :: te_tl, ql_tl, qi_tl
    REAL*8 :: fqi, dqil
    REAL*8 :: fqi_tl, dqil_tl
    REAL*8 :: taufrz
    INTEGER :: k
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    REAL*8 :: arg1
    REAL*8 :: arg1_tl
    taufrz = 1000.
    fqi_tl = ICE_FRACTION_TLM(te, te_tl, fqi)
    dqil = 0.
! freeze liquid
    IF (te .LE. t_ice_max) THEN
      arg1_tl = -(dt*fqi_tl/taufrz)
      arg1 = -(dt*fqi/taufrz)
      dqil_tl = ql_tl*(1.0-EXP(arg1)) - ql*arg1_tl*EXP(arg1)
      dqil = ql*(1.0-EXP(arg1))
    ELSE
      dqil_tl = 0.0_8
    END IF
    IF (0. .LT. dqil) THEN
      dqil = dqil
    ELSE
      dqil = 0.
      dqil_tl = 0.0_8
    END IF
    qi_tl = qi_tl + dqil_tl
    qi = qi + dqil
    ql_tl = ql_tl - dqil_tl
    ql = ql - dqil
    te_tl = te_tl + (mapl8_alhs-mapl8_alhl)*dqil_tl/mapl8_cp
    te = te + (mapl8_alhs-mapl8_alhl)*dqil/mapl8_cp
    dqil = 0.
! melt ice instantly above 0^C
    IF (te .GT. t_ice_max) THEN
      dqil_tl = -qi_tl
      dqil = -qi
    ELSE
      dqil_tl = 0.0_8
    END IF
    IF (0. .GT. dqil) THEN
      dqil = dqil
    ELSE
      dqil = 0.
      dqil_tl = 0.0_8
    END IF
    qi_tl = qi_tl + dqil_tl
    qi = qi + dqil
    ql_tl = ql_tl - dqil_tl
    ql = ql - dqil
    te_tl = te_tl + (mapl8_alhs-mapl8_alhl)*dqil_tl/mapl8_cp
    te = te + (mapl8_alhs-mapl8_alhl)*dqil/mapl8_cp
  END SUBROUTINE MELTFRZ_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE MELTFRZ(dt, te, ql, qi)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: dt
    REAL*8, INTENT(INOUT) :: te, ql, qi
    REAL*8 :: fqi, dqil
    REAL*8 :: taufrz
    INTEGER :: k
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    REAL*8 :: arg1
    taufrz = 1000.
    fqi = ICE_FRACTION(te)
    dqil = 0.
! freeze liquid
    IF (te .LE. t_ice_max) THEN
      arg1 = -(dt*fqi/taufrz)
      dqil = ql*(1.0-EXP(arg1))
    END IF
    IF (0. .LT. dqil) THEN
      dqil = dqil
    ELSE
      dqil = 0.
    END IF
    qi = qi + dqil
    ql = ql - dqil
    te = te + (mapl8_alhs-mapl8_alhl)*dqil/mapl8_cp
    dqil = 0.
! melt ice instantly above 0^C
    IF (te .GT. t_ice_max) dqil = -qi
    IF (0. .GT. dqil) THEN
      dqil = dqil
    ELSE
      dqil = 0.
    END IF
    qi = qi + dqil
    ql = ql - dqil
    te = te + (mapl8_alhs-mapl8_alhl)*dqil/mapl8_cp
  END SUBROUTINE MELTFRZ
!  Differentiation of hystpdf in forward (tangent) mode (with options r8):
!   variations   of useful results: qai qal af qv qci qcl cf te
!   with respect to varying inputs: qai qal af alpha qv qci qcl
!                cf te
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE HYSTPDF_TLM(dt, alpha, alpha_tl, pdfshape, pl, qv, qv_tl, &
&   qcl, qcl_tl, qal, qal_tl, qci, qci_tl, qai, qai_tl, te, te_tl, cf, &
&   cf_tl, af, af_tl)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: dt, alpha, pl
    REAL*8, INTENT(IN) :: alpha_tl
    INTEGER, INTENT(IN) :: pdfshape
    REAL*8, INTENT(INOUT) :: te, qv, qcl, qci, cf, qal, qai, af
    REAL*8, INTENT(INOUT) :: te_tl, qv_tl, qcl_tl, qci_tl, cf_tl, qal_tl&
&   , qai_tl, af_tl
! internal arrays
    REAL*8 :: qco, qvo, cfo, qao, tau
    REAL*8 :: qco_tl, cfo_tl, qao_tl
    REAL*8 :: qt, qmx, qmn, dq, qvtop, sigmaqt1, sigmaqt2
    REAL*8 :: qt_tl, sigmaqt1_tl, sigmaqt2_tl
    REAL*8 :: teo, qsx, dqsx, qs, dqs
    REAL*8 :: teo_tl, qsx_tl, dqsx_tl, dqs_tl
    REAL*8 :: tep, qsp, cfp, qvp, qcp
    REAL*8 :: tep_tl, qcp_tl
    REAL*8 :: ten, qsn, cfn, qvn, qcn
    REAL*8 :: ten_tl, qsn_tl, cfn_tl, qcn_tl
    REAL*8 :: qcx, qvx, cfx, qax, qc, qa, fqi, fqi_a
    REAL*8 :: qcx_tl, qvx_tl, cfx_tl, qax_tl, qc_tl, qa_tl, fqi_tl
    REAL*8 :: dqai, dqal, dqci, dqcl
    REAL*8 :: dqai_tl, dqal_tl, dqci_tl, dqcl_tl
    REAL*8 :: tmparr
    REAL*8 :: tmparr_tl
    REAL*8 :: alhx
    REAL*8 :: alhx_tl
! internal scalars
    INTEGER :: n
    INTRINSIC MAX
    qc_tl = qcl_tl + qci_tl
    qc = qcl + qci
    qa_tl = qal_tl + qai_tl
    qa = qal + qai
    IF (qa .GT. 0.0) THEN
      fqi_a = qai/qa
    ELSE
      fqi_a = 0.0
    END IF
    teo_tl = te_tl
    teo = te
    CALL DQSATSCAPERT_TLM(dqsx, dqsx_tl, qsx, qsx_tl, teo, teo_tl, pl)
    IF (af .LT. 1.0) THEN
      tmparr_tl = -((-af_tl)/(1.-af)**2)
      tmparr = 1./(1.-af)
    ELSE
      tmparr = 0.0
      tmparr_tl = 0.0_8
    END IF
    cfx_tl = cf_tl*tmparr + cf*tmparr_tl
    cfx = cf*tmparr
    qcx_tl = qc_tl*tmparr + qc*tmparr_tl
    qcx = qc*tmparr
    qvx_tl = (qv_tl-qsx_tl*af-qsx*af_tl)*tmparr + (qv-qsx*af)*tmparr_tl
    qvx = (qv-qsx*af)*tmparr
    IF (af .GE. 1.0) THEN
      qvx_tl = 1.e-4*qsx_tl
      qvx = qsx*1.e-4
    END IF
    IF (af .GT. 0.) THEN
      qax_tl = (qa_tl*af-qa*af_tl)/af**2
      qax = qa/af
    ELSE
      qax = 0.
      qax_tl = 0.0_8
    END IF
    qt_tl = qcx_tl + qvx_tl
    qt = qcx + qvx
    tep = teo
    qsn = qsx
    ten_tl = teo_tl
    ten = teo
    cfn_tl = cfx_tl
    cfn = cfx
    qvn = qvx
    qcn_tl = qcx_tl
    qcn = qcx
    dqs = dqsx
    qao_tl = 0.0_8
    fqi_tl = 0.0_8
    DO n=1,4
      qsp = qsn
      qvp = qvn
      qcp_tl = qcn_tl
      qcp = qcn
      cfp = cfn
      CALL DQSATSCAPERT_TLM(dqs, dqs_tl, qsn, qsn_tl, ten, ten_tl, pl)
      tep_tl = ten_tl
      tep = ten
      fqi_tl = ICE_FRACTION_TLM(tep, tep_tl, fqi)
      sigmaqt1_tl = alpha_tl*qsn + alpha*qsn_tl
      sigmaqt1 = alpha*qsn
      sigmaqt2_tl = alpha_tl*qsn + alpha*qsn_tl
      sigmaqt2 = alpha*qsn
      IF (pdfflag .EQ. 2) THEN
! for triangular, symmetric: sigmaqt1 = sigmaqt2 = alpha*qsn (alpha is half width)
! for triangular, skewed r : sigmaqt1 < sigmaqt2
! try: skewed right below 500 mb
!!!       if(pl.lt.500.) then
        sigmaqt1_tl = alpha_tl*qsn + alpha*qsn_tl
        sigmaqt1 = alpha*qsn
        sigmaqt2_tl = alpha_tl*qsn + alpha*qsn_tl
        sigmaqt2 = alpha*qsn
!!!       else
!!!       sigmaqt1  = 2*ALPHA*QSn*0.4
!!!       sigmaqt2  = 2*ALPHA*QSn*0.6
!!!       endif
      END IF
      CALL PDFFRAC_TLM(pdfshape, qt, qt_tl, sigmaqt1, sigmaqt1_tl, &
&                sigmaqt2, sigmaqt2_tl, qsn, qsn_tl, cfn, cfn_tl)
      CALL PDFCONDENSATE_TLM(pdfshape, qt, qt_tl, sigmaqt1, sigmaqt1_tl&
&                      , sigmaqt2, sigmaqt2_tl, qsn, qsn_tl, qcn, qcn_tl&
&                     )
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! These lines represent adjustments
! to anvil condensate due to the 
! assumption of a stationary TOTAL 
! water PDF subject to a varying 
! QSAT value during the iteration
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
      IF (af .GT. 0.) THEN
! + QSx - QS 
        qao_tl = qax_tl
        qao = qax
      ELSE
        qao = 0.
        qao_tl = 0.0_8
      END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      alhx_tl = mapl8_alhs*fqi_tl - mapl8_alhl*fqi_tl
      alhx = (1.0-fqi)*mapl8_alhl + fqi*mapl8_alhs
      IF (pdfflag .EQ. 1) THEN
        qcn_tl = qcp_tl + ((qcn_tl-qcp_tl)*(1.-(cfn*(alpha-1.)-qcn/qsn)*&
&         dqs*alhx/mapl8_cp)+(qcn-qcp)*((cfn_tl*(alpha-1.)+cfn*alpha_tl-&
&         (qcn_tl*qsn-qcn*qsn_tl)/qsn**2)*dqs*alhx+(cfn*(alpha-1.)-qcn/&
&         qsn)*(dqs_tl*alhx+dqs*alhx_tl))/mapl8_cp)/(1.-(cfn*(alpha-1.)-&
&         qcn/qsn)*dqs*alhx/mapl8_cp)**2
        qcn = qcp + (qcn-qcp)/(1.-(cfn*(alpha-1.)-qcn/qsn)*dqs*alhx/&
&         mapl8_cp)
      ELSE IF (pdfflag .EQ. 2) THEN
! This next line needs correcting - need proper d(del qc)/dT derivative for triangular
! for now, just use relaxation of 1/2.
        IF (n .NE. 4) THEN
          qcn_tl = qcp_tl + 0.5*(qcn_tl-qcp_tl)
          qcn = qcp + (qcn-qcp)*0.5
        END IF
      END IF
      qvn = qvp - (qcn-qcp)
      ten_tl = tep_tl + mapl8_alhl*((1.0-fqi)*((qcn_tl-qcp_tl)*(1.-af)-(&
&       qcn-qcp)*af_tl+(qao_tl-qax_tl)*af+(qao-qax)*af_tl)-fqi_tl*((qcn-&
&       qcp)*(1.-af)+(qao-qax)*af))/mapl8_cp + mapl8_alhs*(fqi_tl*((qcn-&
&       qcp)*(1.-af)+(qao-qax)*af)+fqi*((qcn_tl-qcp_tl)*(1.-af)-(qcn-qcp&
&       )*af_tl+(qao_tl-qax_tl)*af+(qao-qax)*af_tl))/mapl8_cp
      ten = tep + (1.0-fqi)*(mapl8_alhl/mapl8_cp)*((qcn-qcp)*(1.-af)+(&
&       qao-qax)*af) + fqi*(mapl8_alhs/mapl8_cp)*((qcn-qcp)*(1.-af)+(qao&
&       -qax)*af)
    END DO
! qsat iteration
    cfo_tl = cfn_tl
    cfo = cfn
    cf = cfn
    qco_tl = qcn_tl
    qco = qcn
    qvo = qvn
    teo = ten
! Update prognostic variables.  Deal with special case of AF=1
! Temporary variables QCo, QAo become updated grid means.
    IF (af .LT. 1.0) THEN
      cf_tl = cfo_tl*(1.-af) - cfo*af_tl
      cf = cfo*(1.-af)
      qco_tl = qco_tl*(1.-af) - qco*af_tl
      qco = qco*(1.-af)
      qao_tl = qao_tl*af + qao*af_tl
      qao = qao*af
    ELSE
! Special case AF=1, i.e., box filled with anvil. 
!   - Note: no guarantee QV_box > QS_box
! Remove any other cloud
      cf = 0.
! Add any LS condensate to anvil type
      qao_tl = qa_tl + qc_tl
      qao = qa + qc
! Remove same from LS   
      qco = 0.
! Total water
      qt_tl = qao_tl + qv_tl
      qt = qao + qv
      IF (qt - qsx .LT. 0.) THEN
        qao = 0.
        cf_tl = 0.0_8
        qao_tl = 0.0_8
        qco_tl = 0.0_8
      ELSE
        qao_tl = qt_tl - qsx_tl
        qao = qt - qsx
        cf_tl = 0.0_8
        qco_tl = 0.0_8
      END IF
    END IF
! Now take {\em New} condensate and partition into ice and liquid
! taking care to keep both >=0 separately. New condensate can be
! less than old, so $\Delta$ can be < 0.
    qcx_tl = qco_tl - qc_tl
    qcx = qco - qc
    dqcl_tl = (1.0-fqi)*qcx_tl - fqi_tl*qcx
    dqcl = (1.0-fqi)*qcx
    dqci_tl = fqi_tl*qcx + fqi*qcx_tl
    dqci = fqi*qcx
    IF (qcl + dqcl .LT. 0.) THEN
      dqci_tl = dqci_tl + qcl_tl + dqcl_tl
      dqci = dqci + (qcl+dqcl)
!== dQCl - (QCl+dQCl)
      dqcl_tl = -qcl_tl
      dqcl = -qcl
    END IF
    IF (qci + dqci .LT. 0.) THEN
      dqcl_tl = dqcl_tl + qci_tl + dqci_tl
      dqcl = dqcl + (qci+dqci)
!== dQCi - (QCi+dQCi)
      dqci_tl = -qci_tl
      dqci = -qci
    END IF
    qax_tl = qao_tl - qa_tl
    qax = qao - qa
! (1.0-fQi)*QAx
    dqal_tl = qax_tl
    dqal = qax
!  fQi  * QAx
    dqai = 0.
    IF (qal + dqal .LT. 0.) THEN
      dqai_tl = qal_tl + dqal_tl
      dqai = dqai + (qal+dqal)
      dqal_tl = -qal_tl
      dqal = -qal
    ELSE
      dqai_tl = 0.0_8
    END IF
    IF (qai + dqai .LT. 0.) THEN
      dqal_tl = dqal_tl + qai_tl + dqai_tl
      dqal = dqal + (qai+dqai)
      dqai_tl = -qai_tl
      dqai = -qai
    END IF
! Clean-up cloud if fractions are too small
    IF (af .LT. 1.e-5) THEN
      dqai_tl = -qai_tl
      dqai = -qai
      dqal_tl = -qal_tl
      dqal = -qal
    END IF
    IF (cf .LT. 1.e-5) THEN
      dqci_tl = -qci_tl
      dqci = -qci
      dqcl_tl = -qcl_tl
      dqcl = -qcl
    END IF
    qai_tl = qai_tl + dqai_tl
    qai = qai + dqai
    qal_tl = qal_tl + dqal_tl
    qal = qal + dqal
    qci_tl = qci_tl + dqci_tl
    qci = qci + dqci
    qcl_tl = qcl_tl + dqcl_tl
    qcl = qcl + dqcl
    qv_tl = qv_tl - dqai_tl - dqci_tl - dqal_tl - dqcl_tl
    qv = qv - (dqai+dqci+dqal+dqcl)
!!TE  = TE + (MAPL8_ALHS/MAPL8_CP)*(dQAi+dQCi) + (MAPL8_ALHL/MAPL8_CP)*(dQAl+dQCl)
    te_tl = te_tl + (mapl8_alhl*(dqai_tl+dqci_tl+dqal_tl+dqcl_tl)+&
&     mapl8_alhf*(dqai_tl+dqci_tl))/mapl8_cp
    te = te + (mapl8_alhl*(dqai+dqci+dqal+dqcl)+mapl8_alhf*(dqai+dqci))/&
&     mapl8_cp
! We need to take care of situations where QS moves past QA
! during QSAT iteration. This should be only when QA/AF is small
! to begin with. Effect is to make QAo negative. So, we 
! "evaporate" offending QAs
!
! We get rid of anvil fraction also, although strictly
! speaking, PDF-wise, we should not do this.
    IF (qao .LE. 0.) THEN
      qv_tl = qv_tl + qai_tl + qal_tl
      qv = qv + qai + qal
      te_tl = te_tl - mapl8_alhs*qai_tl/mapl8_cp - mapl8_alhl*qal_tl/&
&       mapl8_cp
      te = te - mapl8_alhs/mapl8_cp*qai - mapl8_alhl/mapl8_cp*qal
      qai = 0.
      qal = 0.
      af = 0.
      qai_tl = 0.0_8
      qal_tl = 0.0_8
      af_tl = 0.0_8
    END IF
  END SUBROUTINE HYSTPDF_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE HYSTPDF(dt, alpha, pdfshape, pl, qv, qcl, qal, qci, qai, te&
&   , cf, af)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: dt, alpha, pl
    INTEGER, INTENT(IN) :: pdfshape
    REAL*8, INTENT(INOUT) :: te, qv, qcl, qci, cf, qal, qai, af
! internal arrays
    REAL*8 :: qco, qvo, cfo, qao, tau
    REAL*8 :: qt, qmx, qmn, dq, qvtop, sigmaqt1, sigmaqt2
    REAL*8 :: teo, qsx, dqsx, qs, dqs
    REAL*8 :: tep, qsp, cfp, qvp, qcp
    REAL*8 :: ten, qsn, cfn, qvn, qcn
    REAL*8 :: qcx, qvx, cfx, qax, qc, qa, fqi, fqi_a
    REAL*8 :: dqai, dqal, dqci, dqcl
    REAL*8 :: tmparr
    REAL*8 :: alhx
! internal scalars
    INTEGER :: n
    INTRINSIC MAX
    qc = qcl + qci
    qa = qal + qai
    IF (qa .GT. 0.0) THEN
      fqi_a = qai/qa
    ELSE
      fqi_a = 0.0
    END IF
    teo = te
    CALL DQSATSCAPERT(dqsx, qsx, teo, pl)
    IF (af .LT. 1.0) THEN
      tmparr = 1./(1.-af)
    ELSE
      tmparr = 0.0
    END IF
    cfx = cf*tmparr
    qcx = qc*tmparr
    qvx = (qv-qsx*af)*tmparr
    IF (af .GE. 1.0) qvx = qsx*1.e-4
    IF (af .GT. 0.) THEN
      qax = qa/af
    ELSE
      qax = 0.
    END IF
    qt = qcx + qvx
    tep = teo
    qsn = qsx
    ten = teo
    cfn = cfx
    qvn = qvx
    qcn = qcx
    dqs = dqsx
    DO n=1,4
      qsp = qsn
      qvp = qvn
      qcp = qcn
      cfp = cfn
      CALL DQSATSCAPERT(dqs, qsn, ten, pl)
      tep = ten
      fqi = ICE_FRACTION(tep)
      sigmaqt1 = alpha*qsn
      sigmaqt2 = alpha*qsn
      IF (pdfflag .EQ. 2) THEN
! for triangular, symmetric: sigmaqt1 = sigmaqt2 = alpha*qsn (alpha is half width)
! for triangular, skewed r : sigmaqt1 < sigmaqt2
! try: skewed right below 500 mb
!!!       if(pl.lt.500.) then
        sigmaqt1 = alpha*qsn
        sigmaqt2 = alpha*qsn
!!!       else
!!!       sigmaqt1  = 2*ALPHA*QSn*0.4
!!!       sigmaqt2  = 2*ALPHA*QSn*0.6
!!!       endif
      END IF
      CALL PDFFRAC(pdfshape, qt, sigmaqt1, sigmaqt2, qsn, cfn)
      CALL PDFCONDENSATE(pdfshape, qt, sigmaqt1, sigmaqt2, qsn, qcn)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! These lines represent adjustments
! to anvil condensate due to the 
! assumption of a stationary TOTAL 
! water PDF subject to a varying 
! QSAT value during the iteration
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
      IF (af .GT. 0.) THEN
! + QSx - QS 
        qao = qax
      ELSE
        qao = 0.
      END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      alhx = (1.0-fqi)*mapl8_alhl + fqi*mapl8_alhs
      IF (pdfflag .EQ. 1) THEN
        qcn = qcp + (qcn-qcp)/(1.-(cfn*(alpha-1.)-qcn/qsn)*dqs*alhx/&
&         mapl8_cp)
      ELSE IF (pdfflag .EQ. 2) THEN
! This next line needs correcting - need proper d(del qc)/dT derivative for triangular
! for now, just use relaxation of 1/2.
        IF (n .NE. 4) qcn = qcp + (qcn-qcp)*0.5
      END IF
      qvn = qvp - (qcn-qcp)
      ten = tep + (1.0-fqi)*(mapl8_alhl/mapl8_cp)*((qcn-qcp)*(1.-af)+(&
&       qao-qax)*af) + fqi*(mapl8_alhs/mapl8_cp)*((qcn-qcp)*(1.-af)+(qao&
&       -qax)*af)
    END DO
! qsat iteration
    cfo = cfn
    cf = cfn
    qco = qcn
    qvo = qvn
    teo = ten
! Update prognostic variables.  Deal with special case of AF=1
! Temporary variables QCo, QAo become updated grid means.
    IF (af .LT. 1.0) THEN
      cf = cfo*(1.-af)
      qco = qco*(1.-af)
      qao = qao*af
    ELSE
! Special case AF=1, i.e., box filled with anvil. 
!   - Note: no guarantee QV_box > QS_box
! Remove any other cloud
      cf = 0.
! Add any LS condensate to anvil type
      qao = qa + qc
! Remove same from LS   
      qco = 0.
! Total water
      qt = qao + qv
      IF (qt - qsx .LT. 0.) THEN
        qao = 0.
      ELSE
        qao = qt - qsx
      END IF
    END IF
! Now take {\em New} condensate and partition into ice and liquid
! taking care to keep both >=0 separately. New condensate can be
! less than old, so $\Delta$ can be < 0.
    qcx = qco - qc
    dqcl = (1.0-fqi)*qcx
    dqci = fqi*qcx
    IF (qcl + dqcl .LT. 0.) THEN
      dqci = dqci + (qcl+dqcl)
!== dQCl - (QCl+dQCl)
      dqcl = -qcl
    END IF
    IF (qci + dqci .LT. 0.) THEN
      dqcl = dqcl + (qci+dqci)
!== dQCi - (QCi+dQCi)
      dqci = -qci
    END IF
    qax = qao - qa
! (1.0-fQi)*QAx
    dqal = qax
!  fQi  * QAx
    dqai = 0.
    IF (qal + dqal .LT. 0.) THEN
      dqai = dqai + (qal+dqal)
      dqal = -qal
    END IF
    IF (qai + dqai .LT. 0.) THEN
      dqal = dqal + (qai+dqai)
      dqai = -qai
    END IF
! Clean-up cloud if fractions are too small
    IF (af .LT. 1.e-5) THEN
      dqai = -qai
      dqal = -qal
    END IF
    IF (cf .LT. 1.e-5) THEN
      dqci = -qci
      dqcl = -qcl
    END IF
    qai = qai + dqai
    qal = qal + dqal
    qci = qci + dqci
    qcl = qcl + dqcl
    qv = qv - (dqai+dqci+dqal+dqcl)
!!TE  = TE + (MAPL8_ALHS/MAPL8_CP)*(dQAi+dQCi) + (MAPL8_ALHL/MAPL8_CP)*(dQAl+dQCl)
    te = te + (mapl8_alhl*(dqai+dqci+dqal+dqcl)+mapl8_alhf*(dqai+dqci))/&
&     mapl8_cp
! We need to take care of situations where QS moves past QA
! during QSAT iteration. This should be only when QA/AF is small
! to begin with. Effect is to make QAo negative. So, we 
! "evaporate" offending QAs
!
! We get rid of anvil fraction also, although strictly
! speaking, PDF-wise, we should not do this.
    IF (qao .LE. 0.) THEN
      qv = qv + qai + qal
      te = te - mapl8_alhs/mapl8_cp*qai - mapl8_alhl/mapl8_cp*qal
      qai = 0.
      qal = 0.
      af = 0.
    END IF
  END SUBROUTINE HYSTPDF
!  Differentiation of pdffrac in forward (tangent) mode (with options r8):
!   variations   of useful results: clfrac
!   with respect to varying inputs: qtmean sigmaqt1 sigmaqt2 qstar
!                clfrac
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE PDFFRAC_TLM(flag, qtmean, qtmean_tl, sigmaqt1, sigmaqt1_tl&
&   , sigmaqt2, sigmaqt2_tl, qstar, qstar_tl, clfrac, clfrac_tl)
    IMPLICIT NONE
! flag to indicate shape of pdf
    INTEGER :: flag
! 1 for tophat, 2 for triangular, 3 for Gaussian
! Grid box value of q total
    REAL*8 :: qtmean
    REAL*8 :: qtmean_tl
! width of distribution (sigma)
    REAL*8 :: sigmaqt1
    REAL*8 :: sigmaqt1_tl
! width of distribution (sigma)
    REAL*8 :: sigmaqt2
    REAL*8 :: sigmaqt2_tl
! saturation q at grid box avg T
    REAL*8 :: qstar
    REAL*8 :: qstar_tl
! cloud fraction (area under pdf from qs)
    REAL*8 :: clfrac
    REAL*8 :: clfrac_tl
    REAL*8 :: qtmode, qtmin, qtmax
    REAL*8 :: qtmode_tl, qtmin_tl, qtmax_tl
    INTRINSIC MIN
    REAL*8 :: min1
    REAL*8 :: min1_tl
    IF (flag .EQ. 1) THEN
      IF (qtmean + sigmaqt1 .LT. qstar) THEN
        clfrac = 0.
        clfrac_tl = 0.0_8
      ELSE IF (sigmaqt1 .GT. 0.) THEN
        IF (qtmean + sigmaqt1 - qstar .GT. 2.*sigmaqt1) THEN
          min1_tl = 2.*sigmaqt1_tl
          min1 = 2.*sigmaqt1
        ELSE
          min1_tl = qtmean_tl + sigmaqt1_tl - qstar_tl
          min1 = qtmean + sigmaqt1 - qstar
        END IF
        clfrac_tl = (min1_tl*2.*sigmaqt1-min1*2.*sigmaqt1_tl)/(2.*&
&         sigmaqt1)**2
        clfrac = min1/(2.*sigmaqt1)
      ELSE
        clfrac = 1.
        clfrac_tl = 0.0_8
      END IF
    ELSE IF (flag .EQ. 2) THEN
      qtmode_tl = qtmean_tl + (sigmaqt1_tl-sigmaqt2_tl)/3.
      qtmode = qtmean + (sigmaqt1-sigmaqt2)/3.
      IF (qtmode - sigmaqt1 .GT. 0.) THEN
        qtmin = 0.
        qtmin_tl = 0.0_8
      ELSE
        qtmin_tl = qtmode_tl - sigmaqt1_tl
        qtmin = qtmode - sigmaqt1
      END IF
      qtmax_tl = qtmode_tl + sigmaqt2_tl
      qtmax = qtmode + sigmaqt2
      IF (qtmax .LT. qstar) THEN
        clfrac = 0.
        clfrac_tl = 0.0_8
      ELSE IF (qtmode .LE. qstar .AND. qstar .LT. qtmax) THEN
        clfrac_tl = (((qtmax_tl-qstar_tl)*(qtmax-qstar)+(qtmax-qstar)*(&
&         qtmax_tl-qstar_tl))*(qtmax-qtmin)*(qtmax-qtmode)-(qtmax-qstar)&
&         **2*((qtmax_tl-qtmin_tl)*(qtmax-qtmode)+(qtmax-qtmin)*(&
&         qtmax_tl-qtmode_tl)))/((qtmax-qtmin)*(qtmax-qtmode))**2
        clfrac = (qtmax-qstar)*(qtmax-qstar)/((qtmax-qtmin)*(qtmax-&
&         qtmode))
      ELSE IF (qtmin .LE. qstar .AND. qstar .LT. qtmode) THEN
        clfrac_tl = -((((qstar_tl-qtmin_tl)*(qstar-qtmin)+(qstar-qtmin)*&
&         (qstar_tl-qtmin_tl))*(qtmax-qtmin)*(qtmode-qtmin)-(qstar-qtmin&
&         )**2*((qtmax_tl-qtmin_tl)*(qtmode-qtmin)+(qtmax-qtmin)*(&
&         qtmode_tl-qtmin_tl)))/((qtmax-qtmin)*(qtmode-qtmin))**2)
        clfrac = 1. - (qstar-qtmin)*(qstar-qtmin)/((qtmax-qtmin)*(qtmode&
&         -qtmin))
      ELSE IF (qstar .LE. qtmin) THEN
        clfrac = 1.
        clfrac_tl = 0.0_8
      END IF
    END IF
    RETURN
  END SUBROUTINE PDFFRAC_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE PDFFRAC(flag, qtmean, sigmaqt1, sigmaqt2, qstar, clfrac)
    IMPLICIT NONE
! flag to indicate shape of pdf
    INTEGER :: flag
! 1 for tophat, 2 for triangular, 3 for Gaussian
! Grid box value of q total
    REAL*8 :: qtmean
! width of distribution (sigma)
    REAL*8 :: sigmaqt1
! width of distribution (sigma)
    REAL*8 :: sigmaqt2
! saturation q at grid box avg T
    REAL*8 :: qstar
! cloud fraction (area under pdf from qs)
    REAL*8 :: clfrac
    REAL*8 :: qtmode, qtmin, qtmax
    INTRINSIC MIN
    REAL*8 :: min1
    IF (flag .EQ. 1) THEN
      IF (qtmean + sigmaqt1 .LT. qstar) THEN
        clfrac = 0.
      ELSE IF (sigmaqt1 .GT. 0.) THEN
        IF (qtmean + sigmaqt1 - qstar .GT. 2.*sigmaqt1) THEN
          min1 = 2.*sigmaqt1
        ELSE
          min1 = qtmean + sigmaqt1 - qstar
        END IF
        clfrac = min1/(2.*sigmaqt1)
      ELSE
        clfrac = 1.
      END IF
    ELSE IF (flag .EQ. 2) THEN
      qtmode = qtmean + (sigmaqt1-sigmaqt2)/3.
      IF (qtmode - sigmaqt1 .GT. 0.) THEN
        qtmin = 0.
      ELSE
        qtmin = qtmode - sigmaqt1
      END IF
      qtmax = qtmode + sigmaqt2
      IF (qtmax .LT. qstar) THEN
        clfrac = 0.
      ELSE IF (qtmode .LE. qstar .AND. qstar .LT. qtmax) THEN
        clfrac = (qtmax-qstar)*(qtmax-qstar)/((qtmax-qtmin)*(qtmax-&
&         qtmode))
      ELSE IF (qtmin .LE. qstar .AND. qstar .LT. qtmode) THEN
        clfrac = 1. - (qstar-qtmin)*(qstar-qtmin)/((qtmax-qtmin)*(qtmode&
&         -qtmin))
      ELSE IF (qstar .LE. qtmin) THEN
        clfrac = 1.
      END IF
    END IF
    RETURN
  END SUBROUTINE PDFFRAC
!  Differentiation of pdfcondensate in forward (tangent) mode (with options r8):
!   variations   of useful results: condensate4
!   with respect to varying inputs: qtmean4 qstar4 sigmaqt14 sigmaqt24
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE PDFCONDENSATE_TLM(flag, qtmean4, qtmean4_tl, sigmaqt14, &
&   sigmaqt14_tl, sigmaqt24, sigmaqt24_tl, qstar4, qstar4_tl, &
&   condensate4, condensate4_tl)
    IMPLICIT NONE
! flag to indicate shape of pdf
    INTEGER :: flag
! 1 for tophat, 2 for triangular
! Grid box value of q total
    REAL*8 :: qtmean4
    REAL*8 :: qtmean4_tl
! width of distribution (to left)
    REAL*8 :: sigmaqt14
    REAL*8 :: sigmaqt14_tl
! width of distribution (to right)
    REAL*8 :: sigmaqt24
    REAL*8 :: sigmaqt24_tl
! saturation q at grid box avg T
    REAL*8 :: qstar4
    REAL*8 :: qstar4_tl
! condensate (area under (q*-qt)*pdf from qs)
    REAL*8 :: condensate4
    REAL*8 :: condensate4_tl
    REAL*8 :: qtmode, qtmin, qtmax, consta, constb, cloudf
    REAL*8 :: qtmode_tl, qtmin_tl, qtmax_tl, consta_tl, constb_tl, &
&   cloudf_tl
    REAL*8 :: term1, term2, term3
    REAL*8 :: term1_tl, term2_tl, term3_tl
    REAL*8 :: qtmean, sigmaqt1, sigmaqt2, qstar, condensate
    REAL*8 :: qtmean_tl, sigmaqt1_tl, sigmaqt2_tl, qstar_tl, &
&   condensate_tl
    INTRINSIC MIN
    REAL*8 :: min1
    REAL*8 :: min1_tl
    qtmean_tl = qtmean4_tl
    qtmean = qtmean4
    sigmaqt1_tl = sigmaqt14_tl
    sigmaqt1 = sigmaqt14
    sigmaqt2_tl = sigmaqt24_tl
    sigmaqt2 = sigmaqt24
    qstar_tl = qstar4_tl
    qstar = qstar4
    IF (flag .EQ. 1) THEN
      IF (qtmean + sigmaqt1 .LT. qstar) THEN
        condensate = 0.0
        condensate_tl = 0.0_8
      ELSE IF (qstar .GT. qtmean - sigmaqt1) THEN
        IF (sigmaqt1 .GT. 0.0) THEN
          IF (qtmean + sigmaqt1 - qstar .GT. 2.0*sigmaqt1) THEN
            min1_tl = 2.0*sigmaqt1_tl
            min1 = 2.0*sigmaqt1
          ELSE
            min1_tl = qtmean_tl + sigmaqt1_tl - qstar_tl
            min1 = qtmean + sigmaqt1 - qstar
          END IF
          condensate_tl = (2*min1*min1_tl*4.0*sigmaqt1-min1**2*4.0*&
&           sigmaqt1_tl)/(4.0*sigmaqt1)**2
          condensate = min1**2/(4.0*sigmaqt1)
        ELSE
          condensate_tl = qtmean_tl - qstar_tl
          condensate = qtmean - qstar
        END IF
      ELSE
        condensate_tl = qtmean_tl - qstar_tl
        condensate = qtmean - qstar
      END IF
    ELSE IF (flag .EQ. 2) THEN
      qtmode_tl = qtmean_tl + (sigmaqt1_tl-sigmaqt2_tl)/3.0
      qtmode = qtmean + (sigmaqt1-sigmaqt2)/3.0
      IF (qtmode - sigmaqt1 .GT. 0.0) THEN
        qtmin = 0.0
        qtmin_tl = 0.0_8
      ELSE
        qtmin_tl = qtmode_tl - sigmaqt1_tl
        qtmin = qtmode - sigmaqt1
      END IF
      qtmax_tl = qtmode_tl + sigmaqt2_tl
      qtmax = qtmode + sigmaqt2
      IF (qtmax .LT. qstar) THEN
        condensate = 0.0
        condensate_tl = 0.0_8
      ELSE IF (qtmode .LE. qstar .AND. qstar .LT. qtmax) THEN
        constb_tl = -(2.0*((qtmax_tl-qtmin_tl)*(qtmax-qtmode)+(qtmax-&
&         qtmin)*(qtmax_tl-qtmode_tl))/((qtmax-qtmin)*(qtmax-qtmode))**2&
&         )
        constb = 2.0/((qtmax-qtmin)*(qtmax-qtmode))
        cloudf_tl = (((qtmax_tl-qstar_tl)*(qtmax-qstar)+(qtmax-qstar)*(&
&         qtmax_tl-qstar_tl))*(qtmax-qtmin)*(qtmax-qtmode)-(qtmax-qstar)&
&         **2*((qtmax_tl-qtmin_tl)*(qtmax-qtmode)+(qtmax-qtmin)*(&
&         qtmax_tl-qtmode_tl)))/((qtmax-qtmin)*(qtmax-qtmode))**2
        cloudf = (qtmax-qstar)*(qtmax-qstar)/((qtmax-qtmin)*(qtmax-&
&         qtmode))
        term1_tl = ((qstar_tl*qstar+qstar*qstar_tl)*qstar+qstar**2*&
&         qstar_tl)/3.0
        term1 = qstar*qstar*qstar/3.0
        term2_tl = ((qtmax_tl*qstar+qtmax*qstar_tl)*qstar+qtmax*qstar*&
&         qstar_tl)/2.0
        term2 = qtmax*qstar*qstar/2.0
        term3_tl = ((qtmax_tl*qtmax+qtmax*qtmax_tl)*qtmax+qtmax**2*&
&         qtmax_tl)/6.0
        term3 = qtmax*qtmax*qtmax/6.0
        condensate_tl = constb_tl*(term1-term2+term3) + constb*(term1_tl&
&         -term2_tl+term3_tl) - qstar_tl*cloudf - qstar*cloudf_tl
        condensate = constb*(term1-term2+term3) - qstar*cloudf
      ELSE IF (qtmin .LE. qstar .AND. qstar .LT. qtmode) THEN
        consta_tl = -(2.0*((qtmax_tl-qtmin_tl)*(qtmode-qtmin)+(qtmax-&
&         qtmin)*(qtmode_tl-qtmin_tl))/((qtmax-qtmin)*(qtmode-qtmin))**2&
&         )
        consta = 2.0/((qtmax-qtmin)*(qtmode-qtmin))
        cloudf_tl = -((((qstar_tl-qtmin_tl)*(qstar-qtmin)+(qstar-qtmin)*&
&         (qstar_tl-qtmin_tl))*(qtmax-qtmin)*(qtmode-qtmin)-(qstar-qtmin&
&         )**2*((qtmax_tl-qtmin_tl)*(qtmode-qtmin)+(qtmax-qtmin)*(&
&         qtmode_tl-qtmin_tl)))/((qtmax-qtmin)*(qtmode-qtmin))**2)
        cloudf = 1.0 - (qstar-qtmin)*(qstar-qtmin)/((qtmax-qtmin)*(&
&         qtmode-qtmin))
        term1_tl = ((qstar_tl*qstar+qstar*qstar_tl)*qstar+qstar**2*&
&         qstar_tl)/3.0
        term1 = qstar*qstar*qstar/3.0
        term2_tl = ((qtmin_tl*qstar+qtmin*qstar_tl)*qstar+qtmin*qstar*&
&         qstar_tl)/2.0
        term2 = qtmin*qstar*qstar/2.0
        term3_tl = ((qtmin_tl*qtmin+qtmin*qtmin_tl)*qtmin+qtmin**2*&
&         qtmin_tl)/6.0
        term3 = qtmin*qtmin*qtmin/6.0
        condensate_tl = qtmean_tl - consta_tl*(term1-term2+term3) - &
&         consta*(term1_tl-term2_tl+term3_tl) - qstar_tl*cloudf - qstar*&
&         cloudf_tl
        condensate = qtmean - consta*(term1-term2+term3) - qstar*cloudf
      ELSE IF (qstar .LE. qtmin) THEN
        condensate_tl = qtmean_tl - qstar_tl
        condensate = qtmean - qstar
      ELSE
        condensate_tl = 0.0_8
      END IF
    ELSE
      condensate_tl = 0.0_8
    END IF
    condensate4_tl = condensate_tl
    condensate4 = condensate
    RETURN
  END SUBROUTINE PDFCONDENSATE_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE PDFCONDENSATE(flag, qtmean4, sigmaqt14, sigmaqt24, qstar4, &
&   condensate4)
    IMPLICIT NONE
! flag to indicate shape of pdf
    INTEGER :: flag
! 1 for tophat, 2 for triangular
! Grid box value of q total
    REAL*8 :: qtmean4
! width of distribution (to left)
    REAL*8 :: sigmaqt14
! width of distribution (to right)
    REAL*8 :: sigmaqt24
! saturation q at grid box avg T
    REAL*8 :: qstar4
! condensate (area under (q*-qt)*pdf from qs)
    REAL*8 :: condensate4
    REAL*8 :: qtmode, qtmin, qtmax, consta, constb, cloudf
    REAL*8 :: term1, term2, term3
    REAL*8 :: qtmean, sigmaqt1, sigmaqt2, qstar, condensate
    INTRINSIC MIN
    REAL*8 :: min1
    qtmean = qtmean4
    sigmaqt1 = sigmaqt14
    sigmaqt2 = sigmaqt24
    qstar = qstar4
    IF (flag .EQ. 1) THEN
      IF (qtmean + sigmaqt1 .LT. qstar) THEN
        condensate = 0.0
      ELSE IF (qstar .GT. qtmean - sigmaqt1) THEN
        IF (sigmaqt1 .GT. 0.0) THEN
          IF (qtmean + sigmaqt1 - qstar .GT. 2.0*sigmaqt1) THEN
            min1 = 2.0*sigmaqt1
          ELSE
            min1 = qtmean + sigmaqt1 - qstar
          END IF
          condensate = min1**2/(4.0*sigmaqt1)
        ELSE
          condensate = qtmean - qstar
        END IF
      ELSE
        condensate = qtmean - qstar
      END IF
    ELSE IF (flag .EQ. 2) THEN
      qtmode = qtmean + (sigmaqt1-sigmaqt2)/3.0
      IF (qtmode - sigmaqt1 .GT. 0.0) THEN
        qtmin = 0.0
      ELSE
        qtmin = qtmode - sigmaqt1
      END IF
      qtmax = qtmode + sigmaqt2
      IF (qtmax .LT. qstar) THEN
        condensate = 0.0
      ELSE IF (qtmode .LE. qstar .AND. qstar .LT. qtmax) THEN
        constb = 2.0/((qtmax-qtmin)*(qtmax-qtmode))
        cloudf = (qtmax-qstar)*(qtmax-qstar)/((qtmax-qtmin)*(qtmax-&
&         qtmode))
        term1 = qstar*qstar*qstar/3.0
        term2 = qtmax*qstar*qstar/2.0
        term3 = qtmax*qtmax*qtmax/6.0
        condensate = constb*(term1-term2+term3) - qstar*cloudf
      ELSE IF (qtmin .LE. qstar .AND. qstar .LT. qtmode) THEN
        consta = 2.0/((qtmax-qtmin)*(qtmode-qtmin))
        cloudf = 1.0 - (qstar-qtmin)*(qstar-qtmin)/((qtmax-qtmin)*(&
&         qtmode-qtmin))
        term1 = qstar*qstar*qstar/3.0
        term2 = qtmin*qstar*qstar/2.0
        term3 = qtmin*qtmin*qtmin/6.0
        condensate = qtmean - consta*(term1-term2+term3) - qstar*cloudf
      ELSE IF (qstar .LE. qtmin) THEN
        condensate = qtmean - qstar
      END IF
    END IF
    condensate4 = condensate
    RETURN
  END SUBROUTINE PDFCONDENSATE
!  Differentiation of cnvsrc in forward (tangent) mode (with options r8):
!   variations   of useful results: af qv qla qia te
!   with respect to varying inputs: af qs qv qla qia dcf dmf te
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) & 
!#endif
  SUBROUTINE CNVSRC_TLM(dt, iceparam, sclmfdfr, mass, imass, pl, te, &
&   te_tl, qv, qv_tl, dcf, dcf_tl, dmf, dmf_tl, qla, qla_tl, qia, qia_tl&
&   , cf, af, af_tl, qs, qs_tl)
    IMPLICIT NONE
!INPUTS:
!
!       ICEPARAM: 0-1  controls how strongly new conv condensate is partitioned in ice-liquid
!                 1 means partitioning follows ice_fraction(TE). 0 means all new condensate is
!                 liquid 
!
!       SCLMFDFR: Scales detraining mass flux to a cloud fraction source - kludge. Thinly justified
!                 by fuzziness of cloud boundaries and existence of PDF of condensates (for choices
!                 0.-1.0) or by subgrid layering (for choices >1.0) 
    REAL*8, INTENT(IN) :: dt, iceparam, sclmfdfr
    REAL*8, INTENT(IN) :: mass, imass, qs
    REAL*8, INTENT(IN) :: qs_tl
    REAL*8, INTENT(IN) :: dmf, pl
    REAL*8, INTENT(IN) :: dmf_tl
    REAL*8, INTENT(IN) :: dcf, cf
    REAL*8, INTENT(IN) :: dcf_tl
    REAL*8, INTENT(INOUT) :: te
    REAL*8, INTENT(INOUT) :: te_tl
    REAL*8, INTENT(INOUT) :: af, qv
    REAL*8, INTENT(INOUT) :: af_tl, qv_tl
    REAL*8, INTENT(INOUT) :: qla, qia
    REAL*8, INTENT(INOUT) :: qla_tl, qia_tl
    REAL*8 :: tend, qvx, qca, fqi
    REAL*8 :: tend_tl, qvx_tl, fqi_tl
    INTEGER :: strategy
    REAL*8 :: minrhx
    INTRINSIC MIN
    REAL*8 :: result1
    REAL*8 :: result1_tl
    strategy = 1
!Minimum allowed env RH
    minrhx = 0.001
!Addition of condensate from RAS
    tend_tl = imass*dcf_tl
    tend = dcf*imass
    result1_tl = ICE_FRACTION_TLM(te, te_tl, result1)
    fqi_tl = iceparam*result1_tl
    fqi = 0.0 + iceparam*result1
    qla_tl = qla_tl + dt*((1.0-fqi)*tend_tl-fqi_tl*tend)
    qla = qla + (1.0-fqi)*tend*dt
    qia_tl = qia_tl + dt*(fqi_tl*tend+fqi*tend_tl)
    qia = qia + fqi*tend*dt
! dont forget that conv cond has never frozen !!!!
    te_tl = te_tl + (mapl8_alhs-mapl8_alhl)*dt*(fqi_tl*tend+fqi*tend_tl)&
&     /mapl8_cp
    te = te + (mapl8_alhs-mapl8_alhl)*fqi*tend*dt/mapl8_cp
    qca = qla + qia
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Tiedtke-style anvil fraction !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    tend_tl = imass*sclmfdfr*dmf_tl
    tend = dmf*imass*sclmfdfr
    af_tl = af_tl + dt*tend_tl
    af = af + tend*dt
    IF (af .GT. 0.99) THEN
      af = 0.99
      af_tl = 0.0_8
    ELSE
      af = af
    END IF
! where ( (AF+CF) > 1.00 )
!    AF=1.00-CF
! endwhere
!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Check for funny (tiny, negative)
! external QV s, resulting from assumed
! QV=QSAT within anvil.
!
! Two strategies to fix 
!   1) Simply constrain AF assume condensate
!      just gets "packed" in
!   2) Evaporate QCA to bring up QVx leave AF alone
!      Should include QSAT iteration, but ...        
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!   QS  = QSAT(         &
!               TE    , &
!               PL      )
    IF (af .LT. 1.0) THEN
      qvx_tl = ((qv_tl-qs_tl*af-qs*af_tl)*(1.-af)+(qv-qs*af)*af_tl)/(1.-&
&       af)**2
      qvx = (qv-qs*af)/(1.-af)
    ELSE
      qvx_tl = qs_tl
      qvx = qs
    END IF
    IF (strategy .EQ. 1) THEN
      IF (qvx - minrhx*qs .LT. 0.0 .AND. af .GT. 0.) THEN
        af_tl = ((qv_tl-minrhx*qs_tl)*qs*(1.0-minrhx)-(qv-minrhx*qs)*(&
&         1.0-minrhx)*qs_tl)/(qs*(1.0-minrhx))**2
        af = (qv-minrhx*qs)/(qs*(1.0-minrhx))
      END IF
      IF (af .LT. 0.) THEN
! If still cant make suitable env RH then destroy anvil
        af = 0.
        qv_tl = qv_tl + qla_tl + qia_tl
        qv = qv + qla + qia
        te_tl = te_tl - (mapl8_alhl*qla_tl+mapl8_alhs*qia_tl)/mapl8_cp
        te = te - (mapl8_alhl*qla+mapl8_alhs*qia)/mapl8_cp
        qla = 0.
        qia = 0.
        af_tl = 0.0_8
        qla_tl = 0.0_8
        qia_tl = 0.0_8
      END IF
    ELSE IF (strategy .EQ. 2) THEN
      IF (qvx - minrhx*qs .LT. 0.0 .AND. af .GT. 0.) THEN
        qv_tl = qv_tl + (1.-af)*(minrhx*qs_tl-qvx_tl) - af_tl*(minrhx*qs&
&         -qvx)
        qv = qv + (1.-af)*(minrhx*qs-qvx)
        qca = qca - (1.-af)*(minrhx*qs-qvx)
        te_tl = te_tl - mapl8_alhl*((1.-af)*(minrhx*qs_tl-qvx_tl)-af_tl*&
&         (minrhx*qs-qvx))/mapl8_cp
        te = te - (1.-af)*(minrhx*qs-qvx)*mapl8_alhl/mapl8_cp
      END IF
    END IF
  END SUBROUTINE CNVSRC_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) & 
!#endif
  SUBROUTINE CNVSRC(dt, iceparam, sclmfdfr, mass, imass, pl, te, qv, dcf&
&   , dmf, qla, qia, cf, af, qs)
    IMPLICIT NONE
!INPUTS:
!
!       ICEPARAM: 0-1  controls how strongly new conv condensate is partitioned in ice-liquid
!                 1 means partitioning follows ice_fraction(TE). 0 means all new condensate is
!                 liquid 
!
!       SCLMFDFR: Scales detraining mass flux to a cloud fraction source - kludge. Thinly justified
!                 by fuzziness of cloud boundaries and existence of PDF of condensates (for choices
!                 0.-1.0) or by subgrid layering (for choices >1.0) 
    REAL*8, INTENT(IN) :: dt, iceparam, sclmfdfr
    REAL*8, INTENT(IN) :: mass, imass, qs
    REAL*8, INTENT(IN) :: dmf, pl
    REAL*8, INTENT(IN) :: dcf, cf
    REAL*8, INTENT(INOUT) :: te
    REAL*8, INTENT(INOUT) :: af, qv
    REAL*8, INTENT(INOUT) :: qla, qia
    REAL*8 :: tend, qvx, qca, fqi
    INTEGER :: strategy
    REAL*8 :: minrhx
    INTRINSIC MIN
    REAL*8 :: result1
    strategy = 1
!Minimum allowed env RH
    minrhx = 0.001
!Addition of condensate from RAS
    tend = dcf*imass
    result1 = ICE_FRACTION(te)
    fqi = 0.0 + iceparam*result1
    qla = qla + (1.0-fqi)*tend*dt
    qia = qia + fqi*tend*dt
! dont forget that conv cond has never frozen !!!!
    te = te + (mapl8_alhs-mapl8_alhl)*fqi*tend*dt/mapl8_cp
    qca = qla + qia
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Tiedtke-style anvil fraction !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    tend = dmf*imass*sclmfdfr
    af = af + tend*dt
    IF (af .GT. 0.99) THEN
      af = 0.99
    ELSE
      af = af
    END IF
! where ( (AF+CF) > 1.00 )
!    AF=1.00-CF
! endwhere
!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Check for funny (tiny, negative)
! external QV s, resulting from assumed
! QV=QSAT within anvil.
!
! Two strategies to fix 
!   1) Simply constrain AF assume condensate
!      just gets "packed" in
!   2) Evaporate QCA to bring up QVx leave AF alone
!      Should include QSAT iteration, but ...        
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!   QS  = QSAT(         &
!               TE    , &
!               PL      )
    IF (af .LT. 1.0) THEN
      qvx = (qv-qs*af)/(1.-af)
    ELSE
      qvx = qs
    END IF
    IF (strategy .EQ. 1) THEN
      IF (qvx - minrhx*qs .LT. 0.0 .AND. af .GT. 0.) af = (qv-minrhx*qs)&
&         /(qs*(1.0-minrhx))
      IF (af .LT. 0.) THEN
! If still cant make suitable env RH then destroy anvil
        af = 0.
        qv = qv + qla + qia
        te = te - (mapl8_alhl*qla+mapl8_alhs*qia)/mapl8_cp
        qla = 0.
        qia = 0.
      END IF
    ELSE IF (strategy .EQ. 2) THEN
      IF (qvx - minrhx*qs .LT. 0.0 .AND. af .GT. 0.) THEN
        qv = qv + (1.-af)*(minrhx*qs-qvx)
        qca = qca - (1.-af)*(minrhx*qs-qvx)
        te = te - (1.-af)*(minrhx*qs-qvx)*mapl8_alhl/mapl8_cp
      END IF
    END IF
  END SUBROUTINE CNVSRC
!  Differentiation of evap3 in forward (tangent) mode (with options r8):
!   variations   of useful results: f ql qv te
!   with respect to varying inputs: rhcr f qi ql qs qv te
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE EVAP3_TLM(dt, rhcr, rhcr_tl, pl, te, te_tl, qv, qv_tl, ql, &
&   ql_tl, qi, qi_tl, f, f_tl, xf, qs, qs_tl)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: dt
    REAL*8, INTENT(IN) :: rhcr
    REAL*8, INTENT(IN) :: rhcr_tl
    REAL*8, INTENT(IN) :: pl
    REAL*8, INTENT(INOUT) :: te
    REAL*8, INTENT(INOUT) :: te_tl
    REAL*8, INTENT(INOUT) :: qv
    REAL*8, INTENT(INOUT) :: qv_tl
    REAL*8, INTENT(INOUT) :: ql, qi
    REAL*8, INTENT(INOUT) :: ql_tl, qi_tl
    REAL*8, INTENT(INOUT) :: f
    REAL*8, INTENT(INOUT) :: f_tl
    REAL*8, INTENT(IN) :: xf
    REAL*8, INTENT(IN) :: qs
    REAL*8, INTENT(IN) :: qs_tl
!,QS
    REAL*8 :: es, nn, radius, k1, k2, teff, qcm, evap, rhx, qc
    REAL*8 :: es_tl, radius_tl, k1_tl, k2_tl, teff_tl, qcm_tl, evap_tl, &
&   rhx_tl, qc_tl
    REAL*8, PARAMETER :: epsilon=mapl8_h2omw/mapl8_airmw
! J m**-1 s**-1 K**-1
    REAL*8, PARAMETER :: k_cond=2.4e-2
! m**2 s**-1
    REAL*8, PARAMETER :: diffu=2.2e-5
    REAL*8 :: a_eff
    INTRINSIC MIN
    a_eff = cld_evp_eff
    nn = 50.*1.0e6
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!         EVAPORATION OF CLOUD WATER.             !!
!!                                                 !!
!!  DelGenio et al (1996, J. Clim., 9, 270-303)    !!
!!  formulation  (Eq.s 15-17)                      !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!   QS  = QSAT(         &
!               TE    , &
!               PL      )
! (100's <-^ convert from mbar to Pa)
    es_tl = (100.*pl*qs_tl*(epsilon+(1.0-epsilon)*qs)-100.*pl*qs*(1.0-&
&     epsilon)*qs_tl)/(epsilon+(1.0-epsilon)*qs)**2
    es = 100.*pl*qs/(epsilon+(1.0-epsilon)*qs)
    IF (qv/qs .GT. 1.00) THEN
      rhx = 1.00
      rhx_tl = 0.0_8
    ELSE
      rhx_tl = (qv_tl*qs-qv*qs_tl)/qs**2
      rhx = qv/qs
    END IF
    k1_tl = -(mapl8_alhl**2*rho_w*k_cond*mapl8_rvap*2*te*te_tl/(k_cond*&
&     mapl8_rvap*te**2)**2)
    k1 = mapl8_alhl**2*rho_w/(k_cond*mapl8_rvap*te**2)
    k2_tl = (mapl8_rvap*rho_w*te_tl*diffu*1000.*es/pl-mapl8_rvap*te*&
&     rho_w*diffu*1000.*es_tl/pl)/(diffu*(1000./pl)*es)**2
    k2 = mapl8_rvap*te*rho_w/(diffu*(1000./pl)*es)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Here DIFFU is given for 1000 mb  !!
!! so 1000./PR accounts for inc-    !!
!! reased diffusivity at lower      !!
!! pressure.                        !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
    IF (f .GT. 0. .AND. ql .GT. 0.) THEN
      qcm_tl = (ql_tl*f-ql*f_tl)/f**2
      qcm = ql/f
    ELSE
      qcm = 0.
      qcm_tl = 0.0_8
    END IF
    radius_tl = LDRADIUS3_TLM(pl, te, te_tl, qcm, qcm_tl, nn, radius)
    IF (rhx .LT. rhcr .AND. radius .GT. 0.0) THEN
! / (1.00 - RHx)
      teff_tl = ((rhcr_tl-rhx_tl)*(k1+k2)*radius**2-(rhcr-rhx)*((k1_tl+&
&       k2_tl)*radius**2+(k1+k2)*2*radius*radius_tl))/((k1+k2)*radius**2&
&       )**2
      teff = (rhcr-rhx)/((k1+k2)*radius**2)
    ELSE
! -999.
      teff = 0.0
      teff_tl = 0.0_8
    END IF
    evap_tl = a_eff*dt*(ql_tl*teff+ql*teff_tl)
    evap = a_eff*ql*dt*teff
    IF (evap .GT. ql) THEN
      evap_tl = ql_tl
      evap = ql
    ELSE
      evap = evap
    END IF
    qc_tl = ql_tl + qi_tl
    qc = ql + qi
    IF (qc .GT. 0.) THEN
      f_tl = ((f_tl*(qc-evap)+f*(qc_tl-evap_tl))*qc-f*(qc-evap)*qc_tl)/&
&       qc**2
      f = f*(qc-evap)/qc
    END IF
    qv_tl = qv_tl + evap_tl
    qv = qv + evap
    ql_tl = ql_tl - evap_tl
    ql = ql - evap
    te_tl = te_tl - mapl8_alhl*evap_tl/mapl8_cp
    te = te - mapl8_alhl/mapl8_cp*evap
  END SUBROUTINE EVAP3_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE EVAP3(dt, rhcr, pl, te, qv, ql, qi, f, xf, qs)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: dt
    REAL*8, INTENT(IN) :: rhcr
    REAL*8, INTENT(IN) :: pl
    REAL*8, INTENT(INOUT) :: te
    REAL*8, INTENT(INOUT) :: qv
    REAL*8, INTENT(INOUT) :: ql, qi
    REAL*8, INTENT(INOUT) :: f
    REAL*8, INTENT(IN) :: xf
    REAL*8, INTENT(IN) :: qs
!,QS
    REAL*8 :: es, nn, radius, k1, k2, teff, qcm, evap, rhx, qc
    REAL*8, PARAMETER :: epsilon=mapl8_h2omw/mapl8_airmw
! J m**-1 s**-1 K**-1
    REAL*8, PARAMETER :: k_cond=2.4e-2
! m**2 s**-1
    REAL*8, PARAMETER :: diffu=2.2e-5
    REAL*8 :: a_eff
    INTRINSIC MIN
    a_eff = cld_evp_eff
    nn = 50.*1.0e6
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!         EVAPORATION OF CLOUD WATER.             !!
!!                                                 !!
!!  DelGenio et al (1996, J. Clim., 9, 270-303)    !!
!!  formulation  (Eq.s 15-17)                      !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!   QS  = QSAT(         &
!               TE    , &
!               PL      )
! (100's <-^ convert from mbar to Pa)
    es = 100.*pl*qs/(epsilon+(1.0-epsilon)*qs)
    IF (qv/qs .GT. 1.00) THEN
      rhx = 1.00
    ELSE
      rhx = qv/qs
    END IF
    k1 = mapl8_alhl**2*rho_w/(k_cond*mapl8_rvap*te**2)
    k2 = mapl8_rvap*te*rho_w/(diffu*(1000./pl)*es)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Here DIFFU is given for 1000 mb  !!
!! so 1000./PR accounts for inc-    !!
!! reased diffusivity at lower      !!
!! pressure.                        !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
    IF (f .GT. 0. .AND. ql .GT. 0.) THEN
      qcm = ql/f
    ELSE
      qcm = 0.
    END IF
    radius = LDRADIUS3(pl, te, qcm, nn)
    IF (rhx .LT. rhcr .AND. radius .GT. 0.0) THEN
! / (1.00 - RHx)
      teff = (rhcr-rhx)/((k1+k2)*radius**2)
    ELSE
! -999.
      teff = 0.0
    END IF
    evap = a_eff*ql*dt*teff
    IF (evap .GT. ql) THEN
      evap = ql
    ELSE
      evap = evap
    END IF
    qc = ql + qi
    IF (qc .GT. 0.) f = f*(qc-evap)/qc
    qv = qv + evap
    ql = ql - evap
    te = te - mapl8_alhl/mapl8_cp*evap
  END SUBROUTINE EVAP3
!  Differentiation of subl3 in forward (tangent) mode (with options r8):
!   variations   of useful results: f qi qv te
!   with respect to varying inputs: rhcr f qi ql qs qv te
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE SUBL3_TLM(dt, rhcr, rhcr_tl, pl, te, te_tl, qv, qv_tl, ql, &
&   ql_tl, qi, qi_tl, f, f_tl, xf, qs, qs_tl)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: dt
    REAL*8, INTENT(IN) :: rhcr
    REAL*8, INTENT(IN) :: rhcr_tl
    REAL*8, INTENT(IN) :: pl
    REAL*8, INTENT(INOUT) :: te
    REAL*8, INTENT(INOUT) :: te_tl
    REAL*8, INTENT(INOUT) :: qv
    REAL*8, INTENT(INOUT) :: qv_tl
    REAL*8, INTENT(INOUT) :: ql, qi
    REAL*8, INTENT(INOUT) :: ql_tl, qi_tl
    REAL*8, INTENT(INOUT) :: f
    REAL*8, INTENT(INOUT) :: f_tl
    REAL*8, INTENT(IN) :: xf
    REAL*8, INTENT(IN) :: qs
    REAL*8, INTENT(IN) :: qs_tl
!, QS
    REAL*8 :: es, nn, radius, k1, k2, teff, qcm, subl, rhx, qc
    REAL*8 :: es_tl, radius_tl, k1_tl, k2_tl, teff_tl, qcm_tl, subl_tl, &
&   rhx_tl, qc_tl
    REAL*8, PARAMETER :: epsilon=mapl8_h2omw/mapl8_airmw
! J m**-1 s**-1 K**-1
    REAL*8, PARAMETER :: k_cond=2.4e-2
! m**2 s**-1
    REAL*8, PARAMETER :: diffu=2.2e-5
    REAL*8 :: a_eff
    INTRINSIC MIN
    a_eff = cld_evp_eff
    nn = 5.*1.0e6
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!         SUBLORATION OF CLOUD WATER.             !!
!!                                                 !!
!!  DelGenio et al (1996, J. Clim., 9, 270-303)    !!
!!  formulation  (Eq.s 15-17)                      !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!   QS  = QSAT(         &
!               TE    , &
!               PL      )
! (100s <-^ convert from mbar to Pa)
    es_tl = (100.*pl*qs_tl*(epsilon+(1.0-epsilon)*qs)-100.*pl*qs*(1.0-&
&     epsilon)*qs_tl)/(epsilon+(1.0-epsilon)*qs)**2
    es = 100.*pl*qs/(epsilon+(1.0-epsilon)*qs)
    IF (qv/qs .GT. 1.00) THEN
      rhx = 1.00
      rhx_tl = 0.0_8
    ELSE
      rhx_tl = (qv_tl*qs-qv*qs_tl)/qs**2
      rhx = qv/qs
    END IF
    k1_tl = -(mapl8_alhl**2*rho_w*k_cond*mapl8_rvap*2*te*te_tl/(k_cond*&
&     mapl8_rvap*te**2)**2)
    k1 = mapl8_alhl**2*rho_w/(k_cond*mapl8_rvap*te**2)
    k2_tl = (mapl8_rvap*rho_w*te_tl*diffu*1000.*es/pl-mapl8_rvap*te*&
&     rho_w*diffu*1000.*es_tl/pl)/(diffu*(1000./pl)*es)**2
    k2 = mapl8_rvap*te*rho_w/(diffu*(1000./pl)*es)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Here DIFFU is given for 1000 mb  !!
!! so 1000./PR accounts for inc-    !!
!! reased diffusivity at lower      !!
!! pressure.                        !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
    IF (f .GT. 0. .AND. qi .GT. 0.) THEN
      qcm_tl = (qi_tl*f-qi*f_tl)/f**2
      qcm = qi/f
    ELSE
      qcm = 0.
      qcm_tl = 0.0_8
    END IF
    radius_tl = LDRADIUS3_TLM(pl, te, te_tl, qcm, qcm_tl, nn, radius)
    IF (rhx .LT. rhcr .AND. radius .GT. 0.0) THEN
! / (1.00 - RHx)
      teff_tl = ((rhcr_tl-rhx_tl)*(k1+k2)*radius**2-(rhcr-rhx)*((k1_tl+&
&       k2_tl)*radius**2+(k1+k2)*2*radius*radius_tl))/((k1+k2)*radius**2&
&       )**2
      teff = (rhcr-rhx)/((k1+k2)*radius**2)
    ELSE
! -999.
      teff = 0.0
      teff_tl = 0.0_8
    END IF
    subl_tl = a_eff*dt*(qi_tl*teff+qi*teff_tl)
    subl = a_eff*qi*dt*teff
    IF (subl .GT. qi) THEN
      subl_tl = qi_tl
      subl = qi
    ELSE
      subl = subl
    END IF
    qc_tl = ql_tl + qi_tl
    qc = ql + qi
    IF (qc .GT. 0.) THEN
      f_tl = ((f_tl*(qc-subl)+f*(qc_tl-subl_tl))*qc-f*(qc-subl)*qc_tl)/&
&       qc**2
      f = f*(qc-subl)/qc
    END IF
    qv_tl = qv_tl + subl_tl
    qv = qv + subl
    qi_tl = qi_tl - subl_tl
    qi = qi - subl
    te_tl = te_tl - mapl8_alhs*subl_tl/mapl8_cp
    te = te - mapl8_alhs/mapl8_cp*subl
  END SUBROUTINE SUBL3_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE SUBL3(dt, rhcr, pl, te, qv, ql, qi, f, xf, qs)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: dt
    REAL*8, INTENT(IN) :: rhcr
    REAL*8, INTENT(IN) :: pl
    REAL*8, INTENT(INOUT) :: te
    REAL*8, INTENT(INOUT) :: qv
    REAL*8, INTENT(INOUT) :: ql, qi
    REAL*8, INTENT(INOUT) :: f
    REAL*8, INTENT(IN) :: xf
    REAL*8, INTENT(IN) :: qs
!, QS
    REAL*8 :: es, nn, radius, k1, k2, teff, qcm, subl, rhx, qc
    REAL*8, PARAMETER :: epsilon=mapl8_h2omw/mapl8_airmw
! J m**-1 s**-1 K**-1
    REAL*8, PARAMETER :: k_cond=2.4e-2
! m**2 s**-1
    REAL*8, PARAMETER :: diffu=2.2e-5
    REAL*8 :: a_eff
    INTRINSIC MIN
    a_eff = cld_evp_eff
    nn = 5.*1.0e6
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!         SUBLORATION OF CLOUD WATER.             !!
!!                                                 !!
!!  DelGenio et al (1996, J. Clim., 9, 270-303)    !!
!!  formulation  (Eq.s 15-17)                      !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!   QS  = QSAT(         &
!               TE    , &
!               PL      )
! (100s <-^ convert from mbar to Pa)
    es = 100.*pl*qs/(epsilon+(1.0-epsilon)*qs)
    IF (qv/qs .GT. 1.00) THEN
      rhx = 1.00
    ELSE
      rhx = qv/qs
    END IF
    k1 = mapl8_alhl**2*rho_w/(k_cond*mapl8_rvap*te**2)
    k2 = mapl8_rvap*te*rho_w/(diffu*(1000./pl)*es)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Here DIFFU is given for 1000 mb  !!
!! so 1000./PR accounts for inc-    !!
!! reased diffusivity at lower      !!
!! pressure.                        !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
    IF (f .GT. 0. .AND. qi .GT. 0.) THEN
      qcm = qi/f
    ELSE
      qcm = 0.
    END IF
    radius = LDRADIUS3(pl, te, qcm, nn)
    IF (rhx .LT. rhcr .AND. radius .GT. 0.0) THEN
! / (1.00 - RHx)
      teff = (rhcr-rhx)/((k1+k2)*radius**2)
    ELSE
! -999.
      teff = 0.0
    END IF
    subl = a_eff*qi*dt*teff
    IF (subl .GT. qi) THEN
      subl = qi
    ELSE
      subl = subl
    END IF
    qc = ql + qi
    IF (qc .GT. 0.) f = f*(qc-subl)/qc
    qv = qv + subl
    qi = qi - subl
    te = te - mapl8_alhs/mapl8_cp*subl
  END SUBROUTINE SUBL3
!  Differentiation of autocon3 in forward (tangent) mode (with options r8):
!   variations   of useful results: f qc qp
!   with respect to varying inputs: f qc te
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE AUTOCON3_TLM(dt, qc, qc_tl, qp, qp_tl, te, te_tl, pl, kh, f&
&   , f_tl, sundqv2, sundqv3, sundqt1, dzet, vf, fraction_removal)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: fraction_removal
    REAL*8, INTENT(IN) :: dt
    REAL*8, INTENT(IN) :: te
    REAL*8, INTENT(IN) :: te_tl
    REAL*8, INTENT(IN) :: pl
    REAL*8, INTENT(IN) :: kh
    REAL*8, INTENT(INOUT) :: qc
    REAL*8, INTENT(INOUT) :: qc_tl
    REAL*8, INTENT(INOUT) :: qp
    REAL*8, INTENT(INOUT) :: qp_tl
    REAL*8, INTENT(INOUT) :: f
    REAL*8, INTENT(INOUT) :: f_tl
    REAL*8, INTENT(IN) :: dzet
    REAL*8, INTENT(INOUT) :: vf
    REAL*8, INTENT(IN) :: sundqv2, sundqv3, sundqt1
    INTEGER :: nsmx
    REAL*8 :: acf0, acf, dtx
    REAL*8 :: c00x, iqccrx, f2, f3, rate, dqp, qcm
    REAL*8 :: c00x_tl, iqccrx_tl, f2_tl, f3_tl, rate_tl, dqp_tl, qcm_tl
    REAL*8 :: dqfac
    INTEGER :: ns, k
    INTRINSIC EXP
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC SQRT
    REAL*8 :: arg1
    REAL*8 :: arg1_tl
    REAL*8 :: result1
    REAL*8 :: result1_tl
    REAL*8 :: x1_tl
    REAL*8 :: x1
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Precip. conversion from Smith (1990,    !
!   QJRMS, 116, 435, Eq. 2.29). Similar    ! 
!   to Del Genios Eq.(10).                 !
!                                          !
!   Coalesence term needs to be determined !
!   through entire column and is done in   !
!   subroutine "ACCRETE_EVAP_PRECIP"       !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    nsmx = nsmax
    dtx = dt/nsmx
    CALL SUNDQ3_ICE3_TLM(te, te_tl, sundqv2, sundqv3, sundqt1, f2, f2_tl&
&                  , f3)
    c00x_tl = c_00*f3*f2_tl
    c00x = c_00*f2*f3
!QCcrx = LWCRIT / ( F2 * F3 )
    iqccrx_tl = f3*f2_tl/lwcrit
    iqccrx = f2*f3/lwcrit
    IF (f .GT. 0. .AND. qc .GT. 0.) THEN
      qcm_tl = (qc_tl*f-qc*f_tl)/f**2
      qcm = qc/f
    ELSE
      qcm = 0.
      qcm_tl = 0.0_8
    END IF
    arg1_tl = -(2*qcm*iqccrx*(qcm_tl*iqccrx+qcm*iqccrx_tl))
    arg1 = -((qcm*iqccrx)**2)
    rate_tl = c00x_tl*(1.0-EXP(arg1)) - c00x*arg1_tl*EXP(arg1)
    rate = c00x*(1.0-EXP(arg1))
!!! Make up a fall velocity for liquid precipitation - in analogy to falling ice,
!!!    think of the fall velocity as the ratio of autoconverted to existing condensate 
!!!    multiplied by delta z / delta t  
!!!   (ie, autoconversion/sec is related to residence time in layer)
    vf = dzet/dt*(1.0-EXP(-(rate*dt)))
!! temporary kluge until we can figure a better to make
!! thicker low clouds ( reuse arrays F2 and F3 )
    f2 = 1.0
    f3 = 1.0
! Implement ramps for gradual change in autoconv
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Thicken low high lat clouds
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IF (pl .GE. 775. .AND. te .LE. 275.) f3 = 0.2
!!!      F3 = max(-0.016 * PL + 13.4, 0.2)
    IF (pl .GE. 825. .AND. te .LE. 282.) f3 = 0.2
!!!      F3 = max(0.11 * TE - 30.02, 0.2)
    IF (pl .GE. 775. .AND. pl .LT. 825. .AND. te .LE. 282. .AND. te .GT.&
&       275.) f3 = 0.2
!!!      F3 = min(max(-0.016*PL + 0.11 * TE - 16.85, 0.2),1.)
    IF (pl .GE. 825. .AND. te .LE. 275.) f3 = 0.2
    IF (pl .LE. 775. .OR. te .GT. 282.) f3 = 1.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Thin-out low tropical clouds
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IF (pl .GE. 950. .AND. te .GE. 285.) THEN
      IF (0.2*te - 56 .GT. 2.) THEN
        f3 = 2.
        f3_tl = 0.0_8
      ELSE
        f3_tl = 0.2*te_tl
        f3 = 0.2*te - 56
      END IF
    ELSE
      f3_tl = 0.0_8
    END IF
    IF (pl .GE. 925. .AND. te .GE. 290.) THEN
      IF (0.04*pl - 36. .GT. 2.) THEN
        f3 = 2.
        f3_tl = 0.0_8
      ELSE
        f3 = 0.04*pl - 36.
        f3_tl = 0.0_8
      END IF
    END IF
    IF (pl .GE. 925. .AND. pl .LT. 950. .AND. te .GT. 285. .AND. te .LT.&
&       290.) THEN
      IF (0.04*pl + 0.2*te - 94. .GT. 2.) THEN
        x1 = 2.
        x1_tl = 0.0_8
      ELSE
        x1_tl = 0.2*te_tl
        x1 = 0.04*pl + 0.2*te - 94.
      END IF
      IF (x1 .LT. 1.) THEN
        f3 = 1.
        f3_tl = 0.0_8
      ELSE
        f3_tl = x1_tl
        f3 = x1
      END IF
    END IF
    IF (pl .GE. 950. .AND. te .GE. 290.) THEN
      f3 = 2.
      f3_tl = 0.0_8
    END IF
    IF (f3 .LT. 0.1) THEN
      f3 = 0.1
      f3_tl = 0.0_8
    ELSE
      f3 = f3
    END IF
    rate_tl = f3_tl*rate + f3*rate_tl
    rate = f3*rate
    dqp_tl = qc_tl*(1.0-EXP(-(rate*dt))) + qc*dt*rate_tl*EXP(-(rate*dt))
    dqp = qc*(1.0-EXP(-(rate*dt)))
    IF (dqp .LT. 0.0) THEN
      dqp = 0.0
      dqp_tl = 0.0_8
    ELSE
      dqp = dqp
    END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Go ahead and totally wipe-out warm fogs
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!dqfac = 0.
!if ( PL .GE. 975.  .AND. TE .GE.  280. ) then
!   dqfac = max(min(0.2 * TE - 56., 1.),0.)
!end if
!if ( PL .GE. 950.  .AND. TE .GE.  285. ) then
!   dqfac = max(min(0.04 * PL - 38., 1.),0.)
!end if
!if ( PL .GE. 950.  .AND. PL .LT. 975. .AND. TE .GT.  280. .AND. TE .LT. 285.) then
!   dqfac = max(min(0.04*PL + 0.2 * TE - 95., 1.),0.)
!end if
!if ( ( PL >= 975. ) .AND. (TE >= 285. ) ) then
!   dqfac = 1.
!end if
!dQP = max(dQP, dqfac*QC)
    qc_tl = qc_tl - dqp_tl
    qc = qc - dqp
    qp_tl = dqp_tl
    qp = qp + dqp
!SELECT CASE( FRACTION_REMOVAL )
!CASE( 0 )
! do NOTHING
    IF (fraction_removal .EQ. 1) THEN
      IF (qc + dqp .GT. 0.) THEN
        f_tl = ((qc_tl*f+qc*f_tl)*(qc+dqp)-qc*f*(qc_tl+dqp_tl))/(qc+dqp)&
&         **2
        f = qc*f/(qc+dqp)
      END IF
    ELSE IF (fraction_removal .EQ. 2) THEN
      IF (qc + dqp .GT. 0. .AND. qc .GT. 0.) THEN
        arg1_tl = (qc_tl*(qc+dqp)-qc*(qc_tl+dqp_tl))/(qc+dqp)**2
        arg1 = qc/(qc+dqp)
        IF (arg1 .EQ. 0.0_8) THEN
          result1_tl = 0.0_8
        ELSE
          result1_tl = arg1_tl/(2.0*SQRT(arg1))
        END IF
        result1 = SQRT(arg1)
        f_tl = f_tl*result1 + f*result1_tl
        f = f*result1
      END IF
    ELSE IF (fraction_removal .EQ. 3) THEN
      IF (qc + dqp .GT. 0. .AND. qc .GT. 0.) THEN
        f_tl = f_tl*(qc/(qc+dqp))**0.333 + f*0.333*(qc/(qc+dqp))**(&
&         -0.667)*(qc_tl*(qc+dqp)-qc*(qc_tl+dqp_tl))/(qc+dqp)**2
        f = f*(qc/(qc+dqp))**0.333
      END IF
    END IF
  END SUBROUTINE AUTOCON3_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE AUTOCON3(dt, qc, qp, te, pl, kh, f, sundqv2, sundqv3, &
&   sundqt1, dzet, vf, fraction_removal)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: fraction_removal
    REAL*8, INTENT(IN) :: dt
    REAL*8, INTENT(IN) :: te
    REAL*8, INTENT(IN) :: pl
    REAL*8, INTENT(IN) :: kh
    REAL*8, INTENT(INOUT) :: qc
    REAL*8, INTENT(INOUT) :: qp
    REAL*8, INTENT(INOUT) :: f
    REAL*8, INTENT(IN) :: dzet
    REAL*8, INTENT(INOUT) :: vf
    REAL*8, INTENT(IN) :: sundqv2, sundqv3, sundqt1
    INTEGER :: nsmx
    REAL*8 :: acf0, acf, dtx
    REAL*8 :: c00x, iqccrx, f2, f3, rate, dqp, qcm
    REAL*8 :: dqfac
    INTEGER :: ns, k
    INTRINSIC EXP
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC SQRT
    REAL*8 :: arg1
    REAL*8 :: result1
    REAL*8 :: x1
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Precip. conversion from Smith (1990,    !
!   QJRMS, 116, 435, Eq. 2.29). Similar    ! 
!   to Del Genios Eq.(10).                 !
!                                          !
!   Coalesence term needs to be determined !
!   through entire column and is done in   !
!   subroutine "ACCRETE_EVAP_PRECIP"       !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    nsmx = nsmax
    dtx = dt/nsmx
    CALL SUNDQ3_ICE3(te, sundqv2, sundqv3, sundqt1, f2, f3)
    c00x = c_00*f2*f3
!QCcrx = LWCRIT / ( F2 * F3 )
    iqccrx = f2*f3/lwcrit
    IF (f .GT. 0. .AND. qc .GT. 0.) THEN
      qcm = qc/f
    ELSE
      qcm = 0.
    END IF
    arg1 = -((qcm*iqccrx)**2)
    rate = c00x*(1.0-EXP(arg1))
!!! Make up a fall velocity for liquid precipitation - in analogy to falling ice,
!!!    think of the fall velocity as the ratio of autoconverted to existing condensate 
!!!    multiplied by delta z / delta t  
!!!   (ie, autoconversion/sec is related to residence time in layer)
    vf = dzet/dt*(1.0-EXP(-(rate*dt)))
!! temporary kluge until we can figure a better to make
!! thicker low clouds ( reuse arrays F2 and F3 )
    f2 = 1.0
    f3 = 1.0
! Implement ramps for gradual change in autoconv
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Thicken low high lat clouds
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IF (pl .GE. 775. .AND. te .LE. 275.) f3 = 0.2
!!!      F3 = max(-0.016 * PL + 13.4, 0.2)
    IF (pl .GE. 825. .AND. te .LE. 282.) f3 = 0.2
!!!      F3 = max(0.11 * TE - 30.02, 0.2)
    IF (pl .GE. 775. .AND. pl .LT. 825. .AND. te .LE. 282. .AND. te .GT.&
&       275.) f3 = 0.2
!!!      F3 = min(max(-0.016*PL + 0.11 * TE - 16.85, 0.2),1.)
    IF (pl .GE. 825. .AND. te .LE. 275.) f3 = 0.2
    IF (pl .LE. 775. .OR. te .GT. 282.) f3 = 1.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Thin-out low tropical clouds
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IF (pl .GE. 950. .AND. te .GE. 285.) THEN
      IF (0.2*te - 56 .GT. 2.) THEN
        f3 = 2.
      ELSE
        f3 = 0.2*te - 56
      END IF
    END IF
    IF (pl .GE. 925. .AND. te .GE. 290.) THEN
      IF (0.04*pl - 36. .GT. 2.) THEN
        f3 = 2.
      ELSE
        f3 = 0.04*pl - 36.
      END IF
    END IF
    IF (pl .GE. 925. .AND. pl .LT. 950. .AND. te .GT. 285. .AND. te .LT.&
&       290.) THEN
      IF (0.04*pl + 0.2*te - 94. .GT. 2.) THEN
        x1 = 2.
      ELSE
        x1 = 0.04*pl + 0.2*te - 94.
      END IF
      IF (x1 .LT. 1.) THEN
        f3 = 1.
      ELSE
        f3 = x1
      END IF
    END IF
    IF (pl .GE. 950. .AND. te .GE. 290.) f3 = 2.
    IF (f3 .LT. 0.1) THEN
      f3 = 0.1
    ELSE
      f3 = f3
    END IF
    rate = f3*rate
    dqp = qc*(1.0-EXP(-(rate*dt)))
    IF (dqp .LT. 0.0) THEN
      dqp = 0.0
    ELSE
      dqp = dqp
    END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Go ahead and totally wipe-out warm fogs
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!dqfac = 0.
!if ( PL .GE. 975.  .AND. TE .GE.  280. ) then
!   dqfac = max(min(0.2 * TE - 56., 1.),0.)
!end if
!if ( PL .GE. 950.  .AND. TE .GE.  285. ) then
!   dqfac = max(min(0.04 * PL - 38., 1.),0.)
!end if
!if ( PL .GE. 950.  .AND. PL .LT. 975. .AND. TE .GT.  280. .AND. TE .LT. 285.) then
!   dqfac = max(min(0.04*PL + 0.2 * TE - 95., 1.),0.)
!end if
!if ( ( PL >= 975. ) .AND. (TE >= 285. ) ) then
!   dqfac = 1.
!end if
!dQP = max(dQP, dqfac*QC)
    qc = qc - dqp
    qp = qp + dqp
!SELECT CASE( FRACTION_REMOVAL )
!CASE( 0 )
! do NOTHING
    IF (fraction_removal .EQ. 1) THEN
      IF (qc + dqp .GT. 0.) f = qc*f/(qc+dqp)
    ELSE IF (fraction_removal .EQ. 2) THEN
      IF (qc + dqp .GT. 0. .AND. qc .GT. 0.) THEN
        arg1 = qc/(qc+dqp)
        result1 = SQRT(arg1)
        f = f*result1
      END IF
    ELSE IF (fraction_removal .EQ. 3) THEN
      IF (qc + dqp .GT. 0. .AND. qc .GT. 0.) f = f*(qc/(qc+dqp))**0.333
    END IF
  END SUBROUTINE AUTOCON3
!  Differentiation of precip3 in forward (tangent) mode (with options r8):
!   variations   of useful results: pfi_above qv subl_dd_above
!                pfl_above qcl evap_dd_above te
!   with respect to varying inputs: aa area pfi_above qv subl_dd_above
!                bb pfl_above qcl qpi qpl rhcr3 dze qddf3 evap_dd_above
!                te
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device)   &
!#endif
!         RAIN         , & 
!         SNOW         , &
!         REVAP_DIAG   , &
!         RSUBL_DIAG   , &
!         ACRLL_DIAG        , &
!         ACRIL_DIAG        , &
!         PFL_DIAG     , &
!         PFI_DIAG     , &
!         VFALLRN      , &
!         VFALLSN      , &
!         FRZ_DIAG     , &
  SUBROUTINE PRECIP3_TLM(k, lm, dt, frland, rhcr3, rhcr3_tl, qpl, qpl_tl&
&   , qpi, qpi_tl, qcl, qcl_tl, qci, te, te_tl, qv, qv_tl, mass, imass, &
&   pl, dze, dze_tl, qddf3, qddf3_tl, aa, aa_tl, bb, bb_tl, area, &
&   area_tl, pfl_above, pfl_above_tl, pfi_above, pfi_above_tl, &
&   evap_dd_above, evap_dd_above_tl, subl_dd_above, subl_dd_above_tl, &
&   envfc, ddrfc)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: k, lm
    REAL*8, INTENT(IN) :: dt
    REAL*8, INTENT(INOUT) :: qv, qpl, qpi, qcl, qci, te
    REAL*8, INTENT(INOUT) :: qv_tl, qpl_tl, qpi_tl, qcl_tl, te_tl
    REAL*8, INTENT(IN) :: mass, imass
    REAL*8, INTENT(IN) :: pl
    REAL*8, INTENT(IN) :: aa, bb
    REAL*8, INTENT(IN) :: aa_tl, bb_tl
    REAL*8, INTENT(IN) :: rhcr3
    REAL*8, INTENT(IN) :: rhcr3_tl
    REAL*8, INTENT(IN) :: dze
    REAL*8, INTENT(IN) :: dze_tl
    REAL*8, INTENT(IN) :: qddf3
    REAL*8, INTENT(IN) :: qddf3_tl
!      real(8), intent(  out) :: RAIN,SNOW
    REAL*8, INTENT(IN) :: area
    REAL*8, INTENT(IN) :: area_tl
    REAL*8, INTENT(IN) :: frland
    REAL*8, INTENT(INOUT) :: pfl_above, pfi_above
    REAL*8, INTENT(INOUT) :: pfl_above_tl, pfi_above_tl
    REAL*8, INTENT(INOUT) :: evap_dd_above, subl_dd_above
    REAL*8, INTENT(INOUT) :: evap_dd_above_tl, subl_dd_above_tl
!      real(8), intent(  out) :: REVAP_DIAG
!      real(8), intent(  out) :: RSUBL_DIAG
!      real(8), intent(  out) :: ACRLL_DIAG,ACRIL_DIAG
!      real(8), intent(  out) :: PFL_DIAG, PFI_DIAG
!      real(8), intent(inout) :: FRZ_DIAG
!      real(8), intent(  out) :: VFALLSN, VFALLRN
    REAL*8, INTENT(IN) :: envfc, ddrfc
    REAL*8 :: pfi, pfl, qs, dqs, envfrac
    REAL*8 :: pfi_tl, pfl_tl, qs_tl, dqs_tl
    REAL*8 :: tko, qko, qstko, dqstko, rh_box, t_ed, qplko, qpiko
    REAL*8 :: tko_tl, qko_tl, qstko_tl, dqstko_tl, rh_box_tl, t_ed_tl
    REAL*8 :: ifactor, rainrat0, snowrat0
    REAL*8 :: ifactor_tl, rainrat0_tl, snowrat0_tl
    REAL*8 :: fallrn, fallsn, vesn, vern, nrain, nsnow, efactor
    REAL*8 :: fallrn_tl, fallsn_tl, vesn_tl, vern_tl, efactor_tl
    REAL*8 :: tinlayerrn, diamrn, droprad
    REAL*8 :: tinlayerrn_tl, diamrn_tl, droprad_tl
    REAL*8 :: tinlayersn, diamsn, flakrad
    REAL*8 :: tinlayersn_tl, diamsn_tl, flakrad_tl
    REAL*8 :: evap, subl, accr, mltfrz, evapx, sublx
    REAL*8 :: evap_tl, subl_tl, accr_tl, mltfrz_tl, evapx_tl, sublx_tl
    REAL*8 :: evap_dd, subl_dd, ddfract
    REAL*8 :: evap_dd_tl, subl_dd_tl
    REAL*8 :: landseaf
! m/s
    REAL*8, PARAMETER :: trmv_l=1.0
    REAL*8 :: tau_frz, tau_mlt
    INTEGER :: ns, nsmx, itr, l
    LOGICAL, PARAMETER :: taneff=.false.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! fraction of precip falling through "environment" vs
! through cloud
    REAL*8, PARAMETER :: b_sub=1.00
    INTRINSIC TAN
    INTRINSIC ATAN
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC EXP
    REAL*8 :: arg1
    REAL*8 :: arg1_tl
    REAL*8 :: arg2
    IF (taneff) THEN
      envfrac = 1.00
      IF (pl .LE. 600.) THEN
        envfrac = 0.25
      ELSE
        arg1 = 20.*mapl8_pi/21. - 0.5*mapl8_pi
        arg2 = (2.*(pl-600.)/(900.-600.)-1.)*TAN(arg1)
        envfrac = 0.25 + (1.-0.25)/19.*((ATAN(arg2)+0.5*mapl8_pi)*21./&
&         mapl8_pi-1.)
      END IF
      IF (envfrac .GT. 1.) THEN
        envfrac = 1.
      ELSE
        envfrac = envfrac
      END IF
    ELSE
      envfrac = envfc
    END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IF (area .GT. 0.) THEN
      ifactor_tl = -(area_tl/area**2)
      ifactor = 1./area
    ELSE
      ifactor = 1.00
      ifactor_tl = 0.0_8
    END IF
    IF (ifactor .LT. 1.) THEN
      ifactor = 1.
      ifactor_tl = 0.0_8
    ELSE
      ifactor = ifactor
    END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!   Start at top of precip column:
!  
!               a) Accrete                   
!               b) Evaporate/Sublimate  
!               c) Rain/Snow-out to next level down 
!               d) return to (a)
!
!   ....................................................................
!           
!  Accretion formulated according to Smith (1990, Q.J.R.M.S., 116, 435
!  Eq. 2.29)
!  
!  Evaporation (ibid. Eq. 2.32)
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! INITIALIZE DIAGNOSTIC ARRAYS !!!!!!!!!!!!!!!!!!!!!
!      PFL_DIAG =  0.
!      PFI_DIAG =  0.
!      ACRIL_DIAG    =  0.
!      ACRLL_DIAG    =  0.
!      REVAP_DIAG    =  0.
!      RSUBL_DIAG    =  0.
!!!!!!!!!!!!!! UPDATE SATURATED HUMIDITY  !!!!!!!!!!!!!
    CALL DQSATSCAPERT_TLM(dqs, dqs_tl, qs, qs_tl, te, te_tl, pl)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ddfract = ddrfc
    IF (k .EQ. ktop) THEN
      pfl_tl = mass*qpl_tl
      pfl = qpl*mass
      pfi_tl = mass*qpi_tl
      pfi = qpi*mass
      evap_dd = 0.
      subl_dd = 0.
!         VFALLRN = 0.0
!         VFALLSN = 0.0
      evap_dd_tl = 0.0_8
      subl_dd_tl = 0.0_8
    ELSE
      qpl_tl = qpl_tl + imass*pfl_above_tl
      qpl = qpl + pfl_above*imass
      pfl = 0.00
      qpi_tl = qpi_tl + imass*pfi_above_tl
      qpi = qpi + pfi_above*imass
      pfi = 0.00
      accr_tl = b_sub*c_acc*mass*(qpl_tl*qcl+qpl*qcl_tl)
      accr = b_sub*c_acc*(qpl*mass)*qcl
      IF (accr .GT. qcl) THEN
        accr_tl = qcl_tl
        accr = qcl
      ELSE
        accr = accr
      END IF
      qpl_tl = qpl_tl + accr_tl
      qpl = qpl + accr
      qcl_tl = qcl_tl - accr_tl
      qcl = qcl - accr
!         ACRLL_DIAG = ACCR / DT
!! Accretion of liquid condensate by falling ice/snow
      accr_tl = b_sub*c_acc*mass*(qpi_tl*qcl+qpi*qcl_tl)
      accr = b_sub*c_acc*(qpi*mass)*qcl
      IF (accr .GT. qcl) THEN
        accr_tl = qcl_tl
        accr = qcl
      ELSE
        accr = accr
      END IF
      qpi_tl = qpi_tl + accr_tl
      qpi = qpi + accr
      qcl_tl = qcl_tl - accr_tl
      qcl = qcl - accr
!! Liquid freezes when accreted by snow
      te_tl = te_tl + mapl8_alhf*accr_tl/mapl8_cp
      te = te + mapl8_alhf*accr/mapl8_cp
!        ACRIL_DIAG = ACCR / DT
      rainrat0_tl = mass*(ifactor_tl*qpl+ifactor*qpl_tl)/dt
      rainrat0 = ifactor*qpl*mass/dt
      snowrat0_tl = mass*(ifactor_tl*qpi+ifactor*qpi_tl)/dt
      snowrat0 = ifactor*qpi*mass/dt
      CALL MARSHPALMQ2_TLM(rainrat0, rainrat0_tl, pl, diamrn, diamrn_tl&
&                    , nrain, fallrn, fallrn_tl, vern, vern_tl)
      CALL MARSHPALMQ2_TLM(snowrat0, snowrat0_tl, pl, diamsn, diamsn_tl&
&                    , nsnow, fallsn, fallsn_tl, vesn, vesn_tl)
!!      DIAMsn = MAX(  DIAMsn, 1.0e-3 )   ! Over Ocean
!         VFALLRN = FALLrn
!         VFALLSN = FALLsn
      tinlayerrn_tl = (dze_tl*(fallrn+0.01)-dze*fallrn_tl)/(fallrn+0.01)&
&       **2
      tinlayerrn = dze/(fallrn+0.01)
      tinlayersn_tl = (dze_tl*(fallsn+0.01)-dze*fallsn_tl)/(fallsn+0.01)&
&       **2
      tinlayersn = dze/(fallsn+0.01)
!*****************************************
!  Melting of Frozen precipitation      
!*****************************************
! time scale for freezing (s). 
      tau_frz = 5000.
      mltfrz = 0.0
      IF (te .GT. mapl8_tice .AND. te .LE. mapl8_tice + 5.) THEN
        mltfrz_tl = ((tinlayersn_tl*qpi+tinlayersn*qpi_tl)*(te-&
&         mapl8_tice)+tinlayersn*qpi*te_tl)/tau_frz
        mltfrz = tinlayersn*qpi*(te-mapl8_tice)/tau_frz
        IF (qpi .GT. mltfrz) THEN
          mltfrz = mltfrz
        ELSE
          mltfrz_tl = qpi_tl
          mltfrz = qpi
        END IF
        te_tl = te_tl - mapl8_alhf*mltfrz_tl/mapl8_cp
        te = te - mapl8_alhf*mltfrz/mapl8_cp
        qpl_tl = qpl_tl + mltfrz_tl
        qpl = qpl + mltfrz
        qpi_tl = qpi_tl - mltfrz_tl
        qpi = qpi - mltfrz
      END IF
!         FRZ_DIAG = FRZ_DIAG - MLTFRZ / DT
      mltfrz = 0.0
      IF (te .GT. mapl8_tice + 5.) THEN
! Go Ahead and melt any snow/hail left above 5 C 
        mltfrz_tl = qpi_tl
        mltfrz = qpi
        te_tl = te_tl - mapl8_alhf*mltfrz_tl/mapl8_cp
        te = te - mapl8_alhf*mltfrz/mapl8_cp
        qpl_tl = qpl_tl + mltfrz_tl
        qpl = qpl + mltfrz
        qpi_tl = qpi_tl - mltfrz_tl
        qpi = qpi - mltfrz
      END IF
!         FRZ_DIAG = FRZ_DIAG - MLTFRZ / DT
      mltfrz = 0.0
      IF (k .GE. lm - 1) THEN
        IF (te .GT. mapl8_tice + 0.) THEN
! Go Ahead and melt any snow/hail left above 0 C in lowest layers 
          mltfrz_tl = qpi_tl
          mltfrz = qpi
          te_tl = te_tl - mapl8_alhf*mltfrz_tl/mapl8_cp
          te = te - mapl8_alhf*mltfrz/mapl8_cp
          qpl_tl = qpl_tl + mltfrz_tl
          qpl = qpl + mltfrz
          qpi_tl = qpi_tl - mltfrz_tl
          qpi = qpi - mltfrz
        END IF
      END IF
!         FRZ_DIAG = FRZ_DIAG - MLTFRZ / DT
!*****************************************
!  Freezing of liquid precipitation      
!*****************************************
      mltfrz = 0.0
      IF (te .LE. mapl8_tice) THEN
        te_tl = te_tl + mapl8_alhf*qpl_tl/mapl8_cp
        te = te + mapl8_alhf*qpl/mapl8_cp
        qpi_tl = qpl_tl + qpi_tl
        qpi = qpl + qpi
        mltfrz = qpl
        qpl = 0.
        qpl_tl = 0.0_8
      END IF
!         FRZ_DIAG = FRZ_DIAG + MLTFRZ / DT
! ******************************************
!   In the exp below, evaporation time 
!   scale is determined "microphysically"
!   from temp, press, and drop size. In this
!   context C_EV becomes a dimensionless 
!   fudge-fraction.
!   Also remember that these microphysics 
!   are still only for liquid.
! ******************************************
      qko_tl = qv_tl
      qko = qv
      tko_tl = te_tl
      tko = te
      qplko = qpl
      qpiko = qpi
      sublx_tl = 0.0_8
      evap_tl = 0.0_8
      subl_tl = 0.0_8
      evapx_tl = 0.0_8
      DO itr=1,3
        dqstko_tl = dqs_tl
        dqstko = dqs
        qstko_tl = qs_tl + dqstko_tl*(tko-te) + dqstko*(tko_tl-te_tl)
        qstko = qs + dqstko*(tko-te)
        IF (qstko .LT. 1.0e-7) THEN
          qstko = 1.0e-7
          qstko_tl = 0.0_8
        ELSE
          qstko = qstko
        END IF
        rh_box_tl = (qko_tl*qstko-qko*qstko_tl)/qstko**2
        rh_box = qko/qstko
        qko = qv
        tko = te
        IF (rh_box .LT. rhcr3) THEN
          efactor_tl = (rho_w*(aa_tl+bb_tl)*(rhcr3-rh_box)-rho_w*(aa+bb)&
&           *(rhcr3_tl-rh_box_tl))/(rhcr3-rh_box)**2
          efactor = rho_w*(aa+bb)/(rhcr3-rh_box)
        ELSE
          efactor = 9.99e9
          efactor_tl = 0.0_8
        END IF
        IF (frland .LT. 0.1) THEN
! Over Ocean
          landseaf = 0.5
        ELSE
! Over Land
          landseaf = 0.5
        END IF
        landseaf = 1.00
!!!!! RAin falling !!!!!!!!!!!!!!!!!!!!!!!
        IF (rh_box .LT. rhcr3 .AND. diamrn .GT. 0.00 .AND. pl .GT. 100. &
&           .AND. pl .LT. revap_off_p) THEN
          droprad_tl = 0.5*diamrn_tl
          droprad = 0.5*diamrn
          t_ed_tl = efactor_tl*droprad**2 + efactor*2*droprad*droprad_tl
          t_ed = efactor*droprad**2
          t_ed_tl = t_ed_tl*(1.0+dqstko*mapl8_alhl/mapl8_cp) + t_ed*&
&           mapl8_alhl*dqstko_tl/mapl8_cp
          t_ed = t_ed*(1.0+dqstko*mapl8_alhl/mapl8_cp)
          arg1_tl = -((c_ev_r*landseaf*envfrac*(vern_tl*tinlayerrn+vern*&
&           tinlayerrn_tl)*t_ed-c_ev_r*vern*landseaf*envfrac*tinlayerrn*&
&           t_ed_tl)/t_ed**2)
          arg1 = -(c_ev_r*vern*landseaf*envfrac*tinlayerrn/t_ed)
          evap_tl = qpl_tl*(1.0-EXP(arg1)) - qpl*arg1_tl*EXP(arg1)
          evap = qpl*(1.0-EXP(arg1))
        ELSE
          evap = 0.0
          evap_tl = 0.0_8
        END IF
!!!!! Snow falling !!!!!!!!!!!!!!!!!!!!!!!
        IF (rh_box .LT. rhcr3 .AND. diamsn .GT. 0.00 .AND. pl .GT. 100. &
&           .AND. pl .LT. revap_off_p) THEN
          flakrad_tl = 0.5*diamsn_tl
          flakrad = 0.5*diamsn
          t_ed_tl = efactor_tl*flakrad**2 + efactor*2*flakrad*flakrad_tl
          t_ed = efactor*flakrad**2
          t_ed_tl = t_ed_tl*(1.0+dqstko*mapl8_alhs/mapl8_cp) + t_ed*&
&           mapl8_alhs*dqstko_tl/mapl8_cp
          t_ed = t_ed*(1.0+dqstko*mapl8_alhs/mapl8_cp)
          arg1_tl = -((c_ev_s*landseaf*envfrac*(vesn_tl*tinlayersn+vesn*&
&           tinlayersn_tl)*t_ed-c_ev_s*vesn*landseaf*envfrac*tinlayersn*&
&           t_ed_tl)/t_ed**2)
          arg1 = -(c_ev_s*vesn*landseaf*envfrac*tinlayersn/t_ed)
          subl_tl = qpi_tl*(1.0-EXP(arg1)) - qpi*arg1_tl*EXP(arg1)
          subl = qpi*(1.0-EXP(arg1))
        ELSE
          subl = 0.0
          subl_tl = 0.0_8
        END IF
        IF (itr .EQ. 1) THEN
          evapx_tl = evap_tl
          evapx = evap
          sublx_tl = subl_tl
          sublx = subl
        ELSE
          evap_tl = (evap_tl+evapx_tl)/2.0
          evap = (evap+evapx)/2.0
          subl_tl = (subl_tl+sublx_tl)/2.0
          subl = (subl+sublx)/2.0
        END IF
        qko_tl = qv_tl + evap_tl + subl_tl
        qko = qv + evap + subl
        tko_tl = te_tl - mapl8_alhl*evap_tl/mapl8_cp - mapl8_alhs*&
&         subl_tl/mapl8_cp
        tko = te - evap*mapl8_alhl/mapl8_cp - subl*mapl8_alhs/mapl8_cp
      END DO
      qpi_tl = qpi_tl - subl_tl
      qpi = qpi - subl
      qpl_tl = qpl_tl - evap_tl
      qpl = qpl - evap
!! Put some re-evap/re-subl precip in to a \quote{downdraft} to be applied later
      evap_dd_tl = evap_dd_above_tl + ddfract*mass*evap_tl
      evap_dd = evap_dd_above + ddfract*evap*mass
      evap_tl = evap_tl - ddfract*evap_tl
      evap = evap - ddfract*evap
      subl_dd_tl = subl_dd_above_tl + ddfract*mass*subl_tl
      subl_dd = subl_dd_above + ddfract*subl*mass
      subl_tl = subl_tl - ddfract*subl_tl
      subl = subl - ddfract*subl
! -----
      qv_tl = qv_tl + evap_tl + subl_tl
      qv = qv + evap + subl
      te_tl = te_tl - mapl8_alhl*evap_tl/mapl8_cp - mapl8_alhs*subl_tl/&
&       mapl8_cp
      te = te - evap*mapl8_alhl/mapl8_cp - subl*mapl8_alhs/mapl8_cp
!         REVAP_DIAG = EVAP / DT
!         RSUBL_DIAG = SUBL / DT
      pfl_tl = mass*qpl_tl
      pfl = qpl*mass
      pfi_tl = mass*qpi_tl
      pfi = qpi*mass
!         PFL_DIAG =  PFl/DT
!         PFI_DIAG =  PFi/DT
    END IF
! QDDF3 (<= QDDF3_dev) is calculated on the CPU in order to avoid
! the reverse loop on GPUs and thus save local memory use.
    evap_tl = (qddf3_tl*evap_dd+qddf3*evap_dd_tl)/mass
    evap = qddf3*evap_dd/mass
    subl_tl = (qddf3_tl*subl_dd+qddf3*subl_dd_tl)/mass
    subl = qddf3*subl_dd/mass
    qv_tl = qv_tl + evap_tl + subl_tl
    qv = qv + evap + subl
    te_tl = te_tl - mapl8_alhl*evap_tl/mapl8_cp - mapl8_alhs*subl_tl/&
&     mapl8_cp
    te = te - evap*mapl8_alhl/mapl8_cp - subl*mapl8_alhs/mapl8_cp
!      REVAP_DIAG = REVAP_DIAG + EVAP / DT
!      RSUBL_DIAG = RSUBL_DIAG + SUBL / DT
!      IF (K == LM) THEN
!         RAIN  = PFl/DT
!         SNOW  = PFi/DT
!      END IF
    qpi = 0.
    qpl = 0.
    pfl_above_tl = pfl_tl
    pfl_above = pfl
    pfi_above_tl = pfi_tl
    pfi_above = pfi
    evap_dd_above_tl = evap_dd_tl
    evap_dd_above = evap_dd
    subl_dd_above_tl = subl_dd_tl
    subl_dd_above = subl_dd
  END SUBROUTINE PRECIP3_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device)   &
!#endif
!         RAIN         , & 
!         SNOW         , &
!         REVAP_DIAG   , &
!         RSUBL_DIAG   , &
!         ACRLL_DIAG        , &
!         ACRIL_DIAG        , &
!         PFL_DIAG     , &
!         PFI_DIAG     , &
!         VFALLRN      , &
!         VFALLSN      , &
!         FRZ_DIAG     , &
  SUBROUTINE PRECIP3(k, lm, dt, frland, rhcr3, qpl, qpi, qcl, qci, te, &
&   qv, mass, imass, pl, dze, qddf3, aa, bb, area, pfl_above, pfi_above&
&   , evap_dd_above, subl_dd_above, envfc, ddrfc)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: k, lm
    REAL*8, INTENT(IN) :: dt
    REAL*8, INTENT(INOUT) :: qv, qpl, qpi, qcl, qci, te
    REAL*8, INTENT(IN) :: mass, imass
    REAL*8, INTENT(IN) :: pl
    REAL*8, INTENT(IN) :: aa, bb
    REAL*8, INTENT(IN) :: rhcr3
    REAL*8, INTENT(IN) :: dze
    REAL*8, INTENT(IN) :: qddf3
!      real(8), intent(  out) :: RAIN,SNOW
    REAL*8, INTENT(IN) :: area
    REAL*8, INTENT(IN) :: frland
    REAL*8, INTENT(INOUT) :: pfl_above, pfi_above
    REAL*8, INTENT(INOUT) :: evap_dd_above, subl_dd_above
!      real(8), intent(  out) :: REVAP_DIAG
!      real(8), intent(  out) :: RSUBL_DIAG
!      real(8), intent(  out) :: ACRLL_DIAG,ACRIL_DIAG
!      real(8), intent(  out) :: PFL_DIAG, PFI_DIAG
!      real(8), intent(inout) :: FRZ_DIAG
!      real(8), intent(  out) :: VFALLSN, VFALLRN
    REAL*8, INTENT(IN) :: envfc, ddrfc
    REAL*8 :: pfi, pfl, qs, dqs, envfrac
    REAL*8 :: tko, qko, qstko, dqstko, rh_box, t_ed, qplko, qpiko
    REAL*8 :: ifactor, rainrat0, snowrat0
    REAL*8 :: fallrn, fallsn, vesn, vern, nrain, nsnow, efactor
    REAL*8 :: tinlayerrn, diamrn, droprad
    REAL*8 :: tinlayersn, diamsn, flakrad
    REAL*8 :: evap, subl, accr, mltfrz, evapx, sublx
    REAL*8 :: evap_dd, subl_dd, ddfract
    REAL*8 :: landseaf
! m/s
    REAL*8, PARAMETER :: trmv_l=1.0
    REAL*8 :: tau_frz, tau_mlt
    INTEGER :: ns, nsmx, itr, l
    LOGICAL, PARAMETER :: taneff=.false.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! fraction of precip falling through "environment" vs
! through cloud
    REAL*8, PARAMETER :: b_sub=1.00
    INTRINSIC TAN
    INTRINSIC ATAN
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC EXP
    REAL*8 :: arg1
    REAL*8 :: arg2
    IF (taneff) THEN
      envfrac = 1.00
      IF (pl .LE. 600.) THEN
        envfrac = 0.25
      ELSE
        arg1 = 20.*mapl8_pi/21. - 0.5*mapl8_pi
        arg2 = (2.*(pl-600.)/(900.-600.)-1.)*TAN(arg1)
        envfrac = 0.25 + (1.-0.25)/19.*((ATAN(arg2)+0.5*mapl8_pi)*21./&
&         mapl8_pi-1.)
      END IF
      IF (envfrac .GT. 1.) THEN
        envfrac = 1.
      ELSE
        envfrac = envfrac
      END IF
    ELSE
      envfrac = envfc
    END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IF (area .GT. 0.) THEN
      ifactor = 1./area
    ELSE
      ifactor = 1.00
    END IF
    IF (ifactor .LT. 1.) THEN
      ifactor = 1.
    ELSE
      ifactor = ifactor
    END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!   Start at top of precip column:
!  
!               a) Accrete                   
!               b) Evaporate/Sublimate  
!               c) Rain/Snow-out to next level down 
!               d) return to (a)
!
!   ....................................................................
!           
!  Accretion formulated according to Smith (1990, Q.J.R.M.S., 116, 435
!  Eq. 2.29)
!  
!  Evaporation (ibid. Eq. 2.32)
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! INITIALIZE DIAGNOSTIC ARRAYS !!!!!!!!!!!!!!!!!!!!!
!      PFL_DIAG =  0.
!      PFI_DIAG =  0.
!      ACRIL_DIAG    =  0.
!      ACRLL_DIAG    =  0.
!      REVAP_DIAG    =  0.
!      RSUBL_DIAG    =  0.
!!!!!!!!!!!!!! UPDATE SATURATED HUMIDITY  !!!!!!!!!!!!!
    CALL DQSATSCAPERT(dqs, qs, te, pl)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ddfract = ddrfc
    IF (k .EQ. ktop) THEN
      pfl = qpl*mass
      pfi = qpi*mass
      evap_dd = 0.
      subl_dd = 0.
!         VFALLRN = 0.0
!         VFALLSN = 0.0
    ELSE
      qpl = qpl + pfl_above*imass
      pfl = 0.00
      qpi = qpi + pfi_above*imass
      pfi = 0.00
      accr = b_sub*c_acc*(qpl*mass)*qcl
      IF (accr .GT. qcl) THEN
        accr = qcl
      ELSE
        accr = accr
      END IF
      qpl = qpl + accr
      qcl = qcl - accr
!         ACRLL_DIAG = ACCR / DT
!! Accretion of liquid condensate by falling ice/snow
      accr = b_sub*c_acc*(qpi*mass)*qcl
      IF (accr .GT. qcl) THEN
        accr = qcl
      ELSE
        accr = accr
      END IF
      qpi = qpi + accr
      qcl = qcl - accr
!! Liquid freezes when accreted by snow
      te = te + mapl8_alhf*accr/mapl8_cp
!        ACRIL_DIAG = ACCR / DT
      rainrat0 = ifactor*qpl*mass/dt
      snowrat0 = ifactor*qpi*mass/dt
      CALL MARSHPALMQ2(rainrat0, pl, diamrn, nrain, fallrn, vern)
      CALL MARSHPALMQ2(snowrat0, pl, diamsn, nsnow, fallsn, vesn)
!!      DIAMsn = MAX(  DIAMsn, 1.0e-3 )   ! Over Ocean
!         VFALLRN = FALLrn
!         VFALLSN = FALLsn
      tinlayerrn = dze/(fallrn+0.01)
      tinlayersn = dze/(fallsn+0.01)
!*****************************************
!  Melting of Frozen precipitation      
!*****************************************
! time scale for freezing (s). 
      tau_frz = 5000.
      mltfrz = 0.0
      IF (te .GT. mapl8_tice .AND. te .LE. mapl8_tice + 5.) THEN
        mltfrz = tinlayersn*qpi*(te-mapl8_tice)/tau_frz
        IF (qpi .GT. mltfrz) THEN
          mltfrz = mltfrz
        ELSE
          mltfrz = qpi
        END IF
        te = te - mapl8_alhf*mltfrz/mapl8_cp
        qpl = qpl + mltfrz
        qpi = qpi - mltfrz
      END IF
!         FRZ_DIAG = FRZ_DIAG - MLTFRZ / DT
      mltfrz = 0.0
      IF (te .GT. mapl8_tice + 5.) THEN
! Go Ahead and melt any snow/hail left above 5 C 
        mltfrz = qpi
        te = te - mapl8_alhf*mltfrz/mapl8_cp
        qpl = qpl + mltfrz
        qpi = qpi - mltfrz
      END IF
!         FRZ_DIAG = FRZ_DIAG - MLTFRZ / DT
      mltfrz = 0.0
      IF (k .GE. lm - 1) THEN
        IF (te .GT. mapl8_tice + 0.) THEN
! Go Ahead and melt any snow/hail left above 0 C in lowest layers 
          mltfrz = qpi
          te = te - mapl8_alhf*mltfrz/mapl8_cp
          qpl = qpl + mltfrz
          qpi = qpi - mltfrz
        END IF
      END IF
!         FRZ_DIAG = FRZ_DIAG - MLTFRZ / DT
!*****************************************
!  Freezing of liquid precipitation      
!*****************************************
      mltfrz = 0.0
      IF (te .LE. mapl8_tice) THEN
        te = te + mapl8_alhf*qpl/mapl8_cp
        qpi = qpl + qpi
        mltfrz = qpl
        qpl = 0.
      END IF
!         FRZ_DIAG = FRZ_DIAG + MLTFRZ / DT
! ******************************************
!   In the exp below, evaporation time 
!   scale is determined "microphysically"
!   from temp, press, and drop size. In this
!   context C_EV becomes a dimensionless 
!   fudge-fraction.
!   Also remember that these microphysics 
!   are still only for liquid.
! ******************************************
      qko = qv
      tko = te
      qplko = qpl
      qpiko = qpi
      DO itr=1,3
        dqstko = dqs
        qstko = qs + dqstko*(tko-te)
        IF (qstko .LT. 1.0e-7) THEN
          qstko = 1.0e-7
        ELSE
          qstko = qstko
        END IF
        rh_box = qko/qstko
        qko = qv
        tko = te
        IF (rh_box .LT. rhcr3) THEN
          efactor = rho_w*(aa+bb)/(rhcr3-rh_box)
        ELSE
          efactor = 9.99e9
        END IF
        IF (frland .LT. 0.1) THEN
! Over Ocean
          landseaf = 0.5
        ELSE
! Over Land
          landseaf = 0.5
        END IF
        landseaf = 1.00
!!!!! RAin falling !!!!!!!!!!!!!!!!!!!!!!!
        IF (rh_box .LT. rhcr3 .AND. diamrn .GT. 0.00 .AND. pl .GT. 100. &
&           .AND. pl .LT. revap_off_p) THEN
          droprad = 0.5*diamrn
          t_ed = efactor*droprad**2
          t_ed = t_ed*(1.0+dqstko*mapl8_alhl/mapl8_cp)
          arg1 = -(c_ev_r*vern*landseaf*envfrac*tinlayerrn/t_ed)
          evap = qpl*(1.0-EXP(arg1))
        ELSE
          evap = 0.0
        END IF
!!!!! Snow falling !!!!!!!!!!!!!!!!!!!!!!!
        IF (rh_box .LT. rhcr3 .AND. diamsn .GT. 0.00 .AND. pl .GT. 100. &
&           .AND. pl .LT. revap_off_p) THEN
          flakrad = 0.5*diamsn
          t_ed = efactor*flakrad**2
          t_ed = t_ed*(1.0+dqstko*mapl8_alhs/mapl8_cp)
          arg1 = -(c_ev_s*vesn*landseaf*envfrac*tinlayersn/t_ed)
          subl = qpi*(1.0-EXP(arg1))
        ELSE
          subl = 0.0
        END IF
        IF (itr .EQ. 1) THEN
          evapx = evap
          sublx = subl
        ELSE
          evap = (evap+evapx)/2.0
          subl = (subl+sublx)/2.0
        END IF
        qko = qv + evap + subl
        tko = te - evap*mapl8_alhl/mapl8_cp - subl*mapl8_alhs/mapl8_cp
      END DO
      qpi = qpi - subl
      qpl = qpl - evap
!! Put some re-evap/re-subl precip in to a \quote{downdraft} to be applied later
      evap_dd = evap_dd_above + ddfract*evap*mass
      evap = evap - ddfract*evap
      subl_dd = subl_dd_above + ddfract*subl*mass
      subl = subl - ddfract*subl
! -----
      qv = qv + evap + subl
      te = te - evap*mapl8_alhl/mapl8_cp - subl*mapl8_alhs/mapl8_cp
!         REVAP_DIAG = EVAP / DT
!         RSUBL_DIAG = SUBL / DT
      pfl = qpl*mass
      pfi = qpi*mass
!         PFL_DIAG =  PFl/DT
!         PFI_DIAG =  PFi/DT
    END IF
! QDDF3 (<= QDDF3_dev) is calculated on the CPU in order to avoid
! the reverse loop on GPUs and thus save local memory use.
    evap = qddf3*evap_dd/mass
    subl = qddf3*subl_dd/mass
    qv = qv + evap + subl
    te = te - evap*mapl8_alhl/mapl8_cp - subl*mapl8_alhs/mapl8_cp
!      REVAP_DIAG = REVAP_DIAG + EVAP / DT
!      RSUBL_DIAG = RSUBL_DIAG + SUBL / DT
!      IF (K == LM) THEN
!         RAIN  = PFl/DT
!         SNOW  = PFi/DT
!      END IF
    qpi = 0.
    qpl = 0.
    pfl_above = pfl
    pfi_above = pfi
    evap_dd_above = evap_dd
    subl_dd_above = subl_dd
  END SUBROUTINE PRECIP3
!  Differentiation of icefall in forward (tangent) mode (with options r8):
!   variations   of useful results: f qi qp
!   with respect to varying inputs: f qi dz vf
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE ICEFALL_TLM(qi, qi_tl, dz, dz_tl, qp, qp_tl, vf, vf_tl, f, &
&   f_tl, dt, fraction_removal)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: fraction_removal
    REAL*8, INTENT(INOUT) :: qi
    REAL*8, INTENT(INOUT) :: qi_tl
    REAL*8, INTENT(IN) :: dz
    REAL*8, INTENT(IN) :: dz_tl
    REAL*8, INTENT(INOUT) :: qp
    REAL*8, INTENT(INOUT) :: qp_tl
    REAL*8, INTENT(IN) :: vf
    REAL*8, INTENT(IN) :: vf_tl
    REAL*8, INTENT(INOUT) :: f
    REAL*8, INTENT(INOUT) :: f_tl
    REAL*8, INTENT(IN) :: dt
    REAL*8 :: qixp
    REAL*8 :: qixp_tl
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC SQRT
    REAL*8 :: arg1
    REAL*8 :: arg1_tl
    REAL*8 :: result1
    REAL*8 :: result1_tl
    qixp_tl = qi_tl*vf*dt/dz + qi*(dt*vf_tl*dz-vf*dt*dz_tl)/dz**2
    qixp = qi*(vf*dt/dz)
    IF (qixp .GT. qi) THEN
      qixp_tl = qi_tl
      qixp = qi
    ELSE
      qixp = qixp
    END IF
    IF (qixp .LT. 0.0) THEN
      qixp = 0.0
      qixp_tl = 0.0_8
    ELSE
      qixp = qixp
    END IF
    qp_tl = qixp_tl
    qp = qp + qixp
    qi_tl = qi_tl - qixp_tl
    qi = qi - qixp
!SELECT CASE( FRACTION_REMOVAL )
!CASE( 0 )
! do NOTHING
    IF (fraction_removal .EQ. 1) THEN
      IF (qi + qixp .GT. 0.) THEN
        f_tl = ((qi_tl*f+qi*f_tl)*(qi+qixp)-qi*f*(qi_tl+qixp_tl))/(qi+&
&         qixp)**2
        f = qi*f/(qi+qixp)
      END IF
    ELSE IF (fraction_removal .EQ. 2) THEN
      IF (qi + qixp .GT. 0. .AND. qi .GT. 0.) THEN
        arg1_tl = (qi_tl*(qi+qixp)-qi*(qi_tl+qixp_tl))/(qi+qixp)**2
        arg1 = qi/(qi+qixp)
        IF (arg1 .EQ. 0.0_8) THEN
          result1_tl = 0.0_8
        ELSE
          result1_tl = arg1_tl/(2.0*SQRT(arg1))
        END IF
        result1 = SQRT(arg1)
        f_tl = f_tl*result1 + f*result1_tl
        f = f*result1
      END IF
    ELSE IF (fraction_removal .EQ. 3) THEN
      IF (qi + qixp .GT. 0. .AND. qi .GT. 0.) THEN
        f_tl = f_tl*(qi/(qi+qixp))**0.333 + f*0.333*(qi/(qi+qixp))**(&
&         -0.667)*(qi_tl*(qi+qixp)-qi*(qi_tl+qixp_tl))/(qi+qixp)**2
        f = f*(qi/(qi+qixp))**0.333
      END IF
    END IF
  END SUBROUTINE ICEFALL_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE ICEFALL(qi, dz, qp, vf, f, dt, fraction_removal)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: fraction_removal
    REAL*8, INTENT(INOUT) :: qi
    REAL*8, INTENT(IN) :: dz
    REAL*8, INTENT(INOUT) :: qp
    REAL*8, INTENT(IN) :: vf
    REAL*8, INTENT(INOUT) :: f
    REAL*8, INTENT(IN) :: dt
    REAL*8 :: qixp
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC SQRT
    REAL*8 :: arg1
    REAL*8 :: result1
    qixp = qi*(vf*dt/dz)
    IF (qixp .GT. qi) THEN
      qixp = qi
    ELSE
      qixp = qixp
    END IF
    IF (qixp .LT. 0.0) THEN
      qixp = 0.0
    ELSE
      qixp = qixp
    END IF
    qp = qp + qixp
    qi = qi - qixp
!SELECT CASE( FRACTION_REMOVAL )
!CASE( 0 )
! do NOTHING
    IF (fraction_removal .EQ. 1) THEN
      IF (qi + qixp .GT. 0.) f = qi*f/(qi+qixp)
    ELSE IF (fraction_removal .EQ. 2) THEN
      IF (qi + qixp .GT. 0. .AND. qi .GT. 0.) THEN
        arg1 = qi/(qi+qixp)
        result1 = SQRT(arg1)
        f = f*result1
      END IF
    ELSE IF (fraction_removal .EQ. 3) THEN
      IF (qi + qixp .GT. 0. .AND. qi .GT. 0.) f = f*(qi/(qi+qixp))**&
&         0.333
    END IF
  END SUBROUTINE ICEFALL
!  Differentiation of settle_vel in forward (tangent) mode (with options r8):
!   variations   of useful results: vf
!   with respect to varying inputs: f qi te
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE SETTLE_VEL_TLM(wxr, qi, qi_tl, pl, te, te_tl, f, f_tl, kh, &
&   vf, vf_tl, largescale, anvil)
    IMPLICIT NONE
! Arctic stratus options
!if ( KH > 2.0 ) then
!   VF = 0.01 * VF
!end if
!where(PL > 700.)
!  VF = 0.1*VF
!endwhere
!where( (TE >= 250.) .and. (TE<260.))
!  VF =  ( ( -0.75/10.)*(TE-250.) + 1.0 ) * VF
!endwhere
!where(TE >= 260.)
!  VF = 0.25*VF
!endwhere
    REAL*8, INTENT(IN) :: wxr
    REAL*8, INTENT(IN) :: te
    REAL*8, INTENT(IN) :: te_tl
    REAL*8, INTENT(IN) :: qi, f, pl
    REAL*8, INTENT(IN) :: qi_tl, f_tl
    REAL*8, INTENT(IN) :: kh
    REAL*8, INTENT(OUT) :: vf
    REAL*8, INTENT(OUT) :: vf_tl
    REAL*8, INTENT(IN) :: anvil, largescale
    REAL*8 :: rho, xim, lxim, vf_a, vf_l
    REAL*8 :: rho_tl, xim_tl, lxim_tl, vf_a_tl, vf_l_tl
    INTRINSIC LOG10
    INTRINSIC ABS
    INTRINSIC MAX
    REAL*8 :: pwx1
    REAL*8 :: pwr1
    REAL*8 :: abs0
    REAL*8 :: max1
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
! Uses Eq. 1 Lawrence and Crutzen (1998, Tellus 50B, 263-289) 
! Except midlat form is taken to be for LS cloud, and tropical
! form is taken to be for ANVIL cloud
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 1000 TAKES TO g m^-3 ; 100 takes mb TO Pa
    rho_tl = -(1000.*100.*pl*mapl8_rgas*te_tl/(mapl8_rgas*te)**2)
    rho = 1000.*100.*pl/(mapl8_rgas*te)
    IF (f .GT. 0. .AND. qi .GT. 0.) THEN
      xim_tl = (qi_tl*f-qi*f_tl)*rho/f**2 + qi*rho_tl/f
      xim = qi/f*rho
    ELSE
      xim = 0.
      xim_tl = 0.0_8
    END IF
    IF (xim .GT. 0.) THEN
      lxim_tl = xim_tl/(xim*LOG(10.0))
      lxim = LOG10(xim)
    ELSE
      lxim = 0.0
      lxim_tl = 0.0_8
    END IF
! Tropical ANVIL produced by resolved scale motions
    vf_a_tl = 53.2*lxim_tl + 5.5*2*lxim*lxim_tl
    vf_a = 128.6 + 53.2*lxim + 5.5*lxim**2
! Mid-latitude cirrus
    vf_l = 109.0*xim**0.16
    IF (xim .GE. 0.) THEN
      abs0 = xim
    ELSE
      abs0 = -xim
    END IF
    IF (abs0 .GT. 0.0) THEN
!Linearisation security
      vf_l_tl = 109.0*0.16*xim**(-0.84)*xim_tl
      vf_l = 109.0*xim**0.16
    ELSE
      vf_l = 0.0
      vf_l_tl = 0.0_8
    END IF
! Combine the two
    vf_tl = anvil*vf_a_tl + largescale*vf_l_tl
    vf = anvil*vf_a + largescale*vf_l
! Reduce/increase fall speeds for high/low pressure (NOT in LC98!!! ) 
! Assume unmodified they represent situation at 100 mb
    IF (wxr .GT. 0.) THEN
      IF (pl .LT. 10.) THEN
        max1 = 10.
      ELSE
        max1 = pl
      END IF
      pwx1 = 100./max1
      pwr1 = pwx1**wxr
      vf_tl = pwr1*vf_tl
      vf = vf*pwr1
    END IF
    vf_tl = vf_tl/100.
    vf = vf/100.
    IF (kh .GT. 2.0) THEN
      vf_tl = 0.01*vf_tl
      vf = 0.01*vf
    END IF
  END SUBROUTINE SETTLE_VEL_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE SETTLE_VEL(wxr, qi, pl, te, f, kh, vf, largescale, anvil)
    IMPLICIT NONE
! Arctic stratus options
!if ( KH > 2.0 ) then
!   VF = 0.01 * VF
!end if
!where(PL > 700.)
!  VF = 0.1*VF
!endwhere
!where( (TE >= 250.) .and. (TE<260.))
!  VF =  ( ( -0.75/10.)*(TE-250.) + 1.0 ) * VF
!endwhere
!where(TE >= 260.)
!  VF = 0.25*VF
!endwhere
    REAL*8, INTENT(IN) :: wxr
    REAL*8, INTENT(IN) :: te
    REAL*8, INTENT(IN) :: qi, f, pl
    REAL*8, INTENT(IN) :: kh
    REAL*8, INTENT(OUT) :: vf
    REAL*8, INTENT(IN) :: anvil, largescale
    REAL*8 :: rho, xim, lxim, vf_a, vf_l
    INTRINSIC LOG10
    INTRINSIC ABS
    INTRINSIC MAX
    REAL*8 :: pwx1
    REAL*8 :: pwr1
    REAL*8 :: abs0
    REAL*8 :: max1
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
! Uses Eq. 1 Lawrence and Crutzen (1998, Tellus 50B, 263-289) 
! Except midlat form is taken to be for LS cloud, and tropical
! form is taken to be for ANVIL cloud
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 1000 TAKES TO g m^-3 ; 100 takes mb TO Pa
    rho = 1000.*100.*pl/(mapl8_rgas*te)
    IF (f .GT. 0. .AND. qi .GT. 0.) THEN
      xim = qi/f*rho
    ELSE
      xim = 0.
    END IF
    IF (xim .GT. 0.) THEN
      lxim = LOG10(xim)
    ELSE
      lxim = 0.0
    END IF
! Tropical ANVIL produced by resolved scale motions
    vf_a = 128.6 + 53.2*lxim + 5.5*lxim**2
! Mid-latitude cirrus
    vf_l = 109.0*xim**0.16
    IF (xim .GE. 0.) THEN
      abs0 = xim
    ELSE
      abs0 = -xim
    END IF
    IF (abs0 .GT. 0.0) THEN
!Linearisation security
      vf_l = 109.0*xim**0.16
    ELSE
      vf_l = 0.0
    END IF
! Combine the two
    vf = anvil*vf_a + largescale*vf_l
! Reduce/increase fall speeds for high/low pressure (NOT in LC98!!! ) 
! Assume unmodified they represent situation at 100 mb
    IF (wxr .GT. 0.) THEN
      IF (pl .LT. 10.) THEN
        max1 = 10.
      ELSE
        max1 = pl
      END IF
      pwx1 = 100./max1
      pwr1 = pwx1**wxr
      vf = vf*pwr1
    END IF
    vf = vf/100.
    IF (kh .GT. 2.0) vf = 0.01*vf
  END SUBROUTINE SETTLE_VEL
!  Differentiation of marshpalmq2 in forward (tangent) mode (with options r8):
!   variations   of useful results: diam3 w ve
!   with respect to varying inputs: rain
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE MARSHPALMQ2_TLM(rain, rain_tl, pr, diam3, diam3_tl, ntotal&
&   , w, w_tl, ve, ve_tl)
    IMPLICIT NONE
! in kg m**-2 s**-1, mbar
    REAL*8, INTENT(IN) :: rain, pr
    REAL*8, INTENT(IN) :: rain_tl
    REAL*8, INTENT(OUT) :: diam3, ntotal, w, ve
    REAL*8, INTENT(OUT) :: diam3_tl, w_tl, ve_tl
    REAL*8 :: rain_day, lambda, a, b, slopr, diam1
    REAL*8 :: rain_day_tl
! # cm**-3
    REAL*8, PARAMETER :: n0=0.08
    INTEGER :: iqd
    REAL*8 :: rx(8), d3x(8)
    INTRINSIC SQRT
    INTRINSIC MAX
    REAL*8 :: result1
! Marshall-Palmer sizes at different rain-rates: avg(D^3)
!RX = (/ 0.   , 5.   , 20.  , 80.  , 320. , 1280., 4*1280., 16*1280. /)  ! rain per in mm/day
    rx(1) = 0.
    rx(2) = 5.
    rx(3) = 20.
    rx(4) = 80.
    rx(5) = 320.
    rx(6) = 1280.
    rx(7) = 4*1280.
    rx(8) = 16*1280.
!D3X= (/ 0.019, 0.032, 0.043, 0.057, 0.076, 0.102, 0.137  ,  0.183   /)
    d3x(1) = 0.019
    d3x(2) = 0.032
    d3x(3) = 0.043
    d3x(4) = 0.057
    d3x(5) = 0.076
    d3x(6) = 0.102
    d3x(7) = 0.137
    d3x(8) = 0.183
    rain_day_tl = 3600.*24.*rain_tl
    rain_day = rain*3600.*24.
    IF (rain_day .LE. 0.00) THEN
      diam1 = 0.00
      diam3 = 0.00
      ntotal = 0.00
      w = 0.00
      diam3_tl = 0.0_8
    ELSE
      diam3_tl = 0.0_8
    END IF
    DO iqd=1,7
      IF (rain_day .LE. rx(iqd+1) .AND. rain_day .GT. rx(iqd)) THEN
        slopr = (d3x(iqd+1)-d3x(iqd))/(rx(iqd+1)-rx(iqd))
        diam3_tl = slopr*rain_day_tl
        diam3 = d3x(iqd) + (rain_day-rx(iqd))*slopr
      END IF
    END DO
    IF (rain_day .GE. rx(8)) THEN
      diam3 = d3x(8)
      diam3_tl = 0.0_8
    END IF
    ntotal = 0.019*diam3
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!  DRYING/EVAP SHOULD PROBABLY GO AS          !!
    diam3_tl = 0.664*diam3_tl
    diam3 = 0.664*diam3
!!  D_1.5 == <<D^(3/2)>>^(2/3) NOT AS          !!
!!  D_3   == <<D^3>>^(1/3)                     !!
!!  RATIO D_1.5/D_3 =~ 0.66  (JTB 10/17/2002)  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    result1 = SQRT(1000./pr)
    w_tl = result1*2483.8*diam3_tl
    w = (2483.8*diam3+80.)*result1
    IF (0.99*w/100. .LT. 1.000) THEN
      ve = 1.000
      ve_tl = 0.0_8
    ELSE
      ve_tl = 0.99*w_tl/100.
      ve = 0.99*w/100.
    END IF
    diam1 = 3.0*diam3
!  Change back to MKS units
    diam1 = diam1/100.
    diam3_tl = diam3_tl/100.
    diam3 = diam3/100.
    w_tl = w_tl/100.
    w = w/100.
    ntotal = ntotal*1.0e6
  END SUBROUTINE MARSHPALMQ2_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE MARSHPALMQ2(rain, pr, diam3, ntotal, w, ve)
    IMPLICIT NONE
! in kg m**-2 s**-1, mbar
    REAL*8, INTENT(IN) :: rain, pr
    REAL*8, INTENT(OUT) :: diam3, ntotal, w, ve
    REAL*8 :: rain_day, lambda, a, b, slopr, diam1
! # cm**-3
    REAL*8, PARAMETER :: n0=0.08
    INTEGER :: iqd
    REAL*8 :: rx(8), d3x(8)
    INTRINSIC SQRT
    INTRINSIC MAX
    REAL*8 :: result1
! Marshall-Palmer sizes at different rain-rates: avg(D^3)
!RX = (/ 0.   , 5.   , 20.  , 80.  , 320. , 1280., 4*1280., 16*1280. /)  ! rain per in mm/day
    rx(1) = 0.
    rx(2) = 5.
    rx(3) = 20.
    rx(4) = 80.
    rx(5) = 320.
    rx(6) = 1280.
    rx(7) = 4*1280.
    rx(8) = 16*1280.
!D3X= (/ 0.019, 0.032, 0.043, 0.057, 0.076, 0.102, 0.137  ,  0.183   /)
    d3x(1) = 0.019
    d3x(2) = 0.032
    d3x(3) = 0.043
    d3x(4) = 0.057
    d3x(5) = 0.076
    d3x(6) = 0.102
    d3x(7) = 0.137
    d3x(8) = 0.183
    rain_day = rain*3600.*24.
    IF (rain_day .LE. 0.00) THEN
      diam1 = 0.00
      diam3 = 0.00
      ntotal = 0.00
      w = 0.00
    END IF
    DO iqd=1,7
      IF (rain_day .LE. rx(iqd+1) .AND. rain_day .GT. rx(iqd)) THEN
        slopr = (d3x(iqd+1)-d3x(iqd))/(rx(iqd+1)-rx(iqd))
        diam3 = d3x(iqd) + (rain_day-rx(iqd))*slopr
      END IF
    END DO
    IF (rain_day .GE. rx(8)) diam3 = d3x(8)
    ntotal = 0.019*diam3
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!  DRYING/EVAP SHOULD PROBABLY GO AS          !!
    diam3 = 0.664*diam3
!!  D_1.5 == <<D^(3/2)>>^(2/3) NOT AS          !!
!!  D_3   == <<D^3>>^(1/3)                     !!
!!  RATIO D_1.5/D_3 =~ 0.66  (JTB 10/17/2002)  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    result1 = SQRT(1000./pr)
    w = (2483.8*diam3+80.)*result1
    IF (0.99*w/100. .LT. 1.000) THEN
      ve = 1.000
    ELSE
      ve = 0.99*w/100.
    END IF
    diam1 = 3.0*diam3
!  Change back to MKS units
    diam1 = diam1/100.
    diam3 = diam3/100.
    w = w/100.
    ntotal = ntotal*1.0e6
  END SUBROUTINE MARSHPALMQ2
!  Differentiation of micro_aa_bb_3 in forward (tangent) mode (with options r8):
!   variations   of useful results: aa bb
!   with respect to varying inputs: temp q_sat
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE MICRO_AA_BB_3_TLM(temp, temp_tl, pr, q_sat, q_sat_tl, aa, &
&   aa_tl, bb, bb_tl)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: temp, q_sat
    REAL*8, INTENT(IN) :: temp_tl, q_sat_tl
    REAL*8, INTENT(IN) :: pr
    REAL*8, INTENT(OUT) :: aa, bb
    REAL*8, INTENT(OUT) :: aa_tl, bb_tl
    REAL*8 :: e_sat
    REAL*8 :: e_sat_tl
    REAL*8, PARAMETER :: epsilon=mapl8_h2omw/mapl8_airmw
! J m**-1 s**-1 K**-1
    REAL*8, PARAMETER :: k_cond=2.4e-2
! m**2 s**-1
    REAL*8, PARAMETER :: diffu=2.2e-5
    REAL*8 :: result1
    REAL*8 :: result1_tl
! (100 converts from mbar to Pa)
    e_sat_tl = (100.*pr*q_sat_tl*(epsilon+(1.0-epsilon)*q_sat)-100.*pr*&
&     q_sat*(1.0-epsilon)*q_sat_tl)/(epsilon+(1.0-epsilon)*q_sat)**2
    e_sat = 100.*pr*q_sat/(epsilon+(1.0-epsilon)*q_sat)
    result1_tl = GET_ALHX3_TLM(temp, temp_tl, result1)
    aa_tl = (2*result1*result1_tl*k_cond*mapl8_rvap*temp**2-result1**2*&
&     k_cond*mapl8_rvap*2*temp*temp_tl)/(k_cond*mapl8_rvap*temp**2)**2
    aa = result1**2/(k_cond*mapl8_rvap*temp**2)
! AA  = ( MAPL8_ALHL**2 ) / ( K_COND*MAPL8_RVAP*(TEMP**2) )
    bb_tl = (mapl8_rvap*temp_tl*diffu*1000.*e_sat/pr-mapl8_rvap*temp*&
&     diffu*1000.*e_sat_tl/pr)/(diffu*(1000./pr)*e_sat)**2
    bb = mapl8_rvap*temp/(diffu*(1000./pr)*e_sat)
  END SUBROUTINE MICRO_AA_BB_3_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE MICRO_AA_BB_3(temp, pr, q_sat, aa, bb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: temp, q_sat
    REAL*8, INTENT(IN) :: pr
    REAL*8, INTENT(OUT) :: aa, bb
    REAL*8 :: e_sat
    REAL*8, PARAMETER :: epsilon=mapl8_h2omw/mapl8_airmw
! J m**-1 s**-1 K**-1
    REAL*8, PARAMETER :: k_cond=2.4e-2
! m**2 s**-1
    REAL*8, PARAMETER :: diffu=2.2e-5
    REAL*8 :: result1
! (100 converts from mbar to Pa)
    e_sat = 100.*pr*q_sat/(epsilon+(1.0-epsilon)*q_sat)
    result1 = GET_ALHX3(temp)
    aa = result1**2/(k_cond*mapl8_rvap*temp**2)
! AA  = ( MAPL8_ALHL**2 ) / ( K_COND*MAPL8_RVAP*(TEMP**2) )
    bb = mapl8_rvap*temp/(diffu*(1000./pr)*e_sat)
  END SUBROUTINE MICRO_AA_BB_3
!  Differentiation of ldradius3 in forward (tangent) mode (with options r8):
!   variations   of useful results: radius
!   with respect to varying inputs: qcl te
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  FUNCTION LDRADIUS3_TLM(pl, te, te_tl, qcl, qcl_tl, nn, radius) RESULT &
& (RADIUS_TL)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: te, pl, nn, qcl
    REAL*8, INTENT(IN) :: te_tl, qcl_tl
    REAL*8 :: radius
    REAL*8 :: radius_tl
    REAL*8 :: muu, rho
    REAL*8 :: muu_tl, rho_tl
    rho_tl = -(100.*pl*mapl8_rgas*te_tl/(mapl8_rgas*te)**2)
    rho = 100.*pl/(mapl8_rgas*te)
    muu_tl = qcl_tl*rho + qcl*rho_tl
    muu = qcl*rho
    radius_tl = muu_tl/(nn*rho_w*(4./3.)*mapl8_pi)
    radius = muu/(nn*rho_w*(4./3.)*mapl8_pi)
! Equiv. Spherical Cloud Particle Radius in m
    IF (radius .GT. 0.0_8 .OR. (radius .LT. 0.0_8 .AND. 1./3. .EQ. INT(&
&       1./3.))) THEN
      radius_tl = radius**(1./3.-1)*radius_tl/3.
    ELSE IF (radius .EQ. 0.0_8 .AND. 1./3. .EQ. 1.0) THEN
      radius_tl = radius_tl
    ELSE
      radius_tl = 0.0_8
    END IF
    radius = radius**(1./3.)
  END FUNCTION LDRADIUS3_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  FUNCTION LDRADIUS3(pl, te, qcl, nn) RESULT (RADIUS)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: te, pl, nn, qcl
    REAL*8 :: radius
    REAL*8 :: muu, rho
    rho = 100.*pl/(mapl8_rgas*te)
    muu = qcl*rho
    radius = muu/(nn*rho_w*(4./3.)*mapl8_pi)
! Equiv. Spherical Cloud Particle Radius in m
    radius = radius**(1./3.)
  END FUNCTION LDRADIUS3
!  Differentiation of ice_fraction in forward (tangent) mode (with options r8):
!   variations   of useful results: icefrct
!   with respect to varying inputs: temp
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  FUNCTION ICE_FRACTION_TLM(temp, temp_tl, icefrct) RESULT (ICEFRCT_TL)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: temp
    REAL*8, INTENT(IN) :: temp_tl
    REAL*8 :: icefrct
    REAL*8 :: icefrct_tl
    INTRINSIC MIN
    INTRINSIC MAX
    icefrct = 0.00
    IF (temp .LE. t_ice_all) THEN
      icefrct = 1.000
      icefrct_tl = 0.0_8
    ELSE IF (temp .GT. t_ice_all .AND. temp .LE. t_ice_max) THEN
      icefrct_tl = -(temp_tl/(t_ice_max-t_ice_all))
      icefrct = 1.00 - (temp-t_ice_all)/(t_ice_max-t_ice_all)
    ELSE
      icefrct_tl = 0.0_8
    END IF
    IF (icefrct .GT. 1.00) THEN
      icefrct = 1.00
      icefrct_tl = 0.0_8
    ELSE
      icefrct = icefrct
    END IF
    IF (icefrct .LT. 0.00) THEN
      icefrct = 0.00
      icefrct_tl = 0.0_8
    ELSE
      icefrct = icefrct
    END IF
!!ICEFRCT = ICEFRCT**4
    IF (icefrct .GT. 0.0_8 .OR. (icefrct .LT. 0.0_8 .AND. icefrpwr .EQ. &
&       INT(icefrpwr))) THEN
      icefrct_tl = icefrpwr*icefrct**(icefrpwr-1)*icefrct_tl
    ELSE IF (icefrct .EQ. 0.0_8 .AND. icefrpwr .EQ. 1.0) THEN
      icefrct_tl = icefrct_tl
    ELSE
      icefrct_tl = 0.0_8
    END IF
    icefrct = icefrct**icefrpwr
  END FUNCTION ICE_FRACTION_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  FUNCTION ICE_FRACTION(temp) RESULT (ICEFRCT)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: temp
    REAL*8 :: icefrct
    INTRINSIC MIN
    INTRINSIC MAX
    icefrct = 0.00
    IF (temp .LE. t_ice_all) THEN
      icefrct = 1.000
    ELSE IF (temp .GT. t_ice_all .AND. temp .LE. t_ice_max) THEN
      icefrct = 1.00 - (temp-t_ice_all)/(t_ice_max-t_ice_all)
    END IF
    IF (icefrct .GT. 1.00) THEN
      icefrct = 1.00
    ELSE
      icefrct = icefrct
    END IF
    IF (icefrct .LT. 0.00) THEN
      icefrct = 0.00
    ELSE
      icefrct = icefrct
    END IF
!!ICEFRCT = ICEFRCT**4
    icefrct = icefrct**icefrpwr
  END FUNCTION ICE_FRACTION
!  Differentiation of get_alhx3 in forward (tangent) mode (with options r8):
!   variations   of useful results: alhx3
!   with respect to varying inputs: t
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  FUNCTION GET_ALHX3_TLM(t, t_tl, alhx3) RESULT (ALHX3_TL)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t
    REAL*8, INTENT(IN) :: t_tl
    REAL*8 :: alhx3
    REAL*8 :: alhx3_tl
    REAL*8 :: t_x
    t_x = t_ice_max
    IF (t .LT. t_ice_all) alhx3 = mapl8_alhs
    IF (t .GT. t_x) alhx3 = mapl8_alhl
    IF (t .LE. t_x .AND. t .GE. t_ice_all) THEN
      alhx3_tl = (mapl8_alhl-mapl8_alhs)*t_tl/(t_x-t_ice_all)
      alhx3 = mapl8_alhs + (mapl8_alhl-mapl8_alhs)*(t-t_ice_all)/(t_x-&
&       t_ice_all)
    ELSE
      alhx3_tl = 0.0_8
    END IF
  END FUNCTION GET_ALHX3_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  FUNCTION GET_ALHX3(t) RESULT (ALHX3)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t
    REAL*8 :: alhx3
    REAL*8 :: t_x
    t_x = t_ice_max
    IF (t .LT. t_ice_all) alhx3 = mapl8_alhs
    IF (t .GT. t_x) alhx3 = mapl8_alhl
    IF (t .LE. t_x .AND. t .GE. t_ice_all) alhx3 = mapl8_alhs + (&
&       mapl8_alhl-mapl8_alhs)*(t-t_ice_all)/(t_x-t_ice_all)
  END FUNCTION GET_ALHX3
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  REAL*8 FUNCTION ICEFRAC(t, t_trans, t_freez)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t
    REAL*8, INTENT(IN), OPTIONAL :: t_trans
    REAL*8, INTENT(IN), OPTIONAL :: t_freez
    REAL*8 :: t_x, t_f
    INTRINSIC PRESENT
    IF (PRESENT(t_trans)) THEN
      t_x = t_trans
    ELSE
      t_x = t_ice_max
    END IF
    IF (PRESENT(t_freez)) THEN
      t_f = t_freez
    ELSE
      t_f = t_ice_all
    END IF
    IF (t .LT. t_f) icefrac = 1.000
    IF (t .GT. t_x) icefrac = 0.000
    IF (t .LE. t_x .AND. t .GE. t_f) icefrac = 1.00 - (t-t_f)/(t_x-t_f)
  END FUNCTION ICEFRAC
!  Differentiation of sundq3_ice3 in forward (tangent) mode (with options r8):
!   variations   of useful results: f2
!   with respect to varying inputs: temp
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE SUNDQ3_ICE3_TLM(temp, temp_tl, rate2, rate3, te1, f2, f2_tl&
&   , f3)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: rate2, rate3, te1
    REAL*8, INTENT(IN) :: temp
    REAL*8, INTENT(IN) :: temp_tl
    REAL*8, INTENT(OUT) :: f2, f3
    REAL*8, INTENT(OUT) :: f2_tl
!,RATE2,RATE3,TE1
    REAL*8 :: xx, yy, te0, te2, jump1
    INTRINSIC MIN
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!  Ice - phase treatment totally invented
!!  Sharp increase in autoconversion in range
!!  ~~TE1 K ~< T < TE0 K .
!!  (JTB, 3/25/2003)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    te0 = 273.
!TE1=263.
    te2 = 200.
!RATE2=  10.
    jump1 = (rate2-1.0)/(te0-te1)**0.333
!RATE3=  25.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Ice - phase treatment  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
    IF (temp .GE. te0) THEN
      f2 = 1.0
      f3 = 1.0
    END IF
    IF (temp .GE. te1 .AND. temp .LT. te0) THEN
      f2_tl = -(jump1*0.3333*(te0-temp)**(-0.6667)*temp_tl)
      f2 = 1.0 + jump1*(te0-temp)**0.3333
      f3 = 1.0
    ELSE
      f2_tl = 0.0_8
    END IF
    IF (temp .LT. te1) THEN
      f2_tl = (-((rate3-rate2)*temp_tl))/(te1-te2)
      f2 = rate2 + (rate3-rate2)*(te1-temp)/(te1-te2)
      f3 = 1.0
    END IF
    IF (f2 .GT. 27.0) THEN
      f2 = 27.0
      f2_tl = 0.0_8
    ELSE
      f2 = f2
    END IF
  END SUBROUTINE SUNDQ3_ICE3_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE SUNDQ3_ICE3(temp, rate2, rate3, te1, f2, f3)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: rate2, rate3, te1
    REAL*8, INTENT(IN) :: temp
    REAL*8, INTENT(OUT) :: f2, f3
!,RATE2,RATE3,TE1
    REAL*8 :: xx, yy, te0, te2, jump1
    INTRINSIC MIN
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!  Ice - phase treatment totally invented
!!  Sharp increase in autoconversion in range
!!  ~~TE1 K ~< T < TE0 K .
!!  (JTB, 3/25/2003)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    te0 = 273.
!TE1=263.
    te2 = 200.
!RATE2=  10.
    jump1 = (rate2-1.0)/(te0-te1)**0.333
!RATE3=  25.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Ice - phase treatment  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
    IF (temp .GE. te0) THEN
      f2 = 1.0
      f3 = 1.0
    END IF
    IF (temp .GE. te1 .AND. temp .LT. te0) THEN
      f2 = 1.0 + jump1*(te0-temp)**0.3333
      f3 = 1.0
    END IF
    IF (temp .LT. te1) THEN
      f2 = rate2 + (rate3-rate2)*(te1-temp)/(te1-te2)
      f3 = 1.0
    END IF
    IF (f2 .GT. 27.0) THEN
      f2 = 27.0
    ELSE
      f2 = f2
    END IF
  END SUBROUTINE SUNDQ3_ICE3
!  Differentiation of pre_progno_cloud in forward (tangent) mode (with options r8):
!   variations   of useful results: qst3 qddf3 dzet
!   with respect to varying inputs: th1
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
!   subroutine RADCOUPLE(  &
!         TE,              & 
!         PL,              & 
!         CF,              & 
!         AF,              & 
!         QClLS,           & 
!         QCiLS,           & 
!         QClAN,           & 
!         QCiAN,           & 
!         QRN_ALL,         & 
!         QSN_ALL,         & 
!         RAD_QL,          &  
!         RAD_QI,          & 
!         RAD_QR,          & 
!         RAD_QS,          & 
!         RAD_CF,          & 
!         RAD_RL,          & 
!         RAD_RI,          & 
!         CLDVOL2FRC,      &          
!         NN_ANVIL,NN_ICE,NN_WARM,&
!         TEMPOR)
!
!      real(8), intent(in ) :: NN_ANVIL,NN_ICE,NN_WARM 
!      real(8), intent(in ) :: CLDVOL2FRC 
!      real(8), intent(in ) :: TE
!      real(8), intent(in ) :: PL
!      real(8), intent(in ) :: AF,CF, QClAN, QCiAN, QClLS, QCiLS
!      real(8), intent(in ) :: QRN_ALL, QSN_ALL
!      real(8), intent(out) :: RAD_QL,RAD_QI,RAD_QR,RAD_QS,RAD_CF,RAD_RL,RAD_RI
!
!      real(8), intent(in )  :: tempor
!
!      real(8) :: RElAN, REiAN, RElLS, REiLS, QCm, NN, ss, RAD_RI_AN
!      real(8) :: QClANm, QCiANm, QClLSm, QCiLSm, QCtot, AFx
!      real(8) :: rampt, rampu, rampp
!
!      real(8) :: ALPH, POLAR_RL
!
!
!      ! Limits on Radii needed to ensure
!      ! correct behavior of cloud optical
!      ! properties currently calculated in 
!      ! sorad and irrad (1e-6 m = micron)
!
!      POLAR_RL=   5.0e-6  ! 11/09/2007 JTB - COLD low level clouds
!
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      ! Adjust Anvil fractions for
!      ! warm clouds
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!   !  Needed for PRECIP Repartition
!   !  -----------------------------
!   !  ALPH =  0.05
!   !  SS   =  (260.-TE)/30.
!   !  SS   =  MIN( 1.0 , SS )
!   !  SS   =  MAX( 0.0 , SS )
!   !  SS   =  ALPH + (SS**3) * ( 1.0 - ALPH )
!   !  AFx  =  AF * SS 
!
!      ALPH =  0.1
!      SS   =  (280.-TE)/20.
!      SS   =  MIN( 1.0 , SS )
!      SS   =  MAX( 0.0 , SS )
!      SS   =  ALPH + (SS**3) * ( 1.0 - ALPH )
!      AFx  =  AF * SS * 0.5
!
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      ! Total cloud fraction
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      RAD_CF = MIN( CF + AFx, 1.00 )
!
!      ! Total In-cloud liquid
!      if ( RAD_CF > 0. ) then
!         RAD_QL = ( QClLS + QClAN ) / RAD_CF
!      else
!         RAD_QL = 0.0
!      end if
!      RAD_QL = MIN( RAD_QL, 0.01 )
!
!      ! Total In-cloud ice
!      if (  RAD_CF >0. ) then
!         RAD_QI = ( QCiLS + QCiAN ) / RAD_CF
!      else
!         RAD_QI = 0.0
!      end if
!      RAD_QI = MIN( RAD_QI, 0.01 )
!
!
!      ! Total In-cloud precipitation
!      if (  RAD_CF >0. ) then
!         RAD_QR = ( QRN_ALL ) / RAD_CF
!         RAD_QS = ( QSN_ALL ) / RAD_CF
!      else
!         RAD_QR = 0.0
!         RAD_QS = 0.0
!      end if
!      RAD_QR = MIN( RAD_QR, 0.01 )
!      RAD_QS = MIN( RAD_QS, 0.01 )
!
!      if (PL < 150. ) then
!         RAD_RI = MAX_RI
!      end if
!      if (PL >= 150. ) then
!         RAD_RI = MAX_RI*150./PL
!      end if
!
!      !! weigh in a separate R_ice for Anvil Ice according to
!      !
!      !       R_net_eff = (q_anv + q_ls) / ( q_anv/R_ice_anv + q_ls/R_ice_ls )
!      !-------------------------------------------------------------------------
!      RAD_RI_AN  =  RAD_RI ! 40.0e-6   ! MIN_RI 
!
!      if ( ( QCiLS + QCiAN ) > 0.0 ) then
!         RAD_RI_AN  = ( QCiLS + QCiAN ) / ( (QCiLS/RAD_RI) + (QCiAN/RI_ANV) )
!      end if
!
!      RAD_RI = MIN( RAD_RI, RAD_RI_AN )
!
!      RAD_RI = MAX( RAD_RI, MIN_RI )
!
!      ! Implement ramps for gradual change in effective radius
!      if (PL < 300. ) then
!         RAD_RL = 21.e-6
!      end if
!      if (PL >= 300. ) then
!         RAD_RL = 21.e-6*300./PL
!      end if
!      RAD_RL = MAX( RAD_RL, 10.e-6 )
!
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      ! Thicken low high lat clouds
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!      ! NOTE: Due to how tempor is calculated, it is now calculated in the
!      ! GridComp and passed into progno_cloud
!
!      if ( PL .GE. 775.  .AND. TE .LE.  275. .AND. (tempor.eq.1.) ) then
!         RAD_RL = max(min(-0.1 * PL + 87.5, 10.),5.)*1.e-6
!      end if
!      if ( PL .GE. 825.  .AND. TE .LE.  282. .AND. (tempor.eq.1.) ) then
!         RAD_RL = max(0.71 * TE - 190.25, 5.)*1.e-6
!      end if
!      if ( PL .GE. 775.  .AND. PL .LT. 825. .AND. TE .LE.  282. .AND. TE .GT. 275. .AND. (tempor.eq.1.) ) then
!         RAD_RL = min(-0.1*PL + 0.71 * TE - 107.75, 10.)*1.e-6
!      end if
!      if ( PL .GE. 825.  .AND. TE .LE.  275. .AND. (tempor.eq.1.) ) then
!         RAD_RL = 5.*1.e-6
!      end if
!
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      ! Thin low tropical clouds
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!      if ( PL .GE. 950.  .AND. TE .GE.  285. ) then
!         RAD_RL = min(2.2 * TE - 617., 21.)*1.e-6
!      end if
!      if ( PL .GE. 925.  .AND. TE .GE.  290. ) then
!         RAD_RL = min(0.44 * PL - 397., 21.)*1.e-6
!      end if
!      if ( PL .GE. 925.  .AND. PL .LT. 950. .AND. TE .GT.  285. .AND. TE .LT. 290.) then
!         RAD_RL = max(min(0.44*PL + 2.2 * TE - 1035., 21.),10.)*1.e-6
!      end if
!      if ( PL .GE. 950.  .AND. TE .GE.  290. ) then
!         RAD_RL = 21.*1.e-6
!      end if
!
!      if ( RAD_CF < 1.e-5 ) then
!         RAD_QL = 0.
!         RAD_QI = 0.
!         RAD_CF = 0.
!         RAD_QR = 0.
!         RAD_QS = 0.
!      end if
!
!   end subroutine RADCOUPLE
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) function QSAT(TL,PL,PASCALS)
!
!     real(8),              intent(IN) :: TL, PL
!     logical, optional, intent(IN) :: PASCALS
!     real(8) :: QSAT
!
!     real(8) :: URAMP, DD, QQ, TI, DQ, PP
!     integer :: IT
! 
!     URAMP = TMIX
!
!     if (present(PASCALS)) then 
!        if (PASCALS) then
!           PP = PL
!        else
!           PP = PL*100.
!        end if
!     else
!        PP = PL*100.
!     end if
! 
!     TI = TL - ZEROC
!
!     if    (TI <= URAMP) then
!        QSAT  =  QSATICE0(TL,PP,DQ)
!     elseif(TI >= 0.0  ) then
!        QSAT  =  QSATLQU0(TL,PP,DQ)
!     else
!        QSAT  =  QSATICE0(TL,PP,DQ)
!        QQ    =  QSATLQU0(TL,PP,DQ)
!        TI    =  TI/URAMP
!        QSAT  =  TI*(QSAT - QQ) +  QQ
!     end if
!
!   end function QSAT
!
!   attributes(device) function DQSAT(TL,PL,QSAT,PASCALS)
!
!      real(8),              intent(IN) :: TL, PL
!      real(8),              intent(OUT):: QSAT
!      logical, optional, intent(IN ):: PASCALS
!      real(8) :: DQSAT
!
!      real(8) :: URAMP, TT, WW, DD, DQQ, QQ, TI, DQI, QI, PP, DQ
!      integer :: IT
!
!      URAMP = TMIX
!
!      if (present(PASCALS)) then 
!         if (PASCALS) then
!            PP = PL
!         else
!            PP = PL*100.
!         end if
!      else
!         PP = PL*100.
!      end if
!
!      TI = TL - ZEROC
!
!      if    (TI <= URAMP) then
!         QQ  = QSATICE0(TL,PP,DQ)
!         QSAT  = QQ
!         DQSAT = DQ
!      elseif(TI >= 0.0  ) then
!         QQ  = QSATLQU0(TL,PP,DQ)
!         QSAT  = QQ
!         DQSAT = DQ
!      else
!         QQ  = QSATLQU0(TL,PP,DQQ)
!         QI  = QSATICE0(TL,PP,DQI)
!         TI  = TI/URAMP
!         DQSAT = TI*(DQI - DQQ) + DQQ
!         QSAT  = TI*(QI - QQ) +  QQ
!      end if
!
!   end function DQSAT
!
!   attributes(device) function QSATLQU0(TL,PL,DQ) result(QS)
!
!      real(8), intent(IN) :: TL
!      real(8), intent(IN) :: PL
!      real(8), intent(OUT):: DQ
!      real(8) :: QS
!
!      real(8) :: TI,W
!      real(8) :: DD
!      real(8) :: TT
!      real(8) :: DDQ
!      integer :: IT
!
!      integer, parameter :: TYPE = 1
!
!#define TX TL
!#define PX PL
!#define EX QS
!#define DX DQ
!
!
!   if    (TX<TMINLQU) then
!      TI = TMINLQU
!   elseif(TX>TMAXTBL) then
!      TI = TMAXTBL
!   else
!      TI = TX
!   end if
!
!#include "esatlqu.code"
!
!   if    (TX<TMINLQU) then
!      DDQ = 0.0
!   elseif(TX>TMAXTBL) then
!      DDQ = 0.0
!   else
!      if(PX>EX) then
!         DD = EX
!         TI = TX + DELTA_T
!#include "esatlqu.code"
!         DDQ = EX-DD
!         EX  = DD
!      endif
!   end if
!
!   if(PX > EX) then
!      DD = ESFAC/(PX - (1.0-ESFAC)*EX)
!      EX = EX*DD
!      DX = DDQ*ERFAC*PX*DD*DD
!   else
!      EX = MAX_MIXING_RATIO
!      DX = 0.0
!   end if
!
!#undef  DX
!#undef  TX
!#undef  EX
!#undef  PX
!
!      return
!   end function QSATLQU0
!
!   attributes(device) function QSATICE0(TL,PL,DQ) result(QS)
!
!      real(8), intent(IN) :: TL
!      real(8), intent(IN) :: PL
!      real(8), intent(OUT):: DQ
!      real(8) :: QS
!
!      real(8) :: TI,W
!      real(8) :: DD
!      real(8) :: TT
!      real(8) :: DDQ
!      integer :: IT
!
!      integer, parameter :: TYPE = 1
!
!#define TX TL
!#define PX PL
!#define EX QS
!#define DX DQ
!
!
!   if    (TX<TMINICE) then
!      TI = TMINICE
!   elseif(TX>ZEROC  ) then
!      TI = ZEROC
!   else
!      TI = TX
!   end if
!
!#include "esatice.code"
!
!   if    (TX<TMINICE) then
!      DDQ = 0.0
!   elseif(TX>ZEROC  ) then
!      DDQ = 0.0
!   else
!      if(PX>EX) then
!         DD = EX
!         TI = TX + DELTA_T
!#include "esatice.code"
!         DDQ = EX-DD
!         EX  = DD
!      endif
!   end if
!
!   if(PX > EX) then
!      DD = ESFAC/(PX - (1.0-ESFAC)*EX)
!      EX = EX*DD
!      DX = DDQ*ERFAC*PX*DD*DD
!   else
!      EX = MAX_MIXING_RATIO
!      DX = 0.0
!   end if
!
!#undef  DX
!#undef  TX
!#undef  EX
!#undef  PX
!
!         return
!   end function QSATICE0
!
!#endif
  SUBROUTINE PRE_PROGNO_CLOUD_TLM(im, jm, lm, th1, th1_tl, pk, plo, pke&
&   , cnv_ple, qst3, qst3_tl, dzet, dzet_tl, qddf3, qddf3_tl, &
&   cnv_fraction, cldparams)
    IMPLICIT NONE
!Inputs
    INTEGER, INTENT(IN) :: im, jm, lm
    REAL*8, DIMENSION(im, jm, 0:lm), INTENT(IN) :: pke, cnv_ple
    REAL*8, DIMENSION(im, jm, lm), INTENT(IN) :: th1, pk, plo
    REAL*8, DIMENSION(im, jm, lm), INTENT(IN) :: th1_tl
    TYPE(CLDPARAM_TYPE), INTENT(IN) :: cldparams
!Outputs
    REAL*8, DIMENSION(im, jm, lm), INTENT(OUT) :: qst3, dzet, qddf3
    REAL*8, DIMENSION(im, jm, lm), INTENT(OUT) :: qst3_tl, dzet_tl, &
&   qddf3_tl
!Inouts
    REAL*8, DIMENSION(im, jm), INTENT(INOUT) :: cnv_fraction
!Locals
    INTEGER :: i, j, k
    REAL*8, DIMENSION(im, jm, lm) :: temp, mass, dqst3
    REAL*8, DIMENSION(im, jm, lm) :: temp_tl, dqst3_tl
    REAL*8, DIMENSION(im, jm) :: vmip
    REAL*8, DIMENSION(im, jm) :: vmip_tl
    REAL*8, DIMENSION(im, jm, lm + 1) :: zet
    REAL*8, DIMENSION(im, jm, lm+1) :: zet_tl
    INTRINSIC SUM
    temp_tl = pk*th1_tl
    temp = th1*pk
    dqst3 = 0.0
    qst3 = 0.0
    qst3_tl = 0.0_8
    DO i=1,im
      DO j=1,jm
        DO k=1,lm
          CALL DQSATSCAPERT_TLM(dqst3(i, j, k), dqst3_tl(i, j, k), qst3(&
&                         i, j, k), qst3_tl(i, j, k), temp(i, j, k), &
&                         temp_tl(i, j, k), plo(i, j, k))
        END DO
      END DO
    END DO
    dzet = 0.0
    dzet_tl(:, :, 1:lm) = (pke(:, :, 1:lm)-pke(:, :, 0:lm-1))*mapl8_cp*&
&     th1_tl(:, :, 1:lm)/mapl8_grav
    dzet(:, :, 1:lm) = th1(:, :, 1:lm)*(pke(:, :, 1:lm)-pke(:, :, 0:lm-1&
&     ))*mapl8_cp/mapl8_grav
    mass(:, :, 1:lm) = (cnv_ple(:, :, 1:lm)-cnv_ple(:, :, 0:lm-1))*100./&
&     mapl8_grav
    zet(:, :, lm+1) = 0.0
    zet_tl = 0.0_8
    DO k=lm,1,-1
      zet_tl(:, :, k) = zet_tl(:, :, k+1) + dzet_tl(:, :, k)
      zet(:, :, k) = zet(:, :, k+1) + dzet(:, :, k)
    END DO
    qddf3 = 0.0
    qddf3_tl = 0.0_8
    WHERE (zet(:, :, 1:lm) .LT. 3000.) 
      qddf3_tl = -(mass*(zet_tl(:, :, 1:lm)*zet(:, :, 1:lm)+(zet(:, :, 1&
&       :lm)-3000.)*zet_tl(:, :, 1:lm)))
      qddf3 = -((zet(:, :, 1:lm)-3000.)*zet(:, :, 1:lm)*mass)
    ELSEWHERE
      qddf3_tl = 0.0_8
      qddf3 = 0.
    END WHERE
    vmip_tl = 0.0_8
    DO j=1,jm
      DO i=1,im
        vmip_tl(i, j) = SUM(qddf3_tl(i, j, :))
        vmip(i, j) = SUM(qddf3(i, j, :))
      END DO
    END DO
    DO k=1,lm
      qddf3_tl(:, :, k) = (qddf3_tl(:, :, k)*vmip-qddf3(:, :, k)*vmip_tl&
&       )/vmip**2
      qddf3(:, :, k) = qddf3(:, :, k)/vmip
    END DO
    IF (cldparams%move2ras .EQ. 0.) cnv_fraction = 0.0
  END SUBROUTINE PRE_PROGNO_CLOUD_TLM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
!   subroutine RADCOUPLE(  &
!         TE,              & 
!         PL,              & 
!         CF,              & 
!         AF,              & 
!         QClLS,           & 
!         QCiLS,           & 
!         QClAN,           & 
!         QCiAN,           & 
!         QRN_ALL,         & 
!         QSN_ALL,         & 
!         RAD_QL,          &  
!         RAD_QI,          & 
!         RAD_QR,          & 
!         RAD_QS,          & 
!         RAD_CF,          & 
!         RAD_RL,          & 
!         RAD_RI,          & 
!         CLDVOL2FRC,      &          
!         NN_ANVIL,NN_ICE,NN_WARM,&
!         TEMPOR)
!
!      real(8), intent(in ) :: NN_ANVIL,NN_ICE,NN_WARM 
!      real(8), intent(in ) :: CLDVOL2FRC 
!      real(8), intent(in ) :: TE
!      real(8), intent(in ) :: PL
!      real(8), intent(in ) :: AF,CF, QClAN, QCiAN, QClLS, QCiLS
!      real(8), intent(in ) :: QRN_ALL, QSN_ALL
!      real(8), intent(out) :: RAD_QL,RAD_QI,RAD_QR,RAD_QS,RAD_CF,RAD_RL,RAD_RI
!
!      real(8), intent(in )  :: tempor
!
!      real(8) :: RElAN, REiAN, RElLS, REiLS, QCm, NN, ss, RAD_RI_AN
!      real(8) :: QClANm, QCiANm, QClLSm, QCiLSm, QCtot, AFx
!      real(8) :: rampt, rampu, rampp
!
!      real(8) :: ALPH, POLAR_RL
!
!
!      ! Limits on Radii needed to ensure
!      ! correct behavior of cloud optical
!      ! properties currently calculated in 
!      ! sorad and irrad (1e-6 m = micron)
!
!      POLAR_RL=   5.0e-6  ! 11/09/2007 JTB - COLD low level clouds
!
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      ! Adjust Anvil fractions for
!      ! warm clouds
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!   !  Needed for PRECIP Repartition
!   !  -----------------------------
!   !  ALPH =  0.05
!   !  SS   =  (260.-TE)/30.
!   !  SS   =  MIN( 1.0 , SS )
!   !  SS   =  MAX( 0.0 , SS )
!   !  SS   =  ALPH + (SS**3) * ( 1.0 - ALPH )
!   !  AFx  =  AF * SS 
!
!      ALPH =  0.1
!      SS   =  (280.-TE)/20.
!      SS   =  MIN( 1.0 , SS )
!      SS   =  MAX( 0.0 , SS )
!      SS   =  ALPH + (SS**3) * ( 1.0 - ALPH )
!      AFx  =  AF * SS * 0.5
!
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      ! Total cloud fraction
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      RAD_CF = MIN( CF + AFx, 1.00 )
!
!      ! Total In-cloud liquid
!      if ( RAD_CF > 0. ) then
!         RAD_QL = ( QClLS + QClAN ) / RAD_CF
!      else
!         RAD_QL = 0.0
!      end if
!      RAD_QL = MIN( RAD_QL, 0.01 )
!
!      ! Total In-cloud ice
!      if (  RAD_CF >0. ) then
!         RAD_QI = ( QCiLS + QCiAN ) / RAD_CF
!      else
!         RAD_QI = 0.0
!      end if
!      RAD_QI = MIN( RAD_QI, 0.01 )
!
!
!      ! Total In-cloud precipitation
!      if (  RAD_CF >0. ) then
!         RAD_QR = ( QRN_ALL ) / RAD_CF
!         RAD_QS = ( QSN_ALL ) / RAD_CF
!      else
!         RAD_QR = 0.0
!         RAD_QS = 0.0
!      end if
!      RAD_QR = MIN( RAD_QR, 0.01 )
!      RAD_QS = MIN( RAD_QS, 0.01 )
!
!      if (PL < 150. ) then
!         RAD_RI = MAX_RI
!      end if
!      if (PL >= 150. ) then
!         RAD_RI = MAX_RI*150./PL
!      end if
!
!      !! weigh in a separate R_ice for Anvil Ice according to
!      !
!      !       R_net_eff = (q_anv + q_ls) / ( q_anv/R_ice_anv + q_ls/R_ice_ls )
!      !-------------------------------------------------------------------------
!      RAD_RI_AN  =  RAD_RI ! 40.0e-6   ! MIN_RI 
!
!      if ( ( QCiLS + QCiAN ) > 0.0 ) then
!         RAD_RI_AN  = ( QCiLS + QCiAN ) / ( (QCiLS/RAD_RI) + (QCiAN/RI_ANV) )
!      end if
!
!      RAD_RI = MIN( RAD_RI, RAD_RI_AN )
!
!      RAD_RI = MAX( RAD_RI, MIN_RI )
!
!      ! Implement ramps for gradual change in effective radius
!      if (PL < 300. ) then
!         RAD_RL = 21.e-6
!      end if
!      if (PL >= 300. ) then
!         RAD_RL = 21.e-6*300./PL
!      end if
!      RAD_RL = MAX( RAD_RL, 10.e-6 )
!
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      ! Thicken low high lat clouds
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!      ! NOTE: Due to how tempor is calculated, it is now calculated in the
!      ! GridComp and passed into progno_cloud
!
!      if ( PL .GE. 775.  .AND. TE .LE.  275. .AND. (tempor.eq.1.) ) then
!         RAD_RL = max(min(-0.1 * PL + 87.5, 10.),5.)*1.e-6
!      end if
!      if ( PL .GE. 825.  .AND. TE .LE.  282. .AND. (tempor.eq.1.) ) then
!         RAD_RL = max(0.71 * TE - 190.25, 5.)*1.e-6
!      end if
!      if ( PL .GE. 775.  .AND. PL .LT. 825. .AND. TE .LE.  282. .AND. TE .GT. 275. .AND. (tempor.eq.1.) ) then
!         RAD_RL = min(-0.1*PL + 0.71 * TE - 107.75, 10.)*1.e-6
!      end if
!      if ( PL .GE. 825.  .AND. TE .LE.  275. .AND. (tempor.eq.1.) ) then
!         RAD_RL = 5.*1.e-6
!      end if
!
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      ! Thin low tropical clouds
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!      if ( PL .GE. 950.  .AND. TE .GE.  285. ) then
!         RAD_RL = min(2.2 * TE - 617., 21.)*1.e-6
!      end if
!      if ( PL .GE. 925.  .AND. TE .GE.  290. ) then
!         RAD_RL = min(0.44 * PL - 397., 21.)*1.e-6
!      end if
!      if ( PL .GE. 925.  .AND. PL .LT. 950. .AND. TE .GT.  285. .AND. TE .LT. 290.) then
!         RAD_RL = max(min(0.44*PL + 2.2 * TE - 1035., 21.),10.)*1.e-6
!      end if
!      if ( PL .GE. 950.  .AND. TE .GE.  290. ) then
!         RAD_RL = 21.*1.e-6
!      end if
!
!      if ( RAD_CF < 1.e-5 ) then
!         RAD_QL = 0.
!         RAD_QI = 0.
!         RAD_CF = 0.
!         RAD_QR = 0.
!         RAD_QS = 0.
!      end if
!
!   end subroutine RADCOUPLE
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) function QSAT(TL,PL,PASCALS)
!
!     real(8),              intent(IN) :: TL, PL
!     logical, optional, intent(IN) :: PASCALS
!     real(8) :: QSAT
!
!     real(8) :: URAMP, DD, QQ, TI, DQ, PP
!     integer :: IT
! 
!     URAMP = TMIX
!
!     if (present(PASCALS)) then 
!        if (PASCALS) then
!           PP = PL
!        else
!           PP = PL*100.
!        end if
!     else
!        PP = PL*100.
!     end if
! 
!     TI = TL - ZEROC
!
!     if    (TI <= URAMP) then
!        QSAT  =  QSATICE0(TL,PP,DQ)
!     elseif(TI >= 0.0  ) then
!        QSAT  =  QSATLQU0(TL,PP,DQ)
!     else
!        QSAT  =  QSATICE0(TL,PP,DQ)
!        QQ    =  QSATLQU0(TL,PP,DQ)
!        TI    =  TI/URAMP
!        QSAT  =  TI*(QSAT - QQ) +  QQ
!     end if
!
!   end function QSAT
!
!   attributes(device) function DQSAT(TL,PL,QSAT,PASCALS)
!
!      real(8),              intent(IN) :: TL, PL
!      real(8),              intent(OUT):: QSAT
!      logical, optional, intent(IN ):: PASCALS
!      real(8) :: DQSAT
!
!      real(8) :: URAMP, TT, WW, DD, DQQ, QQ, TI, DQI, QI, PP, DQ
!      integer :: IT
!
!      URAMP = TMIX
!
!      if (present(PASCALS)) then 
!         if (PASCALS) then
!            PP = PL
!         else
!            PP = PL*100.
!         end if
!      else
!         PP = PL*100.
!      end if
!
!      TI = TL - ZEROC
!
!      if    (TI <= URAMP) then
!         QQ  = QSATICE0(TL,PP,DQ)
!         QSAT  = QQ
!         DQSAT = DQ
!      elseif(TI >= 0.0  ) then
!         QQ  = QSATLQU0(TL,PP,DQ)
!         QSAT  = QQ
!         DQSAT = DQ
!      else
!         QQ  = QSATLQU0(TL,PP,DQQ)
!         QI  = QSATICE0(TL,PP,DQI)
!         TI  = TI/URAMP
!         DQSAT = TI*(DQI - DQQ) + DQQ
!         QSAT  = TI*(QI - QQ) +  QQ
!      end if
!
!   end function DQSAT
!
!   attributes(device) function QSATLQU0(TL,PL,DQ) result(QS)
!
!      real(8), intent(IN) :: TL
!      real(8), intent(IN) :: PL
!      real(8), intent(OUT):: DQ
!      real(8) :: QS
!
!      real(8) :: TI,W
!      real(8) :: DD
!      real(8) :: TT
!      real(8) :: DDQ
!      integer :: IT
!
!      integer, parameter :: TYPE = 1
!
!#define TX TL
!#define PX PL
!#define EX QS
!#define DX DQ
!
!
!   if    (TX<TMINLQU) then
!      TI = TMINLQU
!   elseif(TX>TMAXTBL) then
!      TI = TMAXTBL
!   else
!      TI = TX
!   end if
!
!#include "esatlqu.code"
!
!   if    (TX<TMINLQU) then
!      DDQ = 0.0
!   elseif(TX>TMAXTBL) then
!      DDQ = 0.0
!   else
!      if(PX>EX) then
!         DD = EX
!         TI = TX + DELTA_T
!#include "esatlqu.code"
!         DDQ = EX-DD
!         EX  = DD
!      endif
!   end if
!
!   if(PX > EX) then
!      DD = ESFAC/(PX - (1.0-ESFAC)*EX)
!      EX = EX*DD
!      DX = DDQ*ERFAC*PX*DD*DD
!   else
!      EX = MAX_MIXING_RATIO
!      DX = 0.0
!   end if
!
!#undef  DX
!#undef  TX
!#undef  EX
!#undef  PX
!
!      return
!   end function QSATLQU0
!
!   attributes(device) function QSATICE0(TL,PL,DQ) result(QS)
!
!      real(8), intent(IN) :: TL
!      real(8), intent(IN) :: PL
!      real(8), intent(OUT):: DQ
!      real(8) :: QS
!
!      real(8) :: TI,W
!      real(8) :: DD
!      real(8) :: TT
!      real(8) :: DDQ
!      integer :: IT
!
!      integer, parameter :: TYPE = 1
!
!#define TX TL
!#define PX PL
!#define EX QS
!#define DX DQ
!
!
!   if    (TX<TMINICE) then
!      TI = TMINICE
!   elseif(TX>ZEROC  ) then
!      TI = ZEROC
!   else
!      TI = TX
!   end if
!
!#include "esatice.code"
!
!   if    (TX<TMINICE) then
!      DDQ = 0.0
!   elseif(TX>ZEROC  ) then
!      DDQ = 0.0
!   else
!      if(PX>EX) then
!         DD = EX
!         TI = TX + DELTA_T
!#include "esatice.code"
!         DDQ = EX-DD
!         EX  = DD
!      endif
!   end if
!
!   if(PX > EX) then
!      DD = ESFAC/(PX - (1.0-ESFAC)*EX)
!      EX = EX*DD
!      DX = DDQ*ERFAC*PX*DD*DD
!   else
!      EX = MAX_MIXING_RATIO
!      DX = 0.0
!   end if
!
!#undef  DX
!#undef  TX
!#undef  EX
!#undef  PX
!
!         return
!   end function QSATICE0
!
!#endif
  SUBROUTINE PRE_PROGNO_CLOUD(im, jm, lm, th1, pk, plo, pke, cnv_ple, &
&   qst3, dzet, qddf3, cnv_fraction, cldparams)
    IMPLICIT NONE
!Inputs
    INTEGER, INTENT(IN) :: im, jm, lm
    REAL*8, DIMENSION(im, jm, 0:lm), INTENT(IN) :: pke, cnv_ple
    REAL*8, DIMENSION(im, jm, lm), INTENT(IN) :: th1, pk, plo
    TYPE(CLDPARAM_TYPE), INTENT(IN) :: cldparams
!Outputs
    REAL*8, DIMENSION(im, jm, lm), INTENT(OUT) :: qst3, dzet, qddf3
!Inouts
    REAL*8, DIMENSION(im, jm), INTENT(INOUT) :: cnv_fraction
!Locals
    INTEGER :: i, j, k
    REAL*8, DIMENSION(im, jm, lm) :: temp, mass, dqst3
    REAL*8, DIMENSION(im, jm) :: vmip
    REAL*8, DIMENSION(im, jm, lm + 1) :: zet
    INTRINSIC SUM
    temp = th1*pk
    dqst3 = 0.0
    qst3 = 0.0
    DO i=1,im
      DO j=1,jm
        DO k=1,lm
          CALL DQSATSCAPERT(dqst3(i, j, k), qst3(i, j, k), temp(i, j, k)&
&                     , plo(i, j, k))
        END DO
      END DO
    END DO
    dzet = 0.0
    dzet(:, :, 1:lm) = th1(:, :, 1:lm)*(pke(:, :, 1:lm)-pke(:, :, 0:lm-1&
&     ))*mapl8_cp/mapl8_grav
    mass(:, :, 1:lm) = (cnv_ple(:, :, 1:lm)-cnv_ple(:, :, 0:lm-1))*100./&
&     mapl8_grav
    zet(:, :, lm+1) = 0.0
    DO k=lm,1,-1
      zet(:, :, k) = zet(:, :, k+1) + dzet(:, :, k)
    END DO
    qddf3 = 0.0
    WHERE (zet(:, :, 1:lm) .LT. 3000.) 
      qddf3 = -((zet(:, :, 1:lm)-3000.)*zet(:, :, 1:lm)*mass)
    ELSEWHERE
      qddf3 = 0.
    END WHERE
    DO j=1,jm
      DO i=1,im
        vmip(i, j) = SUM(qddf3(i, j, :))
      END DO
    END DO
    DO k=1,lm
      qddf3(:, :, k) = qddf3(:, :, k)/vmip
    END DO
    IF (cldparams%move2ras .EQ. 0.) cnv_fraction = 0.0
  END SUBROUTINE PRE_PROGNO_CLOUD
END MODULE CLOUDNEW_D
