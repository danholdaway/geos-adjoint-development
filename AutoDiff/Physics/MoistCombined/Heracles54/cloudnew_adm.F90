!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.11 (r5903) - 14 Dec 2015 10:32
!
! $Id: cloudnew.F90,v 1.40.2.7.2.2.10.1.4.1.4.8.2.1.2.3.6.10.24.1.4.1.2.1.2.1.12.3.4.5.12.1.2.42.2.18.2.12.2.16.2.4.8.1.42.3.10.1
!.46.2.2.2.16.1.6.4.12.1.2.1 2016-09-08 17:43:05 ltakacs Exp $
! $Name: drh-GEOSadas-5_16_0_H54 $
MODULE CLOUDNEW_B
!#ifndef _CUDA
!   use GEOS_UtilsMod,     only: QSAT=>GEOS_Qsat, DQSAT=>GEOS_DQsat
  USE CLDPARAMS
!#else
!   use cudafor
!   ! NOTE: GPUs use the QSAT and DQSAT at the end of this module
!#endif
  USE MAPL_CONSTANTSMOD, ONLY : mapl8_tice, mapl8_cp, mapl8_grav, &
& mapl8_alhs, mapl8_alhl, mapl8_alhf, mapl8_rgas, mapl8_h2omw, &
& mapl8_airmw, mapl8_rvap, mapl8_pi, mapl8_r8, mapl8_r4
!   use MAPL_BaseMod,      only: MAPL_UNDEF
  USE QSAT_UTIL_B
  IMPLICIT NONE
!#ifndef _CUDA
  PRIVATE 
  PUBLIC progno_cloud, pre_progno_cloud
  PUBLIC progno_cloud_adm, pre_progno_cloud_fwd, pre_progno_cloud_bwd
!PUBLIC ICE_FRACTION
  PUBLIC t_cloud_ctl
!#endif
  TYPE T_CLOUD_CTL
      REAL*8 :: sclmfdfr
      REAL*8 :: rsub_radius
  END TYPE T_CLOUD_CTL
!#ifdef _CUDA
!
!   ! Inputs
!   ! ------
!
!   real(8), allocatable, dimension(:,:), device :: PP_dev
!   real(8), allocatable, dimension(:,:), device :: EXNP_dev
!   real(8), allocatable, dimension(:,:), device :: PPE_dev
!   real(8), allocatable, dimension(:,:), device :: KH_dev
!   real(8), allocatable, dimension(:  ), device :: FRLAND_dev
!   real(8), allocatable, dimension(:,:), device :: RMFDTR_dev
!   real(8), allocatable, dimension(:,:), device :: QLWDTR_dev
!   real(8), allocatable, dimension(:,:), device :: U_dev
!   real(8), allocatable, dimension(:,:), device :: V_dev
!   real(8), allocatable, dimension(:,:), device :: QST3_dev
!   real(8), allocatable, dimension(:,:), device :: DZET_dev
!   real(8), allocatable, dimension(:,:), device :: QDDF3_dev
!   real(8), allocatable, dimension(:  ), device :: TEMPOR_dev
!   real(8), allocatable, dimension(:  ), device :: CNV_FRACTION_dev
!
!   ! Inoutputs
!   ! ---------
!
!   real(8), allocatable, dimension(:,:), device :: TH_dev
!   real(8), allocatable, dimension(:,:), device :: Q_dev
!   real(8), allocatable, dimension(:,:), device :: QRN_CU_dev
!   real(8), allocatable, dimension(:,:), device :: CNV_UPDFRC_dev ! on edges, but dims=1:LM
!   real(8), allocatable, dimension(:,:), device :: QLW_LS_dev  
!   real(8), allocatable, dimension(:,:), device :: QLW_AN_dev
!   real(8), allocatable, dimension(:,:), device :: QIW_LS_dev  
!   real(8), allocatable, dimension(:,:), device :: QIW_AN_dev
!   real(8), allocatable, dimension(:,:), device :: ANVFRC_dev
!   real(8), allocatable, dimension(:,:), device :: CLDFRC_dev
!
!   ! Outputs
!   ! -------
!
!   real(8), allocatable, dimension(:,:), device :: RAD_CLDFRC_dev
!   real(8), allocatable, dimension(:,:), device :: RAD_QL_dev
!   real(8), allocatable, dimension(:,:), device :: RAD_QI_dev
!   real(8), allocatable, dimension(:,:), device :: RAD_QR_dev
!   real(8), allocatable, dimension(:,:), device :: RAD_QS_dev
!   real(8), allocatable, dimension(:,:), device :: QPLS_dev
!   real(8), allocatable, dimension(:,:), device :: CLDREFFL_dev
!   real(8), allocatable, dimension(:,:), device :: CLDREFFI_dev
!   real(8), allocatable, dimension(:  ), device :: PRELS_dev
!   real(8), allocatable, dimension(:  ), device :: PRECU_dev
!   real(8), allocatable, dimension(:  ), device :: PREAN_dev
!   real(8), allocatable, dimension(:  ), device :: LSARF_dev
!   real(8), allocatable, dimension(:  ), device :: CUARF_dev
!   real(8), allocatable, dimension(:  ), device :: ANARF_dev
!   real(8), allocatable, dimension(:  ), device :: SNRLS_dev
!   real(8), allocatable, dimension(:  ), device :: SNRCU_dev
!   real(8), allocatable, dimension(:  ), device :: SNRAN_dev
!
!   real(8), allocatable, dimension(:,:), device :: PFL_CN_dev
!   real(8), allocatable, dimension(:,:), device :: PFI_CN_dev
!   real(8), allocatable, dimension(:,:), device :: PFL_AN_dev
!   real(8), allocatable, dimension(:,:), device :: PFI_AN_dev
!   real(8), allocatable, dimension(:,:), device :: PFL_LS_dev
!   real(8), allocatable, dimension(:,:), device :: PFI_LS_dev
!
!   real(8), allocatable, dimension(:,:), device :: RHX_dev
!   real(8), allocatable, dimension(:,:), device :: REV_LS_dev
!   real(8), allocatable, dimension(:,:), device :: REV_AN_dev
!   real(8), allocatable, dimension(:,:), device :: REV_CN_dev
!   real(8), allocatable, dimension(:,:), device :: RSU_LS_dev
!   real(8), allocatable, dimension(:,:), device :: RSU_AN_dev
!   real(8), allocatable, dimension(:,:), device :: RSU_CN_dev
!   real(8), allocatable, dimension(:,:), device :: ACLL_CN_dev
!   real(8), allocatable, dimension(:,:), device :: ACIL_CN_dev
!   real(8), allocatable, dimension(:,:), device :: ACLL_AN_dev
!   real(8), allocatable, dimension(:,:), device :: ACIL_AN_dev
!   real(8), allocatable, dimension(:,:), device :: ACLL_LS_dev
!   real(8), allocatable, dimension(:,:), device :: ACIL_LS_dev
!   real(8), allocatable, dimension(:,:), device :: PDFL_dev
!   real(8), allocatable, dimension(:,:), device :: PDFI_dev
!   real(8), allocatable, dimension(:,:), device :: FIXL_dev
!   real(8), allocatable, dimension(:,:), device :: FIXI_dev                          
!   real(8), allocatable, dimension(:,:), device :: AUT_dev
!   real(8), allocatable, dimension(:,:), device :: EVAPC_dev
!   real(8), allocatable, dimension(:,:), device :: SDM_dev
!   real(8), allocatable, dimension(:,:), device :: SUBLC_dev 
!   real(8), allocatable, dimension(:,:), device :: FRZ_TT_dev
!   real(8), allocatable, dimension(:,:), device :: FRZ_PP_dev
!   real(8), allocatable, dimension(:,:), device :: DCNVL_dev
!   real(8), allocatable, dimension(:,:), device :: DCNVi_dev
!   real(8), allocatable, dimension(:,:), device :: ALPHT_dev
!   real(8), allocatable, dimension(:,:), device :: ALPH1_dev
!   real(8), allocatable, dimension(:,:), device :: ALPH2_dev
!   real(8), allocatable, dimension(:,:), device :: CFPDF_dev
!   real(8), allocatable, dimension(:,:), device :: RHCLR_dev
!   real(8), allocatable, dimension(:,:), device :: DQRL_dev
!   real(8), allocatable, dimension(:,:), device :: VFALLICE_AN_dev
!   real(8), allocatable, dimension(:,:), device :: VFALLICE_LS_dev
!   real(8), allocatable, dimension(:,:), device :: VFALLWAT_AN_dev
!   real(8), allocatable, dimension(:,:), device :: VFALLWAT_LS_dev
!   real(8), allocatable, dimension(:,:), device :: VFALLSN_AN_dev
!   real(8), allocatable, dimension(:,:), device :: VFALLSN_LS_dev
!   real(8), allocatable, dimension(:,:), device :: VFALLSN_CN_dev
!   real(8), allocatable, dimension(:,:), device :: VFALLRN_AN_dev
!   real(8), allocatable, dimension(:,:), device :: VFALLRN_LS_dev
!   real(8), allocatable, dimension(:,:), device :: VFALLRN_CN_dev
!
!   real(8), allocatable, dimension(:,:), device :: LIQANMOVE_dev
!   real(8), allocatable, dimension(:,:), device :: ICEANMOVE_dev
!   real(8), allocatable, dimension(:,:), device :: DANCLD_dev
!   real(8), allocatable, dimension(:,:), device :: DLSCLD_dev
!   real(8), allocatable, dimension(:,:), device :: CURAINMOVE_dev
!   real(8), allocatable, dimension(:,:), device :: CUSNOWMOVE_dev
!
!   ! Constants passed in from CLDPARAMS (from MAPL_GetResource)
!   real(8),    constant :: CNV_BETA
!   real(8),    constant :: ANV_BETA
!   real(8),    constant :: LS_BETA
!   real(8),    constant :: RH00
!   real(8),    constant :: C_00
!   real(8),    constant :: LWCRIT
!   real(8),    constant :: C_ACC
!   real(8),    constant :: C_EV_R
!   real(8),    constant :: C_EV_S
!   real(8),    constant :: CLDVOL2FRC
!   real(8),    constant :: RHSUP_ICE
!   real(8),    constant :: SHR_EVAP_FAC
!   real(8),    constant :: MIN_CLD_WATER
!   real(8),    constant :: CLD_EVP_EFF
!   integer, constant :: NSMAX
!   real(8),    constant :: LS_SDQV2
!   real(8),    constant :: LS_SDQV3
!   real(8),    constant :: LS_SDQVT1
!   real(8),    constant :: ANV_SDQV2
!   real(8),    constant :: ANV_SDQV3
!   real(8),    constant :: ANV_SDQVT1
!   real(8),    constant :: ANV_TO_LS
!   real(8),    constant :: N_WARM
!   real(8),    constant :: N_ICE
!   real(8),    constant :: N_ANVIL
!   real(8),    constant :: N_PBL
!   integer, constant :: DISABLE_RAD
!   integer, constant :: ICE_SETTLE
!   real(8),    constant :: ANV_ICEFALL_C
!   real(8),    constant :: LS_ICEFALL_C
!   real(8),    constant :: REVAP_OFF_P
!   real(8),    constant :: CNVENVFC
!   real(8),    constant :: WRHODEP
!   real(8),    constant :: T_ICE_ALL
!   real(8),    constant :: CNVICEPARAM
!   integer, constant :: ICEFRPWR
!   real(8),    constant :: CNVDDRFC
!   real(8),    constant :: ANVDDRFC
!   real(8),    constant :: LSDDRFC
!   integer, constant :: TANHRHCRIT
!   real(8),    constant :: MINRHCRIT
!   real(8),    constant :: MAXRHCRIT
!   real(8),    constant :: TURNRHCRIT
!   real(8),    constant :: MAXRHCRITLAND
!   integer, constant :: FR_LS_WAT
!   integer, constant :: FR_LS_ICE
!   integer, constant :: FR_AN_WAT
!   integer, constant :: FR_AN_ICE
!   real(8),    constant :: MIN_RL
!   real(8),    constant :: MIN_RI
!   real(8),    constant :: MAX_RL
!   real(8),    constant :: MAX_RI
!   real(8),    constant :: RI_ANV
!   integer, constant :: PDFFLAG
!
!   ! Parameters for Internal DQSAT
!   ! -----------------------------
!
!   real(8), parameter :: ESFAC            = MAPL8_H2OMW/MAPL8_AIRMW
!   real(8), parameter :: MAX_MIXING_RATIO = 1.
!   real(8), parameter :: ZEROC            = MAPL8_TICE
!
!   real(8), parameter :: TMINTBL   =  150.0
!   real(8), parameter :: TMAXTBL   =  333.0
!   real(8), parameter :: DEGSUBS   =  100
!   real(8), parameter :: ERFAC     = (DEGSUBS/ESFAC)
!   real(8), parameter :: DELTA_T   =  1.0 / DEGSUBS
!   real(8), parameter :: TABLESIZE =  nint(TMAXTBL-TMINTBL)*DEGSUBS + 1
!   real(8), parameter :: TMIX      = -20.
!
!   real(8), parameter :: TMINSTR = -95.
!   real(8), parameter :: TSTARR1 = -75.
!   real(8), parameter :: TSTARR2 = -65.
!   real(8), parameter :: TSTARR3 = -50.
!   real(8), parameter :: TSTARR4 = -40.
!   real(8), parameter :: TMAXSTR = +60.
!
!   real(kind=MAPL_R8), parameter :: B6 = 6.136820929E-11*100.0
!   real(kind=MAPL_R8), parameter :: B5 = 2.034080948E-8 *100.0
!   real(kind=MAPL_R8), parameter :: B4 = 3.031240396E-6 *100.0
!   real(kind=MAPL_R8), parameter :: B3 = 2.650648471E-4 *100.0
!   real(kind=MAPL_R8), parameter :: B2 = 1.428945805E-2 *100.0
!   real(kind=MAPL_R8), parameter :: B1 = 4.436518521E-1 *100.0
!   real(kind=MAPL_R8), parameter :: B0 = 6.107799961E+0 *100.0
!   real(kind=MAPL_R8), parameter :: BI6= 1.838826904E-10*100.0
!   real(kind=MAPL_R8), parameter :: BI5= 4.838803174E-8 *100.0
!   real(kind=MAPL_R8), parameter :: BI4= 5.824720280E-6 *100.0
!   real(kind=MAPL_R8), parameter :: BI3= 4.176223716E-4 *100.0
!   real(kind=MAPL_R8), parameter :: BI2= 1.886013408E-2 *100.0
!   real(kind=MAPL_R8), parameter :: BI1= 5.034698970E-1 *100.0
!   real(kind=MAPL_R8), parameter :: BI0= 6.109177956E+0 *100.0
!   real(kind=MAPL_R8), parameter :: S16= 0.516000335E-11*100.0
!   real(kind=MAPL_R8), parameter :: S15= 0.276961083E-8 *100.0
!   real(kind=MAPL_R8), parameter :: S14= 0.623439266E-6 *100.0
!   real(kind=MAPL_R8), parameter :: S13= 0.754129933E-4 *100.0
!   real(kind=MAPL_R8), parameter :: S12= 0.517609116E-2 *100.0
!   real(kind=MAPL_R8), parameter :: S11= 0.191372282E+0 *100.0
!   real(kind=MAPL_R8), parameter :: S10= 0.298152339E+1 *100.0
!   real(kind=MAPL_R8), parameter :: S26= 0.314296723E-10*100.0
!   real(kind=MAPL_R8), parameter :: S25= 0.132243858E-7 *100.0
!   real(kind=MAPL_R8), parameter :: S24= 0.236279781E-5 *100.0
!   real(kind=MAPL_R8), parameter :: S23= 0.230325039E-3 *100.0
!   real(kind=MAPL_R8), parameter :: S22= 0.129690326E-1 *100.0
!   real(kind=MAPL_R8), parameter :: S21= 0.401390832E+0 *100.0
!   real(kind=MAPL_R8), parameter :: S20= 0.535098336E+1 *100.0
!
!   real(kind=MAPL_R8), parameter :: DI(0:3) = (/ 57518.5606E08, 2.01889049, 3.56654, 20.947031 /)
!   real(kind=MAPL_R8), parameter :: CI(0:3) = (/ 9.550426, -5723.265, 3.53068, -.00728332 /)
!   real(kind=MAPL_R8), parameter :: DL(1:6) = (/ -7.902980, 5.02808, -1.3816, 11.344, 8.1328, -3.49149 /)
!   real(kind=MAPL_R8), parameter :: LOGPS   = 3.005714898  ! log10(1013.246)
!   real(kind=MAPL_R8), parameter :: TS      = 373.16
!   real(kind=MAPL_R8), parameter :: CL(0:9) = (/54.842763, -6763.22, -4.21000, .000367, &
!                                       .0415, 218.8,  53.878000, -1331.22, -9.44523, .014025  /)
!
!   real(8), parameter :: TMINLQU = MAPL8_TICE - 40.0
!   real(8), parameter :: TMINICE = MAPL8_TICE + -95.
!
!#else
!! Some parameters set by CLDPARAMS 
  REAL*8 :: cnv_beta
  REAL*8 :: anv_beta
  REAL*8 :: ls_beta
  REAL*8 :: rh00
  REAL*8 :: c_00
  REAL*8 :: lwcrit
  REAL*8 :: c_acc
  REAL*8 :: c_ev_r
  REAL*8 :: c_ev_s
  REAL*8 :: cldvol2frc
  REAL*8 :: rhsup_ice
  REAL*8 :: shr_evap_fac
  REAL*8 :: min_cld_water
  REAL*8 :: cld_evp_eff
  INTEGER :: nsmax
  REAL*8 :: ls_sdqv2
  REAL*8 :: ls_sdqv3
  REAL*8 :: ls_sdqvt1
  REAL*8 :: anv_sdqv2
  REAL*8 :: anv_sdqv3
  REAL*8 :: anv_sdqvt1
  REAL*8 :: anv_to_ls
  REAL*8 :: n_warm
  REAL*8 :: n_ice
  REAL*8 :: n_anvil
  REAL*8 :: n_pbl
  INTEGER :: disable_rad
  INTEGER :: ice_settle
  REAL*8 :: anv_icefall_c
  REAL*8 :: ls_icefall_c
  REAL*8 :: revap_off_p
  REAL*8 :: cnvenvfc
  REAL*8 :: wrhodep
  REAL*8 :: t_ice_all
  REAL*8 :: cnviceparam
  INTEGER :: icefrpwr
  REAL*8 :: cnvddrfc
  REAL*8 :: anvddrfc
  REAL*8 :: lsddrfc
  INTEGER :: tanhrhcrit
  REAL*8 :: minrhcrit
  REAL*8 :: maxrhcrit
  REAL*8 :: turnrhcrit
  REAL*8 :: min_ri, max_ri, min_rl, max_rl, ri_anv
  INTEGER :: fr_ls_wat, fr_ls_ice, fr_an_wat, fr_an_ice
  REAL*8 :: maxrhcritland
  INTEGER :: pdfflag
  INTEGER :: ktop
!#endif
! -7.0+MAPL8_TICE
  REAL*8, PARAMETER :: t_ice_max=mapl8_tice
! Density of liquid water in kg/m^3
  REAL*8, PARAMETER :: rho_w=1.0e3
  REAL*8, PARAMETER :: min_cld_frac=1.0e-8
! There are two PIs in this routine: PI_0 and MAPL8_PI
  REAL*8, PARAMETER :: pi_0=4.*ATAN(1.)

CONTAINS
!  Differentiation of progno_cloud in reverse (adjoint) mode (with options r8 split(GEOS_MoistGridComp.PRE_PROGNO_CLOUD)):
!   gradient     of useful results: qiw_an_dev qlw_an_dev anvfrc_dev
!                u_dev q_dev v_dev qiw_ls_dev qlw_ls_dev cldfrc_dev
!                th_dev
!   with respect to varying inputs: qddf3_dev qiw_an_dev qlw_an_dev
!                cnv_updfrc_dev dzet_dev qst3_dev anvfrc_dev qrn_cu_dev
!                u_dev q_dev v_dev qiw_ls_dev qlwdtr_dev qlw_ls_dev
!                rmfdtr_dev cldfrc_dev th_dev
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! GPU The GPU main routine call is smaller due to CUDA limit on
!     number of arguments permitted in call. Most inputs and outputs
!     are USE-associated in the GridComp
!#ifdef _CUDA
!   attributes(global) subroutine progno_cloud(IRUN,LM,DT,SCLMFDFR)
!#else
!!! first vars are (in) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!         LATS_dev         , &
!         RAD_CLDFRC_dev   , &
!         RAD_QL_dev       , &
!         RAD_QI_dev       , &
!         RAD_QR_dev       , &
!         RAD_QS_dev       , &
!         QPLS_dev         , &
!         CLDREFFL_dev     , &
!         CLDREFFI_dev     , &
!         PRELS_dev        , &
!         PRECU_dev        , &
!         PREAN_dev        , &
!         LSARF_dev        , &
!         CUARF_dev        , &
!         ANARF_dev        , &
!         SNRLS_dev        , &
!         SNRCU_dev        , &
!         SNRAN_dev        , &
!, &
  SUBROUTINE PROGNO_CLOUD_ADM(irun, lm, dt, pp_dev, ppe_dev, exnp_dev, &
&   frland_dev, kh_dev, rmfdtr_dev, rmfdtr_dev_ad, qlwdtr_dev, &
&   qlwdtr_dev_ad, qrn_cu_dev, qrn_cu_dev_ad, cnv_updfrc_dev, &
&   cnv_updfrc_dev_ad, u_dev, u_dev_ad, v_dev, v_dev_ad, th_dev, &
&   th_dev_ad, q_dev, q_dev_ad, qlw_ls_dev, qlw_ls_dev_ad, qlw_an_dev, &
&   qlw_an_dev_ad, qiw_ls_dev, qiw_ls_dev_ad, qiw_an_dev, qiw_an_dev_ad&
&   , anvfrc_dev, anvfrc_dev_ad, cldfrc_dev, cldfrc_dev_ad, cldparams, &
&   sclmfdfr, qst3_dev, qst3_dev_ad, dzet_dev, dzet_dev_ad, qddf3_dev, &
&   qddf3_dev_ad, cnv_fraction_dev)
    IMPLICIT NONE
!#ifndef _CUDA
!#else
!      end if RUN_LOOP
!#endif
!#ifdef _CUDA
!      integer, intent(in   ), value :: IRUN
!      integer, intent(in   ), value :: LM
!      real(8), intent(in   ), value :: DT
!      real(8), intent(in   ), value :: SCLMFDFR   ! CLOUD_CTL%SCLMFDFR
!#else
    TYPE(CLDPARAM_TYPE), INTENT(IN) :: cldparams
! IM*JM
    INTEGER, INTENT(IN) :: irun
! LM
    INTEGER, INTENT(IN) :: lm
! DT_MOIST
    REAL*8, INTENT(IN) :: dt
!      real(8), intent(in   ), dimension(IRUN)      :: LATS_dev    ! LATS
! PLO
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: pp_dev
! CNV_PLE
    REAL*8, DIMENSION(irun, 0:lm), INTENT(IN) :: ppe_dev
! PK
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: exnp_dev
! FRLAND
    REAL*8, DIMENSION(irun), INTENT(IN) :: frland_dev
! KH
    REAL*8, DIMENSION(irun, 0:lm), INTENT(IN) :: kh_dev
! CNV_MFD
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: rmfdtr_dev
    REAL*8, DIMENSION(irun, lm) :: rmfdtr_dev_ad
! CNV_DQLDT
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: qlwdtr_dev
    REAL*8, DIMENSION(irun, lm) :: qlwdtr_dev_ad
! CNV_PRC3 IS THIS INTENT IN?
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qrn_cu_dev
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qrn_cu_dev_ad
! CNV_UPDF
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: cnv_updfrc_dev
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: cnv_updfrc_dev_ad
! U1
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: u_dev
    REAL*8, DIMENSION(irun, lm) :: u_dev_ad
! V1
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: v_dev
    REAL*8, DIMENSION(irun, lm) :: v_dev_ad
! TH1
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: th_dev
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: th_dev_ad
! Q1
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: q_dev
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: q_dev_ad
! QLLS
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qlw_ls_dev
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qlw_ls_dev_ad
! QLCN
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qlw_an_dev
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qlw_an_dev_ad
! QILS
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qiw_ls_dev
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qiw_ls_dev_ad
! QICN
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qiw_an_dev
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qiw_an_dev_ad
! CLCN
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: anvfrc_dev
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: anvfrc_dev_ad
! CLLS
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: cldfrc_dev
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: cldfrc_dev_ad
!      real(8), intent(  out), dimension(IRUN,  LM) :: RAD_CLDFRC_dev ! RAD_CF
!      real(8), intent(  out), dimension(IRUN,  LM) :: RAD_QL_dev ! RAD_QL
!      real(8), intent(  out), dimension(IRUN,  LM) :: RAD_QI_dev ! RAD_QI
!      real(8), intent(  out), dimension(IRUN,  LM) :: RAD_QR_dev ! QRAIN
!      real(8), intent(  out), dimension(IRUN,  LM) :: RAD_QS_dev ! QSNOW
!      real(8), intent(  out), dimension(IRUN,  LM) :: QPLS_dev ! QPLS
!      real(8), intent(  out), dimension(IRUN,  LM) :: CLDREFFL_dev ! CLDREFFL
!      real(8), intent(  out), dimension(IRUN,  LM) :: CLDREFFI_dev ! CLDREFFI
!      real(8), intent(  out), dimension(IRUN     ) :: PRELS_dev ! LS_PRC2
!      real(8), intent(  out), dimension(IRUN     ) :: PRECU_dev ! CN_PRC2
!      real(8), intent(  out), dimension(IRUN     ) :: PREAN_dev ! AN_PRC2
!      real(8), intent(  out), dimension(IRUN     ) :: LSARF_dev ! LS_ARFX
!      real(8), intent(  out), dimension(IRUN     ) :: CUARF_dev ! CN_ARFX
!      real(8), intent(  out), dimension(IRUN     ) :: ANARF_dev ! AN_ARFX
!      real(8), intent(  out), dimension(IRUN     ) :: SNRLS_dev ! LS_SNR
!      real(8), intent(  out), dimension(IRUN     ) :: SNRCU_dev ! CN_SNR
!      real(8), intent(  out), dimension(IRUN     ) :: SNRAN_dev ! AN_SNR
! CLOUD_CTL%SCLMFDFR
    REAL*8, INTENT(IN) :: sclmfdfr
! QST3
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: qst3_dev
    REAL*8, DIMENSION(irun, lm) :: qst3_dev_ad
! DZET
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: dzet_dev
    REAL*8, DIMENSION(irun, lm) :: dzet_dev_ad
! QDDF3
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: qddf3_dev
    REAL*8, DIMENSION(irun, lm) :: qddf3_dev_ad
! CNV_FRACTION
    REAL*8, DIMENSION(irun), INTENT(IN) :: cnv_fraction_dev
!      real(8), intent(  out), dimension(IRUN,  LM) :: RHX_dev    ! RHX
!      real(8), intent(  out), dimension(IRUN,  LM) :: REV_LS_dev ! REV_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: REV_AN_dev ! REV_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: REV_CN_dev ! REV_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: RSU_LS_dev ! RSU_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: RSU_AN_dev ! RSU_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: RSU_CN_dev ! RSU_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACLL_CN_dev ! ACLL_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACIL_CN_dev ! ACIL_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACLL_AN_dev ! ACLL_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACIL_AN_dev ! ACIL_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACLL_LS_dev ! ACLL_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACIL_LS_dev ! ACIL_LS
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFL_CN_dev ! PFL_CN
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFI_CN_dev ! PFI_CN
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFL_AN_dev ! PFL_AN
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFI_AN_dev ! PFI_AN
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFL_LS_dev ! PFL_LS
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFI_LS_dev ! PFI_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: PDFL_dev ! DlPDF
!      real(8), intent(  out), dimension(IRUN,  LM) :: PDFI_dev ! DiPDF
!      real(8), intent(  out), dimension(IRUN,  LM) :: FIXL_dev ! DlFIX
!      real(8), intent(  out), dimension(IRUN,  LM) :: FIXI_dev ! DiFIX                  
!      real(8), intent(  out), dimension(IRUN,  LM) :: AUT_dev   ! AUT
!      real(8), intent(  out), dimension(IRUN,  LM) :: EVAPC_dev ! EVAPC
!      real(8), intent(  out), dimension(IRUN,  LM) :: SDM_dev   ! SDM
!      real(8), intent(  out), dimension(IRUN,  LM) :: SUBLC_dev ! SUBLC
!      real(8), intent(  out), dimension(IRUN,  LM) :: FRZ_TT_dev ! FRZ_TT
!      real(8), intent(  out), dimension(IRUN,  LM) :: FRZ_PP_dev ! FRZ_PP
!      real(8), intent(  out), dimension(IRUN,  LM) :: DCNVL_dev ! DCNVL
!      real(8), intent(  out), dimension(IRUN,  LM) :: DCNVi_dev ! DCNVi
!      real(8), intent(  out), dimension(IRUN,  LM) :: ALPHT_dev ! ALPHT
!      real(8), intent(  out), dimension(IRUN,  LM) :: ALPH1_dev ! ALPH1
!      real(8), intent(  out), dimension(IRUN,  LM) :: ALPH2_dev ! ALPH2
!      real(8), intent(  out), dimension(IRUN,  LM) :: CFPDF_dev ! CFPDF
!      real(8), intent(  out), dimension(IRUN,  LM) :: RHCLR_dev ! RHCLR
!      real(8), intent(  out), dimension(IRUN,  LM) :: DQRL_dev ! DQRL
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLICE_AN_dev ! VFALLICE_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLICE_LS_dev ! VFALLICE_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLWAT_AN_dev ! VFALLWAT_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLWAT_LS_dev ! VFALLWAT_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLSN_AN_dev ! VFALLSN_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLSN_LS_dev ! VFALLSN_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLSN_CN_dev ! VFALLSN_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLRN_AN_dev ! VFALLRN_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLRN_LS_dev ! VFALLRN_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLRN_CN_dev ! VFALLRN_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: LIQANMOVE_dev  ! LIQANMOVE
!      real(8), intent(  out), dimension(IRUN,  LM) :: ICEANMOVE_dev  ! ICEANMOVE
!      real(8), intent(  out), dimension(IRUN,  LM) :: DANCLD_dev     ! DANCLD
!      real(8), intent(  out), dimension(IRUN,  LM) :: DLSCLD_dev     ! DLSCLD
!      real(8), intent(  out), dimension(IRUN,  LM) :: CURAINMOVE_dev ! CURAINMOVE
!      real(8), intent(  out), dimension(IRUN,  LM) :: CUSNOWMOVE_dev ! CUSNOWMOVE
!      real(8), intent(in   ), dimension(IRUN     ) :: TEMPOR_dev  ! TEMPOR
!#endif
! GPU The GPUs need to know how big local arrays are during compile-time
!     as the GPUs cannot allocate memory themselves. This command resets
!     this a priori size to LM for the CPU.
!#ifndef GPU_MAXLEVS
!#define GPU_MAXLEVS LM
!#endif
    INTEGER :: i, j, k, l
    INTEGER :: fraction_removal1, fraction_removal2, fraction_removal3
    REAL*8 :: mass, imass
    REAL*8 :: totfrc
    REAL*8 :: totfrc_ad
    REAL*8 :: qrn_ls, qrn_an, qrn_cu_1d
    REAL*8 :: qrn_ls_ad, qrn_an_ad, qrn_cu_1d_ad
    REAL*8 :: qsn_ls, qsn_an, qsn_cu
    REAL*8 :: qsn_ls_ad, qsn_an_ad, qsn_cu_ad
!      real(8) :: QRN_ALL, QSN_ALL
    REAL*8 :: qtmp1, qtmp2, qtmp3
    REAL*8 :: qtmp1_ad, qtmp2_ad, qtmp3_ad
    REAL*8 :: temp
    REAL*8 :: temp_ad
    REAL*8 :: rhcrit
    REAL*8 :: rhcrit_ad
    REAL*8 :: aa3, bb3, alpha
    REAL*8 :: aa3_ad, bb3_ad, alpha_ad
    REAL*8 :: vfall, vfallrn, vfallsn
    REAL*8 :: vfall_ad
    REAL*8 :: tot_prec_upd
    REAL*8 :: tot_prec_upd_ad
    REAL*8 :: tot_prec_anv
    REAL*8 :: tot_prec_anv_ad
    REAL*8 :: tot_prec_ls
    REAL*8 :: tot_prec_ls_ad
    REAL*8 :: area_upd_prc
    REAL*8 :: area_upd_prc_ad
    REAL*8 :: area_anv_prc
    REAL*8 :: area_anv_prc_ad
    REAL*8 :: area_ls_prc
    REAL*8 :: area_ls_prc_ad
    REAL*8 :: area_upd_prc_tolayer
    REAL*8 :: area_upd_prc_tolayer_ad
    REAL*8 :: area_anv_prc_tolayer
    REAL*8 :: area_anv_prc_tolayer_ad
    REAL*8 :: area_ls_prc_tolayer
    REAL*8 :: area_ls_prc_tolayer_ad
    REAL*8 :: u_above, u_below
    REAL*8 :: u_above_ad, u_below_ad
    REAL*8 :: v_above, v_below
    REAL*8 :: v_above_ad, v_below_ad
    REAL*8 :: dzet_above, dzet_below
    REAL*8 :: dzet_above_ad, dzet_below_ad
    REAL*8 :: prn_cu_above, psn_cu_above
    REAL*8 :: prn_cu_above_ad, psn_cu_above_ad
    REAL*8 :: prn_ls_above, psn_ls_above
    REAL*8 :: prn_ls_above_ad, psn_ls_above_ad
    REAL*8 :: prn_an_above, psn_an_above
    REAL*8 :: prn_an_above_ad, psn_an_above_ad
    REAL*8 :: evap_dd_cu_above, subl_dd_cu_above
    REAL*8 :: evap_dd_cu_above_ad, subl_dd_cu_above_ad
    REAL*8 :: evap_dd_ls_above, subl_dd_ls_above
    REAL*8 :: evap_dd_ls_above_ad, subl_dd_ls_above_ad
    REAL*8 :: evap_dd_an_above, subl_dd_an_above
    REAL*8 :: evap_dd_an_above_ad, subl_dd_an_above_ad
    LOGICAL :: use_autoconv_timescale
    REAL*8 :: tropical, extratropical
    REAL*8 :: lsenvfc, anvenvfc, envfc, ddrfc, beta
    REAL*8 :: sdqv2, sdqv3, sdqvt1
    REAL*8 :: lspdfliqnew, lspdficenew, lspdffracnew
    INTRINSIC INT
    INTRINSIC NINT
    INTRINSIC MAX
    INTEGER :: branch
    REAL*8 :: temp1
    REAL*8 :: temp0
    REAL*8 :: temp_ad8
    REAL*8 :: temp_ad7
    REAL*8 :: temp_ad6
    REAL*8 :: temp_ad5
    REAL*8 :: temp_ad4
    REAL*8 :: temp_ad3
    REAL*8 :: temp_ad2
    REAL*8 :: temp_ad1
    REAL*8 :: temp_ad0
! These are in constant memory in CUDA and are set in the GridComp
!#ifndef _CUDA
! Area factor for convective rain showers (non-dim)
    cnv_beta = cldparams%cnv_beta
! Area factor for anvil rain showers (non-dim)
    anv_beta = cldparams%anv_beta
! Area factor for Large Scale rain showers (non-dim)
    ls_beta = cldparams%ls_beta
! Critical relative humidity
    rh00 = cldparams%rh_crit
    c_00 = cldparams%autoc_ls
    lwcrit = cldparams%qc_crit_ls
    c_acc = cldparams%accretion
    c_ev_r = cldparams%rain_revap_fac
    c_ev_s = cldparams%snow_revap_fac
    cld_evp_eff = cldparams%ccw_evap_eff
    nsmax = INT(cldparams%nsub_autoconv)
    ls_sdqv2 = cldparams%ls_sund_inter
    ls_sdqv3 = cldparams%ls_sund_cold
    ls_sdqvt1 = cldparams%ls_sund_temp1
    anv_sdqv2 = cldparams%anv_sund_inter
    anv_sdqv3 = cldparams%anv_sund_cold
    anv_sdqvt1 = cldparams%anv_sund_temp1
    ice_settle = NINT(cldparams%ice_settle)
    anv_icefall_c = cldparams%anv_icefall
    ls_icefall_c = cldparams%ls_icefall
    revap_off_p = cldparams%revap_off_p
    cnvenvfc = cldparams%cnv_envf
    wrhodep = cldparams%wrhodep
    t_ice_all = cldparams%ice_ramp + mapl8_tice
    cnviceparam = cldparams%cnv_iceparam
    icefrpwr = INT(cldparams%cnv_icefrpwr + .001)
    cnvddrfc = cldparams%cnv_ddrf
    anvddrfc = cldparams%anv_ddrf
    lsddrfc = cldparams%ls_ddrf
    tanhrhcrit = INT(cldparams%tanhrhcrit)
    minrhcrit = cldparams%minrhcrit
    maxrhcrit = cldparams%maxrhcrit
    turnrhcrit = cldparams%turnrhcrit
    maxrhcritland = cldparams%maxrhcritland
    fr_ls_wat = INT(cldparams%fr_ls_wat)
    fr_ls_ice = INT(cldparams%fr_ls_ice)
    fr_an_wat = INT(cldparams%fr_an_wat)
    fr_an_ice = INT(cldparams%fr_an_ice)
    pdfflag = INT(cldparams%pdfshape)
    ktop = INT(cldparams%ktop)
!#endif
!#ifdef _CUDA
!      i = (blockidx%x - 1) * blockdim%x + threadidx%x
!
!      RUN_LOOP: IF ( I <= IRUN ) THEN
!#else
run_loop:DO i=1,irun
!#endif
k_loop:DO k=ktop,lm
        IF (k .EQ. ktop) THEN
          CALL PUSHREAL8(tot_prec_upd)
          tot_prec_upd = 0.
          CALL PUSHREAL8(tot_prec_anv)
          tot_prec_anv = 0.
          CALL PUSHREAL8(tot_prec_ls)
          tot_prec_ls = 0.
          CALL PUSHREAL8(area_upd_prc)
          area_upd_prc = 0.
          CALL PUSHREAL8(area_anv_prc)
          area_anv_prc = 0.
          CALL PUSHREAL8(area_ls_prc)
          area_ls_prc = 0.
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!! ZERO DIAGNOSTIC OUTPUTS BEFORE SHOWERS !!
!               PRELS_dev(I) = 0.
!               PRECU_dev(I) = 0.
!               PREAN_dev(I) = 0.
!               SNRCU_dev(I) = 0. 
!               SNRLS_dev(I) = 0. 
!               SNRAN_dev(I) = 0. 
!               LSARF_dev(I) = 0.
!               CUARF_dev(I) = 0.
!               ANARF_dev(I) = 0.
!Zero out/initialize precips, except QRN_CU which comes from RAS 
        qrn_ls = 0.
        qrn_an = 0.
        qsn_ls = 0.
        qsn_an = 0.
        qsn_cu = 0.
!            RAD_QL_dev(I,K)     = 0.
!            RAD_QI_dev(I,K)     = 0.
!            RAD_QR_dev(I,K)     = 0.
!            RAD_QS_dev(I,K)     = 0.
!            QPLS_dev(I,K)       = 0.
!            RAD_CLDFRC_dev(I,K) = 0.
!            CLDREFFL_dev(I,K)   = 0.
!            CLDREFFI_dev(I,K)   = 0.
!            PFL_CN_dev(I,K) = 0.
!            PFI_CN_dev(I,K) = 0.
!            PFL_AN_dev(I,K) = 0.
!            PFI_AN_dev(I,K) = 0.
!            PFL_LS_dev(I,K) = 0.
!            PFI_LS_dev(I,K) = 0.
!            IF (K == KTOP) THEN
!               PFL_CN_dev(I,0) = 0.
!               PFI_CN_dev(I,0) = 0.
!               PFL_AN_dev(I,0) = 0.
!               PFI_AN_dev(I,0) = 0.
!               PFL_LS_dev(I,0) = 0.
!               PFI_LS_dev(I,0) = 0.
!            END IF
! Initialize other diagnostics 
!            RHX_dev(I,K) = MAPL8_UNDEF
!            REV_LS_dev(I,K) = MAPL8_UNDEF
!            REV_AN_dev(I,K) = MAPL8_UNDEF
!            REV_CN_dev(I,K) = MAPL8_UNDEF
!            RSU_LS_dev(I,K) = MAPL8_UNDEF
!            RSU_AN_dev(I,K) = MAPL8_UNDEF
!            RSU_CN_dev(I,K) = MAPL8_UNDEF
!            ACLL_CN_dev(I,K) = MAPL8_UNDEF
!            ACIL_CN_dev(I,K) = MAPL8_UNDEF
!            ACLL_AN_dev(I,K) = MAPL8_UNDEF
!            ACIL_AN_dev(I,K) = MAPL8_UNDEF
!            ACLL_LS_dev(I,K) = MAPL8_UNDEF
!            ACIL_LS_dev(I,K) = MAPL8_UNDEF
!            PDFL_dev(I,K) = MAPL8_UNDEF
!            PDFI_dev(I,K) = MAPL8_UNDEF
!            FIXL_dev(I,K) = MAPL8_UNDEF
!            FIXI_dev(I,K) = MAPL8_UNDEF
!            AUT_dev(I,K) = MAPL8_UNDEF
!            EVAPC_dev(I,K) = MAPL8_UNDEF
!            SDM_dev(I,K) = MAPL8_UNDEF
!            SUBLC_dev(I,K) = MAPL8_UNDEF
!            FRZ_TT_dev(I,K) = MAPL8_UNDEF
!            FRZ_PP_dev(I,K) = MAPL8_UNDEF
!            DCNVL_dev(I,K) = MAPL8_UNDEF
!            DCNVi_dev(I,K) = MAPL8_UNDEF
!            ALPHT_dev(I,K) = MAPL8_UNDEF
!            ALPH1_dev(I,K) = MAPL8_UNDEF
!            ALPH2_dev(I,K) = MAPL8_UNDEF
!            CFPDF_dev(I,K) = MAPL8_UNDEF
!            RHCLR_dev(I,K) = MAPL8_UNDEF
!            DQRL_dev(I,K) = MAPL8_UNDEF
!            VFALLICE_AN_dev(I,K) = MAPL8_UNDEF
!            VFALLICE_LS_dev(I,K) = MAPL8_UNDEF
!            VFALLWAT_AN_dev(I,K) = MAPL8_UNDEF
!            VFALLWAT_LS_dev(I,K) = MAPL8_UNDEF
!            VFALLSN_AN_dev(I,K) = MAPL8_UNDEF
!            VFALLSN_LS_dev(I,K) = MAPL8_UNDEF
!            VFALLSN_CN_dev(I,K) = MAPL8_UNDEF
!            VFALLRN_AN_dev(I,K) = MAPL8_UNDEF
!            VFALLRN_LS_dev(I,K) = MAPL8_UNDEF
!            VFALLRN_CN_dev(I,K) = MAPL8_UNDEF
! Copy QRN_CU into a temp scalar
        qrn_cu_1d = qrn_cu_dev(i, k)
! layer-mass (kg/m**2)
        mass = (ppe_dev(i, k)-ppe_dev(i, k-1))*100./mapl8_grav
        imass = 1.0/mass
        temp = exnp_dev(i, k)*th_dev(i, k)
!            FRZ_PP_dev(I,K) = 0.00
!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Total Condensate Source
!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            FIXL_dev(I,K) = QLW_AN_dev(I,K) + QLW_LS_dev(I,K)
!            FIXI_dev(I,K) = QIW_AN_dev(I,K) + QIW_LS_dev(I,K)
        CALL PUSHREAL8(anvfrc_dev(i, k))
        CALL PUSHREAL8(qiw_an_dev(i, k))
        CALL PUSHREAL8(qlw_an_dev(i, k))
        CALL PUSHREAL8(cldfrc_dev(i, k))
        CALL PUSHREAL8(qiw_ls_dev(i, k))
        CALL PUSHREAL8(qlw_ls_dev(i, k))
        CALL FIX_UP_CLOUDS(q_dev(i, k), temp, qlw_ls_dev(i, k), &
&                    qiw_ls_dev(i, k), cldfrc_dev(i, k), qlw_an_dev(i, k&
&                    ), qiw_an_dev(i, k), anvfrc_dev(i, k))
!            FIXL_dev(I,K) = -( QLW_AN_dev(I,K) + QLW_LS_dev(I,K) - FIXL_dev(I,K) ) / DT 
!            FIXI_dev(I,K) = -( QIW_AN_dev(I,K) + QIW_LS_dev(I,K) - FIXI_dev(I,K) ) / DT 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            FRZ_TT_dev(I,K) = QIW_AN_dev(I,K) + QIW_LS_dev(I,K)
        CALL PUSHREAL8(qiw_ls_dev(i, k))
        CALL PUSHREAL8(qlw_ls_dev(i, k))
        CALL PUSHREAL8(temp)
        CALL MELTFRZ(dt, temp, qlw_ls_dev(i, k), qiw_ls_dev(i, k))
        CALL PUSHREAL8(qiw_an_dev(i, k))
        CALL PUSHREAL8(qlw_an_dev(i, k))
        CALL PUSHREAL8(temp)
        CALL MELTFRZ(dt, temp, qlw_an_dev(i, k), qiw_an_dev(i, k))
!            FRZ_TT_dev(I,K) = ( QIW_AN_dev(I,K) + QIW_LS_dev(I,K) - FRZ_TT_dev(I,K) ) / DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            DCNVi_dev(I,K) = QIW_AN_dev(I,K)
!            DCNVL_dev(I,K) = QLW_AN_dev(I,K)
        CALL PUSHREAL8(anvfrc_dev(i, k))
        CALL PUSHREAL8(qiw_an_dev(i, k))
        CALL PUSHREAL8(qlw_an_dev(i, k))
        CALL PUSHREAL8(q_dev(i, k))
        CALL PUSHREAL8(temp)
        CALL CNVSRC(dt, cnviceparam, sclmfdfr, mass, imass, pp_dev(i, k)&
&             , temp, q_dev(i, k), qlwdtr_dev(i, k), rmfdtr_dev(i, k), &
&             qlw_an_dev(i, k), qiw_an_dev(i, k), cldfrc_dev(i, k), &
&             anvfrc_dev(i, k), qst3_dev(i, k))
!            DCNVi_dev(I,K) = ( QIW_AN_dev(I,K) - DCNVi_dev(I,K) ) / DT
!            DCNVL_dev(I,K) = ( QLW_AN_dev(I,K) - DCNVL_dev(I,K) ) / DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            PDFL_dev(I,K) = QLW_LS_dev(I,K)+QLW_AN_dev(I,K)
!            PDFI_dev(I,K) = QIW_LS_dev(I,K)+QIW_AN_dev(I,K)
        IF (k .EQ. ktop .OR. k .EQ. lm) THEN
          CALL PUSHREAL8(u_above)
          u_above = 0.0
          CALL PUSHREAL8(u_below)
          u_below = 0.0
          CALL PUSHREAL8(v_above)
          v_above = 0.0
          CALL PUSHREAL8(v_below)
          v_below = 0.0
          CALL PUSHREAL8(dzet_above)
          dzet_above = 0.0
          CALL PUSHREAL8(dzet_below)
          dzet_below = 0.0
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHREAL8(u_above)
          u_above = u_dev(i, k-1)
          CALL PUSHREAL8(u_below)
          u_below = u_dev(i, k+1)
          CALL PUSHREAL8(v_above)
          v_above = v_dev(i, k-1)
          CALL PUSHREAL8(v_below)
          v_below = v_dev(i, k+1)
          CALL PUSHREAL8(dzet_above)
          dzet_above = dzet_dev(i, k-1)
          CALL PUSHREAL8(dzet_below)
          dzet_below = dzet_dev(i, k+1)
          CALL PUSHCONTROL1B(0)
        END IF
!                  ALPHT_dev(I,K), ALPH1_dev(I,K),!ALPH2_dev(I,K), & 
        CALL PUSHREAL8(alpha)
        CALL PDF_SPREAD(k, lm, u_dev(i, k), u_above, u_below, v_dev(i, k&
&                 ), v_above, v_below, kh_dev(i, k-1), dzet_above, &
&                 dzet_below, cnv_updfrc_dev(i, k), pp_dev(i, k), alpha&
&                 , frland_dev(i))
        IF (alpha .LT. 1.0 - rh00) THEN
          alpha = 1.0 - rh00
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
          alpha = alpha
        END IF
        CALL PUSHREAL8(rhcrit)
        rhcrit = 1.0 - alpha
        CALL PUSHREAL8(anvfrc_dev(i, k))
        CALL PUSHREAL8(cldfrc_dev(i, k))
        CALL PUSHREAL8(temp)
        CALL PUSHREAL8(qiw_an_dev(i, k))
        CALL PUSHREAL8(qiw_ls_dev(i, k))
        CALL PUSHREAL8(qlw_an_dev(i, k))
        CALL PUSHREAL8(qlw_ls_dev(i, k))
        CALL PUSHREAL8(q_dev(i, k))
        CALL HYSTPDF(dt, alpha, pdfflag, pp_dev(i, k), q_dev(i, k), &
&              qlw_ls_dev(i, k), qlw_an_dev(i, k), qiw_ls_dev(i, k), &
&              qiw_an_dev(i, k), temp, cldfrc_dev(i, k), anvfrc_dev(i, k&
&              ))
!            RHX_dev(I,K)   = Q_dev(I,K)/QSAT( TEMP, PP_dev(I,K) )
!            CFPDF_dev(I,K) = CLDFRC_dev(I,K)
!            PDFL_dev(I,K)  = ( QLW_LS_dev(I,K) + QLW_AN_dev(I,K) - PDFL_dev(I,K) ) / DT 
!            PDFI_dev(I,K)  = ( QIW_LS_dev(I,K) + QIW_AN_dev(I,K) - PDFI_dev(I,K) ) / DT 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        CALL PUSHREAL8(totfrc)
        totfrc = cldfrc_dev(i, k) + anvfrc_dev(i, k)
        IF (totfrc .GT. 1.00) THEN
          CALL PUSHREAL8(cldfrc_dev(i, k))
          cldfrc_dev(i, k) = cldfrc_dev(i, k)*(1.00/totfrc)
          CALL PUSHREAL8(anvfrc_dev(i, k))
          anvfrc_dev(i, k) = anvfrc_dev(i, k)*(1.00/totfrc)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! CONDENSATE/FRACTION SOURCES FINISHED. NOW LOSE CLOUD CONDENSATE !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Total Condensate Sink
!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!       E  V  A  P  O  R  A  T  I  O  N
!!                A  N  D 
!!       S  U  B  L  I  M  A  T  I  O  N
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            EVAPC_dev(I,K) = QLW_LS_dev(I,K)+QLW_AN_dev(I,K)
!            SUBLC_dev(I,K) = QIW_LS_dev(I,K)+QIW_AN_dev(I,K)
! 'Anvil' partition from RAS/Parameterized not done in hystpdf
        CALL PUSHREAL8(anvfrc_dev(i, k))
        CALL PUSHREAL8(qlw_an_dev(i, k))
        CALL PUSHREAL8(q_dev(i, k))
        CALL PUSHREAL8(temp)
        CALL EVAP3(dt, rhcrit, pp_dev(i, k), temp, q_dev(i, k), &
&            qlw_an_dev(i, k), qiw_an_dev(i, k), anvfrc_dev(i, k), &
&            cldfrc_dev(i, k), qst3_dev(i, k))
        CALL PUSHREAL8(anvfrc_dev(i, k))
        CALL PUSHREAL8(qiw_an_dev(i, k))
        CALL PUSHREAL8(q_dev(i, k))
        CALL PUSHREAL8(temp)
        CALL SUBL3(dt, rhcrit, pp_dev(i, k), temp, q_dev(i, k), &
&            qlw_an_dev(i, k), qiw_an_dev(i, k), anvfrc_dev(i, k), &
&            cldfrc_dev(i, k), qst3_dev(i, k))
!            EVAPC_dev(I,K) = ( EVAPC_dev(I,K) - (QLW_LS_dev(I,K)+QLW_AN_dev(I,K)) ) / DT
!            SUBLC_dev(I,K) = ( SUBLC_dev(I,K) - (QIW_LS_dev(I,K)+QIW_AN_dev(I,K)) ) / DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!       A U T O C O N V E R S I  O  N
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!           FRACTION_REMOVAL = 0 -> none
!                              1 -> constant in-cloud QC
!                              2 -> trim high edge of PDF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            AUT_dev(I,K) = QLW_LS_dev(I,K)+QLW_AN_dev(I,K)
        fraction_removal1 = fr_ls_wat
        CALL PUSHREAL8(vfall)
        CALL PUSHREAL8(cldfrc_dev(i, k))
        CALL PUSHREAL8(qlw_ls_dev(i, k))
        CALL AUTOCON3(dt, qlw_ls_dev(i, k), qrn_ls, temp, pp_dev(i, k), &
&               kh_dev(i, k-1), cldfrc_dev(i, k), ls_sdqv2, ls_sdqv3, &
&               ls_sdqvt1, dzet_dev(i, k), vfall, fraction_removal1)
!            VFALLWAT_LS_dev(I,K) = VFALL
        fraction_removal2 = fr_an_wat
        CALL PUSHREAL8(anvfrc_dev(i, k))
        CALL PUSHREAL8(qlw_an_dev(i, k))
        CALL AUTOCON3(dt, qlw_an_dev(i, k), qrn_an, temp, pp_dev(i, k), &
&               kh_dev(i, k), anvfrc_dev(i, k), anv_sdqv2, anv_sdqv3, &
&               anv_sdqvt1, dzet_dev(i, k), vfall, fraction_removal2)
!            VFALLWAT_AN_dev(I,K) = VFALL
!            AUT_dev(I,K) = ( AUT_dev(I,K) - ( QLW_AN_dev(I,K) + QLW_LS_dev(I,K) ) )/DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Ice cloud settling
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            SDM_dev(I,K) = QIW_AN_dev(I,K)+QIW_LS_dev(I,K)
! Parameterized (RAS) Ice Fall
! ----------------------------
! WMP: Adjustments to resolved scale ice fall speed options                            
        IF (cnv_fraction_dev(i) .GE. 0.5) THEN
          CALL PUSHINTEGER4(fraction_removal3)
          fraction_removal3 = fr_an_ice
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHINTEGER4(fraction_removal3)
          fraction_removal3 = fr_ls_ice
          CALL PUSHCONTROL1B(1)
        END IF
        SELECT CASE  (ice_settle) 
        CASE (0) 
! MERRA-2 Formulation
          CALL PUSHREAL8(tropical)
          tropical = anv_icefall_c*1.0
          CALL PUSHREAL8(extratropical)
          extratropical = anv_icefall_c*0.0
          CALL PUSHCONTROL2B(1)
        CASE (1) 
          CALL PUSHREAL8(tropical)
          tropical = cnv_fraction_dev(i)
          CALL PUSHREAL8(extratropical)
          extratropical = 1.0 - tropical
          tropical = anv_icefall_c*tropical
          extratropical = ls_icefall_c*extratropical
          CALL PUSHCONTROL2B(2)
        CASE DEFAULT
          CALL PUSHCONTROL2B(0)
        END SELECT
        CALL SETTLE_VEL(wrhodep, qiw_an_dev(i, k), pp_dev(i, k), temp, &
&                 anvfrc_dev(i, k), kh_dev(i, k-1), vfall, extratropical&
&                 , tropical)
!            VFALLICE_AN_dev(I,K) = VFALL
        CALL PUSHREAL8(anvfrc_dev(i, k))
        CALL PUSHREAL8(qiw_an_dev(i, k))
        CALL ICEFALL(qiw_an_dev(i, k), dzet_dev(i, k), qsn_an, vfall, &
&              anvfrc_dev(i, k), dt, fraction_removal3)
! Resolved Scale Ice Fall
! -----------------------
! WMP: Adjustments to resolved scale ice fall speed options 
        SELECT CASE  (ice_settle) 
        CASE (0) 
! MERRA-2 Formulation
          CALL PUSHREAL8(tropical)
          tropical = ls_icefall_c*0.0
          CALL PUSHREAL8(extratropical)
          extratropical = ls_icefall_c*1.0
          CALL PUSHCONTROL2B(1)
        CASE (1) 
          CALL PUSHREAL8(tropical)
          tropical = cnv_fraction_dev(i)
          CALL PUSHREAL8(extratropical)
          extratropical = 1.0 - tropical
          tropical = anv_icefall_c*tropical
          extratropical = ls_icefall_c*extratropical
          CALL PUSHCONTROL2B(2)
        CASE DEFAULT
          CALL PUSHCONTROL2B(0)
        END SELECT
        CALL PUSHREAL8(vfall)
        CALL SETTLE_VEL(wrhodep, qiw_ls_dev(i, k), pp_dev(i, k), temp, &
&                 cldfrc_dev(i, k), kh_dev(i, k-1), vfall, extratropical&
&                 , tropical)
!            VFALLICE_LS_dev(I,K) = VFALL
        CALL PUSHREAL8(cldfrc_dev(i, k))
        CALL PUSHREAL8(qiw_ls_dev(i, k))
        CALL ICEFALL(qiw_ls_dev(i, k), dzet_dev(i, k), qsn_ls, vfall, &
&              cldfrc_dev(i, k), dt, fraction_removal3)
!            SDM_dev(I,K) = ( SDM_dev(I,K) - (QIW_LS_dev(I,K) + QIW_AN_dev(I,K)) )/DT
!            DQRL_dev(I,K) = ( QRN_LS + QRN_AN + QSN_LS + QSN_AN ) / DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Add in convective rain 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! CU-FREEZE 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Also "freeze" out any conv. precip that needs
! to be since this isnt done in RAS. This is
! precip w/ large particles, so freezing is 
! strict. Check up on this!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        IF (temp .LT. mapl8_tice) THEN
          qsn_cu = qrn_cu_1d
          qrn_cu_1d = 0.
          CALL PUSHREAL8(temp)
          temp = temp + qsn_cu*(mapl8_alhs-mapl8_alhl)/mapl8_cp
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!            FRZ_PP_dev(I,K) = FRZ_PP_dev(I,K) +  QTMP2/DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!----------------------------------------------------------------------------------------------
! Column will now be swept from top-down for precip accumulation/accretion/re-evaporation
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        CALL PUSHREAL8(area_ls_prc_tolayer)
        area_ls_prc_tolayer = 0.0
        CALL PUSHREAL8(area_upd_prc_tolayer)
        area_upd_prc_tolayer = 0.0
        CALL PUSHREAL8(area_anv_prc_tolayer)
        area_anv_prc_tolayer = 0.0
        CALL PUSHREAL8(tot_prec_upd)
        tot_prec_upd = tot_prec_upd + (qrn_cu_1d+qsn_cu)*mass
        CALL PUSHREAL8(area_upd_prc)
        area_upd_prc = area_upd_prc + cnv_updfrc_dev(i, k)*(qrn_cu_1d+&
&         qsn_cu)*mass
        CALL PUSHREAL8(tot_prec_anv)
        tot_prec_anv = tot_prec_anv + (qrn_an+qsn_an)*mass
        CALL PUSHREAL8(area_anv_prc)
        area_anv_prc = area_anv_prc + anvfrc_dev(i, k)*(qrn_an+qsn_an)*&
&         mass
        CALL PUSHREAL8(tot_prec_ls)
        tot_prec_ls = tot_prec_ls + (qrn_ls+qsn_ls)*mass
        CALL PUSHREAL8(area_ls_prc)
        area_ls_prc = area_ls_prc + cldfrc_dev(i, k)*(qrn_ls+qsn_ls)*&
&         mass
        IF (tot_prec_anv .GT. 0.0) THEN
          IF (area_anv_prc/tot_prec_anv .LT. 1.e-6) THEN
            CALL PUSHCONTROL2B(2)
            area_anv_prc_tolayer = 1.e-6
          ELSE
            area_anv_prc_tolayer = area_anv_prc/tot_prec_anv
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
        IF (tot_prec_upd .GT. 0.0) THEN
          IF (area_upd_prc/tot_prec_upd .LT. 1.e-6) THEN
            CALL PUSHCONTROL2B(2)
            area_upd_prc_tolayer = 1.e-6
          ELSE
            area_upd_prc_tolayer = area_upd_prc/tot_prec_upd
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
        IF (tot_prec_ls .GT. 0.0) THEN
          IF (area_ls_prc/tot_prec_ls .LT. 1.e-6) THEN
            CALL PUSHCONTROL2B(2)
            area_ls_prc_tolayer = 1.e-6
          ELSE
            area_ls_prc_tolayer = area_ls_prc/tot_prec_ls
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
        area_ls_prc_tolayer = ls_beta*area_ls_prc_tolayer
        area_upd_prc_tolayer = cnv_beta*area_upd_prc_tolayer
        area_anv_prc_tolayer = anv_beta*area_anv_prc_tolayer
        IF (k .EQ. lm) THEN
! Weve accumulated over the whole column
          IF (tot_prec_anv .GT. 0.0) THEN
            IF (area_anv_prc/tot_prec_anv .LT. 1.e-6) THEN
              CALL PUSHREAL8(area_anv_prc)
              area_anv_prc = 1.e-6
              CALL PUSHCONTROL2B(2)
            ELSE
              CALL PUSHREAL8(area_anv_prc)
              area_anv_prc = area_anv_prc/tot_prec_anv
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B(0)
          END IF
          IF (tot_prec_upd .GT. 0.0) THEN
            IF (area_upd_prc/tot_prec_upd .LT. 1.e-6) THEN
              CALL PUSHREAL8(area_upd_prc)
              area_upd_prc = 1.e-6
              CALL PUSHCONTROL2B(2)
            ELSE
              CALL PUSHREAL8(area_upd_prc)
              area_upd_prc = area_upd_prc/tot_prec_upd
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B(0)
          END IF
          IF (tot_prec_ls .GT. 0.0) THEN
            IF (area_ls_prc/tot_prec_ls .LT. 1.e-6) THEN
              CALL PUSHREAL8(area_ls_prc)
              area_ls_prc = 1.e-6
              CALL PUSHCONTROL2B(2)
            ELSE
              CALL PUSHREAL8(area_ls_prc)
              area_ls_prc = area_ls_prc/tot_prec_ls
              CALL PUSHCONTROL2B(1)
            END IF
          ELSE
            CALL PUSHCONTROL2B(0)
          END IF
          CALL PUSHREAL8(area_ls_prc)
          area_ls_prc = ls_beta*area_ls_prc
          CALL PUSHREAL8(area_upd_prc)
          area_upd_prc = cnv_beta*area_upd_prc
          CALL PUSHREAL8(area_anv_prc)
          area_anv_prc = anv_beta*area_anv_prc
!! "couple" to diagnostic areal(8) fraction output 
!! Intensity factor in PRECIP3 is floored at
!! 1.0. So this is fair.
!               LSARF_dev(I) = MIN( AREA_LS_PRC,  1.0 )
!               CUARF_dev(I) = MIN( AREA_UPD_PRC, 1.0 )
!               ANARF_dev(I) = MIN( AREA_ANV_PRC, 1.0 )
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
!            QRN_ALL = 0.
!            QSN_ALL = 0.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! GET SOME MICROPHYSICAL QUANTITIES 
        CALL PUSHREAL8(bb3)
        CALL PUSHREAL8(aa3)
        CALL MICRO_AA_BB_3(temp, pp_dev(i, k), qst3_dev(i, k), aa3, bb3)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        CALL PUSHREAL8(qtmp1)
        qtmp1 = qlw_ls_dev(i, k) + qlw_an_dev(i, k)
        CALL PUSHREAL8(qtmp2)
        qtmp2 = qiw_ls_dev(i, k) + qiw_an_dev(i, k)
! CNVENVFC passed in as argument (default=0.8)
! Unlike CNVENVFC which is from PHYSPARAMS, this is set to 1.
! Unlike CNVENVFC which is from PHYSPARAMS, this is set to 1.
        lsenvfc = 1.00
! Apply convective fractions
        envfc = cnvenvfc*cnv_fraction_dev(i) + lsenvfc*(1.0-&
&         cnv_fraction_dev(i))
! Convective
! ----------
!                  PRECU_dev(I)    , & 
!                  SNRCU_dev(I)    , & 
!                  REV_CN_dev(I,K) , &
!                  RSU_CN_dev(I,K) , &
!                  ACLL_CN_dev(I,K), &
!                  ACIL_CN_dev(I,K), &
!                  PFL_CN_dev(I,K) , &
!                  PFI_CN_dev(I,K) , &
!                  VFALLRN         , &
!                  VFALLSN         , &
!                  FRZ_PP_dev(I,K) , &
        CALL PUSHREAL8(subl_dd_cu_above)
        CALL PUSHREAL8(evap_dd_cu_above)
        CALL PUSHREAL8(psn_cu_above)
        CALL PUSHREAL8(prn_cu_above)
        CALL PUSHREAL8(q_dev(i, k))
        CALL PUSHREAL8(temp)
        CALL PUSHREAL8(qtmp1)
        CALL PUSHREAL8(qsn_cu)
        CALL PUSHREAL8(qrn_cu_1d)
        CALL PRECIP3(k, lm, dt, frland_dev(i), rhcrit, qrn_cu_1d, qsn_cu&
&              , qtmp1, qtmp2, temp, q_dev(i, k), mass, imass, pp_dev(i&
&              , k), dzet_dev(i, k), qddf3_dev(i, k), aa3, bb3, &
&              area_upd_prc_tolayer, prn_cu_above, psn_cu_above, &
&              evap_dd_cu_above, subl_dd_cu_above, envfc, cnvddrfc)
!            VFALLSN_CN_dev(I,K) = VFALLSN
!            VFALLRN_CN_dev(I,K) = VFALLRN
!            if (.not.use_autoconv_timescale) then
!               if (VFALLSN.NE.0.) then
!                  QSN_ALL = QSN_ALL + PFI_CN_dev(I,K)/VFALLSN
!               end if
!               if (VFALLRN.NE.0.) then
!                  QRN_ALL = QRN_ALL + PFL_CN_dev(I,K)/VFALLRN
!               end if
!            end if
! Anvil
! -----
!                  PREAN_dev(I)    , & 
!                  SNRAN_dev(I)    , &
!                  REV_AN_dev(I,K) , &
!                  RSU_AN_dev(I,K) , &
!                  ACLL_AN_dev(I,K), &
!                  ACIL_AN_dev(I,K), &
!                  PFL_AN_dev(I,K) , &
!                  PFI_AN_dev(I,K) , &
!                  VFALLRN         , &
!                  VFALLSN         , &
!                  FRZ_PP_dev(I,K) , &
        CALL PUSHREAL8(subl_dd_an_above)
        CALL PUSHREAL8(evap_dd_an_above)
        CALL PUSHREAL8(psn_an_above)
        CALL PUSHREAL8(prn_an_above)
        CALL PUSHREAL8(q_dev(i, k))
        CALL PUSHREAL8(temp)
        CALL PUSHREAL8(qtmp1)
        CALL PUSHREAL8(qsn_an)
        CALL PUSHREAL8(qrn_an)
        CALL PRECIP3(k, lm, dt, frland_dev(i), rhcrit, qrn_an, qsn_an, &
&              qtmp1, qtmp2, temp, q_dev(i, k), mass, imass, pp_dev(i, k&
&              ), dzet_dev(i, k), qddf3_dev(i, k), aa3, bb3, &
&              area_anv_prc_tolayer, prn_an_above, psn_an_above, &
&              evap_dd_an_above, subl_dd_an_above, envfc, anvddrfc)
!            VFALLSN_AN_dev(I,K) = VFALLSN
!            VFALLRN_AN_dev(I,K) = VFALLRN
!            if (.not.use_autoconv_timescale) then
!               if (VFALLSN.NE.0.) then
!                  QSN_ALL = QSN_ALL + PFI_AN_dev(I,K)/VFALLSN
!               end if
!               if (VFALLRN.NE.0.) then
!                  QRN_ALL = QRN_ALL + PFL_AN_dev(I,K)/VFALLRN
!               end if
!            end if
! Largescale
! ----------
!                  PRELS_dev(I)    , & 
!                  SNRLS_dev(I)    , &
!                  REV_LS_dev(I,K) , &
!                  RSU_LS_dev(I,K) , &    
!                  ACLL_LS_dev(I,K), &
!                  ACIL_LS_dev(I,K), &
!                  PFL_LS_dev(I,K) , &
!                  PFI_LS_dev(I,K) , &
!                  VFALLRN         , &
!                  VFALLSN         , &
!                  FRZ_PP_dev(I,K) , &
        CALL PUSHREAL8(subl_dd_ls_above)
        CALL PUSHREAL8(evap_dd_ls_above)
        CALL PUSHREAL8(psn_ls_above)
        CALL PUSHREAL8(prn_ls_above)
        CALL PUSHREAL8(q_dev(i, k))
        CALL PUSHREAL8(temp)
        CALL PUSHREAL8(qtmp1)
        CALL PUSHREAL8(qsn_ls)
        CALL PUSHREAL8(qrn_ls)
        CALL PRECIP3(k, lm, dt, frland_dev(i), rhcrit, qrn_ls, qsn_ls, &
&              qtmp1, qtmp2, temp, q_dev(i, k), mass, imass, pp_dev(i, k&
&              ), dzet_dev(i, k), qddf3_dev(i, k), aa3, bb3, &
&              area_ls_prc_tolayer, prn_ls_above, psn_ls_above, &
&              evap_dd_ls_above, subl_dd_ls_above, envfc, lsddrfc)
!            VFALLSN_LS_dev(I,K) = VFALLSN
!            VFALLRN_LS_dev(I,K) = VFALLRN
!            if (.not.use_autoconv_timescale) then
!               if (VFALLSN.NE.0.) then
!                  QSN_ALL = QSN_ALL + PFI_LS_dev(I,K)/VFALLSN
!               end if
!               if (VFALLRN.NE.0.) then
!                  QRN_ALL = QRN_ALL + PFL_LS_dev(I,K)/VFALLRN
!               end if
!               if (VFALLRN.NE.0. .AND. VFALLSN.NE.0.) then
!                  QPLS_dev(I,K) = QPLS_dev(I,K) + PFL_LS_dev(I,K)/VFALLRN + PFI_LS_dev(I,K)/VFALLSN
!               end if 
!            end if
        IF (qlw_ls_dev(i, k) + qlw_an_dev(i, k) .GT. 0.00) THEN
          CALL PUSHREAL8(qtmp3)
          qtmp3 = 1./(qlw_ls_dev(i, k)+qlw_an_dev(i, k))
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL8(qtmp3)
          qtmp3 = 0.0
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHREAL8(qlw_ls_dev(i, k))
        qlw_ls_dev(i, k) = qlw_ls_dev(i, k)*qtmp1*qtmp3
        CALL PUSHREAL8(qlw_an_dev(i, k))
        qlw_an_dev(i, k) = qlw_an_dev(i, k)*qtmp1*qtmp3
        IF (qiw_ls_dev(i, k) + qiw_an_dev(i, k) .GT. 0.00) THEN
          CALL PUSHREAL8(qtmp3)
          qtmp3 = 1./(qiw_ls_dev(i, k)+qiw_an_dev(i, k))
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL8(qtmp3)
          qtmp3 = 0.0
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHREAL8(qiw_ls_dev(i, k))
        qiw_ls_dev(i, k) = qiw_ls_dev(i, k)*qtmp2*qtmp3
        CALL PUSHREAL8(qiw_an_dev(i, k))
        qiw_an_dev(i, k) = qiw_an_dev(i, k)*qtmp2*qtmp3
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        th_dev(i, k) = temp/exnp_dev(i, k)
!            QRN_ALL = QRN_ALL / (100.*PP_dev(I,K) / (MAPL8_RGAS*TEMP ))
!            QSN_ALL = QSN_ALL / (100.*PP_dev(I,K) / (MAPL8_RGAS*TEMP ))
!            RHCLR_dev(I,K) = MIN( CLDFRC_dev(I,K) + ANVFRC_dev(I,K), 1.00 )
!            IF ( RHCLR_dev(I,K) < 1.00 ) THEN
!               RHCLR_dev(I,K) = ( MIN( Q_dev(I,K)/QSAT(TEMP,PP_dev(I,K)),1.0 ) - RHCLR_dev(I,K) ) / &
!                                     (1. - RHCLR_dev(I,K))
!               IF ( RHCLR_dev(I,K) < 0.00 ) THEN
!                  RHCLR_dev(I,K) = MAPL8_UNDEF
!               END IF
!            ELSE
!               RHCLR_dev(I,K) = MAPL8_UNDEF
!            END IF
!            IF (DISABLE_RAD==1) THEN
!               RAD_QL_dev(I,K)     = 0.
!               RAD_QI_dev(I,K)     = 0.
!               RAD_QR_dev(I,K)     = 0.
!               RAD_QS_dev(I,K)     = 0.
!               RAD_CLDFRC_dev(I,K) = 0.
!               CLDREFFL_dev(I,K)   = 0.
!               CLDREFFI_dev(I,K)   = 0.
!            ELSE
!               call RADCOUPLE ( TEMP, PP_dev(I,K), CLDFRC_dev(I,K), ANVFRC_dev(I,K), &
!                     QLW_LS_dev(I,K), QIW_LS_dev(I,K), QLW_AN_dev(I,K), QIW_AN_dev(I,K), QRN_ALL, QSN_ALL, & 
!                     RAD_QL_dev(I,K), RAD_QI_dev(I,K), RAD_QR_dev(I,K), RAD_QS_dev(I,K), RAD_CLDFRC_dev(I,K), & 
!                     CLDREFFL_dev(I,K), CLDREFFI_dev(I,K), CLDVOL2FRC,N_ANVIL*1.e6,N_ICE*1.e6,N_WARM*1.e6, &
!                     TEMPOR_dev(I))
!            END IF
        qrn_cu_dev(i, k) = qrn_cu_1d
      END DO k_loop
    END DO run_loop
    qddf3_dev_ad = 0.0_8
    cnv_updfrc_dev_ad = 0.0_8
    dzet_dev_ad = 0.0_8
    qst3_dev_ad = 0.0_8
    qrn_cu_dev_ad = 0.0_8
    qlwdtr_dev_ad = 0.0_8
    rmfdtr_dev_ad = 0.0_8
    evap_dd_ls_above_ad = 0.0_8
    prn_ls_above_ad = 0.0_8
    subl_dd_ls_above_ad = 0.0_8
    area_upd_prc_ad = 0.0_8
    tot_prec_ls_ad = 0.0_8
    psn_an_above_ad = 0.0_8
    evap_dd_cu_above_ad = 0.0_8
    prn_cu_above_ad = 0.0_8
    subl_dd_cu_above_ad = 0.0_8
    psn_ls_above_ad = 0.0_8
    area_ls_prc_ad = 0.0_8
    tot_prec_upd_ad = 0.0_8
    area_anv_prc_ad = 0.0_8
    psn_cu_above_ad = 0.0_8
    tot_prec_anv_ad = 0.0_8
    evap_dd_an_above_ad = 0.0_8
    prn_an_above_ad = 0.0_8
    subl_dd_an_above_ad = 0.0_8
    DO i=irun,1,-1
      DO k=lm,ktop,-1
        qrn_cu_dev_ad(i, k) = 0.0_8
        temp_ad = th_dev_ad(i, k)/exnp_dev(i, k)
        th_dev_ad(i, k) = 0.0_8
        CALL POPREAL8(qiw_an_dev(i, k))
        temp_ad7 = qiw_an_dev(i, k)*qiw_an_dev_ad(i, k)
        qiw_an_dev_ad(i, k) = qtmp2*qtmp3*qiw_an_dev_ad(i, k)
        CALL POPREAL8(qiw_ls_dev(i, k))
        temp_ad8 = qiw_ls_dev(i, k)*qiw_ls_dev_ad(i, k)
        qtmp2_ad = qtmp3*temp_ad8 + qtmp3*temp_ad7
        qtmp3_ad = qtmp2*temp_ad8 + qtmp2*temp_ad7
        qiw_ls_dev_ad(i, k) = qtmp2*qtmp3*qiw_ls_dev_ad(i, k)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(qtmp3)
          temp1 = qiw_ls_dev(i, k) + qiw_an_dev(i, k)
          temp_ad6 = -(qtmp3_ad/temp1**2)
          qiw_ls_dev_ad(i, k) = qiw_ls_dev_ad(i, k) + temp_ad6
          qiw_an_dev_ad(i, k) = qiw_an_dev_ad(i, k) + temp_ad6
        ELSE
          CALL POPREAL8(qtmp3)
        END IF
        CALL POPREAL8(qlw_an_dev(i, k))
        temp_ad4 = qlw_an_dev(i, k)*qlw_an_dev_ad(i, k)
        qlw_an_dev_ad(i, k) = qtmp1*qtmp3*qlw_an_dev_ad(i, k)
        CALL POPREAL8(qlw_ls_dev(i, k))
        temp_ad5 = qlw_ls_dev(i, k)*qlw_ls_dev_ad(i, k)
        qtmp1_ad = qtmp3*temp_ad5 + qtmp3*temp_ad4
        qtmp3_ad = qtmp1*temp_ad5 + qtmp1*temp_ad4
        qlw_ls_dev_ad(i, k) = qtmp1*qtmp3*qlw_ls_dev_ad(i, k)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(qtmp3)
          temp0 = qlw_ls_dev(i, k) + qlw_an_dev(i, k)
          temp_ad3 = -(qtmp3_ad/temp0**2)
          qlw_ls_dev_ad(i, k) = qlw_ls_dev_ad(i, k) + temp_ad3
          qlw_an_dev_ad(i, k) = qlw_an_dev_ad(i, k) + temp_ad3
        ELSE
          CALL POPREAL8(qtmp3)
        END IF
        mass = (ppe_dev(i, k)-ppe_dev(i, k-1))*100./mapl8_grav
        imass = 1.0/mass
        lsenvfc = 1.00
        envfc = cnvenvfc*cnv_fraction_dev(i) + lsenvfc*(1.0-&
&         cnv_fraction_dev(i))
        CALL POPREAL8(qrn_ls)
        CALL POPREAL8(qsn_ls)
        CALL POPREAL8(qtmp1)
        CALL POPREAL8(temp)
        CALL POPREAL8(q_dev(i, k))
        CALL POPREAL8(prn_ls_above)
        CALL POPREAL8(psn_ls_above)
        CALL POPREAL8(evap_dd_ls_above)
        CALL POPREAL8(subl_dd_ls_above)
        rhcrit_ad = 0.0_8
        aa3_ad = 0.0_8
        bb3_ad = 0.0_8
        CALL PRECIP3_ADM(k, lm, dt, frland_dev(i), rhcrit, rhcrit_ad, &
&                  qrn_ls, qrn_ls_ad, qsn_ls, qsn_ls_ad, qtmp1, qtmp1_ad&
&                  , qtmp2, temp, temp_ad, q_dev(i, k), q_dev_ad(i, k), &
&                  mass, imass, pp_dev(i, k), dzet_dev(i, k), &
&                  dzet_dev_ad(i, k), qddf3_dev(i, k), qddf3_dev_ad(i, k&
&                  ), aa3, aa3_ad, bb3, bb3_ad, area_ls_prc_tolayer, &
&                  area_ls_prc_tolayer_ad, prn_ls_above, prn_ls_above_ad&
&                  , psn_ls_above, psn_ls_above_ad, evap_dd_ls_above, &
&                  evap_dd_ls_above_ad, subl_dd_ls_above, &
&                  subl_dd_ls_above_ad, envfc, lsddrfc)
        CALL POPREAL8(qrn_an)
        CALL POPREAL8(qsn_an)
        CALL POPREAL8(qtmp1)
        CALL POPREAL8(temp)
        CALL POPREAL8(q_dev(i, k))
        CALL POPREAL8(prn_an_above)
        CALL POPREAL8(psn_an_above)
        CALL POPREAL8(evap_dd_an_above)
        CALL POPREAL8(subl_dd_an_above)
        CALL PRECIP3_ADM(k, lm, dt, frland_dev(i), rhcrit, rhcrit_ad, &
&                  qrn_an, qrn_an_ad, qsn_an, qsn_an_ad, qtmp1, qtmp1_ad&
&                  , qtmp2, temp, temp_ad, q_dev(i, k), q_dev_ad(i, k), &
&                  mass, imass, pp_dev(i, k), dzet_dev(i, k), &
&                  dzet_dev_ad(i, k), qddf3_dev(i, k), qddf3_dev_ad(i, k&
&                  ), aa3, aa3_ad, bb3, bb3_ad, area_anv_prc_tolayer, &
&                  area_anv_prc_tolayer_ad, prn_an_above, &
&                  prn_an_above_ad, psn_an_above, psn_an_above_ad, &
&                  evap_dd_an_above, evap_dd_an_above_ad, &
&                  subl_dd_an_above, subl_dd_an_above_ad, envfc, &
&                  anvddrfc)
        CALL POPREAL8(qrn_cu_1d)
        CALL POPREAL8(qsn_cu)
        CALL POPREAL8(qtmp1)
        CALL POPREAL8(temp)
        CALL POPREAL8(q_dev(i, k))
        CALL POPREAL8(prn_cu_above)
        CALL POPREAL8(psn_cu_above)
        CALL POPREAL8(evap_dd_cu_above)
        CALL POPREAL8(subl_dd_cu_above)
        CALL PRECIP3_ADM(k, lm, dt, frland_dev(i), rhcrit, rhcrit_ad, &
&                  qrn_cu_1d, qrn_cu_1d_ad, qsn_cu, qsn_cu_ad, qtmp1, &
&                  qtmp1_ad, qtmp2, temp, temp_ad, q_dev(i, k), q_dev_ad&
&                  (i, k), mass, imass, pp_dev(i, k), dzet_dev(i, k), &
&                  dzet_dev_ad(i, k), qddf3_dev(i, k), qddf3_dev_ad(i, k&
&                  ), aa3, aa3_ad, bb3, bb3_ad, area_upd_prc_tolayer, &
&                  area_upd_prc_tolayer_ad, prn_cu_above, &
&                  prn_cu_above_ad, psn_cu_above, psn_cu_above_ad, &
&                  evap_dd_cu_above, evap_dd_cu_above_ad, &
&                  subl_dd_cu_above, subl_dd_cu_above_ad, envfc, &
&                  cnvddrfc)
        CALL POPREAL8(qtmp2)
        qiw_ls_dev_ad(i, k) = qiw_ls_dev_ad(i, k) + qtmp2_ad
        qiw_an_dev_ad(i, k) = qiw_an_dev_ad(i, k) + qtmp2_ad
        CALL POPREAL8(qtmp1)
        qlw_ls_dev_ad(i, k) = qlw_ls_dev_ad(i, k) + qtmp1_ad
        qlw_an_dev_ad(i, k) = qlw_an_dev_ad(i, k) + qtmp1_ad
        CALL POPREAL8(aa3)
        CALL POPREAL8(bb3)
        CALL MICRO_AA_BB_3_ADM(temp, temp_ad, pp_dev(i, k), qst3_dev(i, &
&                        k), qst3_dev_ad(i, k), aa3, aa3_ad, bb3, bb3_ad&
&                       )
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(area_anv_prc)
          area_anv_prc_ad = anv_beta*area_anv_prc_ad
          CALL POPREAL8(area_upd_prc)
          area_upd_prc_ad = cnv_beta*area_upd_prc_ad
          CALL POPREAL8(area_ls_prc)
          area_ls_prc_ad = ls_beta*area_ls_prc_ad
          CALL POPCONTROL2B(branch)
          IF (branch .NE. 0) THEN
            IF (branch .EQ. 1) THEN
              CALL POPREAL8(area_ls_prc)
              tot_prec_ls_ad = tot_prec_ls_ad - area_ls_prc*&
&               area_ls_prc_ad/tot_prec_ls**2
              area_ls_prc_ad = area_ls_prc_ad/tot_prec_ls
            ELSE
              CALL POPREAL8(area_ls_prc)
              area_ls_prc_ad = 0.0_8
            END IF
          END IF
          CALL POPCONTROL2B(branch)
          IF (branch .NE. 0) THEN
            IF (branch .EQ. 1) THEN
              CALL POPREAL8(area_upd_prc)
              tot_prec_upd_ad = tot_prec_upd_ad - area_upd_prc*&
&               area_upd_prc_ad/tot_prec_upd**2
              area_upd_prc_ad = area_upd_prc_ad/tot_prec_upd
            ELSE
              CALL POPREAL8(area_upd_prc)
              area_upd_prc_ad = 0.0_8
            END IF
          END IF
          CALL POPCONTROL2B(branch)
          IF (branch .NE. 0) THEN
            IF (branch .EQ. 1) THEN
              CALL POPREAL8(area_anv_prc)
              tot_prec_anv_ad = tot_prec_anv_ad - area_anv_prc*&
&               area_anv_prc_ad/tot_prec_anv**2
              area_anv_prc_ad = area_anv_prc_ad/tot_prec_anv
            ELSE
              CALL POPREAL8(area_anv_prc)
              area_anv_prc_ad = 0.0_8
            END IF
          END IF
        END IF
        area_anv_prc_tolayer_ad = anv_beta*area_anv_prc_tolayer_ad
        area_upd_prc_tolayer_ad = cnv_beta*area_upd_prc_tolayer_ad
        area_ls_prc_tolayer_ad = ls_beta*area_ls_prc_tolayer_ad
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            area_ls_prc_ad = area_ls_prc_ad + area_ls_prc_tolayer_ad/&
&             tot_prec_ls
            tot_prec_ls_ad = tot_prec_ls_ad - area_ls_prc*&
&             area_ls_prc_tolayer_ad/tot_prec_ls**2
          END IF
        END IF
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            area_upd_prc_ad = area_upd_prc_ad + area_upd_prc_tolayer_ad/&
&             tot_prec_upd
            tot_prec_upd_ad = tot_prec_upd_ad - area_upd_prc*&
&             area_upd_prc_tolayer_ad/tot_prec_upd**2
          END IF
        END IF
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            area_anv_prc_ad = area_anv_prc_ad + area_anv_prc_tolayer_ad/&
&             tot_prec_anv
            tot_prec_anv_ad = tot_prec_anv_ad - area_anv_prc*&
&             area_anv_prc_tolayer_ad/tot_prec_anv**2
          END IF
        END IF
        CALL POPREAL8(area_ls_prc)
        temp_ad0 = mass*cldfrc_dev(i, k)*area_ls_prc_ad
        cldfrc_dev_ad(i, k) = cldfrc_dev_ad(i, k) + mass*(qrn_ls+qsn_ls)&
&         *area_ls_prc_ad
        qrn_ls_ad = qrn_ls_ad + mass*tot_prec_ls_ad + temp_ad0
        qsn_ls_ad = qsn_ls_ad + mass*tot_prec_ls_ad + temp_ad0
        CALL POPREAL8(tot_prec_ls)
        CALL POPREAL8(area_anv_prc)
        temp_ad1 = mass*anvfrc_dev(i, k)*area_anv_prc_ad
        anvfrc_dev_ad(i, k) = anvfrc_dev_ad(i, k) + mass*(qrn_an+qsn_an)&
&         *area_anv_prc_ad
        qrn_an_ad = qrn_an_ad + mass*tot_prec_anv_ad + temp_ad1
        qsn_an_ad = qsn_an_ad + mass*tot_prec_anv_ad + temp_ad1
        CALL POPREAL8(tot_prec_anv)
        CALL POPREAL8(area_upd_prc)
        temp_ad2 = mass*cnv_updfrc_dev(i, k)*area_upd_prc_ad
        cnv_updfrc_dev_ad(i, k) = cnv_updfrc_dev_ad(i, k) + mass*(&
&         qrn_cu_1d+qsn_cu)*area_upd_prc_ad
        qrn_cu_1d_ad = qrn_cu_1d_ad + mass*tot_prec_upd_ad + temp_ad2
        qsn_cu_ad = qsn_cu_ad + mass*tot_prec_upd_ad + temp_ad2
        CALL POPREAL8(tot_prec_upd)
        CALL POPREAL8(area_anv_prc_tolayer)
        CALL POPREAL8(area_upd_prc_tolayer)
        CALL POPREAL8(area_ls_prc_tolayer)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(temp)
          qsn_cu_ad = qsn_cu_ad + (mapl8_alhs-mapl8_alhl)*temp_ad/&
&           mapl8_cp
          qrn_cu_1d_ad = qsn_cu_ad
        END IF
        CALL POPREAL8(qiw_ls_dev(i, k))
        CALL POPREAL8(cldfrc_dev(i, k))
        CALL ICEFALL_ADM(qiw_ls_dev(i, k), qiw_ls_dev_ad(i, k), dzet_dev&
&                  (i, k), dzet_dev_ad(i, k), qsn_ls, qsn_ls_ad, vfall, &
&                  vfall_ad, cldfrc_dev(i, k), cldfrc_dev_ad(i, k), dt, &
&                  fraction_removal3)
        CALL POPREAL8(vfall)
        CALL SETTLE_VEL_ADM(wrhodep, qiw_ls_dev(i, k), qiw_ls_dev_ad(i, &
&                     k), pp_dev(i, k), temp, temp_ad, cldfrc_dev(i, k)&
&                     , cldfrc_dev_ad(i, k), kh_dev(i, k-1), vfall, &
&                     vfall_ad, extratropical, tropical)
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            CALL POPREAL8(extratropical)
            CALL POPREAL8(tropical)
          ELSE
            CALL POPREAL8(extratropical)
            CALL POPREAL8(tropical)
          END IF
        END IF
        CALL POPREAL8(qiw_an_dev(i, k))
        CALL POPREAL8(anvfrc_dev(i, k))
        CALL ICEFALL_ADM(qiw_an_dev(i, k), qiw_an_dev_ad(i, k), dzet_dev&
&                  (i, k), dzet_dev_ad(i, k), qsn_an, qsn_an_ad, vfall, &
&                  vfall_ad, anvfrc_dev(i, k), anvfrc_dev_ad(i, k), dt, &
&                  fraction_removal3)
        CALL SETTLE_VEL_ADM(wrhodep, qiw_an_dev(i, k), qiw_an_dev_ad(i, &
&                     k), pp_dev(i, k), temp, temp_ad, anvfrc_dev(i, k)&
&                     , anvfrc_dev_ad(i, k), kh_dev(i, k-1), vfall, &
&                     vfall_ad, extratropical, tropical)
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            CALL POPREAL8(extratropical)
            CALL POPREAL8(tropical)
          ELSE
            CALL POPREAL8(extratropical)
            CALL POPREAL8(tropical)
          END IF
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPINTEGER4(fraction_removal3)
        ELSE
          CALL POPINTEGER4(fraction_removal3)
        END IF
        fraction_removal2 = fr_an_wat
        CALL POPREAL8(qlw_an_dev(i, k))
        CALL POPREAL8(anvfrc_dev(i, k))
        CALL AUTOCON3_ADM(dt, qlw_an_dev(i, k), qlw_an_dev_ad(i, k), &
&                   qrn_an, qrn_an_ad, temp, temp_ad, pp_dev(i, k), &
&                   kh_dev(i, k), anvfrc_dev(i, k), anvfrc_dev_ad(i, k)&
&                   , anv_sdqv2, anv_sdqv3, anv_sdqvt1, dzet_dev(i, k), &
&                   vfall, fraction_removal2)
        fraction_removal1 = fr_ls_wat
        CALL POPREAL8(qlw_ls_dev(i, k))
        CALL POPREAL8(cldfrc_dev(i, k))
        CALL POPREAL8(vfall)
        CALL AUTOCON3_ADM(dt, qlw_ls_dev(i, k), qlw_ls_dev_ad(i, k), &
&                   qrn_ls, qrn_ls_ad, temp, temp_ad, pp_dev(i, k), &
&                   kh_dev(i, k-1), cldfrc_dev(i, k), cldfrc_dev_ad(i, k&
&                   ), ls_sdqv2, ls_sdqv3, ls_sdqvt1, dzet_dev(i, k), &
&                   vfall, fraction_removal1)
        CALL POPREAL8(temp)
        CALL POPREAL8(q_dev(i, k))
        CALL POPREAL8(qiw_an_dev(i, k))
        CALL POPREAL8(anvfrc_dev(i, k))
        CALL SUBL3_ADM(dt, rhcrit, rhcrit_ad, pp_dev(i, k), temp, &
&                temp_ad, q_dev(i, k), q_dev_ad(i, k), qlw_an_dev(i, k)&
&                , qlw_an_dev_ad(i, k), qiw_an_dev(i, k), qiw_an_dev_ad(&
&                i, k), anvfrc_dev(i, k), anvfrc_dev_ad(i, k), &
&                cldfrc_dev(i, k), qst3_dev(i, k), qst3_dev_ad(i, k))
        CALL POPREAL8(temp)
        CALL POPREAL8(q_dev(i, k))
        CALL POPREAL8(qlw_an_dev(i, k))
        CALL POPREAL8(anvfrc_dev(i, k))
        CALL EVAP3_ADM(dt, rhcrit, rhcrit_ad, pp_dev(i, k), temp, &
&                temp_ad, q_dev(i, k), q_dev_ad(i, k), qlw_an_dev(i, k)&
&                , qlw_an_dev_ad(i, k), qiw_an_dev(i, k), qiw_an_dev_ad(&
&                i, k), anvfrc_dev(i, k), anvfrc_dev_ad(i, k), &
&                cldfrc_dev(i, k), qst3_dev(i, k), qst3_dev_ad(i, k))
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(anvfrc_dev(i, k))
          CALL POPREAL8(cldfrc_dev(i, k))
          totfrc_ad = -(cldfrc_dev(i, k)*cldfrc_dev_ad(i, k)/totfrc**2) &
&           - anvfrc_dev(i, k)*anvfrc_dev_ad(i, k)/totfrc**2
          anvfrc_dev_ad(i, k) = anvfrc_dev_ad(i, k)/totfrc
          cldfrc_dev_ad(i, k) = cldfrc_dev_ad(i, k)/totfrc
        ELSE
          totfrc_ad = 0.0_8
        END IF
        CALL POPREAL8(totfrc)
        cldfrc_dev_ad(i, k) = cldfrc_dev_ad(i, k) + totfrc_ad
        anvfrc_dev_ad(i, k) = anvfrc_dev_ad(i, k) + totfrc_ad
        CALL POPREAL8(q_dev(i, k))
        CALL POPREAL8(qlw_ls_dev(i, k))
        CALL POPREAL8(qlw_an_dev(i, k))
        CALL POPREAL8(qiw_ls_dev(i, k))
        CALL POPREAL8(qiw_an_dev(i, k))
        CALL POPREAL8(temp)
        CALL POPREAL8(cldfrc_dev(i, k))
        CALL POPREAL8(anvfrc_dev(i, k))
        CALL HYSTPDF_ADM(dt, alpha, alpha_ad, pdfflag, pp_dev(i, k), &
&                  q_dev(i, k), q_dev_ad(i, k), qlw_ls_dev(i, k), &
&                  qlw_ls_dev_ad(i, k), qlw_an_dev(i, k), qlw_an_dev_ad(&
&                  i, k), qiw_ls_dev(i, k), qiw_ls_dev_ad(i, k), &
&                  qiw_an_dev(i, k), qiw_an_dev_ad(i, k), temp, temp_ad&
&                  , cldfrc_dev(i, k), cldfrc_dev_ad(i, k), anvfrc_dev(i&
&                  , k), anvfrc_dev_ad(i, k))
        CALL POPREAL8(rhcrit)
        alpha_ad = alpha_ad - rhcrit_ad
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) alpha_ad = 0.0_8
        CALL POPREAL8(alpha)
        CALL PDF_SPREAD_ADM(k, lm, u_dev(i, k), u_dev_ad(i, k), u_above&
&                     , u_above_ad, u_below, u_below_ad, v_dev(i, k), &
&                     v_dev_ad(i, k), v_above, v_above_ad, v_below, &
&                     v_below_ad, kh_dev(i, k-1), dzet_above, &
&                     dzet_above_ad, dzet_below, dzet_below_ad, &
&                     cnv_updfrc_dev(i, k), pp_dev(i, k), alpha, &
&                     alpha_ad, frland_dev(i))
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(dzet_below)
          dzet_dev_ad(i, k+1) = dzet_dev_ad(i, k+1) + dzet_below_ad
          CALL POPREAL8(dzet_above)
          dzet_dev_ad(i, k-1) = dzet_dev_ad(i, k-1) + dzet_above_ad
          CALL POPREAL8(v_below)
          v_dev_ad(i, k+1) = v_dev_ad(i, k+1) + v_below_ad
          CALL POPREAL8(v_above)
          v_dev_ad(i, k-1) = v_dev_ad(i, k-1) + v_above_ad
          CALL POPREAL8(u_below)
          u_dev_ad(i, k+1) = u_dev_ad(i, k+1) + u_below_ad
          CALL POPREAL8(u_above)
          u_dev_ad(i, k-1) = u_dev_ad(i, k-1) + u_above_ad
        ELSE
          CALL POPREAL8(dzet_below)
          CALL POPREAL8(dzet_above)
          CALL POPREAL8(v_below)
          CALL POPREAL8(v_above)
          CALL POPREAL8(u_below)
          CALL POPREAL8(u_above)
        END IF
        CALL POPREAL8(temp)
        CALL POPREAL8(q_dev(i, k))
        CALL POPREAL8(qlw_an_dev(i, k))
        CALL POPREAL8(qiw_an_dev(i, k))
        CALL POPREAL8(anvfrc_dev(i, k))
        CALL CNVSRC_ADM(dt, cnviceparam, sclmfdfr, mass, imass, pp_dev(i&
&                 , k), temp, temp_ad, q_dev(i, k), q_dev_ad(i, k), &
&                 qlwdtr_dev(i, k), qlwdtr_dev_ad(i, k), rmfdtr_dev(i, k&
&                 ), rmfdtr_dev_ad(i, k), qlw_an_dev(i, k), &
&                 qlw_an_dev_ad(i, k), qiw_an_dev(i, k), qiw_an_dev_ad(i&
&                 , k), cldfrc_dev(i, k), anvfrc_dev(i, k), &
&                 anvfrc_dev_ad(i, k), qst3_dev(i, k), qst3_dev_ad(i, k)&
&                )
        CALL POPREAL8(temp)
        CALL POPREAL8(qlw_an_dev(i, k))
        CALL POPREAL8(qiw_an_dev(i, k))
        CALL MELTFRZ_ADM(dt, temp, temp_ad, qlw_an_dev(i, k), &
&                  qlw_an_dev_ad(i, k), qiw_an_dev(i, k), qiw_an_dev_ad(&
&                  i, k))
        CALL POPREAL8(temp)
        CALL POPREAL8(qlw_ls_dev(i, k))
        CALL POPREAL8(qiw_ls_dev(i, k))
        CALL MELTFRZ_ADM(dt, temp, temp_ad, qlw_ls_dev(i, k), &
&                  qlw_ls_dev_ad(i, k), qiw_ls_dev(i, k), qiw_ls_dev_ad(&
&                  i, k))
        CALL POPREAL8(qlw_ls_dev(i, k))
        CALL POPREAL8(qiw_ls_dev(i, k))
        CALL POPREAL8(cldfrc_dev(i, k))
        CALL POPREAL8(qlw_an_dev(i, k))
        CALL POPREAL8(qiw_an_dev(i, k))
        CALL POPREAL8(anvfrc_dev(i, k))
        CALL FIX_UP_CLOUDS_ADM(q_dev(i, k), q_dev_ad(i, k), temp, &
&                        temp_ad, qlw_ls_dev(i, k), qlw_ls_dev_ad(i, k)&
&                        , qiw_ls_dev(i, k), qiw_ls_dev_ad(i, k), &
&                        cldfrc_dev(i, k), cldfrc_dev_ad(i, k), &
&                        qlw_an_dev(i, k), qlw_an_dev_ad(i, k), &
&                        qiw_an_dev(i, k), qiw_an_dev_ad(i, k), &
&                        anvfrc_dev(i, k), anvfrc_dev_ad(i, k))
        th_dev_ad(i, k) = th_dev_ad(i, k) + exnp_dev(i, k)*temp_ad
        qrn_cu_dev_ad(i, k) = qrn_cu_dev_ad(i, k) + qrn_cu_1d_ad
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(area_ls_prc)
          CALL POPREAL8(area_anv_prc)
          CALL POPREAL8(area_upd_prc)
          CALL POPREAL8(tot_prec_ls)
          CALL POPREAL8(tot_prec_anv)
          CALL POPREAL8(tot_prec_upd)
          area_upd_prc_ad = 0.0_8
          tot_prec_ls_ad = 0.0_8
          area_ls_prc_ad = 0.0_8
          tot_prec_upd_ad = 0.0_8
          area_anv_prc_ad = 0.0_8
          tot_prec_anv_ad = 0.0_8
        END IF
      END DO
    END DO
  END SUBROUTINE PROGNO_CLOUD_ADM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! GPU The GPU main routine call is smaller due to CUDA limit on
!     number of arguments permitted in call. Most inputs and outputs
!     are USE-associated in the GridComp
!#ifdef _CUDA
!   attributes(global) subroutine progno_cloud(IRUN,LM,DT,SCLMFDFR)
!#else
!!! first vars are (in) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!         LATS_dev         , &
!         RAD_CLDFRC_dev   , &
!         RAD_QL_dev       , &
!         RAD_QI_dev       , &
!         RAD_QR_dev       , &
!         RAD_QS_dev       , &
!         QPLS_dev         , &
!         CLDREFFL_dev     , &
!         CLDREFFI_dev     , &
!         PRELS_dev        , &
!         PRECU_dev        , &
!         PREAN_dev        , &
!         LSARF_dev        , &
!         CUARF_dev        , &
!         ANARF_dev        , &
!         SNRLS_dev        , &
!         SNRCU_dev        , &
!         SNRAN_dev        , &
!, &
  SUBROUTINE PROGNO_CLOUD(irun, lm, dt, pp_dev, ppe_dev, exnp_dev, &
&   frland_dev, kh_dev, rmfdtr_dev, qlwdtr_dev, qrn_cu_dev, &
&   cnv_updfrc_dev, u_dev, v_dev, th_dev, q_dev, qlw_ls_dev, qlw_an_dev&
&   , qiw_ls_dev, qiw_an_dev, anvfrc_dev, cldfrc_dev, cldparams, &
&   sclmfdfr, qst3_dev, dzet_dev, qddf3_dev, cnv_fraction_dev)
    IMPLICIT NONE
!#ifndef _CUDA
!#else
!      end if RUN_LOOP
!#endif
!#ifdef _CUDA
!      integer, intent(in   ), value :: IRUN
!      integer, intent(in   ), value :: LM
!      real(8), intent(in   ), value :: DT
!      real(8), intent(in   ), value :: SCLMFDFR   ! CLOUD_CTL%SCLMFDFR
!#else
    TYPE(CLDPARAM_TYPE), INTENT(IN) :: cldparams
! IM*JM
    INTEGER, INTENT(IN) :: irun
! LM
    INTEGER, INTENT(IN) :: lm
! DT_MOIST
    REAL*8, INTENT(IN) :: dt
!      real(8), intent(in   ), dimension(IRUN)      :: LATS_dev    ! LATS
! PLO
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: pp_dev
! CNV_PLE
    REAL*8, DIMENSION(irun, 0:lm), INTENT(IN) :: ppe_dev
! PK
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: exnp_dev
! FRLAND
    REAL*8, DIMENSION(irun), INTENT(IN) :: frland_dev
! KH
    REAL*8, DIMENSION(irun, 0:lm), INTENT(IN) :: kh_dev
! CNV_MFD
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: rmfdtr_dev
! CNV_DQLDT
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: qlwdtr_dev
! CNV_PRC3 IS THIS INTENT IN?
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qrn_cu_dev
! CNV_UPDF
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: cnv_updfrc_dev
! U1
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: u_dev
! V1
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: v_dev
! TH1
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: th_dev
! Q1
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: q_dev
! QLLS
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qlw_ls_dev
! QLCN
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qlw_an_dev
! QILS
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qiw_ls_dev
! QICN
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: qiw_an_dev
! CLCN
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: anvfrc_dev
! CLLS
    REAL*8, DIMENSION(irun, lm), INTENT(INOUT) :: cldfrc_dev
!      real(8), intent(  out), dimension(IRUN,  LM) :: RAD_CLDFRC_dev ! RAD_CF
!      real(8), intent(  out), dimension(IRUN,  LM) :: RAD_QL_dev ! RAD_QL
!      real(8), intent(  out), dimension(IRUN,  LM) :: RAD_QI_dev ! RAD_QI
!      real(8), intent(  out), dimension(IRUN,  LM) :: RAD_QR_dev ! QRAIN
!      real(8), intent(  out), dimension(IRUN,  LM) :: RAD_QS_dev ! QSNOW
!      real(8), intent(  out), dimension(IRUN,  LM) :: QPLS_dev ! QPLS
!      real(8), intent(  out), dimension(IRUN,  LM) :: CLDREFFL_dev ! CLDREFFL
!      real(8), intent(  out), dimension(IRUN,  LM) :: CLDREFFI_dev ! CLDREFFI
!      real(8), intent(  out), dimension(IRUN     ) :: PRELS_dev ! LS_PRC2
!      real(8), intent(  out), dimension(IRUN     ) :: PRECU_dev ! CN_PRC2
!      real(8), intent(  out), dimension(IRUN     ) :: PREAN_dev ! AN_PRC2
!      real(8), intent(  out), dimension(IRUN     ) :: LSARF_dev ! LS_ARFX
!      real(8), intent(  out), dimension(IRUN     ) :: CUARF_dev ! CN_ARFX
!      real(8), intent(  out), dimension(IRUN     ) :: ANARF_dev ! AN_ARFX
!      real(8), intent(  out), dimension(IRUN     ) :: SNRLS_dev ! LS_SNR
!      real(8), intent(  out), dimension(IRUN     ) :: SNRCU_dev ! CN_SNR
!      real(8), intent(  out), dimension(IRUN     ) :: SNRAN_dev ! AN_SNR
! CLOUD_CTL%SCLMFDFR
    REAL*8, INTENT(IN) :: sclmfdfr
! QST3
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: qst3_dev
! DZET
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: dzet_dev
! QDDF3
    REAL*8, DIMENSION(irun, lm), INTENT(IN) :: qddf3_dev
! CNV_FRACTION
    REAL*8, DIMENSION(irun), INTENT(IN) :: cnv_fraction_dev
!      real(8), intent(  out), dimension(IRUN,  LM) :: RHX_dev    ! RHX
!      real(8), intent(  out), dimension(IRUN,  LM) :: REV_LS_dev ! REV_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: REV_AN_dev ! REV_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: REV_CN_dev ! REV_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: RSU_LS_dev ! RSU_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: RSU_AN_dev ! RSU_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: RSU_CN_dev ! RSU_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACLL_CN_dev ! ACLL_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACIL_CN_dev ! ACIL_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACLL_AN_dev ! ACLL_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACIL_AN_dev ! ACIL_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACLL_LS_dev ! ACLL_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: ACIL_LS_dev ! ACIL_LS
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFL_CN_dev ! PFL_CN
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFI_CN_dev ! PFI_CN
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFL_AN_dev ! PFL_AN
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFI_AN_dev ! PFI_AN
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFL_LS_dev ! PFL_LS
!      real(8), intent(  out), dimension(IRUN,0:LM) :: PFI_LS_dev ! PFI_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: PDFL_dev ! DlPDF
!      real(8), intent(  out), dimension(IRUN,  LM) :: PDFI_dev ! DiPDF
!      real(8), intent(  out), dimension(IRUN,  LM) :: FIXL_dev ! DlFIX
!      real(8), intent(  out), dimension(IRUN,  LM) :: FIXI_dev ! DiFIX                  
!      real(8), intent(  out), dimension(IRUN,  LM) :: AUT_dev   ! AUT
!      real(8), intent(  out), dimension(IRUN,  LM) :: EVAPC_dev ! EVAPC
!      real(8), intent(  out), dimension(IRUN,  LM) :: SDM_dev   ! SDM
!      real(8), intent(  out), dimension(IRUN,  LM) :: SUBLC_dev ! SUBLC
!      real(8), intent(  out), dimension(IRUN,  LM) :: FRZ_TT_dev ! FRZ_TT
!      real(8), intent(  out), dimension(IRUN,  LM) :: FRZ_PP_dev ! FRZ_PP
!      real(8), intent(  out), dimension(IRUN,  LM) :: DCNVL_dev ! DCNVL
!      real(8), intent(  out), dimension(IRUN,  LM) :: DCNVi_dev ! DCNVi
!      real(8), intent(  out), dimension(IRUN,  LM) :: ALPHT_dev ! ALPHT
!      real(8), intent(  out), dimension(IRUN,  LM) :: ALPH1_dev ! ALPH1
!      real(8), intent(  out), dimension(IRUN,  LM) :: ALPH2_dev ! ALPH2
!      real(8), intent(  out), dimension(IRUN,  LM) :: CFPDF_dev ! CFPDF
!      real(8), intent(  out), dimension(IRUN,  LM) :: RHCLR_dev ! RHCLR
!      real(8), intent(  out), dimension(IRUN,  LM) :: DQRL_dev ! DQRL
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLICE_AN_dev ! VFALLICE_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLICE_LS_dev ! VFALLICE_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLWAT_AN_dev ! VFALLWAT_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLWAT_LS_dev ! VFALLWAT_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLSN_AN_dev ! VFALLSN_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLSN_LS_dev ! VFALLSN_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLSN_CN_dev ! VFALLSN_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLRN_AN_dev ! VFALLRN_AN
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLRN_LS_dev ! VFALLRN_LS
!      real(8), intent(  out), dimension(IRUN,  LM) :: VFALLRN_CN_dev ! VFALLRN_CN
!      real(8), intent(  out), dimension(IRUN,  LM) :: LIQANMOVE_dev  ! LIQANMOVE
!      real(8), intent(  out), dimension(IRUN,  LM) :: ICEANMOVE_dev  ! ICEANMOVE
!      real(8), intent(  out), dimension(IRUN,  LM) :: DANCLD_dev     ! DANCLD
!      real(8), intent(  out), dimension(IRUN,  LM) :: DLSCLD_dev     ! DLSCLD
!      real(8), intent(  out), dimension(IRUN,  LM) :: CURAINMOVE_dev ! CURAINMOVE
!      real(8), intent(  out), dimension(IRUN,  LM) :: CUSNOWMOVE_dev ! CUSNOWMOVE
!      real(8), intent(in   ), dimension(IRUN     ) :: TEMPOR_dev  ! TEMPOR
!#endif
! GPU The GPUs need to know how big local arrays are during compile-time
!     as the GPUs cannot allocate memory themselves. This command resets
!     this a priori size to LM for the CPU.
!#ifndef GPU_MAXLEVS
!#define GPU_MAXLEVS LM
!#endif
    INTEGER :: i, j, k, l
    INTEGER :: fraction_removal1, fraction_removal2, fraction_removal3
    REAL*8 :: mass, imass
    REAL*8 :: totfrc
    REAL*8 :: qrn_ls, qrn_an, qrn_cu_1d
    REAL*8 :: qsn_ls, qsn_an, qsn_cu
!      real(8) :: QRN_ALL, QSN_ALL
    REAL*8 :: qtmp1, qtmp2, qtmp3
    REAL*8 :: temp
    REAL*8 :: rhcrit
    REAL*8 :: aa3, bb3, alpha
    REAL*8 :: vfall, vfallrn, vfallsn
    REAL*8 :: tot_prec_upd
    REAL*8 :: tot_prec_anv
    REAL*8 :: tot_prec_ls
    REAL*8 :: area_upd_prc
    REAL*8 :: area_anv_prc
    REAL*8 :: area_ls_prc
    REAL*8 :: area_upd_prc_tolayer
    REAL*8 :: area_anv_prc_tolayer
    REAL*8 :: area_ls_prc_tolayer
    REAL*8 :: u_above, u_below
    REAL*8 :: v_above, v_below
    REAL*8 :: dzet_above, dzet_below
    REAL*8 :: prn_cu_above, psn_cu_above
    REAL*8 :: prn_ls_above, psn_ls_above
    REAL*8 :: prn_an_above, psn_an_above
    REAL*8 :: evap_dd_cu_above, subl_dd_cu_above
    REAL*8 :: evap_dd_ls_above, subl_dd_ls_above
    REAL*8 :: evap_dd_an_above, subl_dd_an_above
    LOGICAL :: use_autoconv_timescale
    REAL*8 :: tropical, extratropical
    REAL*8 :: lsenvfc, anvenvfc, envfc, ddrfc, beta
    REAL*8 :: sdqv2, sdqv3, sdqvt1
    REAL*8 :: lspdfliqnew, lspdficenew, lspdffracnew
    INTRINSIC INT
    INTRINSIC NINT
    INTRINSIC MAX
! These are in constant memory in CUDA and are set in the GridComp
!#ifndef _CUDA
! Area factor for convective rain showers (non-dim)
    cnv_beta = cldparams%cnv_beta
! Area factor for anvil rain showers (non-dim)
    anv_beta = cldparams%anv_beta
! Area factor for Large Scale rain showers (non-dim)
    ls_beta = cldparams%ls_beta
! Critical relative humidity
    rh00 = cldparams%rh_crit
    c_00 = cldparams%autoc_ls
    lwcrit = cldparams%qc_crit_ls
    c_acc = cldparams%accretion
    c_ev_r = cldparams%rain_revap_fac
    c_ev_s = cldparams%snow_revap_fac
    cldvol2frc = cldparams%vol_to_frac
    rhsup_ice = cldparams%supersat
    shr_evap_fac = cldparams%shear_evap_fac
    min_cld_water = cldparams%min_allow_ccw
    cld_evp_eff = cldparams%ccw_evap_eff
    nsmax = INT(cldparams%nsub_autoconv)
    ls_sdqv2 = cldparams%ls_sund_inter
    ls_sdqv3 = cldparams%ls_sund_cold
    ls_sdqvt1 = cldparams%ls_sund_temp1
    anv_sdqv2 = cldparams%anv_sund_inter
    anv_sdqv3 = cldparams%anv_sund_cold
    anv_sdqvt1 = cldparams%anv_sund_temp1
    anv_to_ls = cldparams%anv_to_ls_time
    n_warm = cldparams%nccn_warm
    n_ice = cldparams%nccn_ice
    n_anvil = cldparams%nccn_anvil
    n_pbl = cldparams%nccn_pbl
    disable_rad = INT(cldparams%disable_rad)
    ice_settle = NINT(cldparams%ice_settle)
    anv_icefall_c = cldparams%anv_icefall
    ls_icefall_c = cldparams%ls_icefall
    revap_off_p = cldparams%revap_off_p
    cnvenvfc = cldparams%cnv_envf
    wrhodep = cldparams%wrhodep
    t_ice_all = cldparams%ice_ramp + mapl8_tice
    cnviceparam = cldparams%cnv_iceparam
    icefrpwr = INT(cldparams%cnv_icefrpwr + .001)
    cnvddrfc = cldparams%cnv_ddrf
    anvddrfc = cldparams%anv_ddrf
    lsddrfc = cldparams%ls_ddrf
    tanhrhcrit = INT(cldparams%tanhrhcrit)
    minrhcrit = cldparams%minrhcrit
    maxrhcrit = cldparams%maxrhcrit
    turnrhcrit = cldparams%turnrhcrit
    maxrhcritland = cldparams%maxrhcritland
    fr_ls_wat = INT(cldparams%fr_ls_wat)
    fr_ls_ice = INT(cldparams%fr_ls_ice)
    fr_an_wat = INT(cldparams%fr_an_wat)
    fr_an_ice = INT(cldparams%fr_an_ice)
    min_rl = cldparams%min_rl
    min_ri = cldparams%min_ri
    max_rl = cldparams%max_rl
    max_ri = cldparams%max_ri
    ri_anv = cldparams%ri_anv
    pdfflag = INT(cldparams%pdfshape)
    ktop = INT(cldparams%ktop)
!#endif
    use_autoconv_timescale = .false.
!#ifdef _CUDA
!      i = (blockidx%x - 1) * blockdim%x + threadidx%x
!
!      RUN_LOOP: IF ( I <= IRUN ) THEN
!#else
run_loop:DO i=1,irun
!#endif
k_loop:DO k=ktop,lm
        IF (k .EQ. ktop) THEN
          tot_prec_upd = 0.
          tot_prec_anv = 0.
          tot_prec_ls = 0.
          area_upd_prc = 0.
          area_anv_prc = 0.
          area_ls_prc = 0.
        END IF
!! ZERO DIAGNOSTIC OUTPUTS BEFORE SHOWERS !!
!               PRELS_dev(I) = 0.
!               PRECU_dev(I) = 0.
!               PREAN_dev(I) = 0.
!               SNRCU_dev(I) = 0. 
!               SNRLS_dev(I) = 0. 
!               SNRAN_dev(I) = 0. 
!               LSARF_dev(I) = 0.
!               CUARF_dev(I) = 0.
!               ANARF_dev(I) = 0.
!Zero out/initialize precips, except QRN_CU which comes from RAS 
        qrn_ls = 0.
        qrn_an = 0.
        qrn_cu_1d = 0.
        qsn_ls = 0.
        qsn_an = 0.
        qsn_cu = 0.
        vfall = 0.
!            RAD_QL_dev(I,K)     = 0.
!            RAD_QI_dev(I,K)     = 0.
!            RAD_QR_dev(I,K)     = 0.
!            RAD_QS_dev(I,K)     = 0.
!            QPLS_dev(I,K)       = 0.
!            RAD_CLDFRC_dev(I,K) = 0.
!            CLDREFFL_dev(I,K)   = 0.
!            CLDREFFI_dev(I,K)   = 0.
!            PFL_CN_dev(I,K) = 0.
!            PFI_CN_dev(I,K) = 0.
!            PFL_AN_dev(I,K) = 0.
!            PFI_AN_dev(I,K) = 0.
!            PFL_LS_dev(I,K) = 0.
!            PFI_LS_dev(I,K) = 0.
!            IF (K == KTOP) THEN
!               PFL_CN_dev(I,0) = 0.
!               PFI_CN_dev(I,0) = 0.
!               PFL_AN_dev(I,0) = 0.
!               PFI_AN_dev(I,0) = 0.
!               PFL_LS_dev(I,0) = 0.
!               PFI_LS_dev(I,0) = 0.
!            END IF
! Initialize other diagnostics 
!            RHX_dev(I,K) = MAPL8_UNDEF
!            REV_LS_dev(I,K) = MAPL8_UNDEF
!            REV_AN_dev(I,K) = MAPL8_UNDEF
!            REV_CN_dev(I,K) = MAPL8_UNDEF
!            RSU_LS_dev(I,K) = MAPL8_UNDEF
!            RSU_AN_dev(I,K) = MAPL8_UNDEF
!            RSU_CN_dev(I,K) = MAPL8_UNDEF
!            ACLL_CN_dev(I,K) = MAPL8_UNDEF
!            ACIL_CN_dev(I,K) = MAPL8_UNDEF
!            ACLL_AN_dev(I,K) = MAPL8_UNDEF
!            ACIL_AN_dev(I,K) = MAPL8_UNDEF
!            ACLL_LS_dev(I,K) = MAPL8_UNDEF
!            ACIL_LS_dev(I,K) = MAPL8_UNDEF
!            PDFL_dev(I,K) = MAPL8_UNDEF
!            PDFI_dev(I,K) = MAPL8_UNDEF
!            FIXL_dev(I,K) = MAPL8_UNDEF
!            FIXI_dev(I,K) = MAPL8_UNDEF
!            AUT_dev(I,K) = MAPL8_UNDEF
!            EVAPC_dev(I,K) = MAPL8_UNDEF
!            SDM_dev(I,K) = MAPL8_UNDEF
!            SUBLC_dev(I,K) = MAPL8_UNDEF
!            FRZ_TT_dev(I,K) = MAPL8_UNDEF
!            FRZ_PP_dev(I,K) = MAPL8_UNDEF
!            DCNVL_dev(I,K) = MAPL8_UNDEF
!            DCNVi_dev(I,K) = MAPL8_UNDEF
!            ALPHT_dev(I,K) = MAPL8_UNDEF
!            ALPH1_dev(I,K) = MAPL8_UNDEF
!            ALPH2_dev(I,K) = MAPL8_UNDEF
!            CFPDF_dev(I,K) = MAPL8_UNDEF
!            RHCLR_dev(I,K) = MAPL8_UNDEF
!            DQRL_dev(I,K) = MAPL8_UNDEF
!            VFALLICE_AN_dev(I,K) = MAPL8_UNDEF
!            VFALLICE_LS_dev(I,K) = MAPL8_UNDEF
!            VFALLWAT_AN_dev(I,K) = MAPL8_UNDEF
!            VFALLWAT_LS_dev(I,K) = MAPL8_UNDEF
!            VFALLSN_AN_dev(I,K) = MAPL8_UNDEF
!            VFALLSN_LS_dev(I,K) = MAPL8_UNDEF
!            VFALLSN_CN_dev(I,K) = MAPL8_UNDEF
!            VFALLRN_AN_dev(I,K) = MAPL8_UNDEF
!            VFALLRN_LS_dev(I,K) = MAPL8_UNDEF
!            VFALLRN_CN_dev(I,K) = MAPL8_UNDEF
! Copy QRN_CU into a temp scalar
        qrn_cu_1d = qrn_cu_dev(i, k)
! layer-mass (kg/m**2)
        mass = (ppe_dev(i, k)-ppe_dev(i, k-1))*100./mapl8_grav
        imass = 1.0/mass
        temp = exnp_dev(i, k)*th_dev(i, k)
!            FRZ_PP_dev(I,K) = 0.00
!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Total Condensate Source
!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            FIXL_dev(I,K) = QLW_AN_dev(I,K) + QLW_LS_dev(I,K)
!            FIXI_dev(I,K) = QIW_AN_dev(I,K) + QIW_LS_dev(I,K)
        CALL FIX_UP_CLOUDS(q_dev(i, k), temp, qlw_ls_dev(i, k), &
&                    qiw_ls_dev(i, k), cldfrc_dev(i, k), qlw_an_dev(i, k&
&                    ), qiw_an_dev(i, k), anvfrc_dev(i, k))
!            FIXL_dev(I,K) = -( QLW_AN_dev(I,K) + QLW_LS_dev(I,K) - FIXL_dev(I,K) ) / DT 
!            FIXI_dev(I,K) = -( QIW_AN_dev(I,K) + QIW_LS_dev(I,K) - FIXI_dev(I,K) ) / DT 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            FRZ_TT_dev(I,K) = QIW_AN_dev(I,K) + QIW_LS_dev(I,K)
        CALL MELTFRZ(dt, temp, qlw_ls_dev(i, k), qiw_ls_dev(i, k))
        CALL MELTFRZ(dt, temp, qlw_an_dev(i, k), qiw_an_dev(i, k))
!            FRZ_TT_dev(I,K) = ( QIW_AN_dev(I,K) + QIW_LS_dev(I,K) - FRZ_TT_dev(I,K) ) / DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            DCNVi_dev(I,K) = QIW_AN_dev(I,K)
!            DCNVL_dev(I,K) = QLW_AN_dev(I,K)
        CALL CNVSRC(dt, cnviceparam, sclmfdfr, mass, imass, pp_dev(i, k)&
&             , temp, q_dev(i, k), qlwdtr_dev(i, k), rmfdtr_dev(i, k), &
&             qlw_an_dev(i, k), qiw_an_dev(i, k), cldfrc_dev(i, k), &
&             anvfrc_dev(i, k), qst3_dev(i, k))
!            DCNVi_dev(I,K) = ( QIW_AN_dev(I,K) - DCNVi_dev(I,K) ) / DT
!            DCNVL_dev(I,K) = ( QLW_AN_dev(I,K) - DCNVL_dev(I,K) ) / DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            PDFL_dev(I,K) = QLW_LS_dev(I,K)+QLW_AN_dev(I,K)
!            PDFI_dev(I,K) = QIW_LS_dev(I,K)+QIW_AN_dev(I,K)
        IF (k .EQ. ktop .OR. k .EQ. lm) THEN
          u_above = 0.0
          u_below = 0.0
          v_above = 0.0
          v_below = 0.0
          dzet_above = 0.0
          dzet_below = 0.0
        ELSE
          u_above = u_dev(i, k-1)
          u_below = u_dev(i, k+1)
          v_above = v_dev(i, k-1)
          v_below = v_dev(i, k+1)
          dzet_above = dzet_dev(i, k-1)
          dzet_below = dzet_dev(i, k+1)
        END IF
!                  ALPHT_dev(I,K), ALPH1_dev(I,K),!ALPH2_dev(I,K), & 
        CALL PDF_SPREAD(k, lm, u_dev(i, k), u_above, u_below, v_dev(i, k&
&                 ), v_above, v_below, kh_dev(i, k-1), dzet_above, &
&                 dzet_below, cnv_updfrc_dev(i, k), pp_dev(i, k), alpha&
&                 , frland_dev(i))
        IF (alpha .LT. 1.0 - rh00) THEN
          alpha = 1.0 - rh00
        ELSE
          alpha = alpha
        END IF
        rhcrit = 1.0 - alpha
        lspdfliqnew = qlw_ls_dev(i, k)
        lspdficenew = qiw_ls_dev(i, k)
        lspdffracnew = cldfrc_dev(i, k)
        CALL HYSTPDF(dt, alpha, pdfflag, pp_dev(i, k), q_dev(i, k), &
&              qlw_ls_dev(i, k), qlw_an_dev(i, k), qiw_ls_dev(i, k), &
&              qiw_an_dev(i, k), temp, cldfrc_dev(i, k), anvfrc_dev(i, k&
&              ))
        lspdfliqnew = qlw_ls_dev(i, k) - lspdfliqnew
        lspdficenew = qiw_ls_dev(i, k) - lspdficenew
        lspdffracnew = cldfrc_dev(i, k) - lspdffracnew
!            RHX_dev(I,K)   = Q_dev(I,K)/QSAT( TEMP, PP_dev(I,K) )
!            CFPDF_dev(I,K) = CLDFRC_dev(I,K)
!            PDFL_dev(I,K)  = ( QLW_LS_dev(I,K) + QLW_AN_dev(I,K) - PDFL_dev(I,K) ) / DT 
!            PDFI_dev(I,K)  = ( QIW_LS_dev(I,K) + QIW_AN_dev(I,K) - PDFI_dev(I,K) ) / DT 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        totfrc = cldfrc_dev(i, k) + anvfrc_dev(i, k)
        IF (totfrc .GT. 1.00) THEN
          cldfrc_dev(i, k) = cldfrc_dev(i, k)*(1.00/totfrc)
          anvfrc_dev(i, k) = anvfrc_dev(i, k)*(1.00/totfrc)
        END IF
        totfrc = cldfrc_dev(i, k) + anvfrc_dev(i, k)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! CONDENSATE/FRACTION SOURCES FINISHED. NOW LOSE CLOUD CONDENSATE !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Total Condensate Sink
!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!       E  V  A  P  O  R  A  T  I  O  N
!!                A  N  D 
!!       S  U  B  L  I  M  A  T  I  O  N
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            EVAPC_dev(I,K) = QLW_LS_dev(I,K)+QLW_AN_dev(I,K)
!            SUBLC_dev(I,K) = QIW_LS_dev(I,K)+QIW_AN_dev(I,K)
! 'Anvil' partition from RAS/Parameterized not done in hystpdf
        CALL EVAP3(dt, rhcrit, pp_dev(i, k), temp, q_dev(i, k), &
&            qlw_an_dev(i, k), qiw_an_dev(i, k), anvfrc_dev(i, k), &
&            cldfrc_dev(i, k), qst3_dev(i, k))
        CALL SUBL3(dt, rhcrit, pp_dev(i, k), temp, q_dev(i, k), &
&            qlw_an_dev(i, k), qiw_an_dev(i, k), anvfrc_dev(i, k), &
&            cldfrc_dev(i, k), qst3_dev(i, k))
!            EVAPC_dev(I,K) = ( EVAPC_dev(I,K) - (QLW_LS_dev(I,K)+QLW_AN_dev(I,K)) ) / DT
!            SUBLC_dev(I,K) = ( SUBLC_dev(I,K) - (QIW_LS_dev(I,K)+QIW_AN_dev(I,K)) ) / DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!       A U T O C O N V E R S I  O  N
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!           FRACTION_REMOVAL = 0 -> none
!                              1 -> constant in-cloud QC
!                              2 -> trim high edge of PDF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            AUT_dev(I,K) = QLW_LS_dev(I,K)+QLW_AN_dev(I,K)
        fraction_removal1 = fr_ls_wat
        CALL AUTOCON3(dt, qlw_ls_dev(i, k), qrn_ls, temp, pp_dev(i, k), &
&               kh_dev(i, k-1), cldfrc_dev(i, k), ls_sdqv2, ls_sdqv3, &
&               ls_sdqvt1, dzet_dev(i, k), vfall, fraction_removal1)
!            VFALLWAT_LS_dev(I,K) = VFALL
        fraction_removal2 = fr_an_wat
        CALL AUTOCON3(dt, qlw_an_dev(i, k), qrn_an, temp, pp_dev(i, k), &
&               kh_dev(i, k), anvfrc_dev(i, k), anv_sdqv2, anv_sdqv3, &
&               anv_sdqvt1, dzet_dev(i, k), vfall, fraction_removal2)
!            VFALLWAT_AN_dev(I,K) = VFALL
!            AUT_dev(I,K) = ( AUT_dev(I,K) - ( QLW_AN_dev(I,K) + QLW_LS_dev(I,K) ) )/DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Ice cloud settling
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!            SDM_dev(I,K) = QIW_AN_dev(I,K)+QIW_LS_dev(I,K)
! Parameterized (RAS) Ice Fall
! ----------------------------
! WMP: Adjustments to resolved scale ice fall speed options                            
        IF (cnv_fraction_dev(i) .GE. 0.5) THEN
          fraction_removal3 = fr_an_ice
        ELSE
          fraction_removal3 = fr_ls_ice
        END IF
        SELECT CASE  (ice_settle) 
        CASE (0) 
! MERRA-2 Formulation
          tropical = anv_icefall_c*1.0
          extratropical = anv_icefall_c*0.0
        CASE (1) 
          tropical = cnv_fraction_dev(i)
          extratropical = 1.0 - tropical
          tropical = anv_icefall_c*tropical
          extratropical = ls_icefall_c*extratropical
        END SELECT
        CALL SETTLE_VEL(wrhodep, qiw_an_dev(i, k), pp_dev(i, k), temp, &
&                 anvfrc_dev(i, k), kh_dev(i, k-1), vfall, extratropical&
&                 , tropical)
!            VFALLICE_AN_dev(I,K) = VFALL
        CALL ICEFALL(qiw_an_dev(i, k), dzet_dev(i, k), qsn_an, vfall, &
&              anvfrc_dev(i, k), dt, fraction_removal3)
! Resolved Scale Ice Fall
! -----------------------
! WMP: Adjustments to resolved scale ice fall speed options 
        SELECT CASE  (ice_settle) 
        CASE (0) 
! MERRA-2 Formulation
          tropical = ls_icefall_c*0.0
          extratropical = ls_icefall_c*1.0
        CASE (1) 
          tropical = cnv_fraction_dev(i)
          extratropical = 1.0 - tropical
          tropical = anv_icefall_c*tropical
          extratropical = ls_icefall_c*extratropical
        END SELECT
        CALL SETTLE_VEL(wrhodep, qiw_ls_dev(i, k), pp_dev(i, k), temp, &
&                 cldfrc_dev(i, k), kh_dev(i, k-1), vfall, extratropical&
&                 , tropical)
!            VFALLICE_LS_dev(I,K) = VFALL
        CALL ICEFALL(qiw_ls_dev(i, k), dzet_dev(i, k), qsn_ls, vfall, &
&              cldfrc_dev(i, k), dt, fraction_removal3)
!            SDM_dev(I,K) = ( SDM_dev(I,K) - (QIW_LS_dev(I,K) + QIW_AN_dev(I,K)) )/DT
!            DQRL_dev(I,K) = ( QRN_LS + QRN_AN + QSN_LS + QSN_AN ) / DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Add in convective rain 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! CU-FREEZE 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Also "freeze" out any conv. precip that needs
! to be since this isnt done in RAS. This is
! precip w/ large particles, so freezing is 
! strict. Check up on this!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        qtmp2 = 0.
        IF (temp .LT. mapl8_tice) THEN
          qtmp2 = qrn_cu_1d
          qsn_cu = qrn_cu_1d
          qrn_cu_1d = 0.
          temp = temp + qsn_cu*(mapl8_alhs-mapl8_alhl)/mapl8_cp
        END IF
!            FRZ_PP_dev(I,K) = FRZ_PP_dev(I,K) +  QTMP2/DT
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!----------------------------------------------------------------------------------------------
! Column will now be swept from top-down for precip accumulation/accretion/re-evaporation
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        area_ls_prc_tolayer = 0.0
        area_upd_prc_tolayer = 0.0
        area_anv_prc_tolayer = 0.0
        tot_prec_upd = tot_prec_upd + (qrn_cu_1d+qsn_cu)*mass
        area_upd_prc = area_upd_prc + cnv_updfrc_dev(i, k)*(qrn_cu_1d+&
&         qsn_cu)*mass
        tot_prec_anv = tot_prec_anv + (qrn_an+qsn_an)*mass
        area_anv_prc = area_anv_prc + anvfrc_dev(i, k)*(qrn_an+qsn_an)*&
&         mass
        tot_prec_ls = tot_prec_ls + (qrn_ls+qsn_ls)*mass
        area_ls_prc = area_ls_prc + cldfrc_dev(i, k)*(qrn_ls+qsn_ls)*&
&         mass
        IF (tot_prec_anv .GT. 0.0) THEN
          IF (area_anv_prc/tot_prec_anv .LT. 1.e-6) THEN
            area_anv_prc_tolayer = 1.e-6
          ELSE
            area_anv_prc_tolayer = area_anv_prc/tot_prec_anv
          END IF
        END IF
        IF (tot_prec_upd .GT. 0.0) THEN
          IF (area_upd_prc/tot_prec_upd .LT. 1.e-6) THEN
            area_upd_prc_tolayer = 1.e-6
          ELSE
            area_upd_prc_tolayer = area_upd_prc/tot_prec_upd
          END IF
        END IF
        IF (tot_prec_ls .GT. 0.0) THEN
          IF (area_ls_prc/tot_prec_ls .LT. 1.e-6) THEN
            area_ls_prc_tolayer = 1.e-6
          ELSE
            area_ls_prc_tolayer = area_ls_prc/tot_prec_ls
          END IF
        END IF
        area_ls_prc_tolayer = ls_beta*area_ls_prc_tolayer
        area_upd_prc_tolayer = cnv_beta*area_upd_prc_tolayer
        area_anv_prc_tolayer = anv_beta*area_anv_prc_tolayer
        IF (k .EQ. lm) THEN
! Weve accumulated over the whole column
          IF (tot_prec_anv .GT. 0.0) THEN
            IF (area_anv_prc/tot_prec_anv .LT. 1.e-6) THEN
              area_anv_prc = 1.e-6
            ELSE
              area_anv_prc = area_anv_prc/tot_prec_anv
            END IF
          END IF
          IF (tot_prec_upd .GT. 0.0) THEN
            IF (area_upd_prc/tot_prec_upd .LT. 1.e-6) THEN
              area_upd_prc = 1.e-6
            ELSE
              area_upd_prc = area_upd_prc/tot_prec_upd
            END IF
          END IF
          IF (tot_prec_ls .GT. 0.0) THEN
            IF (area_ls_prc/tot_prec_ls .LT. 1.e-6) THEN
              area_ls_prc = 1.e-6
            ELSE
              area_ls_prc = area_ls_prc/tot_prec_ls
            END IF
          END IF
          area_ls_prc = ls_beta*area_ls_prc
          area_upd_prc = cnv_beta*area_upd_prc
          area_anv_prc = anv_beta*area_anv_prc
!! "couple" to diagnostic areal(8) fraction output 
!! Intensity factor in PRECIP3 is floored at
!! 1.0. So this is fair.
!               LSARF_dev(I) = MIN( AREA_LS_PRC,  1.0 )
!               CUARF_dev(I) = MIN( AREA_UPD_PRC, 1.0 )
!               ANARF_dev(I) = MIN( AREA_ANV_PRC, 1.0 )
        END IF
!            QRN_ALL = 0.
!            QSN_ALL = 0.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! GET SOME MICROPHYSICAL QUANTITIES 
        CALL MICRO_AA_BB_3(temp, pp_dev(i, k), qst3_dev(i, k), aa3, bb3)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        qtmp1 = qlw_ls_dev(i, k) + qlw_an_dev(i, k)
        qtmp2 = qiw_ls_dev(i, k) + qiw_an_dev(i, k)
! CNVENVFC passed in as argument (default=0.8)
! Unlike CNVENVFC which is from PHYSPARAMS, this is set to 1.
        anvenvfc = 1.00
! Unlike CNVENVFC which is from PHYSPARAMS, this is set to 1.
        lsenvfc = 1.00
! Apply convective fractions
        envfc = cnvenvfc*cnv_fraction_dev(i) + lsenvfc*(1.0-&
&         cnv_fraction_dev(i))
! Convective
! ----------
!                  PRECU_dev(I)    , & 
!                  SNRCU_dev(I)    , & 
!                  REV_CN_dev(I,K) , &
!                  RSU_CN_dev(I,K) , &
!                  ACLL_CN_dev(I,K), &
!                  ACIL_CN_dev(I,K), &
!                  PFL_CN_dev(I,K) , &
!                  PFI_CN_dev(I,K) , &
!                  VFALLRN         , &
!                  VFALLSN         , &
!                  FRZ_PP_dev(I,K) , &
        CALL PRECIP3(k, lm, dt, frland_dev(i), rhcrit, qrn_cu_1d, qsn_cu&
&              , qtmp1, qtmp2, temp, q_dev(i, k), mass, imass, pp_dev(i&
&              , k), dzet_dev(i, k), qddf3_dev(i, k), aa3, bb3, &
&              area_upd_prc_tolayer, prn_cu_above, psn_cu_above, &
&              evap_dd_cu_above, subl_dd_cu_above, envfc, cnvddrfc)
!            VFALLSN_CN_dev(I,K) = VFALLSN
!            VFALLRN_CN_dev(I,K) = VFALLRN
!            if (.not.use_autoconv_timescale) then
!               if (VFALLSN.NE.0.) then
!                  QSN_ALL = QSN_ALL + PFI_CN_dev(I,K)/VFALLSN
!               end if
!               if (VFALLRN.NE.0.) then
!                  QRN_ALL = QRN_ALL + PFL_CN_dev(I,K)/VFALLRN
!               end if
!            end if
! Anvil
! -----
!                  PREAN_dev(I)    , & 
!                  SNRAN_dev(I)    , &
!                  REV_AN_dev(I,K) , &
!                  RSU_AN_dev(I,K) , &
!                  ACLL_AN_dev(I,K), &
!                  ACIL_AN_dev(I,K), &
!                  PFL_AN_dev(I,K) , &
!                  PFI_AN_dev(I,K) , &
!                  VFALLRN         , &
!                  VFALLSN         , &
!                  FRZ_PP_dev(I,K) , &
        CALL PRECIP3(k, lm, dt, frland_dev(i), rhcrit, qrn_an, qsn_an, &
&              qtmp1, qtmp2, temp, q_dev(i, k), mass, imass, pp_dev(i, k&
&              ), dzet_dev(i, k), qddf3_dev(i, k), aa3, bb3, &
&              area_anv_prc_tolayer, prn_an_above, psn_an_above, &
&              evap_dd_an_above, subl_dd_an_above, envfc, anvddrfc)
!            VFALLSN_AN_dev(I,K) = VFALLSN
!            VFALLRN_AN_dev(I,K) = VFALLRN
!            if (.not.use_autoconv_timescale) then
!               if (VFALLSN.NE.0.) then
!                  QSN_ALL = QSN_ALL + PFI_AN_dev(I,K)/VFALLSN
!               end if
!               if (VFALLRN.NE.0.) then
!                  QRN_ALL = QRN_ALL + PFL_AN_dev(I,K)/VFALLRN
!               end if
!            end if
! Largescale
! ----------
!                  PRELS_dev(I)    , & 
!                  SNRLS_dev(I)    , &
!                  REV_LS_dev(I,K) , &
!                  RSU_LS_dev(I,K) , &    
!                  ACLL_LS_dev(I,K), &
!                  ACIL_LS_dev(I,K), &
!                  PFL_LS_dev(I,K) , &
!                  PFI_LS_dev(I,K) , &
!                  VFALLRN         , &
!                  VFALLSN         , &
!                  FRZ_PP_dev(I,K) , &
        CALL PRECIP3(k, lm, dt, frland_dev(i), rhcrit, qrn_ls, qsn_ls, &
&              qtmp1, qtmp2, temp, q_dev(i, k), mass, imass, pp_dev(i, k&
&              ), dzet_dev(i, k), qddf3_dev(i, k), aa3, bb3, &
&              area_ls_prc_tolayer, prn_ls_above, psn_ls_above, &
&              evap_dd_ls_above, subl_dd_ls_above, envfc, lsddrfc)
!            VFALLSN_LS_dev(I,K) = VFALLSN
!            VFALLRN_LS_dev(I,K) = VFALLRN
!            if (.not.use_autoconv_timescale) then
!               if (VFALLSN.NE.0.) then
!                  QSN_ALL = QSN_ALL + PFI_LS_dev(I,K)/VFALLSN
!               end if
!               if (VFALLRN.NE.0.) then
!                  QRN_ALL = QRN_ALL + PFL_LS_dev(I,K)/VFALLRN
!               end if
!               if (VFALLRN.NE.0. .AND. VFALLSN.NE.0.) then
!                  QPLS_dev(I,K) = QPLS_dev(I,K) + PFL_LS_dev(I,K)/VFALLRN + PFI_LS_dev(I,K)/VFALLSN
!               end if 
!            end if
        IF (qlw_ls_dev(i, k) + qlw_an_dev(i, k) .GT. 0.00) THEN
          qtmp3 = 1./(qlw_ls_dev(i, k)+qlw_an_dev(i, k))
        ELSE
          qtmp3 = 0.0
        END IF
        qlw_ls_dev(i, k) = qlw_ls_dev(i, k)*qtmp1*qtmp3
        qlw_an_dev(i, k) = qlw_an_dev(i, k)*qtmp1*qtmp3
        IF (qiw_ls_dev(i, k) + qiw_an_dev(i, k) .GT. 0.00) THEN
          qtmp3 = 1./(qiw_ls_dev(i, k)+qiw_an_dev(i, k))
        ELSE
          qtmp3 = 0.0
        END IF
        qiw_ls_dev(i, k) = qiw_ls_dev(i, k)*qtmp2*qtmp3
        qiw_an_dev(i, k) = qiw_an_dev(i, k)*qtmp2*qtmp3
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
        th_dev(i, k) = temp/exnp_dev(i, k)
!            QRN_ALL = QRN_ALL / (100.*PP_dev(I,K) / (MAPL8_RGAS*TEMP ))
!            QSN_ALL = QSN_ALL / (100.*PP_dev(I,K) / (MAPL8_RGAS*TEMP ))
!            RHCLR_dev(I,K) = MIN( CLDFRC_dev(I,K) + ANVFRC_dev(I,K), 1.00 )
!            IF ( RHCLR_dev(I,K) < 1.00 ) THEN
!               RHCLR_dev(I,K) = ( MIN( Q_dev(I,K)/QSAT(TEMP,PP_dev(I,K)),1.0 ) - RHCLR_dev(I,K) ) / &
!                                     (1. - RHCLR_dev(I,K))
!               IF ( RHCLR_dev(I,K) < 0.00 ) THEN
!                  RHCLR_dev(I,K) = MAPL8_UNDEF
!               END IF
!            ELSE
!               RHCLR_dev(I,K) = MAPL8_UNDEF
!            END IF
!            IF (DISABLE_RAD==1) THEN
!               RAD_QL_dev(I,K)     = 0.
!               RAD_QI_dev(I,K)     = 0.
!               RAD_QR_dev(I,K)     = 0.
!               RAD_QS_dev(I,K)     = 0.
!               RAD_CLDFRC_dev(I,K) = 0.
!               CLDREFFL_dev(I,K)   = 0.
!               CLDREFFI_dev(I,K)   = 0.
!            ELSE
!               call RADCOUPLE ( TEMP, PP_dev(I,K), CLDFRC_dev(I,K), ANVFRC_dev(I,K), &
!                     QLW_LS_dev(I,K), QIW_LS_dev(I,K), QLW_AN_dev(I,K), QIW_AN_dev(I,K), QRN_ALL, QSN_ALL, & 
!                     RAD_QL_dev(I,K), RAD_QI_dev(I,K), RAD_QR_dev(I,K), RAD_QS_dev(I,K), RAD_CLDFRC_dev(I,K), & 
!                     CLDREFFL_dev(I,K), CLDREFFI_dev(I,K), CLDVOL2FRC,N_ANVIL*1.e6,N_ICE*1.e6,N_WARM*1.e6, &
!                     TEMPOR_dev(I))
!            END IF
        qrn_cu_dev(i, k) = qrn_cu_1d
      END DO k_loop
    END DO run_loop
  END SUBROUTINE PROGNO_CLOUD
!  Differentiation of pdf_spread in reverse (adjoint) mode (with options r8 split(GEOS_MoistGridComp.PRE_PROGNO_CLOUD)):
!   gradient     of useful results: u alpha v
!   with respect to varying inputs: v_below u_above u v u_below
!                dz_above dz_below v_above
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!              P R O C E S S   S U B R O U T I N E S                 !!
!!                         * * * * *                                  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!              P R O C E S S   S U B R O U T I N E S                 !!
!!                         * * * * *                                  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!              P R O C E S S   S U B R O U T I N E S                 !!
!!                         * * * * *                                  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
!         ALPHT_DIAG, ALPH1_DIAG, ALPH2_DIAG,&
  SUBROUTINE PDF_SPREAD_ADM(k, lm, u, u_ad, u_above, u_above_ad, u_below&
&   , u_below_ad, v, v_ad, v_above, v_above_ad, v_below, v_below_ad, kh&
&   , dz_above, dz_above_ad, dz_below, dz_below_ad, updf, pp, alpha, &
&   alpha_ad, frland)
    IMPLICIT NONE
!      ALPHT_DIAG = ALPHA
    INTEGER, INTENT(IN) :: k, lm
    REAL*8, INTENT(IN) :: u, u_above, u_below
    REAL*8 :: u_ad, u_above_ad, u_below_ad
    REAL*8, INTENT(IN) :: v, v_above, v_below
    REAL*8 :: v_ad, v_above_ad, v_below_ad
    REAL*8, INTENT(IN) :: dz_above, dz_below
    REAL*8 :: dz_above_ad, dz_below_ad
    REAL*8, INTENT(IN) :: updf, pp
    REAL*8, INTENT(IN) :: kh
    REAL*8 :: alpha
    REAL*8 :: alpha_ad
!      real(8),    intent(out) :: ALPH1_DIAG, ALPH2_DIAG, ALPHT_DIAG
    REAL*8, INTENT(IN) :: frland
    REAL*8 :: a1, a2, a3
    REAL*8 :: a1_ad, a2_ad, a3_ad
    REAL*8 :: tempmaxrh
    INTRINSIC TAN
    INTRINSIC ATAN
    INTRINSIC MIN
    INTRINSIC SQRT
    INTRINSIC ABS
    INTEGER :: branch
    REAL*8 :: temp2
    REAL*8 :: temp1
    REAL*8 :: temp0
    REAL*8 :: temp_ad7
    REAL*8 :: temp_ad6
    REAL*8 :: temp_ad5
    REAL*8 :: temp_ad4
    REAL*8 :: temp_ad3
    REAL*8 :: temp_ad2
    REAL*8 :: temp_ad1
    REAL*8 :: temp_ad0
    REAL*8 :: temp_ad
    REAL*8 :: temp
! end of slingo ritter if-sequence
! alpha is the 1/2*width so RH_crit=1.0-alpha
    IF (tanhrhcrit .EQ. 1) THEN
!  Use Slingo-Ritter (1985) formulation for critical relative humidity
!  array a1 holds the critical rh, ranges from 0.8 to 1
      tempmaxrh = maxrhcrit
      IF (frland .GT. 0.05) tempmaxrh = maxrhcritland
      IF (pp .LE. turnrhcrit) THEN
        a1 = minrhcrit
      ELSE
        a1 = minrhcrit + (tempmaxrh-minrhcrit)/19.*((ATAN((2.*(pp-&
&         turnrhcrit)/(1020.-turnrhcrit)-1.)*TAN(20.*pi_0/21.-0.5*pi_0))&
&         +0.5*pi_0)*21./pi_0-1.)
      END IF
      IF (a1 .GT. 1.) THEN
        a1 = 1.
      ELSE
        a1 = a1
      END IF
      CALL PUSHREAL8(alpha)
      alpha = 1. - a1
      CALL PUSHCONTROL1B(1)
    ELSE
! 0.1% RH SLOP
      CALL PUSHREAL8(alpha)
      alpha = 0.001
!! DIRECTIONAL SHEAR == ABS( e_normal dot [U_z,V_z] ) 
      a1 = 0.
! inverse of wind mag 
      a3 = 1./SQRT(u**2+v**2+0.01)
! x-component of unit normal to (U,V) 
      a2 = v*a3
      IF (k .GT. 1 .AND. k .LT. lm) THEN
        a1 = a2*(u_above-u_below)/(dz_above+dz_below)
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
! y-component of unit normal to (U,V) 
      a2 = -(u*a3)
      IF (k .GT. 1 .AND. k .LT. lm) THEN
        a1 = a2*(v_above-v_below)/(dz_above+dz_below) + a1
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (a1 .GE. 0.) THEN
        CALL PUSHCONTROL1B(0)
        a1 = a1
      ELSE
        a1 = -a1
        CALL PUSHCONTROL1B(1)
      END IF
      alpha = alpha + 10.*a1
!         ALPH1_DIAG = 10.*A1
!! Total shear = SQRT( [U_z,V_z] dot [U_z,V_z] )
      a1 = 0.
      IF (k .GT. 1 .AND. k .LT. lm) THEN
        a1 = ((u_above-u_below)/(dz_above+dz_below))**2 + ((v_above-&
&         v_below)/(dz_above+dz_below))**2
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
! A1 is now magnitude of TOTAL shear at layers in (m/s) /m.  Thus, A1=.001  ==> 1 m/s/km
      CALL PUSHREAL8(a1)
      a1 = SQRT(a1)
      alpha = alpha + 3.33*a1
!! KH values ~100 m+2 s-1 typical of strong PBLs
      alpha = alpha + 0.002*kh
!         ALPH2_DIAG = 0.002*KH
      CALL PUSHCONTROL1B(0)
    END IF
    IF (alpha .GT. 0.25) alpha_ad = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      a1_ad = 3.33*alpha_ad
      CALL POPREAL8(a1)
      IF (a1 .EQ. 0.0_8) THEN
        a1_ad = 0.0
      ELSE
        a1_ad = a1_ad/(2.0*SQRT(a1))
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        temp1 = (u_above-u_below)/(dz_above+dz_below)
        temp_ad4 = 2*temp1*a1_ad/(dz_above+dz_below)
        temp_ad5 = -(temp1*temp_ad4)
        temp2 = (v_above-v_below)/(dz_above+dz_below)
        temp_ad6 = 2*temp2*a1_ad/(dz_above+dz_below)
        temp_ad7 = -(temp2*temp_ad6)
        u_above_ad = temp_ad4
        u_below_ad = -temp_ad4
        dz_above_ad = temp_ad7 + temp_ad5
        dz_below_ad = temp_ad7 + temp_ad5
        v_above_ad = temp_ad6
        v_below_ad = -temp_ad6
      ELSE
        v_below_ad = 0.0_8
        u_above_ad = 0.0_8
        u_below_ad = 0.0_8
        dz_above_ad = 0.0_8
        dz_below_ad = 0.0_8
        v_above_ad = 0.0_8
      END IF
      a1_ad = 10.*alpha_ad
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) a1_ad = -a1_ad
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        a2_ad = 0.0_8
      ELSE
        temp_ad2 = a1_ad/(dz_above+dz_below)
        temp_ad3 = -(a2*(v_above-v_below)*temp_ad2/(dz_above+dz_below))
        a2_ad = (v_above-v_below)*temp_ad2
        v_above_ad = v_above_ad + a2*temp_ad2
        v_below_ad = v_below_ad - a2*temp_ad2
        dz_above_ad = dz_above_ad + temp_ad3
        dz_below_ad = dz_below_ad + temp_ad3
      END IF
      u_ad = u_ad - a3*a2_ad
      a3_ad = -(u*a2_ad)
      a2 = v*a3
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        temp_ad0 = a1_ad/(dz_above+dz_below)
        temp_ad1 = -(a2*(u_above-u_below)*temp_ad0/(dz_above+dz_below))
        a2_ad = (u_above-u_below)*temp_ad0
        u_above_ad = u_above_ad + a2*temp_ad0
        u_below_ad = u_below_ad - a2*temp_ad0
        dz_above_ad = dz_above_ad + temp_ad1
        dz_below_ad = dz_below_ad + temp_ad1
      ELSE
        a2_ad = 0.0_8
      END IF
      a3_ad = a3_ad + v*a2_ad
      temp = u**2 + v**2 + 0.01
      temp0 = SQRT(temp)
      IF (temp .EQ. 0.0_8) THEN
        temp_ad = 0.0
      ELSE
        temp_ad = -(a3_ad/(temp0**3*2.0))
      END IF
      v_ad = v_ad + 2*v*temp_ad + a3*a2_ad
      u_ad = u_ad + 2*u*temp_ad
      CALL POPREAL8(alpha)
    ELSE
      CALL POPREAL8(alpha)
      v_below_ad = 0.0_8
      u_above_ad = 0.0_8
      u_below_ad = 0.0_8
      dz_above_ad = 0.0_8
      dz_below_ad = 0.0_8
      v_above_ad = 0.0_8
    END IF
  END SUBROUTINE PDF_SPREAD_ADM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!              P R O C E S S   S U B R O U T I N E S                 !!
!!                         * * * * *                                  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!              P R O C E S S   S U B R O U T I N E S                 !!
!!                         * * * * *                                  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!                                                                    !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!              P R O C E S S   S U B R O U T I N E S                 !!
!!                         * * * * *                                  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
!         ALPHT_DIAG, ALPH1_DIAG, ALPH2_DIAG,&
  SUBROUTINE PDF_SPREAD(k, lm, u, u_above, u_below, v, v_above, v_below&
&   , kh, dz_above, dz_below, updf, pp, alpha, frland)
    IMPLICIT NONE
!      ALPHT_DIAG = ALPHA
    INTEGER, INTENT(IN) :: k, lm
    REAL*8, INTENT(IN) :: u, u_above, u_below
    REAL*8, INTENT(IN) :: v, v_above, v_below
    REAL*8, INTENT(IN) :: dz_above, dz_below
    REAL*8, INTENT(IN) :: updf, pp
    REAL*8, INTENT(IN) :: kh
    REAL*8, INTENT(OUT) :: alpha
!      real(8),    intent(out) :: ALPH1_DIAG, ALPH2_DIAG, ALPHT_DIAG
    REAL*8, INTENT(IN) :: frland
    REAL*8 :: a1, a2, a3
    REAL*8 :: tempmaxrh
    INTRINSIC TAN
    INTRINSIC ATAN
    INTRINSIC MIN
    INTRINSIC SQRT
    INTRINSIC ABS
! end of slingo ritter if-sequence
! alpha is the 1/2*width so RH_crit=1.0-alpha
    IF (tanhrhcrit .EQ. 1) THEN
!  Use Slingo-Ritter (1985) formulation for critical relative humidity
!  array a1 holds the critical rh, ranges from 0.8 to 1
      tempmaxrh = maxrhcrit
      IF (frland .GT. 0.05) tempmaxrh = maxrhcritland
      a1 = 1.0
      IF (pp .LE. turnrhcrit) THEN
        a1 = minrhcrit
      ELSE
        a1 = minrhcrit + (tempmaxrh-minrhcrit)/19.*((ATAN((2.*(pp-&
&         turnrhcrit)/(1020.-turnrhcrit)-1.)*TAN(20.*pi_0/21.-0.5*pi_0))&
&         +0.5*pi_0)*21./pi_0-1.)
      END IF
      IF (a1 .GT. 1.) THEN
        a1 = 1.
      ELSE
        a1 = a1
      END IF
      alpha = 1. - a1
    ELSE
! 0.1% RH SLOP
      alpha = 0.001
!! DIRECTIONAL SHEAR == ABS( e_normal dot [U_z,V_z] ) 
      a1 = 0.
! inverse of wind mag 
      a3 = 1./SQRT(u**2+v**2+0.01)
! x-component of unit normal to (U,V) 
      a2 = v*a3
      IF (k .GT. 1 .AND. k .LT. lm) a1 = a2*(u_above-u_below)/(dz_above+&
&         dz_below)
! y-component of unit normal to (U,V) 
      a2 = -(u*a3)
      IF (k .GT. 1 .AND. k .LT. lm) a1 = a2*(v_above-v_below)/(dz_above+&
&         dz_below) + a1
      IF (a1 .GE. 0.) THEN
        a1 = a1
      ELSE
        a1 = -a1
      END IF
      alpha = alpha + 10.*a1
!         ALPH1_DIAG = 10.*A1
!! Total shear = SQRT( [U_z,V_z] dot [U_z,V_z] )
      a1 = 0.
      IF (k .GT. 1 .AND. k .LT. lm) a1 = ((u_above-u_below)/(dz_above+&
&         dz_below))**2 + ((v_above-v_below)/(dz_above+dz_below))**2
! A1 is now magnitude of TOTAL shear at layers in (m/s) /m.  Thus, A1=.001  ==> 1 m/s/km
      a1 = SQRT(a1)
      alpha = alpha + 3.33*a1
!! KH values ~100 m+2 s-1 typical of strong PBLs
      alpha = alpha + 0.002*kh
!         ALPH2_DIAG = 0.002*KH
    END IF
    IF (alpha .GT. 0.25) THEN
      alpha = 0.25
    ELSE
      alpha = alpha
    END IF
  END SUBROUTINE PDF_SPREAD
!  Differentiation of fix_up_clouds in reverse (adjoint) mode (with options r8 split(GEOS_MoistGridComp.PRE_PROGNO_CLOUD)):
!   gradient     of useful results: af qv qla qlc qia qic cf te
!   with respect to varying inputs: af qv qla qlc qia qic cf te
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE FIX_UP_CLOUDS_ADM(qv, qv_ad, te, te_ad, qlc, qlc_ad, qic, &
&   qic_ad, cf, cf_ad, qla, qla_ad, qia, qia_ad, af, af_ad)
    IMPLICIT NONE
    REAL*8, INTENT(INOUT) :: te, qv, qlc, cf, qla, af, qic, qia
    REAL*8 :: te_ad, qv_ad, qlc_ad, cf_ad, qla_ad, af_ad, qic_ad, qia_ad
    INTEGER :: branch
! Fix if Anvil cloud fraction too small
    IF (af .LT. 1.e-5) THEN
      CALL PUSHREAL8(qla)
      qla = 0.
      CALL PUSHREAL8(qia)
      qia = 0.
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! Fix if LS cloud fraction too small
    IF (cf .LT. 1.e-5) THEN
      CALL PUSHREAL8(qlc)
      qlc = 0.
      CALL PUSHREAL8(qic)
      qic = 0.
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! LS LIQUID too small
    IF (qlc .LT. 1.e-8) THEN
      CALL PUSHREAL8(qlc)
      qlc = 0.
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! LS ICE too small
    IF (qic .LT. 1.e-8) THEN
      CALL PUSHREAL8(qic)
      qic = 0.
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! Anvil LIQUID too small
    IF (qla .LT. 1.e-8) THEN
      CALL PUSHREAL8(qla)
      qla = 0.
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! Anvil ICE too small
    IF (qia .LT. 1.e-8) THEN
      CALL PUSHREAL8(qia)
      qia = 0.
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! Fix ALL cloud quants if Anvil cloud LIQUID+ICE too small
    IF (qla + qia .LT. 1.e-8) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! Ditto if LS cloud LIQUID+ICE too small
    IF (qlc + qic .LT. 1.e-8) THEN
      qlc_ad = qv_ad - mapl8_alhl*te_ad/mapl8_cp
      qic_ad = qv_ad - mapl8_alhs*te_ad/mapl8_cp
      cf_ad = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qla_ad = qv_ad - mapl8_alhl*te_ad/mapl8_cp
      qia_ad = qv_ad - mapl8_alhs*te_ad/mapl8_cp
      af_ad = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(qia)
      qia_ad = qv_ad - mapl8_alhs*te_ad/mapl8_cp
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(qla)
      qla_ad = qv_ad - mapl8_alhl*te_ad/mapl8_cp
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(qic)
      qic_ad = qv_ad - mapl8_alhs*te_ad/mapl8_cp
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(qlc)
      qlc_ad = qv_ad - mapl8_alhl*te_ad/mapl8_cp
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(qic)
      CALL POPREAL8(qlc)
      qlc_ad = qv_ad - mapl8_alhl*te_ad/mapl8_cp
      qic_ad = qv_ad - mapl8_alhs*te_ad/mapl8_cp
      cf_ad = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(qia)
      CALL POPREAL8(qla)
      qla_ad = qv_ad - mapl8_alhl*te_ad/mapl8_cp
      qia_ad = qv_ad - mapl8_alhs*te_ad/mapl8_cp
      af_ad = 0.0_8
    END IF
  END SUBROUTINE FIX_UP_CLOUDS_ADM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE FIX_UP_CLOUDS(qv, te, qlc, qic, cf, qla, qia, af)
    IMPLICIT NONE
    REAL*8, INTENT(INOUT) :: te, qv, qlc, cf, qla, af, qic, qia
! Fix if Anvil cloud fraction too small
    IF (af .LT. 1.e-5) THEN
      qv = qv + qla + qia
      te = te - mapl8_alhl/mapl8_cp*qla - mapl8_alhs/mapl8_cp*qia
      af = 0.
      qla = 0.
      qia = 0.
    END IF
! Fix if LS cloud fraction too small
    IF (cf .LT. 1.e-5) THEN
      qv = qv + qlc + qic
      te = te - mapl8_alhl/mapl8_cp*qlc - mapl8_alhs/mapl8_cp*qic
      cf = 0.
      qlc = 0.
      qic = 0.
    END IF
! LS LIQUID too small
    IF (qlc .LT. 1.e-8) THEN
      qv = qv + qlc
      te = te - mapl8_alhl/mapl8_cp*qlc
      qlc = 0.
    END IF
! LS ICE too small
    IF (qic .LT. 1.e-8) THEN
      qv = qv + qic
      te = te - mapl8_alhs/mapl8_cp*qic
      qic = 0.
    END IF
! Anvil LIQUID too small
    IF (qla .LT. 1.e-8) THEN
      qv = qv + qla
      te = te - mapl8_alhl/mapl8_cp*qla
      qla = 0.
    END IF
! Anvil ICE too small
    IF (qia .LT. 1.e-8) THEN
      qv = qv + qia
      te = te - mapl8_alhs/mapl8_cp*qia
      qia = 0.
    END IF
! Fix ALL cloud quants if Anvil cloud LIQUID+ICE too small
    IF (qla + qia .LT. 1.e-8) THEN
      qv = qv + qla + qia
      te = te - mapl8_alhl/mapl8_cp*qla - mapl8_alhs/mapl8_cp*qia
      af = 0.
      qla = 0.
      qia = 0.
    END IF
! Ditto if LS cloud LIQUID+ICE too small
    IF (qlc + qic .LT. 1.e-8) THEN
      qv = qv + qlc + qic
      te = te - mapl8_alhl/mapl8_cp*qlc - mapl8_alhs/mapl8_cp*qic
      cf = 0.
      qlc = 0.
      qic = 0.
    END IF
  END SUBROUTINE FIX_UP_CLOUDS
!  Differentiation of meltfrz in reverse (adjoint) mode (with options r8 split(GEOS_MoistGridComp.PRE_PROGNO_CLOUD)):
!   gradient     of useful results: qi ql te
!   with respect to varying inputs: qi ql te
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE MELTFRZ_ADM(dt, te, te_ad, ql, ql_ad, qi, qi_ad)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: dt
    REAL*8, INTENT(INOUT) :: te, ql, qi
    REAL*8 :: te_ad, ql_ad, qi_ad
    REAL*8 :: fqi, dqil
    REAL*8 :: fqi_ad, dqil_ad
    REAL*8 :: taufrz
    INTEGER :: k
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: branch
    REAL*8 :: temp
    taufrz = 1000.
    fqi = ICE_FRACTION(te)
    dqil = 0.
! freeze liquid
    IF (te .LE. t_ice_max) THEN
      dqil = ql*(1.0-EXP(-(dt*fqi/taufrz)))
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (0. .LT. dqil) THEN
      CALL PUSHCONTROL1B(0)
      dqil = dqil
    ELSE
      dqil = 0.
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(qi)
    qi = qi + dqil
    CALL PUSHREAL8(te)
    te = te + (mapl8_alhs-mapl8_alhl)*dqil/mapl8_cp
    dqil = 0.
! melt ice instantly above 0^C
    IF (te .GT. t_ice_max) THEN
      dqil = -qi
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (0. .GT. dqil) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    dqil_ad = qi_ad - ql_ad + (mapl8_alhs-mapl8_alhl)*te_ad/mapl8_cp
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) dqil_ad = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) qi_ad = qi_ad - dqil_ad
    CALL POPREAL8(te)
    dqil_ad = qi_ad - ql_ad + (mapl8_alhs-mapl8_alhl)*te_ad/mapl8_cp
    CALL POPREAL8(qi)
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) dqil_ad = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      fqi_ad = 0.0_8
    ELSE
      temp = -(dt*fqi/taufrz)
      ql_ad = ql_ad + (1.0-EXP(temp))*dqil_ad
      fqi_ad = dt*EXP(temp)*ql*dqil_ad/taufrz
    END IF
    CALL ICE_FRACTION_ADM(te, te_ad, fqi_ad)
  END SUBROUTINE MELTFRZ_ADM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE MELTFRZ(dt, te, ql, qi)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: dt
    REAL*8, INTENT(INOUT) :: te, ql, qi
    REAL*8 :: fqi, dqil
    REAL*8 :: taufrz
    INTEGER :: k
    INTRINSIC EXP
    INTRINSIC MAX
    INTRINSIC MIN
    taufrz = 1000.
    fqi = ICE_FRACTION(te)
    dqil = 0.
! freeze liquid
    IF (te .LE. t_ice_max) dqil = ql*(1.0-EXP(-(dt*fqi/taufrz)))
    IF (0. .LT. dqil) THEN
      dqil = dqil
    ELSE
      dqil = 0.
    END IF
    qi = qi + dqil
    ql = ql - dqil
    te = te + (mapl8_alhs-mapl8_alhl)*dqil/mapl8_cp
    dqil = 0.
! melt ice instantly above 0^C
    IF (te .GT. t_ice_max) dqil = -qi
    IF (0. .GT. dqil) THEN
      dqil = dqil
    ELSE
      dqil = 0.
    END IF
    qi = qi + dqil
    ql = ql - dqil
    te = te + (mapl8_alhs-mapl8_alhl)*dqil/mapl8_cp
  END SUBROUTINE MELTFRZ
!  Differentiation of hystpdf in reverse (adjoint) mode (with options r8 split(GEOS_MoistGridComp.PRE_PROGNO_CLOUD)):
!   gradient     of useful results: qai qal af qv qci qcl cf te
!   with respect to varying inputs: qai qal af alpha qv qci qcl
!                cf te
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE HYSTPDF_ADM(dt, alpha, alpha_ad, pdfshape, pl, qv, qv_ad, &
&   qcl, qcl_ad, qal, qal_ad, qci, qci_ad, qai, qai_ad, te, te_ad, cf, &
&   cf_ad, af, af_ad)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: dt, alpha, pl
    REAL*8 :: alpha_ad
    INTEGER, INTENT(IN) :: pdfshape
    REAL*8, INTENT(INOUT) :: te, qv, qcl, qci, cf, qal, qai, af
    REAL*8 :: te_ad, qv_ad, qcl_ad, qci_ad, cf_ad, qal_ad, qai_ad, af_ad
! internal arrays
    REAL*8 :: qco, qvo, cfo, qao, tau
    REAL*8 :: qco_ad, cfo_ad, qao_ad
    REAL*8 :: qt, qmx, qmn, dq, qvtop, sigmaqt1, sigmaqt2
    REAL*8 :: qt_ad, sigmaqt1_ad, sigmaqt2_ad
    REAL*8 :: teo, qsx, dqsx, qs, dqs
    REAL*8 :: teo_ad, qsx_ad, dqsx_ad, dqs_ad
    REAL*8 :: tep, qsp, cfp, qvp, qcp
    REAL*8 :: tep_ad, qcp_ad
    REAL*8 :: ten, qsn, cfn, qvn, qcn
    REAL*8 :: ten_ad, qsn_ad, cfn_ad, qcn_ad
    REAL*8 :: qcx, qvx, cfx, qax, qc, qa, fqi, fqi_a
    REAL*8 :: qcx_ad, qvx_ad, cfx_ad, qax_ad, qc_ad, qa_ad, fqi_ad
    REAL*8 :: dqai, dqal, dqci, dqcl
    REAL*8 :: dqai_ad, dqal_ad, dqci_ad, dqcl_ad
    REAL*8 :: tmparr
    REAL*8 :: tmparr_ad
    REAL*8 :: alhx
    REAL*8 :: alhx_ad
! internal scalars
    INTEGER :: n
    INTRINSIC MAX
    INTEGER :: branch
    REAL*8 :: temp1
    REAL*8 :: temp0
    REAL*8 :: temp_ad7
    REAL*8 :: temp_ad6
    REAL*8 :: temp_ad5
    REAL*8 :: temp_ad4
    REAL*8 :: temp_ad3
    REAL*8 :: temp_ad2
    REAL*8 :: temp_ad1
    REAL*8 :: temp_ad0
    REAL*8 :: temp_ad
    REAL*8 :: temp
    qc = qcl + qci
    qa = qal + qai
    teo = te
    CALL DQSATSCAPERT(dqsx, qsx, teo, pl)
    IF (af .LT. 1.0) THEN
      tmparr = 1./(1.-af)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      tmparr = 0.0
    END IF
    cfx = cf*tmparr
    qcx = qc*tmparr
    qvx = (qv-qsx*af)*tmparr
    IF (af .GE. 1.0) THEN
      qvx = qsx*1.e-4
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (af .GT. 0.) THEN
      qax = qa/af
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      qax = 0.
    END IF
    qt = qcx + qvx
    ten = teo
    cfn = cfx
    qcn = qcx
    DO n=1,4
      CALL PUSHREAL8(qcp)
      qcp = qcn
      CALL PUSHREAL8(qsn)
      CALL PUSHREAL8(dqs)
      CALL DQSATSCAPERT(dqs, qsn, ten, pl)
      CALL PUSHREAL8(tep)
      tep = ten
      CALL PUSHREAL8(fqi)
      fqi = ICE_FRACTION(tep)
      CALL PUSHREAL8(sigmaqt1)
      sigmaqt1 = alpha*qsn
      CALL PUSHREAL8(sigmaqt2)
      sigmaqt2 = alpha*qsn
      IF (pdfflag .EQ. 2) THEN
! for triangular, symmetric: sigmaqt1 = sigmaqt2 = alpha*qsn (alpha is half width)
! for triangular, skewed r : sigmaqt1 < sigmaqt2
! try: skewed right below 500 mb
!!!       if(pl.lt.500.) then
        sigmaqt1 = alpha*qsn
        sigmaqt2 = alpha*qsn
!!!       else
!!!       sigmaqt1  = 2*ALPHA*QSn*0.4
!!!       sigmaqt2  = 2*ALPHA*QSn*0.6
!!!       endif
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      CALL PUSHREAL8(cfn)
      CALL PDFFRAC(pdfshape, qt, sigmaqt1, sigmaqt2, qsn, cfn)
      CALL PUSHREAL8(qcn)
      CALL PDFCONDENSATE(pdfshape, qt, sigmaqt1, sigmaqt2, qsn, qcn)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! These lines represent adjustments
! to anvil condensate due to the 
! assumption of a stationary TOTAL 
! water PDF subject to a varying 
! QSAT value during the iteration
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
      IF (af .GT. 0.) THEN
! + QSx - QS 
        CALL PUSHREAL8(qao)
        qao = qax
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHREAL8(qao)
        qao = 0.
        CALL PUSHCONTROL1B(1)
      END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      CALL PUSHREAL8(alhx)
      alhx = (1.0-fqi)*mapl8_alhl + fqi*mapl8_alhs
      IF (pdfflag .EQ. 1) THEN
        CALL PUSHREAL8(qcn)
        qcn = qcp + (qcn-qcp)/(1.-(cfn*(alpha-1.)-qcn/qsn)*dqs*alhx/&
&         mapl8_cp)
        CALL PUSHCONTROL2B(0)
      ELSE IF (pdfflag .EQ. 2) THEN
! This next line needs correcting - need proper d(del qc)/dT derivative for triangular
! for now, just use relaxation of 1/2.
        IF (n .NE. 4) THEN
          qcn = qcp + (qcn-qcp)*0.5
          CALL PUSHCONTROL2B(1)
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
      ELSE
        CALL PUSHCONTROL2B(3)
      END IF
      CALL PUSHREAL8(ten)
      ten = tep + (1.0-fqi)*(mapl8_alhl/mapl8_cp)*((qcn-qcp)*(1.-af)+(&
&       qao-qax)*af) + fqi*(mapl8_alhs/mapl8_cp)*((qcn-qcp)*(1.-af)+(qao&
&       -qax)*af)
    END DO
! qsat iteration
    cfo = cfn
    qco = qcn
! Update prognostic variables.  Deal with special case of AF=1
! Temporary variables QCo, QAo become updated grid means.
    IF (af .LT. 1.0) THEN
      CALL PUSHREAL8(cf)
      cf = cfo*(1.-af)
      CALL PUSHREAL8(qco)
      qco = qco*(1.-af)
      CALL PUSHREAL8(qao)
      qao = qao*af
      CALL PUSHCONTROL2B(0)
    ELSE
! Special case AF=1, i.e., box filled with anvil. 
!   - Note: no guarantee QV_box > QS_box
! Remove any other cloud
      CALL PUSHREAL8(cf)
      cf = 0.
! Add any LS condensate to anvil type
      CALL PUSHREAL8(qao)
      qao = qa + qc
! Remove same from LS   
      qco = 0.
! Total water
      qt = qao + qv
      IF (qt - qsx .LT. 0.) THEN
        qao = 0.
        CALL PUSHCONTROL2B(2)
      ELSE
        qao = qt - qsx
        CALL PUSHCONTROL2B(1)
      END IF
    END IF
! Now take {\em New} condensate and partition into ice and liquid
! taking care to keep both >=0 separately. New condensate can be
! less than old, so $\Delta$ can be < 0.
    qcx = qco - qc
    dqcl = (1.0-fqi)*qcx
    dqci = fqi*qcx
    IF (qcl + dqcl .LT. 0.) THEN
      dqci = dqci + (qcl+dqcl)
!== dQCl - (QCl+dQCl)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (qci + dqci .LT. 0.) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    CALL PUSHREAL8(qax)
    qax = qao - qa
! (1.0-fQi)*QAx
    dqal = qax
!  fQi  * QAx
    dqai = 0.
    IF (qal + dqal .LT. 0.) THEN
      dqai = dqai + (qal+dqal)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (qai + dqai .LT. 0.) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! Clean-up cloud if fractions are too small
    IF (af .LT. 1.e-5) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (cf .LT. 1.e-5) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
!!TE  = TE + (MAPL8_ALHS/MAPL8_CP)*(dQAi+dQCi) + (MAPL8_ALHL/MAPL8_CP)*(dQAl+dQCl)
! We need to take care of situations where QS moves past QA
! during QSAT iteration. This should be only when QA/AF is small
! to begin with. Effect is to make QAo negative. So, we 
! "evaporate" offending QAs
!
! We get rid of anvil fraction also, although strictly
! speaking, PDF-wise, we should not do this.
    IF (qao .LE. 0.) THEN
      qai_ad = qv_ad - mapl8_alhs*te_ad/mapl8_cp
      qal_ad = qv_ad - mapl8_alhl*te_ad/mapl8_cp
      af_ad = 0.0_8
    END IF
    temp_ad6 = te_ad/mapl8_cp
    temp_ad7 = mapl8_alhl*temp_ad6
    dqai_ad = qai_ad - qv_ad + mapl8_alhf*temp_ad6 + temp_ad7
    dqci_ad = qci_ad - qv_ad + mapl8_alhf*temp_ad6 + temp_ad7
    dqal_ad = qal_ad - qv_ad + temp_ad7
    dqcl_ad = qcl_ad - qv_ad + temp_ad7
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qcl_ad = qcl_ad - dqcl_ad
      qci_ad = qci_ad - dqci_ad
      dqci_ad = 0.0_8
      dqcl_ad = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qal_ad = qal_ad - dqal_ad
      qai_ad = qai_ad - dqai_ad
      dqai_ad = 0.0_8
      dqal_ad = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qai_ad = qai_ad + dqal_ad - dqai_ad
      dqai_ad = dqal_ad
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qal_ad = qal_ad + dqai_ad - dqal_ad
      dqal_ad = dqai_ad
    END IF
    qax_ad = dqal_ad
    CALL POPREAL8(qax)
    qao_ad = qax_ad
    qa_ad = -qax_ad
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qci_ad = qci_ad + dqcl_ad - dqci_ad
      dqci_ad = dqcl_ad
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qcl_ad = qcl_ad + dqci_ad - dqcl_ad
      dqcl_ad = dqci_ad
    END IF
    fqi_ad = qcx*dqci_ad - qcx*dqcl_ad
    qcx_ad = (1.0-fqi)*dqcl_ad + fqi*dqci_ad
    qco_ad = qcx_ad
    qc_ad = -qcx_ad
    CALL POPCONTROL2B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(qao)
      CALL POPREAL8(qco)
      af_ad = af_ad + qao*qao_ad - cfo*cf_ad - qco*qco_ad
      qao_ad = af*qao_ad
      qco_ad = (1.-af)*qco_ad
      CALL POPREAL8(cf)
      cfo_ad = (1.-af)*cf_ad
      qsx_ad = 0.0_8
    ELSE
      IF (branch .EQ. 1) THEN
        qt_ad = qao_ad
        qsx_ad = -qao_ad
      ELSE
        qt_ad = 0.0_8
        qsx_ad = 0.0_8
      END IF
      qao_ad = qt_ad
      qv_ad = qv_ad + qt_ad
      CALL POPREAL8(qao)
      qa_ad = qa_ad + qao_ad
      qc_ad = qc_ad + qao_ad
      CALL POPREAL8(cf)
      qao_ad = 0.0_8
      cfo_ad = 0.0_8
      qco_ad = 0.0_8
    END IF
    qcn_ad = qco_ad
    cfn_ad = cfo_ad
    qcx = qc*tmparr
    qt = qcx + qvx
    alpha_ad = 0.0_8
    ten_ad = 0.0_8
    qt_ad = 0.0_8
    qax_ad = 0.0_8
    DO n=4,1,-1
      CALL POPREAL8(ten)
      temp_ad4 = mapl8_alhl*(1.0-fqi)*ten_ad/mapl8_cp
      temp_ad5 = mapl8_alhs*fqi*ten_ad/mapl8_cp
      tep_ad = ten_ad
      fqi_ad = fqi_ad + (((qcn-qcp)*(1.-af)+(qao-qax)*af)*mapl8_alhs/&
&       mapl8_cp-((qcn-qcp)*(1.-af)+(qao-qax)*af)*mapl8_alhl/mapl8_cp)*&
&       ten_ad
      qcn_ad = qcn_ad + (1.-af)*temp_ad5 + (1.-af)*temp_ad4
      qcp_ad = -((1.-af)*temp_ad5) - (1.-af)*temp_ad4
      af_ad = af_ad + (qao-qax-qcn+qcp)*temp_ad5 + (qao-qax-qcn+qcp)*&
&       temp_ad4
      qao_ad = qao_ad + af*temp_ad5 + af*temp_ad4
      qax_ad = qax_ad - af*temp_ad5 - af*temp_ad4
      CALL POPCONTROL2B(branch)
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(qcn)
          temp1 = dqs*alhx/mapl8_cp
          temp0 = cfn*(alpha-1.) - qcn/qsn
          temp = -(temp0*temp1) + 1.
          temp_ad0 = qcn_ad/temp
          temp_ad1 = -((qcn-qcp)*temp_ad0/temp)
          temp_ad2 = -(temp1*temp_ad1)
          temp_ad3 = -(temp0*temp_ad1/mapl8_cp)
          qcp_ad = qcp_ad + qcn_ad - temp_ad0
          cfn_ad = cfn_ad + (alpha-1.)*temp_ad2
          alpha_ad = alpha_ad + cfn*temp_ad2
          qsn_ad = qcn*temp_ad2/qsn**2
          dqs_ad = alhx*temp_ad3
          alhx_ad = dqs*temp_ad3
          qcn_ad = temp_ad0 - temp_ad2/qsn
          GOTO 100
        ELSE
          qcp_ad = qcp_ad + 0.5*qcn_ad
          qcn_ad = 0.5*qcn_ad
        END IF
      END IF
      dqs_ad = 0.0_8
      alhx_ad = 0.0_8
      qsn_ad = 0.0_8
 100  CALL POPREAL8(alhx)
      fqi_ad = fqi_ad + (mapl8_alhs-mapl8_alhl)*alhx_ad
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(qao)
        qax_ad = qax_ad + qao_ad
      ELSE
        CALL POPREAL8(qao)
      END IF
      CALL POPREAL8(qcn)
      CALL PDFCONDENSATE_ADM(pdfshape, qt, qt_ad, sigmaqt1, sigmaqt1_ad&
&                      , sigmaqt2, sigmaqt2_ad, qsn, qsn_ad, qcn, qcn_ad&
&                     )
      CALL POPREAL8(cfn)
      CALL PDFFRAC_ADM(pdfshape, qt, qt_ad, sigmaqt1, sigmaqt1_ad, &
&                sigmaqt2, sigmaqt2_ad, qsn, qsn_ad, cfn, cfn_ad)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        alpha_ad = alpha_ad + qsn*sigmaqt1_ad + qsn*sigmaqt2_ad
        qsn_ad = qsn_ad + alpha*sigmaqt1_ad + alpha*sigmaqt2_ad
        sigmaqt1_ad = 0.0_8
        sigmaqt2_ad = 0.0_8
      END IF
      CALL POPREAL8(sigmaqt2)
      alpha_ad = alpha_ad + qsn*sigmaqt1_ad + qsn*sigmaqt2_ad
      qsn_ad = qsn_ad + alpha*sigmaqt1_ad + alpha*sigmaqt2_ad
      CALL POPREAL8(sigmaqt1)
      CALL POPREAL8(fqi)
      CALL ICE_FRACTION_ADM(tep, tep_ad, fqi_ad)
      CALL POPREAL8(tep)
      ten_ad = tep_ad
      CALL POPREAL8(dqs)
      CALL POPREAL8(qsn)
      CALL DQSATSCAPERT_ADM(dqs, dqs_ad, qsn, qsn_ad, ten, ten_ad, pl)
      CALL POPREAL8(qcp)
      qcn_ad = qcp_ad
      qao_ad = 0.0_8
      fqi_ad = 0.0_8
    END DO
    qcx_ad = qt_ad + qcn_ad
    cfx_ad = cfn_ad
    teo_ad = ten_ad
    qvx_ad = qt_ad
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qa_ad = qa_ad + qax_ad/af
      af_ad = af_ad - qa*qax_ad/af**2
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qsx_ad = qsx_ad + 1.e-4*qvx_ad
      qvx_ad = 0.0_8
    END IF
    temp_ad = tmparr*qvx_ad
    qv_ad = qv_ad + temp_ad
    qsx_ad = qsx_ad - af*temp_ad
    af_ad = af_ad - qsx*temp_ad
    tmparr_ad = qc*qcx_ad + cf*cfx_ad + (qv-qsx*af)*qvx_ad
    qc_ad = qc_ad + tmparr*qcx_ad
    cf_ad = tmparr*cfx_ad
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) af_ad = af_ad + tmparr_ad/(1.-af)**2
    dqsx_ad = 0.0_8
    CALL DQSATSCAPERT_ADM(dqsx, dqsx_ad, qsx, qsx_ad, teo, teo_ad, pl)
    te_ad = te_ad + teo_ad
    qal_ad = qal_ad + qa_ad
    qai_ad = qai_ad + qa_ad
    qcl_ad = qcl_ad + qc_ad
    qci_ad = qci_ad + qc_ad
  END SUBROUTINE HYSTPDF_ADM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE HYSTPDF(dt, alpha, pdfshape, pl, qv, qcl, qal, qci, qai, te&
&   , cf, af)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: dt, alpha, pl
    INTEGER, INTENT(IN) :: pdfshape
    REAL*8, INTENT(INOUT) :: te, qv, qcl, qci, cf, qal, qai, af
! internal arrays
    REAL*8 :: qco, qvo, cfo, qao, tau
    REAL*8 :: qt, qmx, qmn, dq, qvtop, sigmaqt1, sigmaqt2
    REAL*8 :: teo, qsx, dqsx, qs, dqs
    REAL*8 :: tep, qsp, cfp, qvp, qcp
    REAL*8 :: ten, qsn, cfn, qvn, qcn
    REAL*8 :: qcx, qvx, cfx, qax, qc, qa, fqi, fqi_a
    REAL*8 :: dqai, dqal, dqci, dqcl
    REAL*8 :: tmparr
    REAL*8 :: alhx
! internal scalars
    INTEGER :: n
    INTRINSIC MAX
    qc = qcl + qci
    qa = qal + qai
    IF (qa .GT. 0.0) THEN
      fqi_a = qai/qa
    ELSE
      fqi_a = 0.0
    END IF
    teo = te
    CALL DQSATSCAPERT(dqsx, qsx, teo, pl)
    IF (af .LT. 1.0) THEN
      tmparr = 1./(1.-af)
    ELSE
      tmparr = 0.0
    END IF
    cfx = cf*tmparr
    qcx = qc*tmparr
    qvx = (qv-qsx*af)*tmparr
    IF (af .GE. 1.0) qvx = qsx*1.e-4
    IF (af .GT. 0.) THEN
      qax = qa/af
    ELSE
      qax = 0.
    END IF
    qt = qcx + qvx
    tep = teo
    qsn = qsx
    ten = teo
    cfn = cfx
    qvn = qvx
    qcn = qcx
    dqs = dqsx
    DO n=1,4
      qsp = qsn
      qvp = qvn
      qcp = qcn
      cfp = cfn
      CALL DQSATSCAPERT(dqs, qsn, ten, pl)
      tep = ten
      fqi = ICE_FRACTION(tep)
      sigmaqt1 = alpha*qsn
      sigmaqt2 = alpha*qsn
      IF (pdfflag .EQ. 2) THEN
! for triangular, symmetric: sigmaqt1 = sigmaqt2 = alpha*qsn (alpha is half width)
! for triangular, skewed r : sigmaqt1 < sigmaqt2
! try: skewed right below 500 mb
!!!       if(pl.lt.500.) then
        sigmaqt1 = alpha*qsn
        sigmaqt2 = alpha*qsn
!!!       else
!!!       sigmaqt1  = 2*ALPHA*QSn*0.4
!!!       sigmaqt2  = 2*ALPHA*QSn*0.6
!!!       endif
      END IF
      CALL PDFFRAC(pdfshape, qt, sigmaqt1, sigmaqt2, qsn, cfn)
      CALL PDFCONDENSATE(pdfshape, qt, sigmaqt1, sigmaqt2, qsn, qcn)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! These lines represent adjustments
! to anvil condensate due to the 
! assumption of a stationary TOTAL 
! water PDF subject to a varying 
! QSAT value during the iteration
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
      IF (af .GT. 0.) THEN
! + QSx - QS 
        qao = qax
      ELSE
        qao = 0.
      END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
      alhx = (1.0-fqi)*mapl8_alhl + fqi*mapl8_alhs
      IF (pdfflag .EQ. 1) THEN
        qcn = qcp + (qcn-qcp)/(1.-(cfn*(alpha-1.)-qcn/qsn)*dqs*alhx/&
&         mapl8_cp)
      ELSE IF (pdfflag .EQ. 2) THEN
! This next line needs correcting - need proper d(del qc)/dT derivative for triangular
! for now, just use relaxation of 1/2.
        IF (n .NE. 4) qcn = qcp + (qcn-qcp)*0.5
      END IF
      qvn = qvp - (qcn-qcp)
      ten = tep + (1.0-fqi)*(mapl8_alhl/mapl8_cp)*((qcn-qcp)*(1.-af)+(&
&       qao-qax)*af) + fqi*(mapl8_alhs/mapl8_cp)*((qcn-qcp)*(1.-af)+(qao&
&       -qax)*af)
    END DO
! qsat iteration
    cfo = cfn
    cf = cfn
    qco = qcn
    qvo = qvn
    teo = ten
! Update prognostic variables.  Deal with special case of AF=1
! Temporary variables QCo, QAo become updated grid means.
    IF (af .LT. 1.0) THEN
      cf = cfo*(1.-af)
      qco = qco*(1.-af)
      qao = qao*af
    ELSE
! Special case AF=1, i.e., box filled with anvil. 
!   - Note: no guarantee QV_box > QS_box
! Remove any other cloud
      cf = 0.
! Add any LS condensate to anvil type
      qao = qa + qc
! Remove same from LS   
      qco = 0.
! Total water
      qt = qao + qv
      IF (qt - qsx .LT. 0.) THEN
        qao = 0.
      ELSE
        qao = qt - qsx
      END IF
    END IF
! Now take {\em New} condensate and partition into ice and liquid
! taking care to keep both >=0 separately. New condensate can be
! less than old, so $\Delta$ can be < 0.
    qcx = qco - qc
    dqcl = (1.0-fqi)*qcx
    dqci = fqi*qcx
    IF (qcl + dqcl .LT. 0.) THEN
      dqci = dqci + (qcl+dqcl)
!== dQCl - (QCl+dQCl)
      dqcl = -qcl
    END IF
    IF (qci + dqci .LT. 0.) THEN
      dqcl = dqcl + (qci+dqci)
!== dQCi - (QCi+dQCi)
      dqci = -qci
    END IF
    qax = qao - qa
! (1.0-fQi)*QAx
    dqal = qax
!  fQi  * QAx
    dqai = 0.
    IF (qal + dqal .LT. 0.) THEN
      dqai = dqai + (qal+dqal)
      dqal = -qal
    END IF
    IF (qai + dqai .LT. 0.) THEN
      dqal = dqal + (qai+dqai)
      dqai = -qai
    END IF
! Clean-up cloud if fractions are too small
    IF (af .LT. 1.e-5) THEN
      dqai = -qai
      dqal = -qal
    END IF
    IF (cf .LT. 1.e-5) THEN
      dqci = -qci
      dqcl = -qcl
    END IF
    qai = qai + dqai
    qal = qal + dqal
    qci = qci + dqci
    qcl = qcl + dqcl
    qv = qv - (dqai+dqci+dqal+dqcl)
!!TE  = TE + (MAPL8_ALHS/MAPL8_CP)*(dQAi+dQCi) + (MAPL8_ALHL/MAPL8_CP)*(dQAl+dQCl)
    te = te + (mapl8_alhl*(dqai+dqci+dqal+dqcl)+mapl8_alhf*(dqai+dqci))/&
&     mapl8_cp
! We need to take care of situations where QS moves past QA
! during QSAT iteration. This should be only when QA/AF is small
! to begin with. Effect is to make QAo negative. So, we 
! "evaporate" offending QAs
!
! We get rid of anvil fraction also, although strictly
! speaking, PDF-wise, we should not do this.
    IF (qao .LE. 0.) THEN
      qv = qv + qai + qal
      te = te - mapl8_alhs/mapl8_cp*qai - mapl8_alhl/mapl8_cp*qal
      qai = 0.
      qal = 0.
      af = 0.
    END IF
  END SUBROUTINE HYSTPDF
!  Differentiation of pdffrac in reverse (adjoint) mode (with options r8 split(GEOS_MoistGridComp.PRE_PROGNO_CLOUD)):
!   gradient     of useful results: qtmean sigmaqt1 sigmaqt2 qstar
!                clfrac
!   with respect to varying inputs: qtmean sigmaqt1 sigmaqt2 qstar
!                clfrac
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE PDFFRAC_ADM(flag, qtmean, qtmean_ad, sigmaqt1, sigmaqt1_ad&
&   , sigmaqt2, sigmaqt2_ad, qstar, qstar_ad, clfrac, clfrac_ad)
    IMPLICIT NONE
! flag to indicate shape of pdf
    INTEGER :: flag
! 1 for tophat, 2 for triangular, 3 for Gaussian
! Grid box value of q total
    REAL*8 :: qtmean
    REAL*8 :: qtmean_ad
! width of distribution (sigma)
    REAL*8 :: sigmaqt1
    REAL*8 :: sigmaqt1_ad
! width of distribution (sigma)
    REAL*8 :: sigmaqt2
    REAL*8 :: sigmaqt2_ad
! saturation q at grid box avg T
    REAL*8 :: qstar
    REAL*8 :: qstar_ad
! cloud fraction (area under pdf from qs)
    REAL*8 :: clfrac
    REAL*8 :: clfrac_ad
    REAL*8 :: qtmode, qtmin, qtmax
    REAL*8 :: qtmode_ad, qtmin_ad, qtmax_ad
    INTRINSIC MIN
    INTEGER :: branch
    REAL*8 :: temp0
    REAL*8 :: min1
    REAL*8 :: min1_ad
    REAL*8 :: temp_ad5
    REAL*8 :: temp_ad4
    REAL*8 :: temp_ad3
    REAL*8 :: temp_ad2
    REAL*8 :: temp_ad1
    REAL*8 :: temp_ad0
    REAL*8 :: temp_ad
    REAL*8 :: temp
    IF (flag .EQ. 1) THEN
      IF (qtmean + sigmaqt1 .GE. qstar) THEN
        IF (sigmaqt1 .GT. 0.) THEN
          IF (qtmean + sigmaqt1 - qstar .GT. 2.*sigmaqt1) THEN
            min1 = 2.*sigmaqt1
            CALL PUSHCONTROL1B(0)
          ELSE
            min1 = qtmean + sigmaqt1 - qstar
            CALL PUSHCONTROL1B(1)
          END IF
          temp_ad = clfrac_ad/(2.*sigmaqt1)
          min1_ad = temp_ad
          sigmaqt1_ad = sigmaqt1_ad - min1*temp_ad/sigmaqt1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            sigmaqt1_ad = sigmaqt1_ad + 2.*min1_ad
          ELSE
            qtmean_ad = qtmean_ad + min1_ad
            sigmaqt1_ad = sigmaqt1_ad + min1_ad
            qstar_ad = qstar_ad - min1_ad
          END IF
        END IF
      END IF
      clfrac_ad = 0.0_8
    ELSE IF (flag .EQ. 2) THEN
      qtmode = qtmean + (sigmaqt1-sigmaqt2)/3.
      IF (qtmode - sigmaqt1 .GT. 0.) THEN
        CALL PUSHCONTROL1B(0)
        qtmin = 0.
      ELSE
        qtmin = qtmode - sigmaqt1
        CALL PUSHCONTROL1B(1)
      END IF
      qtmax = qtmode + sigmaqt2
      IF (qtmax .LT. qstar) THEN
        clfrac_ad = 0.0_8
        qtmax_ad = 0.0_8
        qtmin_ad = 0.0_8
        qtmode_ad = 0.0_8
      ELSE IF (qtmode .LE. qstar .AND. qstar .LT. qtmax) THEN
        temp = (qtmax-qtmin)*(qtmax-qtmode)
        temp_ad0 = clfrac_ad/temp
        temp_ad1 = 2*(qtmax-qstar)*temp_ad0
        temp_ad2 = -((qtmax-qstar)**2*temp_ad0/temp)
        qtmax_ad = (2*qtmax-qtmin-qtmode)*temp_ad2 + temp_ad1
        qstar_ad = qstar_ad - temp_ad1
        qtmin_ad = -((qtmax-qtmode)*temp_ad2)
        qtmode_ad = -((qtmax-qtmin)*temp_ad2)
        clfrac_ad = 0.0_8
      ELSE IF (qtmin .LE. qstar .AND. qstar .LT. qtmode) THEN
        temp0 = (qtmax-qtmin)*(qtmode-qtmin)
        temp_ad3 = -(clfrac_ad/temp0)
        temp_ad4 = 2*(qstar-qtmin)*temp_ad3
        temp_ad5 = -((qstar-qtmin)**2*temp_ad3/temp0)
        qstar_ad = qstar_ad + temp_ad4
        qtmin_ad = (2*qtmin-qtmax-qtmode)*temp_ad5 - temp_ad4
        qtmax_ad = (qtmode-qtmin)*temp_ad5
        qtmode_ad = (qtmax-qtmin)*temp_ad5
        clfrac_ad = 0.0_8
      ELSE
        IF (qstar .LE. qtmin) clfrac_ad = 0.0_8
        qtmax_ad = 0.0_8
        qtmin_ad = 0.0_8
        qtmode_ad = 0.0_8
      END IF
      qtmode_ad = qtmode_ad + qtmax_ad
      sigmaqt2_ad = sigmaqt2_ad + qtmax_ad
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        qtmode_ad = qtmode_ad + qtmin_ad
        sigmaqt1_ad = sigmaqt1_ad - qtmin_ad
      END IF
      qtmean_ad = qtmean_ad + qtmode_ad
      sigmaqt1_ad = sigmaqt1_ad + qtmode_ad/3.
      sigmaqt2_ad = sigmaqt2_ad - qtmode_ad/3.
    END IF
  END SUBROUTINE PDFFRAC_ADM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE PDFFRAC(flag, qtmean, sigmaqt1, sigmaqt2, qstar, clfrac)
    IMPLICIT NONE
! flag to indicate shape of pdf
    INTEGER :: flag
! 1 for tophat, 2 for triangular, 3 for Gaussian
! Grid box value of q total
    REAL*8 :: qtmean
! width of distribution (sigma)
    REAL*8 :: sigmaqt1
! width of distribution (sigma)
    REAL*8 :: sigmaqt2
! saturation q at grid box avg T
    REAL*8 :: qstar
! cloud fraction (area under pdf from qs)
    REAL*8 :: clfrac
    REAL*8 :: qtmode, qtmin, qtmax
    INTRINSIC MIN
    REAL*8 :: min1
    IF (flag .EQ. 1) THEN
      IF (qtmean + sigmaqt1 .LT. qstar) THEN
        clfrac = 0.
      ELSE IF (sigmaqt1 .GT. 0.) THEN
        IF (qtmean + sigmaqt1 - qstar .GT. 2.*sigmaqt1) THEN
          min1 = 2.*sigmaqt1
        ELSE
          min1 = qtmean + sigmaqt1 - qstar
        END IF
        clfrac = min1/(2.*sigmaqt1)
      ELSE
        clfrac = 1.
      END IF
    ELSE IF (flag .EQ. 2) THEN
      qtmode = qtmean + (sigmaqt1-sigmaqt2)/3.
      IF (qtmode - sigmaqt1 .GT. 0.) THEN
        qtmin = 0.
      ELSE
        qtmin = qtmode - sigmaqt1
      END IF
      qtmax = qtmode + sigmaqt2
      IF (qtmax .LT. qstar) THEN
        clfrac = 0.
      ELSE IF (qtmode .LE. qstar .AND. qstar .LT. qtmax) THEN
        clfrac = (qtmax-qstar)*(qtmax-qstar)/((qtmax-qtmin)*(qtmax-&
&         qtmode))
      ELSE IF (qtmin .LE. qstar .AND. qstar .LT. qtmode) THEN
        clfrac = 1. - (qstar-qtmin)*(qstar-qtmin)/((qtmax-qtmin)*(qtmode&
&         -qtmin))
      ELSE IF (qstar .LE. qtmin) THEN
        clfrac = 1.
      END IF
    END IF
    RETURN
  END SUBROUTINE PDFFRAC
!  Differentiation of pdfcondensate in reverse (adjoint) mode (with options r8 split(GEOS_MoistGridComp.PRE_PROGNO_CLOUD)):
!   gradient     of useful results: qtmean4 qstar4 condensate4
!   with respect to varying inputs: qtmean4 qstar4 sigmaqt14 sigmaqt24
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE PDFCONDENSATE_ADM(flag, qtmean4, qtmean4_ad, sigmaqt14, &
&   sigmaqt14_ad, sigmaqt24, sigmaqt24_ad, qstar4, qstar4_ad, &
&   condensate4, condensate4_ad)
    IMPLICIT NONE
! flag to indicate shape of pdf
    INTEGER :: flag
! 1 for tophat, 2 for triangular
! Grid box value of q total
    REAL*8 :: qtmean4
    REAL*8 :: qtmean4_ad
! width of distribution (to left)
    REAL*8 :: sigmaqt14
    REAL*8 :: sigmaqt14_ad
! width of distribution (to right)
    REAL*8 :: sigmaqt24
    REAL*8 :: sigmaqt24_ad
! saturation q at grid box avg T
    REAL*8 :: qstar4
    REAL*8 :: qstar4_ad
! condensate (area under (q*-qt)*pdf from qs)
    REAL*8 :: condensate4
    REAL*8 :: condensate4_ad
    REAL*8 :: qtmode, qtmin, qtmax, consta, constb, cloudf
    REAL*8 :: qtmode_ad, qtmin_ad, qtmax_ad, consta_ad, constb_ad, &
&   cloudf_ad
    REAL*8 :: term1, term2, term3
    REAL*8 :: term1_ad, term2_ad, term3_ad
    REAL*8 :: qtmean, sigmaqt1, sigmaqt2, qstar, condensate
    REAL*8 :: qtmean_ad, sigmaqt1_ad, sigmaqt2_ad, qstar_ad, &
&   condensate_ad
    INTRINSIC MIN
    INTEGER :: branch
    REAL*8 :: temp2
    REAL*8 :: temp1
    REAL*8 :: temp0
    REAL*8 :: min1
    REAL*8 :: min1_ad
    REAL*8 :: temp_ad9
    REAL*8 :: temp_ad8
    REAL*8 :: temp_ad7
    REAL*8 :: temp_ad6
    REAL*8 :: temp_ad5
    REAL*8 :: temp_ad4
    REAL*8 :: temp_ad3
    REAL*8 :: temp_ad2
    REAL*8 :: temp_ad1
    REAL*8 :: temp_ad0
    REAL*8 :: temp_ad
    REAL*8 :: temp
    qtmean = qtmean4
    sigmaqt1 = sigmaqt14
    sigmaqt2 = sigmaqt24
    qstar = qstar4
    IF (flag .EQ. 1) THEN
      IF (qtmean + sigmaqt1 .LT. qstar) THEN
        CALL PUSHCONTROL4B(0)
      ELSE IF (qstar .GT. qtmean - sigmaqt1) THEN
        IF (sigmaqt1 .GT. 0.0) THEN
          IF (qtmean + sigmaqt1 - qstar .GT. 2.0*sigmaqt1) THEN
            min1 = 2.0*sigmaqt1
            CALL PUSHCONTROL1B(0)
          ELSE
            min1 = qtmean + sigmaqt1 - qstar
            CALL PUSHCONTROL1B(1)
          END IF
          CALL PUSHCONTROL4B(1)
        ELSE
          CALL PUSHCONTROL4B(2)
        END IF
      ELSE
        CALL PUSHCONTROL4B(3)
      END IF
    ELSE IF (flag .EQ. 2) THEN
      qtmode = qtmean + (sigmaqt1-sigmaqt2)/3.0
      IF (qtmode - sigmaqt1 .GT. 0.0) THEN
        qtmin = 0.0
        CALL PUSHCONTROL1B(0)
      ELSE
        qtmin = qtmode - sigmaqt1
        CALL PUSHCONTROL1B(1)
      END IF
      qtmax = qtmode + sigmaqt2
      IF (qtmax .LT. qstar) THEN
        CALL PUSHCONTROL4B(4)
      ELSE IF (qtmode .LE. qstar .AND. qstar .LT. qtmax) THEN
        constb = 2.0/((qtmax-qtmin)*(qtmax-qtmode))
        cloudf = (qtmax-qstar)*(qtmax-qstar)/((qtmax-qtmin)*(qtmax-&
&         qtmode))
        term1 = qstar*qstar*qstar/3.0
        term2 = qtmax*qstar*qstar/2.0
        term3 = qtmax*qtmax*qtmax/6.0
        CALL PUSHCONTROL4B(5)
      ELSE IF (qtmin .LE. qstar .AND. qstar .LT. qtmode) THEN
        consta = 2.0/((qtmax-qtmin)*(qtmode-qtmin))
        cloudf = 1.0 - (qstar-qtmin)*(qstar-qtmin)/((qtmax-qtmin)*(&
&         qtmode-qtmin))
        term1 = qstar*qstar*qstar/3.0
        term2 = qtmin*qstar*qstar/2.0
        term3 = qtmin*qtmin*qtmin/6.0
        CALL PUSHCONTROL4B(6)
      ELSE IF (qstar .LE. qtmin) THEN
        CALL PUSHCONTROL4B(7)
      ELSE
        CALL PUSHCONTROL4B(8)
      END IF
    ELSE
      CALL PUSHCONTROL4B(9)
    END IF
    condensate_ad = condensate4_ad
    CALL POPCONTROL4B(branch)
    IF (branch .LT. 5) THEN
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          qtmean_ad = 0.0_8
          sigmaqt1_ad = 0.0_8
          qstar_ad = 0.0_8
        ELSE
          temp_ad = condensate_ad/(4.0*sigmaqt1)
          min1_ad = 2*min1*temp_ad
          sigmaqt1_ad = -(min1**2*temp_ad/sigmaqt1)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            sigmaqt1_ad = sigmaqt1_ad + 2.0*min1_ad
            qtmean_ad = 0.0_8
            qstar_ad = 0.0_8
          ELSE
            qtmean_ad = min1_ad
            sigmaqt1_ad = sigmaqt1_ad + min1_ad
            qstar_ad = -min1_ad
          END IF
        END IF
      ELSE IF (branch .EQ. 2) THEN
        qtmean_ad = condensate_ad
        qstar_ad = -condensate_ad
        sigmaqt1_ad = 0.0_8
      ELSE IF (branch .EQ. 3) THEN
        qtmean_ad = condensate_ad
        qstar_ad = -condensate_ad
        sigmaqt1_ad = 0.0_8
      ELSE
        qtmean_ad = 0.0_8
        qtmax_ad = 0.0_8
        qstar_ad = 0.0_8
        qtmin_ad = 0.0_8
        qtmode_ad = 0.0_8
        GOTO 100
      END IF
      sigmaqt2_ad = 0.0_8
      GOTO 110
    ELSE IF (branch .LT. 7) THEN
      IF (branch .EQ. 5) THEN
        cloudf_ad = -(qstar*condensate_ad)
        temp0 = (qtmax-qtmin)*(qtmax-qtmode)
        temp_ad4 = cloudf_ad/temp0
        temp_ad1 = 2*(qtmax-qstar)*temp_ad4
        temp_ad0 = constb*condensate_ad
        constb_ad = (term1-term2+term3)*condensate_ad
        term1_ad = temp_ad0
        term2_ad = -temp_ad0
        term3_ad = temp_ad0
        qstar_ad = qtmax*2*qstar*term2_ad/2.0 - temp_ad1 + 3*qstar**2*&
&         term1_ad/3.0 - cloudf*condensate_ad
        temp_ad3 = -((qtmax-qstar)**2*temp_ad4/temp0)
        temp = (qtmax-qtmin)*(qtmax-qtmode)
        temp_ad2 = -(2.0*constb_ad/temp**2)
        qtmax_ad = qstar**2*term2_ad/2.0 + (2*qtmax-qtmin-qtmode)*&
&         temp_ad2 + (2*qtmax-qtmin-qtmode)*temp_ad3 + temp_ad1 + 3*&
&         qtmax**2*term3_ad/6.0
        qtmin_ad = -((qtmax-qtmode)*temp_ad2) - (qtmax-qtmode)*temp_ad3
        qtmode_ad = -((qtmax-qtmin)*temp_ad2) - (qtmax-qtmin)*temp_ad3
        qtmean_ad = 0.0_8
      ELSE
        cloudf_ad = -(qstar*condensate_ad)
        temp2 = (qtmax-qtmin)*(qtmode-qtmin)
        temp_ad9 = -(cloudf_ad/temp2)
        temp_ad6 = 2*(qstar-qtmin)*temp_ad9
        temp_ad5 = -(consta*condensate_ad)
        qtmean_ad = condensate_ad
        consta_ad = -((term1-term2+term3)*condensate_ad)
        term1_ad = temp_ad5
        term2_ad = -temp_ad5
        term3_ad = temp_ad5
        qstar_ad = qtmin*2*qstar*term2_ad/2.0 + temp_ad6 + 3*qstar**2*&
&         term1_ad/3.0 - cloudf*condensate_ad
        temp_ad8 = -((qstar-qtmin)**2*temp_ad9/temp2)
        temp1 = (qtmax-qtmin)*(qtmode-qtmin)
        temp_ad7 = -(2.0*consta_ad/temp1**2)
        qtmin_ad = qstar**2*term2_ad/2.0 + (2*qtmin-qtmax-qtmode)*&
&         temp_ad7 + (2*qtmin-qtmax-qtmode)*temp_ad8 - temp_ad6 + 3*&
&         qtmin**2*term3_ad/6.0
        qtmax_ad = (qtmode-qtmin)*temp_ad7 + (qtmode-qtmin)*temp_ad8
        qtmode_ad = (qtmax-qtmin)*temp_ad7 + (qtmax-qtmin)*temp_ad8
      END IF
    ELSE
      IF (branch .EQ. 7) THEN
        qtmean_ad = condensate_ad
        qstar_ad = -condensate_ad
      ELSE IF (branch .EQ. 8) THEN
        qtmean_ad = 0.0_8
        qstar_ad = 0.0_8
      ELSE
        qtmean_ad = 0.0_8
        sigmaqt1_ad = 0.0_8
        sigmaqt2_ad = 0.0_8
        qstar_ad = 0.0_8
        GOTO 110
      END IF
      qtmax_ad = 0.0_8
      qtmin_ad = 0.0_8
      qtmode_ad = 0.0_8
    END IF
 100 qtmode_ad = qtmode_ad + qtmax_ad
    sigmaqt2_ad = qtmax_ad
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      sigmaqt1_ad = 0.0_8
    ELSE
      qtmode_ad = qtmode_ad + qtmin_ad
      sigmaqt1_ad = -qtmin_ad
    END IF
    qtmean_ad = qtmean_ad + qtmode_ad
    sigmaqt1_ad = sigmaqt1_ad + qtmode_ad/3.0
    sigmaqt2_ad = sigmaqt2_ad - qtmode_ad/3.0
 110 qstar4_ad = qstar4_ad + qstar_ad
    sigmaqt24_ad = sigmaqt2_ad
    sigmaqt14_ad = sigmaqt1_ad
    qtmean4_ad = qtmean4_ad + qtmean_ad
  END SUBROUTINE PDFCONDENSATE_ADM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE PDFCONDENSATE(flag, qtmean4, sigmaqt14, sigmaqt24, qstar4, &
&   condensate4)
    IMPLICIT NONE
! flag to indicate shape of pdf
    INTEGER :: flag
! 1 for tophat, 2 for triangular
! Grid box value of q total
    REAL*8 :: qtmean4
! width of distribution (to left)
    REAL*8 :: sigmaqt14
! width of distribution (to right)
    REAL*8 :: sigmaqt24
! saturation q at grid box avg T
    REAL*8 :: qstar4
! condensate (area under (q*-qt)*pdf from qs)
    REAL*8 :: condensate4
    REAL*8 :: qtmode, qtmin, qtmax, consta, constb, cloudf
    REAL*8 :: term1, term2, term3
    REAL*8 :: qtmean, sigmaqt1, sigmaqt2, qstar, condensate
    INTRINSIC MIN
    REAL*8 :: min1
    qtmean = qtmean4
    sigmaqt1 = sigmaqt14
    sigmaqt2 = sigmaqt24
    qstar = qstar4
    IF (flag .EQ. 1) THEN
      IF (qtmean + sigmaqt1 .LT. qstar) THEN
        condensate = 0.0
      ELSE IF (qstar .GT. qtmean - sigmaqt1) THEN
        IF (sigmaqt1 .GT. 0.0) THEN
          IF (qtmean + sigmaqt1 - qstar .GT. 2.0*sigmaqt1) THEN
            min1 = 2.0*sigmaqt1
          ELSE
            min1 = qtmean + sigmaqt1 - qstar
          END IF
          condensate = min1**2/(4.0*sigmaqt1)
        ELSE
          condensate = qtmean - qstar
        END IF
      ELSE
        condensate = qtmean - qstar
      END IF
    ELSE IF (flag .EQ. 2) THEN
      qtmode = qtmean + (sigmaqt1-sigmaqt2)/3.0
      IF (qtmode - sigmaqt1 .GT. 0.0) THEN
        qtmin = 0.0
      ELSE
        qtmin = qtmode - sigmaqt1
      END IF
      qtmax = qtmode + sigmaqt2
      IF (qtmax .LT. qstar) THEN
        condensate = 0.0
      ELSE IF (qtmode .LE. qstar .AND. qstar .LT. qtmax) THEN
        constb = 2.0/((qtmax-qtmin)*(qtmax-qtmode))
        cloudf = (qtmax-qstar)*(qtmax-qstar)/((qtmax-qtmin)*(qtmax-&
&         qtmode))
        term1 = qstar*qstar*qstar/3.0
        term2 = qtmax*qstar*qstar/2.0
        term3 = qtmax*qtmax*qtmax/6.0
        condensate = constb*(term1-term2+term3) - qstar*cloudf
      ELSE IF (qtmin .LE. qstar .AND. qstar .LT. qtmode) THEN
        consta = 2.0/((qtmax-qtmin)*(qtmode-qtmin))
        cloudf = 1.0 - (qstar-qtmin)*(qstar-qtmin)/((qtmax-qtmin)*(&
&         qtmode-qtmin))
        term1 = qstar*qstar*qstar/3.0
        term2 = qtmin*qstar*qstar/2.0
        term3 = qtmin*qtmin*qtmin/6.0
        condensate = qtmean - consta*(term1-term2+term3) - qstar*cloudf
      ELSE IF (qstar .LE. qtmin) THEN
        condensate = qtmean - qstar
      END IF
    END IF
    condensate4 = condensate
    RETURN
  END SUBROUTINE PDFCONDENSATE
!  Differentiation of cnvsrc in reverse (adjoint) mode (with options r8 split(GEOS_MoistGridComp.PRE_PROGNO_CLOUD)):
!   gradient     of useful results: af qs qv qla qia dcf dmf te
!   with respect to varying inputs: af qs qv qla qia dcf dmf te
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) & 
!#endif
  SUBROUTINE CNVSRC_ADM(dt, iceparam, sclmfdfr, mass, imass, pl, te, &
&   te_ad, qv, qv_ad, dcf, dcf_ad, dmf, dmf_ad, qla, qla_ad, qia, qia_ad&
&   , cf, af, af_ad, qs, qs_ad)
    IMPLICIT NONE
!INPUTS:
!
!       ICEPARAM: 0-1  controls how strongly new conv condensate is partitioned in ice-liquid
!                 1 means partitioning follows ice_fraction(TE). 0 means all new condensate is
!                 liquid 
!
!       SCLMFDFR: Scales detraining mass flux to a cloud fraction source - kludge. Thinly justified
!                 by fuzziness of cloud boundaries and existence of PDF of condensates (for choices
!                 0.-1.0) or by subgrid layering (for choices >1.0) 
    REAL*8, INTENT(IN) :: dt, iceparam, sclmfdfr
    REAL*8, INTENT(IN) :: mass, imass, qs
    REAL*8 :: qs_ad
    REAL*8, INTENT(IN) :: dmf, pl
    REAL*8 :: dmf_ad
    REAL*8, INTENT(IN) :: dcf, cf
    REAL*8 :: dcf_ad
    REAL*8, INTENT(INOUT) :: te
    REAL*8 :: te_ad
    REAL*8, INTENT(INOUT) :: af, qv
    REAL*8 :: af_ad, qv_ad
    REAL*8, INTENT(INOUT) :: qla, qia
    REAL*8 :: qla_ad, qia_ad
    REAL*8 :: tend, qvx, qca, fqi
    REAL*8 :: tend_ad, qvx_ad, fqi_ad
    INTEGER :: strategy
    REAL*8 :: minrhx
    INTRINSIC MIN
    REAL*8 :: result1
    REAL*8 :: result1_ad
    INTEGER :: branch
    REAL*8 :: temp_ad2
    REAL*8 :: temp_ad1
    REAL*8 :: temp_ad0
    REAL*8 :: temp_ad
    strategy = 1
!Minimum allowed env RH
    minrhx = 0.001
!Addition of condensate from RAS
    result1 = ICE_FRACTION(te)
    fqi = 0.0 + iceparam*result1
! dont forget that conv cond has never frozen !!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Tiedtke-style anvil fraction !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    tend = dmf*imass*sclmfdfr
    CALL PUSHREAL8(af)
    af = af + tend*dt
    IF (af .GT. 0.99) THEN
      af = 0.99
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      af = af
    END IF
! where ( (AF+CF) > 1.00 )
!    AF=1.00-CF
! endwhere
!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Check for funny (tiny, negative)
! external QV s, resulting from assumed
! QV=QSAT within anvil.
!
! Two strategies to fix 
!   1) Simply constrain AF assume condensate
!      just gets "packed" in
!   2) Evaporate QCA to bring up QVx leave AF alone
!      Should include QSAT iteration, but ...        
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!   QS  = QSAT(         &
!               TE    , &
!               PL      )
    IF (af .LT. 1.0) THEN
      qvx = (qv-qs*af)/(1.-af)
      CALL PUSHCONTROL1B(0)
    ELSE
      qvx = qs
      CALL PUSHCONTROL1B(1)
    END IF
    IF (strategy .EQ. 1) THEN
      IF (qvx - minrhx*qs .LT. 0.0 .AND. af .GT. 0.) THEN
        CALL PUSHREAL8(af)
        af = (qv-minrhx*qs)/(qs*(1.0-minrhx))
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (af .LT. 0.) THEN
        qla_ad = qv_ad - mapl8_alhl*te_ad/mapl8_cp
        qia_ad = qv_ad - mapl8_alhs*te_ad/mapl8_cp
        af_ad = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(af)
        temp_ad1 = af_ad/((1.0-minrhx)*qs)
        qv_ad = qv_ad + temp_ad1
        qs_ad = qs_ad + (-((qv-minrhx*qs)/qs)-minrhx)*temp_ad1
        af_ad = 0.0_8
      END IF
      qvx_ad = 0.0_8
    ELSE IF (strategy .EQ. 2) THEN
      IF (qvx - minrhx*qs .LT. 0.0 .AND. af .GT. 0.) THEN
        temp_ad2 = -(mapl8_alhl*(1.-af)*te_ad/mapl8_cp)
        af_ad = af_ad + (minrhx*qs-qvx)*mapl8_alhl*te_ad/mapl8_cp - (&
&         minrhx*qs-qvx)*qv_ad
        qs_ad = qs_ad + (1.-af)*minrhx*qv_ad + minrhx*temp_ad2
        qvx_ad = -((1.-af)*qv_ad) - temp_ad2
      ELSE
        qvx_ad = 0.0_8
      END IF
    ELSE
      qvx_ad = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      temp_ad0 = qvx_ad/(1.-af)
      qv_ad = qv_ad + temp_ad0
      qs_ad = qs_ad - af*temp_ad0
      af_ad = af_ad + ((qv-qs*af)/(1.-af)-qs)*temp_ad0
    ELSE
      qs_ad = qs_ad + qvx_ad
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) af_ad = 0.0_8
    CALL POPREAL8(af)
    tend_ad = dt*af_ad
    dmf_ad = dmf_ad + imass*sclmfdfr*tend_ad
    tend = dcf*imass
    temp_ad = (mapl8_alhs-mapl8_alhl)*dt*te_ad/mapl8_cp
    fqi_ad = dt*tend*qia_ad - tend*dt*qla_ad + tend*temp_ad
    tend_ad = dt*fqi*qia_ad + dt*(1.0-fqi)*qla_ad + fqi*temp_ad
    result1_ad = iceparam*fqi_ad
    CALL ICE_FRACTION_ADM(te, te_ad, result1_ad)
    dcf_ad = dcf_ad + imass*tend_ad
  END SUBROUTINE CNVSRC_ADM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) & 
!#endif
  SUBROUTINE CNVSRC(dt, iceparam, sclmfdfr, mass, imass, pl, te, qv, dcf&
&   , dmf, qla, qia, cf, af, qs)
    IMPLICIT NONE
!INPUTS:
!
!       ICEPARAM: 0-1  controls how strongly new conv condensate is partitioned in ice-liquid
!                 1 means partitioning follows ice_fraction(TE). 0 means all new condensate is
!                 liquid 
!
!       SCLMFDFR: Scales detraining mass flux to a cloud fraction source - kludge. Thinly justified
!                 by fuzziness of cloud boundaries and existence of PDF of condensates (for choices
!                 0.-1.0) or by subgrid layering (for choices >1.0) 
    REAL*8, INTENT(IN) :: dt, iceparam, sclmfdfr
    REAL*8, INTENT(IN) :: mass, imass, qs
    REAL*8, INTENT(IN) :: dmf, pl
    REAL*8, INTENT(IN) :: dcf, cf
    REAL*8, INTENT(INOUT) :: te
    REAL*8, INTENT(INOUT) :: af, qv
    REAL*8, INTENT(INOUT) :: qla, qia
    REAL*8 :: tend, qvx, qca, fqi
    INTEGER :: strategy
    REAL*8 :: minrhx
    INTRINSIC MIN
    REAL*8 :: result1
    strategy = 1
!Minimum allowed env RH
    minrhx = 0.001
!Addition of condensate from RAS
    tend = dcf*imass
    result1 = ICE_FRACTION(te)
    fqi = 0.0 + iceparam*result1
    qla = qla + (1.0-fqi)*tend*dt
    qia = qia + fqi*tend*dt
! dont forget that conv cond has never frozen !!!!
    te = te + (mapl8_alhs-mapl8_alhl)*fqi*tend*dt/mapl8_cp
    qca = qla + qia
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Tiedtke-style anvil fraction !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    tend = dmf*imass*sclmfdfr
    af = af + tend*dt
    IF (af .GT. 0.99) THEN
      af = 0.99
    ELSE
      af = af
    END IF
! where ( (AF+CF) > 1.00 )
!    AF=1.00-CF
! endwhere
!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Check for funny (tiny, negative)
! external QV s, resulting from assumed
! QV=QSAT within anvil.
!
! Two strategies to fix 
!   1) Simply constrain AF assume condensate
!      just gets "packed" in
!   2) Evaporate QCA to bring up QVx leave AF alone
!      Should include QSAT iteration, but ...        
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!   QS  = QSAT(         &
!               TE    , &
!               PL      )
    IF (af .LT. 1.0) THEN
      qvx = (qv-qs*af)/(1.-af)
    ELSE
      qvx = qs
    END IF
    IF (strategy .EQ. 1) THEN
      IF (qvx - minrhx*qs .LT. 0.0 .AND. af .GT. 0.) af = (qv-minrhx*qs)&
&         /(qs*(1.0-minrhx))
      IF (af .LT. 0.) THEN
! If still cant make suitable env RH then destroy anvil
        af = 0.
        qv = qv + qla + qia
        te = te - (mapl8_alhl*qla+mapl8_alhs*qia)/mapl8_cp
        qla = 0.
        qia = 0.
      END IF
    ELSE IF (strategy .EQ. 2) THEN
      IF (qvx - minrhx*qs .LT. 0.0 .AND. af .GT. 0.) THEN
        qv = qv + (1.-af)*(minrhx*qs-qvx)
        qca = qca - (1.-af)*(minrhx*qs-qvx)
        te = te - (1.-af)*(minrhx*qs-qvx)*mapl8_alhl/mapl8_cp
      END IF
    END IF
  END SUBROUTINE CNVSRC
!  Differentiation of evap3 in reverse (adjoint) mode (with options r8 split(GEOS_MoistGridComp.PRE_PROGNO_CLOUD)):
!   gradient     of useful results: rhcr f qi ql qs qv te
!   with respect to varying inputs: rhcr f qi ql qs qv te
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE EVAP3_ADM(dt, rhcr, rhcr_ad, pl, te, te_ad, qv, qv_ad, ql, &
&   ql_ad, qi, qi_ad, f, f_ad, xf, qs, qs_ad)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: dt
    REAL*8, INTENT(IN) :: rhcr
    REAL*8 :: rhcr_ad
    REAL*8, INTENT(IN) :: pl
    REAL*8, INTENT(INOUT) :: te
    REAL*8 :: te_ad
    REAL*8, INTENT(INOUT) :: qv
    REAL*8 :: qv_ad
    REAL*8, INTENT(INOUT) :: ql, qi
    REAL*8 :: ql_ad, qi_ad
    REAL*8, INTENT(INOUT) :: f
    REAL*8 :: f_ad
    REAL*8, INTENT(IN) :: xf
    REAL*8, INTENT(IN) :: qs
    REAL*8 :: qs_ad
!,QS
    REAL*8 :: es, nn, radius, k1, k2, teff, qcm, evap, rhx, qc
    REAL*8 :: es_ad, radius_ad, k1_ad, k2_ad, teff_ad, qcm_ad, evap_ad, &
&   rhx_ad, qc_ad
    REAL*8, PARAMETER :: epsilon=mapl8_h2omw/mapl8_airmw
! J m**-1 s**-1 K**-1
    REAL*8, PARAMETER :: k_cond=2.4e-2
! m**2 s**-1
    REAL*8, PARAMETER :: diffu=2.2e-5
    REAL*8 :: a_eff
    INTRINSIC MIN
    INTEGER :: branch
    REAL*8 :: temp3
    REAL*8 :: temp2
    REAL*8 :: temp1
    REAL*8 :: temp0
    REAL*8 :: temp_ad4
    REAL*8 :: temp_ad3
    REAL*8 :: temp_ad2
    REAL*8 :: temp_ad1
    REAL*8 :: temp_ad0
    REAL*8 :: temp_ad
    REAL*8 :: temp
    a_eff = cld_evp_eff
    nn = 50.*1.0e6
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!         EVAPORATION OF CLOUD WATER.             !!
!!                                                 !!
!!  DelGenio et al (1996, J. Clim., 9, 270-303)    !!
!!  formulation  (Eq.s 15-17)                      !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!   QS  = QSAT(         &
!               TE    , &
!               PL      )
! (100's <-^ convert from mbar to Pa)
    es = 100.*pl*qs/(epsilon+(1.0-epsilon)*qs)
    IF (qv/qs .GT. 1.00) THEN
      CALL PUSHCONTROL1B(0)
      rhx = 1.00
    ELSE
      rhx = qv/qs
      CALL PUSHCONTROL1B(1)
    END IF
    k1 = mapl8_alhl**2*rho_w/(k_cond*mapl8_rvap*te**2)
    k2 = mapl8_rvap*te*rho_w/(diffu*(1000./pl)*es)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Here DIFFU is given for 1000 mb  !!
!! so 1000./PR accounts for inc-    !!
!! reased diffusivity at lower      !!
!! pressure.                        !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
    IF (f .GT. 0. .AND. ql .GT. 0.) THEN
      qcm = ql/f
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      qcm = 0.
    END IF
    radius = LDRADIUS3(pl, te, qcm, nn)
    IF (rhx .LT. rhcr .AND. radius .GT. 0.0) THEN
! / (1.00 - RHx)
      teff = (rhcr-rhx)/((k1+k2)*radius**2)
      CALL PUSHCONTROL1B(1)
    ELSE
! -999.
      teff = 0.0
      CALL PUSHCONTROL1B(0)
    END IF
    evap = a_eff*ql*dt*teff
    IF (evap .GT. ql) THEN
      evap = ql
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      evap = evap
    END IF
    qc = ql + qi
    IF (qc .GT. 0.) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    evap_ad = qv_ad - ql_ad - mapl8_alhl*te_ad/mapl8_cp
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      temp3 = f/qc
      temp_ad4 = (qc-evap)*f_ad/qc
      qc_ad = temp3*f_ad - temp3*temp_ad4
      evap_ad = evap_ad - temp3*f_ad
      f_ad = temp_ad4
    ELSE
      qc_ad = 0.0_8
    END IF
    ql_ad = ql_ad + qc_ad
    qi_ad = qi_ad + qc_ad
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      ql_ad = ql_ad + evap_ad
      evap_ad = 0.0_8
    END IF
    temp_ad3 = a_eff*dt*evap_ad
    ql_ad = ql_ad + teff*temp_ad3
    teff_ad = ql*temp_ad3
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      radius_ad = 0.0_8
      k1_ad = 0.0_8
      k2_ad = 0.0_8
      rhx_ad = 0.0_8
    ELSE
      temp2 = radius**2
      temp_ad1 = teff_ad/((k1+k2)*temp2)
      temp_ad2 = -((rhcr-rhx)*temp_ad1/((k1+k2)*temp2))
      rhcr_ad = rhcr_ad + temp_ad1
      rhx_ad = -temp_ad1
      k1_ad = temp2*temp_ad2
      k2_ad = temp2*temp_ad2
      radius_ad = (k1+k2)*2*radius*temp_ad2
    END IF
    CALL LDRADIUS3_ADM(pl, te, te_ad, qcm, qcm_ad, nn, radius_ad)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      ql_ad = ql_ad + qcm_ad/f
      f_ad = f_ad - ql*qcm_ad/f**2
    END IF
    temp0 = k_cond*mapl8_rvap*te**2
    temp1 = 1000.*diffu*es
    temp_ad0 = mapl8_rvap*rho_w*pl*k2_ad/temp1
    te_ad = te_ad + temp_ad0 - k_cond*mapl8_rvap*mapl8_alhl**2*rho_w*2*&
&     te*k1_ad/temp0**2
    es_ad = -(te*diffu*1000.*temp_ad0/temp1)
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      qv_ad = qv_ad + rhx_ad/qs
      qs_ad = qs_ad - qv*rhx_ad/qs**2
    END IF
    temp = epsilon + (-epsilon+1.0)*qs
    temp_ad = pl*100.*es_ad/temp
    qs_ad = qs_ad + (1.0_8-qs*(1.0-epsilon)/temp)*temp_ad
  END SUBROUTINE EVAP3_ADM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE EVAP3(dt, rhcr, pl, te, qv, ql, qi, f, xf, qs)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: dt
    REAL*8, INTENT(IN) :: rhcr
    REAL*8, INTENT(IN) :: pl
    REAL*8, INTENT(INOUT) :: te
    REAL*8, INTENT(INOUT) :: qv
    REAL*8, INTENT(INOUT) :: ql, qi
    REAL*8, INTENT(INOUT) :: f
    REAL*8, INTENT(IN) :: xf
    REAL*8, INTENT(IN) :: qs
!,QS
    REAL*8 :: es, nn, radius, k1, k2, teff, qcm, evap, rhx, qc
    REAL*8, PARAMETER :: epsilon=mapl8_h2omw/mapl8_airmw
! J m**-1 s**-1 K**-1
    REAL*8, PARAMETER :: k_cond=2.4e-2
! m**2 s**-1
    REAL*8, PARAMETER :: diffu=2.2e-5
    REAL*8 :: a_eff
    INTRINSIC MIN
    a_eff = cld_evp_eff
    nn = 50.*1.0e6
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!         EVAPORATION OF CLOUD WATER.             !!
!!                                                 !!
!!  DelGenio et al (1996, J. Clim., 9, 270-303)    !!
!!  formulation  (Eq.s 15-17)                      !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!   QS  = QSAT(         &
!               TE    , &
!               PL      )
! (100's <-^ convert from mbar to Pa)
    es = 100.*pl*qs/(epsilon+(1.0-epsilon)*qs)
    IF (qv/qs .GT. 1.00) THEN
      rhx = 1.00
    ELSE
      rhx = qv/qs
    END IF
    k1 = mapl8_alhl**2*rho_w/(k_cond*mapl8_rvap*te**2)
    k2 = mapl8_rvap*te*rho_w/(diffu*(1000./pl)*es)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Here DIFFU is given for 1000 mb  !!
!! so 1000./PR accounts for inc-    !!
!! reased diffusivity at lower      !!
!! pressure.                        !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
    IF (f .GT. 0. .AND. ql .GT. 0.) THEN
      qcm = ql/f
    ELSE
      qcm = 0.
    END IF
    radius = LDRADIUS3(pl, te, qcm, nn)
    IF (rhx .LT. rhcr .AND. radius .GT. 0.0) THEN
! / (1.00 - RHx)
      teff = (rhcr-rhx)/((k1+k2)*radius**2)
    ELSE
! -999.
      teff = 0.0
    END IF
    evap = a_eff*ql*dt*teff
    IF (evap .GT. ql) THEN
      evap = ql
    ELSE
      evap = evap
    END IF
    qc = ql + qi
    IF (qc .GT. 0.) f = f*(qc-evap)/qc
    qv = qv + evap
    ql = ql - evap
    te = te - mapl8_alhl/mapl8_cp*evap
  END SUBROUTINE EVAP3
!  Differentiation of subl3 in reverse (adjoint) mode (with options r8 split(GEOS_MoistGridComp.PRE_PROGNO_CLOUD)):
!   gradient     of useful results: rhcr f qi ql qs qv te
!   with respect to varying inputs: rhcr f qi ql qs qv te
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE SUBL3_ADM(dt, rhcr, rhcr_ad, pl, te, te_ad, qv, qv_ad, ql, &
&   ql_ad, qi, qi_ad, f, f_ad, xf, qs, qs_ad)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: dt
    REAL*8, INTENT(IN) :: rhcr
    REAL*8 :: rhcr_ad
    REAL*8, INTENT(IN) :: pl
    REAL*8, INTENT(INOUT) :: te
    REAL*8 :: te_ad
    REAL*8, INTENT(INOUT) :: qv
    REAL*8 :: qv_ad
    REAL*8, INTENT(INOUT) :: ql, qi
    REAL*8 :: ql_ad, qi_ad
    REAL*8, INTENT(INOUT) :: f
    REAL*8 :: f_ad
    REAL*8, INTENT(IN) :: xf
    REAL*8, INTENT(IN) :: qs
    REAL*8 :: qs_ad
!, QS
    REAL*8 :: es, nn, radius, k1, k2, teff, qcm, subl, rhx, qc
    REAL*8 :: es_ad, radius_ad, k1_ad, k2_ad, teff_ad, qcm_ad, subl_ad, &
&   rhx_ad, qc_ad
    REAL*8, PARAMETER :: epsilon=mapl8_h2omw/mapl8_airmw
! J m**-1 s**-1 K**-1
    REAL*8, PARAMETER :: k_cond=2.4e-2
! m**2 s**-1
    REAL*8, PARAMETER :: diffu=2.2e-5
    REAL*8 :: a_eff
    INTRINSIC MIN
    INTEGER :: branch
    REAL*8 :: temp3
    REAL*8 :: temp2
    REAL*8 :: temp1
    REAL*8 :: temp0
    REAL*8 :: temp_ad4
    REAL*8 :: temp_ad3
    REAL*8 :: temp_ad2
    REAL*8 :: temp_ad1
    REAL*8 :: temp_ad0
    REAL*8 :: temp_ad
    REAL*8 :: temp
    a_eff = cld_evp_eff
    nn = 5.*1.0e6
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!         SUBLORATION OF CLOUD WATER.             !!
!!                                                 !!
!!  DelGenio et al (1996, J. Clim., 9, 270-303)    !!
!!  formulation  (Eq.s 15-17)                      !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!   QS  = QSAT(         &
!               TE    , &
!               PL      )
! (100s <-^ convert from mbar to Pa)
    es = 100.*pl*qs/(epsilon+(1.0-epsilon)*qs)
    IF (qv/qs .GT. 1.00) THEN
      CALL PUSHCONTROL1B(0)
      rhx = 1.00
    ELSE
      rhx = qv/qs
      CALL PUSHCONTROL1B(1)
    END IF
    k1 = mapl8_alhl**2*rho_w/(k_cond*mapl8_rvap*te**2)
    k2 = mapl8_rvap*te*rho_w/(diffu*(1000./pl)*es)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Here DIFFU is given for 1000 mb  !!
!! so 1000./PR accounts for inc-    !!
!! reased diffusivity at lower      !!
!! pressure.                        !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
    IF (f .GT. 0. .AND. qi .GT. 0.) THEN
      qcm = qi/f
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      qcm = 0.
    END IF
    radius = LDRADIUS3(pl, te, qcm, nn)
    IF (rhx .LT. rhcr .AND. radius .GT. 0.0) THEN
! / (1.00 - RHx)
      teff = (rhcr-rhx)/((k1+k2)*radius**2)
      CALL PUSHCONTROL1B(1)
    ELSE
! -999.
      teff = 0.0
      CALL PUSHCONTROL1B(0)
    END IF
    subl = a_eff*qi*dt*teff
    IF (subl .GT. qi) THEN
      subl = qi
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      subl = subl
    END IF
    qc = ql + qi
    IF (qc .GT. 0.) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    subl_ad = qv_ad - qi_ad - mapl8_alhs*te_ad/mapl8_cp
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      temp3 = f/qc
      temp_ad4 = (qc-subl)*f_ad/qc
      qc_ad = temp3*f_ad - temp3*temp_ad4
      subl_ad = subl_ad - temp3*f_ad
      f_ad = temp_ad4
    ELSE
      qc_ad = 0.0_8
    END IF
    ql_ad = ql_ad + qc_ad
    qi_ad = qi_ad + qc_ad
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qi_ad = qi_ad + subl_ad
      subl_ad = 0.0_8
    END IF
    temp_ad3 = a_eff*dt*subl_ad
    qi_ad = qi_ad + teff*temp_ad3
    teff_ad = qi*temp_ad3
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      radius_ad = 0.0_8
      k1_ad = 0.0_8
      k2_ad = 0.0_8
      rhx_ad = 0.0_8
    ELSE
      temp2 = radius**2
      temp_ad1 = teff_ad/((k1+k2)*temp2)
      temp_ad2 = -((rhcr-rhx)*temp_ad1/((k1+k2)*temp2))
      rhcr_ad = rhcr_ad + temp_ad1
      rhx_ad = -temp_ad1
      k1_ad = temp2*temp_ad2
      k2_ad = temp2*temp_ad2
      radius_ad = (k1+k2)*2*radius*temp_ad2
    END IF
    CALL LDRADIUS3_ADM(pl, te, te_ad, qcm, qcm_ad, nn, radius_ad)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qi_ad = qi_ad + qcm_ad/f
      f_ad = f_ad - qi*qcm_ad/f**2
    END IF
    temp0 = k_cond*mapl8_rvap*te**2
    temp1 = 1000.*diffu*es
    temp_ad0 = mapl8_rvap*rho_w*pl*k2_ad/temp1
    te_ad = te_ad + temp_ad0 - k_cond*mapl8_rvap*mapl8_alhl**2*rho_w*2*&
&     te*k1_ad/temp0**2
    es_ad = -(te*diffu*1000.*temp_ad0/temp1)
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      qv_ad = qv_ad + rhx_ad/qs
      qs_ad = qs_ad - qv*rhx_ad/qs**2
    END IF
    temp = epsilon + (-epsilon+1.0)*qs
    temp_ad = pl*100.*es_ad/temp
    qs_ad = qs_ad + (1.0_8-qs*(1.0-epsilon)/temp)*temp_ad
  END SUBROUTINE SUBL3_ADM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE SUBL3(dt, rhcr, pl, te, qv, ql, qi, f, xf, qs)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: dt
    REAL*8, INTENT(IN) :: rhcr
    REAL*8, INTENT(IN) :: pl
    REAL*8, INTENT(INOUT) :: te
    REAL*8, INTENT(INOUT) :: qv
    REAL*8, INTENT(INOUT) :: ql, qi
    REAL*8, INTENT(INOUT) :: f
    REAL*8, INTENT(IN) :: xf
    REAL*8, INTENT(IN) :: qs
!, QS
    REAL*8 :: es, nn, radius, k1, k2, teff, qcm, subl, rhx, qc
    REAL*8, PARAMETER :: epsilon=mapl8_h2omw/mapl8_airmw
! J m**-1 s**-1 K**-1
    REAL*8, PARAMETER :: k_cond=2.4e-2
! m**2 s**-1
    REAL*8, PARAMETER :: diffu=2.2e-5
    REAL*8 :: a_eff
    INTRINSIC MIN
    a_eff = cld_evp_eff
    nn = 5.*1.0e6
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!         SUBLORATION OF CLOUD WATER.             !!
!!                                                 !!
!!  DelGenio et al (1996, J. Clim., 9, 270-303)    !!
!!  formulation  (Eq.s 15-17)                      !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!   QS  = QSAT(         &
!               TE    , &
!               PL      )
! (100s <-^ convert from mbar to Pa)
    es = 100.*pl*qs/(epsilon+(1.0-epsilon)*qs)
    IF (qv/qs .GT. 1.00) THEN
      rhx = 1.00
    ELSE
      rhx = qv/qs
    END IF
    k1 = mapl8_alhl**2*rho_w/(k_cond*mapl8_rvap*te**2)
    k2 = mapl8_rvap*te*rho_w/(diffu*(1000./pl)*es)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Here DIFFU is given for 1000 mb  !!
!! so 1000./PR accounts for inc-    !!
!! reased diffusivity at lower      !!
!! pressure.                        !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
    IF (f .GT. 0. .AND. qi .GT. 0.) THEN
      qcm = qi/f
    ELSE
      qcm = 0.
    END IF
    radius = LDRADIUS3(pl, te, qcm, nn)
    IF (rhx .LT. rhcr .AND. radius .GT. 0.0) THEN
! / (1.00 - RHx)
      teff = (rhcr-rhx)/((k1+k2)*radius**2)
    ELSE
! -999.
      teff = 0.0
    END IF
    subl = a_eff*qi*dt*teff
    IF (subl .GT. qi) THEN
      subl = qi
    ELSE
      subl = subl
    END IF
    qc = ql + qi
    IF (qc .GT. 0.) f = f*(qc-subl)/qc
    qv = qv + subl
    qi = qi - subl
    te = te - mapl8_alhs/mapl8_cp*subl
  END SUBROUTINE SUBL3
!  Differentiation of autocon3 in reverse (adjoint) mode (with options r8 split(GEOS_MoistGridComp.PRE_PROGNO_CLOUD)):
!   gradient     of useful results: f qc qp te
!   with respect to varying inputs: f qc te
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE AUTOCON3_ADM(dt, qc, qc_ad, qp, qp_ad, te, te_ad, pl, kh, f&
&   , f_ad, sundqv2, sundqv3, sundqt1, dzet, vf, fraction_removal)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: fraction_removal
    REAL*8, INTENT(IN) :: dt
    REAL*8, INTENT(IN) :: te
    REAL*8 :: te_ad
    REAL*8, INTENT(IN) :: pl
    REAL*8, INTENT(IN) :: kh
    REAL*8, INTENT(INOUT) :: qc
    REAL*8 :: qc_ad
    REAL*8, INTENT(INOUT) :: qp
    REAL*8 :: qp_ad
    REAL*8, INTENT(INOUT) :: f
    REAL*8 :: f_ad
    REAL*8, INTENT(IN) :: dzet
    REAL*8, INTENT(INOUT) :: vf
    REAL*8, INTENT(IN) :: sundqv2, sundqv3, sundqt1
    INTEGER :: nsmx
    REAL*8 :: acf0, acf, dtx
    REAL*8 :: c00x, iqccrx, f2, f3, rate, dqp, qcm
    REAL*8 :: c00x_ad, iqccrx_ad, f2_ad, f3_ad, rate_ad, dqp_ad, qcm_ad
    REAL*8 :: dqfac
    INTEGER :: ns, k
    INTRINSIC EXP
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC SQRT
    INTEGER :: branch
    REAL*8 :: temp2
    REAL*8 :: temp1
    REAL*8 :: temp0
    REAL*8 :: x1_ad
    REAL*8 :: x1
    REAL*8 :: temp_ad5
    REAL*8 :: temp_ad4
    REAL*8 :: temp_ad3
    REAL*8 :: temp_ad2
    REAL*8 :: temp_ad1
    REAL*8 :: temp_ad0
    REAL*8 :: temp_ad
    REAL*8 :: temp
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Precip. conversion from Smith (1990,    !
!   QJRMS, 116, 435, Eq. 2.29). Similar    ! 
!   to Del Genios Eq.(10).                 !
!                                          !
!   Coalesence term needs to be determined !
!   through entire column and is done in   !
!   subroutine "ACCRETE_EVAP_PRECIP"       !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    CALL PUSHREAL8(f2)
    CALL SUNDQ3_ICE3(te, sundqv2, sundqv3, sundqt1, f2, f3)
    c00x = c_00*f2*f3
!QCcrx = LWCRIT / ( F2 * F3 )
    iqccrx = f2*f3/lwcrit
    IF (f .GT. 0. .AND. qc .GT. 0.) THEN
      qcm = qc/f
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      qcm = 0.
    END IF
    rate = c00x*(1.0-EXP(-((qcm*iqccrx)**2)))
!!! Make up a fall velocity for liquid precipitation - in analogy to falling ice,
!!!    think of the fall velocity as the ratio of autoconverted to existing condensate 
!!!    multiplied by delta z / delta t  
!!!   (ie, autoconversion/sec is related to residence time in layer)
!! temporary kluge until we can figure a better to make
!! thicker low clouds ( reuse arrays F2 and F3 )
    CALL PUSHREAL8(f3)
    f3 = 1.0
! Implement ramps for gradual change in autoconv
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Thicken low high lat clouds
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IF (pl .GE. 775. .AND. te .LE. 275.) f3 = 0.2
!!!      F3 = max(-0.016 * PL + 13.4, 0.2)
    IF (pl .GE. 825. .AND. te .LE. 282.) f3 = 0.2
!!!      F3 = max(0.11 * TE - 30.02, 0.2)
    IF (pl .GE. 775. .AND. pl .LT. 825. .AND. te .LE. 282. .AND. te .GT.&
&       275.) f3 = 0.2
!!!      F3 = min(max(-0.016*PL + 0.11 * TE - 16.85, 0.2),1.)
    IF (pl .GE. 825. .AND. te .LE. 275.) f3 = 0.2
    IF (pl .LE. 775. .OR. te .GT. 282.) f3 = 1.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Thin-out low tropical clouds
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IF (pl .GE. 950. .AND. te .GE. 285.) THEN
      IF (0.2*te - 56 .GT. 2.) THEN
        CALL PUSHCONTROL2B(2)
        f3 = 2.
      ELSE
        f3 = 0.2*te - 56
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(0)
    END IF
    IF (pl .GE. 925. .AND. te .GE. 290.) THEN
      IF (0.04*pl - 36. .GT. 2.) THEN
        CALL PUSHCONTROL1B(1)
        f3 = 2.
      ELSE
        CALL PUSHCONTROL1B(1)
        f3 = 0.04*pl - 36.
      END IF
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (pl .GE. 925. .AND. pl .LT. 950. .AND. te .GT. 285. .AND. te .LT.&
&       290.) THEN
      IF (0.04*pl + 0.2*te - 94. .GT. 2.) THEN
        CALL PUSHCONTROL1B(0)
        x1 = 2.
      ELSE
        x1 = 0.04*pl + 0.2*te - 94.
        CALL PUSHCONTROL1B(1)
      END IF
      IF (x1 .LT. 1.) THEN
        f3 = 1.
        CALL PUSHCONTROL2B(2)
      ELSE
        f3 = x1
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(0)
    END IF
    IF (pl .GE. 950. .AND. te .GE. 290.) THEN
      f3 = 2.
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (f3 .LT. 0.1) THEN
      f3 = 0.1
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      f3 = f3
    END IF
    CALL PUSHREAL8(rate)
    rate = f3*rate
    dqp = qc*(1.0-EXP(-(rate*dt)))
    IF (dqp .LT. 0.0) THEN
      dqp = 0.0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      dqp = dqp
    END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Go ahead and totally wipe-out warm fogs
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!dqfac = 0.
!if ( PL .GE. 975.  .AND. TE .GE.  280. ) then
!   dqfac = max(min(0.2 * TE - 56., 1.),0.)
!end if
!if ( PL .GE. 950.  .AND. TE .GE.  285. ) then
!   dqfac = max(min(0.04 * PL - 38., 1.),0.)
!end if
!if ( PL .GE. 950.  .AND. PL .LT. 975. .AND. TE .GT.  280. .AND. TE .LT. 285.) then
!   dqfac = max(min(0.04*PL + 0.2 * TE - 95., 1.),0.)
!end if
!if ( ( PL >= 975. ) .AND. (TE >= 285. ) ) then
!   dqfac = 1.
!end if
!dQP = max(dQP, dqfac*QC)
    CALL PUSHREAL8(qc)
    qc = qc - dqp
!SELECT CASE( FRACTION_REMOVAL )
!CASE( 0 )
! do NOTHING
    IF (fraction_removal .EQ. 1) THEN
      IF (qc + dqp .GT. 0.) THEN
        temp_ad0 = f_ad/(qc+dqp)
        temp_ad1 = -(qc*f*temp_ad0/(qc+dqp))
        qc_ad = qc_ad + temp_ad1 + f*temp_ad0
        dqp_ad = temp_ad1
        f_ad = qc*temp_ad0
      ELSE
        dqp_ad = 0.0_8
      END IF
    ELSE IF (fraction_removal .EQ. 2) THEN
      IF (qc + dqp .GT. 0. .AND. qc .GT. 0.) THEN
        temp0 = qc/(qc+dqp)
        temp1 = SQRT(temp0)
        IF (temp0 .EQ. 0.0_8) THEN
          temp_ad2 = 0.0
        ELSE
          temp_ad2 = f*f_ad/(2.0*temp1*(qc+dqp))
        END IF
        temp_ad3 = -(temp0*temp_ad2)
        qc_ad = qc_ad + temp_ad3 + temp_ad2
        dqp_ad = temp_ad3
        f_ad = temp1*f_ad
      ELSE
        dqp_ad = 0.0_8
      END IF
    ELSE IF (fraction_removal .EQ. 3) THEN
      IF (qc + dqp .GT. 0. .AND. qc .GT. 0.) THEN
        temp2 = qc/(qc+dqp)
        temp_ad4 = 0.333*temp2**(-0.667)*f*f_ad/(qc+dqp)
        temp_ad5 = -(temp2*temp_ad4)
        qc_ad = qc_ad + temp_ad5 + temp_ad4
        dqp_ad = temp_ad5
        f_ad = temp2**0.333*f_ad
      ELSE
        dqp_ad = 0.0_8
      END IF
    ELSE
      dqp_ad = 0.0_8
    END IF
    dqp_ad = dqp_ad + qp_ad - qc_ad
    CALL POPREAL8(qc)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) dqp_ad = 0.0_8
    qc_ad = qc_ad + (1.0-EXP(-(dt*rate)))*dqp_ad
    rate_ad = EXP(-(dt*rate))*qc*dt*dqp_ad
    CALL POPREAL8(rate)
    f3_ad = rate*rate_ad
    rate_ad = f3*rate_ad
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) f3_ad = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) f3_ad = 0.0_8
    CALL POPCONTROL2B(branch)
    IF (branch .NE. 0) THEN
      IF (branch .EQ. 1) THEN
        x1_ad = f3_ad
      ELSE
        x1_ad = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) te_ad = te_ad + 0.2*x1_ad
      f3_ad = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) f3_ad = 0.0_8
    CALL POPCONTROL2B(branch)
    IF (branch .NE. 0) THEN
      IF (branch .EQ. 1) te_ad = te_ad + 0.2*f3_ad
    END IF
    CALL POPREAL8(f3)
    temp = qcm*iqccrx
    temp_ad = EXP(-(temp**2))*c00x*2*temp*rate_ad
    c00x_ad = (1.0-EXP(-(temp**2)))*rate_ad
    qcm_ad = iqccrx*temp_ad
    iqccrx_ad = qcm*temp_ad
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qc_ad = qc_ad + qcm_ad/f
      f_ad = f_ad - qc*qcm_ad/f**2
    END IF
    f2_ad = c_00*f3*c00x_ad + f3*iqccrx_ad/lwcrit
    CALL POPREAL8(f2)
    CALL SUNDQ3_ICE3_ADM(te, te_ad, sundqv2, sundqv3, sundqt1, f2, f2_ad&
&                  , f3)
  END SUBROUTINE AUTOCON3_ADM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE AUTOCON3(dt, qc, qp, te, pl, kh, f, sundqv2, sundqv3, &
&   sundqt1, dzet, vf, fraction_removal)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: fraction_removal
    REAL*8, INTENT(IN) :: dt
    REAL*8, INTENT(IN) :: te
    REAL*8, INTENT(IN) :: pl
    REAL*8, INTENT(IN) :: kh
    REAL*8, INTENT(INOUT) :: qc
    REAL*8, INTENT(INOUT) :: qp
    REAL*8, INTENT(INOUT) :: f
    REAL*8, INTENT(IN) :: dzet
    REAL*8, INTENT(INOUT) :: vf
    REAL*8, INTENT(IN) :: sundqv2, sundqv3, sundqt1
    INTEGER :: nsmx
    REAL*8 :: acf0, acf, dtx
    REAL*8 :: c00x, iqccrx, f2, f3, rate, dqp, qcm
    REAL*8 :: dqfac
    INTEGER :: ns, k
    INTRINSIC EXP
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC SQRT
    REAL*8 :: x1
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Precip. conversion from Smith (1990,    !
!   QJRMS, 116, 435, Eq. 2.29). Similar    ! 
!   to Del Genios Eq.(10).                 !
!                                          !
!   Coalesence term needs to be determined !
!   through entire column and is done in   !
!   subroutine "ACCRETE_EVAP_PRECIP"       !
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    nsmx = nsmax
    dtx = dt/nsmx
    CALL SUNDQ3_ICE3(te, sundqv2, sundqv3, sundqt1, f2, f3)
    c00x = c_00*f2*f3
!QCcrx = LWCRIT / ( F2 * F3 )
    iqccrx = f2*f3/lwcrit
    IF (f .GT. 0. .AND. qc .GT. 0.) THEN
      qcm = qc/f
    ELSE
      qcm = 0.
    END IF
    rate = c00x*(1.0-EXP(-((qcm*iqccrx)**2)))
!!! Make up a fall velocity for liquid precipitation - in analogy to falling ice,
!!!    think of the fall velocity as the ratio of autoconverted to existing condensate 
!!!    multiplied by delta z / delta t  
!!!   (ie, autoconversion/sec is related to residence time in layer)
    vf = dzet/dt*(1.0-EXP(-(rate*dt)))
!! temporary kluge until we can figure a better to make
!! thicker low clouds ( reuse arrays F2 and F3 )
    f2 = 1.0
    f3 = 1.0
! Implement ramps for gradual change in autoconv
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Thicken low high lat clouds
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IF (pl .GE. 775. .AND. te .LE. 275.) f3 = 0.2
!!!      F3 = max(-0.016 * PL + 13.4, 0.2)
    IF (pl .GE. 825. .AND. te .LE. 282.) f3 = 0.2
!!!      F3 = max(0.11 * TE - 30.02, 0.2)
    IF (pl .GE. 775. .AND. pl .LT. 825. .AND. te .LE. 282. .AND. te .GT.&
&       275.) f3 = 0.2
!!!      F3 = min(max(-0.016*PL + 0.11 * TE - 16.85, 0.2),1.)
    IF (pl .GE. 825. .AND. te .LE. 275.) f3 = 0.2
    IF (pl .LE. 775. .OR. te .GT. 282.) f3 = 1.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! Thin-out low tropical clouds
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IF (pl .GE. 950. .AND. te .GE. 285.) THEN
      IF (0.2*te - 56 .GT. 2.) THEN
        f3 = 2.
      ELSE
        f3 = 0.2*te - 56
      END IF
    END IF
    IF (pl .GE. 925. .AND. te .GE. 290.) THEN
      IF (0.04*pl - 36. .GT. 2.) THEN
        f3 = 2.
      ELSE
        f3 = 0.04*pl - 36.
      END IF
    END IF
    IF (pl .GE. 925. .AND. pl .LT. 950. .AND. te .GT. 285. .AND. te .LT.&
&       290.) THEN
      IF (0.04*pl + 0.2*te - 94. .GT. 2.) THEN
        x1 = 2.
      ELSE
        x1 = 0.04*pl + 0.2*te - 94.
      END IF
      IF (x1 .LT. 1.) THEN
        f3 = 1.
      ELSE
        f3 = x1
      END IF
    END IF
    IF (pl .GE. 950. .AND. te .GE. 290.) f3 = 2.
    IF (f3 .LT. 0.1) THEN
      f3 = 0.1
    ELSE
      f3 = f3
    END IF
    rate = f3*rate
    dqp = qc*(1.0-EXP(-(rate*dt)))
    IF (dqp .LT. 0.0) THEN
      dqp = 0.0
    ELSE
      dqp = dqp
    END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Go ahead and totally wipe-out warm fogs
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!dqfac = 0.
!if ( PL .GE. 975.  .AND. TE .GE.  280. ) then
!   dqfac = max(min(0.2 * TE - 56., 1.),0.)
!end if
!if ( PL .GE. 950.  .AND. TE .GE.  285. ) then
!   dqfac = max(min(0.04 * PL - 38., 1.),0.)
!end if
!if ( PL .GE. 950.  .AND. PL .LT. 975. .AND. TE .GT.  280. .AND. TE .LT. 285.) then
!   dqfac = max(min(0.04*PL + 0.2 * TE - 95., 1.),0.)
!end if
!if ( ( PL >= 975. ) .AND. (TE >= 285. ) ) then
!   dqfac = 1.
!end if
!dQP = max(dQP, dqfac*QC)
    qc = qc - dqp
    qp = qp + dqp
!SELECT CASE( FRACTION_REMOVAL )
!CASE( 0 )
! do NOTHING
    IF (fraction_removal .EQ. 1) THEN
      IF (qc + dqp .GT. 0.) f = qc*f/(qc+dqp)
    ELSE IF (fraction_removal .EQ. 2) THEN
      IF (qc + dqp .GT. 0. .AND. qc .GT. 0.) f = f*SQRT(qc/(qc+dqp))
    ELSE IF (fraction_removal .EQ. 3) THEN
      IF (qc + dqp .GT. 0. .AND. qc .GT. 0.) f = f*(qc/(qc+dqp))**0.333
    END IF
  END SUBROUTINE AUTOCON3
!  Differentiation of precip3 in reverse (adjoint) mode (with options r8 split(GEOS_MoistGridComp.PRE_PROGNO_CLOUD)):
!   gradient     of useful results: aa pfi_above qv subl_dd_above
!                bb pfl_above qcl rhcr3 dze qddf3 evap_dd_above
!                te
!   with respect to varying inputs: aa area pfi_above qv subl_dd_above
!                bb pfl_above qcl qpi qpl rhcr3 dze qddf3 evap_dd_above
!                te
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device)   &
!#endif
!         RAIN         , & 
!         SNOW         , &
!         REVAP_DIAG   , &
!         RSUBL_DIAG   , &
!         ACRLL_DIAG        , &
!         ACRIL_DIAG        , &
!         PFL_DIAG     , &
!         PFI_DIAG     , &
!         VFALLRN      , &
!         VFALLSN      , &
!         FRZ_DIAG     , &
  SUBROUTINE PRECIP3_ADM(k, lm, dt, frland, rhcr3, rhcr3_ad, qpl, qpl_ad&
&   , qpi, qpi_ad, qcl, qcl_ad, qci, te, te_ad, qv, qv_ad, mass, imass, &
&   pl, dze, dze_ad, qddf3, qddf3_ad, aa, aa_ad, bb, bb_ad, area, &
&   area_ad, pfl_above, pfl_above_ad, pfi_above, pfi_above_ad, &
&   evap_dd_above, evap_dd_above_ad, subl_dd_above, subl_dd_above_ad, &
&   envfc, ddrfc)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: k, lm
    REAL*8, INTENT(IN) :: dt
    REAL*8, INTENT(INOUT) :: qv, qpl, qpi, qcl, qci, te
    REAL*8 :: qv_ad, qpl_ad, qpi_ad, qcl_ad, te_ad
    REAL*8, INTENT(IN) :: mass, imass
    REAL*8, INTENT(IN) :: pl
    REAL*8, INTENT(IN) :: aa, bb
    REAL*8 :: aa_ad, bb_ad
    REAL*8, INTENT(IN) :: rhcr3
    REAL*8 :: rhcr3_ad
    REAL*8, INTENT(IN) :: dze
    REAL*8 :: dze_ad
    REAL*8, INTENT(IN) :: qddf3
    REAL*8 :: qddf3_ad
!      real(8), intent(  out) :: RAIN,SNOW
    REAL*8, INTENT(IN) :: area
    REAL*8 :: area_ad
    REAL*8, INTENT(IN) :: frland
    REAL*8, INTENT(INOUT) :: pfl_above, pfi_above
    REAL*8 :: pfl_above_ad, pfi_above_ad
    REAL*8, INTENT(INOUT) :: evap_dd_above, subl_dd_above
    REAL*8 :: evap_dd_above_ad, subl_dd_above_ad
!      real(8), intent(  out) :: REVAP_DIAG
!      real(8), intent(  out) :: RSUBL_DIAG
!      real(8), intent(  out) :: ACRLL_DIAG,ACRIL_DIAG
!      real(8), intent(  out) :: PFL_DIAG, PFI_DIAG
!      real(8), intent(inout) :: FRZ_DIAG
!      real(8), intent(  out) :: VFALLSN, VFALLRN
    REAL*8, INTENT(IN) :: envfc, ddrfc
    REAL*8 :: pfi, pfl, qs, dqs, envfrac
    REAL*8 :: pfi_ad, pfl_ad, qs_ad, dqs_ad
    REAL*8 :: tko, qko, qstko, dqstko, rh_box, t_ed, qplko, qpiko
    REAL*8 :: tko_ad, qko_ad, qstko_ad, dqstko_ad, rh_box_ad, t_ed_ad
    REAL*8 :: ifactor, rainrat0, snowrat0
    REAL*8 :: ifactor_ad, rainrat0_ad, snowrat0_ad
    REAL*8 :: fallrn, fallsn, vesn, vern, nrain, nsnow, efactor
    REAL*8 :: fallrn_ad, fallsn_ad, vesn_ad, vern_ad, efactor_ad
    REAL*8 :: tinlayerrn, diamrn, droprad
    REAL*8 :: tinlayerrn_ad, diamrn_ad, droprad_ad
    REAL*8 :: tinlayersn, diamsn, flakrad
    REAL*8 :: tinlayersn_ad, diamsn_ad, flakrad_ad
    REAL*8 :: evap, subl, accr, mltfrz, evapx, sublx
    REAL*8 :: evap_ad, subl_ad, accr_ad, mltfrz_ad, evapx_ad, sublx_ad
    REAL*8 :: evap_dd, subl_dd, ddfract
    REAL*8 :: evap_dd_ad, subl_dd_ad
    REAL*8 :: landseaf
! m/s
    REAL*8, PARAMETER :: trmv_l=1.0
    REAL*8 :: tau_frz, tau_mlt
    INTEGER :: ns, nsmx, itr, l
    LOGICAL, PARAMETER :: taneff=.false.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! fraction of precip falling through "environment" vs
! through cloud
    REAL*8, PARAMETER :: b_sub=1.00
    INTRINSIC TAN
    INTRINSIC ATAN
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC EXP
    INTEGER :: branch
    REAL*8 :: temp3
    REAL*8 :: temp2
    REAL*8 :: temp1
    REAL*8 :: temp0
    REAL*8 :: temp_ad9
    REAL*8 :: temp_ad8
    REAL*8 :: temp_ad7
    REAL*8 :: temp_ad6
    REAL*8 :: temp_ad5
    REAL*8 :: temp_ad4
    REAL*8 :: temp_ad3
    REAL*8 :: temp_ad2
    REAL*8 :: temp_ad1
    REAL*8 :: temp_ad0
    REAL*8 :: temp_ad
    REAL*8 :: temp
    REAL*8 :: temp4
    IF (taneff) THEN
      IF (pl .LE. 600.) THEN
        envfrac = 0.25
      ELSE
        envfrac = 0.25 + (1.-0.25)/19.*((ATAN((2.*(pl-600.)/(900.-600.)-&
&         1.)*TAN(20.*mapl8_pi/21.-0.5*mapl8_pi))+0.5*mapl8_pi)*21./&
&         mapl8_pi-1.)
      END IF
      IF (envfrac .GT. 1.) THEN
        CALL PUSHCONTROL1B(1)
        envfrac = 1.
      ELSE
        CALL PUSHCONTROL1B(1)
        envfrac = envfrac
      END IF
    ELSE
      CALL PUSHCONTROL1B(0)
      envfrac = envfc
    END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IF (area .GT. 0.) THEN
      ifactor = 1./area
      CALL PUSHCONTROL1B(1)
    ELSE
      ifactor = 1.00
      CALL PUSHCONTROL1B(0)
    END IF
    IF (ifactor .LT. 1.) THEN
      ifactor = 1.
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      ifactor = ifactor
    END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!   Start at top of precip column:
!  
!               a) Accrete                   
!               b) Evaporate/Sublimate  
!               c) Rain/Snow-out to next level down 
!               d) return to (a)
!
!   ....................................................................
!           
!  Accretion formulated according to Smith (1990, Q.J.R.M.S., 116, 435
!  Eq. 2.29)
!  
!  Evaporation (ibid. Eq. 2.32)
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! INITIALIZE DIAGNOSTIC ARRAYS !!!!!!!!!!!!!!!!!!!!!
!      PFL_DIAG =  0.
!      PFI_DIAG =  0.
!      ACRIL_DIAG    =  0.
!      ACRLL_DIAG    =  0.
!      REVAP_DIAG    =  0.
!      RSUBL_DIAG    =  0.
!!!!!!!!!!!!!! UPDATE SATURATED HUMIDITY  !!!!!!!!!!!!!
    CALL DQSATSCAPERT(dqs, qs, te, pl)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ddfract = ddrfc
    IF (k .EQ. ktop) THEN
      evap_dd = 0.
      subl_dd = 0.
!         VFALLRN = 0.0
!         VFALLSN = 0.0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHREAL8(qpl)
      qpl = qpl + pfl_above*imass
      CALL PUSHREAL8(qpi)
      qpi = qpi + pfi_above*imass
      accr = b_sub*c_acc*(qpl*mass)*qcl
      IF (accr .GT. qcl) THEN
        accr = qcl
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
        accr = accr
      END IF
      CALL PUSHREAL8(qpl)
      qpl = qpl + accr
      CALL PUSHREAL8(qcl)
      qcl = qcl - accr
!         ACRLL_DIAG = ACCR / DT
!! Accretion of liquid condensate by falling ice/snow
      accr = b_sub*c_acc*(qpi*mass)*qcl
      IF (accr .GT. qcl) THEN
        accr = qcl
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
        accr = accr
      END IF
      CALL PUSHREAL8(qpi)
      qpi = qpi + accr
!! Liquid freezes when accreted by snow
      CALL PUSHREAL8(te)
      te = te + mapl8_alhf*accr/mapl8_cp
!        ACRIL_DIAG = ACCR / DT
      rainrat0 = ifactor*qpl*mass/dt
      snowrat0 = ifactor*qpi*mass/dt
      CALL PUSHREAL8(diamrn)
      CALL MARSHPALMQ2(rainrat0, pl, diamrn, nrain, fallrn, vern)
      CALL PUSHREAL8(diamsn)
      CALL MARSHPALMQ2(snowrat0, pl, diamsn, nsnow, fallsn, vesn)
!!      DIAMsn = MAX(  DIAMsn, 1.0e-3 )   ! Over Ocean
!         VFALLRN = FALLrn
!         VFALLSN = FALLsn
      tinlayerrn = dze/(fallrn+0.01)
      tinlayersn = dze/(fallsn+0.01)
!*****************************************
!  Melting of Frozen precipitation      
!*****************************************
! time scale for freezing (s). 
      tau_frz = 5000.
      IF (te .GT. mapl8_tice .AND. te .LE. mapl8_tice + 5.) THEN
        mltfrz = tinlayersn*qpi*(te-mapl8_tice)/tau_frz
        IF (qpi .GT. mltfrz) THEN
          CALL PUSHCONTROL1B(0)
          mltfrz = mltfrz
        ELSE
          mltfrz = qpi
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHREAL8(te)
        te = te - mapl8_alhf*mltfrz/mapl8_cp
        CALL PUSHREAL8(qpl)
        qpl = qpl + mltfrz
        CALL PUSHREAL8(qpi)
        qpi = qpi - mltfrz
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!         FRZ_DIAG = FRZ_DIAG - MLTFRZ / DT
      IF (te .GT. mapl8_tice + 5.) THEN
! Go Ahead and melt any snow/hail left above 5 C 
        mltfrz = qpi
        te = te - mapl8_alhf*mltfrz/mapl8_cp
        CALL PUSHREAL8(qpl)
        qpl = qpl + mltfrz
        CALL PUSHREAL8(qpi)
        qpi = qpi - mltfrz
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!         FRZ_DIAG = FRZ_DIAG - MLTFRZ / DT
      IF (k .GE. lm - 1) THEN
        IF (te .GT. mapl8_tice + 0.) THEN
! Go Ahead and melt any snow/hail left above 0 C in lowest layers 
          mltfrz = qpi
          te = te - mapl8_alhf*mltfrz/mapl8_cp
          CALL PUSHREAL8(qpl)
          qpl = qpl + mltfrz
          CALL PUSHREAL8(qpi)
          qpi = qpi - mltfrz
          CALL PUSHCONTROL2B(0)
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(2)
      END IF
!         FRZ_DIAG = FRZ_DIAG - MLTFRZ / DT
!*****************************************
!  Freezing of liquid precipitation      
!*****************************************
      IF (te .LE. mapl8_tice) THEN
        te = te + mapl8_alhf*qpl/mapl8_cp
        CALL PUSHREAL8(qpi)
        qpi = qpl + qpi
        CALL PUSHREAL8(qpl)
        qpl = 0.
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
!         FRZ_DIAG = FRZ_DIAG + MLTFRZ / DT
! ******************************************
!   In the exp below, evaporation time 
!   scale is determined "microphysically"
!   from temp, press, and drop size. In this
!   context C_EV becomes a dimensionless 
!   fudge-fraction.
!   Also remember that these microphysics 
!   are still only for liquid.
! ******************************************
      qko = qv
      tko = te
      DO itr=1,3
        dqstko = dqs
        CALL PUSHREAL8(qstko)
        qstko = qs + dqstko*(tko-te)
        IF (qstko .LT. 1.0e-7) THEN
          qstko = 1.0e-7
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
          qstko = qstko
        END IF
        CALL PUSHREAL8(rh_box)
        rh_box = qko/qstko
        IF (rh_box .LT. rhcr3) THEN
          CALL PUSHREAL8(efactor)
          efactor = rho_w*(aa+bb)/(rhcr3-rh_box)
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHREAL8(efactor)
          efactor = 9.99e9
          CALL PUSHCONTROL1B(1)
        END IF
        landseaf = 1.00
!!!!! RAin falling !!!!!!!!!!!!!!!!!!!!!!!
        IF (rh_box .LT. rhcr3 .AND. diamrn .GT. 0.00 .AND. pl .GT. 100. &
&           .AND. pl .LT. revap_off_p) THEN
          droprad = 0.5*diamrn
          CALL PUSHREAL8(t_ed)
          t_ed = efactor*droprad**2
          CALL PUSHREAL8(t_ed)
          t_ed = t_ed*(1.0+dqstko*mapl8_alhl/mapl8_cp)
          evap = qpl*(1.0-EXP(-(c_ev_r*vern*landseaf*envfrac*tinlayerrn/&
&           t_ed)))
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
          evap = 0.0
        END IF
!!!!! Snow falling !!!!!!!!!!!!!!!!!!!!!!!
        IF (rh_box .LT. rhcr3 .AND. diamsn .GT. 0.00 .AND. pl .GT. 100. &
&           .AND. pl .LT. revap_off_p) THEN
          flakrad = 0.5*diamsn
          CALL PUSHREAL8(t_ed)
          t_ed = efactor*flakrad**2
          CALL PUSHREAL8(t_ed)
          t_ed = t_ed*(1.0+dqstko*mapl8_alhs/mapl8_cp)
          subl = qpi*(1.0-EXP(-(c_ev_s*vesn*landseaf*envfrac*tinlayersn/&
&           t_ed)))
          CALL PUSHCONTROL1B(0)
        ELSE
          subl = 0.0
          CALL PUSHCONTROL1B(1)
        END IF
        IF (itr .EQ. 1) THEN
          evapx = evap
          sublx = subl
          CALL PUSHCONTROL1B(0)
        ELSE
          evap = (evap+evapx)/2.0
          subl = (subl+sublx)/2.0
          CALL PUSHCONTROL1B(1)
        END IF
        CALL PUSHREAL8(qko)
        qko = qv + evap + subl
        CALL PUSHREAL8(tko)
        tko = te - evap*mapl8_alhl/mapl8_cp - subl*mapl8_alhs/mapl8_cp
      END DO
!! Put some re-evap/re-subl precip in to a \quote{downdraft} to be applied later
      evap_dd = evap_dd_above + ddfract*evap*mass
      subl_dd = subl_dd_above + ddfract*subl*mass
! -----
!         REVAP_DIAG = EVAP / DT
!         RSUBL_DIAG = SUBL / DT
!         PFL_DIAG =  PFl/DT
!         PFI_DIAG =  PFi/DT
      CALL PUSHCONTROL1B(1)
    END IF
    subl_ad = qv_ad - mapl8_alhs*te_ad/mapl8_cp
    evap_ad = qv_ad - mapl8_alhl*te_ad/mapl8_cp
    subl_dd_ad = qddf3*subl_ad/mass + subl_dd_above_ad
    evap_dd_ad = qddf3*evap_ad/mass + evap_dd_above_ad
    pfi_ad = pfi_above_ad
    pfl_ad = pfl_above_ad
    qddf3_ad = qddf3_ad + evap_dd*evap_ad/mass + subl_dd*subl_ad/mass
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qpi_ad = mass*pfi_ad
      qpl_ad = mass*pfl_ad
      pfi_above_ad = 0.0_8
      subl_dd_above_ad = 0.0_8
      pfl_above_ad = 0.0_8
      evap_dd_above_ad = 0.0_8
      dqs_ad = 0.0_8
      qs_ad = 0.0_8
      ifactor_ad = 0.0_8
    ELSE
      qpi_ad = mass*pfi_ad
      qpl_ad = mass*pfl_ad
      evap_ad = qv_ad - mapl8_alhl*te_ad/mapl8_cp
      subl_ad = qv_ad - mapl8_alhs*te_ad/mapl8_cp
      subl_ad = ddfract*mass*subl_dd_ad - qpi_ad + (1.0_8-ddfract)*&
&       subl_ad
      subl_dd_above_ad = subl_dd_ad
      evap_ad = ddfract*mass*evap_dd_ad - qpl_ad + (1.0_8-ddfract)*&
&       evap_ad
      evap_dd_above_ad = evap_dd_ad
      tko_ad = 0.0_8
      sublx_ad = 0.0_8
      dqs_ad = 0.0_8
      qs_ad = 0.0_8
      qko_ad = 0.0_8
      diamrn_ad = 0.0_8
      vern_ad = 0.0_8
      tinlayerrn_ad = 0.0_8
      diamsn_ad = 0.0_8
      evapx_ad = 0.0_8
      vesn_ad = 0.0_8
      tinlayersn_ad = 0.0_8
      DO itr=3,1,-1
        CALL POPREAL8(tko)
        te_ad = te_ad + tko_ad
        evap_ad = evap_ad + qko_ad - mapl8_alhl*tko_ad/mapl8_cp
        subl_ad = subl_ad + qko_ad - mapl8_alhs*tko_ad/mapl8_cp
        CALL POPREAL8(qko)
        qv_ad = qv_ad + qko_ad
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          subl_ad = subl_ad + sublx_ad
          evap_ad = evap_ad + evapx_ad
          sublx_ad = 0.0_8
          evapx_ad = 0.0_8
        ELSE
          sublx_ad = sublx_ad + subl_ad/2.0
          subl_ad = subl_ad/2.0
          evapx_ad = evapx_ad + evap_ad/2.0
          evap_ad = evap_ad/2.0
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          landseaf = 1.00
          temp2 = vesn*tinlayersn/t_ed
          temp4 = c_ev_s*landseaf*envfrac
          temp3 = -(temp4*temp2)
          temp_ad9 = temp4*EXP(temp3)*qpi*subl_ad/t_ed
          qpi_ad = qpi_ad + (1.0-EXP(temp3))*subl_ad
          vesn_ad = vesn_ad + tinlayersn*temp_ad9
          tinlayersn_ad = tinlayersn_ad + vesn*temp_ad9
          t_ed_ad = -(temp2*temp_ad9)
          dqstko = dqs
          flakrad = 0.5*diamsn
          CALL POPREAL8(t_ed)
          dqstko_ad = mapl8_alhs*t_ed*t_ed_ad/mapl8_cp
          t_ed_ad = (mapl8_alhs*(dqstko/mapl8_cp)+1.0)*t_ed_ad
          CALL POPREAL8(t_ed)
          efactor_ad = flakrad**2*t_ed_ad
          flakrad_ad = efactor*2*flakrad*t_ed_ad
          diamsn_ad = diamsn_ad + 0.5*flakrad_ad
        ELSE
          landseaf = 1.00
          dqstko = dqs
          dqstko_ad = 0.0_8
          efactor_ad = 0.0_8
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          temp = vern*tinlayerrn/t_ed
          temp1 = c_ev_r*landseaf*envfrac
          temp0 = -(temp1*temp)
          temp_ad8 = temp1*EXP(temp0)*qpl*evap_ad/t_ed
          qpl_ad = qpl_ad + (1.0-EXP(temp0))*evap_ad
          vern_ad = vern_ad + tinlayerrn*temp_ad8
          tinlayerrn_ad = tinlayerrn_ad + vern*temp_ad8
          t_ed_ad = -(temp*temp_ad8)
          droprad = 0.5*diamrn
          CALL POPREAL8(t_ed)
          dqstko_ad = dqstko_ad + mapl8_alhl*t_ed*t_ed_ad/mapl8_cp
          t_ed_ad = (mapl8_alhl*(dqstko/mapl8_cp)+1.0)*t_ed_ad
          CALL POPREAL8(t_ed)
          efactor_ad = efactor_ad + droprad**2*t_ed_ad
          droprad_ad = efactor*2*droprad*t_ed_ad
          diamrn_ad = diamrn_ad + 0.5*droprad_ad
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(efactor)
          temp_ad6 = rho_w*efactor_ad/(rhcr3-rh_box)
          temp_ad7 = -((aa+bb)*temp_ad6/(rhcr3-rh_box))
          aa_ad = aa_ad + temp_ad6
          bb_ad = bb_ad + temp_ad6
          rhcr3_ad = rhcr3_ad + temp_ad7
          rh_box_ad = -temp_ad7
        ELSE
          CALL POPREAL8(efactor)
          rh_box_ad = 0.0_8
        END IF
        CALL POPREAL8(rh_box)
        qko_ad = rh_box_ad/qstko
        qstko_ad = -(qko*rh_box_ad/qstko**2)
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) qstko_ad = 0.0_8
        CALL POPREAL8(qstko)
        qs_ad = qs_ad + qstko_ad
        dqstko_ad = dqstko_ad + (tko-te)*qstko_ad
        tko_ad = dqstko*qstko_ad
        te_ad = te_ad - dqstko*qstko_ad
        dqs_ad = dqs_ad + dqstko_ad
        evap_ad = 0.0_8
        subl_ad = 0.0_8
      END DO
      te_ad = te_ad + tko_ad
      qv_ad = qv_ad + qko_ad
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(qpl)
        CALL POPREAL8(qpi)
        qpl_ad = mapl8_alhf*te_ad/mapl8_cp + qpi_ad
      END IF
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(qpi)
        mltfrz_ad = qpl_ad - mapl8_alhf*te_ad/mapl8_cp - qpi_ad
        CALL POPREAL8(qpl)
        qpi_ad = qpi_ad + mltfrz_ad
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(qpi)
        mltfrz_ad = qpl_ad - mapl8_alhf*te_ad/mapl8_cp - qpi_ad
        CALL POPREAL8(qpl)
        qpi_ad = qpi_ad + mltfrz_ad
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(qpi)
        mltfrz_ad = qpl_ad - mapl8_alhf*te_ad/mapl8_cp - qpi_ad
        CALL POPREAL8(qpl)
        CALL POPREAL8(te)
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          qpi_ad = qpi_ad + mltfrz_ad
          mltfrz_ad = 0.0_8
        END IF
        temp_ad5 = (te-mapl8_tice)*mltfrz_ad/tau_frz
        tinlayersn_ad = tinlayersn_ad + qpi*temp_ad5
        qpi_ad = qpi_ad + tinlayersn*temp_ad5
        te_ad = te_ad + tinlayersn*qpi*mltfrz_ad/tau_frz
      END IF
      temp_ad2 = tinlayerrn_ad/(fallrn+0.01)
      temp_ad1 = tinlayersn_ad/(fallsn+0.01)
      dze_ad = dze_ad + temp_ad2 + temp_ad1
      fallsn_ad = -(dze*temp_ad1/(fallsn+0.01))
      fallrn_ad = -(dze*temp_ad2/(fallrn+0.01))
      CALL POPREAL8(diamsn)
      CALL MARSHPALMQ2_ADM(snowrat0, snowrat0_ad, pl, diamsn, diamsn_ad&
&                    , nsnow, fallsn, fallsn_ad, vesn, vesn_ad)
      CALL POPREAL8(diamrn)
      CALL MARSHPALMQ2_ADM(rainrat0, rainrat0_ad, pl, diamrn, diamrn_ad&
&                    , nrain, fallrn, fallrn_ad, vern, vern_ad)
      temp_ad3 = mass*snowrat0_ad/dt
      qpi_ad = qpi_ad + ifactor*temp_ad3
      temp_ad4 = mass*rainrat0_ad/dt
      ifactor_ad = qpl*temp_ad4 + qpi*temp_ad3
      qpl_ad = qpl_ad + ifactor*temp_ad4
      CALL POPREAL8(te)
      accr_ad = qpi_ad - qcl_ad + mapl8_alhf*te_ad/mapl8_cp
      CALL POPREAL8(qpi)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        qcl_ad = qcl_ad + accr_ad
        accr_ad = 0.0_8
      END IF
      temp_ad0 = b_sub*c_acc*mass*accr_ad
      qpi_ad = qpi_ad + qcl*temp_ad0
      qcl_ad = qcl_ad + qpi*temp_ad0
      CALL POPREAL8(qcl)
      accr_ad = qpl_ad - qcl_ad
      CALL POPREAL8(qpl)
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        qcl_ad = qcl_ad + accr_ad
        accr_ad = 0.0_8
      END IF
      temp_ad = b_sub*c_acc*mass*accr_ad
      qpl_ad = qpl_ad + qcl*temp_ad
      qcl_ad = qcl_ad + qpl*temp_ad
      CALL POPREAL8(qpi)
      pfi_above_ad = imass*qpi_ad
      CALL POPREAL8(qpl)
      pfl_above_ad = imass*qpl_ad
    END IF
    CALL DQSATSCAPERT_ADM(dqs, dqs_ad, qs, qs_ad, te, te_ad, pl)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) ifactor_ad = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      area_ad = 0.0_8
    ELSE
      area_ad = -(ifactor_ad/area**2)
    END IF
    CALL POPCONTROL1B(branch)
  END SUBROUTINE PRECIP3_ADM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device)   &
!#endif
!         RAIN         , & 
!         SNOW         , &
!         REVAP_DIAG   , &
!         RSUBL_DIAG   , &
!         ACRLL_DIAG        , &
!         ACRIL_DIAG        , &
!         PFL_DIAG     , &
!         PFI_DIAG     , &
!         VFALLRN      , &
!         VFALLSN      , &
!         FRZ_DIAG     , &
  SUBROUTINE PRECIP3(k, lm, dt, frland, rhcr3, qpl, qpi, qcl, qci, te, &
&   qv, mass, imass, pl, dze, qddf3, aa, bb, area, pfl_above, pfi_above&
&   , evap_dd_above, subl_dd_above, envfc, ddrfc)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: k, lm
    REAL*8, INTENT(IN) :: dt
    REAL*8, INTENT(INOUT) :: qv, qpl, qpi, qcl, qci, te
    REAL*8, INTENT(IN) :: mass, imass
    REAL*8, INTENT(IN) :: pl
    REAL*8, INTENT(IN) :: aa, bb
    REAL*8, INTENT(IN) :: rhcr3
    REAL*8, INTENT(IN) :: dze
    REAL*8, INTENT(IN) :: qddf3
!      real(8), intent(  out) :: RAIN,SNOW
    REAL*8, INTENT(IN) :: area
    REAL*8, INTENT(IN) :: frland
    REAL*8, INTENT(INOUT) :: pfl_above, pfi_above
    REAL*8, INTENT(INOUT) :: evap_dd_above, subl_dd_above
!      real(8), intent(  out) :: REVAP_DIAG
!      real(8), intent(  out) :: RSUBL_DIAG
!      real(8), intent(  out) :: ACRLL_DIAG,ACRIL_DIAG
!      real(8), intent(  out) :: PFL_DIAG, PFI_DIAG
!      real(8), intent(inout) :: FRZ_DIAG
!      real(8), intent(  out) :: VFALLSN, VFALLRN
    REAL*8, INTENT(IN) :: envfc, ddrfc
    REAL*8 :: pfi, pfl, qs, dqs, envfrac
    REAL*8 :: tko, qko, qstko, dqstko, rh_box, t_ed, qplko, qpiko
    REAL*8 :: ifactor, rainrat0, snowrat0
    REAL*8 :: fallrn, fallsn, vesn, vern, nrain, nsnow, efactor
    REAL*8 :: tinlayerrn, diamrn, droprad
    REAL*8 :: tinlayersn, diamsn, flakrad
    REAL*8 :: evap, subl, accr, mltfrz, evapx, sublx
    REAL*8 :: evap_dd, subl_dd, ddfract
    REAL*8 :: landseaf
! m/s
    REAL*8, PARAMETER :: trmv_l=1.0
    REAL*8 :: tau_frz, tau_mlt
    INTEGER :: ns, nsmx, itr, l
    LOGICAL, PARAMETER :: taneff=.false.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! fraction of precip falling through "environment" vs
! through cloud
    REAL*8, PARAMETER :: b_sub=1.00
    INTRINSIC TAN
    INTRINSIC ATAN
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC EXP
    IF (taneff) THEN
      envfrac = 1.00
      IF (pl .LE. 600.) THEN
        envfrac = 0.25
      ELSE
        envfrac = 0.25 + (1.-0.25)/19.*((ATAN((2.*(pl-600.)/(900.-600.)-&
&         1.)*TAN(20.*mapl8_pi/21.-0.5*mapl8_pi))+0.5*mapl8_pi)*21./&
&         mapl8_pi-1.)
      END IF
      IF (envfrac .GT. 1.) THEN
        envfrac = 1.
      ELSE
        envfrac = envfrac
      END IF
    ELSE
      envfrac = envfc
    END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    IF (area .GT. 0.) THEN
      ifactor = 1./area
    ELSE
      ifactor = 1.00
    END IF
    IF (ifactor .LT. 1.) THEN
      ifactor = 1.
    ELSE
      ifactor = ifactor
    END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!   Start at top of precip column:
!  
!               a) Accrete                   
!               b) Evaporate/Sublimate  
!               c) Rain/Snow-out to next level down 
!               d) return to (a)
!
!   ....................................................................
!           
!  Accretion formulated according to Smith (1990, Q.J.R.M.S., 116, 435
!  Eq. 2.29)
!  
!  Evaporation (ibid. Eq. 2.32)
!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! INITIALIZE DIAGNOSTIC ARRAYS !!!!!!!!!!!!!!!!!!!!!
!      PFL_DIAG =  0.
!      PFI_DIAG =  0.
!      ACRIL_DIAG    =  0.
!      ACRLL_DIAG    =  0.
!      REVAP_DIAG    =  0.
!      RSUBL_DIAG    =  0.
!!!!!!!!!!!!!! UPDATE SATURATED HUMIDITY  !!!!!!!!!!!!!
    CALL DQSATSCAPERT(dqs, qs, te, pl)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    ddfract = ddrfc
    IF (k .EQ. ktop) THEN
      pfl = qpl*mass
      pfi = qpi*mass
      evap_dd = 0.
      subl_dd = 0.
!         VFALLRN = 0.0
!         VFALLSN = 0.0
    ELSE
      qpl = qpl + pfl_above*imass
      pfl = 0.00
      qpi = qpi + pfi_above*imass
      pfi = 0.00
      accr = b_sub*c_acc*(qpl*mass)*qcl
      IF (accr .GT. qcl) THEN
        accr = qcl
      ELSE
        accr = accr
      END IF
      qpl = qpl + accr
      qcl = qcl - accr
!         ACRLL_DIAG = ACCR / DT
!! Accretion of liquid condensate by falling ice/snow
      accr = b_sub*c_acc*(qpi*mass)*qcl
      IF (accr .GT. qcl) THEN
        accr = qcl
      ELSE
        accr = accr
      END IF
      qpi = qpi + accr
      qcl = qcl - accr
!! Liquid freezes when accreted by snow
      te = te + mapl8_alhf*accr/mapl8_cp
!        ACRIL_DIAG = ACCR / DT
      rainrat0 = ifactor*qpl*mass/dt
      snowrat0 = ifactor*qpi*mass/dt
      CALL MARSHPALMQ2(rainrat0, pl, diamrn, nrain, fallrn, vern)
      CALL MARSHPALMQ2(snowrat0, pl, diamsn, nsnow, fallsn, vesn)
!!      DIAMsn = MAX(  DIAMsn, 1.0e-3 )   ! Over Ocean
!         VFALLRN = FALLrn
!         VFALLSN = FALLsn
      tinlayerrn = dze/(fallrn+0.01)
      tinlayersn = dze/(fallsn+0.01)
!*****************************************
!  Melting of Frozen precipitation      
!*****************************************
! time scale for freezing (s). 
      tau_frz = 5000.
      mltfrz = 0.0
      IF (te .GT. mapl8_tice .AND. te .LE. mapl8_tice + 5.) THEN
        mltfrz = tinlayersn*qpi*(te-mapl8_tice)/tau_frz
        IF (qpi .GT. mltfrz) THEN
          mltfrz = mltfrz
        ELSE
          mltfrz = qpi
        END IF
        te = te - mapl8_alhf*mltfrz/mapl8_cp
        qpl = qpl + mltfrz
        qpi = qpi - mltfrz
      END IF
!         FRZ_DIAG = FRZ_DIAG - MLTFRZ / DT
      mltfrz = 0.0
      IF (te .GT. mapl8_tice + 5.) THEN
! Go Ahead and melt any snow/hail left above 5 C 
        mltfrz = qpi
        te = te - mapl8_alhf*mltfrz/mapl8_cp
        qpl = qpl + mltfrz
        qpi = qpi - mltfrz
      END IF
!         FRZ_DIAG = FRZ_DIAG - MLTFRZ / DT
      mltfrz = 0.0
      IF (k .GE. lm - 1) THEN
        IF (te .GT. mapl8_tice + 0.) THEN
! Go Ahead and melt any snow/hail left above 0 C in lowest layers 
          mltfrz = qpi
          te = te - mapl8_alhf*mltfrz/mapl8_cp
          qpl = qpl + mltfrz
          qpi = qpi - mltfrz
        END IF
      END IF
!         FRZ_DIAG = FRZ_DIAG - MLTFRZ / DT
!*****************************************
!  Freezing of liquid precipitation      
!*****************************************
      mltfrz = 0.0
      IF (te .LE. mapl8_tice) THEN
        te = te + mapl8_alhf*qpl/mapl8_cp
        qpi = qpl + qpi
        mltfrz = qpl
        qpl = 0.
      END IF
!         FRZ_DIAG = FRZ_DIAG + MLTFRZ / DT
! ******************************************
!   In the exp below, evaporation time 
!   scale is determined "microphysically"
!   from temp, press, and drop size. In this
!   context C_EV becomes a dimensionless 
!   fudge-fraction.
!   Also remember that these microphysics 
!   are still only for liquid.
! ******************************************
      qko = qv
      tko = te
      qplko = qpl
      qpiko = qpi
      DO itr=1,3
        dqstko = dqs
        qstko = qs + dqstko*(tko-te)
        IF (qstko .LT. 1.0e-7) THEN
          qstko = 1.0e-7
        ELSE
          qstko = qstko
        END IF
        rh_box = qko/qstko
        qko = qv
        tko = te
        IF (rh_box .LT. rhcr3) THEN
          efactor = rho_w*(aa+bb)/(rhcr3-rh_box)
        ELSE
          efactor = 9.99e9
        END IF
        IF (frland .LT. 0.1) THEN
! Over Ocean
          landseaf = 0.5
        ELSE
! Over Land
          landseaf = 0.5
        END IF
        landseaf = 1.00
!!!!! RAin falling !!!!!!!!!!!!!!!!!!!!!!!
        IF (rh_box .LT. rhcr3 .AND. diamrn .GT. 0.00 .AND. pl .GT. 100. &
&           .AND. pl .LT. revap_off_p) THEN
          droprad = 0.5*diamrn
          t_ed = efactor*droprad**2
          t_ed = t_ed*(1.0+dqstko*mapl8_alhl/mapl8_cp)
          evap = qpl*(1.0-EXP(-(c_ev_r*vern*landseaf*envfrac*tinlayerrn/&
&           t_ed)))
        ELSE
          evap = 0.0
        END IF
!!!!! Snow falling !!!!!!!!!!!!!!!!!!!!!!!
        IF (rh_box .LT. rhcr3 .AND. diamsn .GT. 0.00 .AND. pl .GT. 100. &
&           .AND. pl .LT. revap_off_p) THEN
          flakrad = 0.5*diamsn
          t_ed = efactor*flakrad**2
          t_ed = t_ed*(1.0+dqstko*mapl8_alhs/mapl8_cp)
          subl = qpi*(1.0-EXP(-(c_ev_s*vesn*landseaf*envfrac*tinlayersn/&
&           t_ed)))
        ELSE
          subl = 0.0
        END IF
        IF (itr .EQ. 1) THEN
          evapx = evap
          sublx = subl
        ELSE
          evap = (evap+evapx)/2.0
          subl = (subl+sublx)/2.0
        END IF
        qko = qv + evap + subl
        tko = te - evap*mapl8_alhl/mapl8_cp - subl*mapl8_alhs/mapl8_cp
      END DO
      qpi = qpi - subl
      qpl = qpl - evap
!! Put some re-evap/re-subl precip in to a \quote{downdraft} to be applied later
      evap_dd = evap_dd_above + ddfract*evap*mass
      evap = evap - ddfract*evap
      subl_dd = subl_dd_above + ddfract*subl*mass
      subl = subl - ddfract*subl
! -----
      qv = qv + evap + subl
      te = te - evap*mapl8_alhl/mapl8_cp - subl*mapl8_alhs/mapl8_cp
!         REVAP_DIAG = EVAP / DT
!         RSUBL_DIAG = SUBL / DT
      pfl = qpl*mass
      pfi = qpi*mass
!         PFL_DIAG =  PFl/DT
!         PFI_DIAG =  PFi/DT
    END IF
! QDDF3 (<= QDDF3_dev) is calculated on the CPU in order to avoid
! the reverse loop on GPUs and thus save local memory use.
    evap = qddf3*evap_dd/mass
    subl = qddf3*subl_dd/mass
    qv = qv + evap + subl
    te = te - evap*mapl8_alhl/mapl8_cp - subl*mapl8_alhs/mapl8_cp
!      REVAP_DIAG = REVAP_DIAG + EVAP / DT
!      RSUBL_DIAG = RSUBL_DIAG + SUBL / DT
!      IF (K == LM) THEN
!         RAIN  = PFl/DT
!         SNOW  = PFi/DT
!      END IF
    qpi = 0.
    qpl = 0.
    pfl_above = pfl
    pfi_above = pfi
    evap_dd_above = evap_dd
    subl_dd_above = subl_dd
  END SUBROUTINE PRECIP3
!  Differentiation of icefall in reverse (adjoint) mode (with options r8 split(GEOS_MoistGridComp.PRE_PROGNO_CLOUD)):
!   gradient     of useful results: f qi qp dz
!   with respect to varying inputs: f qi dz vf
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE ICEFALL_ADM(qi, qi_ad, dz, dz_ad, qp, qp_ad, vf, vf_ad, f, &
&   f_ad, dt, fraction_removal)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: fraction_removal
    REAL*8, INTENT(INOUT) :: qi
    REAL*8 :: qi_ad
    REAL*8, INTENT(IN) :: dz
    REAL*8 :: dz_ad
    REAL*8, INTENT(INOUT) :: qp
    REAL*8 :: qp_ad
    REAL*8, INTENT(IN) :: vf
    REAL*8 :: vf_ad
    REAL*8, INTENT(INOUT) :: f
    REAL*8 :: f_ad
    REAL*8, INTENT(IN) :: dt
    REAL*8 :: qixp
    REAL*8 :: qixp_ad
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC SQRT
    INTEGER :: branch
    REAL*8 :: temp1
    REAL*8 :: temp0
    REAL*8 :: temp_ad5
    REAL*8 :: temp_ad4
    REAL*8 :: temp_ad3
    REAL*8 :: temp_ad2
    REAL*8 :: temp_ad1
    REAL*8 :: temp_ad0
    REAL*8 :: temp_ad
    REAL*8 :: temp
    qixp = qi*(vf*dt/dz)
    IF (qixp .GT. qi) THEN
      qixp = qi
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      qixp = qixp
    END IF
    IF (qixp .LT. 0.0) THEN
      qixp = 0.0
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      qixp = qixp
    END IF
    CALL PUSHREAL8(qi)
    qi = qi - qixp
!SELECT CASE( FRACTION_REMOVAL )
!CASE( 0 )
! do NOTHING
    IF (fraction_removal .EQ. 1) THEN
      IF (qi + qixp .GT. 0.) THEN
        temp_ad0 = f_ad/(qi+qixp)
        temp_ad1 = -(qi*f*temp_ad0/(qi+qixp))
        qi_ad = qi_ad + temp_ad1 + f*temp_ad0
        qixp_ad = temp_ad1
        f_ad = qi*temp_ad0
      ELSE
        qixp_ad = 0.0_8
      END IF
    ELSE IF (fraction_removal .EQ. 2) THEN
      IF (qi + qixp .GT. 0. .AND. qi .GT. 0.) THEN
        temp = qi/(qi+qixp)
        temp0 = SQRT(temp)
        IF (temp .EQ. 0.0_8) THEN
          temp_ad2 = 0.0
        ELSE
          temp_ad2 = f*f_ad/(2.0*temp0*(qi+qixp))
        END IF
        temp_ad3 = -(temp*temp_ad2)
        qi_ad = qi_ad + temp_ad3 + temp_ad2
        qixp_ad = temp_ad3
        f_ad = temp0*f_ad
      ELSE
        qixp_ad = 0.0_8
      END IF
    ELSE IF (fraction_removal .EQ. 3) THEN
      IF (qi + qixp .GT. 0. .AND. qi .GT. 0.) THEN
        temp1 = qi/(qi+qixp)
        temp_ad4 = 0.333*temp1**(-0.667)*f*f_ad/(qi+qixp)
        temp_ad5 = -(temp1*temp_ad4)
        qi_ad = qi_ad + temp_ad5 + temp_ad4
        qixp_ad = temp_ad5
        f_ad = temp1**0.333*f_ad
      ELSE
        qixp_ad = 0.0_8
      END IF
    ELSE
      qixp_ad = 0.0_8
    END IF
    CALL POPREAL8(qi)
    qixp_ad = qixp_ad + qp_ad - qi_ad
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) qixp_ad = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qi_ad = qi_ad + qixp_ad
      qixp_ad = 0.0_8
    END IF
    temp_ad = dt*qixp_ad/dz
    qi_ad = qi_ad + vf*temp_ad
    vf_ad = qi*temp_ad
    dz_ad = dz_ad - qi*vf*temp_ad/dz
  END SUBROUTINE ICEFALL_ADM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE ICEFALL(qi, dz, qp, vf, f, dt, fraction_removal)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: fraction_removal
    REAL*8, INTENT(INOUT) :: qi
    REAL*8, INTENT(IN) :: dz
    REAL*8, INTENT(INOUT) :: qp
    REAL*8, INTENT(IN) :: vf
    REAL*8, INTENT(INOUT) :: f
    REAL*8, INTENT(IN) :: dt
    REAL*8 :: qixp
    INTRINSIC MIN
    INTRINSIC MAX
    INTRINSIC SQRT
    qixp = qi*(vf*dt/dz)
    IF (qixp .GT. qi) THEN
      qixp = qi
    ELSE
      qixp = qixp
    END IF
    IF (qixp .LT. 0.0) THEN
      qixp = 0.0
    ELSE
      qixp = qixp
    END IF
    qp = qp + qixp
    qi = qi - qixp
!SELECT CASE( FRACTION_REMOVAL )
!CASE( 0 )
! do NOTHING
    IF (fraction_removal .EQ. 1) THEN
      IF (qi + qixp .GT. 0.) f = qi*f/(qi+qixp)
    ELSE IF (fraction_removal .EQ. 2) THEN
      IF (qi + qixp .GT. 0. .AND. qi .GT. 0.) f = f*SQRT(qi/(qi+qixp))
    ELSE IF (fraction_removal .EQ. 3) THEN
      IF (qi + qixp .GT. 0. .AND. qi .GT. 0.) f = f*(qi/(qi+qixp))**&
&         0.333
    END IF
  END SUBROUTINE ICEFALL
!  Differentiation of settle_vel in reverse (adjoint) mode (with options r8 split(GEOS_MoistGridComp.PRE_PROGNO_CLOUD)):
!   gradient     of useful results: f qi vf te
!   with respect to varying inputs: f qi te
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE SETTLE_VEL_ADM(wxr, qi, qi_ad, pl, te, te_ad, f, f_ad, kh, &
&   vf, vf_ad, largescale, anvil)
    IMPLICIT NONE
! Arctic stratus options
!if ( KH > 2.0 ) then
!   VF = 0.01 * VF
!end if
!where(PL > 700.)
!  VF = 0.1*VF
!endwhere
!where( (TE >= 250.) .and. (TE<260.))
!  VF =  ( ( -0.75/10.)*(TE-250.) + 1.0 ) * VF
!endwhere
!where(TE >= 260.)
!  VF = 0.25*VF
!endwhere
    REAL*8, INTENT(IN) :: wxr
    REAL*8, INTENT(IN) :: te
    REAL*8 :: te_ad
    REAL*8, INTENT(IN) :: qi, f, pl
    REAL*8 :: qi_ad, f_ad
    REAL*8, INTENT(IN) :: kh
    REAL*8 :: vf
    REAL*8 :: vf_ad
    REAL*8, INTENT(IN) :: anvil, largescale
    REAL*8 :: rho, xim, lxim, vf_a, vf_l
    REAL*8 :: rho_ad, xim_ad, lxim_ad, vf_a_ad, vf_l_ad
    INTRINSIC LOG10
    INTRINSIC ABS
    INTRINSIC MAX
    INTEGER :: branch
    REAL*8 :: temp_ad
    REAL*8 :: abs0
    REAL*8 :: max1
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
! Uses Eq. 1 Lawrence and Crutzen (1998, Tellus 50B, 263-289) 
! Except midlat form is taken to be for LS cloud, and tropical
! form is taken to be for ANVIL cloud
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 1000 TAKES TO g m^-3 ; 100 takes mb TO Pa
    rho = 1000.*100.*pl/(mapl8_rgas*te)
    IF (f .GT. 0. .AND. qi .GT. 0.) THEN
      xim = qi/f*rho
      CALL PUSHCONTROL1B(0)
    ELSE
      xim = 0.
      CALL PUSHCONTROL1B(1)
    END IF
    IF (xim .GT. 0.) THEN
      lxim = LOG10(xim)
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
      lxim = 0.0
    END IF
! Tropical ANVIL produced by resolved scale motions
! Mid-latitude cirrus
    IF (xim .GE. 0.) THEN
      abs0 = xim
    ELSE
      abs0 = -xim
    END IF
    IF (abs0 .GT. 0.0) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! Combine the two
! Reduce/increase fall speeds for high/low pressure (NOT in LC98!!! ) 
! Assume unmodified they represent situation at 100 mb
    IF (wxr .GT. 0.) THEN
      IF (pl .LT. 10.) THEN
        max1 = 10.
      ELSE
        max1 = pl
      END IF
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (kh .GT. 2.0) vf_ad = 0.01*vf_ad
    vf_ad = vf_ad/100.
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) vf_ad = (100./max1)**wxr*vf_ad
    vf_a_ad = anvil*vf_ad
    vf_l_ad = largescale*vf_ad
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      xim_ad = 109.0*0.16*xim**(-0.84)*vf_l_ad
    ELSE
      xim_ad = 0.0_8
    END IF
    lxim_ad = (5.5*2*lxim+53.2)*vf_a_ad
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) xim_ad = xim_ad + lxim_ad/(xim*LOG(10.0))
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      temp_ad = xim_ad/f
      qi_ad = qi_ad + rho*temp_ad
      rho_ad = qi*temp_ad
      f_ad = f_ad - qi*rho*temp_ad/f
    ELSE
      rho_ad = 0.0_8
    END IF
    te_ad = te_ad - pl*100.*1000.*rho_ad/(mapl8_rgas*te**2)
  END SUBROUTINE SETTLE_VEL_ADM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE SETTLE_VEL(wxr, qi, pl, te, f, kh, vf, largescale, anvil)
    IMPLICIT NONE
! Arctic stratus options
!if ( KH > 2.0 ) then
!   VF = 0.01 * VF
!end if
!where(PL > 700.)
!  VF = 0.1*VF
!endwhere
!where( (TE >= 250.) .and. (TE<260.))
!  VF =  ( ( -0.75/10.)*(TE-250.) + 1.0 ) * VF
!endwhere
!where(TE >= 260.)
!  VF = 0.25*VF
!endwhere
    REAL*8, INTENT(IN) :: wxr
    REAL*8, INTENT(IN) :: te
    REAL*8, INTENT(IN) :: qi, f, pl
    REAL*8, INTENT(IN) :: kh
    REAL*8, INTENT(OUT) :: vf
    REAL*8, INTENT(IN) :: anvil, largescale
    REAL*8 :: rho, xim, lxim, vf_a, vf_l
    INTRINSIC LOG10
    INTRINSIC ABS
    INTRINSIC MAX
    REAL*8 :: abs0
    REAL*8 :: max1
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
! Uses Eq. 1 Lawrence and Crutzen (1998, Tellus 50B, 263-289) 
! Except midlat form is taken to be for LS cloud, and tropical
! form is taken to be for ANVIL cloud
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
! 1000 TAKES TO g m^-3 ; 100 takes mb TO Pa
    rho = 1000.*100.*pl/(mapl8_rgas*te)
    IF (f .GT. 0. .AND. qi .GT. 0.) THEN
      xim = qi/f*rho
    ELSE
      xim = 0.
    END IF
    IF (xim .GT. 0.) THEN
      lxim = LOG10(xim)
    ELSE
      lxim = 0.0
    END IF
! Tropical ANVIL produced by resolved scale motions
    vf_a = 128.6 + 53.2*lxim + 5.5*lxim**2
! Mid-latitude cirrus
    vf_l = 109.0*xim**0.16
    IF (xim .GE. 0.) THEN
      abs0 = xim
    ELSE
      abs0 = -xim
    END IF
    IF (abs0 .GT. 0.0) THEN
!Linearisation security
      vf_l = 109.0*xim**0.16
    ELSE
      vf_l = 0.0
    END IF
! Combine the two
    vf = anvil*vf_a + largescale*vf_l
! Reduce/increase fall speeds for high/low pressure (NOT in LC98!!! ) 
! Assume unmodified they represent situation at 100 mb
    IF (wxr .GT. 0.) THEN
      IF (pl .LT. 10.) THEN
        max1 = 10.
      ELSE
        max1 = pl
      END IF
      vf = vf*(100./max1)**wxr
    END IF
    vf = vf/100.
    IF (kh .GT. 2.0) vf = 0.01*vf
  END SUBROUTINE SETTLE_VEL
!  Differentiation of marshpalmq2 in reverse (adjoint) mode (with options r8 split(GEOS_MoistGridComp.PRE_PROGNO_CLOUD)):
!   gradient     of useful results: diam3 w ve
!   with respect to varying inputs: rain
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE MARSHPALMQ2_ADM(rain, rain_ad, pr, diam3, diam3_ad, ntotal&
&   , w, w_ad, ve, ve_ad)
    IMPLICIT NONE
! in kg m**-2 s**-1, mbar
    REAL*8, INTENT(IN) :: rain, pr
    REAL*8 :: rain_ad
    REAL*8 :: diam3, ntotal, w, ve
    REAL*8 :: diam3_ad, w_ad, ve_ad
    REAL*8 :: rain_day, lambda, a, b, slopr, diam1
    REAL*8 :: rain_day_ad
! # cm**-3
    REAL*8, PARAMETER :: n0=0.08
    INTEGER :: iqd
    REAL*8 :: rx(8), d3x(8)
    INTRINSIC SQRT
    INTRINSIC MAX
    INTEGER :: branch
! Marshall-Palmer sizes at different rain-rates: avg(D^3)
!RX = (/ 0.   , 5.   , 20.  , 80.  , 320. , 1280., 4*1280., 16*1280. /)  ! rain per in mm/day
    rx(1) = 0.
    rx(2) = 5.
    rx(3) = 20.
    rx(4) = 80.
    rx(5) = 320.
    rx(6) = 1280.
    rx(7) = 4*1280.
    rx(8) = 16*1280.
!D3X= (/ 0.019, 0.032, 0.043, 0.057, 0.076, 0.102, 0.137  ,  0.183   /)
    d3x(1) = 0.019
    d3x(2) = 0.032
    d3x(3) = 0.043
    d3x(4) = 0.057
    d3x(5) = 0.076
    d3x(6) = 0.102
    d3x(7) = 0.137
    d3x(8) = 0.183
    rain_day = rain*3600.*24.
    IF (rain_day .LE. 0.00) diam3 = 0.00
    DO iqd=1,7
      IF (rain_day .LE. rx(iqd+1) .AND. rain_day .GT. rx(iqd)) THEN
        CALL PUSHREAL8(slopr)
        slopr = (d3x(iqd+1)-d3x(iqd))/(rx(iqd+1)-rx(iqd))
        diam3 = d3x(iqd) + (rain_day-rx(iqd))*slopr
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    IF (rain_day .GE. rx(8)) THEN
      diam3 = d3x(8)
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!  DRYING/EVAP SHOULD PROBABLY GO AS          !!
    diam3 = 0.664*diam3
!!  D_1.5 == <<D^(3/2)>>^(2/3) NOT AS          !!
!!  D_3   == <<D^3>>^(1/3)                     !!
!!  RATIO D_1.5/D_3 =~ 0.66  (JTB 10/17/2002)  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    w = (2483.8*diam3+80.)*SQRT(1000./pr)
    IF (0.99*w/100. .LT. 1.000) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    w_ad = w_ad/100.
    diam3_ad = diam3_ad/100.
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) w_ad = w_ad + 0.99*ve_ad/100.
    diam3_ad = diam3_ad + SQRT(1000./pr)*2483.8*w_ad
    diam3_ad = 0.664*diam3_ad
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) diam3_ad = 0.0_8
    rain_day_ad = 0.0_8
    DO iqd=7,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        rain_day_ad = rain_day_ad + slopr*diam3_ad
        CALL POPREAL8(slopr)
        diam3_ad = 0.0_8
      END IF
    END DO
    rain_ad = 24.*3600.*rain_day_ad
  END SUBROUTINE MARSHPALMQ2_ADM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE MARSHPALMQ2(rain, pr, diam3, ntotal, w, ve)
    IMPLICIT NONE
! in kg m**-2 s**-1, mbar
    REAL*8, INTENT(IN) :: rain, pr
    REAL*8, INTENT(OUT) :: diam3, ntotal, w, ve
    REAL*8 :: rain_day, lambda, a, b, slopr, diam1
! # cm**-3
    REAL*8, PARAMETER :: n0=0.08
    INTEGER :: iqd
    REAL*8 :: rx(8), d3x(8)
    INTRINSIC SQRT
    INTRINSIC MAX
! Marshall-Palmer sizes at different rain-rates: avg(D^3)
!RX = (/ 0.   , 5.   , 20.  , 80.  , 320. , 1280., 4*1280., 16*1280. /)  ! rain per in mm/day
    rx(1) = 0.
    rx(2) = 5.
    rx(3) = 20.
    rx(4) = 80.
    rx(5) = 320.
    rx(6) = 1280.
    rx(7) = 4*1280.
    rx(8) = 16*1280.
!D3X= (/ 0.019, 0.032, 0.043, 0.057, 0.076, 0.102, 0.137  ,  0.183   /)
    d3x(1) = 0.019
    d3x(2) = 0.032
    d3x(3) = 0.043
    d3x(4) = 0.057
    d3x(5) = 0.076
    d3x(6) = 0.102
    d3x(7) = 0.137
    d3x(8) = 0.183
    rain_day = rain*3600.*24.
    IF (rain_day .LE. 0.00) THEN
      diam1 = 0.00
      diam3 = 0.00
      ntotal = 0.00
      w = 0.00
    END IF
    DO iqd=1,7
      IF (rain_day .LE. rx(iqd+1) .AND. rain_day .GT. rx(iqd)) THEN
        slopr = (d3x(iqd+1)-d3x(iqd))/(rx(iqd+1)-rx(iqd))
        diam3 = d3x(iqd) + (rain_day-rx(iqd))*slopr
      END IF
    END DO
    IF (rain_day .GE. rx(8)) diam3 = d3x(8)
    ntotal = 0.019*diam3
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!  DRYING/EVAP SHOULD PROBABLY GO AS          !!
    diam3 = 0.664*diam3
!!  D_1.5 == <<D^(3/2)>>^(2/3) NOT AS          !!
!!  D_3   == <<D^3>>^(1/3)                     !!
!!  RATIO D_1.5/D_3 =~ 0.66  (JTB 10/17/2002)  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    w = (2483.8*diam3+80.)*SQRT(1000./pr)
    IF (0.99*w/100. .LT. 1.000) THEN
      ve = 1.000
    ELSE
      ve = 0.99*w/100.
    END IF
    diam1 = 3.0*diam3
!  Change back to MKS units
    diam1 = diam1/100.
    diam3 = diam3/100.
    w = w/100.
    ntotal = ntotal*1.0e6
  END SUBROUTINE MARSHPALMQ2
!  Differentiation of micro_aa_bb_3 in reverse (adjoint) mode (with options r8 split(GEOS_MoistGridComp.PRE_PROGNO_CLOUD)):
!   gradient     of useful results: aa temp bb q_sat
!   with respect to varying inputs: temp q_sat
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE MICRO_AA_BB_3_ADM(temp, temp_ad1, pr, q_sat, q_sat_ad, aa, &
&   aa_ad, bb, bb_ad)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: temp, q_sat
    REAL*8 :: temp_ad1, q_sat_ad
    REAL*8, INTENT(IN) :: pr
    REAL*8 :: aa, bb
    REAL*8 :: aa_ad, bb_ad
    REAL*8 :: e_sat
    REAL*8 :: e_sat_ad
    REAL*8, PARAMETER :: epsilon=mapl8_h2omw/mapl8_airmw
! J m**-1 s**-1 K**-1
    REAL*8, PARAMETER :: k_cond=2.4e-2
! m**2 s**-1
    REAL*8, PARAMETER :: diffu=2.2e-5
    REAL*8 :: result1
    REAL*8 :: result1_ad
    REAL*8 :: temp2
    REAL*8 :: temp1
    REAL*8 :: temp0
    REAL*8 :: temp_ad0
    REAL*8 :: temp_ad
! (100 converts from mbar to Pa)
    e_sat = 100.*pr*q_sat/(epsilon+(1.0-epsilon)*q_sat)
    result1 = GET_ALHX3(temp)
! AA  = ( MAPL8_ALHL**2 ) / ( K_COND*MAPL8_RVAP*(TEMP**2) )
    temp1 = k_cond*mapl8_rvap*temp**2
    temp2 = 1000.*diffu*e_sat
    temp_ad = mapl8_rvap*pr*bb_ad/temp2
    temp_ad1 = temp_ad1 + temp_ad - k_cond*mapl8_rvap*result1**2*2*temp*&
&     aa_ad/temp1**2
    e_sat_ad = -(temp*diffu*1000.*temp_ad/temp2)
    result1_ad = 2*result1*aa_ad/temp1
    CALL GET_ALHX3_ADM(temp, temp_ad1, result1_ad)
    temp0 = epsilon + (-epsilon+1.0)*q_sat
    temp_ad0 = pr*100.*e_sat_ad/temp0
    q_sat_ad = q_sat_ad + (1.0_8-q_sat*(1.0-epsilon)/temp0)*temp_ad0
  END SUBROUTINE MICRO_AA_BB_3_ADM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE MICRO_AA_BB_3(temp, pr, q_sat, aa, bb)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: temp, q_sat
    REAL*8, INTENT(IN) :: pr
    REAL*8, INTENT(OUT) :: aa, bb
    REAL*8 :: e_sat
    REAL*8, PARAMETER :: epsilon=mapl8_h2omw/mapl8_airmw
! J m**-1 s**-1 K**-1
    REAL*8, PARAMETER :: k_cond=2.4e-2
! m**2 s**-1
    REAL*8, PARAMETER :: diffu=2.2e-5
    REAL*8 :: result1
! (100 converts from mbar to Pa)
    e_sat = 100.*pr*q_sat/(epsilon+(1.0-epsilon)*q_sat)
    result1 = GET_ALHX3(temp)
    aa = result1**2/(k_cond*mapl8_rvap*temp**2)
! AA  = ( MAPL8_ALHL**2 ) / ( K_COND*MAPL8_RVAP*(TEMP**2) )
    bb = mapl8_rvap*temp/(diffu*(1000./pr)*e_sat)
  END SUBROUTINE MICRO_AA_BB_3
!  Differentiation of ldradius3 in reverse (adjoint) mode (with options r8 split(GEOS_MoistGridComp.PRE_PROGNO_CLOUD)):
!   gradient     of useful results: radius te
!   with respect to varying inputs: qcl te
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE LDRADIUS3_ADM(pl, te, te_ad, qcl, qcl_ad, nn, radius_ad)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: te, pl, nn, qcl
    REAL*8 :: te_ad, qcl_ad
    REAL*8 :: radius
    REAL*8 :: radius_ad
    REAL*8 :: muu, rho
    REAL*8 :: muu_ad, rho_ad
    rho = 100.*pl/(mapl8_rgas*te)
    muu = qcl*rho
    radius = muu/(nn*rho_w*(4./3.)*mapl8_pi)
! Equiv. Spherical Cloud Particle Radius in m
    IF (radius .LE. 0.0_8 .AND. (1.0/3. .EQ. 0.0_8 .OR. 1.0/3. .NE. INT(&
&       1.0/3.))) THEN
      radius_ad = 0.0
    ELSE
      radius_ad = radius**(1.0/3.-1)*radius_ad/3.
    END IF
    muu_ad = 3.*radius_ad/(nn*4.*rho_w*mapl8_pi)
    qcl_ad = rho*muu_ad
    rho_ad = qcl*muu_ad
    te_ad = te_ad - pl*100.*rho_ad/(mapl8_rgas*te**2)
  END SUBROUTINE LDRADIUS3_ADM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  FUNCTION LDRADIUS3(pl, te, qcl, nn) RESULT (RADIUS)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: te, pl, nn, qcl
    REAL*8 :: radius
    REAL*8 :: muu, rho
    rho = 100.*pl/(mapl8_rgas*te)
    muu = qcl*rho
    radius = muu/(nn*rho_w*(4./3.)*mapl8_pi)
! Equiv. Spherical Cloud Particle Radius in m
    radius = radius**(1./3.)
  END FUNCTION LDRADIUS3
!  Differentiation of ice_fraction in reverse (adjoint) mode (with options r8 split(GEOS_MoistGridComp.PRE_PROGNO_CLOUD)):
!   gradient     of useful results: temp icefrct
!   with respect to varying inputs: temp
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE ICE_FRACTION_ADM(temp, temp_ad, icefrct_ad)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: temp
    REAL*8 :: temp_ad
    REAL*8 :: icefrct
    REAL*8 :: icefrct_ad
    INTRINSIC MIN
    INTRINSIC MAX
    INTEGER :: branch
    icefrct = 0.00
    IF (temp .LE. t_ice_all) THEN
      CALL PUSHCONTROL2B(2)
      icefrct = 1.000
    ELSE IF (temp .GT. t_ice_all .AND. temp .LE. t_ice_max) THEN
      icefrct = 1.00 - (temp-t_ice_all)/(t_ice_max-t_ice_all)
      CALL PUSHCONTROL2B(1)
    ELSE
      CALL PUSHCONTROL2B(0)
    END IF
    IF (icefrct .GT. 1.00) THEN
      icefrct = 1.00
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      icefrct = icefrct
    END IF
    IF (icefrct .LT. 0.00) THEN
      icefrct = 0.00
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      icefrct = icefrct
    END IF
    IF (icefrct .LE. 0.0_8 .AND. (icefrpwr .EQ. 0.0_8 .OR. icefrpwr .NE.&
&       INT(icefrpwr))) THEN
      icefrct_ad = 0.0
    ELSE
      icefrct_ad = icefrpwr*icefrct**(icefrpwr-1)*icefrct_ad
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) icefrct_ad = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) icefrct_ad = 0.0_8
    CALL POPCONTROL2B(branch)
    IF (branch .NE. 0) THEN
      IF (branch .EQ. 1) temp_ad = temp_ad - icefrct_ad/(t_ice_max-&
&         t_ice_all)
    END IF
  END SUBROUTINE ICE_FRACTION_ADM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  FUNCTION ICE_FRACTION(temp) RESULT (ICEFRCT)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: temp
    REAL*8 :: icefrct
    INTRINSIC MIN
    INTRINSIC MAX
    icefrct = 0.00
    IF (temp .LE. t_ice_all) THEN
      icefrct = 1.000
    ELSE IF (temp .GT. t_ice_all .AND. temp .LE. t_ice_max) THEN
      icefrct = 1.00 - (temp-t_ice_all)/(t_ice_max-t_ice_all)
    END IF
    IF (icefrct .GT. 1.00) THEN
      icefrct = 1.00
    ELSE
      icefrct = icefrct
    END IF
    IF (icefrct .LT. 0.00) THEN
      icefrct = 0.00
    ELSE
      icefrct = icefrct
    END IF
!!ICEFRCT = ICEFRCT**4
    icefrct = icefrct**icefrpwr
  END FUNCTION ICE_FRACTION
!  Differentiation of get_alhx3 in reverse (adjoint) mode (with options r8 split(GEOS_MoistGridComp.PRE_PROGNO_CLOUD)):
!   gradient     of useful results: t alhx3
!   with respect to varying inputs: t
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE GET_ALHX3_ADM(t, t_ad, alhx3_ad)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t
    REAL*8 :: t_ad
    REAL*8 :: alhx3
    REAL*8 :: alhx3_ad
    REAL*8 :: t_x
    t_x = t_ice_max
    IF (t .LE. t_x .AND. t .GE. t_ice_all) t_ad = t_ad + (mapl8_alhl-&
&       mapl8_alhs)*alhx3_ad/(t_x-t_ice_all)
  END SUBROUTINE GET_ALHX3_ADM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  FUNCTION GET_ALHX3(t) RESULT (ALHX3)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t
    REAL*8 :: alhx3
    REAL*8 :: t_x
    t_x = t_ice_max
    IF (t .LT. t_ice_all) alhx3 = mapl8_alhs
    IF (t .GT. t_x) alhx3 = mapl8_alhl
    IF (t .LE. t_x .AND. t .GE. t_ice_all) alhx3 = mapl8_alhs + (&
&       mapl8_alhl-mapl8_alhs)*(t-t_ice_all)/(t_x-t_ice_all)
  END FUNCTION GET_ALHX3
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  REAL*8 FUNCTION ICEFRAC(t, t_trans, t_freez)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: t
    REAL*8, INTENT(IN), OPTIONAL :: t_trans
    REAL*8, INTENT(IN), OPTIONAL :: t_freez
    REAL*8 :: t_x, t_f
    INTRINSIC PRESENT
    IF (PRESENT(t_trans)) THEN
      t_x = t_trans
    ELSE
      t_x = t_ice_max
    END IF
    IF (PRESENT(t_freez)) THEN
      t_f = t_freez
    ELSE
      t_f = t_ice_all
    END IF
    IF (t .LT. t_f) icefrac = 1.000
    IF (t .GT. t_x) icefrac = 0.000
    IF (t .LE. t_x .AND. t .GE. t_f) icefrac = 1.00 - (t-t_f)/(t_x-t_f)
  END FUNCTION ICEFRAC
!  Differentiation of sundq3_ice3 in reverse (adjoint) mode (with options r8 split(GEOS_MoistGridComp.PRE_PROGNO_CLOUD)):
!   gradient     of useful results: temp f2
!   with respect to varying inputs: temp
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE SUNDQ3_ICE3_ADM(temp, temp_ad, rate2, rate3, te1, f2, f2_ad&
&   , f3)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: rate2, rate3, te1
    REAL*8, INTENT(IN) :: temp
    REAL*8 :: temp_ad
    REAL*8 :: f2, f3
    REAL*8 :: f2_ad
!,RATE2,RATE3,TE1
    REAL*8 :: xx, yy, te0, te2, jump1
    INTRINSIC MIN
    INTEGER :: branch
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!  Ice - phase treatment totally invented
!!  Sharp increase in autoconversion in range
!!  ~~TE1 K ~< T < TE0 K .
!!  (JTB, 3/25/2003)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    te0 = 273.
!TE1=263.
    te2 = 200.
!RATE2=  10.
    jump1 = (rate2-1.0)/(te0-te1)**0.333
!RATE3=  25.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Ice - phase treatment  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
    IF (temp .GE. te0) f2 = 1.0
    IF (temp .GE. te1 .AND. temp .LT. te0) THEN
      f2 = 1.0 + jump1*(te0-temp)**0.3333
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (temp .LT. te1) THEN
      f2 = rate2 + (rate3-rate2)*(te1-temp)/(te1-te2)
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (f2 .GT. 27.0) f2_ad = 0.0_8
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      temp_ad = temp_ad - (rate3-rate2)*f2_ad/(te1-te2)
      f2_ad = 0.0_8
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) temp_ad = temp_ad - 0.3333*(te0-temp)**(-0.6667)*&
&       jump1*f2_ad
  END SUBROUTINE SUNDQ3_ICE3_ADM
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
  SUBROUTINE SUNDQ3_ICE3(temp, rate2, rate3, te1, f2, f3)
    IMPLICIT NONE
    REAL*8, INTENT(IN) :: rate2, rate3, te1
    REAL*8, INTENT(IN) :: temp
    REAL*8, INTENT(OUT) :: f2, f3
!,RATE2,RATE3,TE1
    REAL*8 :: xx, yy, te0, te2, jump1
    INTRINSIC MIN
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!  Ice - phase treatment totally invented
!!  Sharp increase in autoconversion in range
!!  ~~TE1 K ~< T < TE0 K .
!!  (JTB, 3/25/2003)
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    te0 = 273.
!TE1=263.
    te2 = 200.
!RATE2=  10.
    jump1 = (rate2-1.0)/(te0-te1)**0.333
!RATE3=  25.
!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!  Ice - phase treatment  !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
    IF (temp .GE. te0) THEN
      f2 = 1.0
      f3 = 1.0
    END IF
    IF (temp .GE. te1 .AND. temp .LT. te0) THEN
      f2 = 1.0 + jump1*(te0-temp)**0.3333
      f3 = 1.0
    END IF
    IF (temp .LT. te1) THEN
      f2 = rate2 + (rate3-rate2)*(te1-temp)/(te1-te2)
      f3 = 1.0
    END IF
    IF (f2 .GT. 27.0) THEN
      f2 = 27.0
    ELSE
      f2 = f2
    END IF
  END SUBROUTINE SUNDQ3_ICE3
!  Differentiation of pre_progno_cloud in reverse (adjoint) mode, forward sweep (with options r8 split(GEOS_MoistGridComp.PRE_PRO
!GNO_CLOUD)):
!   gradient     of useful results: qst3 th1 qddf3 dzet
!   with respect to varying inputs: th1
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
!   subroutine RADCOUPLE(  &
!         TE,              & 
!         PL,              & 
!         CF,              & 
!         AF,              & 
!         QClLS,           & 
!         QCiLS,           & 
!         QClAN,           & 
!         QCiAN,           & 
!         QRN_ALL,         & 
!         QSN_ALL,         & 
!         RAD_QL,          &  
!         RAD_QI,          & 
!         RAD_QR,          & 
!         RAD_QS,          & 
!         RAD_CF,          & 
!         RAD_RL,          & 
!         RAD_RI,          & 
!         CLDVOL2FRC,      &          
!         NN_ANVIL,NN_ICE,NN_WARM,&
!         TEMPOR)
!
!      real(8), intent(in ) :: NN_ANVIL,NN_ICE,NN_WARM 
!      real(8), intent(in ) :: CLDVOL2FRC 
!      real(8), intent(in ) :: TE
!      real(8), intent(in ) :: PL
!      real(8), intent(in ) :: AF,CF, QClAN, QCiAN, QClLS, QCiLS
!      real(8), intent(in ) :: QRN_ALL, QSN_ALL
!      real(8), intent(out) :: RAD_QL,RAD_QI,RAD_QR,RAD_QS,RAD_CF,RAD_RL,RAD_RI
!
!      real(8), intent(in )  :: tempor
!
!      real(8) :: RElAN, REiAN, RElLS, REiLS, QCm, NN, ss, RAD_RI_AN
!      real(8) :: QClANm, QCiANm, QClLSm, QCiLSm, QCtot, AFx
!      real(8) :: rampt, rampu, rampp
!
!      real(8) :: ALPH, POLAR_RL
!
!
!      ! Limits on Radii needed to ensure
!      ! correct behavior of cloud optical
!      ! properties currently calculated in 
!      ! sorad and irrad (1e-6 m = micron)
!
!      POLAR_RL=   5.0e-6  ! 11/09/2007 JTB - COLD low level clouds
!
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      ! Adjust Anvil fractions for
!      ! warm clouds
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!   !  Needed for PRECIP Repartition
!   !  -----------------------------
!   !  ALPH =  0.05
!   !  SS   =  (260.-TE)/30.
!   !  SS   =  MIN( 1.0 , SS )
!   !  SS   =  MAX( 0.0 , SS )
!   !  SS   =  ALPH + (SS**3) * ( 1.0 - ALPH )
!   !  AFx  =  AF * SS 
!
!      ALPH =  0.1
!      SS   =  (280.-TE)/20.
!      SS   =  MIN( 1.0 , SS )
!      SS   =  MAX( 0.0 , SS )
!      SS   =  ALPH + (SS**3) * ( 1.0 - ALPH )
!      AFx  =  AF * SS * 0.5
!
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      ! Total cloud fraction
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      RAD_CF = MIN( CF + AFx, 1.00 )
!
!      ! Total In-cloud liquid
!      if ( RAD_CF > 0. ) then
!         RAD_QL = ( QClLS + QClAN ) / RAD_CF
!      else
!         RAD_QL = 0.0
!      end if
!      RAD_QL = MIN( RAD_QL, 0.01 )
!
!      ! Total In-cloud ice
!      if (  RAD_CF >0. ) then
!         RAD_QI = ( QCiLS + QCiAN ) / RAD_CF
!      else
!         RAD_QI = 0.0
!      end if
!      RAD_QI = MIN( RAD_QI, 0.01 )
!
!
!      ! Total In-cloud precipitation
!      if (  RAD_CF >0. ) then
!         RAD_QR = ( QRN_ALL ) / RAD_CF
!         RAD_QS = ( QSN_ALL ) / RAD_CF
!      else
!         RAD_QR = 0.0
!         RAD_QS = 0.0
!      end if
!      RAD_QR = MIN( RAD_QR, 0.01 )
!      RAD_QS = MIN( RAD_QS, 0.01 )
!
!      if (PL < 150. ) then
!         RAD_RI = MAX_RI
!      end if
!      if (PL >= 150. ) then
!         RAD_RI = MAX_RI*150./PL
!      end if
!
!      !! weigh in a separate R_ice for Anvil Ice according to
!      !
!      !       R_net_eff = (q_anv + q_ls) / ( q_anv/R_ice_anv + q_ls/R_ice_ls )
!      !-------------------------------------------------------------------------
!      RAD_RI_AN  =  RAD_RI ! 40.0e-6   ! MIN_RI 
!
!      if ( ( QCiLS + QCiAN ) > 0.0 ) then
!         RAD_RI_AN  = ( QCiLS + QCiAN ) / ( (QCiLS/RAD_RI) + (QCiAN/RI_ANV) )
!      end if
!
!      RAD_RI = MIN( RAD_RI, RAD_RI_AN )
!
!      RAD_RI = MAX( RAD_RI, MIN_RI )
!
!      ! Implement ramps for gradual change in effective radius
!      if (PL < 300. ) then
!         RAD_RL = 21.e-6
!      end if
!      if (PL >= 300. ) then
!         RAD_RL = 21.e-6*300./PL
!      end if
!      RAD_RL = MAX( RAD_RL, 10.e-6 )
!
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      ! Thicken low high lat clouds
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!      ! NOTE: Due to how tempor is calculated, it is now calculated in the
!      ! GridComp and passed into progno_cloud
!
!      if ( PL .GE. 775.  .AND. TE .LE.  275. .AND. (tempor.eq.1.) ) then
!         RAD_RL = max(min(-0.1 * PL + 87.5, 10.),5.)*1.e-6
!      end if
!      if ( PL .GE. 825.  .AND. TE .LE.  282. .AND. (tempor.eq.1.) ) then
!         RAD_RL = max(0.71 * TE - 190.25, 5.)*1.e-6
!      end if
!      if ( PL .GE. 775.  .AND. PL .LT. 825. .AND. TE .LE.  282. .AND. TE .GT. 275. .AND. (tempor.eq.1.) ) then
!         RAD_RL = min(-0.1*PL + 0.71 * TE - 107.75, 10.)*1.e-6
!      end if
!      if ( PL .GE. 825.  .AND. TE .LE.  275. .AND. (tempor.eq.1.) ) then
!         RAD_RL = 5.*1.e-6
!      end if
!
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      ! Thin low tropical clouds
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!      if ( PL .GE. 950.  .AND. TE .GE.  285. ) then
!         RAD_RL = min(2.2 * TE - 617., 21.)*1.e-6
!      end if
!      if ( PL .GE. 925.  .AND. TE .GE.  290. ) then
!         RAD_RL = min(0.44 * PL - 397., 21.)*1.e-6
!      end if
!      if ( PL .GE. 925.  .AND. PL .LT. 950. .AND. TE .GT.  285. .AND. TE .LT. 290.) then
!         RAD_RL = max(min(0.44*PL + 2.2 * TE - 1035., 21.),10.)*1.e-6
!      end if
!      if ( PL .GE. 950.  .AND. TE .GE.  290. ) then
!         RAD_RL = 21.*1.e-6
!      end if
!
!      if ( RAD_CF < 1.e-5 ) then
!         RAD_QL = 0.
!         RAD_QI = 0.
!         RAD_CF = 0.
!         RAD_QR = 0.
!         RAD_QS = 0.
!      end if
!
!   end subroutine RADCOUPLE
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) function QSAT(TL,PL,PASCALS)
!
!     real(8),              intent(IN) :: TL, PL
!     logical, optional, intent(IN) :: PASCALS
!     real(8) :: QSAT
!
!     real(8) :: URAMP, DD, QQ, TI, DQ, PP
!     integer :: IT
! 
!     URAMP = TMIX
!
!     if (present(PASCALS)) then 
!        if (PASCALS) then
!           PP = PL
!        else
!           PP = PL*100.
!        end if
!     else
!        PP = PL*100.
!     end if
! 
!     TI = TL - ZEROC
!
!     if    (TI <= URAMP) then
!        QSAT  =  QSATICE0(TL,PP,DQ)
!     elseif(TI >= 0.0  ) then
!        QSAT  =  QSATLQU0(TL,PP,DQ)
!     else
!        QSAT  =  QSATICE0(TL,PP,DQ)
!        QQ    =  QSATLQU0(TL,PP,DQ)
!        TI    =  TI/URAMP
!        QSAT  =  TI*(QSAT - QQ) +  QQ
!     end if
!
!   end function QSAT
!
!   attributes(device) function DQSAT(TL,PL,QSAT,PASCALS)
!
!      real(8),              intent(IN) :: TL, PL
!      real(8),              intent(OUT):: QSAT
!      logical, optional, intent(IN ):: PASCALS
!      real(8) :: DQSAT
!
!      real(8) :: URAMP, TT, WW, DD, DQQ, QQ, TI, DQI, QI, PP, DQ
!      integer :: IT
!
!      URAMP = TMIX
!
!      if (present(PASCALS)) then 
!         if (PASCALS) then
!            PP = PL
!         else
!            PP = PL*100.
!         end if
!      else
!         PP = PL*100.
!      end if
!
!      TI = TL - ZEROC
!
!      if    (TI <= URAMP) then
!         QQ  = QSATICE0(TL,PP,DQ)
!         QSAT  = QQ
!         DQSAT = DQ
!      elseif(TI >= 0.0  ) then
!         QQ  = QSATLQU0(TL,PP,DQ)
!         QSAT  = QQ
!         DQSAT = DQ
!      else
!         QQ  = QSATLQU0(TL,PP,DQQ)
!         QI  = QSATICE0(TL,PP,DQI)
!         TI  = TI/URAMP
!         DQSAT = TI*(DQI - DQQ) + DQQ
!         QSAT  = TI*(QI - QQ) +  QQ
!      end if
!
!   end function DQSAT
!
!   attributes(device) function QSATLQU0(TL,PL,DQ) result(QS)
!
!      real(8), intent(IN) :: TL
!      real(8), intent(IN) :: PL
!      real(8), intent(OUT):: DQ
!      real(8) :: QS
!
!      real(8) :: TI,W
!      real(8) :: DD
!      real(8) :: TT
!      real(8) :: DDQ
!      integer :: IT
!
!      integer, parameter :: TYPE = 1
!
!#define TX TL
!#define PX PL
!#define EX QS
!#define DX DQ
!
!
!   if    (TX<TMINLQU) then
!      TI = TMINLQU
!   elseif(TX>TMAXTBL) then
!      TI = TMAXTBL
!   else
!      TI = TX
!   end if
!
!#include "esatlqu.code"
!
!   if    (TX<TMINLQU) then
!      DDQ = 0.0
!   elseif(TX>TMAXTBL) then
!      DDQ = 0.0
!   else
!      if(PX>EX) then
!         DD = EX
!         TI = TX + DELTA_T
!#include "esatlqu.code"
!         DDQ = EX-DD
!         EX  = DD
!      endif
!   end if
!
!   if(PX > EX) then
!      DD = ESFAC/(PX - (1.0-ESFAC)*EX)
!      EX = EX*DD
!      DX = DDQ*ERFAC*PX*DD*DD
!   else
!      EX = MAX_MIXING_RATIO
!      DX = 0.0
!   end if
!
!#undef  DX
!#undef  TX
!#undef  EX
!#undef  PX
!
!      return
!   end function QSATLQU0
!
!   attributes(device) function QSATICE0(TL,PL,DQ) result(QS)
!
!      real(8), intent(IN) :: TL
!      real(8), intent(IN) :: PL
!      real(8), intent(OUT):: DQ
!      real(8) :: QS
!
!      real(8) :: TI,W
!      real(8) :: DD
!      real(8) :: TT
!      real(8) :: DDQ
!      integer :: IT
!
!      integer, parameter :: TYPE = 1
!
!#define TX TL
!#define PX PL
!#define EX QS
!#define DX DQ
!
!
!   if    (TX<TMINICE) then
!      TI = TMINICE
!   elseif(TX>ZEROC  ) then
!      TI = ZEROC
!   else
!      TI = TX
!   end if
!
!#include "esatice.code"
!
!   if    (TX<TMINICE) then
!      DDQ = 0.0
!   elseif(TX>ZEROC  ) then
!      DDQ = 0.0
!   else
!      if(PX>EX) then
!         DD = EX
!         TI = TX + DELTA_T
!#include "esatice.code"
!         DDQ = EX-DD
!         EX  = DD
!      endif
!   end if
!
!   if(PX > EX) then
!      DD = ESFAC/(PX - (1.0-ESFAC)*EX)
!      EX = EX*DD
!      DX = DDQ*ERFAC*PX*DD*DD
!   else
!      EX = MAX_MIXING_RATIO
!      DX = 0.0
!   end if
!
!#undef  DX
!#undef  TX
!#undef  EX
!#undef  PX
!
!         return
!   end function QSATICE0
!
!#endif
  SUBROUTINE PRE_PROGNO_CLOUD_FWD(im, jm, lm, th1, pk, plo, pke, cnv_ple&
&   , qst3, dzet, qddf3, cnv_fraction, cldparams)
    IMPLICIT NONE
!Inputs
    INTEGER, INTENT(IN) :: im, jm, lm
    REAL*8, DIMENSION(im, jm, 0:lm), INTENT(IN) :: pke, cnv_ple
    REAL*8, DIMENSION(im, jm, lm), INTENT(IN) :: th1, pk, plo
    TYPE(CLDPARAM_TYPE), INTENT(IN) :: cldparams
!Outputs
    REAL*8, DIMENSION(im, jm, lm) :: qst3, dzet, qddf3
!Inouts
    REAL*8, DIMENSION(im, jm), INTENT(INOUT) :: cnv_fraction
!Locals
    INTEGER :: i, j, k
    REAL*8, DIMENSION(im, jm, lm) :: temp, mass, dqst3
    REAL*8, DIMENSION(im, jm) :: vmip
    REAL*8, DIMENSION(im, jm, lm + 1) :: zet
    INTRINSIC SUM
    LOGICAL :: mask(im, jm, lm)
    temp = th1*pk
    qst3 = 0.0
    DO i=1,im
      DO j=1,jm
        DO k=1,lm
          CALL DQSATSCAPERT(dqst3(i, j, k), qst3(i, j, k), temp(i, j, k)&
&                     , plo(i, j, k))
        END DO
      END DO
    END DO
    dzet(:, :, 1:lm) = th1(:, :, 1:lm)*(pke(:, :, 1:lm)-pke(:, :, 0:lm-1&
&     ))*mapl8_cp/mapl8_grav
    mass(:, :, 1:lm) = (cnv_ple(:, :, 1:lm)-cnv_ple(:, :, 0:lm-1))*100./&
&     mapl8_grav
    zet(:, :, lm+1) = 0.0
    DO k=lm,1,-1
      zet(:, :, k) = zet(:, :, k+1) + dzet(:, :, k)
    END DO
    qddf3 = 0.0
    mask(:, :, 1:lm) = zet(:, :, 1:lm) .LT. 3000.
    WHERE (mask(:, :, 1:lm)) 
      qddf3 = -((zet(:, :, 1:lm)-3000.)*zet(:, :, 1:lm)*mass)
    ELSEWHERE
      qddf3 = 0.
    END WHERE
    DO j=1,jm
      DO i=1,im
        vmip(i, j) = SUM(qddf3(i, j, :))
      END DO
    END DO
    DO k=1,lm
      CALL PUSHREAL8ARRAY(qddf3(:, :, k), im*jm)
      qddf3(:, :, k) = qddf3(:, :, k)/vmip
    END DO
    IF (cldparams%move2ras .EQ. 0.) THEN
      CALL PUSHREAL8ARRAY(cnv_fraction, im*jm)
      cnv_fraction = 0.0
      CALL PUSHBOOLEANARRAY(mask, im*jm*lm)
      CALL PUSHREAL8ARRAY(vmip, im*jm)
      CALL PUSHREAL8ARRAY(zet, im*jm*(lm+1))
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHBOOLEANARRAY(mask, im*jm*lm)
      CALL PUSHREAL8ARRAY(vmip, im*jm)
      CALL PUSHREAL8ARRAY(zet, im*jm*(lm+1))
      CALL PUSHCONTROL1B(0)
    END IF
  END SUBROUTINE PRE_PROGNO_CLOUD_FWD
!  Differentiation of pre_progno_cloud in reverse (adjoint) mode, backward sweep (with options r8 split(GEOS_MoistGridComp.PRE_PR
!OGNO_CLOUD)):
!   gradient     of useful results: qst3 th1 qddf3 dzet
!   with respect to varying inputs: th1
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
!   subroutine RADCOUPLE(  &
!         TE,              & 
!         PL,              & 
!         CF,              & 
!         AF,              & 
!         QClLS,           & 
!         QCiLS,           & 
!         QClAN,           & 
!         QCiAN,           & 
!         QRN_ALL,         & 
!         QSN_ALL,         & 
!         RAD_QL,          &  
!         RAD_QI,          & 
!         RAD_QR,          & 
!         RAD_QS,          & 
!         RAD_CF,          & 
!         RAD_RL,          & 
!         RAD_RI,          & 
!         CLDVOL2FRC,      &          
!         NN_ANVIL,NN_ICE,NN_WARM,&
!         TEMPOR)
!
!      real(8), intent(in ) :: NN_ANVIL,NN_ICE,NN_WARM 
!      real(8), intent(in ) :: CLDVOL2FRC 
!      real(8), intent(in ) :: TE
!      real(8), intent(in ) :: PL
!      real(8), intent(in ) :: AF,CF, QClAN, QCiAN, QClLS, QCiLS
!      real(8), intent(in ) :: QRN_ALL, QSN_ALL
!      real(8), intent(out) :: RAD_QL,RAD_QI,RAD_QR,RAD_QS,RAD_CF,RAD_RL,RAD_RI
!
!      real(8), intent(in )  :: tempor
!
!      real(8) :: RElAN, REiAN, RElLS, REiLS, QCm, NN, ss, RAD_RI_AN
!      real(8) :: QClANm, QCiANm, QClLSm, QCiLSm, QCtot, AFx
!      real(8) :: rampt, rampu, rampp
!
!      real(8) :: ALPH, POLAR_RL
!
!
!      ! Limits on Radii needed to ensure
!      ! correct behavior of cloud optical
!      ! properties currently calculated in 
!      ! sorad and irrad (1e-6 m = micron)
!
!      POLAR_RL=   5.0e-6  ! 11/09/2007 JTB - COLD low level clouds
!
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      ! Adjust Anvil fractions for
!      ! warm clouds
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!   !  Needed for PRECIP Repartition
!   !  -----------------------------
!   !  ALPH =  0.05
!   !  SS   =  (260.-TE)/30.
!   !  SS   =  MIN( 1.0 , SS )
!   !  SS   =  MAX( 0.0 , SS )
!   !  SS   =  ALPH + (SS**3) * ( 1.0 - ALPH )
!   !  AFx  =  AF * SS 
!
!      ALPH =  0.1
!      SS   =  (280.-TE)/20.
!      SS   =  MIN( 1.0 , SS )
!      SS   =  MAX( 0.0 , SS )
!      SS   =  ALPH + (SS**3) * ( 1.0 - ALPH )
!      AFx  =  AF * SS * 0.5
!
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      ! Total cloud fraction
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      RAD_CF = MIN( CF + AFx, 1.00 )
!
!      ! Total In-cloud liquid
!      if ( RAD_CF > 0. ) then
!         RAD_QL = ( QClLS + QClAN ) / RAD_CF
!      else
!         RAD_QL = 0.0
!      end if
!      RAD_QL = MIN( RAD_QL, 0.01 )
!
!      ! Total In-cloud ice
!      if (  RAD_CF >0. ) then
!         RAD_QI = ( QCiLS + QCiAN ) / RAD_CF
!      else
!         RAD_QI = 0.0
!      end if
!      RAD_QI = MIN( RAD_QI, 0.01 )
!
!
!      ! Total In-cloud precipitation
!      if (  RAD_CF >0. ) then
!         RAD_QR = ( QRN_ALL ) / RAD_CF
!         RAD_QS = ( QSN_ALL ) / RAD_CF
!      else
!         RAD_QR = 0.0
!         RAD_QS = 0.0
!      end if
!      RAD_QR = MIN( RAD_QR, 0.01 )
!      RAD_QS = MIN( RAD_QS, 0.01 )
!
!      if (PL < 150. ) then
!         RAD_RI = MAX_RI
!      end if
!      if (PL >= 150. ) then
!         RAD_RI = MAX_RI*150./PL
!      end if
!
!      !! weigh in a separate R_ice for Anvil Ice according to
!      !
!      !       R_net_eff = (q_anv + q_ls) / ( q_anv/R_ice_anv + q_ls/R_ice_ls )
!      !-------------------------------------------------------------------------
!      RAD_RI_AN  =  RAD_RI ! 40.0e-6   ! MIN_RI 
!
!      if ( ( QCiLS + QCiAN ) > 0.0 ) then
!         RAD_RI_AN  = ( QCiLS + QCiAN ) / ( (QCiLS/RAD_RI) + (QCiAN/RI_ANV) )
!      end if
!
!      RAD_RI = MIN( RAD_RI, RAD_RI_AN )
!
!      RAD_RI = MAX( RAD_RI, MIN_RI )
!
!      ! Implement ramps for gradual change in effective radius
!      if (PL < 300. ) then
!         RAD_RL = 21.e-6
!      end if
!      if (PL >= 300. ) then
!         RAD_RL = 21.e-6*300./PL
!      end if
!      RAD_RL = MAX( RAD_RL, 10.e-6 )
!
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      ! Thicken low high lat clouds
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!      ! NOTE: Due to how tempor is calculated, it is now calculated in the
!      ! GridComp and passed into progno_cloud
!
!      if ( PL .GE. 775.  .AND. TE .LE.  275. .AND. (tempor.eq.1.) ) then
!         RAD_RL = max(min(-0.1 * PL + 87.5, 10.),5.)*1.e-6
!      end if
!      if ( PL .GE. 825.  .AND. TE .LE.  282. .AND. (tempor.eq.1.) ) then
!         RAD_RL = max(0.71 * TE - 190.25, 5.)*1.e-6
!      end if
!      if ( PL .GE. 775.  .AND. PL .LT. 825. .AND. TE .LE.  282. .AND. TE .GT. 275. .AND. (tempor.eq.1.) ) then
!         RAD_RL = min(-0.1*PL + 0.71 * TE - 107.75, 10.)*1.e-6
!      end if
!      if ( PL .GE. 825.  .AND. TE .LE.  275. .AND. (tempor.eq.1.) ) then
!         RAD_RL = 5.*1.e-6
!      end if
!
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      ! Thin low tropical clouds
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!      if ( PL .GE. 950.  .AND. TE .GE.  285. ) then
!         RAD_RL = min(2.2 * TE - 617., 21.)*1.e-6
!      end if
!      if ( PL .GE. 925.  .AND. TE .GE.  290. ) then
!         RAD_RL = min(0.44 * PL - 397., 21.)*1.e-6
!      end if
!      if ( PL .GE. 925.  .AND. PL .LT. 950. .AND. TE .GT.  285. .AND. TE .LT. 290.) then
!         RAD_RL = max(min(0.44*PL + 2.2 * TE - 1035., 21.),10.)*1.e-6
!      end if
!      if ( PL .GE. 950.  .AND. TE .GE.  290. ) then
!         RAD_RL = 21.*1.e-6
!      end if
!
!      if ( RAD_CF < 1.e-5 ) then
!         RAD_QL = 0.
!         RAD_QI = 0.
!         RAD_CF = 0.
!         RAD_QR = 0.
!         RAD_QS = 0.
!      end if
!
!   end subroutine RADCOUPLE
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) function QSAT(TL,PL,PASCALS)
!
!     real(8),              intent(IN) :: TL, PL
!     logical, optional, intent(IN) :: PASCALS
!     real(8) :: QSAT
!
!     real(8) :: URAMP, DD, QQ, TI, DQ, PP
!     integer :: IT
! 
!     URAMP = TMIX
!
!     if (present(PASCALS)) then 
!        if (PASCALS) then
!           PP = PL
!        else
!           PP = PL*100.
!        end if
!     else
!        PP = PL*100.
!     end if
! 
!     TI = TL - ZEROC
!
!     if    (TI <= URAMP) then
!        QSAT  =  QSATICE0(TL,PP,DQ)
!     elseif(TI >= 0.0  ) then
!        QSAT  =  QSATLQU0(TL,PP,DQ)
!     else
!        QSAT  =  QSATICE0(TL,PP,DQ)
!        QQ    =  QSATLQU0(TL,PP,DQ)
!        TI    =  TI/URAMP
!        QSAT  =  TI*(QSAT - QQ) +  QQ
!     end if
!
!   end function QSAT
!
!   attributes(device) function DQSAT(TL,PL,QSAT,PASCALS)
!
!      real(8),              intent(IN) :: TL, PL
!      real(8),              intent(OUT):: QSAT
!      logical, optional, intent(IN ):: PASCALS
!      real(8) :: DQSAT
!
!      real(8) :: URAMP, TT, WW, DD, DQQ, QQ, TI, DQI, QI, PP, DQ
!      integer :: IT
!
!      URAMP = TMIX
!
!      if (present(PASCALS)) then 
!         if (PASCALS) then
!            PP = PL
!         else
!            PP = PL*100.
!         end if
!      else
!         PP = PL*100.
!      end if
!
!      TI = TL - ZEROC
!
!      if    (TI <= URAMP) then
!         QQ  = QSATICE0(TL,PP,DQ)
!         QSAT  = QQ
!         DQSAT = DQ
!      elseif(TI >= 0.0  ) then
!         QQ  = QSATLQU0(TL,PP,DQ)
!         QSAT  = QQ
!         DQSAT = DQ
!      else
!         QQ  = QSATLQU0(TL,PP,DQQ)
!         QI  = QSATICE0(TL,PP,DQI)
!         TI  = TI/URAMP
!         DQSAT = TI*(DQI - DQQ) + DQQ
!         QSAT  = TI*(QI - QQ) +  QQ
!      end if
!
!   end function DQSAT
!
!   attributes(device) function QSATLQU0(TL,PL,DQ) result(QS)
!
!      real(8), intent(IN) :: TL
!      real(8), intent(IN) :: PL
!      real(8), intent(OUT):: DQ
!      real(8) :: QS
!
!      real(8) :: TI,W
!      real(8) :: DD
!      real(8) :: TT
!      real(8) :: DDQ
!      integer :: IT
!
!      integer, parameter :: TYPE = 1
!
!#define TX TL
!#define PX PL
!#define EX QS
!#define DX DQ
!
!
!   if    (TX<TMINLQU) then
!      TI = TMINLQU
!   elseif(TX>TMAXTBL) then
!      TI = TMAXTBL
!   else
!      TI = TX
!   end if
!
!#include "esatlqu.code"
!
!   if    (TX<TMINLQU) then
!      DDQ = 0.0
!   elseif(TX>TMAXTBL) then
!      DDQ = 0.0
!   else
!      if(PX>EX) then
!         DD = EX
!         TI = TX + DELTA_T
!#include "esatlqu.code"
!         DDQ = EX-DD
!         EX  = DD
!      endif
!   end if
!
!   if(PX > EX) then
!      DD = ESFAC/(PX - (1.0-ESFAC)*EX)
!      EX = EX*DD
!      DX = DDQ*ERFAC*PX*DD*DD
!   else
!      EX = MAX_MIXING_RATIO
!      DX = 0.0
!   end if
!
!#undef  DX
!#undef  TX
!#undef  EX
!#undef  PX
!
!      return
!   end function QSATLQU0
!
!   attributes(device) function QSATICE0(TL,PL,DQ) result(QS)
!
!      real(8), intent(IN) :: TL
!      real(8), intent(IN) :: PL
!      real(8), intent(OUT):: DQ
!      real(8) :: QS
!
!      real(8) :: TI,W
!      real(8) :: DD
!      real(8) :: TT
!      real(8) :: DDQ
!      integer :: IT
!
!      integer, parameter :: TYPE = 1
!
!#define TX TL
!#define PX PL
!#define EX QS
!#define DX DQ
!
!
!   if    (TX<TMINICE) then
!      TI = TMINICE
!   elseif(TX>ZEROC  ) then
!      TI = ZEROC
!   else
!      TI = TX
!   end if
!
!#include "esatice.code"
!
!   if    (TX<TMINICE) then
!      DDQ = 0.0
!   elseif(TX>ZEROC  ) then
!      DDQ = 0.0
!   else
!      if(PX>EX) then
!         DD = EX
!         TI = TX + DELTA_T
!#include "esatice.code"
!         DDQ = EX-DD
!         EX  = DD
!      endif
!   end if
!
!   if(PX > EX) then
!      DD = ESFAC/(PX - (1.0-ESFAC)*EX)
!      EX = EX*DD
!      DX = DDQ*ERFAC*PX*DD*DD
!   else
!      EX = MAX_MIXING_RATIO
!      DX = 0.0
!   end if
!
!#undef  DX
!#undef  TX
!#undef  EX
!#undef  PX
!
!         return
!   end function QSATICE0
!
!#endif
  SUBROUTINE PRE_PROGNO_CLOUD_BWD(im, jm, lm, th1, th1_ad, pk, plo, pke&
&   , cnv_ple, qst3, qst3_ad, dzet, dzet_ad, qddf3, qddf3_ad, &
&   cnv_fraction, cldparams)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: im, jm, lm
    REAL*8, DIMENSION(im, jm, 0:lm), INTENT(IN) :: pke, cnv_ple
    REAL*8, DIMENSION(im, jm, lm), INTENT(IN) :: th1, pk, plo
    REAL*8, DIMENSION(im, jm, lm) :: th1_ad
    TYPE(CLDPARAM_TYPE), INTENT(IN) :: cldparams
    REAL*8, DIMENSION(im, jm, lm) :: qst3, dzet, qddf3
    REAL*8, DIMENSION(im, jm, lm) :: qst3_ad, dzet_ad, qddf3_ad
    REAL*8, DIMENSION(im, jm), INTENT(INOUT) :: cnv_fraction
    INTEGER :: i, j, k
    REAL*8, DIMENSION(im, jm, lm) :: temp, mass, dqst3
    REAL*8, DIMENSION(im, jm, lm) :: temp_ad, dqst3_ad
    REAL*8, DIMENSION(im, jm) :: vmip
    REAL*8, DIMENSION(im, jm) :: vmip_ad
    REAL*8, DIMENSION(im, jm, lm + 1) :: zet
    REAL*8, DIMENSION(im, jm, lm+1) :: zet_ad
    INTRINSIC SUM
    INTEGER :: branch
    LOGICAL :: mask(im, jm, lm)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8ARRAY(zet, im*jm*(lm+1))
      CALL POPREAL8ARRAY(vmip, im*jm)
      CALL POPBOOLEANARRAY(mask, im*jm*lm)
    ELSE
      CALL POPREAL8ARRAY(zet, im*jm*(lm+1))
      CALL POPREAL8ARRAY(vmip, im*jm)
      CALL POPBOOLEANARRAY(mask, im*jm*lm)
      CALL POPREAL8ARRAY(cnv_fraction, im*jm)
    END IF
    vmip_ad = 0.0_8
    DO k=lm,1,-1
      CALL POPREAL8ARRAY(qddf3(:, :, k), im*jm)
      vmip_ad = vmip_ad - qddf3(:, :, k)*qddf3_ad(:, :, k)/vmip**2
      qddf3_ad(:, :, k) = qddf3_ad(:, :, k)/vmip
    END DO
    DO j=jm,1,-1
      DO i=im,1,-1
        qddf3_ad(i, j, :) = qddf3_ad(i, j, :) + vmip_ad(i, j)
        vmip_ad(i, j) = 0.0_8
      END DO
    END DO
    WHERE (.NOT.mask(:, :, 1:lm)) qddf3_ad = 0.0_8
    mass(:, :, 1:lm) = (cnv_ple(:, :, 1:lm)-cnv_ple(:, :, 0:lm-1))*100./&
&     mapl8_grav
    zet_ad = 0.0_8
    WHERE (mask(:, :, 1:lm)) zet_ad(:, :, 1:lm) = zet_ad(:, :, 1:lm) - (&
&       zet(:, :, 1:lm)-3000.)*mass*qddf3_ad - zet(:, :, 1:lm)*mass*&
&       qddf3_ad
    DO k=1,lm,1
      zet_ad(:, :, k+1) = zet_ad(:, :, k+1) + zet_ad(:, :, k)
      dzet_ad(:, :, k) = dzet_ad(:, :, k) + zet_ad(:, :, k)
      zet_ad(:, :, k) = 0.0_8
    END DO
    th1_ad = th1_ad + (pke(:, :, 1:lm)-pke(:, :, 0:lm-1))*mapl8_cp*&
&     dzet_ad/mapl8_grav
    temp_ad = 0.0_8
    DO i=im,1,-1
      DO j=jm,1,-1
        DO k=lm,1,-1
          temp = th1*pk
          dqst3_ad = 0.0_8
          CALL DQSATSCAPERT_ADM(dqst3(i, j, k), dqst3_ad(i, j, k), qst3(&
&                         i, j, k), qst3_ad(i, j, k), temp(i, j, k), &
&                         temp_ad(i, j, k), plo(i, j, k))
          dqst3_ad(i, j, k) = 0.0_8
          qst3_ad(i, j, k) = 0.0_8
        END DO
      END DO
    END DO
    th1_ad = th1_ad + pk*temp_ad
  END SUBROUTINE PRE_PROGNO_CLOUD_BWD
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) &
!#endif
!   subroutine RADCOUPLE(  &
!         TE,              & 
!         PL,              & 
!         CF,              & 
!         AF,              & 
!         QClLS,           & 
!         QCiLS,           & 
!         QClAN,           & 
!         QCiAN,           & 
!         QRN_ALL,         & 
!         QSN_ALL,         & 
!         RAD_QL,          &  
!         RAD_QI,          & 
!         RAD_QR,          & 
!         RAD_QS,          & 
!         RAD_CF,          & 
!         RAD_RL,          & 
!         RAD_RI,          & 
!         CLDVOL2FRC,      &          
!         NN_ANVIL,NN_ICE,NN_WARM,&
!         TEMPOR)
!
!      real(8), intent(in ) :: NN_ANVIL,NN_ICE,NN_WARM 
!      real(8), intent(in ) :: CLDVOL2FRC 
!      real(8), intent(in ) :: TE
!      real(8), intent(in ) :: PL
!      real(8), intent(in ) :: AF,CF, QClAN, QCiAN, QClLS, QCiLS
!      real(8), intent(in ) :: QRN_ALL, QSN_ALL
!      real(8), intent(out) :: RAD_QL,RAD_QI,RAD_QR,RAD_QS,RAD_CF,RAD_RL,RAD_RI
!
!      real(8), intent(in )  :: tempor
!
!      real(8) :: RElAN, REiAN, RElLS, REiLS, QCm, NN, ss, RAD_RI_AN
!      real(8) :: QClANm, QCiANm, QClLSm, QCiLSm, QCtot, AFx
!      real(8) :: rampt, rampu, rampp
!
!      real(8) :: ALPH, POLAR_RL
!
!
!      ! Limits on Radii needed to ensure
!      ! correct behavior of cloud optical
!      ! properties currently calculated in 
!      ! sorad and irrad (1e-6 m = micron)
!
!      POLAR_RL=   5.0e-6  ! 11/09/2007 JTB - COLD low level clouds
!
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      ! Adjust Anvil fractions for
!      ! warm clouds
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!   !  Needed for PRECIP Repartition
!   !  -----------------------------
!   !  ALPH =  0.05
!   !  SS   =  (260.-TE)/30.
!   !  SS   =  MIN( 1.0 , SS )
!   !  SS   =  MAX( 0.0 , SS )
!   !  SS   =  ALPH + (SS**3) * ( 1.0 - ALPH )
!   !  AFx  =  AF * SS 
!
!      ALPH =  0.1
!      SS   =  (280.-TE)/20.
!      SS   =  MIN( 1.0 , SS )
!      SS   =  MAX( 0.0 , SS )
!      SS   =  ALPH + (SS**3) * ( 1.0 - ALPH )
!      AFx  =  AF * SS * 0.5
!
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      ! Total cloud fraction
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      RAD_CF = MIN( CF + AFx, 1.00 )
!
!      ! Total In-cloud liquid
!      if ( RAD_CF > 0. ) then
!         RAD_QL = ( QClLS + QClAN ) / RAD_CF
!      else
!         RAD_QL = 0.0
!      end if
!      RAD_QL = MIN( RAD_QL, 0.01 )
!
!      ! Total In-cloud ice
!      if (  RAD_CF >0. ) then
!         RAD_QI = ( QCiLS + QCiAN ) / RAD_CF
!      else
!         RAD_QI = 0.0
!      end if
!      RAD_QI = MIN( RAD_QI, 0.01 )
!
!
!      ! Total In-cloud precipitation
!      if (  RAD_CF >0. ) then
!         RAD_QR = ( QRN_ALL ) / RAD_CF
!         RAD_QS = ( QSN_ALL ) / RAD_CF
!      else
!         RAD_QR = 0.0
!         RAD_QS = 0.0
!      end if
!      RAD_QR = MIN( RAD_QR, 0.01 )
!      RAD_QS = MIN( RAD_QS, 0.01 )
!
!      if (PL < 150. ) then
!         RAD_RI = MAX_RI
!      end if
!      if (PL >= 150. ) then
!         RAD_RI = MAX_RI*150./PL
!      end if
!
!      !! weigh in a separate R_ice for Anvil Ice according to
!      !
!      !       R_net_eff = (q_anv + q_ls) / ( q_anv/R_ice_anv + q_ls/R_ice_ls )
!      !-------------------------------------------------------------------------
!      RAD_RI_AN  =  RAD_RI ! 40.0e-6   ! MIN_RI 
!
!      if ( ( QCiLS + QCiAN ) > 0.0 ) then
!         RAD_RI_AN  = ( QCiLS + QCiAN ) / ( (QCiLS/RAD_RI) + (QCiAN/RI_ANV) )
!      end if
!
!      RAD_RI = MIN( RAD_RI, RAD_RI_AN )
!
!      RAD_RI = MAX( RAD_RI, MIN_RI )
!
!      ! Implement ramps for gradual change in effective radius
!      if (PL < 300. ) then
!         RAD_RL = 21.e-6
!      end if
!      if (PL >= 300. ) then
!         RAD_RL = 21.e-6*300./PL
!      end if
!      RAD_RL = MAX( RAD_RL, 10.e-6 )
!
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      ! Thicken low high lat clouds
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!      ! NOTE: Due to how tempor is calculated, it is now calculated in the
!      ! GridComp and passed into progno_cloud
!
!      if ( PL .GE. 775.  .AND. TE .LE.  275. .AND. (tempor.eq.1.) ) then
!         RAD_RL = max(min(-0.1 * PL + 87.5, 10.),5.)*1.e-6
!      end if
!      if ( PL .GE. 825.  .AND. TE .LE.  282. .AND. (tempor.eq.1.) ) then
!         RAD_RL = max(0.71 * TE - 190.25, 5.)*1.e-6
!      end if
!      if ( PL .GE. 775.  .AND. PL .LT. 825. .AND. TE .LE.  282. .AND. TE .GT. 275. .AND. (tempor.eq.1.) ) then
!         RAD_RL = min(-0.1*PL + 0.71 * TE - 107.75, 10.)*1.e-6
!      end if
!      if ( PL .GE. 825.  .AND. TE .LE.  275. .AND. (tempor.eq.1.) ) then
!         RAD_RL = 5.*1.e-6
!      end if
!
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!      ! Thin low tropical clouds
!      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!
!      if ( PL .GE. 950.  .AND. TE .GE.  285. ) then
!         RAD_RL = min(2.2 * TE - 617., 21.)*1.e-6
!      end if
!      if ( PL .GE. 925.  .AND. TE .GE.  290. ) then
!         RAD_RL = min(0.44 * PL - 397., 21.)*1.e-6
!      end if
!      if ( PL .GE. 925.  .AND. PL .LT. 950. .AND. TE .GT.  285. .AND. TE .LT. 290.) then
!         RAD_RL = max(min(0.44*PL + 2.2 * TE - 1035., 21.),10.)*1.e-6
!      end if
!      if ( PL .GE. 950.  .AND. TE .GE.  290. ) then
!         RAD_RL = 21.*1.e-6
!      end if
!
!      if ( RAD_CF < 1.e-5 ) then
!         RAD_QL = 0.
!         RAD_QI = 0.
!         RAD_CF = 0.
!         RAD_QR = 0.
!         RAD_QS = 0.
!      end if
!
!   end subroutine RADCOUPLE
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!#ifdef _CUDA
!   attributes(device) function QSAT(TL,PL,PASCALS)
!
!     real(8),              intent(IN) :: TL, PL
!     logical, optional, intent(IN) :: PASCALS
!     real(8) :: QSAT
!
!     real(8) :: URAMP, DD, QQ, TI, DQ, PP
!     integer :: IT
! 
!     URAMP = TMIX
!
!     if (present(PASCALS)) then 
!        if (PASCALS) then
!           PP = PL
!        else
!           PP = PL*100.
!        end if
!     else
!        PP = PL*100.
!     end if
! 
!     TI = TL - ZEROC
!
!     if    (TI <= URAMP) then
!        QSAT  =  QSATICE0(TL,PP,DQ)
!     elseif(TI >= 0.0  ) then
!        QSAT  =  QSATLQU0(TL,PP,DQ)
!     else
!        QSAT  =  QSATICE0(TL,PP,DQ)
!        QQ    =  QSATLQU0(TL,PP,DQ)
!        TI    =  TI/URAMP
!        QSAT  =  TI*(QSAT - QQ) +  QQ
!     end if
!
!   end function QSAT
!
!   attributes(device) function DQSAT(TL,PL,QSAT,PASCALS)
!
!      real(8),              intent(IN) :: TL, PL
!      real(8),              intent(OUT):: QSAT
!      logical, optional, intent(IN ):: PASCALS
!      real(8) :: DQSAT
!
!      real(8) :: URAMP, TT, WW, DD, DQQ, QQ, TI, DQI, QI, PP, DQ
!      integer :: IT
!
!      URAMP = TMIX
!
!      if (present(PASCALS)) then 
!         if (PASCALS) then
!            PP = PL
!         else
!            PP = PL*100.
!         end if
!      else
!         PP = PL*100.
!      end if
!
!      TI = TL - ZEROC
!
!      if    (TI <= URAMP) then
!         QQ  = QSATICE0(TL,PP,DQ)
!         QSAT  = QQ
!         DQSAT = DQ
!      elseif(TI >= 0.0  ) then
!         QQ  = QSATLQU0(TL,PP,DQ)
!         QSAT  = QQ
!         DQSAT = DQ
!      else
!         QQ  = QSATLQU0(TL,PP,DQQ)
!         QI  = QSATICE0(TL,PP,DQI)
!         TI  = TI/URAMP
!         DQSAT = TI*(DQI - DQQ) + DQQ
!         QSAT  = TI*(QI - QQ) +  QQ
!      end if
!
!   end function DQSAT
!
!   attributes(device) function QSATLQU0(TL,PL,DQ) result(QS)
!
!      real(8), intent(IN) :: TL
!      real(8), intent(IN) :: PL
!      real(8), intent(OUT):: DQ
!      real(8) :: QS
!
!      real(8) :: TI,W
!      real(8) :: DD
!      real(8) :: TT
!      real(8) :: DDQ
!      integer :: IT
!
!      integer, parameter :: TYPE = 1
!
!#define TX TL
!#define PX PL
!#define EX QS
!#define DX DQ
!
!
!   if    (TX<TMINLQU) then
!      TI = TMINLQU
!   elseif(TX>TMAXTBL) then
!      TI = TMAXTBL
!   else
!      TI = TX
!   end if
!
!#include "esatlqu.code"
!
!   if    (TX<TMINLQU) then
!      DDQ = 0.0
!   elseif(TX>TMAXTBL) then
!      DDQ = 0.0
!   else
!      if(PX>EX) then
!         DD = EX
!         TI = TX + DELTA_T
!#include "esatlqu.code"
!         DDQ = EX-DD
!         EX  = DD
!      endif
!   end if
!
!   if(PX > EX) then
!      DD = ESFAC/(PX - (1.0-ESFAC)*EX)
!      EX = EX*DD
!      DX = DDQ*ERFAC*PX*DD*DD
!   else
!      EX = MAX_MIXING_RATIO
!      DX = 0.0
!   end if
!
!#undef  DX
!#undef  TX
!#undef  EX
!#undef  PX
!
!      return
!   end function QSATLQU0
!
!   attributes(device) function QSATICE0(TL,PL,DQ) result(QS)
!
!      real(8), intent(IN) :: TL
!      real(8), intent(IN) :: PL
!      real(8), intent(OUT):: DQ
!      real(8) :: QS
!
!      real(8) :: TI,W
!      real(8) :: DD
!      real(8) :: TT
!      real(8) :: DDQ
!      integer :: IT
!
!      integer, parameter :: TYPE = 1
!
!#define TX TL
!#define PX PL
!#define EX QS
!#define DX DQ
!
!
!   if    (TX<TMINICE) then
!      TI = TMINICE
!   elseif(TX>ZEROC  ) then
!      TI = ZEROC
!   else
!      TI = TX
!   end if
!
!#include "esatice.code"
!
!   if    (TX<TMINICE) then
!      DDQ = 0.0
!   elseif(TX>ZEROC  ) then
!      DDQ = 0.0
!   else
!      if(PX>EX) then
!         DD = EX
!         TI = TX + DELTA_T
!#include "esatice.code"
!         DDQ = EX-DD
!         EX  = DD
!      endif
!   end if
!
!   if(PX > EX) then
!      DD = ESFAC/(PX - (1.0-ESFAC)*EX)
!      EX = EX*DD
!      DX = DDQ*ERFAC*PX*DD*DD
!   else
!      EX = MAX_MIXING_RATIO
!      DX = 0.0
!   end if
!
!#undef  DX
!#undef  TX
!#undef  EX
!#undef  PX
!
!         return
!   end function QSATICE0
!
!#endif
  SUBROUTINE PRE_PROGNO_CLOUD(im, jm, lm, th1, pk, plo, pke, cnv_ple, &
&   qst3, dzet, qddf3, cnv_fraction, cldparams)
    IMPLICIT NONE
!Inputs
    INTEGER, INTENT(IN) :: im, jm, lm
    REAL*8, DIMENSION(im, jm, 0:lm), INTENT(IN) :: pke, cnv_ple
    REAL*8, DIMENSION(im, jm, lm), INTENT(IN) :: th1, pk, plo
    TYPE(CLDPARAM_TYPE), INTENT(IN) :: cldparams
!Outputs
    REAL*8, DIMENSION(im, jm, lm), INTENT(OUT) :: qst3, dzet, qddf3
!Inouts
    REAL*8, DIMENSION(im, jm), INTENT(INOUT) :: cnv_fraction
!Locals
    INTEGER :: i, j, k
    REAL*8, DIMENSION(im, jm, lm) :: temp, mass, dqst3
    REAL*8, DIMENSION(im, jm) :: vmip
    REAL*8, DIMENSION(im, jm, lm + 1) :: zet
    INTRINSIC SUM
    LOGICAL :: mask(im, jm, lm)
    temp = th1*pk
    dqst3 = 0.0
    qst3 = 0.0
    DO i=1,im
      DO j=1,jm
        DO k=1,lm
          CALL DQSATSCAPERT(dqst3(i, j, k), qst3(i, j, k), temp(i, j, k)&
&                     , plo(i, j, k))
        END DO
      END DO
    END DO
    dzet = 0.0
    dzet(:, :, 1:lm) = th1(:, :, 1:lm)*(pke(:, :, 1:lm)-pke(:, :, 0:lm-1&
&     ))*mapl8_cp/mapl8_grav
    mass(:, :, 1:lm) = (cnv_ple(:, :, 1:lm)-cnv_ple(:, :, 0:lm-1))*100./&
&     mapl8_grav
    zet(:, :, lm+1) = 0.0
    DO k=lm,1,-1
      zet(:, :, k) = zet(:, :, k+1) + dzet(:, :, k)
    END DO
    qddf3 = 0.0
    mask(:, :, 1:lm) = zet(:, :, 1:lm) .LT. 3000.
    WHERE (mask(:, :, 1:lm)) 
      qddf3 = -((zet(:, :, 1:lm)-3000.)*zet(:, :, 1:lm)*mass)
    ELSEWHERE
      qddf3 = 0.
    END WHERE
    DO j=1,jm
      DO i=1,im
        vmip(i, j) = SUM(qddf3(i, j, :))
      END DO
    END DO
    DO k=1,lm
      qddf3(:, :, k) = qddf3(:, :, k)/vmip
    END DO
    IF (cldparams%move2ras .EQ. 0.) cnv_fraction = 0.0
  END SUBROUTINE PRE_PROGNO_CLOUD
END MODULE CLOUDNEW_B
