!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.9 (r5096) - 24 Feb 2014 16:53
!
!  Differentiation of rase_tracer in reverse (adjoint) mode:
!   gradient     of useful results: xho
!   with respect to varying inputs: xho
!   RW status of diff variables: xho:in-out
SUBROUTINE RASE_TRACER_B(idim, irun, k0, icmin, dt, cons_cp, cons_alhl, &
& cons_grav, cons_rgas, cons_h2omw, cons_airmw, cons_vireps, seedras, &
& sige, kcbl, wgt0, wgt1, frland, ts, thoin, qhoin, uhoin, vhoin, &
& co_auto, ple, rasparams, estblx, itrcr, xho, xhob, fscav)
  IMPLICIT NONE
!INPUTS
  INTEGER, INTENT(IN) :: idim, irun, k0, icmin
  REAL*8, DIMENSION(idim, k0 + 1), INTENT(IN) :: ple
  REAL*8, DIMENSION(k0 + 1), INTENT(IN) :: sige
  REAL*8, INTENT(IN) :: dt, cons_cp, cons_alhl, cons_grav, cons_rgas
  REAL*8, INTENT(IN) :: cons_h2omw, cons_airmw, cons_vireps
  INTEGER, DIMENSION(idim), INTENT(IN) :: seedras
  INTEGER, DIMENSION(idim), INTENT(IN) :: kcbl
  REAL*8, DIMENSION(idim), INTENT(IN) :: ts, frland
  REAL*8, DIMENSION(idim), INTENT(IN) :: co_auto
  REAL*8, DIMENSION(idim, k0), INTENT(IN) :: wgt0, wgt1
  REAL*8, DIMENSION(:), INTENT(IN) :: rasparams
  REAL*8, DIMENSION(:), INTENT(IN) :: estblx
  INTEGER, INTENT(IN) :: itrcr
  REAL*8, DIMENSION(itrcr), INTENT(IN) :: fscav
  REAL*8, DIMENSION(idim, k0), INTENT(IN) :: thoin, qhoin, uhoin, vhoin
!PROGNOSTIC
  REAL*8, DIMENSION(idim, k0, itrcr), INTENT(INOUT) :: xho
  REAL*8, DIMENSION(idim, k0, itrcr), INTENT(INOUT) :: xhob
!LOCALS
  INTEGER :: i, ic, l, kk, k
!Parameters
  REAL*8, PARAMETER :: onepkap=1.+2./7., daylen=86400.0
  REAL*8, PARAMETER :: rhmax=0.9999
  REAL*8, PARAMETER :: cbl_qpert=0.0, cbl_tpert=1.0
  REAL*8, PARAMETER :: cbl_tpert_mxocn=2.0, cbl_tpert_mxlnd=4.0
!Constants
  REAL*8 :: grav, cp, alhl, cpbg, alhi, cpi, gravi, ddt, lbcp
!Rasparams
  REAL*8 :: fricfac, cli_crit, rasal1, rasal2
  REAL*8 :: friclambda
  REAL*8 :: sdqv2, sdqv3, sdqvt1
  REAL*8 :: acritfac, pblfrac, autorampb
  REAL*8 :: maxdallowed, rhmn, rhmx
  REAL*8 :: mxdiam
  REAL*8 :: tx2, tx3, akm, acr, alm, tth, qqh, dqx
  REAL*8 :: wfn, tem, trg, trgexp, evp, wlq, qcc
  REAL*8 :: cli, te_a, c00_x, cli_crit_x, toki
  REAL*8 :: dt_lyr, rate, cvw_x, closs, f2, f3, f4
  REAL*8 :: wght0, prcbl, rndu
  REAL*8 :: lambda_min, lambda_max
  REAL*8 :: tpert, qpert
  REAL*8 :: uht, vht
  REAL*8, DIMENSION(k0) :: poi_sv, qoi_sv, uoi_sv, voi_sv
  REAL*8, DIMENSION(k0) :: poi, qoi, uoi, voi, dqq, bet, gam, cll
  REAL*8, DIMENSION(k0) :: poi_c, qoi_c
  REAL*8, DIMENSION(k0) :: prh, pri, ght, dpt, dpb, pki
  REAL*8, DIMENSION(k0) :: ucu, vcu
  REAL*8, DIMENSION(k0) :: cln, rns, pol
  REAL*8, DIMENSION(k0) :: qst, ssl, rmf, rnn, rn1, rmfc, rmfp
  REAL*8, DIMENSION(k0) :: gms, eta, gmh, eht, gm1, hcc, rmfd
  REAL*8, DIMENSION(k0) :: hol, hst, qol, zol, hcld, cll0, cllx, clli
  REAL*8, DIMENSION(k0) :: bke, cvw, updfrc
  REAL*8, DIMENSION(k0) :: rasal, updfrp, bk2, dll0, dllx
  REAL*8, DIMENSION(k0) :: wght, massf
  REAL*8, DIMENSION(k0) :: qss, dqs, pf, pk, tempf, zlo
  REAL*8, DIMENSION(k0 + 1) :: prj, prs, qht, sht, zet, zle, pke
  REAL*8, DIMENSION(idim, k0) :: tho, qho, uho, vho
!Tracer scavenging
  INTEGER :: itr
!Layer thickness in km
  REAL*8 :: delzkm
!Fraction of tracer *not* scavenged
  REAL*8 :: fnoscav
  REAL*8, DIMENSION(k0, itrcr) :: xoi, xcu, xoi_sv
  REAL*8, DIMENSION(k0, itrcr) :: xoib, xcub, xoi_svb
  REAL*8, DIMENSION(itrcr) :: xht
  REAL*8, DIMENSION(itrcr) :: xhtb
  INTRINSIC MAX
  INTRINSIC MIN
  INTRINSIC SQRT
  INTRINSIC EXP
  INTRINSIC SUM
  REAL*8 :: arg1
  INTEGER :: ad_to
  INTEGER :: ad_from
  INTEGER :: ad_from0
  INTEGER :: branch
  INTEGER :: ad_to0
  INTEGER :: ad_to1
  INTEGER :: ad_from1
  REAL*8 :: tempb2
  REAL*8 :: tempb1
  REAL*8 :: tempb0
  REAL*8 :: x5
  REAL*8 :: x4
  REAL*8 :: x3
  REAL*8 :: x2
  REAL*8 :: x1
  REAL*8 :: tempb
  REAL*8 :: max2
  REAL*8 :: max1
  REAL*8 :: y1
!Pass meteorology to internal arrays so it is not updated
  tho = thoin
  qho = qhoin
!Initialize Local Arrays
  poi = 0.0
  qoi = 0.0
  dqq = 0.0
  bet = 0.0
  gam = 0.0
  prh = 0.0
  pri = 0.0
  ght = 0.0
  dpt = 0.0
  dpb = 0.0
  pki = 0.0
  pol = 0.0
  qst = 0.0
  ssl = 0.0
  gms = 0.0
  eta = 0.0
  gmh = 0.0
  eht = 0.0
  gm1 = 0.0
  hcc = 0.0
  hst = 0.0
  qol = 0.0
  zol = 0.0
  hcld = 0.0
  rasal = 0.0
  bk2 = 0.0
  qss = 0.0
  dqs = 0.0
  prj = 0.0
  prs = 0.0
  qht = 0.0
  sht = 0.0
  zet = 0.0
!  ---  1
!  ---  4
  cli_crit = rasparams(4)
!  ---  5
  rasal1 = rasparams(5)
!  ---  6
  rasal2 = rasparams(6)
!  --- 11
!  --- 14
  sdqv2 = rasparams(14)
!  --- 15
  sdqv3 = rasparams(15)
!  --- 16
  sdqvt1 = rasparams(16)
!  --- 17
  acritfac = rasparams(17)
!  --- 20
  pblfrac = rasparams(20)
!  --- 21
  autorampb = rasparams(21)
!  --- 24
  rhmn = rasparams(24)
!  --- 24
  maxdallowed = rasparams(23)
!  --- 25
  rhmx = rasparams(25)
  grav = cons_grav
  alhl = cons_alhl
  cp = cons_cp
  cpi = 1.0/cp
  alhi = 1.0/alhl
  gravi = 1.0/grav
  cpbg = cp*gravi
  lbcp = alhl*cpi
  i = 1
!CALL FINDBASE
  k = kcbl(i)
  IF (k .GT. 0) THEN
!Get saturation specific humidity and gradient wrt to T
    pke = (ple(i, :)/1000.)**(cons_rgas/cons_cp)
    pf = 0.5*(ple(i, 1:k0)+ple(i, 2:k0+1))
    pk = (pf/1000.)**(cons_rgas/cons_cp)
    tempf = tho(i, :)*pk
    zle = 0.0
    zlo = 0.0
    zle(k0+1) = 0.
    DO l=k0,1,-1
      zle(l) = tho(i, l)*(1.+cons_vireps*qho(i, l))
      zlo(l) = zle(l+1) + cons_cp/cons_grav*(pke(l+1)-pk(l))*zle(l)
      zle(l) = zlo(l) + cons_cp/cons_grav*(pk(l)-pke(l))*zle(l)
    END DO
    tpert = cbl_tpert*(ts(i)-(tempf(k0)+cons_grav*zlo(k0)/cons_cp))
!* ( QSSFC - Q(:,:,K0) ) [CBL_QPERT = 0.0]
    qpert = cbl_qpert
    IF (tpert .LT. 0.0) THEN
      tpert = 0.0
    ELSE
      tpert = tpert
    END IF
    IF (qpert .LT. 0.0) THEN
      qpert = 0.0
    ELSE
      qpert = qpert
    END IF
    IF (frland(i) .LT. 0.1) THEN
      IF (tpert .GT. cbl_tpert_mxocn) THEN
        tpert = cbl_tpert_mxocn
      ELSE
        tpert = tpert
      END IF
    ELSE IF (tpert .GT. cbl_tpert_mxlnd) THEN
      tpert = cbl_tpert_mxlnd
    ELSE
      tpert = tpert
    END IF
    CALL DQSAT_RAS(dqs, qss, tempf, pf, k0, estblx, cons_h2omw, &
&            cons_airmw)
    DO kk=icmin,k+1
      prj(kk) = pke(kk)
    END DO
    prs(icmin:k0+1) = ple(i, icmin:k0+1)
    poi(icmin:k) = tho(i, icmin:k)
    qoi(icmin:k) = qho(i, icmin:k)
    qst(icmin:k) = qss(icmin:k)
    dqq(icmin:k) = dqs(icmin:k)
!Mass fraction of each layer below cloud base
    massf(:) = wgt0(i, :)
!RESET PRESSURE at bottom edge of CBL 
    prcbl = prs(k)
    DO l=k,k0
      prcbl = prcbl + massf(l)*(prs(l+1)-prs(l))
    END DO
    prs(k+1) = prcbl
    prj(k+1) = (prs(k+1)/1000.)**(cons_rgas/cons_cp)
    DO l=k,icmin,-1
      pol(l) = 0.5*(prs(l)+prs(l+1))
      prh(l) = (prs(l+1)*prj(l+1)-prs(l)*prj(l))/(onepkap*(prs(l+1)-prs(&
&       l)))
      pki(l) = 1.0/prh(l)
      dpt(l) = prh(l) - prj(l)
      dpb(l) = prj(l+1) - prh(l)
      pri(l) = .01/(prs(l+1)-prs(l))
    END DO
!RECALCULATE PROFILE QUAN. IN LOWEST STRAPPED LAYER
    IF (k .LE. k0) THEN
      poi(k) = 0.
      qoi(k) = 0.
!SPECIFY WEIGHTS GIVEN TO EACH LAYER WITHIN SUBCLOUD "SUPERLAYER"
      wght = 0.
      DO l=k,k0
        wght(l) = massf(l)*(ple(i, l+1)-ple(i, l))/(prs(k+1)-prs(k))
      END DO
      DO l=k,k0
        poi(k) = poi(k) + wght(l)*tho(i, l)
        qoi(k) = qoi(k) + wght(l)*qho(i, l)
      END DO
      CALL PUSHCONTROL1B(1)
      arg1 = poi(k)*prh(k)
      CALL DQSATS_RAS(dqq(k), qst(k), arg1, pol(k), estblx, cons_h2omw, &
&               cons_airmw)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (seedras(i)/1000000. .LT. 1e-6) THEN
      rndu = 1e-6
    ELSE
      rndu = seedras(i)/1000000.
    END IF
    mxdiam = maxdallowed*rndu**(-(1./2.))
    DO l=k,icmin,-1
!*
      bet(l) = dqq(l)*pki(l)
!*
      gam(l) = pki(l)/(1.0+lbcp*dqq(l))
      IF (l .LT. k) THEN
        ght(l+1) = gam(l)*dpb(l) + gam(l+1)*dpt(l+1)
        gm1(l+1) = 0.5*lbcp*(dqq(l)/(alhl*(1.0+lbcp*dqq(l)))+dqq(l+1)/(&
&         alhl*(1.0+lbcp*dqq(l+1))))
      END IF
    END DO
    rmf = 0.
!DO_TRACERS
    cvw = 0.0
! HOL initialized here in order not to confuse Valgrind debugger
    hol = 0.
    zet(k+1) = 0
    sht(k+1) = cp*poi(k)*prj(k+1)
    DO l=k,icmin,-1
      IF (qst(l)*rhmax .GT. qoi(l)) THEN
        qol(l) = qoi(l)
      ELSE
        qol(l) = qst(l)*rhmax
      END IF
      IF (0.000 .LT. qol(l)) THEN
        qol(l) = qol(l)
      ELSE
        qol(l) = 0.000
      END IF
      ssl(l) = cp*prj(l+1)*poi(l) + grav*zet(l+1)
      hol(l) = ssl(l) + qol(l)*alhl
      hst(l) = ssl(l) + qst(l)*alhl
      tem = poi(l)*(prj(l+1)-prj(l))*cpbg
      zet(l) = zet(l+1) + tem
      zol(l) = zet(l+1) + (prj(l+1)-prh(l))*poi(l)*cpbg
    END DO
    DO ic=k,icmin+1,-1
!DO_TRACERS
      IF (1. .GT. (qoi(k)/qst(k)-rhmn)/(rhmx-rhmn)) THEN
        trg = (qoi(k)/qst(k)-rhmn)/(rhmx-rhmn)
      ELSE
        trg = 1.
      END IF
      IF (0.0 .LT. (autorampb-sige(ic))/0.2) THEN
        y1 = (autorampb-sige(ic))/0.2
      ELSE
        y1 = 0.0
      END IF
      IF (1.0 .GT. y1) THEN
        f4 = y1
      ELSE
        f4 = 1.0
      END IF
      IF (trg .LE. 1.0e-5) THEN
        CALL PUSHCONTROL3B(5)
      ELSE
!================>>
!RECOMPUTE SOUNDING UP TO DETRAINMENT LEVEL
        poi_c = poi
        qoi_c = qoi
        poi_c(k) = poi_c(k) + tpert
        qoi_c(k) = qoi_c(k) + qpert
        zet(k+1) = 0.
        sht(k+1) = cp*poi_c(k)*prj(k+1)
        DO l=k,ic,-1
          IF (qst(l)*rhmax .GT. qoi_c(l)) THEN
            qol(l) = qoi_c(l)
          ELSE
            qol(l) = qst(l)*rhmax
          END IF
          IF (0.000 .LT. qol(l)) THEN
            qol(l) = qol(l)
          ELSE
            qol(l) = 0.000
          END IF
          ssl(l) = cp*prj(l+1)*poi_c(l) + grav*zet(l+1)
          hol(l) = ssl(l) + qol(l)*alhl
          hst(l) = ssl(l) + qst(l)*alhl
          CALL PUSHREAL8(tem)
          tem = poi_c(l)*(prj(l+1)-prj(l))*cpbg
          zet(l) = zet(l+1) + tem
          zol(l) = zet(l+1) + (prj(l+1)-prh(l))*poi_c(l)*cpbg
        END DO
        CALL PUSHINTEGER4(l + 1)
        ad_from = ic + 1
        DO l=ad_from,k
          CALL PUSHREAL8(tem)
          tem = (prj(l)-prh(l-1))/(prh(l)-prh(l-1))
          sht(l) = ssl(l-1) + tem*(ssl(l)-ssl(l-1))
          qht(l) = .5*(qol(l)+qol(l-1))
        END DO
        CALL PUSHINTEGER4(ad_from)
!CALCULATE LAMBDA, ETA, AND WORKFUNCTION
        lambda_min = .2/mxdiam
        lambda_max = .2/200.
        IF (hol(k) .LE. hst(ic)) THEN
          CALL PUSHCONTROL3B(4)
        ELSE
!================>>
!LAMBDA CALCULATION: MS-A18
          CALL PUSHREAL8(tem)
          tem = (hst(ic)-hol(ic))*(zol(ic)-zet(ic+1))
          DO l=ic+1,k-1
            tem = tem + (hst(ic)-hol(l))*(zet(l)-zet(l+1))
          END DO
          IF (tem .LE. 0.0) THEN
            CALL PUSHCONTROL3B(3)
          ELSE
!================>>
            alm = (hol(k)-hst(ic))/tem
            IF (alm .GT. lambda_max) THEN
              CALL PUSHCONTROL3B(2)
            ELSE
!================>>
              toki = 1.0
              IF (alm .LT. lambda_min) toki = (alm/lambda_min)**2
              ad_from0 = ic + 1
!ETA CALCULATION: MS-A2
              DO l=ad_from0,k
                CALL PUSHREAL8(eta(l))
                eta(l) = 1.0 + alm*(zet(l)-zet(k))
              END DO
              CALL PUSHINTEGER4(ad_from0)
              CALL PUSHREAL8(eta(ic))
              eta(ic) = 1.0 + alm*(zol(ic)-zet(k))
!WORKFUNCTION CALCULATION:  MS-A22
              wfn = 0.0
              hcc(k) = hol(k)
              DO l=k-1,ic+1,-1
                hcc(l) = hcc(l+1) + (eta(l)-eta(l+1))*hol(l)
                tem = hcc(l+1)*dpb(l) + hcc(l)*dpt(l)
                eht(l) = eta(l+1)*dpb(l) + eta(l)*dpt(l)
                wfn = wfn + (tem-eht(l)*hst(l))*gam(l)
              END DO
              hcc(ic) = hst(ic)*eta(ic)
              wfn = wfn + (hcc(ic+1)-hst(ic)*eta(ic+1))*gam(ic)*dpb(ic)
!VERTICAL VELOCITY/KE CALCULATION (ADDED 12/2001 JTB)
              bk2(k) = 0.0
              hcld(k) = hol(k)
              DO l=k-1,ic,-1
                hcld(l) = (eta(l+1)*hcld(l+1)+(eta(l)-eta(l+1))*hol(l))/&
&                 eta(l)
                tem = (hcld(l)-hst(l))*(zet(l)-zet(l+1))/(1.0+lbcp*dqq(l&
&                 ))
                IF (tem .LT. 0.0) THEN
                  max1 = 0.0
                ELSE
                  max1 = tem
                END IF
                bk2(l) = bk2(l+1) + grav*max1/(cp*prj(l+1)*poi(l))
                IF (bk2(l) .LT. 0.0) THEN
                  max2 = 0.0
                ELSE
                  max2 = bk2(l)
                END IF
                cvw(l) = SQRT(2.0*max2)
              END DO
!ALPHA CALCULATION 
              IF (zet(ic) .LT. 2000.) rasal(ic) = rasal1
              IF (zet(ic) .GE. 2000.) rasal(ic) = rasal1 + (rasal2-&
&                 rasal1)*(zet(ic)-2000.)/8000.
              IF (rasal(ic) .GT. 1.0e5) THEN
                rasal(ic) = 1.0e5
              ELSE
                rasal(ic) = rasal(ic)
              END IF
              rasal(ic) = dt/rasal(ic)
              DO l=ic,k
                IF (cvw(l) .LT. 1.00) THEN
                  cvw(l) = 1.00
                ELSE
                  cvw(l) = cvw(l)
                END IF
              END DO
              CALL ACRITN(pol(ic), prs(k), acr, acritfac)
              IF (wfn .LE. acr) THEN
                CALL PUSHCONTROL3B(1)
              ELSE
!================>>
!DO_TRACERS
                DO itr=1,itrcr
!Scavenging of the below cloud tracer
                  delzkm = (zet(ic)-zet(k))/1000.
                  x4 = EXP(-(fscav(itr)*delzkm))
                  IF (x4 .GT. 1.) THEN
                    x1 = 1.
                  ELSE
                    x1 = x4
                  END IF
                  IF (x1 .LT. 0.) THEN
                    CALL PUSHREAL8(fnoscav)
                    fnoscav = 0.
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    CALL PUSHREAL8(fnoscav)
                    fnoscav = x1
                    CALL PUSHCONTROL1B(1)
                  END IF
                END DO
                wlq = qol(k)
                DO l=k-1,ic,-1
                  CALL PUSHREAL8(tem)
                  tem = eta(l) - eta(l+1)
                  wlq = wlq + tem*qol(l)
!DO_TRACERS
                  DO itr=1,itrcr
!Scavenging of the entrained tracer.  Updates transported tracer mass.
                    delzkm = (zet(ic)-zet(l+1))/1000.
                    x5 = EXP(-(fscav(itr)*delzkm))
                    IF (x5 .GT. 1.) THEN
                      x2 = 1.
                    ELSE
                      x2 = x5
                    END IF
                    IF (x2 .LT. 0.) THEN
                      CALL PUSHREAL8(fnoscav)
                      fnoscav = 0.
                      CALL PUSHCONTROL1B(0)
                    ELSE
                      CALL PUSHREAL8(fnoscav)
                      fnoscav = x2
                      CALL PUSHCONTROL1B(1)
                    END IF
                  END DO
                  IF (l .GT. ic) THEN
                    tx2 = 0.5*(qst(l)+qst(l-1))*eta(l)
                    tx3 = 0.5*(hst(l)+hst(l-1))*eta(l)
                    qcc = tx2 + gm1(l)*(hcc(l)-tx3)
                    cll0(l) = wlq - qcc
                  ELSE
                    cll0(l) = wlq - qst(ic)*eta(ic)
                  END IF
                  IF (cll0(l) .LT. 0.00) THEN
                    cll0(l) = 0.00
                  ELSE
                    cll0(l) = cll0(l)
                  END IF
                  cli = cll0(l)/eta(l)
                  te_a = poi(l)*prh(l)
                  CALL SUNDQ3_ICE(te_a, sdqv2, sdqv3, sdqvt1, f2, f3)
                  c00_x = co_auto(i)*f2*f3*f4
                  cli_crit_x = cli_crit/(f2*f3)
                  rate = c00_x*(1.0-EXP(-(cli**2/cli_crit_x**2)))
                  IF (cvw(l) .LT. 1.00) THEN
                    cvw_x = 1.00
                  ELSE
                    cvw_x = cvw(l)
                  END IF
                  dt_lyr = (zet(l)-zet(l+1))/cvw_x
                  closs = cll0(l)*rate*dt_lyr
                  IF (closs .GT. cll0(l)) THEN
                    closs = cll0(l)
                  ELSE
                    closs = closs
                  END IF
                  IF (closs .GT. 0.) wlq = wlq - closs
                END DO
                CALL PUSHINTEGER4(l + 1)
                wlq = wlq - qst(ic)*eta(ic)
!CALCULATE GAMMAS AND KERNEL
                gms(k) = (sht(k)-ssl(k))*pri(k)
                gmh(k) = gms(k) + (qht(k)-qol(k))*pri(k)*alhl
                akm = gmh(k)*gam(k-1)*dpb(k-1)
                tx2 = gmh(k)
                DO l=k-1,ic+1,-1
                  gms(l) = (eta(l)*(sht(l)-ssl(l))+eta(l+1)*(ssl(l)-sht(&
&                   l+1)))*pri(l)
                  gmh(l) = gms(l) + (eta(l)*(qht(l)-qol(l))+eta(l+1)*(&
&                   qol(l)-qht(l+1)))*alhl*pri(l)
                  tx2 = tx2 + (eta(l)-eta(l+1))*gmh(l)
                  akm = akm - gms(l)*eht(l)*pki(l) + tx2*ght(l)
                END DO
                gms(ic) = eta(ic+1)*(ssl(ic)-sht(ic+1))*pri(ic)
                akm = akm - gms(ic)*eta(ic+1)*dpb(ic)*pki(ic)
                gmh(ic) = gms(ic) + (eta(ic+1)*(qol(ic)-qht(ic+1))*alhl+&
&                 eta(ic)*(hst(ic)-hol(ic)))*pri(ic)
!CLOUD BASE MASS FLUX
                IF (akm .GE. 0.0 .OR. wlq .LT. 0.0) THEN
                  CALL PUSHCONTROL3B(0)
                ELSE
!================>>
                  wfn = -((wfn-acr)/akm)
                  x3 = rasal(ic)*trg*toki*wfn
                  IF (x3 .GT. (prs(k+1)-prs(k))*(100.*pblfrac)) THEN
                    wfn = (prs(k+1)-prs(k))*(100.*pblfrac)
                  ELSE
                    wfn = x3
                  END IF
!CUMULATIVE PRECIP AND CLOUD-BASE MASS FLUX FOR OUTPUT
                  CALL PUSHREAL8(tem)
                  tem = wfn*gravi
                  rmf(ic) = rmf(ic) + tem
!THETA AND Q CHANGE DUE TO CLOUD TYPE IC
                  DO l=ic,k
                    gmh(l) = gmh(l)*wfn
                    gms(l) = gms(l)*wfn
                    qoi(l) = qoi(l) + (gmh(l)-gms(l))*alhi
                    poi(l) = poi(l) + gms(l)*pki(l)*cpi
                    qst(l) = qst(l) + gms(l)*bet(l)*cpi
                  END DO
!*FRICFAC*0.5
                  wfn = wfn*0.5*1.0
!DO_TRACERS
                  tem = wfn*pri(k)
                  DO itr=1,itrcr
                    DO l=k-1,ic+1,-1
                      CALL PUSHREAL8(tem)
                      tem = wfn*pri(l)
                    END DO
                    CALL PUSHINTEGER4(l + 1)
                  END DO
                  CALL PUSHREAL8(tem)
                  tem = wfn*pri(ic)
                  DO itr=1,itrcr
                    ad_from1 = ic
                    CALL PUSHINTEGER4(ad_from1)
                  END DO
                  CALL PUSHCONTROL3B(6)
                END IF
              END IF
            END IF
          END IF
        END IF
      END IF
    END DO
!CLOUD LOOP
    IF (SUM(rmf(icmin:k)) .GT. 0.0) THEN
!De-strap tendencies from RAS
      CALL PUSHREAL8ARRAY(wght, k0)
      wght = wgt1(i, :)
!Scale properly by layer masses
      wght0 = 0.
      DO l=k,k0
        wght0 = wght0 + wght(l)*(ple(i, l+1)-ple(i, l))
      END DO
      wght0 = (prs(k+1)-prs(k))/wght0
      wght = wght0*wght
      xoib = 0.0_8
      xoi_svb = 0.0_8
      DO itr=itrcr,1,-1
        DO l=k0,k,-1
          xoib(k, itr) = xoib(k, itr) + wght(l)*xhob(i, l, itr)
          xoi_svb(k, itr) = xoi_svb(k, itr) - wght(l)*xhob(i, l, itr)
        END DO
      END DO
      xoib(icmin:k-1, :) = xoib(icmin:k-1, :) + xhob(i, icmin:k-1, :)
      xhob(i, icmin:k-1, :) = 0.0_8
      CALL POPREAL8ARRAY(wght, k0)
    ELSE
      xoib = 0.0_8
      xoi_svb = 0.0_8
    END IF
    xcub = 0.0_8
    xhtb = 0.0_8
    DO ic=icmin+1,k,1
      CALL POPCONTROL3B(branch)
      IF (branch .LT. 3) THEN
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            GOTO 100
          ELSE
            GOTO 110
          END IF
        END IF
      ELSE IF (branch .LT. 5) THEN
        IF (branch .EQ. 3) THEN
          GOTO 110
        ELSE
          GOTO 120
        END IF
      ELSE IF (branch .EQ. 5) THEN
        GOTO 130
      ELSE
        DO itr=itrcr,1,-1
          CALL POPINTEGER4(ad_from1)
          DO l=k,ad_from1,-1
            xcub(l, itr) = xcub(l, itr) + xoib(l, itr)
          END DO
        END DO
        DO itr=itrcr,1,-1
          tempb1 = tem*xcub(ic, itr)
          tempb2 = -(eta(ic+1)*tempb1)
          xhtb(itr) = xhtb(itr) + 2.*tempb1
          xoib(ic, itr) = xoib(ic, itr) + tempb2 - 2.*(eta(ic)-eta(ic+1)&
&           )*tempb1
          xoib(ic+1, itr) = xoib(ic+1, itr) + tempb2
        END DO
        CALL POPREAL8(tem)
        DO itr=itrcr,1,-1
          CALL POPINTEGER4(ad_to1)
          DO l=ad_to1,k-1,1
            tempb = tem*xcub(l, itr)
            tempb0 = eta(l+1)*tempb
            xoib(l-1, itr) = xoib(l-1, itr) + eta(l)*tempb
            xoib(l, itr) = xoib(l, itr) + tempb0 - eta(l)*tempb
            xoib(l+1, itr) = xoib(l+1, itr) - tempb0
            CALL POPREAL8(tem)
          END DO
        END DO
        DO itr=itrcr,1,-1
          xoib(k-1, itr) = xoib(k-1, itr) + tem*xcub(k, itr)
          xoib(k, itr) = xoib(k, itr) - tem*xcub(k, itr)
        END DO
        CALL POPREAL8(tem)
      END IF
      CALL POPINTEGER4(ad_to0)
      DO l=ad_to0,k-1,1
        DO itr=itrcr,1,-1
          xoib(l, itr) = xoib(l, itr) + tem*fnoscav*xhtb(itr)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(fnoscav)
          ELSE
            CALL POPREAL8(fnoscav)
          END IF
        END DO
        CALL POPREAL8(tem)
      END DO
      DO itr=itrcr,1,-1
        xoib(k, itr) = xoib(k, itr) + fnoscav*xhtb(itr)
        xhtb(itr) = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(fnoscav)
        ELSE
          CALL POPREAL8(fnoscav)
        END IF
      END DO
 100  CALL POPREAL8(eta(ic))
      CALL POPINTEGER4(ad_from0)
      DO l=k,ad_from0,-1
        CALL POPREAL8(eta(l))
      END DO
 110  CALL POPREAL8(tem)
 120  CALL POPINTEGER4(ad_from)
      DO l=k,ad_from,-1
        CALL POPREAL8(tem)
      END DO
      CALL POPINTEGER4(ad_to)
      DO l=ad_to,k,1
        CALL POPREAL8(tem)
      END DO
 130  xcub(icmin:k0, :) = 0.0_8
    END DO
    xoib = xoib + xoi_svb
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      DO itr=itrcr,1,-1
        DO l=k0,k,-1
          xhob(i, l, itr) = xhob(i, l, itr) + wght(l)*xoib(k, itr)
        END DO
      END DO
      xoib(k, :) = 0.0_8
    END IF
    DO itr=itrcr,1,-1
      xhob(i, icmin:k, itr) = xhob(i, icmin:k, itr) + xoib(icmin:k, itr)
      xoib(icmin:k, itr) = 0.0_8
    END DO
  END IF
END SUBROUTINE RASE_TRACER_B

