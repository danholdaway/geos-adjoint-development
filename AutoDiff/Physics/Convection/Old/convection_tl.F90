MODULE CONVECTION_TL

USE qsat_util
USE convection

IMPLICIT NONE

PRIVATE
PUBLIC CONVECTION_DRIVER_D

CONTAINS
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.7 (r4786) - 21 Feb 2013 15:53
!
!  Differentiation of convection_driver in forward (tangent) mode:
!   variations   of useful results: th cnv_prc3 q cnv_dqldt u v
!                cnv_updf cnv_mfd
!   with respect to varying inputs: th q u v
!   RW status of diff variables: th:in-out cnv_prc3:out q:in-out
!                cnv_dqldt:out u:in-out v:in-out cnv_updf:out cnv_mfd:out
SUBROUTINE CONVECTION_DRIVER_D(im, jm, lm, pref, dt_moist, frland, kcbl&
&  , ts, rasparams, u, ud, v, vd, th, thd, q, qd, ple, cnv_dqldt, &
&  cnv_dqldtd, cnv_mfd, cnv_mfdd, cnv_prc3, cnv_prc3d, cnv_updf, &
&  cnv_updfd, estblx)
  IMPLICIT NONE
!!INPUTS!!
  INTEGER, INTENT(IN) :: im, jm, lm
  REAL*8, INTENT(IN) :: dt_moist
  REAL*8, DIMENSION(0:lm), INTENT(IN) :: pref
  INTEGER, DIMENSION(im, jm), INTENT(IN) :: kcbl
  REAL*8, DIMENSION(im, jm), INTENT(IN) :: frland
  REAL*8, INTENT(IN) :: rasparams(25)
  REAL*8, DIMENSION(im, jm), INTENT(IN) :: ts
  REAL*8, DIMENSION(im, jm, 0:lm), INTENT(IN) :: ple
!!INOUTS!!
  REAL*8, DIMENSION(im, jm, lm), INTENT(INOUT) :: u, v, th, q
  REAL*8, DIMENSION(im, jm, lm), INTENT(INOUT) :: ud, vd, thd, qd
!!OUTPUTS!!
  REAL*8, DIMENSION(im, jm, lm), INTENT(OUT) :: cnv_dqldt, cnv_mfd, &
&  cnv_prc3, cnv_updf
  REAL*8, DIMENSION(im, jm, lm), INTENT(OUT) :: cnv_dqldtd, cnv_mfdd, &
&  cnv_prc3d, cnv_updfd
!!LOCALS!!
  REAL*8, PARAMETER :: cons_runiv=8314.3, cons_kappa=2.0/7.0, cons_airmw&
&  = 28.97, cons_h2omw=18.01, cons_grav=9.80
  REAL*8, PARAMETER :: cons_rgas=cons_runiv/cons_airmw, cons_cp=&
&    cons_rgas/cons_kappa, cons_vireps=cons_airmw/cons_h2omw-1.0
  INTEGER :: i, j, k, l, ii, jj, idim, k0, icmin
  REAL*8, PARAMETER :: pmin_det=3000.0, cbl_tpert=1.0, cbl_qpert=0.0
  REAL*8, PARAMETER :: autoc_cn_ocn=2.5e-3, autoc_cn_land=2.5e-3
  REAL*8, PARAMETER :: cbl_tpert_mxocn=2.0, cbl_tpert_mxlnd=4.0
  REAL*8, DIMENSION(0:lm) :: sige
  INTEGER, DIMENSION(im, jm) :: seedras
  REAL*8, DIMENSION(im, jm) :: qssfc, tpert, qpert, co_auto
  REAL*8, DIMENSION(im, jm) :: tpertd, qpertd
  REAL*8, DIMENSION(im, jm, 0:lm) :: cnv_ple, pke, zle
  REAL*8, DIMENSION(im, jm, 0:lm) :: zled
  REAL*8, DIMENSION(im, jm, lm) :: plo, pk, temp, dqs, qss, zlo, wgt0, &
&  wgt1
  REAL*8, DIMENSION(im, jm, lm) :: tempd, dqsd, qssd, zlod, wgt0d, wgt1d
!QSATVP TABLE
  REAL*8 :: estblx(:)
  REAL*8, DIMENSION(im, jm, 0:lm) :: pwx1
  REAL*8 :: pwy1
  REAL*8, DIMENSION(im, jm, lm) :: pwx10
  REAL*8, DIMENSION(im, jm) :: arg1
  INTRINSIC MAX
  INTRINSIC INT
  INTRINSIC MIN
!ZERO OUTPUTS
  cnv_dqldt = 0.0
  cnv_mfd = 0.0
  cnv_prc3 = 0.0
  cnv_updf = 0.0
  sige = 0.0
  seedras = 0
  qssfc = 0.0
  tpert = 0.0
  qpert = 0.0
  cnv_ple = 0.0
  pke = 0.0
  zle = 0.0
  plo = 0.0
  pk = 0.0
  temp = 0.0
  dqs = 0.0
  qss = 0.0
  zlo = 0.0
  wgt0 = 0.0
  wgt1 = 0.0
  idim = 1
  k0 = lm
  icmin = 0
  DO l=0,lm
    IF (pref(l) .LT. pmin_det) icmin = icmin + 1
  END DO
  cnv_ple = ple*.01
  plo = 0.5*(cnv_ple(:, :, 0:lm-1)+cnv_ple(:, :, 1:lm))
  pwx1 = cnv_ple/1000.
  pwy1 = cons_rgas/cons_cp
  pke = pwx1**pwy1
  pwx10 = plo/1000.
  pwy1 = cons_rgas/cons_cp
  pk = pwx10**pwy1
  tempd = pk*thd
  temp = th*pk
  qssd = 0.0_8
  dqsd = 0.0_8
  CALL DQSAT_SUB_D(dqs, dqsd, qss, qssd, temp, tempd, plo, im, jm, lm, &
&             estblx)
!GEOS_QSAT( TS , PLE(:,:,LM) ) - Not needed currently as CBL_qpert = 0
  qssfc = 0.0
  zled(:, :, lm) = 0.0_8
  zle(:, :, lm) = 0.
  zlod = 0.0_8
  zled = 0.0_8
  DO l=lm,1,-1
    zled(:, :, l-1) = thd(:, :, l)*(1.+cons_vireps*q(:, :, l)) + th(:, :&
&      , l)*cons_vireps*qd(:, :, l)
    zle(:, :, l-1) = th(:, :, l)*(1.+cons_vireps*q(:, :, l))
    zlod(:, :, l) = zled(:, :, l) + cons_cp*(pke(:, :, l)-pk(:, :, l))*&
&      zled(:, :, l-1)/cons_grav
    zlo(:, :, l) = zle(:, :, l) + cons_cp/cons_grav*(pke(:, :, l)-pk(:, &
&      :, l))*zle(:, :, l-1)
    zled(:, :, l-1) = zlod(:, :, l) + cons_cp*(pk(:, :, l)-pke(:, :, l-1&
&      ))*zled(:, :, l-1)/cons_grav
    zle(:, :, l-1) = zlo(:, :, l) + cons_cp/cons_grav*(pk(:, :, l)-pke(:&
&      , :, l-1))*zle(:, :, l-1)
  END DO
  tpertd = cbl_tpert*(-tempd(:, :, lm)-cons_grav*zlod(:, :, lm)/cons_cp)
  tpert = cbl_tpert*(ts-(temp(:, :, lm)+cons_grav*zlo(:, :, lm)/cons_cp)&
&    )
  qpertd = -(cbl_qpert*qd(:, :, lm))
  qpert = cbl_qpert*(qssfc-q(:, :, lm))
  WHERE (tpert .LT. 0.0) 
    tpertd = 0.0_8
    tpert = 0.0
  ELSEWHERE
    tpert = tpert
  END WHERE
  WHERE (tpert .GT. cbl_tpert_mxocn) 
    tpertd = 0.0_8
    tpert = cbl_tpert_mxocn
  ELSEWHERE
    tpert = tpert
  END WHERE
  WHERE (tpert .GT. cbl_tpert_mxlnd) 
    tpertd = 0.0_8
    tpert = cbl_tpert_mxlnd
  ELSEWHERE
    tpert = tpert
  END WHERE
! ocean value
  WHERE (frland .LT. 0.1) 
    co_auto = autoc_cn_ocn
  ELSEWHERE
    co_auto = autoc_cn_land
  END WHERE
  arg1(:, :) = 1000000*(100*temp(:, :, lm)-INT(100*temp(:, :, lm)))
  seedras(:, :) = INT(arg1(:, :))
  sige = pref/pref(lm)
  DO i=1,im
    DO j=1,jm
      wgt0d(i, j, :) = 0.0_8
      wgt0(i, j, :) = 0.
      wgt0d(i, j, kcbl(i, j):k0) = 0.0_8
      wgt0(i, j, kcbl(i, j):k0) = 1.0
      wgt1d(i, j, :) = 0.0_8
      wgt1(i, j, :) = 0.
      wgt1d(i, j, kcbl(i, j):k0) = 0.0_8
      wgt1(i, j, kcbl(i, j):k0) = 1.0
    END DO
  END DO
!!where? see below.
! inputs for CBL
! inputs
! Pass in CO_AUTO
!
! outputs
! -> progno_cloud
! -> progno_cloud
! -> progno_cloud 
! -> progno_cloud
! params
  CALL RASE_D(idim, k0, icmin, dt_moist, seedras, sige, kcbl, wgt0, wgt1&
&        , tpert, tpertd, qpert, qpertd, th, thd, q, qd, u, ud, v, vd, &
&        qss, qssd, dqs, dqsd, co_auto, cnv_ple, pke, cnv_dqldt, &
&        cnv_dqldtd, cnv_mfd, cnv_mfdd, cnv_prc3, cnv_prc3d, cnv_updf, &
&        cnv_updfd, rasparams, estblx)
END SUBROUTINE CONVECTION_DRIVER_D

!  Differentiation of rase in forward (tangent) mode:
!   variations   of useful results: ccnv_prc3 clw tho qho vho cnv_updfrc
!                uho flxd
!   with respect to varying inputs: tho cdqs qho cqpert vho uho
!                cqss ctpert
SUBROUTINE RASE_D(idim, k0, icmin, dt, seedras, sige, kcbl, wgt0, wgt1, &
&  ctpert, ctpertd, cqpert, cqpertd, tho, thod, qho, qhod, uho, uhod, vho&
&  , vhod, cqss, cqssd, cdqs, cdqsd, cco_auto, cple, cpke, clw, clwd, &
&  flxd, flxdd, ccnv_prc3, ccnv_prc3d, cnv_updfrc, cnv_updfrcd, rasparams&
&  , estblx)
  IMPLICIT NONE
!ARGUMENTS
  INTEGER, INTENT(IN) :: idim, k0, icmin
  REAL*8, DIMENSION(idim, k0), INTENT(INOUT) :: tho, qho, uho, vho
  REAL*8, DIMENSION(idim, k0), INTENT(INOUT) :: thod, qhod, uhod, vhod
  REAL*8, DIMENSION(idim, k0 + 1), INTENT(IN) :: cple, cpke
  REAL*8, DIMENSION(idim, k0), INTENT(IN) :: cqss, cdqs
  REAL*8, DIMENSION(idim, k0), INTENT(IN) :: cqssd, cdqsd
  REAL*8, DIMENSION(k0 + 1), INTENT(IN) :: sige
  REAL*8, DIMENSION(idim, k0), INTENT(OUT) :: clw, flxd
  REAL*8, DIMENSION(idim, k0), INTENT(OUT) :: clwd, flxdd
  REAL*8, DIMENSION(idim, k0), INTENT(OUT) :: ccnv_prc3
  REAL*8, DIMENSION(idim, k0), INTENT(OUT) :: ccnv_prc3d
  REAL*8, DIMENSION(idim, k0), INTENT(OUT) :: cnv_updfrc
  REAL*8, DIMENSION(idim, k0), INTENT(OUT) :: cnv_updfrcd
  REAL*8, INTENT(IN) :: dt
  INTEGER, DIMENSION(idim), INTENT(IN) :: seedras
  INTEGER, DIMENSION(idim), INTENT(IN) :: kcbl
  REAL*8, DIMENSION(idim), INTENT(IN) :: ctpert, cqpert
  REAL*8, DIMENSION(idim), INTENT(IN) :: ctpertd, cqpertd
  REAL*8, DIMENSION(idim), INTENT(IN) :: cco_auto
  REAL*8, DIMENSION(idim, k0), INTENT(IN) :: wgt0, wgt1
  REAL*8, DIMENSION(:), INTENT(IN) :: rasparams
  REAL*8, DIMENSION(:), INTENT(IN) :: estblx
!RASPARAMS REDEFINED
  REAL*8 :: fricfac, cli_crit, rasal1, rasal2, friclambda, sdqv2, sdqv3&
&  , sdqvt1, mxdiam
  REAL*8 :: acritfac, hmintrigger, pblfrac, autorampb, co_zdep, &
&  maxdallowed, rhmn, rhmx
!GLOBAL CONSTANTS
  REAL*8, PARAMETER :: cons_runiv=8314.3, cons_grav=9.80, cons_kappa=2.0&
&    /7.0, cons_airmw=28.97, cons_alhl=2.4665e6
  REAL*8, PARAMETER :: cons_rgas=cons_runiv/cons_airmw, cons_cp=&
&    cons_rgas/cons_kappa
  REAL*8, PARAMETER :: onepkap=1.+2./7., daylen=86400.0, rhmax=0.9999
  REAL*8 :: grav, cp, alhl, cpbg, alhi, cpi, gravi, ddt, lbcp
!LOCALS
  INTEGER :: i, k, ic, l
  REAL*8, DIMENSION(k0) :: poi_sv, qoi_sv, uoi_sv, voi_sv
  REAL*8, DIMENSION(k0) :: poi_svd, qoi_svd, uoi_svd, voi_svd
  REAL*8, DIMENSION(k0) :: poi, qoi, uoi, voi, dqq, bet, gam, cll
  REAL*8, DIMENSION(k0) :: poid, qoid, uoid, void0, dqqd, betd, gamd, &
&  clld
  REAL*8, DIMENSION(k0) :: poi_c, qoi_c
  REAL*8, DIMENSION(k0) :: poi_cd, qoi_cd
  REAL*8, DIMENSION(k0) :: prh, pri, ght, dpt, dpb, pki
  REAL*8, DIMENSION(k0) :: prhd, ghtd, dptd, dpbd, pkid
  REAL*8, DIMENSION(k0) :: tcu, qcu, rns, pol
  REAL*8, DIMENSION(k0) :: rnsd, pold
  REAL*8, DIMENSION(k0) :: qst, ssl, rmf, rmfc, rmfp
  REAL*8, DIMENSION(k0) :: qstd, ssld, rmfpd
  REAL*8, DIMENSION(k0) :: gm1, rmfd
  REAL*8, DIMENSION(k0) :: gm1d, rmfdd
  REAL*8, DIMENSION(k0) :: hol, hst, qol, zol, cll0, clli, cllb
  REAL*8, DIMENSION(k0) :: hold, hstd, qold, zold, cll0d
  REAL*8, DIMENSION(k0) :: cvw, updfrc
  REAL*8, DIMENSION(k0) :: cvwd, updfrcd
  REAL*8, DIMENSION(k0) :: updfrp, dll0, dllx
  REAL*8, DIMENSION(k0) :: updfrpd
  REAL*8, DIMENSION(k0 + 1) :: prj, prs, sht, zet
  REAL*8, DIMENSION(k0+1) :: prjd, prsd, shtd, zetd
  REAL*8 :: tema, temb, temc
  REAL*8 :: temad
!QSATVP LOOKUP TABLE
  INTEGER, PARAMETER :: degsubs=100
  REAL*8, PARAMETER :: tmintbl=150.0, tmaxtbl=333.0
  INTEGER, PARAMETER :: tablesize=NINT(tmaxtbl-tmintbl)*degsubs+1
  INTRINSIC MAX
  INTRINSIC SUM
  INTRINSIC NINT
  INTRINSIC MIN
!ZERO OUTPUTS
  clw = 0.0
  flxd = 0.0
  ccnv_prc3 = 0.0
  cnv_updfrc = 0.0
!Zero locals, taf linearisation safety measure
  poi_sv = 0.0
  qoi_sv = 0.0
  uoi_sv = 0.0
  voi_sv = 0.0
  poi = 0.0
  qoi = 0.0
  uoi = 0.0
  voi = 0.0
  dqq = 0.0
  bet = 0.0
  gam = 0.0
  cll = 0.0
  poi_c = 0.0
  qoi_c = 0.0
  prh = 0.0
  pri = 0.0
  ght = 0.0
  dpt = 0.0
  dpb = 0.0
  pki = 0.0
  tcu = 0.0
  qcu = 0.0
  rns = 0.0
  pol = 0.0
  qst = 0.0
  ssl = 0.0
  rmf = 0.0
  rmfc = 0.0
  rmfp = 0.0
  gm1 = 0.0
  rmfd = 0.0
  hol = 0.0
  hst = 0.0
  qol = 0.0
  zol = 0.0
  cll0 = 0.0
  clli = 0.0
  cllb = 0.0
  cvw = 0.0
  updfrc = 0.0
  updfrp = 0.0
  dll0 = 0.0
  dllx = 0.0
  prj = 0.0
  prs = 0.0
  sht = 0.0
  zet = 0.0
  tema = 0.0
  temb = 0.0
  temc = 0.0
!ASSIGN RASPARAMS NEEDED
!  ---  1
  fricfac = rasparams(1)
!  ---  4
  cli_crit = rasparams(4)
!  ---  5
  rasal1 = rasparams(5)
!  ---  6
  rasal2 = rasparams(6)
!  --- 11
  friclambda = rasparams(11)
!  --- 14
  sdqv2 = rasparams(14)
!  --- 15
  sdqv3 = rasparams(15)
!  --- 16
  sdqvt1 = rasparams(16)
!  --- 17
  acritfac = rasparams(17)
!  --- 18
  hmintrigger = rasparams(18)
!  --- 20
  pblfrac = rasparams(20)
!  --- 21
  autorampb = rasparams(21)
!  --- 22
  co_zdep = rasparams(22)
!  --- 23
  maxdallowed = rasparams(23)
!  --- 24
  rhmn = rasparams(24)
!  --- 25
  rhmx = rasparams(25)
!ASIGN RASE CONSTANTS
  grav = cons_grav
  alhl = cons_alhl
  cp = cons_cp
  cpi = 1.0/cp
  alhi = 1.0/alhl
  gravi = 1.0/grav
  cpbg = cp*gravi
  ddt = daylen/dt
  lbcp = alhl*cpi
  i = 1
!!CALL FINDBASE
  k = kcbl(i)
  IF (k .GT. 0) THEN
    CALL STRAP0_D(i, k, k0, idim, icmin, cpke, cple, uho, uhod, vho, &
&            vhod, tho, thod, qho, qhod, cdqs, cdqsd, cqss, cqssd, estblx&
&            , seedras, wgt0, mxdiam, poi, poid, qoi, qoid, uoi, uoid, &
&            voi, void0, prj, prjd, prs, prsd, qst, qstd, dqq, dqqd, &
&            cons_rgas, cons_cp, onepkap, pol, pold, prh, prhd, pki, pkid&
&            , dpt, dptd, dpb, dpbd, pri, maxdallowed, bet, betd, gam, &
&            gamd, lbcp, ght, ghtd, gm1, gm1d, alhl, tcu, qcu, rns, cll, &
&            rmf, rmfd, rmfc, rmfp, cll0, dll0, dllx, clli, cllb, cvw, &
&            updfrc, updfrp, poi_sv, poi_svd, qoi_sv, qoi_svd, uoi_sv, &
&            uoi_svd, voi_sv, voi_svd)
!HTEST ROUTINE
    hol = 0.0
    zetd(k+1) = 0.0_8
    zet(k+1) = 0
    shtd = 0.0_8
    shtd(k+1) = cp*prj(k+1)*poid(k)
    sht(k+1) = cp*poi(k)*prj(k+1)
    hstd = 0.0_8
    qold = 0.0_8
    ssld = 0.0_8
    zetd = 0.0_8
    zold = 0.0_8
    hold = 0.0_8
    DO l=k,icmin,-1
      IF (qst(l)*rhmax .GT. qoi(l)) THEN
        qold(l) = qoid(l)
        qol(l) = qoi(l)
      ELSE
        qold(l) = rhmax*qstd(l)
        qol(l) = qst(l)*rhmax
      END IF
      IF (0.000 .LT. qol(l)) THEN
        qol(l) = qol(l)
      ELSE
        qold(l) = 0.0_8
        qol(l) = 0.000
      END IF
      ssld(l) = cp*prj(l+1)*poid(l) + grav*zetd(l+1)
      ssl(l) = cp*prj(l+1)*poi(l) + grav*zet(l+1)
      hold(l) = ssld(l) + alhl*qold(l)
      hol(l) = ssl(l) + qol(l)*alhl
      hstd(l) = ssld(l) + alhl*qstd(l)
      hst(l) = ssl(l) + qst(l)*alhl
      temad = (prj(l+1)-prj(l))*cpbg*poid(l)
      tema = poi(l)*(prj(l+1)-prj(l))*cpbg
      zetd(l) = zetd(l+1) + temad
      zet(l) = zet(l+1) + tema
      zold(l) = zetd(l+1) + (prj(l+1)-prh(l))*cpbg*poid(l)
      zol(l) = zet(l+1) + (prj(l+1)-prh(l))*poi(l)*cpbg
    END DO
!END HTEST ROUTINE
!MAIN CLOUD LOOP
    CALL CLOUDE_D(i, k, k0, idim, icmin, dt, ddt, daylen, rhmn, rhmx, &
&            autorampb, co_zdep, cp, cpi, rhmax, grav, gravi, alhi, alhl&
&            , cpbg, lbcp, rasal1, rasal2, acritfac, sdqv2, sdqv3, sdqvt1&
&            , cli_crit, pblfrac, fricfac, friclambda, qoi, qoid, qst, &
&            qstd, poi, poid, uoi, uoid, voi, void0, sige, poi_c, poi_cd&
&            , qoi_c, qoi_cd, ctpert, ctpertd, cqpert, cqpertd, mxdiam, &
&            cco_auto, zet, zetd, sht, shtd, qol, qold, ssl, ssld, hol, &
&            hold, hst, hstd, zol, zold, prj, prh, dpb, dpt, bet, betd, &
&            gam, gamd, cvw, cvwd, dqq, dqqd, pol, prs, cll0, cll0d, dll0&
&            , gm1, gm1d, pri, ght, ghtd, pki, cll, clld, rmf, rmfd, &
&            rmfdd, rmfp, rmfpd, rmfc, dllx, updfrp, updfrpd, updfrc, &
&            updfrcd, clli, cllb, rns, rnsd)
    IF (SUM(rmf(icmin:k)) .GT. 0.0) THEN
!RNEVP ROUTINE
      zet(k+1) = 0
      DO l=k,icmin,-1
        temb = poi(l)*(prj(l+1)-prj(l))*cpbg
        zet(l) = zet(l+1) + temb
      END DO
      ccnv_prc3d = 0.0_8
      DO l=icmin,k
        temc = pri(l)*grav
        ccnv_prc3d(i, l) = temc*rnsd(l)
        ccnv_prc3(i, l) = rns(l)*temc
      END DO
!END RNEVP ROUTINE
      CALL STRAP1_D(i, k, k0, idim, icmin, tho, thod, qho, qhod, uho, &
&              uhod, vho, vhod, cnv_updfrc, cnv_updfrcd, cple, flxd, &
&              flxdd, clw, clwd, wgt1, poi, poid, qoi, qoid, uoi, uoid, &
&              voi, void0, updfrc, updfrcd, cvw, cllb, prs, poi_sv, &
&              poi_svd, qoi_sv, qoi_svd, uoi_sv, uoi_svd, voi_sv, voi_svd&
&              , rmf, rmfd, rmfdd, rmfc, cll, clld, ddt, daylen)
    ELSE
      flxdd(i, :) = 0.0_8
      flxd(i, :) = 0.
      clwd(i, :) = 0.0_8
      clw(i, :) = 0.
      ccnv_prc3d = 0.0_8
      clwd = 0.0_8
      cnv_updfrcd = 0.0_8
      flxdd = 0.0_8
    END IF
  ELSE
    flxdd(i, :) = 0.0_8
    flxd(i, :) = 0.
    clwd(i, :) = 0.0_8
    clw(i, :) = 0.
    ccnv_prc3d = 0.0_8
    clwd = 0.0_8
    cnv_updfrcd = 0.0_8
    flxdd = 0.0_8
  END IF
  RETURN
END SUBROUTINE RASE_D

!  Differentiation of cloude in forward (tangent) mode:
!   variations   of useful results: qoi voi updfrc poi rns uoi
!                rmfd cll
!   with respect to varying inputs: gm1 dqq ght bet hst cqpert
!                qoi qol voi sht qst poi uoi ssl zet zol ctpert
!                hol gam
SUBROUTINE CLOUDE_D(i, k, k0, idim, icmin, dt, ddt, daylen, rhmn, rhmx, &
&  autorampb, co_zdep, cp, cpi, rhmax, grav, gravi, alhi, alhl, cpbg, &
&  lbcp, rasal1, rasal2, acritfac, sdqv2, sdqv3, sdqvt1, cli_crit, &
&  pblfrac, fricfac, friclambda, qoi, qoid, qst, qstd, poi, poid, uoi, &
&  uoid, voi, void0, sige, poi_c, poi_cd, qoi_c, qoi_cd, ctpert, ctpertd&
&  , cqpert, cqpertd, mxdiam, cco_auto, zet, zetd, sht, shtd, qol, qold, &
&  ssl, ssld, hol, hold, hst, hstd, zol, zold, prj, prh, dpb, dpt, bet, &
&  betd, gam, gamd, cvw, cvwd, dqq, dqqd, pol, prs, cll0, cll0d, dll0, &
&  gm1, gm1d, pri, ght, ghtd, pki, cll, clld, rmf, rmfd, rmfdd, rmfp, &
&  rmfpd, rmfc, dllx, updfrp, updfrpd, updfrc, updfrcd, clli, cllb, rns, &
&  rnsd)
  IMPLICIT NONE
!!GLOBALS!!
  INTEGER :: i, k, k0, idim, icmin
  REAL*8 :: dt, ddt, daylen, rhmn, rhmx, autorampb, co_zdep, cp, cpi, &
&  rhmax, grav, gravi, alhi, alhl, cpbg, lbcp
  REAL*8 :: rasal1, rasal2, acritfac, sdqv2, sdqv3, sdqvt1, cli_crit, &
&  pblfrac, fricfac, friclambda, mxdiam
  REAL*8, DIMENSION(idim) :: ctpert, cqpert, cco_auto
  REAL*8, DIMENSION(idim) :: ctpertd, cqpertd
  REAL*8, DIMENSION(k0) :: qoi, qst, poi, uoi, voi, poi_c, qoi_c
  REAL*8, DIMENSION(k0) :: qoid, qstd, poid, uoid, void0, poi_cd, qoi_cd
  REAL*8, DIMENSION(k0) :: qol, ssl, hol, hst, zol, prh, dpb, dpt, bet, &
&  gam, cvw
  REAL*8, DIMENSION(k0) :: qold, ssld, hold, hstd, zold, betd, gamd, &
&  cvwd
  REAL*8, DIMENSION(k0) :: dqq, pol, cll0, dll0, gm1, pri, ght, pki
  REAL*8, DIMENSION(k0) :: dqqd, cll0d, gm1d, ghtd
  REAL*8, DIMENSION(k0) :: cll, rmf, rmfd, rmfp, rmfc, dllx, updfrp, &
&  updfrc, clli, cllb, rns
  REAL*8, DIMENSION(k0) :: clld, rmfdd, rmfpd, updfrpd, updfrcd, rnsd
  REAL*8, DIMENSION(k0 + 1) :: sige, zet, sht, prj, prs
  REAL*8, DIMENSION(k0+1) :: zetd, shtd
!!LOCALS!!
  INTEGER :: ic, l, rc, icl, icl_c, n_dtl
  REAL*8 :: te0, te1, te2, jump1
  REAL*8 :: tem1, tem2, tem3, tem4, tem5, tem6, tem7, tem8, tem9, tem10
  REAL*8 :: tem1d, tem3d, tem4d, tem5d, tem6d, tem7d, tem8d, tem9d, &
&  tem10d
  REAL*8 :: alm, trg, lambda_min, lambda_max
  REAL*8 :: almd, trgd
  REAL*8 :: wfn, wfn1, wfn2, acr, akm, wlq, uht, vht, tx2, tx3, qcc
  REAL*8 :: wfnd, wfn1d, wfn2d, akmd, wlqd, uhtd, vhtd, tx2d, tx3d, qccd
  REAL*8 :: cli, te_a, c00_x, cli_crit_x, toki
  REAL*8 :: clid, te_ad, c00_xd, cli_crit_xd, tokid
  REAL*8 :: dt_lyr, rate, cvw_x, closs, f2, f4, f5
  REAL*8 :: dt_lyrd, rated, cvw_xd, clossd, f2d
  REAL*8, DIMENSION(k0) :: eta, hcc, eht, bk2, hcld, rasal, rnn, ucu, &
&  vcu
  REAL*8, DIMENSION(k0) :: etad, hccd, ehtd, bk2d, hcldd, rasald, rnnd, &
&  ucud, vcud
  REAL*8, DIMENSION(k0) :: gms, gms1, gmh
  REAL*8, DIMENSION(k0) :: gmsd, gms1d, gmhd
  REAL*8, DIMENSION(k0 + 1) :: qht
  REAL*8, DIMENSION(k0+1) :: qhtd
  REAL*8 :: arg1
  REAL*8 :: arg1d
  INTRINSIC EXP
  REAL*8 :: max2d
  INTRINSIC MAX
  INTRINSIC ABS
  REAL*8 :: x1
  REAL*8 :: max1d
  REAL*8 :: x1d
  REAL*8 :: abs8
  REAL*8 :: abs7
  REAL*8 :: abs6
  REAL*8 :: abs5
  REAL*8 :: abs4
  REAL*8 :: abs3
  REAL*8 :: abs2
  REAL*8 :: abs1
  REAL*8 :: abs0
  INTRINSIC MIN
  INTRINSIC SQRT
  REAL*8 :: max2
  REAL*8 :: max1
  REAL*8 :: y1
!LOCALS TO ZERO
  cli = 0.0
  te_a = 0.0
  c00_x = 0.0
  cli_crit_x = 0.0
  toki = 0.0
  dt_lyr = 0.0
  rate = 0.0
  cvw_x = 0.0
  closs = 0.0
  f2 = 0.0
  f4 = 0.0
  f5 = 0.0
  alm = 0.0
  trg = 0.0
  tem1 = 0.0
  tem2 = 0.0
  tem3 = 0.0
  tem4 = 0.0
  tem5 = 0.0
  tem6 = 0.0
  tem7 = 0.0
  tem8 = 0.0
  tem9 = 0.0
  tem10 = 0.0
  lambda_min = 0.0
  lambda_max = 0.0
  wfn = 0.0
  wfn1 = 0.0
  wfn2 = 0.0
  acr = 0.0
  akm = 0.0
  wlq = 0.0
  uht = 0.0
  vht = 0.0
  tx2 = 0.0
  tx3 = 0.0
  qcc = 0.0
  eta = 0.0
  hcc = 0.0
  eht = 0.0
  bk2 = 0.0
  hcld = 0.0
  rasal = 0.0
  rnn = 0.0
  ucu = 0.0
  vcu = 0.0
  qht = 0.0
  gms = 0.0
  gms1 = 0.0
  gmh = 0.0
  te0 = 273.0
  te1 = sdqvt1
  te2 = 200.
  jump1 = (sdqv2-1.0)/(te0-te1)**0.333
  n_dtl = k - icmin
  cvwd = 0.0_8
  updfrcd = 0.0_8
  rnsd = 0.0_8
  rmfdd = 0.0_8
  updfrpd = 0.0_8
  cll0d = 0.0_8
  clld = 0.0_8
  rmfpd = 0.0_8
  ehtd = 0.0_8
  wfn1d = 0.0_8
  hccd = 0.0_8
  trgd = 0.0_8
  ucud = 0.0_8
  qhtd = 0.0_8
  gms1d = 0.0_8
  bk2d = 0.0_8
  rasald = 0.0_8
  hcldd = 0.0_8
  etad = 0.0_8
  gmhd = 0.0_8
  rnnd = 0.0_8
  gmsd = 0.0_8
  vcud = 0.0_8
!CLOUD LOOP
  DO icl_c=1,n_dtl
!ICL_V( ICL_C )
    icl = k - icl_c
! This change makes cumulus friction
    ucud(icmin:) = 0.0_8
    ucu(icmin:) = 0.
! correct.
    vcud(icmin:) = 0.0_8
    vcu(icmin:) = 0.
    IF (icl .GT. icmin) THEN
      ic = icl
      rc = 10
      alm = 0.
      IF (qst(k) .GE. 0.) THEN
        abs0 = qst(k)
      ELSE
        abs0 = -qst(k)
      END IF
      IF (abs0 .GT. 0.0) THEN
        IF (1. .GT. (qoi(k)/qst(k)-rhmn)/(rhmx-rhmn)) THEN
          trgd = (qoid(k)*qst(k)-qoi(k)*qstd(k))/qst(k)**2/(rhmx-rhmn)
          trg = (qoi(k)/qst(k)-rhmn)/(rhmx-rhmn)
        ELSE
          trg = 1.
          trgd = 0.0_8
        END IF
      END IF
      IF (0.0 .LT. (autorampb-sige(ic))/0.2) THEN
        y1 = (autorampb-sige(ic))/0.2
      ELSE
        y1 = 0.0
      END IF
      IF (1.0 .GT. y1) THEN
        f4 = y1
      ELSE
        f4 = 1.0
      END IF
! to 1 at SIG=AUTORAMPB-0.2
!if ( SIGE(IC) >= 0.5 ) then
!   F5 = 1.0
!else
!   F5 = 1.0 - 2.*CO_ZDEP *( 0.5 - SIGE(IC) )
!   F5 = MAX( F5 , 0.0 )
!endif
      IF (trg .LE. 1.0e-5) rc = 1
! TRIGGER  =========>>      
!RETURN
!RC = 1
      IF (rc .EQ. 10) THEN
!RECOMPUTE SOUNDING UP TO DETRAINMENT LEVEL
        poi_cd = poid
        poi_c = poi
        qoi_cd = qoid
        qoi_c = qoi
        poi_cd(k) = poi_cd(k) + ctpertd(i)
        poi_c(k) = poi_c(k) + ctpert(i)
        qoi_cd(k) = qoi_cd(k) + cqpertd(i)
        qoi_c(k) = qoi_c(k) + cqpert(i)
        zetd(k+1) = 0.0_8
        zet(k+1) = 0.
        shtd(k+1) = cp*prj(k+1)*poi_cd(k)
        sht(k+1) = cp*poi_c(k)*prj(k+1)
        DO l=k,ic,-1
          IF (qst(l)*rhmax .GT. qoi_c(l)) THEN
            qold(l) = qoi_cd(l)
            qol(l) = qoi_c(l)
          ELSE
            qold(l) = rhmax*qstd(l)
            qol(l) = qst(l)*rhmax
          END IF
          IF (0.000 .LT. qol(l)) THEN
            qol(l) = qol(l)
          ELSE
            qold(l) = 0.0_8
            qol(l) = 0.000
          END IF
          ssld(l) = cp*prj(l+1)*poi_cd(l) + grav*zetd(l+1)
          ssl(l) = cp*prj(l+1)*poi_c(l) + grav*zet(l+1)
          hold(l) = ssld(l) + alhl*qold(l)
          hol(l) = ssl(l) + qol(l)*alhl
          hstd(l) = ssld(l) + alhl*qstd(l)
          hst(l) = ssl(l) + qst(l)*alhl
          tem1d = (prj(l+1)-prj(l))*cpbg*poi_cd(l)
          tem1 = poi_c(l)*(prj(l+1)-prj(l))*cpbg
          zetd(l) = zetd(l+1) + tem1d
          zet(l) = zet(l+1) + tem1
          zold(l) = zetd(l+1) + (prj(l+1)-prh(l))*cpbg*poi_cd(l)
          zol(l) = zet(l+1) + (prj(l+1)-prh(l))*poi_c(l)*cpbg
        END DO
        DO l=ic+1,k
          tem2 = (prj(l)-prh(l-1))/(prh(l)-prh(l-1))
          shtd(l) = ssld(l-1) + tem2*(ssld(l)-ssld(l-1))
          sht(l) = ssl(l-1) + tem2*(ssl(l)-ssl(l-1))
          qhtd(l) = .5*(qold(l)+qold(l-1))
          qht(l) = .5*(qol(l)+qol(l-1))
        END DO
!CALCULATE LAMBDA, ETA, AND WORKFUNCTION
        lambda_min = .2/mxdiam
        lambda_max = .2/200.
        IF (hol(k) .LE. hst(ic)) rc = 2
! CANNOT REACH IC LEVEL  ======>>
!RETURN
!====EXIT====>
!RC = 2
        IF (rc .EQ. 10) THEN
!LAMBDA CALCULATION: MS-A18
          tem3d = (hstd(ic)-hold(ic))*(zol(ic)-zet(ic+1)) + (hst(ic)-hol&
&            (ic))*(zold(ic)-zetd(ic+1))
          tem3 = (hst(ic)-hol(ic))*(zol(ic)-zet(ic+1))
          DO l=ic+1,k-1
            tem3d = tem3d + (hstd(ic)-hold(l))*(zet(l)-zet(l+1)) + (hst(&
&              ic)-hol(l))*(zetd(l)-zetd(l+1))
            tem3 = tem3 + (hst(ic)-hol(l))*(zet(l)-zet(l+1))
          END DO
          IF (tem3 .LE. 0.0) rc = 3
! NO VALID LAMBDA  ============>>
!RETURN
!====EXIT====>
!RC = 3
          IF (rc .EQ. 10) THEN
            IF (tem3 .GE. 0.) THEN
              abs1 = tem3
            ELSE
              abs1 = -tem3
            END IF
            IF (abs1 .GT. 0.0) THEN
!Linearisation security
              almd = ((hold(k)-hstd(ic))*tem3-(hol(k)-hst(ic))*tem3d)/&
&                tem3**2
              alm = (hol(k)-hst(ic))/tem3
            ELSE
              almd = 0.0_8
            END IF
            IF (alm .GT. lambda_max) rc = 4
!RETURN
!====EXIT====>
!RC = 4
            IF (rc .EQ. 10) THEN
              toki = 1.0
              IF (alm .LT. lambda_min) THEN
                tokid = 2*alm*almd/lambda_min**2
                toki = (alm/lambda_min)**2
              ELSE
                tokid = 0.0_8
              END IF
!ETA CALCULATION: MS-A2
              DO l=ic+1,k
                etad(l) = almd*(zet(l)-zet(k)) + alm*(zetd(l)-zetd(k))
                eta(l) = 1.0 + alm*(zet(l)-zet(k))
              END DO
              etad(ic) = almd*(zol(ic)-zet(k)) + alm*(zold(ic)-zetd(k))
              eta(ic) = 1.0 + alm*(zol(ic)-zet(k))
!WORKFUNCTION CALCULATION:  MS-A22
              wfn = 0.0
              hccd(k) = hold(k)
              hcc(k) = hol(k)
              wfnd = 0.0_8
              DO l=k-1,ic+1,-1
                hccd(l) = hccd(l+1) + (etad(l)-etad(l+1))*hol(l) + (eta(&
&                  l)-eta(l+1))*hold(l)
                hcc(l) = hcc(l+1) + (eta(l)-eta(l+1))*hol(l)
                tem4d = dpb(l)*hccd(l+1) + dpt(l)*hccd(l)
                tem4 = hcc(l+1)*dpb(l) + hcc(l)*dpt(l)
                ehtd(l) = dpb(l)*etad(l+1) + dpt(l)*etad(l)
                eht(l) = eta(l+1)*dpb(l) + eta(l)*dpt(l)
                wfnd = wfnd + (tem4d-ehtd(l)*hst(l)-eht(l)*hstd(l))*gam(&
&                  l) + (tem4-eht(l)*hst(l))*gamd(l)
                wfn = wfn + (tem4-eht(l)*hst(l))*gam(l)
              END DO
              hccd(ic) = hstd(ic)*eta(ic) + hst(ic)*etad(ic)
              hcc(ic) = hst(ic)*eta(ic)
              wfnd = wfnd + dpb(ic)*((hccd(ic+1)-hstd(ic)*eta(ic+1)-hst(&
&                ic)*etad(ic+1))*gam(ic)+(hcc(ic+1)-hst(ic)*eta(ic+1))*&
&                gamd(ic))
              wfn = wfn + (hcc(ic+1)-hst(ic)*eta(ic+1))*gam(ic)*dpb(ic)
!VERTICAL VELOCITY/KE CALCULATION (ADDED 12/2001 JTB)
              hcldd(k) = hold(k)
              hcld(k) = hol(k)
              DO l=k-1,ic,-1
                IF (eta(l) .GE. 0.) THEN
                  abs2 = eta(l)
                ELSE
                  abs2 = -eta(l)
                END IF
                IF (abs2 .GT. 0.0) THEN
!Linearisation security
                  hcldd(l) = ((etad(l+1)*hcld(l+1)+eta(l+1)*hcldd(l+1)+(&
&                    etad(l)-etad(l+1))*hol(l)+(eta(l)-eta(l+1))*hold(l))&
&                    *(eta(l)+1e-15)-(eta(l+1)*hcld(l+1)+(eta(l)-eta(l+1)&
&                    )*hol(l))*etad(l))/(eta(l)+1e-15)**2
                  hcld(l) = (eta(l+1)*hcld(l+1)+(eta(l)-eta(l+1))*hol(l)&
&                    )/(eta(l)+1e-15)
                END IF
              END DO
              bk2d(k) = 0.0_8
              bk2(k) = 0.0
              DO l=k-1,ic,-1
                IF (1.0 + lbcp*dqq(l) .GE. 0.) THEN
                  abs3 = 1.0 + lbcp*dqq(l)
                ELSE
                  abs3 = -(1.0+lbcp*dqq(l))
                END IF
                IF (abs3 .GT. 0.0) THEN
!Linearisation security
                  tem5d = (((hcldd(l)-hstd(l))*(zet(l)-zet(l+1))+(hcld(l&
&                    )-hst(l))*(zetd(l)-zetd(l+1)))*(1.0+lbcp*dqq(l)+&
&                    1e-15)-(hcld(l)-hst(l))*(zet(l)-zet(l+1))*lbcp*dqqd(&
&                    l))/(1.0+lbcp*dqq(l)+1e-15)**2
                  tem5 = (hcld(l)-hst(l))*(zet(l)-zet(l+1))/(1.0+lbcp*&
&                    dqq(l)+1e-15)
                  IF (cp*prj(l+1)*poi(l) .GE. 0.) THEN
                    abs4 = cp*prj(l+1)*poi(l)
                  ELSE
                    abs4 = -(cp*prj(l+1)*poi(l))
                  END IF
                  IF (abs4 .GT. 0.0) THEN
                    IF (tem5 .LT. 0.0) THEN
                      max1 = 0.0
                      max1d = 0.0_8
                    ELSE
                      max1d = tem5d
                      max1 = tem5
                    END IF
!Linearisation security
                    bk2d(l) = bk2d(l+1) + (grav*max1d*cp*prj(l+1)*poi(l)&
&                      -grav*max1*cp*prj(l+1)*poid(l))/(cp*prj(l+1)*poi(l&
&                      ))**2
                    bk2(l) = bk2(l+1) + grav*max1/(cp*prj(l+1)*poi(l))
                  END IF
                END IF
                IF (bk2(l) .LT. 0.0) THEN
                  max2 = 0.0
                  max2d = 0.0_8
                ELSE
                  max2d = bk2d(l)
                  max2 = bk2(l)
                END IF
                IF (2.0*max2 .EQ. 0.0) THEN
                  cvwd(l) = 0.0_8
                ELSE
                  cvwd(l) = max2d/SQRT(2.0*max2)
                END IF
                cvw(l) = SQRT(2.0*max2)
              END DO
!ALPHA CALCULATION 
              rasald(ic) = 0.0_8
              rasal(ic) = dt/rasal1
              IF (zet(ic) .GE. 2000.) THEN
                rasald(ic) = -(dt*(rasal2-rasal1)*zetd(ic)/8000./(rasal1&
&                  +(rasal2-rasal1)*(zet(ic)-2000.)/8000.)**2)
                rasal(ic) = dt/(rasal1+(rasal2-rasal1)*(zet(ic)-2000.)/&
&                  8000.)
!RASAL(IC) = MIN( RASAL(IC) , 1.0e5 )
!RASAL(IC) = DT / RASAL(IC)
              END IF
              WHERE (cvw(ic:k) .LT. 1.00) 
                cvwd(ic:k) = 0.0_8
                cvw(ic:k) = 1.00
              ELSEWHERE
                cvw(ic:k) = cvw(ic:k)
              END WHERE
!TEST FOR CRITICAL WORK FUNCTION
              CALL ACRITN(pol(ic), prs(k), acritfac, acr)
              IF (wfn .LE. acr) rc = 5
! SUB-CRITICAL WORK FUNCTION ======>>
!RETURN
!====EXIT====>
!RC = 5
!CLOUD TOP WATER AND MOMENTUM (TIMES ETA(IC)) MS-A16
              IF (rc .EQ. 10) THEN
                wlqd = qold(k)
                wlq = qol(k)
                uhtd = uoid(k)
                uht = uoi(k)
                vhtd = void0(k)
                vht = voi(k)
                rnnd(k) = 0.0_8
                rnn(k) = 0.
                cll0d(k) = 0.0_8
                cll0(k) = 0.
                DO l=k-1,ic,-1
                  tem6d = etad(l) - etad(l+1)
                  tem6 = eta(l) - eta(l+1)
                  wlqd = wlqd + tem6d*qol(l) + tem6*qold(l)
                  wlq = wlq + tem6*qol(l)
                  uhtd = uhtd + tem6d*uoi(l) + tem6*uoid(l)
                  uht = uht + tem6*uoi(l)
                  vhtd = vhtd + tem6d*voi(l) + tem6*void0(l)
                  vht = vht + tem6*voi(l)
!!!! How much condensate (CLI) is present here? 
                  IF (l .GT. ic) THEN
                    tx2d = 0.5*((qstd(l)+qstd(l-1))*eta(l)+(qst(l)+qst(l&
&                      -1))*etad(l))
                    tx2 = 0.5*(qst(l)+qst(l-1))*eta(l)
                    tx3d = 0.5*((hstd(l)+hstd(l-1))*eta(l)+(hst(l)+hst(l&
&                      -1))*etad(l))
                    tx3 = 0.5*(hst(l)+hst(l-1))*eta(l)
                    qccd = tx2d + gm1d(l)*(hcc(l)-tx3) + gm1(l)*(hccd(l)&
&                      -tx3d)
                    qcc = tx2 + gm1(l)*(hcc(l)-tx3)
                    cll0d(l) = wlqd - qccd
                    cll0(l) = wlq - qcc
                  ELSE
                    cll0d(l) = wlqd - qstd(ic)*eta(ic) - qst(ic)*etad(ic&
&                      )
                    cll0(l) = wlq - qst(ic)*eta(ic)
                  END IF
                  IF (cll0(l) .LT. 0.00) THEN
                    cll0d(l) = 0.0_8
                    cll0(l) = 0.00
                  ELSE
                    cll0(l) = cll0(l)
                  END IF
! Temperature (K)
                  te_ad = prh(l)*poid(l)
                  te_a = poi(l)*prh(l)
                  IF (eta(l) .GE. 0.) THEN
                    abs5 = eta(l)
                  ELSE
                    abs5 = -eta(l)
                  END IF
                  IF (abs5 .GT. 0.0) THEN
!Linearisation security
!SUNDQ3_ICE
                    f2 = 1.0
                    IF (te_a .GE. te1 .AND. te_a .LT. te0) THEN
                      f2d = -(jump1*0.3333*(te0-te_a)**(-0.6667)*te_ad)
                      f2 = 1.0 + jump1*(te0-te_a)**0.3333
                    ELSE IF (te_a .LT. te1) THEN
                      f2d = (-((sdqv3-sdqv2)*te_ad))/(te1-te2)
                      f2 = sdqv2 + (sdqv3-sdqv2)*(te1-te_a)/(te1-te2)
                    ELSE
                      f2d = 0.0_8
                    END IF
!end sundq3_ice
! * F5  ! F4 reduces AUTO for shallow clouds, F5 modifies auto for deep clouds
                    c00_xd = cco_auto(i)*f4*f2d
                    c00_x = cco_auto(i)*f2*f4
                    cli_crit_xd = -(cli_crit*f2d/f2**2)
                    cli_crit_x = cli_crit/f2
! condensate (kg/kg)  
                    clid = (cll0d(l)*eta(l)-cll0(l)*etad(l))/eta(l)**2
                    cli = cll0(l)/eta(l)
                    arg1d = -((2*cli*clid*(cli_crit_x**2+10e-15)-cli**2*&
&                      2*cli_crit_x*cli_crit_xd)/(cli_crit_x**2+10e-15)**&
&                      2)
                    arg1 = -(cli**2/(cli_crit_x**2+10e-15))
                    rated = c00_xd*(1.0-EXP(arg1)) - c00_x*arg1d*EXP(&
&                      arg1)
                    rate = c00_x*(1.0-EXP(arg1))
                    IF (cvw(l) .LT. 1.00) THEN
                      cvw_x = 1.00
                      cvw_xd = 0.0_8
                    ELSE
                      cvw_xd = cvwd(l)
                      cvw_x = cvw(l)
                    END IF
! l.h.s. DT_LYR => time in layer (L,L+1)
                    dt_lyrd = ((zetd(l)-zetd(l+1))*cvw_x-(zet(l)-zet(l+1&
&                      ))*cvw_xd)/cvw_x**2
                    dt_lyr = (zet(l)-zet(l+1))/cvw_x
                    clossd = cll0d(l)*rate*dt_lyr + cll0(l)*(rated*&
&                      dt_lyr+rate*dt_lyrd)
                    closs = cll0(l)*rate*dt_lyr
                    IF (closs .GT. cll0(l)) THEN
                      clossd = cll0d(l)
                      closs = cll0(l)
                    ELSE
                      closs = closs
                    END IF
                    cll0d(l) = cll0d(l) - clossd
                    cll0(l) = cll0(l) - closs
                    dll0(l) = closs
                    IF (closs .GT. 0.) THEN
                      wlqd = wlqd - clossd
                      wlq = wlq - closs
                      rnnd(l) = clossd
                      rnn(l) = closs
                    ELSE
                      rnnd(l) = 0.0_8
                      rnn(l) = 0.
                    END IF
                  END IF
                END DO
                wlqd = wlqd - qstd(ic)*eta(ic) - qst(ic)*etad(ic)
                wlq = wlq - qst(ic)*eta(ic)
!CALCULATE GAMMAS AND KERNEL
! MS-A30 (W/O GRAV)
                gmsd(k) = pri(k)*(shtd(k)-ssld(k))
                gms(k) = (sht(k)-ssl(k))*pri(k)
! MS-A31 (W/O GRAV)
                gmhd(k) = gmsd(k) + pri(k)*alhl*(qhtd(k)-qold(k))
                gmh(k) = gms(k) + (qht(k)-qol(k))*pri(k)*alhl
! MS-A37 (W/O GRAV)
                akmd = dpb(k-1)*(gmhd(k)*gam(k-1)+gmh(k)*gamd(k-1))
                akm = gmh(k)*gam(k-1)*dpb(k-1)
                tx2d = gmhd(k)
                tx2 = gmh(k)
                DO l=k-1,ic+1,-1
                  gmsd(l) = pri(l)*(etad(l)*(sht(l)-ssl(l))+eta(l)*(shtd&
&                    (l)-ssld(l))+etad(l+1)*(ssl(l)-sht(l+1))+eta(l+1)*(&
&                    ssld(l)-shtd(l+1)))
                  gms(l) = (eta(l)*(sht(l)-ssl(l))+eta(l+1)*(ssl(l)-sht(&
&                    l+1)))*pri(l)
                  gmhd(l) = gmsd(l) + alhl*pri(l)*(etad(l)*(qht(l)-qol(l&
&                    ))+eta(l)*(qhtd(l)-qold(l))+etad(l+1)*(qol(l)-qht(l+&
&                    1))+eta(l+1)*(qold(l)-qhtd(l+1)))
                  gmh(l) = gms(l) + (eta(l)*(qht(l)-qol(l))+eta(l+1)*(&
&                    qol(l)-qht(l+1)))*alhl*pri(l)
                  tx2d = tx2d + (etad(l)-etad(l+1))*gmh(l) + (eta(l)-eta&
&                    (l+1))*gmhd(l)
                  tx2 = tx2 + (eta(l)-eta(l+1))*gmh(l)
                  akmd = akmd - pki(l)*(gmsd(l)*eht(l)+gms(l)*ehtd(l)) +&
&                    tx2d*ght(l) + tx2*ghtd(l)
                  akm = akm - gms(l)*eht(l)*pki(l) + tx2*ght(l)
                END DO
                gmsd(ic) = pri(ic)*(etad(ic+1)*(ssl(ic)-sht(ic+1))+eta(&
&                  ic+1)*(ssld(ic)-shtd(ic+1)))
                gms(ic) = eta(ic+1)*(ssl(ic)-sht(ic+1))*pri(ic)
                akmd = akmd - dpb(ic)*pki(ic)*(gmsd(ic)*eta(ic+1)+gms(ic&
&                  )*etad(ic+1))
                akm = akm - gms(ic)*eta(ic+1)*dpb(ic)*pki(ic)
                gmhd(ic) = gmsd(ic) + pri(ic)*(alhl*(etad(ic+1)*(qol(ic)&
&                  -qht(ic+1))+eta(ic+1)*(qold(ic)-qhtd(ic+1)))+etad(ic)*&
&                  (hst(ic)-hol(ic))+eta(ic)*(hstd(ic)-hold(ic)))
                gmh(ic) = gms(ic) + (eta(ic+1)*(qol(ic)-qht(ic+1))*alhl+&
&                  eta(ic)*(hst(ic)-hol(ic)))*pri(ic)
!CLOUD BASE MASS FLUX
                IF (akm .GE. 0.0 .OR. wlq .LT. 0.0) rc = 6
!  =========>
!RETURN
!====EXIT====>
!RC = 6
                IF (rc .EQ. 10) THEN
                  IF (akm .GE. 0.) THEN
                    abs6 = akm
                  ELSE
                    abs6 = -akm
                  END IF
                  IF (abs6 .GT. 0.0) THEN
!Linearisation security
! MS-A39 MASS-FLUX IN Pa/step
                    wfn1d = -((wfnd*akm-(wfn-acr)*akmd)/akm**2)
                    wfn1 = -((wfn-acr)/akm)
                    x1d = (rasald(ic)*wfn1+rasal(ic)*wfn1d)*trg*toki + &
&                      rasal(ic)*wfn1*(trgd*toki+trg*tokid)
                    x1 = rasal(ic)*trg*toki*wfn1
                    IF (x1 .GT. (prs(k+1)-prs(k))*(100.*pblfrac)) THEN
                      wfn1 = (prs(k+1)-prs(k))*(100.*pblfrac)
                      wfn1d = 0.0_8
                    ELSE
                      wfn1d = x1d
                      wfn1 = x1
                    END IF
                  END IF
!CUMULATIVE PRECIP AND CLOUD-BASE MASS FLUX FOR OUTPUT
                  tem7d = gravi*wfn1d
                  tem7 = wfn1*gravi
! (kg/m^2/step)
                  clld(ic) = clld(ic) + wlqd*tem7 + wlq*tem7d
                  cll(ic) = cll(ic) + wlq*tem7
! (kg/m^2/step)
                  rmf(ic) = rmf(ic) + tem7
! (kg/m^2/step)
                  rmfdd(ic) = rmfdd(ic) + tem7d*eta(ic) + tem7*etad(ic)
                  rmfd(ic) = rmfd(ic) + tem7*eta(ic)
                  DO l=ic+1,k
! (kg/m^2/step)
                    rmfpd(l) = tem7d*eta(l) + tem7*etad(l)
                    rmfp(l) = tem7*eta(l)
! (kg/m^2/step)
                    rmfc(l) = rmfc(l) + rmfp(l)
                    dllx(l) = dllx(l) + tem7*dll0(l)
                    IF (cvw(l) .GT. 0.0) THEN
                      IF (cvw(l)*prs(l) .GE. 0.) THEN
                        abs7 = cvw(l)*prs(l)
                      ELSE
                        abs7 = -(cvw(l)*prs(l))
                      END IF
                      IF (abs7 .GT. 0.0) THEN
!Linearisation security
                        updfrpd(l) = (ddt*1000.*rmfpd(l)*cvw(l)*prs(l)/&
&                          daylen-rmfp(l)*ddt*1000.*prs(l)*cvwd(l)/daylen&
&                          )/(cvw(l)*prs(l))**2
                        updfrp(l) = rmfp(l)*(ddt/daylen)*1000./(cvw(l)*&
&                          prs(l))
                      END IF
                    ELSE
                      updfrpd(l) = 0.0_8
                      updfrp(l) = 0.0
                    END IF
                    IF (eta(l) .GE. 0.) THEN
                      abs8 = eta(l)
                    ELSE
                      abs8 = -eta(l)
                    END IF
                    IF (abs8 .GT. 0.0) clli(l) = cll0(l)/eta(l)
!Linearisation security
! current cloud; incloud condensate        
!  cumulative grid mean convective condensate        
                    cllb(l) = cllb(l) + updfrp(l)*clli(l)
                    updfrcd(l) = updfrcd(l) + updfrpd(l)
                    updfrc(l) = updfrc(l) + updfrp(l)
                  END DO
!THETA AND Q CHANGE DUE TO CLOUD TYPE IC
                  DO l=ic,k
! (kg/m^2/step)
                    rnsd(l) = rnsd(l) + rnnd(l)*tem7 + rnn(l)*tem7d
                    rns(l) = rns(l) + rnn(l)*tem7
                    gmhd(l) = gmhd(l)*wfn1 + gmh(l)*wfn1d
                    gmh(l) = gmh(l)*wfn1
                    gms1d(l) = gmsd(l)*wfn1 + gms(l)*wfn1d
                    gms1(l) = gms(l)*wfn1
                    qoid(l) = qoid(l) + alhi*(gmhd(l)-gms1d(l))
                    qoi(l) = qoi(l) + (gmh(l)-gms1(l))*alhi
                    poid(l) = poid(l) + pki(l)*cpi*gms1d(l)
                    poi(l) = poi(l) + gms1(l)*pki(l)*cpi
                    qstd(l) = qstd(l) + cpi*(gms1d(l)*bet(l)+gms1(l)*&
&                      betd(l))
                    qst(l) = qst(l) + gms1(l)*bet(l)*cpi
                  END DO
!CUMULUS FRICTION
                  IF (fricfac .LE. 0.0) rc = 6
!RETURN  !  NO CUMULUS FRICTION =========>>
                  IF (rc .EQ. 10) THEN
!*FRICFAC*0.5
                    wfn2d = 0.5*wfn1d
                    wfn2 = wfn1*0.5*1.0
                    wfn2d = fricfac*(wfn2d*EXP(-(alm/friclambda))-wfn2*&
&                      almd*EXP(-(alm/friclambda))/friclambda)
                    wfn2 = wfn2*fricfac*EXP(-(alm/friclambda))
                    tem8d = pri(k)*wfn2d
                    tem8 = wfn2*pri(k)
                    ucud(k) = ucud(k) + tem8d*(uoi(k-1)-uoi(k)) + tem8*(&
&                      uoid(k-1)-uoid(k))
                    ucu(k) = ucu(k) + tem8*(uoi(k-1)-uoi(k))
                    vcud(k) = vcud(k) + tem8d*(voi(k-1)-voi(k)) + tem8*(&
&                      void0(k-1)-void0(k))
                    vcu(k) = vcu(k) + tem8*(voi(k-1)-voi(k))
                    DO l=k-1,ic+1,-1
                      tem9d = pri(l)*wfn2d
                      tem9 = wfn2*pri(l)
                      ucud(l) = ucud(l) + tem9d*((uoi(l-1)-uoi(l))*eta(l&
&                        )+(uoi(l)-uoi(l+1))*eta(l+1)) + tem9*((uoid(l-1)&
&                        -uoid(l))*eta(l)+(uoi(l-1)-uoi(l))*etad(l)+(uoid&
&                        (l)-uoid(l+1))*eta(l+1)+(uoi(l)-uoi(l+1))*etad(l&
&                        +1))
                      ucu(l) = ucu(l) + tem9*((uoi(l-1)-uoi(l))*eta(l)+(&
&                        uoi(l)-uoi(l+1))*eta(l+1))
                      vcud(l) = vcud(l) + tem9d*((voi(l-1)-voi(l))*eta(l&
&                        )+(voi(l)-voi(l+1))*eta(l+1)) + tem9*((void0(l-1&
&                        )-void0(l))*eta(l)+(voi(l-1)-voi(l))*etad(l)+(&
&                        void0(l)-void0(l+1))*eta(l+1)+(voi(l)-voi(l+1))*&
&                        etad(l+1))
                      vcu(l) = vcu(l) + tem9*((voi(l-1)-voi(l))*eta(l)+(&
&                        voi(l)-voi(l+1))*eta(l+1))
                    END DO
                    tem10d = pri(ic)*wfn2d
                    tem10 = wfn2*pri(ic)
                    ucud(ic) = ucud(ic) + (2.*(uhtd-uoid(ic)*(eta(ic)-&
&                      eta(ic+1))-uoi(ic)*(etad(ic)-etad(ic+1)))-(uoid(ic&
&                      )+uoid(ic+1))*eta(ic+1)-(uoi(ic)+uoi(ic+1))*etad(&
&                      ic+1))*tem10 + (2.*(uht-uoi(ic)*(eta(ic)-eta(ic+1)&
&                      ))-(uoi(ic)+uoi(ic+1))*eta(ic+1))*tem10d
                    ucu(ic) = ucu(ic) + (2.*(uht-uoi(ic)*(eta(ic)-eta(ic&
&                      +1)))-(uoi(ic)+uoi(ic+1))*eta(ic+1))*tem10
                    vcud(ic) = vcud(ic) + (2.*(vhtd-void0(ic)*(eta(ic)-&
&                      eta(ic+1))-voi(ic)*(etad(ic)-etad(ic+1)))-(void0(&
&                      ic)+void0(ic+1))*eta(ic+1)-(voi(ic)+voi(ic+1))*&
&                      etad(ic+1))*tem10 + (2.*(vht-voi(ic)*(eta(ic)-eta(&
&                      ic+1)))-(voi(ic)+voi(ic+1))*eta(ic+1))*tem10d
                    vcu(ic) = vcu(ic) + (2.*(vht-voi(ic)*(eta(ic)-eta(ic&
&                      +1)))-(voi(ic)+voi(ic+1))*eta(ic+1))*tem10
                    DO l=ic,k
                      uoid(l) = uoid(l) + ucud(l)
                      uoi(l) = uoi(l) + ucu(l)
                      void0(l) = void0(l) + vcud(l)
                      voi(l) = voi(l) + vcu(l)
                    END DO
                  END IF
!DID EVERYTHING (Exc Cumulus Friction)
                  rc = 0
                END IF
              END IF
            END IF
          END IF
        END IF
      END IF
    END IF
  END DO
  RETURN
END SUBROUTINE CLOUDE_D

!  Differentiation of strap0 in forward (tangent) mode:
!   variations   of useful results: gm1 dqq ght bet qoi_sv uoi_sv
!                qoi voi qst poi poi_sv uoi voi_sv gam
!   with respect to varying inputs: tho cdqs qho vho uho cqss
SUBROUTINE STRAP0_D(i, k, k0, idim, icmin, cpke, cple, uho, uhod, vho, &
&  vhod, tho, thod, qho, qhod, cdqs, cdqsd, cqss, cqssd, estblx, seedras&
&  , wgt0, mxdiam, poi, poid, qoi, qoid, uoi, uoid, voi, void0, prj, prjd&
&  , prs, prsd, qst, qstd, dqq, dqqd, cons_rgas, cons_cp, onepkap, pol, &
&  pold, prh, prhd, pki, pkid, dpt, dptd, dpb, dpbd, pri, maxdallowed, &
&  bet, betd, gam, gamd, lbcp, ght, ghtd, gm1, gm1d, alhl, tcu, qcu, rns&
&  , cll, rmf, rmfd, rmfc, rmfp, cll0, dll0, dllx, clli, cllb, cvw, &
&  updfrc, updfrp, poi_sv, poi_svd, qoi_sv, qoi_svd, uoi_sv, uoi_svd, &
&  voi_sv, voi_svd)
  IMPLICIT NONE
!!GLOBALS!!
  INTEGER :: i, k, k0, idim, icmin
  INTEGER, DIMENSION(idim) :: seedras
  REAL*8, DIMENSION(idim, k0) :: uho, vho, tho, qho, cdqs, cqss, wgt0
  REAL*8, DIMENSION(idim, k0) :: uhod, vhod, thod, qhod, cdqsd, cqssd
  REAL*8, DIMENSION(idim, k0 + 1) :: cpke, cple
  REAL*8 :: cons_rgas, cons_cp
  REAL*8 :: onepkap, maxdallowed, lbcp, alhl, mxdiam
  REAL*8, DIMENSION(k0 + 1) :: prj, prs
  REAL*8, DIMENSION(k0+1) :: prjd, prsd
  REAL*8, DIMENSION(k0) :: poi, qoi, uoi, voi, qst, dqq, temp1
  REAL*8, DIMENSION(k0) :: poid, qoid, uoid, void0, qstd, dqqd, temp1d
  REAL*8, DIMENSION(k0) :: pol, prh, pki, dpt, dpb, pri
  REAL*8, DIMENSION(k0) :: pold, prhd, pkid, dptd, dpbd
  REAL*8, DIMENSION(k0) :: bet, gam, ght, gm1, tcu, qcu
  REAL*8, DIMENSION(k0) :: betd, gamd, ghtd, gm1d
  REAL*8, DIMENSION(k0) :: poi_sv, qoi_sv, uoi_sv, voi_sv
  REAL*8, DIMENSION(k0) :: poi_svd, qoi_svd, uoi_svd, voi_svd
  REAL*8, DIMENSION(k0) :: rns, cll, rmf, rmfd, rmfc, rmfp, cll0, dll0, &
&  dllx, clli, cllb, cvw, updfrc, updfrp
!!LOCALS!!
  INTEGER :: l, kk
  REAL*8 :: wght0, prcbl, rndu
  REAL*8, DIMENSION(k0) :: wght, massf
  REAL*8, DIMENSION(k0) :: wghtd
!Table lookup constants
  REAL*8 :: estblx(:)
  REAL*8 :: pwx1
  REAL*8 :: pwy1
  REAL*8 :: pwr1
  INTRINSIC MAX
!Zero locals
  wght0 = 0.0
  prcbl = 0.0
  rndu = 0.0
  wght = 0.0
  massf = 0.0
  DO kk=icmin,k+1
    prjd(kk) = 0.0_8
    prj(kk) = cpke(i, kk)
  END DO
! These initialized here in order not to confuse Valgrind debugger
  poi = 0.
! Do not believe it actually makes any difference.
  qoi = 0.
  uoi = 0.
  voi = 0.
  prsd(icmin:k0+1) = 0.0_8
  prs(icmin:k0+1) = cple(i, icmin:k0+1)
  poid = 0.0_8
  poid(icmin:k) = thod(i, icmin:k)
  poi(icmin:k) = tho(i, icmin:k)
  qoid = 0.0_8
  qoid(icmin:k) = qhod(i, icmin:k)
  qoi(icmin:k) = qho(i, icmin:k)
  uoid = 0.0_8
  uoid(icmin:k) = uhod(i, icmin:k)
  uoi(icmin:k) = uho(i, icmin:k)
  void0 = 0.0_8
  void0(icmin:k) = vhod(i, icmin:k)
  voi(icmin:k) = vho(i, icmin:k)
  qstd = 0.0_8
  qstd(icmin:k) = cqssd(i, icmin:k)
  qst(icmin:k) = cqss(i, icmin:k)
  dqqd = 0.0_8
  dqqd(icmin:k) = cdqsd(i, icmin:k)
  dqq(icmin:k) = cdqs(i, icmin:k)
!!! Mass fraction of each layer below cloud base
!!! contributed to aggregate cloudbase layer (CBL) 
  massf(:) = wgt0(i, :)
!!! RESET PRESSURE at bottom edge of CBL 
  prcbl = prs(k)
  DO l=k,k0
    prcbl = prcbl + massf(l)*(prs(l+1)-prs(l))
  END DO
  prsd(k+1) = 0.0_8
  prs(k+1) = prcbl
  pwx1 = prs(k+1)/1000.
  pwy1 = cons_rgas/cons_cp
  prjd(k+1) = 0.0_8
  prj(k+1) = pwx1**pwy1
  DO l=k,icmin,-1
    pold(l) = 0.0_8
    pol(l) = 0.5*(prs(l)+prs(l+1))
    prhd(l) = 0.0_8
    prh(l) = (prs(l+1)*prj(l+1)-prs(l)*prj(l))/(onepkap*(prs(l+1)-prs(l)&
&      ))
    pkid(l) = 0.0_8
    pki(l) = 1.0/prh(l)
    dptd(l) = 0.0_8
    dpt(l) = prh(l) - prj(l)
    dpbd(l) = 0.0_8
    dpb(l) = prj(l+1) - prh(l)
    pri(l) = .01/(prs(l+1)-prs(l))
  END DO
!!!!! RECALCULATE PROFILE QUAN. IN LOWEST STRAPPED LAYER
  IF (k .LE. k0) THEN
    poid(k) = 0.0_8
    poi(k) = 0.
    qoid(k) = 0.0_8
    qoi(k) = 0.
    uoid(k) = 0.0_8
    uoi(k) = 0.
    void0(k) = 0.0_8
    voi(k) = 0.
!! SPECIFY WEIGHTS GIVEN TO EACH LAYER WITHIN SUBCLOUD "SUPERLAYER"
    wght = 0.
    DO l=k,k0
      wghtd(l) = 0.0_8
      wght(l) = massf(l)*(cple(i, l+1)-cple(i, l))/(prs(k+1)-prs(k))
    END DO
    DO l=k,k0
      poid(k) = poid(k) + wght(l)*thod(i, l)
      poi(k) = poi(k) + wght(l)*tho(i, l)
      qoid(k) = qoid(k) + wght(l)*qhod(i, l)
      qoi(k) = qoi(k) + wght(l)*qho(i, l)
      uoid(k) = uoid(k) + wght(l)*uhod(i, l)
      uoi(k) = uoi(k) + wght(l)*uho(i, l)
      void0(k) = void0(k) + wght(l)*vhod(i, l)
      voi(k) = voi(k) + wght(l)*vho(i, l)
    END DO
    dqqd(k) = 0.0_8
    dqq(k) = 0.0
    qstd(k) = 0.0_8
    qst(k) = 0.0
    temp1d = 0.0_8
    temp1d(k) = prh(k)*poid(k)
    temp1(k) = poi(k)*prh(k)
    CALL DQSAT_SUB_D(dqq(k), dqqd(k), qst(k), qstd(k), temp1(k), temp1d(&
&               k), pol(k), 1, 1, 1, estblx)
  END IF
  IF (seedras(i)/1000000. .LT. 1e-6) THEN
    rndu = 1e-6
  ELSE
    rndu = seedras(i)/1000000.
  END IF
  pwr1 = rndu**(-(1./2.))
  mxdiam = maxdallowed*pwr1
  gm1d = 0.0_8
  ghtd = 0.0_8
  betd = 0.0_8
  gamd = 0.0_8
  DO l=k,icmin,-1
!*
    betd(l) = pki(l)*dqqd(l)
    bet(l) = dqq(l)*pki(l)
!*
    gamd(l) = -(pki(l)*lbcp*dqqd(l)/(1.0+lbcp*dqq(l))**2)
    gam(l) = pki(l)/(1.0+lbcp*dqq(l))
    IF (l .LT. k) THEN
      ghtd(l+1) = dpb(l)*gamd(l) + dpt(l+1)*gamd(l+1)
      ght(l+1) = gam(l)*dpb(l) + gam(l+1)*dpt(l+1)
      gm1d(l+1) = 0.5*lbcp*((dqqd(l)*alhl*(1.0+lbcp*dqq(l))-dqq(l)*alhl*&
&        lbcp*dqqd(l))/(alhl*(1.0+lbcp*dqq(l)))**2+(dqqd(l+1)*alhl*(1.0+&
&        lbcp*dqq(l+1))-dqq(l+1)*alhl*lbcp*dqqd(l+1))/(alhl*(1.0+lbcp*dqq&
&        (l+1)))**2)
      gm1(l+1) = 0.5*lbcp*(dqq(l)/(alhl*(1.0+lbcp*dqq(l)))+dqq(l+1)/(&
&        alhl*(1.0+lbcp*dqq(l+1))))
    END IF
  END DO
  tcu(icmin:k) = -(poi(icmin:k)*prh(icmin:k))
  qcu(icmin:k) = -qoi(icmin:k)
  rns = 0.
  cll = 0.
  rmf = 0.
  rmfd = 0.
  rmfc = 0.
  rmfp = 0.
  cll0 = 0.
  dll0 = 0.
  dllx = 0.
  clli = 0.
  cllb = 0.
  poi_svd = poid
  poi_sv = poi
  qoi_svd = qoid
  qoi_sv = qoi
  uoi_svd = uoid
  uoi_sv = uoi
  voi_svd = void0
  voi_sv = voi
  cvw = 0.0
  updfrc = 0.0
  updfrp = 0.0
END SUBROUTINE STRAP0_D

!  Differentiation of strap1 in forward (tangent) mode:
!   variations   of useful results: clw tho qho vho cnv_updfrc
!                uho flxd
!   with respect to varying inputs: tho qho qoi_sv vho uoi_sv qoi
!                voi uho updfrc poi poi_sv uoi rmfd voi_sv cll
SUBROUTINE STRAP1_D(i, k, k0, idim, icmin, tho, thod, qho, qhod, uho, &
&  uhod, vho, vhod, cnv_updfrc, cnv_updfrcd, cple, flxd, flxdd, clw, clwd&
&  , wgt1, poi, poid, qoi, qoid, uoi, uoid, voi, void0, updfrc, updfrcd, &
&  cvw, cllb, prs, poi_sv, poi_svd, qoi_sv, qoi_svd, uoi_sv, uoi_svd, &
&  voi_sv, voi_svd, rmf, rmfd, rmfdd, rmfc, cll, clld, ddt, daylen)
  IMPLICIT NONE
!!GLOBALS!!
  INTEGER :: i, k, k0, idim, icmin
  REAL*8 :: ddt, daylen
  REAL*8, DIMENSION(idim, k0) :: tho, qho, uho, vho
  REAL*8, DIMENSION(idim, k0) :: thod, qhod, uhod, vhod
  REAL*8, DIMENSION(idim, k0) :: cnv_updfrc, flxd, clw, wgt1
  REAL*8, DIMENSION(idim, k0) :: cnv_updfrcd, flxdd, clwd
  REAL*8, DIMENSION(idim, k0 + 1) :: cple
  REAL*8, DIMENSION(k0) :: poi, qoi, uoi, voi, poi_sv, qoi_sv, uoi_sv, &
&  voi_sv
  REAL*8, DIMENSION(k0) :: poid, qoid, uoid, void0, poi_svd, qoi_svd, &
&  uoi_svd, voi_svd
  REAL*8, DIMENSION(k0) :: updfrc, cvw, cllb, prs, rmf, rmfd, rmfc, cll
  REAL*8, DIMENSION(k0) :: updfrcd, rmfdd, clld
!!LOCALS!! 
  INTEGER :: l
  REAL*8 :: wght0
  REAL*8, DIMENSION(k0) :: wght
!Zero locals
  wght0 = 0.0
  wght = 0.0
  thod(i, icmin:k-1) = poid(icmin:k-1)
  tho(i, icmin:k-1) = poi(icmin:k-1)
  qhod(i, icmin:k-1) = qoid(icmin:k-1)
  qho(i, icmin:k-1) = qoi(icmin:k-1)
  uhod(i, icmin:k-1) = uoid(icmin:k-1)
  uho(i, icmin:k-1) = uoi(icmin:k-1)
  vhod(i, icmin:k-1) = void0(icmin:k-1)
  vho(i, icmin:k-1) = voi(icmin:k-1)
  cnv_updfrcd = 0.0_8
  cnv_updfrcd(i, icmin:k-1) = updfrcd(icmin:k-1)
  cnv_updfrc(i, icmin:k-1) = updfrc(icmin:k-1)
  wght = wgt1(i, :)
!! Scale properly by layer masses
  wght0 = 0.
  DO l=k,k0
    wght0 = wght0 + wght(l)*(cple(i, l+1)-cple(i, l))
  END DO
  wght0 = (prs(k+1)-prs(k))/wght0
  wght = wght0*wght
  DO l=k,k0
    thod(i, l) = thod(i, l) + wght(l)*(poid(k)-poi_svd(k))
    tho(i, l) = tho(i, l) + wght(l)*(poi(k)-poi_sv(k))
    qhod(i, l) = qhod(i, l) + wght(l)*(qoid(k)-qoi_svd(k))
    qho(i, l) = qho(i, l) + wght(l)*(qoi(k)-qoi_sv(k))
    uhod(i, l) = uhod(i, l) + wght(l)*(uoid(k)-uoi_svd(k))
    uho(i, l) = uho(i, l) + wght(l)*(uoi(k)-uoi_sv(k))
    vhod(i, l) = vhod(i, l) + wght(l)*(void0(k)-voi_svd(k))
    vho(i, l) = vho(i, l) + wght(l)*(voi(k)-voi_sv(k))
  END DO
  flxdd = 0.0_8
!  (KG/m^2/s @ CLOUD TOP)
  flxdd(i, icmin:k) = ddt*rmfdd(icmin:k)/daylen
  flxd(i, icmin:k) = rmfd(icmin:k)*ddt/daylen
  clwd = 0.0_8
!  (KG/m^2/s )
  clwd(i, icmin:k) = ddt*clld(icmin:k)/daylen
  clw(i, icmin:k) = cll(icmin:k)*ddt/daylen
  flxdd(i, 1:icmin-1) = 0.0_8
  flxd(i, 1:icmin-1) = 0.
  clwd(i, 1:icmin-1) = 0.0_8
  clw(i, 1:icmin-1) = 0.
  IF (k .LT. k0) THEN
    flxdd(i, k:k0) = 0.0_8
    flxd(i, k:k0) = 0.
    clwd(i, k:k0) = 0.0_8
    clw(i, k:k0) = 0.
  END IF
END SUBROUTINE STRAP1_D

!  Differentiation of dqsat_sub in forward (tangent) mode:
!   variations   of useful results: dqsi qssi
!   with respect to varying inputs: temp dqsi qssi
SUBROUTINE DQSAT_SUB_D(dqsi, dqsid, qssi, qssid, temp, tempd, plo, im, &
&  jm, lm, estblx)
  IMPLICIT NONE
!Inputs
  INTEGER :: im, jm, lm
  REAL*8, DIMENSION(im, jm, lm) :: temp, plo
  REAL*8, DIMENSION(im, jm, lm) :: tempd
  REAL*8 :: estblx(:)
!Outputs
  REAL*8, DIMENSION(im, jm, lm) :: dqsi, qssi
  REAL*8, DIMENSION(im, jm, lm) :: dqsid, qssid
!Locals
  REAL*8, PARAMETER :: max_mixing_ratio=1.0
  REAL*8, PARAMETER :: cons_h2omw=18.01, cons_airmw=28.97
  REAL*8, PARAMETER :: esfac=cons_h2omw/cons_airmw
  INTEGER :: i, j, k
  REAL*8 :: tl, tt, ti, dqsat, qsat, dqq, qq, pl, pp, dd
  REAL*8 :: tld, ttd, tid, dqsatd, qsatd, qqd, ddd
  INTEGER :: it
  INTEGER, PARAMETER :: degsubs=100
  REAL*8, PARAMETER :: tmintbl=150.0, tmaxtbl=333.0
  INTEGER, PARAMETER :: tablesize=NINT(tmaxtbl-tmintbl)*degsubs+1
  INTRINSIC NINT
  INTRINSIC INT
  DO k=1,lm
    DO j=1,jm
      DO i=1,im
        tld = tempd(i, j, k)
        tl = temp(i, j, k)
        pl = plo(i, j, k)
        pp = pl*100.0
        IF (tl .LE. tmintbl) THEN
          ti = tmintbl
          tid = 0.0_8
        ELSE IF (tl .GE. tmaxtbl - .001) THEN
          tid = 0.0_8
          ti = tmaxtbl - .001
        ELSE
          tid = tld
          ti = tl
        END IF
        ttd = degsubs*tid
        tt = (ti-tmintbl)*degsubs + 1
        it = INT(tt)
        dqq = estblx(it+1) - estblx(it)
        qqd = dqq*ttd
        qq = (tt-it)*dqq + estblx(it)
        IF (pp .LE. qq) THEN
          qsat = max_mixing_ratio
          dqsat = 0.0
          qsatd = 0.0_8
          dqsatd = 0.0_8
        ELSE
          ddd = -((-((1.0-esfac)*qqd))/(pp-(1.0-esfac)*qq)**2)
          dd = 1.0/(pp-(1.0-esfac)*qq)
          qsatd = esfac*(qqd*dd+qq*ddd)
          qsat = esfac*qq*dd
          dqsatd = esfac*degsubs*dqq*pp*(ddd*dd+dd*ddd)
          dqsat = esfac*degsubs*dqq*pp*(dd*dd)
        END IF
        dqsid(i, j, k) = dqsatd
        dqsi(i, j, k) = dqsat
        qssid(i, j, k) = qsatd
        qssi(i, j, k) = qsat
      END DO
    END DO
  END DO
END SUBROUTINE DQSAT_SUB_D

END MODULE CONVECTION_TL
