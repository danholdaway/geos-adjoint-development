MODULE CONVECTION_AD

USE qsat_util
USE convection

IMPLICIT NONE

PRIVATE
PUBLIC CONVECTION_DRIVER_B

CONTAINS
!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.7 (r4786) - 21 Feb 2013 15:53
!
!  Differentiation of convection_driver in reverse (adjoint) mode:
!   gradient     of useful results: th cnv_prc3 q cnv_dqldt u v
!                cnv_updf cnv_mfd
!   with respect to varying inputs: th cnv_prc3 q cnv_dqldt u v
!                cnv_updf cnv_mfd
!   RW status of diff variables: th:in-out cnv_prc3:in-zero q:in-out
!                cnv_dqldt:in-zero u:in-out v:in-out cnv_updf:in-zero
!                cnv_mfd:in-zero
SUBROUTINE CONVECTION_DRIVER_B(im, jm, lm, pref, dt_moist, frland, kcbl&
&  , ts, rasparams, u, ub, v, vb, th, thb, q, qb, ple, cnv_dqldt, &
&  cnv_dqldtb, cnv_mfd, cnv_mfdb, cnv_prc3, cnv_prc3b, cnv_updf, &
&  cnv_updfb, estblx)
  IMPLICIT NONE
!!INPUTS!!
  INTEGER, INTENT(IN) :: im, jm, lm
  REAL*8, INTENT(IN) :: dt_moist
  REAL*8, DIMENSION(0:lm), INTENT(IN) :: pref
  INTEGER, DIMENSION(im, jm), INTENT(IN) :: kcbl
  REAL*8, DIMENSION(im, jm), INTENT(IN) :: frland
  REAL*8, INTENT(IN) :: rasparams(25)
  REAL*8, DIMENSION(im, jm), INTENT(IN) :: ts
  REAL*8, DIMENSION(im, jm, 0:lm), INTENT(IN) :: ple
!!INOUTS!!
  REAL*8, DIMENSION(im, jm, lm), INTENT(INOUT) :: u, v, th, q
  REAL*8, DIMENSION(im, jm, lm), INTENT(INOUT) :: ub
!!OUTPUTS!!
  REAL*8, DIMENSION(im, jm, lm) :: cnv_dqldt, cnv_mfd, cnv_prc3, &
&  cnv_updf
  REAL*8, DIMENSION(im, jm, lm) :: cnv_dqldtb, cnv_mfdb, cnv_prc3b, &
&  cnv_updfb
!!LOCALS!!
  REAL*8, PARAMETER :: cons_runiv=8314.3, cons_kappa=2.0/7.0, cons_airmw&
&  = 28.97, cons_h2omw=18.01, cons_grav=9.80
  REAL*8, PARAMETER :: cons_rgas=cons_runiv/cons_airmw, cons_cp=&
&    cons_rgas/cons_kappa, cons_vireps=cons_airmw/cons_h2omw-1.0
  INTEGER :: i, j, k, l, ii, jj, idim, k0, icmin
  REAL*8, PARAMETER :: pmin_det=3000.0, cbl_tpert=1.0, cbl_qpert=0.0
  REAL*8, PARAMETER :: autoc_cn_ocn=2.5e-3, autoc_cn_land=2.5e-3
  REAL*8, PARAMETER :: cbl_tpert_mxocn=2.0, cbl_tpert_mxlnd=4.0
  REAL*8, DIMENSION(0:lm) :: sige
  INTEGER, DIMENSION(im, jm) :: seedras
  REAL*8, DIMENSION(im, jm) :: qssfc, tpert, qpert, co_auto
  REAL*8, DIMENSION(im, jm) :: tpertb, qpertb
  REAL*8, DIMENSION(im, jm, 0:lm) :: cnv_ple, pke, zle
  REAL*8, DIMENSION(im, jm, 0:lm) :: zleb
  REAL*8, DIMENSION(im, jm, lm) :: plo, pk, temp, dqs, qss, zlo, wgt0, &
&  wgt1
  REAL*8, DIMENSION(im, jm, lm) :: tempb, dqsb, qssb, zlob
!QSATVP TABLE
  REAL*8 :: estblx(:)
  REAL*8, DIMENSION(im, jm, lm), INTENT(INOUT) :: qb
  REAL*8, DIMENSION(im, jm, lm), INTENT(INOUT) :: vb
  REAL*8, DIMENSION(im, jm, lm), INTENT(INOUT) :: thb
  LOGICAL :: mask3(im, jm)
  LOGICAL :: mask2(im, jm)
  LOGICAL :: mask1(im, jm)
  LOGICAL :: mask0(im, jm)
  INTRINSIC MAX
  INTRINSIC INT
  INTRINSIC MIN
  LOGICAL :: mask(im, jm)
!ZERO OUTPUTS
  zle = 0.0
  dqs = 0.0
  qss = 0.0
  zlo = 0.0
  wgt0 = 0.0
  wgt1 = 0.0
  k0 = lm
  icmin = 0
  DO l=0,lm
    IF (pref(l) .LT. pmin_det) icmin = icmin + 1
  END DO
  cnv_ple = ple*.01
  plo = 0.5*(cnv_ple(:, :, 0:lm-1)+cnv_ple(:, :, 1:lm))
  pke = (cnv_ple/1000.)**(cons_rgas/cons_cp)
  pk = (plo/1000.)**(cons_rgas/cons_cp)
  temp = th*pk
  CALL DQSAT_SUB(dqs, qss, temp, plo, im, jm, lm, estblx)
!GEOS_QSAT( TS , PLE(:,:,LM) ) - Not needed currently as CBL_qpert = 0
  qssfc = 0.0
  zle(:, :, lm) = 0.
  DO l=lm,1,-1
    zle(:, :, l-1) = th(:, :, l)*(1.+cons_vireps*q(:, :, l))
    zlo(:, :, l) = zle(:, :, l) + cons_cp/cons_grav*(pke(:, :, l)-pk(:, &
&      :, l))*zle(:, :, l-1)
    zle(:, :, l-1) = zlo(:, :, l) + cons_cp/cons_grav*(pk(:, :, l)-pke(:&
&      , :, l-1))*zle(:, :, l-1)
  END DO
  tpert = cbl_tpert*(ts-(temp(:, :, lm)+cons_grav*zlo(:, :, lm)/cons_cp)&
&    )
  qpert = cbl_qpert*(qssfc-q(:, :, lm))
  mask = tpert .LT. 0.0
  WHERE (mask) 
    tpert = 0.0
  ELSEWHERE
    tpert = tpert
  END WHERE
  mask1 = tpert .GT. cbl_tpert_mxocn
  WHERE (mask1) 
    tpert = cbl_tpert_mxocn
  ELSEWHERE
    tpert = tpert
  END WHERE
  mask2 = tpert .GT. cbl_tpert_mxlnd
  WHERE (mask2) 
    tpert = cbl_tpert_mxlnd
  ELSEWHERE
    tpert = tpert
  END WHERE
  mask3 = frland .LT. 0.1
! ocean value
  WHERE (mask3) 
    co_auto = autoc_cn_ocn
  ELSEWHERE
    co_auto = autoc_cn_land
  END WHERE
  seedras(:, :) = INT(1000000*(100*temp(:, :, lm)-INT(100*temp(:, :, lm)&
&    )))
  sige = pref/pref(lm)
  DO i=1,im
    DO j=1,jm
      wgt0(i, j, :) = 0.
      wgt0(i, j, kcbl(i, j):k0) = 1.0
      wgt1(i, j, :) = 0.
      wgt1(i, j, kcbl(i, j):k0) = 1.0
    END DO
  END DO
  CALL RASE_B(idim, k0, icmin, dt_moist, seedras, sige, kcbl, wgt0, wgt1&
&        , tpert, tpertb, qpert, qpertb, th, thb, q, qb, u, ub, v, vb, &
&        qss, qssb, dqs, dqsb, co_auto, cnv_ple, pke, cnv_dqldt, &
&        cnv_dqldtb, cnv_mfd, cnv_mfdb, cnv_prc3, cnv_prc3b, cnv_updf, &
&        cnv_updfb, rasparams, estblx)
  WHERE (mask2) tpertb = 0.0_8
  WHERE (mask1) tpertb = 0.0_8
  WHERE (mask) tpertb = 0.0_8
  qb(:, :, lm) = qb(:, :, lm) - cbl_qpert*qpertb
  zlob = 0.0_8
  tempb = 0.0_8
  tempb(:, :, lm) = tempb(:, :, lm) - cbl_tpert*tpertb
  zlob(:, :, lm) = zlob(:, :, lm) - cons_grav*cbl_tpert*tpertb/cons_cp
  zleb = 0.0_8
  DO l=1,lm,1
    zlob(:, :, l) = zlob(:, :, l) + zleb(:, :, l-1)
    zleb(:, :, l-1) = cons_cp*(pk(:, :, l)-pke(:, :, l-1))*zleb(:, :, l-&
&      1)/cons_grav
    zleb(:, :, l) = zleb(:, :, l) + zlob(:, :, l)
    zleb(:, :, l-1) = zleb(:, :, l-1) + cons_cp*(pke(:, :, l)-pk(:, :, l&
&      ))*zlob(:, :, l)/cons_grav
    zlob(:, :, l) = 0.0_8
    thb(:, :, l) = thb(:, :, l) + (cons_vireps*q(:, :, l)+1.)*zleb(:, :&
&      , l-1)
    qb(:, :, l) = qb(:, :, l) + cons_vireps*th(:, :, l)*zleb(:, :, l-1)
    zleb(:, :, l-1) = 0.0_8
  END DO
  CALL DQSAT_SUB_B(dqs, dqsb, qss, qssb, temp, tempb, plo, im, jm, lm, &
&             estblx)
  thb = thb + pk*tempb
  cnv_prc3b = 0.0_8
  cnv_dqldtb = 0.0_8
  cnv_updfb = 0.0_8
  cnv_mfdb = 0.0_8
END SUBROUTINE CONVECTION_DRIVER_B

!  Differentiation of rase in reverse (adjoint) mode:
!   gradient     of useful results: ccnv_prc3 clw tho qho vho cnv_updfrc
!                uho flxd
!   with respect to varying inputs: tho cdqs qho cqpert vho uho
!                cqss ctpert
SUBROUTINE RASE_B(idim, k0, icmin, dt, seedras, sige, kcbl, wgt0, wgt1, &
&  ctpert, ctpertb, cqpert, cqpertb, tho, thob, qho, qhob, uho, uhob, vho&
&  , vhob, cqss, cqssb, cdqs, cdqsb, cco_auto, cple, cpke, clw, clwb, &
&  flxd, flxdb, ccnv_prc3, ccnv_prc3b, cnv_updfrc, cnv_updfrcb, rasparams&
&  , estblx)
  IMPLICIT NONE
!ARGUMENTS
  INTEGER, INTENT(IN) :: idim, k0, icmin
  REAL*8, DIMENSION(idim, k0), INTENT(INOUT) :: tho, qho, uho, vho
  REAL*8, DIMENSION(idim, k0), INTENT(INOUT) :: thob
  REAL*8, DIMENSION(idim, k0 + 1), INTENT(IN) :: cple, cpke
  REAL*8, DIMENSION(idim, k0), INTENT(IN) :: cqss, cdqs
  REAL*8, DIMENSION(idim, k0) :: cqssb, cdqsb
  REAL*8, DIMENSION(k0 + 1), INTENT(IN) :: sige
  REAL*8, DIMENSION(idim, k0) :: clw, flxd
  REAL*8, DIMENSION(idim, k0) :: clwb, flxdb
  REAL*8, DIMENSION(idim, k0) :: ccnv_prc3
  REAL*8, DIMENSION(idim, k0) :: ccnv_prc3b
  REAL*8, DIMENSION(idim, k0) :: cnv_updfrc
  REAL*8, DIMENSION(idim, k0) :: cnv_updfrcb
  REAL*8, INTENT(IN) :: dt
  INTEGER, DIMENSION(idim), INTENT(IN) :: seedras
  INTEGER, DIMENSION(idim), INTENT(IN) :: kcbl
  REAL*8, DIMENSION(idim), INTENT(IN) :: ctpert, cqpert
  REAL*8, DIMENSION(idim) :: ctpertb, cqpertb
  REAL*8, DIMENSION(idim), INTENT(IN) :: cco_auto
  REAL*8, DIMENSION(idim, k0), INTENT(IN) :: wgt0, wgt1
  REAL*8, DIMENSION(:), INTENT(IN) :: rasparams
  REAL*8, DIMENSION(:), INTENT(IN) :: estblx
!RASPARAMS REDEFINED
  REAL*8 :: fricfac, cli_crit, rasal1, rasal2, friclambda, sdqv2, sdqv3&
&  , sdqvt1, mxdiam
  REAL*8 :: acritfac, hmintrigger, pblfrac, autorampb, co_zdep, &
&  maxdallowed, rhmn, rhmx
!GLOBAL CONSTANTS
  REAL*8, PARAMETER :: cons_runiv=8314.3, cons_grav=9.80, cons_kappa=2.0&
&    /7.0, cons_airmw=28.97, cons_alhl=2.4665e6
  REAL*8, PARAMETER :: cons_rgas=cons_runiv/cons_airmw, cons_cp=&
&    cons_rgas/cons_kappa
  REAL*8, PARAMETER :: onepkap=1.+2./7., daylen=86400.0, rhmax=0.9999
  REAL*8 :: grav, cp, alhl, cpbg, alhi, cpi, gravi, ddt, lbcp
!LOCALS
  INTEGER :: i, k, ic, l
  REAL*8, DIMENSION(k0) :: poi_sv, qoi_sv, uoi_sv, voi_sv
  REAL*8, DIMENSION(k0) :: poi_svb, qoi_svb, uoi_svb, voi_svb
  REAL*8, DIMENSION(k0) :: poi, qoi, uoi, voi, dqq, bet, gam, cll
  REAL*8, DIMENSION(k0) :: poib, qoib, uoib, voib, dqqb, betb, gamb, &
&  cllb0
  REAL*8, DIMENSION(k0) :: poi_c, qoi_c
  REAL*8, DIMENSION(k0) :: poi_cb, qoi_cb
  REAL*8, DIMENSION(k0) :: prh, pri, ght, dpt, dpb, pki
  REAL*8, DIMENSION(k0) :: ghtb
  REAL*8, DIMENSION(k0) :: tcu, qcu, rns, pol
  REAL*8, DIMENSION(k0) :: rnsb
  REAL*8, DIMENSION(k0) :: qst, ssl, rmf, rmfc, rmfp
  REAL*8, DIMENSION(k0) :: qstb, sslb, rmfpb
  REAL*8, DIMENSION(k0) :: gm1, rmfd
  REAL*8, DIMENSION(k0) :: gm1b, rmfdb
  REAL*8, DIMENSION(k0) :: hol, hst, qol, zol, cll0, clli, cllb
  REAL*8, DIMENSION(k0) :: holb, hstb, qolb, zolb, cll0b
  REAL*8, DIMENSION(k0) :: cvw, updfrc
  REAL*8, DIMENSION(k0) :: cvwb, updfrcb
  REAL*8, DIMENSION(k0) :: updfrp, dll0, dllx
  REAL*8, DIMENSION(k0) :: updfrpb
  REAL*8, DIMENSION(k0 + 1) :: prj, prs, sht, zet
  REAL*8, DIMENSION(k0+1) :: shtb, zetb
  REAL*8 :: tema, temb, temc
  REAL*8 :: temab
!QSATVP LOOKUP TABLE
  INTEGER, PARAMETER :: degsubs=100
  REAL*8, PARAMETER :: tmintbl=150.0, tmaxtbl=333.0
  INTEGER, PARAMETER :: tablesize=NINT(tmaxtbl-tmintbl)*degsubs+1
  INTEGER :: branch
  REAL*8, DIMENSION(idim, k0), INTENT(INOUT) :: vhob
  REAL*8, DIMENSION(idim, k0), INTENT(INOUT) :: uhob
  REAL*8, DIMENSION(idim, k0), INTENT(INOUT) :: qhob
  INTRINSIC MAX
  INTRINSIC SUM
  INTRINSIC NINT
  INTRINSIC MIN
!ZERO OUTPUTS
!Zero locals, taf linearisation safety measure
  dqq = 0.0
  bet = 0.0
  gam = 0.0
  prh = 0.0
  pri = 0.0
  ght = 0.0
  dpt = 0.0
  dpb = 0.0
  pki = 0.0
  pol = 0.0
  qst = 0.0
  ssl = 0.0
  gm1 = 0.0
  hst = 0.0
  qol = 0.0
  zol = 0.0
  prj = 0.0
  prs = 0.0
  sht = 0.0
  zet = 0.0
!ASSIGN RASPARAMS NEEDED
!  ---  1
  fricfac = rasparams(1)
!  ---  4
  cli_crit = rasparams(4)
!  ---  5
  rasal1 = rasparams(5)
!  ---  6
  rasal2 = rasparams(6)
!  --- 11
  friclambda = rasparams(11)
!  --- 14
  sdqv2 = rasparams(14)
!  --- 15
  sdqv3 = rasparams(15)
!  --- 16
  sdqvt1 = rasparams(16)
!  --- 17
  acritfac = rasparams(17)
!  --- 18
!  --- 20
  pblfrac = rasparams(20)
!  --- 21
  autorampb = rasparams(21)
!  --- 22
!  --- 23
  maxdallowed = rasparams(23)
!  --- 24
  rhmn = rasparams(24)
!  --- 25
  rhmx = rasparams(25)
!ASIGN RASE CONSTANTS
  grav = cons_grav
  alhl = cons_alhl
  cp = cons_cp
  cpi = 1.0/cp
  alhi = 1.0/alhl
  gravi = 1.0/grav
  cpbg = cp*gravi
  ddt = daylen/dt
  lbcp = alhl*cpi
  i = 1
!!CALL FINDBASE
  k = kcbl(i)
  IF (k .GT. 0) THEN
    CALL PUSHREAL8ARRAY(dpb, k0)
    CALL PUSHREAL8ARRAY(dpt, k0)
    CALL PUSHREAL8ARRAY(pki, k0)
    CALL PUSHREAL8ARRAY(prh, k0)
    CALL PUSHREAL8ARRAY(pol, k0)
    CALL PUSHREAL8ARRAY(dqq, k0)
    CALL PUSHREAL8ARRAY(prs, k0 + 1)
    CALL PUSHREAL8ARRAY(prj, k0 + 1)
    CALL STRAP0(i, k, k0, idim, icmin, cpke, cple, uho, vho, tho, qho, &
&          cdqs, cqss, estblx, seedras, wgt0, mxdiam, poi, qoi, uoi, voi&
&          , prj, prs, qst, dqq, cons_rgas, cons_cp, onepkap, pol, prh, &
&          pki, dpt, dpb, pri, maxdallowed, bet, gam, lbcp, ght, gm1, &
&          alhl, tcu, qcu, rns, cll, rmf, rmfd, rmfc, rmfp, cll0, dll0, &
&          dllx, clli, cllb, cvw, updfrc, updfrp, poi_sv, qoi_sv, uoi_sv&
&          , voi_sv)
!HTEST ROUTINE
    hol = 0.0
    zet(k+1) = 0
    sht(k+1) = cp*poi(k)*prj(k+1)
    DO l=k,icmin,-1
      IF (qst(l)*rhmax .GT. qoi(l)) THEN
        qol(l) = qoi(l)
        CALL PUSHCONTROL1B(0)
      ELSE
        qol(l) = qst(l)*rhmax
        CALL PUSHCONTROL1B(1)
      END IF
      IF (0.000 .LT. qol(l)) THEN
        CALL PUSHCONTROL1B(0)
        qol(l) = qol(l)
      ELSE
        qol(l) = 0.000
        CALL PUSHCONTROL1B(1)
      END IF
      ssl(l) = cp*prj(l+1)*poi(l) + grav*zet(l+1)
      hol(l) = ssl(l) + qol(l)*alhl
      hst(l) = ssl(l) + qst(l)*alhl
      tema = poi(l)*(prj(l+1)-prj(l))*cpbg
      zet(l) = zet(l+1) + tema
      zol(l) = zet(l+1) + (prj(l+1)-prh(l))*poi(l)*cpbg
    END DO
    CALL PUSHREAL8ARRAY(cvw, k0)
    CALL PUSHREAL8ARRAY(zol, k0)
    CALL PUSHREAL8ARRAY(hst, k0)
    CALL PUSHREAL8ARRAY(hol, k0)
    CALL PUSHREAL8ARRAY(ssl, k0)
    CALL PUSHREAL8ARRAY(qol, k0)
    CALL PUSHREAL8ARRAY(sht, k0 + 1)
    CALL PUSHREAL8ARRAY(zet, k0 + 1)
    CALL PUSHREAL8ARRAY(voi, k0)
    CALL PUSHREAL8ARRAY(uoi, k0)
    CALL PUSHREAL8ARRAY(poi, k0)
    CALL PUSHREAL8ARRAY(qst, k0)
    CALL PUSHREAL8ARRAY(qoi, k0)
!END HTEST ROUTINE
!MAIN CLOUD LOOP
    CALL CLOUDE(i, k, k0, idim, icmin, dt, ddt, daylen, rhmn, rhmx, &
&          autorampb, co_zdep, cp, cpi, rhmax, grav, gravi, alhi, alhl, &
&          cpbg, lbcp, rasal1, rasal2, acritfac, sdqv2, sdqv3, sdqvt1, &
&          cli_crit, pblfrac, fricfac, friclambda, qoi, qst, poi, uoi, &
&          voi, sige, poi_c, qoi_c, ctpert, cqpert, mxdiam, cco_auto, zet&
&          , sht, qol, ssl, hol, hst, zol, prj, prh, dpb, dpt, bet, gam, &
&          cvw, dqq, pol, prs, cll0, dll0, gm1, pri, ght, pki, cll, rmf, &
&          rmfd, rmfp, rmfc, dllx, updfrp, updfrc, clli, cllb, rns)
    IF (SUM(rmf(icmin:k)) .GT. 0.0) THEN
      CALL STRAP1_B(i, k, k0, idim, icmin, tho, thob, qho, qhob, uho, &
&              uhob, vho, vhob, cnv_updfrc, cnv_updfrcb, cple, flxd, &
&              flxdb, clw, clwb, wgt1, poi, poib, qoi, qoib, uoi, uoib, &
&              voi, voib, updfrc, updfrcb, cvw, cllb, prs, poi_sv, &
&              poi_svb, qoi_sv, qoi_svb, uoi_sv, uoi_svb, voi_sv, voi_svb&
&              , rmf, rmfd, rmfdb, rmfc, cll, cllb0, ddt, daylen)
      rnsb = 0.0_8
      DO l=k,icmin,-1
        temc = pri(l)*grav
        rnsb(l) = rnsb(l) + temc*ccnv_prc3b(i, l)
        ccnv_prc3b(i, l) = 0.0_8
      END DO
    ELSE
      qoi_svb = 0.0_8
      uoi_svb = 0.0_8
      qoib = 0.0_8
      voib = 0.0_8
      updfrcb = 0.0_8
      poib = 0.0_8
      rnsb = 0.0_8
      poi_svb = 0.0_8
      uoib = 0.0_8
      rmfdb = 0.0_8
      voi_svb = 0.0_8
      cllb0 = 0.0_8
    END IF
    CALL POPREAL8ARRAY(qoi, k0)
    CALL POPREAL8ARRAY(qst, k0)
    CALL POPREAL8ARRAY(poi, k0)
    CALL POPREAL8ARRAY(uoi, k0)
    CALL POPREAL8ARRAY(voi, k0)
    CALL POPREAL8ARRAY(zet, k0 + 1)
    CALL POPREAL8ARRAY(sht, k0 + 1)
    CALL POPREAL8ARRAY(qol, k0)
    CALL POPREAL8ARRAY(ssl, k0)
    CALL POPREAL8ARRAY(hol, k0)
    CALL POPREAL8ARRAY(hst, k0)
    CALL POPREAL8ARRAY(zol, k0)
    CALL POPREAL8ARRAY(cvw, k0)
    CALL CLOUDE_B(i, k, k0, idim, icmin, dt, ddt, daylen, rhmn, rhmx, &
&            autorampb, co_zdep, cp, cpi, rhmax, grav, gravi, alhi, alhl&
&            , cpbg, lbcp, rasal1, rasal2, acritfac, sdqv2, sdqv3, sdqvt1&
&            , cli_crit, pblfrac, fricfac, friclambda, qoi, qoib, qst, &
&            qstb, poi, poib, uoi, uoib, voi, voib, sige, poi_c, poi_cb, &
&            qoi_c, qoi_cb, ctpert, ctpertb, cqpert, cqpertb, mxdiam, &
&            cco_auto, zet, zetb, sht, shtb, qol, qolb, ssl, sslb, hol, &
&            holb, hst, hstb, zol, zolb, prj, prh, dpb, dpt, bet, betb, &
&            gam, gamb, cvw, cvwb, dqq, dqqb, pol, prs, cll0, cll0b, dll0&
&            , gm1, gm1b, pri, ght, ghtb, pki, cll, cllb0, rmf, rmfd, &
&            rmfdb, rmfp, rmfpb, rmfc, dllx, updfrp, updfrpb, updfrc, &
&            updfrcb, clli, cllb, rns, rnsb)
    DO l=icmin,k,1
      sslb(l) = sslb(l) + holb(l) + hstb(l)
      zetb(l+1) = zetb(l+1) + zetb(l) + zolb(l)
      temab = zetb(l)
      poib(l) = poib(l) + (prj(l+1)-prj(l))*cpbg*temab + prj(l+1)*cp*&
&        sslb(l) + (prj(l+1)-prh(l))*cpbg*zolb(l)
      zolb(l) = 0.0_8
      zetb(l) = 0.0_8
      qstb(l) = qstb(l) + alhl*hstb(l)
      hstb(l) = 0.0_8
      qolb(l) = qolb(l) + alhl*holb(l)
      holb(l) = 0.0_8
      zetb(l+1) = zetb(l+1) + grav*sslb(l)
      sslb(l) = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) qolb(l) = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        qoib(l) = qoib(l) + qolb(l)
        qolb(l) = 0.0_8
      ELSE
        qstb(l) = qstb(l) + rhmax*qolb(l)
        qolb(l) = 0.0_8
      END IF
    END DO
    poib(k) = poib(k) + prj(k+1)*cp*shtb(k+1)
    CALL POPREAL8ARRAY(prj, k0 + 1)
    CALL POPREAL8ARRAY(prs, k0 + 1)
    CALL POPREAL8ARRAY(dqq, k0)
    CALL POPREAL8ARRAY(pol, k0)
    CALL POPREAL8ARRAY(prh, k0)
    CALL POPREAL8ARRAY(pki, k0)
    CALL POPREAL8ARRAY(dpt, k0)
    CALL POPREAL8ARRAY(dpb, k0)
    CALL STRAP0_B(i, k, k0, idim, icmin, cpke, cple, uho, uhob, vho, &
&            vhob, tho, thob, qho, qhob, cdqs, cdqsb, cqss, cqssb, estblx&
&            , seedras, wgt0, mxdiam, poi, poib, qoi, qoib, uoi, uoib, &
&            voi, voib, prj, prs, qst, qstb, dqq, dqqb, cons_rgas, &
&            cons_cp, onepkap, pol, prh, pki, dpt, dpb, pri, maxdallowed&
&            , bet, betb, gam, gamb, lbcp, ght, ghtb, gm1, gm1b, alhl, &
&            tcu, qcu, rns, cll, rmf, rmfd, rmfc, rmfp, cll0, dll0, dllx&
&            , clli, cllb, cvw, updfrc, updfrp, poi_sv, poi_svb, qoi_sv, &
&            qoi_svb, uoi_sv, uoi_svb, voi_sv, voi_svb)
  ELSE
    cdqsb = 0.0_8
    cqpertb = 0.0_8
    cqssb = 0.0_8
    ctpertb = 0.0_8
  END IF
END SUBROUTINE RASE_B

!  Differentiation of cloude in reverse (adjoint) mode:
!   gradient     of useful results: qoi voi updfrc poi rns uoi
!                rmfd cll
!   with respect to varying inputs: gm1 dqq ght bet hst cqpert
!                qoi qol voi sht qst poi uoi ssl zet zol ctpert
!                hol gam
SUBROUTINE CLOUDE_B(i, k, k0, idim, icmin, dt, ddt, daylen, rhmn, rhmx, &
&  autorampb, co_zdep, cp, cpi, rhmax, grav, gravi, alhi, alhl, cpbg, &
&  lbcp, rasal1, rasal2, acritfac, sdqv2, sdqv3, sdqvt1, cli_crit, &
&  pblfrac, fricfac, friclambda, qoi, qoib, qst, qstb, poi, poib, uoi, &
&  uoib, voi, voib, sige, poi_c, poi_cb, qoi_c, qoi_cb, ctpert, ctpertb, &
&  cqpert, cqpertb, mxdiam, cco_auto, zet, zetb, sht, shtb, qol, qolb, &
&  ssl, sslb, hol, holb, hst, hstb, zol, zolb, prj, prh, dpb, dpt, bet, &
&  betb, gam, gamb, cvw, cvwb, dqq, dqqb, pol, prs, cll0, cll0b, dll0, &
&  gm1, gm1b, pri, ght, ghtb, pki, cll, cllb0, rmf, rmfd, rmfdb, rmfp, &
&  rmfpb, rmfc, dllx, updfrp, updfrpb, updfrc, updfrcb, clli, cllb, rns, &
&  rnsb)
  IMPLICIT NONE
!!GLOBALS!!
  INTEGER :: i, k, k0, idim, icmin
  REAL*8 :: dt, ddt, daylen, rhmn, rhmx, autorampb, co_zdep, cp, cpi, &
&  rhmax, grav, gravi, alhi, alhl, cpbg, lbcp
  REAL*8 :: rasal1, rasal2, acritfac, sdqv2, sdqv3, sdqvt1, cli_crit, &
&  pblfrac, fricfac, friclambda, mxdiam
  REAL*8, DIMENSION(idim) :: ctpert, cqpert, cco_auto
  REAL*8, DIMENSION(idim) :: ctpertb, cqpertb
  REAL*8, DIMENSION(k0) :: qoi, qst, poi, uoi, voi, poi_c, qoi_c
  REAL*8, DIMENSION(k0) :: qoib, qstb, poib, uoib, voib, poi_cb, qoi_cb
  REAL*8, DIMENSION(k0) :: qol, ssl, hol, hst, zol, prh, dpb, dpt, bet, &
&  gam, cvw
  REAL*8, DIMENSION(k0) :: qolb, sslb, holb, hstb, zolb, betb, gamb, &
&  cvwb
  REAL*8, DIMENSION(k0) :: dqq, pol, cll0, dll0, gm1, pri, ght, pki
  REAL*8, DIMENSION(k0) :: dqqb, cll0b, gm1b, ghtb
  REAL*8, DIMENSION(k0) :: cll, rmf, rmfd, rmfp, rmfc, dllx, updfrp, &
&  updfrc, clli, cllb, rns
  REAL*8, DIMENSION(k0) :: cllb0, rmfdb, rmfpb, updfrpb, updfrcb, rnsb
  REAL*8, DIMENSION(k0 + 1) :: sige, zet, sht, prj, prs
  REAL*8, DIMENSION(k0+1) :: zetb, shtb
!!LOCALS!!
  INTEGER :: ic, l, rc, icl, icl_c, n_dtl
  REAL*8 :: te0, te1, te2, jump1
  REAL*8 :: tem1, tem2, tem3, tem4, tem5, tem6, tem7, tem8, tem9, tem10
  REAL*8 :: tem1b, tem3b, tem4b, tem5b, tem6b, tem7b, tem8b, tem9b, &
&  tem10b
  REAL*8 :: alm, trg, lambda_min, lambda_max
  REAL*8 :: almb, trgb
  REAL*8 :: wfn, wfn1, wfn2, acr, akm, wlq, uht, vht, tx2, tx3, qcc
  REAL*8 :: wfnb, wfn1b, wfn2b, akmb, wlqb, uhtb, vhtb, tx2b, tx3b, qccb
  REAL*8 :: cli, te_a, c00_x, cli_crit_x, toki
  REAL*8 :: clib, te_ab, c00_xb, cli_crit_xb, tokib
  REAL*8 :: dt_lyr, rate, cvw_x, closs, f2, f4, f5
  REAL*8 :: dt_lyrb, rateb, cvw_xb, clossb, f2b
  REAL*8, DIMENSION(k0) :: eta, hcc, eht, bk2, hcld, rasal, rnn, ucu, &
&  vcu
  REAL*8, DIMENSION(k0) :: etab, hccb, ehtb, bk2b, hcldb, rasalb, rnnb, &
&  ucub, vcub
  REAL*8, DIMENSION(k0) :: gms, gms1, gmh
  REAL*8, DIMENSION(k0) :: gmsb, gms1b, gmhb
  REAL*8, DIMENSION(k0 + 1) :: qht
  REAL*8, DIMENSION(k0+1) :: qhtb
  INTEGER :: branch
  INTEGER :: ad_to
  INTEGER :: ad_from
  INTEGER :: ad_from0
  INTEGER :: ad_from1
  INTEGER :: ad_to0
  INTEGER :: ad_to1
  INTEGER :: ad_to2
  INTEGER :: ad_to3
  INTEGER :: ad_to4
  INTEGER :: ad_from2
  INTEGER :: ad_from3
  INTEGER :: ad_to5
  INTEGER :: ad_from4
  REAL*8 :: temp3
  REAL*8 :: temp2
  REAL*8 :: temp1
  REAL*8 :: temp0
  REAL*8 :: temp7b
  INTRINSIC EXP
  REAL*8 :: tempb8
  REAL*8 :: tempb7
  REAL*8 :: tempb6
  REAL*8 :: max2b
  REAL*8 :: tempb5
  REAL*8 :: tempb4
  REAL*8 :: tempb3
  REAL*8 :: tempb2
  REAL*8 :: temp7b12
  REAL*8 :: tempb1
  REAL*8 :: temp7b11
  REAL*8 :: tempb0
  REAL*8 :: temp7b9
  REAL*8 :: temp7b10
  REAL*8 :: temp7b8
  INTRINSIC MAX
  REAL*8 :: temp7b7
  REAL*8 :: temp7b6
  REAL*8 :: temp7b5
  REAL*8 :: temp7b4
  REAL*8 :: temp7b3
  REAL*8 :: temp7b2
  INTRINSIC ABS
  REAL*8 :: temp7b1
  REAL*8 :: x1
  REAL*8 :: temp7b0
  REAL*8 :: max1b
  REAL*8 :: temp5b2
  REAL*8 :: temp5b1
  REAL*8 :: temp5b0
  REAL*8 :: tempb
  REAL*8 :: temp2b
  REAL*8 :: temp8b8
  REAL*8 :: x1b
  REAL*8 :: temp8b7
  REAL*8 :: temp8b6
  REAL*8 :: temp8b5
  REAL*8 :: temp8b4
  REAL*8 :: temp5b
  REAL*8 :: temp8b3
  REAL*8 :: temp8b2
  REAL*8 :: temp8b1
  REAL*8 :: temp8b0
  REAL*8 :: abs8
  REAL*8 :: temp8b
  REAL*8 :: abs7
  REAL*8 :: abs6
  REAL*8 :: abs5
  REAL*8 :: abs4
  REAL*8 :: abs3
  REAL*8 :: abs2
  REAL*8 :: abs1
  REAL*8 :: abs0
  INTRINSIC MIN
  INTRINSIC SQRT
  LOGICAL :: mask(k-ic+1)
  REAL*8 :: temp
  REAL*8 :: max2
  REAL*8 :: max1
  REAL*8 :: temp7
  REAL*8 :: temp6
  REAL*8 :: temp5
  REAL*8 :: y1
  REAL*8 :: temp4
!LOCALS TO ZERO
  trg = 0.0
  wfn1 = 0.0
  eta = 0.0
  hcc = 0.0
  eht = 0.0
  bk2 = 0.0
  hcld = 0.0
  rasal = 0.0
  rnn = 0.0
  ucu = 0.0
  vcu = 0.0
  qht = 0.0
  gms = 0.0
  gmh = 0.0
  te0 = 273.0
  te1 = sdqvt1
  te2 = 200.
  jump1 = (sdqv2-1.0)/(te0-te1)**0.333
  n_dtl = k - icmin
!CLOUD LOOP
  DO icl_c=1,n_dtl
!ICL_V( ICL_C )
    icl = k - icl_c
! This change makes cumulus friction
    ucu(icmin:) = 0.
! correct.
    vcu(icmin:) = 0.
    IF (icl .GT. icmin) THEN
      CALL PUSHINTEGER4(ic)
      ic = icl
      rc = 10
      CALL PUSHREAL8(alm)
      alm = 0.
      IF (qst(k) .GE. 0.) THEN
        abs0 = qst(k)
      ELSE
        abs0 = -qst(k)
      END IF
      IF (abs0 .GT. 0.0) THEN
        IF (1. .GT. (qoi(k)/qst(k)-rhmn)/(rhmx-rhmn)) THEN
          CALL PUSHREAL8(trg)
          trg = (qoi(k)/qst(k)-rhmn)/(rhmx-rhmn)
          CALL PUSHCONTROL2B(2)
        ELSE
          CALL PUSHREAL8(trg)
          trg = 1.
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
      IF (0.0 .LT. (autorampb-sige(ic))/0.2) THEN
        y1 = (autorampb-sige(ic))/0.2
      ELSE
        y1 = 0.0
      END IF
      IF (1.0 .GT. y1) THEN
        CALL PUSHREAL8(f4)
        f4 = y1
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHREAL8(f4)
        f4 = 1.0
        CALL PUSHCONTROL1B(1)
      END IF
! to 1 at SIG=AUTORAMPB-0.2
!if ( SIGE(IC) >= 0.5 ) then
!   F5 = 1.0
!else
!   F5 = 1.0 - 2.*CO_ZDEP *( 0.5 - SIGE(IC) )
!   F5 = MAX( F5 , 0.0 )
!endif
      IF (trg .LE. 1.0e-5) rc = 1
! TRIGGER  =========>>      
!RETURN
!RC = 1
      IF (rc .EQ. 10) THEN
!RECOMPUTE SOUNDING UP TO DETRAINMENT LEVEL
        poi_c = poi
        qoi_c = qoi
        poi_c(k) = poi_c(k) + ctpert(i)
        qoi_c(k) = qoi_c(k) + cqpert(i)
        CALL PUSHREAL8(zet(k+1))
        zet(k+1) = 0.
        CALL PUSHREAL8(sht(k+1))
        sht(k+1) = cp*poi_c(k)*prj(k+1)
        DO l=k,ic,-1
          IF (qst(l)*rhmax .GT. qoi_c(l)) THEN
            CALL PUSHREAL8(qol(l))
            qol(l) = qoi_c(l)
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHREAL8(qol(l))
            qol(l) = qst(l)*rhmax
            CALL PUSHCONTROL1B(1)
          END IF
          IF (0.000 .LT. qol(l)) THEN
            CALL PUSHCONTROL1B(0)
            qol(l) = qol(l)
          ELSE
            qol(l) = 0.000
            CALL PUSHCONTROL1B(1)
          END IF
          CALL PUSHREAL8(ssl(l))
          ssl(l) = cp*prj(l+1)*poi_c(l) + grav*zet(l+1)
          CALL PUSHREAL8(hol(l))
          hol(l) = ssl(l) + qol(l)*alhl
          CALL PUSHREAL8(hst(l))
          hst(l) = ssl(l) + qst(l)*alhl
          tem1 = poi_c(l)*(prj(l+1)-prj(l))*cpbg
          CALL PUSHREAL8(zet(l))
          zet(l) = zet(l+1) + tem1
          CALL PUSHREAL8(zol(l))
          zol(l) = zet(l+1) + (prj(l+1)-prh(l))*poi_c(l)*cpbg
        END DO
        CALL PUSHINTEGER4(l + 1)
        ad_from = ic + 1
        DO l=ad_from,k
          tem2 = (prj(l)-prh(l-1))/(prh(l)-prh(l-1))
          CALL PUSHREAL8(sht(l))
          sht(l) = ssl(l-1) + tem2*(ssl(l)-ssl(l-1))
          CALL PUSHREAL8(qht(l))
          qht(l) = .5*(qol(l)+qol(l-1))
        END DO
        CALL PUSHINTEGER4(ad_from)
        CALL PUSHREAL8(lambda_min)
!CALCULATE LAMBDA, ETA, AND WORKFUNCTION
        lambda_min = .2/mxdiam
        lambda_max = .2/200.
        IF (hol(k) .LE. hst(ic)) rc = 2
! CANNOT REACH IC LEVEL  ======>>
!RETURN
!====EXIT====>
!RC = 2
        IF (rc .EQ. 10) THEN
          CALL PUSHREAL8(tem3)
!LAMBDA CALCULATION: MS-A18
          tem3 = (hst(ic)-hol(ic))*(zol(ic)-zet(ic+1))
          ad_from0 = ic + 1
          DO l=ad_from0,k-1
            tem3 = tem3 + (hst(ic)-hol(l))*(zet(l)-zet(l+1))
          END DO
          CALL PUSHINTEGER4(ad_from0)
          IF (tem3 .LE. 0.0) rc = 3
! NO VALID LAMBDA  ============>>
!RETURN
!====EXIT====>
!RC = 3
          IF (rc .EQ. 10) THEN
            IF (tem3 .GE. 0.) THEN
              abs1 = tem3
            ELSE
              abs1 = -tem3
            END IF
            IF (abs1 .GT. 0.0) THEN
!Linearisation security
              alm = (hol(k)-hst(ic))/tem3
              CALL PUSHCONTROL1B(0)
            ELSE
              CALL PUSHCONTROL1B(1)
            END IF
            IF (alm .GT. lambda_max) rc = 4
!RETURN
!====EXIT====>
!RC = 4
            IF (rc .EQ. 10) THEN
              CALL PUSHREAL8(toki)
              toki = 1.0
              IF (alm .LT. lambda_min) THEN
                toki = (alm/lambda_min)**2
                CALL PUSHCONTROL1B(1)
              ELSE
                CALL PUSHCONTROL1B(0)
              END IF
              ad_from1 = ic + 1
!ETA CALCULATION: MS-A2
              DO l=ad_from1,k
                CALL PUSHREAL8(eta(l))
                eta(l) = 1.0 + alm*(zet(l)-zet(k))
              END DO
              CALL PUSHINTEGER4(ad_from1)
              CALL PUSHREAL8(eta(ic))
              eta(ic) = 1.0 + alm*(zol(ic)-zet(k))
              CALL PUSHREAL8(wfn)
!WORKFUNCTION CALCULATION:  MS-A22
              wfn = 0.0
              CALL PUSHREAL8(hcc(k))
              hcc(k) = hol(k)
              DO l=k-1,ic+1,-1
                CALL PUSHREAL8(hcc(l))
                hcc(l) = hcc(l+1) + (eta(l)-eta(l+1))*hol(l)
                CALL PUSHREAL8(tem4)
                tem4 = hcc(l+1)*dpb(l) + hcc(l)*dpt(l)
                CALL PUSHREAL8(eht(l))
                eht(l) = eta(l+1)*dpb(l) + eta(l)*dpt(l)
                wfn = wfn + (tem4-eht(l)*hst(l))*gam(l)
              END DO
              CALL PUSHINTEGER4(l + 1)
              CALL PUSHREAL8(hcc(ic))
              hcc(ic) = hst(ic)*eta(ic)
              wfn = wfn + (hcc(ic+1)-hst(ic)*eta(ic+1))*gam(ic)*dpb(ic)
              CALL PUSHREAL8(hcld(k))
!VERTICAL VELOCITY/KE CALCULATION (ADDED 12/2001 JTB)
              hcld(k) = hol(k)
              DO l=k-1,ic,-1
                IF (eta(l) .GE. 0.) THEN
                  abs2 = eta(l)
                ELSE
                  abs2 = -eta(l)
                END IF
                IF (abs2 .GT. 0.0) THEN
                  CALL PUSHREAL8(hcld(l))
!Linearisation security
                  hcld(l) = (eta(l+1)*hcld(l+1)+(eta(l)-eta(l+1))*hol(l)&
&                    )/(eta(l)+1e-15)
                  CALL PUSHCONTROL1B(1)
                ELSE
                  CALL PUSHCONTROL1B(0)
                END IF
              END DO
              CALL PUSHINTEGER4(l + 1)
              bk2(k) = 0.0
              DO l=k-1,ic,-1
                IF (1.0 + lbcp*dqq(l) .GE. 0.) THEN
                  abs3 = 1.0 + lbcp*dqq(l)
                ELSE
                  abs3 = -(1.0+lbcp*dqq(l))
                END IF
                IF (abs3 .GT. 0.0) THEN
!Linearisation security
                  tem5 = (hcld(l)-hst(l))*(zet(l)-zet(l+1))/(1.0+lbcp*&
&                    dqq(l)+1e-15)
                  IF (cp*prj(l+1)*poi(l) .GE. 0.) THEN
                    abs4 = cp*prj(l+1)*poi(l)
                  ELSE
                    abs4 = -(cp*prj(l+1)*poi(l))
                  END IF
                  IF (abs4 .GT. 0.0) THEN
                    IF (tem5 .LT. 0.0) THEN
                      CALL PUSHREAL8(max1)
                      max1 = 0.0
                      CALL PUSHCONTROL1B(0)
                    ELSE
                      CALL PUSHREAL8(max1)
                      max1 = tem5
                      CALL PUSHCONTROL1B(1)
                    END IF
!Linearisation security
                    bk2(l) = bk2(l+1) + grav*max1/(cp*prj(l+1)*poi(l))
                    CALL PUSHCONTROL2B(2)
                  ELSE
                    CALL PUSHCONTROL2B(1)
                  END IF
                ELSE
                  CALL PUSHCONTROL2B(0)
                END IF
                IF (bk2(l) .LT. 0.0) THEN
                  CALL PUSHREAL8(max2)
                  max2 = 0.0
                  CALL PUSHCONTROL1B(0)
                ELSE
                  CALL PUSHREAL8(max2)
                  max2 = bk2(l)
                  CALL PUSHCONTROL1B(1)
                END IF
                CALL PUSHREAL8(cvw(l))
                cvw(l) = SQRT(2.0*max2)
              END DO
              CALL PUSHINTEGER4(l + 1)
              CALL PUSHREAL8(rasal(ic))
!ALPHA CALCULATION 
              rasal(ic) = dt/rasal1
              IF (zet(ic) .GE. 2000.) THEN
                CALL PUSHREAL8(rasal(ic))
                rasal(ic) = dt/(rasal1+(rasal2-rasal1)*(zet(ic)-2000.)/&
&                  8000.)
!RASAL(IC) = MIN( RASAL(IC) , 1.0e5 )
!RASAL(IC) = DT / RASAL(IC)
                CALL PUSHCONTROL1B(1)
              ELSE
                CALL PUSHCONTROL1B(0)
              END IF
              CALL PUSHBOOLEANARRAY(mask, k - ic + 1)
              mask(1:k-ic+1) = cvw(ic:k) .LT. 1.00
              CALL PUSHREAL8ARRAY(cvw(ic:k), k - ic + 1)
              WHERE (mask(1:k-ic+1)) cvw(ic:k) = 1.00
              CALL PUSHREAL8ARRAY(cvw(ic:k), k - ic + 1)
              WHERE (.NOT.mask(1:k-ic+1)) cvw(ic:k) = cvw(ic:k)
              CALL PUSHREAL8(acr)
!TEST FOR CRITICAL WORK FUNCTION
              CALL ACRITN(pol(ic), prs(k), acritfac, acr)
              IF (wfn .LE. acr) rc = 5
! SUB-CRITICAL WORK FUNCTION ======>>
!RETURN
!====EXIT====>
!RC = 5
!CLOUD TOP WATER AND MOMENTUM (TIMES ETA(IC)) MS-A16
              IF (rc .EQ. 10) THEN
                CALL PUSHREAL8(wlq)
                wlq = qol(k)
                CALL PUSHREAL8(uht)
                uht = uoi(k)
                CALL PUSHREAL8(vht)
                vht = voi(k)
                CALL PUSHREAL8(rnn(k))
                rnn(k) = 0.
                DO l=k-1,ic,-1
                  tem6 = eta(l) - eta(l+1)
                  wlq = wlq + tem6*qol(l)
                  uht = uht + tem6*uoi(l)
                  vht = vht + tem6*voi(l)
!!!! How much condensate (CLI) is present here? 
                  IF (l .GT. ic) THEN
                    CALL PUSHREAL8(tx2)
                    tx2 = 0.5*(qst(l)+qst(l-1))*eta(l)
                    CALL PUSHREAL8(tx3)
                    tx3 = 0.5*(hst(l)+hst(l-1))*eta(l)
                    qcc = tx2 + gm1(l)*(hcc(l)-tx3)
                    CALL PUSHREAL8(cll0(l))
                    cll0(l) = wlq - qcc
                    CALL PUSHCONTROL1B(1)
                  ELSE
                    CALL PUSHREAL8(cll0(l))
                    cll0(l) = wlq - qst(ic)*eta(ic)
                    CALL PUSHCONTROL1B(0)
                  END IF
                  IF (cll0(l) .LT. 0.00) THEN
                    cll0(l) = 0.00
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    CALL PUSHCONTROL1B(1)
                    cll0(l) = cll0(l)
                  END IF
! Temperature (K)
                  te_a = poi(l)*prh(l)
                  IF (eta(l) .GE. 0.) THEN
                    abs5 = eta(l)
                  ELSE
                    abs5 = -eta(l)
                  END IF
                  IF (abs5 .GT. 0.0) THEN
                    CALL PUSHREAL8(f2)
!Linearisation security
!SUNDQ3_ICE
                    f2 = 1.0
                    IF (te_a .GE. te1 .AND. te_a .LT. te0) THEN
                      f2 = 1.0 + jump1*(te0-te_a)**0.3333
                      CALL PUSHCONTROL2B(2)
                    ELSE IF (te_a .LT. te1) THEN
                      f2 = sdqv2 + (sdqv3-sdqv2)*(te1-te_a)/(te1-te2)
                      CALL PUSHCONTROL2B(1)
                    ELSE
                      CALL PUSHCONTROL2B(0)
                    END IF
                    CALL PUSHREAL8(c00_x)
!end sundq3_ice
! * F5  ! F4 reduces AUTO for shallow clouds, F5 modifies auto for deep clouds
                    c00_x = cco_auto(i)*f2*f4
                    cli_crit_x = cli_crit/f2
! condensate (kg/kg)  
                    cli = cll0(l)/eta(l)
                    CALL PUSHREAL8(rate)
                    rate = c00_x*(1.0-EXP(-(cli**2/(cli_crit_x**2+10e-15&
&                      ))))
                    IF (cvw(l) .LT. 1.00) THEN
                      CALL PUSHREAL8(cvw_x)
                      cvw_x = 1.00
                      CALL PUSHCONTROL1B(0)
                    ELSE
                      CALL PUSHREAL8(cvw_x)
                      cvw_x = cvw(l)
                      CALL PUSHCONTROL1B(1)
                    END IF
! l.h.s. DT_LYR => time in layer (L,L+1)
                    dt_lyr = (zet(l)-zet(l+1))/cvw_x
                    closs = cll0(l)*rate*dt_lyr
                    IF (closs .GT. cll0(l)) THEN
                      closs = cll0(l)
                      CALL PUSHCONTROL1B(0)
                    ELSE
                      closs = closs
                      CALL PUSHCONTROL1B(1)
                    END IF
                    IF (closs .GT. 0.) THEN
                      wlq = wlq - closs
                      CALL PUSHREAL8(rnn(l))
                      rnn(l) = closs
                      CALL PUSHCONTROL2B(2)
                    ELSE
                      CALL PUSHREAL8(rnn(l))
                      rnn(l) = 0.
                      CALL PUSHCONTROL2B(1)
                    END IF
                  ELSE
                    CALL PUSHCONTROL2B(0)
                  END IF
                END DO
                CALL PUSHINTEGER4(l + 1)
                wlq = wlq - qst(ic)*eta(ic)
                CALL PUSHREAL8(gms(k))
!CALCULATE GAMMAS AND KERNEL
! MS-A30 (W/O GRAV)
                gms(k) = (sht(k)-ssl(k))*pri(k)
                CALL PUSHREAL8(gmh(k))
! MS-A31 (W/O GRAV)
                gmh(k) = gms(k) + (qht(k)-qol(k))*pri(k)*alhl
                CALL PUSHREAL8(akm)
! MS-A37 (W/O GRAV)
                akm = gmh(k)*gam(k-1)*dpb(k-1)
                CALL PUSHREAL8(tx2)
                tx2 = gmh(k)
                DO l=k-1,ic+1,-1
                  CALL PUSHREAL8(gms(l))
                  gms(l) = (eta(l)*(sht(l)-ssl(l))+eta(l+1)*(ssl(l)-sht(&
&                    l+1)))*pri(l)
                  CALL PUSHREAL8(gmh(l))
                  gmh(l) = gms(l) + (eta(l)*(qht(l)-qol(l))+eta(l+1)*(&
&                    qol(l)-qht(l+1)))*alhl*pri(l)
                  CALL PUSHREAL8(tx2)
                  tx2 = tx2 + (eta(l)-eta(l+1))*gmh(l)
                  akm = akm - gms(l)*eht(l)*pki(l) + tx2*ght(l)
                END DO
                CALL PUSHINTEGER4(l + 1)
                CALL PUSHREAL8(gms(ic))
                gms(ic) = eta(ic+1)*(ssl(ic)-sht(ic+1))*pri(ic)
                akm = akm - gms(ic)*eta(ic+1)*dpb(ic)*pki(ic)
                CALL PUSHREAL8(gmh(ic))
                gmh(ic) = gms(ic) + (eta(ic+1)*(qol(ic)-qht(ic+1))*alhl+&
&                  eta(ic)*(hst(ic)-hol(ic)))*pri(ic)
!CLOUD BASE MASS FLUX
                IF (akm .GE. 0.0 .OR. wlq .LT. 0.0) rc = 6
!  =========>
!RETURN
!====EXIT====>
!RC = 6
                IF (rc .EQ. 10) THEN
                  IF (akm .GE. 0.) THEN
                    abs6 = akm
                  ELSE
                    abs6 = -akm
                  END IF
                  IF (abs6 .GT. 0.0) THEN
                    CALL PUSHREAL8(wfn1)
!Linearisation security
! MS-A39 MASS-FLUX IN Pa/step
                    wfn1 = -((wfn-acr)/akm)
                    x1 = rasal(ic)*trg*toki*wfn1
                    IF (x1 .GT. (prs(k+1)-prs(k))*(100.*pblfrac)) THEN
                      wfn1 = (prs(k+1)-prs(k))*(100.*pblfrac)
                      CALL PUSHCONTROL2B(2)
                    ELSE
                      wfn1 = x1
                      CALL PUSHCONTROL2B(1)
                    END IF
                  ELSE
                    CALL PUSHCONTROL2B(0)
                  END IF
                  CALL PUSHREAL8(tem7)
!CUMULATIVE PRECIP AND CLOUD-BASE MASS FLUX FOR OUTPUT
                  tem7 = wfn1*gravi
! (kg/m^2/step)
! (kg/m^2/step)
! (kg/m^2/step)
                  ad_from2 = ic + 1
                  DO l=ad_from2,k
                    CALL PUSHREAL8(rmfp(l))
! (kg/m^2/step)
                    rmfp(l) = tem7*eta(l)
! (kg/m^2/step)
                    IF (cvw(l) .GT. 0.0) THEN
                      IF (cvw(l)*prs(l) .GE. 0.) THEN
                        abs7 = cvw(l)*prs(l)
                      ELSE
                        abs7 = -(cvw(l)*prs(l))
                      END IF
                      IF (abs7 .GT. 0.0) THEN
                        CALL PUSHCONTROL2B(2)
                      ELSE
                        CALL PUSHCONTROL2B(1)
                      END IF
                    ELSE
                      CALL PUSHCONTROL2B(0)
                    END IF
                  END DO
                  CALL PUSHINTEGER4(ad_from2)
                  ad_from3 = ic
!THETA AND Q CHANGE DUE TO CLOUD TYPE IC
                  DO l=ad_from3,k
                    CALL PUSHREAL8(gmh(l))
! (kg/m^2/step)
                    gmh(l) = gmh(l)*wfn1
                    CALL PUSHREAL8(gms1(l))
                    gms1(l) = gms(l)*wfn1
                    CALL PUSHREAL8(qoi(l))
                    qoi(l) = qoi(l) + (gmh(l)-gms1(l))*alhi
                    CALL PUSHREAL8(poi(l))
                    poi(l) = poi(l) + gms1(l)*pki(l)*cpi
                    CALL PUSHREAL8(qst(l))
                    qst(l) = qst(l) + gms1(l)*bet(l)*cpi
                  END DO
                  CALL PUSHINTEGER4(ad_from3)
!CUMULUS FRICTION
                  IF (fricfac .LE. 0.0) rc = 6
!RETURN  !  NO CUMULUS FRICTION =========>>
                  IF (rc .EQ. 10) THEN
!*FRICFAC*0.5
                    wfn2 = wfn1*0.5*1.0
                    CALL PUSHREAL8(wfn2)
                    wfn2 = wfn2*fricfac*EXP(-(alm/friclambda))
                    CALL PUSHREAL8(tem8)
                    tem8 = wfn2*pri(k)
                    ucu(k) = ucu(k) + tem8*(uoi(k-1)-uoi(k))
                    vcu(k) = vcu(k) + tem8*(voi(k-1)-voi(k))
                    DO l=k-1,ic+1,-1
                      CALL PUSHREAL8(tem9)
                      tem9 = wfn2*pri(l)
                      ucu(l) = ucu(l) + tem9*((uoi(l-1)-uoi(l))*eta(l)+(&
&                        uoi(l)-uoi(l+1))*eta(l+1))
                      vcu(l) = vcu(l) + tem9*((voi(l-1)-voi(l))*eta(l)+(&
&                        voi(l)-voi(l+1))*eta(l+1))
                    END DO
                    CALL PUSHINTEGER4(l + 1)
                    CALL PUSHREAL8(tem10)
                    tem10 = wfn2*pri(ic)
                    ucu(ic) = ucu(ic) + (2.*(uht-uoi(ic)*(eta(ic)-eta(ic&
&                      +1)))-(uoi(ic)+uoi(ic+1))*eta(ic+1))*tem10
                    vcu(ic) = vcu(ic) + (2.*(vht-voi(ic)*(eta(ic)-eta(ic&
&                      +1)))-(voi(ic)+voi(ic+1))*eta(ic+1))*tem10
                    ad_from4 = ic
                    DO l=ad_from4,k
                      CALL PUSHREAL8(uoi(l))
                      uoi(l) = uoi(l) + ucu(l)
                      CALL PUSHREAL8(voi(l))
                      voi(l) = voi(l) + vcu(l)
                    END DO
                    CALL PUSHINTEGER4(ad_from4)
                    CALL PUSHCONTROL1B(0)
                  ELSE
                    CALL PUSHCONTROL1B(1)
                  END IF
                  CALL PUSHCONTROL3B(7)
                ELSE
                  CALL PUSHCONTROL3B(6)
                END IF
              ELSE
                CALL PUSHCONTROL3B(5)
              END IF
            ELSE
              CALL PUSHCONTROL3B(4)
            END IF
          ELSE
            CALL PUSHCONTROL3B(3)
          END IF
        ELSE
          CALL PUSHCONTROL3B(2)
        END IF
      ELSE
        CALL PUSHCONTROL3B(1)
      END IF
    ELSE
      CALL PUSHCONTROL3B(0)
    END IF
  END DO
  gm1b = 0.0_8
  dqqb = 0.0_8
  cvwb = 0.0_8
  ghtb = 0.0_8
  betb = 0.0_8
  hstb = 0.0_8
  cqpertb = 0.0_8
  qolb = 0.0_8
  shtb = 0.0_8
  qstb = 0.0_8
  sslb = 0.0_8
  zetb = 0.0_8
  updfrpb = 0.0_8
  zolb = 0.0_8
  ctpertb = 0.0_8
  cll0b = 0.0_8
  holb = 0.0_8
  rmfpb = 0.0_8
  gamb = 0.0_8
  ehtb = 0.0_8
  wfn1b = 0.0_8
  hccb = 0.0_8
  trgb = 0.0_8
  ucub = 0.0_8
  qhtb = 0.0_8
  gms1b = 0.0_8
  bk2b = 0.0_8
  rasalb = 0.0_8
  hcldb = 0.0_8
  etab = 0.0_8
  gmhb = 0.0_8
  rnnb = 0.0_8
  gmsb = 0.0_8
  vcub = 0.0_8
  DO icl_c=n_dtl,1,-1
    CALL POPCONTROL3B(branch)
    IF (branch .LT. 4) THEN
      IF (branch .LT. 2) THEN
        IF (branch .EQ. 0) THEN
          GOTO 130
        ELSE
          GOTO 120
        END IF
      ELSE IF (branch .EQ. 2) THEN
        GOTO 110
      ELSE
        tem3b = 0.0_8
      END IF
    ELSE
      IF (branch .LT. 6) THEN
        IF (branch .EQ. 4) THEN
          almb = 0.0_8
          GOTO 100
        ELSE
          wfnb = 0.0_8
          tokib = 0.0_8
          almb = 0.0_8
        END IF
      ELSE
        IF (branch .EQ. 6) THEN
          wlqb = 0.0_8
          wfnb = 0.0_8
          vhtb = 0.0_8
          akmb = 0.0_8
          tokib = 0.0_8
          almb = 0.0_8
          uhtb = 0.0_8
        ELSE
          icl = k - icl_c
          ic = icl
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPINTEGER4(ad_from4)
            DO l=k,ad_from4,-1
              CALL POPREAL8(voi(l))
              vcub(l) = vcub(l) + voib(l)
              CALL POPREAL8(uoi(l))
              ucub(l) = ucub(l) + uoib(l)
            END DO
            temp8b3 = tem10*vcub(ic)
            temp8b4 = 2.*temp8b3
            temp8b5 = -(eta(ic+1)*temp8b3)
            vhtb = temp8b4
            voib(ic) = voib(ic) + temp8b5 - (eta(ic)-eta(ic+1))*temp8b4
            etab(ic) = etab(ic) - voi(ic)*temp8b4
            etab(ic+1) = etab(ic+1) + voi(ic)*temp8b4 - (voi(ic)+voi(ic+&
&              1))*temp8b3
            voib(ic+1) = voib(ic+1) + temp8b5
            tem10b = (2.*(uht-uoi(ic)*(eta(ic)-eta(ic+1)))-(uoi(ic)+uoi(&
&              ic+1))*eta(ic+1))*ucub(ic) + (2.*(vht-voi(ic)*(eta(ic)-eta&
&              (ic+1)))-(voi(ic)+voi(ic+1))*eta(ic+1))*vcub(ic)
            temp8b6 = tem10*ucub(ic)
            temp8b7 = 2.*temp8b6
            temp8b8 = -(eta(ic+1)*temp8b6)
            uhtb = temp8b7
            uoib(ic) = uoib(ic) + temp8b8 - (eta(ic)-eta(ic+1))*temp8b7
            etab(ic) = etab(ic) - uoi(ic)*temp8b7
            etab(ic+1) = etab(ic+1) + uoi(ic)*temp8b7 - (uoi(ic)+uoi(ic+&
&              1))*temp8b6
            uoib(ic+1) = uoib(ic+1) + temp8b8
            CALL POPREAL8(tem10)
            wfn2b = pri(ic)*tem10b
            CALL POPINTEGER4(ad_to5)
            DO l=ad_to5,k-1,1
              temp8b = tem9*vcub(l)
              temp8b0 = eta(l+1)*temp8b
              tem9b = ((uoi(l-1)-uoi(l))*eta(l)+(uoi(l)-uoi(l+1))*eta(l+&
&                1))*ucub(l) + ((voi(l-1)-voi(l))*eta(l)+(voi(l)-voi(l+1)&
&                )*eta(l+1))*vcub(l)
              voib(l-1) = voib(l-1) + eta(l)*temp8b
              voib(l) = voib(l) + temp8b0 - eta(l)*temp8b
              etab(l) = etab(l) + (voi(l-1)-voi(l))*temp8b
              voib(l+1) = voib(l+1) - temp8b0
              etab(l+1) = etab(l+1) + (voi(l)-voi(l+1))*temp8b
              temp8b1 = tem9*ucub(l)
              temp8b2 = eta(l+1)*temp8b1
              uoib(l-1) = uoib(l-1) + eta(l)*temp8b1
              uoib(l) = uoib(l) + temp8b2 - eta(l)*temp8b1
              etab(l) = etab(l) + (uoi(l-1)-uoi(l))*temp8b1
              uoib(l+1) = uoib(l+1) - temp8b2
              etab(l+1) = etab(l+1) + (uoi(l)-uoi(l+1))*temp8b1
              CALL POPREAL8(tem9)
              wfn2b = wfn2b + pri(l)*tem9b
            END DO
            tem8b = (uoi(k-1)-uoi(k))*ucub(k) + (voi(k-1)-voi(k))*vcub(k&
&              )
            voib(k-1) = voib(k-1) + tem8*vcub(k)
            voib(k) = voib(k) - tem8*vcub(k)
            uoib(k-1) = uoib(k-1) + tem8*ucub(k)
            uoib(k) = uoib(k) - tem8*ucub(k)
            CALL POPREAL8(tem8)
            wfn2b = wfn2b + pri(k)*tem8b
            CALL POPREAL8(wfn2)
            almb = -(EXP(-(alm/friclambda))*wfn2*fricfac*wfn2b/&
&              friclambda)
            wfn2b = fricfac*EXP(-(alm/friclambda))*wfn2b
            wfn1b = wfn1b + 0.5*wfn2b
          ELSE
            vhtb = 0.0_8
            almb = 0.0_8
            uhtb = 0.0_8
          END IF
          tem7b = 0.0_8
          CALL POPINTEGER4(ad_from3)
          DO l=k,ad_from3,-1
            CALL POPREAL8(qst(l))
            gms1b(l) = gms1b(l) + pki(l)*cpi*poib(l) - alhi*qoib(l) + &
&              cpi*bet(l)*qstb(l)
            betb(l) = betb(l) + cpi*gms1(l)*qstb(l)
            CALL POPREAL8(poi(l))
            CALL POPREAL8(qoi(l))
            gmhb(l) = gmhb(l) + alhi*qoib(l)
            CALL POPREAL8(gms1(l))
            gmsb(l) = gmsb(l) + wfn1*gms1b(l)
            CALL POPREAL8(gmh(l))
            wfn1b = wfn1b + gmh(l)*gmhb(l) + gms(l)*gms1b(l)
            gms1b(l) = 0.0_8
            gmhb(l) = wfn1*gmhb(l)
            rnnb(l) = rnnb(l) + tem7*rnsb(l)
            tem7b = tem7b + rnn(l)*rnsb(l)
          END DO
          CALL POPINTEGER4(ad_from2)
          DO l=k,ad_from2,-1
            updfrpb(l) = updfrpb(l) + updfrcb(l)
            CALL POPCONTROL2B(branch)
            IF (branch .EQ. 0) THEN
              updfrpb(l) = 0.0_8
            ELSE IF (branch .NE. 1) THEN
              temp7 = daylen*prs(l)*cvw(l)
              temp7b12 = ddt*1000.*updfrpb(l)/temp7
              rmfpb(l) = rmfpb(l) + temp7b12
              cvwb(l) = cvwb(l) - rmfp(l)*daylen*prs(l)*temp7b12/temp7
              updfrpb(l) = 0.0_8
            END IF
            CALL POPREAL8(rmfp(l))
            tem7b = tem7b + eta(l)*rmfpb(l)
            etab(l) = etab(l) + tem7*rmfpb(l)
            rmfpb(l) = 0.0_8
          END DO
          tem7b = tem7b + wlq*cllb0(ic) + eta(ic)*rmfdb(ic)
          etab(ic) = etab(ic) + tem7*rmfdb(ic)
          wlqb = tem7*cllb0(ic)
          CALL POPREAL8(tem7)
          wfn1b = wfn1b + gravi*tem7b
          CALL POPCONTROL2B(branch)
          IF (branch .EQ. 0) THEN
            wfnb = 0.0_8
            akmb = 0.0_8
            tokib = 0.0_8
          ELSE
            IF (branch .EQ. 1) THEN
              x1b = wfn1b
              wfn1 = -((wfn-acr)/akm)
            ELSE
              wfn1 = -((wfn-acr)/akm)
              x1b = 0.0_8
            END IF
            temp7b10 = trg*toki*x1b
            temp7b11 = rasal(ic)*wfn1*x1b
            rasalb(ic) = rasalb(ic) + wfn1*temp7b10
            wfn1b = rasal(ic)*temp7b10
            trgb = trgb + toki*temp7b11
            tokib = trg*temp7b11
            CALL POPREAL8(wfn1)
            wfnb = -(wfn1b/akm)
            akmb = (wfn-acr)*wfn1b/akm**2
            wfn1b = 0.0_8
          END IF
        END IF
        temp7b8 = -(dpb(ic)*pki(ic)*akmb)
        CALL POPREAL8(gmh(ic))
        temp7b6 = pri(ic)*gmhb(ic)
        temp7b7 = alhl*eta(ic+1)*temp7b6
        gmsb(ic) = gmsb(ic) + eta(ic+1)*temp7b8 + gmhb(ic)
        etab(ic+1) = etab(ic+1) + alhl*(qol(ic)-qht(ic+1))*temp7b6
        qolb(ic) = qolb(ic) + temp7b7
        qhtb(ic+1) = qhtb(ic+1) - temp7b7
        etab(ic) = etab(ic) + (hst(ic)-hol(ic))*temp7b6
        hstb(ic) = hstb(ic) + eta(ic)*temp7b6
        holb(ic) = holb(ic) - eta(ic)*temp7b6
        gmhb(ic) = 0.0_8
        etab(ic+1) = etab(ic+1) + pri(ic)*(ssl(ic)-sht(ic+1))*gmsb(ic) +&
&          gms(ic)*temp7b8
        CALL POPREAL8(gms(ic))
        temp7b9 = pri(ic)*eta(ic+1)*gmsb(ic)
        sslb(ic) = sslb(ic) + temp7b9
        shtb(ic+1) = shtb(ic+1) - temp7b9
        gmsb(ic) = 0.0_8
        tx2b = 0.0_8
        CALL POPINTEGER4(ad_to4)
        DO l=ad_to4,k-1,1
          tx2b = tx2b + ght(l)*akmb
          gmhb(l) = gmhb(l) + (eta(l)-eta(l+1))*tx2b
          gmsb(l) = gmsb(l) + gmhb(l) - pki(l)*eht(l)*akmb
          ehtb(l) = ehtb(l) - pki(l)*gms(l)*akmb
          ghtb(l) = ghtb(l) + tx2*akmb
          CALL POPREAL8(tx2)
          etab(l) = etab(l) + gmh(l)*tx2b
          etab(l+1) = etab(l+1) - gmh(l)*tx2b
          CALL POPREAL8(gmh(l))
          temp7b2 = alhl*pri(l)*gmhb(l)
          temp7b3 = eta(l+1)*temp7b2
          etab(l) = etab(l) + (qht(l)-qol(l))*temp7b2
          qhtb(l) = qhtb(l) + eta(l)*temp7b2
          qolb(l) = qolb(l) + temp7b3 - eta(l)*temp7b2
          etab(l+1) = etab(l+1) + (qol(l)-qht(l+1))*temp7b2
          qhtb(l+1) = qhtb(l+1) - temp7b3
          gmhb(l) = 0.0_8
          CALL POPREAL8(gms(l))
          temp7b4 = pri(l)*gmsb(l)
          temp7b5 = eta(l+1)*temp7b4
          etab(l) = etab(l) + (sht(l)-ssl(l))*temp7b4
          shtb(l) = shtb(l) + eta(l)*temp7b4
          sslb(l) = sslb(l) + temp7b5 - eta(l)*temp7b4
          etab(l+1) = etab(l+1) + (ssl(l)-sht(l+1))*temp7b4
          shtb(l+1) = shtb(l+1) - temp7b5
          gmsb(l) = 0.0_8
        END DO
        temp7b0 = dpb(k-1)*akmb
        CALL POPREAL8(tx2)
        gmhb(k) = gmhb(k) + gam(k-1)*temp7b0 + tx2b
        CALL POPREAL8(akm)
        gamb(k-1) = gamb(k-1) + gmh(k)*temp7b0
        CALL POPREAL8(gmh(k))
        temp7b1 = pri(k)*alhl*gmhb(k)
        gmsb(k) = gmsb(k) + gmhb(k)
        qhtb(k) = qhtb(k) + temp7b1
        qolb(k) = qolb(k) - temp7b1
        gmhb(k) = 0.0_8
        CALL POPREAL8(gms(k))
        shtb(k) = shtb(k) + pri(k)*gmsb(k)
        sslb(k) = sslb(k) - pri(k)*gmsb(k)
        gmsb(k) = 0.0_8
        qstb(ic) = qstb(ic) - eta(ic)*wlqb
        etab(ic) = etab(ic) - qst(ic)*wlqb
        CALL POPINTEGER4(ad_to3)
        DO l=ad_to3,k-1,1
          CALL POPCONTROL2B(branch)
          IF (branch .EQ. 0) THEN
            te_ab = 0.0_8
          ELSE
            IF (branch .EQ. 1) THEN
              CALL POPREAL8(rnn(l))
              rnnb(l) = 0.0_8
              clossb = 0.0_8
            ELSE
              CALL POPREAL8(rnn(l))
              clossb = rnnb(l) - wlqb
              rnnb(l) = 0.0_8
            END IF
            clossb = clossb - cll0b(l)
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              dt_lyr = (zet(l)-zet(l+1))/cvw_x
              cll0b(l) = cll0b(l) + clossb
              clossb = 0.0_8
            ELSE
              dt_lyr = (zet(l)-zet(l+1))/cvw_x
            END IF
            cll0b(l) = cll0b(l) + rate*dt_lyr*clossb
            rateb = cll0(l)*dt_lyr*clossb
            dt_lyrb = cll0(l)*rate*clossb
            temp7b = dt_lyrb/cvw_x
            zetb(l) = zetb(l) + temp7b
            zetb(l+1) = zetb(l+1) - temp7b
            cvw_xb = -((zet(l)-zet(l+1))*temp7b/cvw_x)
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL8(cvw_x)
            ELSE
              CALL POPREAL8(cvw_x)
              cvwb(l) = cvwb(l) + cvw_xb
            END IF
            cli_crit_x = cli_crit/f2
            cli = cll0(l)/eta(l)
            CALL POPREAL8(rate)
            temp6 = cli_crit_x**2 + 10e-15
            temp5 = cli**2/temp6
            temp5b1 = EXP(-temp5)*c00_x*rateb/temp6
            c00_xb = (1.0-EXP(-temp5))*rateb
            clib = 2*cli*temp5b1
            cli_crit_xb = -(temp5*2*cli_crit_x*temp5b1)
            temp5b2 = clib/eta(l)
            cll0b(l) = cll0b(l) + temp5b2
            etab(l) = etab(l) - cll0(l)*temp5b2/eta(l)
            f2b = cco_auto(i)*f4*c00_xb - cli_crit*cli_crit_xb/f2**2
            CALL POPREAL8(c00_x)
            te_a = poi(l)*prh(l)
            CALL POPCONTROL2B(branch)
            IF (branch .EQ. 0) THEN
              te_ab = 0.0_8
            ELSE IF (branch .EQ. 1) THEN
              te_ab = -((sdqv3-sdqv2)*f2b/(te1-te2))
            ELSE
              te_ab = -(0.3333*(te0-te_a)**(-0.6667)*jump1*f2b)
            END IF
            CALL POPREAL8(f2)
          END IF
          poib(l) = poib(l) + prh(l)*te_ab
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) cll0b(l) = 0.0_8
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPREAL8(cll0(l))
            wlqb = wlqb + cll0b(l)
            qstb(ic) = qstb(ic) - eta(ic)*cll0b(l)
            etab(ic) = etab(ic) - qst(ic)*cll0b(l)
            cll0b(l) = 0.0_8
          ELSE
            CALL POPREAL8(cll0(l))
            wlqb = wlqb + cll0b(l)
            qccb = -cll0b(l)
            cll0b(l) = 0.0_8
            tx2b = qccb
            gm1b(l) = gm1b(l) + (hcc(l)-tx3)*qccb
            hccb(l) = hccb(l) + gm1(l)*qccb
            tx3b = -(gm1(l)*qccb)
            CALL POPREAL8(tx3)
            temp5b = 0.5*eta(l)*tx3b
            hstb(l) = hstb(l) + temp5b
            hstb(l-1) = hstb(l-1) + temp5b
            etab(l) = etab(l) + 0.5*(qst(l)+qst(l-1))*tx2b + 0.5*(hst(l)&
&              +hst(l-1))*tx3b
            CALL POPREAL8(tx2)
            temp5b0 = 0.5*eta(l)*tx2b
            qstb(l) = qstb(l) + temp5b0
            qstb(l-1) = qstb(l-1) + temp5b0
          END IF
          tem6 = eta(l) - eta(l+1)
          tem6b = uoi(l)*uhtb + qol(l)*wlqb + voi(l)*vhtb
          voib(l) = voib(l) + tem6*vhtb
          uoib(l) = uoib(l) + tem6*uhtb
          qolb(l) = qolb(l) + tem6*wlqb
          etab(l) = etab(l) + tem6b
          etab(l+1) = etab(l+1) - tem6b
        END DO
        cll0b(k) = 0.0_8
        CALL POPREAL8(rnn(k))
        rnnb(k) = 0.0_8
        CALL POPREAL8(vht)
        voib(k) = voib(k) + vhtb
        CALL POPREAL8(uht)
        uoib(k) = uoib(k) + uhtb
        CALL POPREAL8(wlq)
        qolb(k) = qolb(k) + wlqb
      END IF
      CALL POPREAL8(acr)
      CALL POPREAL8ARRAY(cvw(ic:k), k - ic + 1)
      CALL POPREAL8ARRAY(cvw(ic:k), k - ic + 1)
      CALL POPBOOLEANARRAY(mask, k - ic + 1)
      WHERE (mask(1:k-ic+1)) cvwb(ic:k) = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        CALL POPREAL8(rasal(ic))
        temp4 = rasal1 + (rasal2-rasal1)*(zet(ic)-2000.)/8000.
        zetb(ic) = zetb(ic) - (rasal2-rasal1)*dt*rasalb(ic)/(temp4**2*&
&          8000.)
        rasalb(ic) = 0.0_8
      END IF
      CALL POPREAL8(rasal(ic))
      rasalb(ic) = 0.0_8
      CALL POPINTEGER4(ad_to2)
      DO l=ad_to2,k-1,1
        CALL POPREAL8(cvw(l))
        IF (2.0*max2 .EQ. 0.0) THEN
          max2b = 0.0
        ELSE
          max2b = cvwb(l)/SQRT(2.0*max2)
        END IF
        cvwb(l) = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          CALL POPREAL8(max2)
        ELSE
          CALL POPREAL8(max2)
          bk2b(l) = bk2b(l) + max2b
        END IF
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .EQ. 1) THEN
            tem5b = 0.0_8
          ELSE
            temp3 = cp*prj(l+1)
            temp2 = temp3*poi(l)
            temp2b = grav*bk2b(l)/temp2
            bk2b(l+1) = bk2b(l+1) + bk2b(l)
            max1b = temp2b
            poib(l) = poib(l) - max1*temp3*temp2b/temp2
            bk2b(l) = 0.0_8
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              CALL POPREAL8(max1)
              tem5b = 0.0_8
            ELSE
              CALL POPREAL8(max1)
              tem5b = max1b
            END IF
          END IF
          temp1 = lbcp*dqq(l) + 1.000000000000001
          tempb8 = tem5b/temp1
          temp0 = zet(l) - zet(l+1)
          temp = hcld(l) - hst(l)
          hcldb(l) = hcldb(l) + temp0*tempb8
          hstb(l) = hstb(l) - temp0*tempb8
          zetb(l) = zetb(l) + temp*tempb8
          zetb(l+1) = zetb(l+1) - temp*tempb8
          dqqb(l) = dqqb(l) - temp*temp0*lbcp*tempb8/temp1
        END IF
      END DO
      bk2b(k) = 0.0_8
      CALL POPINTEGER4(ad_to1)
      DO l=ad_to1,k-1,1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          CALL POPREAL8(hcld(l))
          tempb7 = hcldb(l)/(eta(l)+1e-15)
          etab(l+1) = etab(l+1) + (hcld(l+1)-hol(l))*tempb7
          hcldb(l+1) = hcldb(l+1) + eta(l+1)*tempb7
          etab(l) = etab(l) + (hol(l)-(eta(l+1)*hcld(l+1)+(eta(l)-eta(l+&
&            1))*hol(l))/(eta(l)+1e-15))*tempb7
          holb(l) = holb(l) + (eta(l)-eta(l+1))*tempb7
          hcldb(l) = 0.0_8
        END IF
      END DO
      CALL POPREAL8(hcld(k))
      holb(k) = holb(k) + hcldb(k)
      hcldb(k) = 0.0_8
      tempb6 = dpb(ic)*gam(ic)*wfnb
      hccb(ic+1) = hccb(ic+1) + tempb6
      hstb(ic) = hstb(ic) + eta(ic)*hccb(ic) - eta(ic+1)*tempb6
      etab(ic+1) = etab(ic+1) - hst(ic)*tempb6
      gamb(ic) = gamb(ic) + dpb(ic)*(hcc(ic+1)-hst(ic)*eta(ic+1))*wfnb
      CALL POPREAL8(hcc(ic))
      etab(ic) = etab(ic) + hst(ic)*hccb(ic)
      hccb(ic) = 0.0_8
      CALL POPINTEGER4(ad_to0)
      DO l=ad_to0,k-1,1
        tem4 = hcc(l+1)*dpb(l) + hcc(l)*dpt(l)
        tempb5 = gam(l)*wfnb
        tem4b = tempb5
        ehtb(l) = ehtb(l) - hst(l)*tempb5
        hstb(l) = hstb(l) - eht(l)*tempb5
        gamb(l) = gamb(l) + (tem4-eht(l)*hst(l))*wfnb
        CALL POPREAL8(eht(l))
        etab(l+1) = etab(l+1) + dpb(l)*ehtb(l)
        CALL POPREAL8(tem4)
        hccb(l+1) = hccb(l+1) + dpb(l)*tem4b
        hccb(l) = hccb(l) + dpt(l)*tem4b
        CALL POPREAL8(hcc(l))
        hccb(l+1) = hccb(l+1) + hccb(l)
        etab(l) = etab(l) + hol(l)*hccb(l) + dpt(l)*ehtb(l)
        ehtb(l) = 0.0_8
        etab(l+1) = etab(l+1) - hol(l)*hccb(l)
        holb(l) = holb(l) + (eta(l)-eta(l+1))*hccb(l)
        hccb(l) = 0.0_8
      END DO
      CALL POPREAL8(hcc(k))
      holb(k) = holb(k) + hccb(k)
      hccb(k) = 0.0_8
      CALL POPREAL8(wfn)
      CALL POPREAL8(eta(ic))
      almb = almb + (zol(ic)-zet(k))*etab(ic)
      zolb(ic) = zolb(ic) + alm*etab(ic)
      zetb(k) = zetb(k) - alm*etab(ic)
      etab(ic) = 0.0_8
      CALL POPINTEGER4(ad_from1)
      DO l=k,ad_from1,-1
        CALL POPREAL8(eta(l))
        almb = almb + (zet(l)-zet(k))*etab(l)
        zetb(l) = zetb(l) + alm*etab(l)
        zetb(k) = zetb(k) - alm*etab(l)
        etab(l) = 0.0_8
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) almb = almb + 2*alm*tokib/lambda_min**2
      CALL POPREAL8(toki)
 100  CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        tempb4 = almb/tem3
        holb(k) = holb(k) + tempb4
        hstb(ic) = hstb(ic) - tempb4
        tem3b = -((hol(k)-hst(ic))*tempb4/tem3)
      ELSE
        tem3b = 0.0_8
      END IF
    END IF
    CALL POPINTEGER4(ad_from0)
    DO l=k-1,ad_from0,-1
      tempb2 = (zet(l)-zet(l+1))*tem3b
      tempb3 = (hst(ic)-hol(l))*tem3b
      hstb(ic) = hstb(ic) + tempb2
      holb(l) = holb(l) - tempb2
      zetb(l) = zetb(l) + tempb3
      zetb(l+1) = zetb(l+1) - tempb3
    END DO
    CALL POPREAL8(tem3)
    tempb0 = (zol(ic)-zet(ic+1))*tem3b
    tempb1 = (hst(ic)-hol(ic))*tem3b
    hstb(ic) = hstb(ic) + tempb0
    holb(ic) = holb(ic) - tempb0
    zolb(ic) = zolb(ic) + tempb1
    zetb(ic+1) = zetb(ic+1) - tempb1
 110 CALL POPREAL8(lambda_min)
    CALL POPINTEGER4(ad_from)
    DO l=k,ad_from,-1
      CALL POPREAL8(qht(l))
      qolb(l) = qolb(l) + .5*qhtb(l)
      qolb(l-1) = qolb(l-1) + .5*qhtb(l)
      qhtb(l) = 0.0_8
      tem2 = (prj(l)-prh(l-1))/(prh(l)-prh(l-1))
      CALL POPREAL8(sht(l))
      sslb(l-1) = sslb(l-1) + (1.0_8-tem2)*shtb(l)
      sslb(l) = sslb(l) + tem2*shtb(l)
      shtb(l) = 0.0_8
    END DO
    poi_cb = 0.0_8
    qoi_cb = 0.0_8
    CALL POPINTEGER4(ad_to)
    DO l=ad_to,k,1
      sslb(l) = sslb(l) + holb(l) + hstb(l)
      CALL POPREAL8(zol(l))
      zetb(l+1) = zetb(l+1) + zetb(l) + zolb(l)
      CALL POPREAL8(zet(l))
      tem1b = zetb(l)
      poi_cb(l) = poi_cb(l) + (prj(l+1)-prj(l))*cpbg*tem1b + prj(l+1)*cp&
&        *sslb(l) + (prj(l+1)-prh(l))*cpbg*zolb(l)
      zolb(l) = 0.0_8
      zetb(l) = 0.0_8
      CALL POPREAL8(hst(l))
      qstb(l) = qstb(l) + alhl*hstb(l)
      hstb(l) = 0.0_8
      CALL POPREAL8(hol(l))
      qolb(l) = qolb(l) + alhl*holb(l)
      holb(l) = 0.0_8
      CALL POPREAL8(ssl(l))
      zetb(l+1) = zetb(l+1) + grav*sslb(l)
      sslb(l) = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) qolb(l) = 0.0_8
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        CALL POPREAL8(qol(l))
        qoi_cb(l) = qoi_cb(l) + qolb(l)
        qolb(l) = 0.0_8
      ELSE
        CALL POPREAL8(qol(l))
        qstb(l) = qstb(l) + rhmax*qolb(l)
        qolb(l) = 0.0_8
      END IF
    END DO
    CALL POPREAL8(sht(k+1))
    poi_cb(k) = poi_cb(k) + prj(k+1)*cp*shtb(k+1)
    shtb(k+1) = 0.0_8
    CALL POPREAL8(zet(k+1))
    zetb(k+1) = 0.0_8
    cqpertb(i) = cqpertb(i) + qoi_cb(k)
    ctpertb(i) = ctpertb(i) + poi_cb(k)
    qoib = qoib + qoi_cb
    poib = poib + poi_cb
 120 CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8(f4)
    ELSE
      CALL POPREAL8(f4)
    END IF
    CALL POPCONTROL2B(branch)
    IF (branch .NE. 0) THEN
      IF (branch .EQ. 1) THEN
        CALL POPREAL8(trg)
      ELSE
        CALL POPREAL8(trg)
        tempb = trgb/((rhmx-rhmn)*qst(k))
        qoib(k) = qoib(k) + tempb
        qstb(k) = qstb(k) - qoi(k)*tempb/qst(k)
      END IF
      trgb = 0.0_8
    END IF
    CALL POPREAL8(alm)
    CALL POPINTEGER4(ic)
 130 vcub(icmin:k0) = 0.0_8
    ucub(icmin:k0) = 0.0_8
  END DO
END SUBROUTINE CLOUDE_B

!  Differentiation of strap0 in reverse (adjoint) mode:
!   gradient     of useful results: gm1 tho dqq ght bet qho qoi_sv
!                vho uoi_sv qoi voi uho qst poi poi_sv uoi voi_sv
!                gam
!   with respect to varying inputs: tho cdqs qho vho uho cqss
SUBROUTINE STRAP0_B(i, k, k0, idim, icmin, cpke, cple, uho, uhob, vho, &
&  vhob, tho, thob, qho, qhob, cdqs, cdqsb, cqss, cqssb, estblx, seedras&
&  , wgt0, mxdiam, poi, poib, qoi, qoib, uoi, uoib, voi, voib, prj, prs, &
&  qst, qstb, dqq, dqqb, cons_rgas, cons_cp, onepkap, pol, prh, pki, dpt&
&  , dpb, pri, maxdallowed, bet, betb, gam, gamb, lbcp, ght, ghtb, gm1, &
&  gm1b, alhl, tcu, qcu, rns, cll, rmf, rmfd, rmfc, rmfp, cll0, dll0, &
&  dllx, clli, cllb, cvw, updfrc, updfrp, poi_sv, poi_svb, qoi_sv, &
&  qoi_svb, uoi_sv, uoi_svb, voi_sv, voi_svb)
  IMPLICIT NONE
!!GLOBALS!!
  INTEGER :: i, k, k0, idim, icmin
  INTEGER, DIMENSION(idim) :: seedras
  REAL*8, DIMENSION(idim, k0) :: uho, vho, tho, qho, cdqs, cqss, wgt0
  REAL*8, DIMENSION(idim, k0) :: uhob, vhob, thob, qhob, cdqsb, cqssb
  REAL*8, DIMENSION(idim, k0 + 1) :: cpke, cple
  REAL*8 :: cons_rgas, cons_cp
  REAL*8 :: onepkap, maxdallowed, lbcp, alhl, mxdiam
  REAL*8, DIMENSION(k0 + 1) :: prj, prs
  REAL*8, DIMENSION(k0) :: poi, qoi, uoi, voi, qst, dqq, temp1
  REAL*8, DIMENSION(k0) :: poib, qoib, uoib, voib, qstb, dqqb, temp1b
  REAL*8, DIMENSION(k0) :: pol, prh, pki, dpt, dpb, pri
  REAL*8, DIMENSION(k0) :: bet, gam, ght, gm1, tcu, qcu
  REAL*8, DIMENSION(k0) :: betb, gamb, ghtb, gm1b
  REAL*8, DIMENSION(k0) :: poi_sv, qoi_sv, uoi_sv, voi_sv
  REAL*8, DIMENSION(k0) :: poi_svb, qoi_svb, uoi_svb, voi_svb
  REAL*8, DIMENSION(k0) :: rns, cll, rmf, rmfd, rmfc, rmfp, cll0, dll0, &
&  dllx, clli, cllb, cvw, updfrc, updfrp
!!LOCALS!!
  INTEGER :: l, kk
  REAL*8 :: wght0, prcbl, rndu
  REAL*8, DIMENSION(k0) :: wght, massf
!Table lookup constants
  REAL*8 :: estblx(:)
!Zero locals
  INTEGER :: branch
  REAL*8 :: temp2
  REAL*8 :: temp0
  REAL*8 :: temp0b
  INTRINSIC MAX
  REAL*8 :: temp0b1
  REAL*8 :: temp0b0
  REAL*8 :: temp
  DO kk=icmin,k+1
    prj(kk) = cpke(i, kk)
  END DO
! These initialized here in order not to confuse Valgrind debugger
  poi = 0.
! Do not believe it actually makes any difference.
  prs(icmin:k0+1) = cple(i, icmin:k0+1)
  poi(icmin:k) = tho(i, icmin:k)
  dqq(icmin:k) = cdqs(i, icmin:k)
!!! Mass fraction of each layer below cloud base
!!! contributed to aggregate cloudbase layer (CBL) 
  massf(:) = wgt0(i, :)
!!! RESET PRESSURE at bottom edge of CBL 
  prcbl = prs(k)
  DO l=k,k0
    prcbl = prcbl + massf(l)*(prs(l+1)-prs(l))
  END DO
  prs(k+1) = prcbl
  prj(k+1) = (prs(k+1)/1000.)**(cons_rgas/cons_cp)
  DO l=k,icmin,-1
    pol(l) = 0.5*(prs(l)+prs(l+1))
    prh(l) = (prs(l+1)*prj(l+1)-prs(l)*prj(l))/(onepkap*(prs(l+1)-prs(l)&
&      ))
    pki(l) = 1.0/prh(l)
    dpt(l) = prh(l) - prj(l)
    dpb(l) = prj(l+1) - prh(l)
  END DO
!!!!! RECALCULATE PROFILE QUAN. IN LOWEST STRAPPED LAYER
  IF (k .LE. k0) THEN
    poi(k) = 0.
!! SPECIFY WEIGHTS GIVEN TO EACH LAYER WITHIN SUBCLOUD "SUPERLAYER"
    wght = 0.
    DO l=k,k0
      wght(l) = massf(l)*(cple(i, l+1)-cple(i, l))/(prs(k+1)-prs(k))
    END DO
    DO l=k,k0
      poi(k) = poi(k) + wght(l)*tho(i, l)
    END DO
    dqq(k) = 0.0
    temp1(k) = poi(k)*prh(k)
    CALL DQSAT_SUB(dqq(k), qst(k), temp1(k), pol(k), 1, 1, 1, estblx)
    CALL PUSHCONTROL1B(1)
  ELSE
    CALL PUSHCONTROL1B(0)
  END IF
  DO l=k,icmin,-1
!*
!*
    IF (l .LT. k) THEN
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
  END DO
  voib = voib + voi_svb
  uoib = uoib + uoi_svb
  qoib = qoib + qoi_svb
  poib = poib + poi_svb
  DO l=icmin,k,1
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      temp2 = alhl*(lbcp*dqq(l+1)+1.0)
      temp0 = alhl*(lbcp*dqq(l)+1.0)
      temp0b = lbcp*0.5*gm1b(l+1)
      temp0b0 = temp0b/temp0
      temp0b1 = temp0b/temp2
      dqqb(l) = dqqb(l) + (1.0_8-alhl*dqq(l)*lbcp/temp0)*temp0b0
      dqqb(l+1) = dqqb(l+1) + (1.0_8-alhl*dqq(l+1)*lbcp/temp2)*temp0b1
      gm1b(l+1) = 0.0_8
      gamb(l) = gamb(l) + dpb(l)*ghtb(l+1)
      gamb(l+1) = gamb(l+1) + dpt(l+1)*ghtb(l+1)
      ghtb(l+1) = 0.0_8
    END IF
    temp = lbcp*dqq(l) + 1.0
    dqqb(l) = dqqb(l) + pki(l)*betb(l) - pki(l)*lbcp*gamb(l)/temp**2
    gamb(l) = 0.0_8
    betb(l) = 0.0_8
  END DO
  CALL POPCONTROL1B(branch)
  IF (branch .NE. 0) THEN
    temp1b = 0.0_8
    CALL DQSAT_SUB_B(dqq(k), dqqb(k), qst(k), qstb(k), temp1(k), temp1b(&
&               k), pol(k), 1, 1, 1, estblx)
    poib(k) = poib(k) + prh(k)*temp1b(k)
    qstb(k) = 0.0_8
    dqqb(k) = 0.0_8
    DO l=k0,k,-1
      vhob(i, l) = vhob(i, l) + wght(l)*voib(k)
      uhob(i, l) = uhob(i, l) + wght(l)*uoib(k)
      qhob(i, l) = qhob(i, l) + wght(l)*qoib(k)
      thob(i, l) = thob(i, l) + wght(l)*poib(k)
    END DO
    voib(k) = 0.0_8
    uoib(k) = 0.0_8
    qoib(k) = 0.0_8
    poib(k) = 0.0_8
  END IF
  cdqsb = 0.0_8
  cdqsb(i, icmin:k) = cdqsb(i, icmin:k) + dqqb(icmin:k)
  cqssb = 0.0_8
  cqssb(i, icmin:k) = cqssb(i, icmin:k) + qstb(icmin:k)
  vhob(i, icmin:k) = vhob(i, icmin:k) + voib(icmin:k)
  uhob(i, icmin:k) = uhob(i, icmin:k) + uoib(icmin:k)
  qhob(i, icmin:k) = qhob(i, icmin:k) + qoib(icmin:k)
  thob(i, icmin:k) = thob(i, icmin:k) + poib(icmin:k)
END SUBROUTINE STRAP0_B

!  Differentiation of strap1 in reverse (adjoint) mode:
!   gradient     of useful results: clw tho qho vho cnv_updfrc
!                uho flxd
!   with respect to varying inputs: tho qho qoi_sv vho uoi_sv qoi
!                voi uho updfrc poi poi_sv uoi rmfd voi_sv cll
SUBROUTINE STRAP1_B(i, k, k0, idim, icmin, tho, thob, qho, qhob, uho, &
&  uhob, vho, vhob, cnv_updfrc, cnv_updfrcb, cple, flxd, flxdb, clw, clwb&
&  , wgt1, poi, poib, qoi, qoib, uoi, uoib, voi, voib, updfrc, updfrcb, &
&  cvw, cllb, prs, poi_sv, poi_svb, qoi_sv, qoi_svb, uoi_sv, uoi_svb, &
&  voi_sv, voi_svb, rmf, rmfd, rmfdb, rmfc, cll, cllb0, ddt, daylen)
  IMPLICIT NONE
!!GLOBALS!!
  INTEGER :: i, k, k0, idim, icmin
  REAL*8 :: ddt, daylen
  REAL*8, DIMENSION(idim, k0) :: tho, qho, uho, vho
  REAL*8, DIMENSION(idim, k0) :: thob, qhob, uhob, vhob
  REAL*8, DIMENSION(idim, k0) :: cnv_updfrc, flxd, clw, wgt1
  REAL*8, DIMENSION(idim, k0) :: cnv_updfrcb, flxdb, clwb
  REAL*8, DIMENSION(idim, k0 + 1) :: cple
  REAL*8, DIMENSION(k0) :: poi, qoi, uoi, voi, poi_sv, qoi_sv, uoi_sv, &
&  voi_sv
  REAL*8, DIMENSION(k0) :: poib, qoib, uoib, voib, poi_svb, qoi_svb, &
&  uoi_svb, voi_svb
  REAL*8, DIMENSION(k0) :: updfrc, cvw, cllb, prs, rmf, rmfd, rmfc, cll
  REAL*8, DIMENSION(k0) :: updfrcb, rmfdb, cllb0
!!LOCALS!! 
  INTEGER :: l
  REAL*8 :: wght0
  REAL*8, DIMENSION(k0) :: wght
!Zero locals
  wght = wgt1(i, :)
!! Scale properly by layer masses
  wght0 = 0.
  DO l=k,k0
    wght0 = wght0 + wght(l)*(cple(i, l+1)-cple(i, l))
  END DO
  wght0 = (prs(k+1)-prs(k))/wght0
  wght = wght0*wght
!  (KG/m^2/s @ CLOUD TOP)
!  (KG/m^2/s )
  IF (k .LT. k0) THEN
    clwb(i, k:k0) = 0.0_8
    flxdb(i, k:k0) = 0.0_8
  END IF
  clwb(i, 1:icmin-1) = 0.0_8
  flxdb(i, 1:icmin-1) = 0.0_8
  cllb0 = 0.0_8
  cllb0(icmin:k) = cllb0(icmin:k) + ddt*clwb(i, icmin:k)/daylen
  rmfdb = 0.0_8
  rmfdb(icmin:k) = rmfdb(icmin:k) + ddt*flxdb(i, icmin:k)/daylen
  qoi_svb = 0.0_8
  uoi_svb = 0.0_8
  qoib = 0.0_8
  voib = 0.0_8
  poib = 0.0_8
  poi_svb = 0.0_8
  uoib = 0.0_8
  voi_svb = 0.0_8
  DO l=k0,k,-1
    voib(k) = voib(k) + wght(l)*vhob(i, l)
    voi_svb(k) = voi_svb(k) - wght(l)*vhob(i, l)
    uoib(k) = uoib(k) + wght(l)*uhob(i, l)
    uoi_svb(k) = uoi_svb(k) - wght(l)*uhob(i, l)
    qoib(k) = qoib(k) + wght(l)*qhob(i, l)
    qoi_svb(k) = qoi_svb(k) - wght(l)*qhob(i, l)
    poib(k) = poib(k) + wght(l)*thob(i, l)
    poi_svb(k) = poi_svb(k) - wght(l)*thob(i, l)
  END DO
  updfrcb = 0.0_8
  updfrcb(icmin:k-1) = updfrcb(icmin:k-1) + cnv_updfrcb(i, icmin:k-1)
  voib(icmin:k-1) = voib(icmin:k-1) + vhob(i, icmin:k-1)
  vhob(i, icmin:k-1) = 0.0_8
  uoib(icmin:k-1) = uoib(icmin:k-1) + uhob(i, icmin:k-1)
  uhob(i, icmin:k-1) = 0.0_8
  qoib(icmin:k-1) = qoib(icmin:k-1) + qhob(i, icmin:k-1)
  qhob(i, icmin:k-1) = 0.0_8
  poib(icmin:k-1) = poib(icmin:k-1) + thob(i, icmin:k-1)
  thob(i, icmin:k-1) = 0.0_8
END SUBROUTINE STRAP1_B

!  Differentiation of dqsat_sub in reverse (adjoint) mode:
!   gradient     of useful results: temp dqsi qssi
!   with respect to varying inputs: temp dqsi qssi
SUBROUTINE DQSAT_SUB_B(dqsi, dqsib, qssi, qssib, temp, tempb, plo, im, &
&  jm, lm, estblx)
  IMPLICIT NONE
!Inputs
  INTEGER :: im, jm, lm
  REAL*8, DIMENSION(im, jm, lm) :: temp, plo
  REAL*8, DIMENSION(im, jm, lm) :: tempb
  REAL*8 :: estblx(:)
!Outputs
  REAL*8, DIMENSION(im, jm, lm) :: dqsi, qssi
  REAL*8, DIMENSION(im, jm, lm) :: dqsib, qssib
!Locals
  REAL*8, PARAMETER :: max_mixing_ratio=1.0
  REAL*8, PARAMETER :: cons_h2omw=18.01, cons_airmw=28.97
  REAL*8, PARAMETER :: esfac=cons_h2omw/cons_airmw
  INTEGER :: i, j, k
  REAL*8 :: tl, tt, ti, dqsat, qsat, dqq, qq, pl, pp, dd
  REAL*8 :: tlb, ttb, tib, dqsatb, qsatb, qqb, ddb
  INTEGER :: it
  INTEGER, PARAMETER :: degsubs=100
  REAL*8, PARAMETER :: tmintbl=150.0, tmaxtbl=333.0
  INTEGER, PARAMETER :: tablesize=NINT(tmaxtbl-tmintbl)*degsubs+1
  INTEGER :: branch
  REAL*8 :: temp0
  INTRINSIC NINT
  INTRINSIC INT
  DO k=1,lm
    DO j=1,jm
      DO i=1,im
        tl = temp(i, j, k)
        pl = plo(i, j, k)
        pp = pl*100.0
        IF (tl .LE. tmintbl) THEN
          ti = tmintbl
          CALL PUSHCONTROL2B(0)
        ELSE IF (tl .GE. tmaxtbl - .001) THEN
          ti = tmaxtbl - .001
          CALL PUSHCONTROL2B(1)
        ELSE
          ti = tl
          CALL PUSHCONTROL2B(2)
        END IF
        tt = (ti-tmintbl)*degsubs + 1
        it = INT(tt)
        CALL PUSHREAL8(dqq)
        dqq = estblx(it+1) - estblx(it)
        CALL PUSHREAL8(qq)
        qq = (tt-it)*dqq + estblx(it)
        IF (pp .LE. qq) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
      END DO
    END DO
  END DO
  DO k=lm,1,-1
    DO j=jm,1,-1
      DO i=im,1,-1
        qsatb = qssib(i, j, k)
        qssib(i, j, k) = 0.0_8
        dqsatb = dqsib(i, j, k)
        dqsib(i, j, k) = 0.0_8
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          qqb = 0.0_8
        ELSE
          pl = plo(i, j, k)
          pp = pl*100.0
          dd = 1.0/(pp-(1.0-esfac)*qq)
          ddb = esfac*qq*qsatb + esfac*degsubs*dqq*pp*2*dd*dqsatb
          temp0 = pp - (-esfac+1.0)*qq
          qqb = (1.0-esfac)*ddb/temp0**2 + esfac*dd*qsatb
        END IF
        CALL POPREAL8(qq)
        ttb = dqq*qqb
        CALL POPREAL8(dqq)
        tib = degsubs*ttb
        CALL POPCONTROL2B(branch)
        IF (branch .EQ. 0) THEN
          tlb = 0.0_8
        ELSE IF (branch .EQ. 1) THEN
          tlb = 0.0_8
        ELSE
          tlb = tib
        END IF
        tempb(i, j, k) = tempb(i, j, k) + tlb
      END DO
    END DO
  END DO
END SUBROUTINE DQSAT_SUB_B

END MODULE CONVECTION_AD
