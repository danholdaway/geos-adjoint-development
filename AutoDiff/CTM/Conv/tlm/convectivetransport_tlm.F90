!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
!-------------------------------------------------------------------------
!         NASA/GSFC, Software Systems Support Office, Code 610.3         !
!-------------------------------------------------------------------------
!BOP
!
! !MODULE: convectiveTransport_mod 
!
! !INTERFACE:
!
MODULE CONVECTIVETRANSPORT_MOD_D
  IMPLICIT NONE
!EOC
!------------------------------------------------------------------------------
  PRIVATE 
  PUBLIC convectivetransport
  PUBLIC convectivetransport_tlm

CONTAINS
!  Differentiation of convectivetransport in forward (tangent) mode:
!   variations   of useful results: qq
!   with respect to varying inputs: qq
!
! !DESCRIPTION:
! Module for the convective transport.
!
!EOP
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!BOP
!
! !IROUTINE: convectiveTransport
!
! !INTERFACE:
!
  SUBROUTINE CONVECTIVETRANSPORT_TLM(il2g, delt, xmbsth, ideep, pbli, &
&   dui, eui, mui, mdi, dpi, fracis, qq, qq_tl, isfixedconcentration, i1&
&   , i2, k1, k2, ilong, numspecies)
    IMPLICIT NONE
!
! !INPUT PARAMETERS
    LOGICAL, INTENT(IN) :: isfixedconcentration(:)
    INTEGER, INTENT(IN) :: i1, i2, k1, k2, ilong, numspecies
! gathered max lon indices over which to operate
    INTEGER, INTENT(IN) :: il2g
! convection time step (s)
    REAL*8, INTENT(IN) :: delt
! threshold below which we treat mass fluxes as zero (mb/s)
    REAL*8, INTENT(IN) :: xmbsth
! gathering array
    INTEGER, INTENT(IN) :: ideep(ilong)
! index of planetary boundary layer
    INTEGER, INTENT(IN) :: pbli(ilong)
! mass detraining from updraft
    REAL*8, INTENT(IN) :: dui(ilong, k1:k2)
! mass entraining into updraft
    REAL*8, INTENT(IN) :: eui(ilong, k1:k2)
! mass flux up
    REAL*8, INTENT(IN) :: mui(ilong, k1:k2)
! mass flux down
    REAL*8, INTENT(IN) :: mdi(ilong, k1:k2)
! delta pressure between interfaces
    REAL*8, INTENT(IN) :: dpi(ilong, k1:k2)
! insoluble fraction of tracer
    REAL*8, INTENT(IN) :: fracis(i1:i2, k1:k2, numspecies)
!
! !INPUT/OUTPUT PARAMETERS:
! tracer array including moisture (mixing ratio)
    REAL*8, INTENT(INOUT) :: qq(i1:i2, k1:k2, numspecies)
    REAL*8, INTENT(INOUT) :: qq_tl(i1:i2, k1:k2, numspecies)
!
! !DESCRIPTION:
! This routine performs convective transport of trace species.
! Note that we assume that the tracers are in a moist mixing ratio.
!
! !DEFINED PARAMETERS:
    REAL*8, PARAMETER :: small=1.0d-36
!
!EOP
!-----------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
    CHARACTER(len=75) :: err_msg
    INTEGER :: il, ik, ic
    INTEGER :: km1, kp1
! average mixing ratio in pbl
    REAL*8 :: avg_pbl
    REAL*8 :: avg_pbl_tl
! mix ratio of constituent above
    REAL*8 :: cabv
! mix ratio of constituent below
    REAL*8 :: cbel
! normalized diff. between cabv and cbel
    REAL*8 :: cdifr
! flux coming into  each box at a k level
    REAL*8 :: fluxin
    REAL*8 :: fluxin_tl
! flux going out of each box at a k level
    REAL*8 :: fluxout
    REAL*8 :: fluxout_tl
    REAL*8 :: maxc
    REAL*8 :: minc
! mixing ratio of a scavenged tracer
    REAL*8 :: scav
    REAL*8 :: scav_tl
    REAL*8 :: sqrt_fisg
!.sds - new temp variable for updraft concen calc
    REAL*8 :: temp_conu
    REAL*8 :: temp_conu_tl
! mix ratio in env.      at interfaces
    REAL*8 :: chat(il2g, k1:k2)
    REAL*8 :: chat_tl(il2g, k1:k2)
! mix ratio in updraft   at interfaces
    REAL*8 :: conu(il2g, k1:k2)
    REAL*8 :: conu_tl(il2g, k1:k2)
! mix ratio in downdraft at interfaces
    REAL*8 :: cond(il2g, k1:k2)
    REAL*8 :: cond_tl(il2g, k1:k2)
! gathered tend.  array
    REAL*8 :: dcondt(il2g, k1:k2)
    REAL*8 :: dcondt_tl(il2g, k1:k2)
! gathered downdraft entrainment
    REAL*8 :: edi(il2g, k1:k2)
! gathered insoluble frac. of tracer
    REAL*8 :: fisg(il2g, k1:k2)
! gathered tracer array
    REAL*8 :: xconst(il2g, k1:k2)
    REAL*8 :: xconst_tl(il2g, k1:k2)
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC SUM
    INTRINSIC SQRT
    INTRINSIC ABS
    REAL*8 :: min1
    REAL*8 :: min1_tl
    REAL*8 :: abs0
    REAL*8 :: min2
    REAL*8 :: min2_tl
    REAL*8 :: min3
    REAL*8 :: min3_tl
    REAL*8, DIMENSION((pbli(il)-k2)/(-1)+1) :: arg1
    REAL*8, DIMENSION((pbli(il)-k2)/(-1)+1) :: arg1_tl
    conu_tl = 0.0_8
    dcondt_tl = 0.0_8
    chat_tl = 0.0_8
    cond_tl = 0.0_8
    xconst_tl = 0.0_8
icloop:DO ic=1,numspecies
      IF (.NOT.isfixedconcentration(ic)) THEN
! ------------------------------------------------
! Gather up the constituent and set tend. to zero.
! ------------------------------------------------
        DO ik=k1,k2
          DO il=1,il2g
            fisg(il, ik) = fracis(ideep(il), ik, ic)
            xconst_tl(il, ik) = qq_tl(ideep(il), ik, ic)
            xconst(il, ik) = qq(ideep(il), ik, ic) !0.0
          END DO
        END DO
! -----------------------------------------
! From now on work only with gathered data.
! -----------------------------------------
! ----------------------------------------------------
! Interpolate environment tracer values to interfaces.
! ----------------------------------------------------
ikloop1:DO ik=k1,k2
          IF (k1 .LT. ik - 1) THEN
            km1 = ik - 1
          ELSE
            km1 = k1
          END IF
          IF (k2 .GT. ik + 1) THEN
            kp1 = ik + 1
          ELSE
            kp1 = k2
          END IF
          edi(:, ik) = mdi(:, ik) - mdi(:, kp1)
  illoop1:DO il=1,il2g
!minc = Min (xconst(il,km1), xconst(il,ik))
!maxc = Max (xconst(il,km1), xconst(il,ik))
!if (minc < 0.0d0) then
!cdifr = 0.0d0
!else
!cdifr = Abs (xconst(il,ik) - xconst(il,km1)) /  &
!        Max (maxc, SMALL)
!end if
!if (cdifr > 1.0d-6) then
!   ! -------------------------------------------------------
!   ! The two layers differ significantly, so use a geometric
!   ! averaging procedure.
!   ! -------------------------------------------------------
!   cabv = Max (xconst(il,km1), (maxc * 1.0d-12))
!   cbel = Max (xconst(il,ik),  (maxc * 1.0d-12))
!   chat(il,ik) = Log (cabv/cbel) / (cabv - cbel) * cabv * cbel
!else
! ---------------------------------------------------
! The two layers have only a small difference, so use
! arithmetic mean.
! ---------------------------------------------------
            chat_tl(il, ik) = 0.5d0*(xconst_tl(il, ik)+xconst_tl(il, km1))
            chat   (il, ik) = 0.5d0*(xconst   (il, ik)+xconst   (il, km1)) !0.0
!end if
! -------------------------------------
! Provisional up and down draft values.
! -------------------------------------
            conu_tl(il, ik) = chat_tl(il, ik)
            conu   (il, ik) = chat   (il, ik) !0.0
            cond_tl(il, ik) = chat_tl(il, km1)
            cond   (il, ik) = chat   (il, km1) !0.0
! ------------------
! Provisional tends.
! ------------------
            dcondt_tl(il, ik) = 0.0_8
            dcondt   (il, ik) = 0.0d0
          END DO illoop1
        END DO ikloop1
        WHERE (edi(:, :) .LT. 0.0d0) edi(:, :) = 0.0d0
illoop2:DO il=1,il2g
! ----------------------------------------------------------------------
! Find the mixing ratio in the downdraft, top of atmosphere down.
! NOTE: mass flux   in downdraft (mdi) will be zero or negative.
!       entrainment in downdraft (edi) will be zero or positive.
! ----------------------------------------------------------------------
 ikloopdd:DO ik=2,k2
            IF (mdi(il, ik-1) .LT. -xmbsth .OR. edi(il, ik) .GT. xmbsth&
&           ) THEN
              cond_tl(il, ik) = (mdi(il, ik-1)*cond_tl(il, ik-1)-edi(il, ik)*xconst_tl(il, ik))/(mdi(il, ik-1)-edi(il, ik))
              cond   (il, ik) = (cond   (il, ik-1)*mdi(il, ik-1)-xconst   (il, ik)*edi(il, ik))/(mdi(il, ik-1)-edi(il, ik)) !0.0
            END IF
          END DO ikloopdd
! ------------------------------------------------------
! Calculate updrafts with scavenging from bottom to top.
! Include the downdrafts.
! ------------------------------------------------------
! -------------------------------------
! Do the bottom most levels in the pbl.
! -------------------------------------
          IF (SUM(dpi(il, k2:pbli(il):-1)) .EQ. 0.0d0) THEN
            GOTO 100
          ELSE
            arg1_tl(:) = dpi(il, k2:pbli(il):-1)*xconst_tl(il, k2:pbli(il):-1)
            arg1   (:) = xconst   (il, k2:pbli(il):-1)*dpi(il, k2:pbli(il):-1) !0.0
            avg_pbl_tl = SUM(arg1_tl(:))/SUM(dpi(il, k2:pbli(il):-1))
            avg_pbl    = SUM(arg1   (:))/SUM(dpi(il, k2:pbli(il):-1)) !0.0
            sqrt_fisg = SQRT(fisg(il, pbli(il)))
            scav_tl = (1.0d0-sqrt_fisg)*avg_pbl_tl
            scav    = avg_pbl   *(1.0d0-sqrt_fisg) !0.0
            conu_tl(il, pbli(il)) = sqrt_fisg*avg_pbl_tl
            conu   (il, pbli(il)) = avg_pbl  *sqrt_fisg !0.0
            !IF (chat(il, pbli(il)) .GT. xconst(il, pbli(il)-1)) THEN
            !  min1_tl = xconst_tl(il, pbli(il)-1)
            !  min1    = xconst   (il, pbli(il)-1)
            !ELSE
              min1_tl = chat_tl(il, pbli(il))
              min1    = chat   (il, pbli(il))  !0.0
            !END IF
            fluxin_tl = (mui(il, pbli(il))+mdi(il, pbli(il)))*min1_tl - mdi(il, pbli(il))*cond_tl(il, pbli(il))
            fluxin    = (mui(il, pbli(il))+mdi(il, pbli(il)))*min1    - mdi(il, pbli(il))*cond   (il, pbli(il)) !0.0
            fluxout_tl = mui(il, pbli(il))*conu_tl(il, pbli(il)) + mui(il, pbli(il))*scav_tl
            fluxout    = mui(il, pbli(il))*conu   (il, pbli(il)) + mui(il, pbli(il))*scav !0.0
            dcondt_tl(il, k2) = (fluxin_tl-fluxout_tl)/SUM(dpi(il, k2:pbli(il):-1))
            dcondt   (il, k2) = (fluxin   -fluxout   )/SUM(dpi(il, k2:pbli(il):-1)) !0.0
            IF (avg_pbl .GT. 0.0d0) THEN
              DO ik=k2,pbli(il),-1
                qq_tl(ideep(il), ik, ic) = ((avg_pbl_tl+delt*dcondt_tl(il, k2))*avg_pbl-(avg_pbl+dcondt(il, k2)*delt)*avg_pbl_tl)*xconst(il, ik)/avg_pbl**2 + (avg_pbl+dcondt(il, k2)*delt)*xconst_tl(il, ik)/avg_pbl
                qq   (ideep(il), ik, ic) = (avg_pbl+dcondt(il, k2)*delt)/avg_pbl*xconst(il, ik)
              END DO
            END IF
! ---------------------------
! Loop over all other levels.
! ---------------------------
    ikloop2:DO ik=pbli(il)-1,2,-1
              kp1 = ik + 1
              km1 = ik - 1
! -----------------------------
! Find mixing ratio in updraft.
! -----------------------------
              IF (mui(il, kp1) - dui(il, ik) + eui(il, ik) .GT. xmbsth) &
&             THEN
                sqrt_fisg = SQRT(fisg(il, ik))
                IF (mui(il, kp1) + eui(il, ik) .GE. 0.) THEN
                  abs0 = mui(il, kp1) + eui(il, ik)
                ELSE
                  abs0 = -(mui(il, kp1)+eui(il, ik))
                END IF
                IF (abs0 .GE. xmbsth) THEN
!... mix updraft and entrainment, then detrain this concentration
                  temp_conu_tl = (mui(il, kp1)*conu_tl(il, kp1)+eui(il,ik)*xconst_tl(il, ik))/(mui(il, kp1)+eui(il, ik))
                  temp_conu    = (mui(il, kp1)*conu   (il, kp1)+eui(il,ik)*xconst   (il, ik))/(mui(il, kp1)+eui(il, ik))
!... if updraft and entrainment flux sum to 0.0, then take average concen
                ELSE
                  temp_conu_tl = (xconst_tl(il, ik)+conu_tl(il, kp1))/2.0d0
                  temp_conu    = (xconst   (il, ik)+conu   (il, kp1))/2.0d0
                END IF
!
                scav_tl = ((1.0d0-fisg(il, ik))*(mui(il, kp1)*conu_tl(il,kp1)-dui(il, ik)*temp_conu_tl) + eui(il, ik)*(1.0d0-sqrt_fisg)*xconst_tl(il, ik))/(mui(il, kp1)-dui(il, ik)+eui(il, ik))
                scav    = ((1.0d0-fisg(il, ik))*(mui(il, kp1)*conu_tl(il,kp1)-dui(il, ik)*temp_conu_tl) + eui(il, ik)*(1.0d0-sqrt_fisg)*xconst_tl(il, ik))/(mui(il, kp1)-dui(il, ik)+eui(il, ik))
                conu_tl(il, ik) = (fisg(il, ik)*(mui(il, kp1)*conu_tl(il, kp1)-dui(il, ik)*temp_conu_tl) + eui(il, ik)*sqrt_fisg*xconst_tl(il, ik))/(mui(il, kp1)-dui(il, ik)+eui(il, ik))
                conu   (il, ik) = ((mui(il, kp1)*conu   (il, kp1)-dui(il, ik)*temp_conu   )*fisg(il, ik) + eui(il, ik)*xconst   (il, ik)*sqrt_fisg)/(mui(il, kp1)-dui(il, ik)+eui(il, ik))
              ELSE
                conu_tl(il, ik) = xconst_tl(il, ik)
                conu   (il, ik) = xconst   (il, ik)
                scav    = 0.0d0
                scav_tl = 0.0_8
              END IF
              IF (chat(il, ik) .GT. xconst(il, km1)) THEN
                min2_tl = xconst_tl(il, km1)
                min2    = xconst   (il, km1)
              ELSE
                min2_tl = chat_tl(il, ik)
                min2    = chat   (il, ik)
              END IF
! -------------------------------------------------------
! Calculate fluxes into and out of box.  With scavenging
! included the net flux for the whole column is no longer
! guaranteed to be zero.
! Include the downdrafts.
! -------------------------------------------------------
              fluxin_tl = mui(il, kp1)*conu_tl(il, kp1) + (mui(il, ik)+mdi(il, ik))*min2_tl - mdi(il, ik)*cond_tl(il, ik)
              fluxin    = mui(il, kp1)*conu   (il, kp1) + (mui(il, ik)+mdi(il, ik))*min2    - mdi(il, ik)*cond   (il, ik)
              IF (chat(il, kp1) .GT. xconst(il, ik)) THEN
                min3_tl = xconst_tl(il, ik)
                min3    = xconst   (il, ik)
              ELSE
                min3_tl = chat_tl(il, kp1)
                min3    = chat   (il, kp1)
              END IF
              fluxout_tl = mui(il, ik)*conu_tl(il, ik) + (mui(il, kp1)+mdi(il, kp1))*min3_tl + (mui(il, ik)+mui(il, kp1))*0.5d0*scav_tl - mdi(il, kp1)*cond_tl(il, kp1)
              fluxout    = mui(il, ik)*conu   (il, ik) + (mui(il, kp1)+mdi(il, kp1))*min3    + (mui(il, ik)+mui(il, kp1))*0.5d0*scav    - mdi(il, kp1)*cond   (il, kp1)
              dcondt_tl(il, ik) = (fluxin_tl-fluxout_tl)/dpi(il, ik)
              dcondt   (il, ik) = (fluxin   -fluxout   )/dpi(il, ik)
! --------------------------------------------
! Update and scatter data back to full arrays.
! --------------------------------------------
              qq_tl(ideep(il), ik, ic) = xconst_tl(il, ik) + delt*dcondt_tl(il, ik)
              qq   (ideep(il), ik, ic) = xconst   (il, ik) + dcondt   (il, ik)*delt
            END DO ikloop2
          END IF
        END DO illoop2
      END IF
    END DO icloop
    RETURN
 100 err_msg = 'Problem in convectiveTransport.'
    PRINT*, err_msg
    STOP
  END SUBROUTINE CONVECTIVETRANSPORT_TLM
!
! !DESCRIPTION:
! Module for the convective transport.
!
!EOP
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!BOP
!
! !IROUTINE: convectiveTransport
!
! !INTERFACE:
!
  SUBROUTINE CONVECTIVETRANSPORT(il2g, delt, xmbsth, ideep, pbli, dui, &
&   eui, mui, mdi, dpi, fracis, qq, isfixedconcentration, i1, i2, k1, k2&
&   , ilong, numspecies)
    IMPLICIT NONE
!
! !INPUT PARAMETERS
    LOGICAL, INTENT(IN) :: isfixedconcentration(:)
    INTEGER, INTENT(IN) :: i1, i2, k1, k2, ilong, numspecies
! gathered max lon indices over which to operate
    INTEGER, INTENT(IN) :: il2g
! convection time step (s)
    REAL*8, INTENT(IN) :: delt
! threshold below which we treat mass fluxes as zero (mb/s)
    REAL*8, INTENT(IN) :: xmbsth
! gathering array
    INTEGER, INTENT(IN) :: ideep(ilong)
! index of planetary boundary layer
    INTEGER, INTENT(IN) :: pbli(ilong)
! mass detraining from updraft
    REAL*8, INTENT(IN) :: dui(ilong, k1:k2)
! mass entraining into updraft
    REAL*8, INTENT(IN) :: eui(ilong, k1:k2)
! mass flux up
    REAL*8, INTENT(IN) :: mui(ilong, k1:k2)
! mass flux down
    REAL*8, INTENT(IN) :: mdi(ilong, k1:k2)
! delta pressure between interfaces
    REAL*8, INTENT(IN) :: dpi(ilong, k1:k2)
! insoluble fraction of tracer
    REAL*8, INTENT(IN) :: fracis(i1:i2, k1:k2, numspecies)
!
! !INPUT/OUTPUT PARAMETERS:
! tracer array including moisture (mixing ratio)
    REAL*8, INTENT(INOUT) :: qq(i1:i2, k1:k2, numspecies)
!
! !DESCRIPTION:
! This routine performs convective transport of trace species.
! Note that we assume that the tracers are in a moist mixing ratio.
!
! !DEFINED PARAMETERS:
    REAL*8, PARAMETER :: small=1.0d-36
!
!EOP
!-----------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
    CHARACTER(len=75) :: err_msg
    INTEGER :: il, ik, ic
    INTEGER :: km1, kp1
! average mixing ratio in pbl
    REAL*8 :: avg_pbl
! mix ratio of constituent above
    REAL*8 :: cabv
! mix ratio of constituent below
    REAL*8 :: cbel
! normalized diff. between cabv and cbel
    REAL*8 :: cdifr
! flux coming into  each box at a k level
    REAL*8 :: fluxin
! flux going out of each box at a k level
    REAL*8 :: fluxout
    REAL*8 :: maxc
    REAL*8 :: minc
! mixing ratio of a scavenged tracer
    REAL*8 :: scav
    REAL*8 :: sqrt_fisg
!.sds - new temp variable for updraft concen calc
    REAL*8 :: temp_conu
! mix ratio in env.      at interfaces
    REAL*8 :: chat(il2g, k1:k2)
! mix ratio in updraft   at interfaces
    REAL*8 :: conu(il2g, k1:k2)
! mix ratio in downdraft at interfaces
    REAL*8 :: cond(il2g, k1:k2)
! gathered tend.  array
    REAL*8 :: dcondt(il2g, k1:k2)
! gathered downdraft entrainment
    REAL*8 :: edi(il2g, k1:k2)
! gathered insoluble frac. of tracer
    REAL*8 :: fisg(il2g, k1:k2)
! gathered tracer array
    REAL*8 :: xconst(il2g, k1:k2)
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC SUM
    INTRINSIC SQRT
    INTRINSIC ABS
    REAL*8 :: min1
    REAL*8 :: abs0
    REAL*8 :: min2
    REAL*8 :: min3
    REAL*8, DIMENSION((pbli(il)-k2)/(-1)+1) :: arg1
icloop:DO ic=1,numspecies
      IF (.NOT.isfixedconcentration(ic)) THEN
! ------------------------------------------------
! Gather up the constituent and set tend. to zero.
! ------------------------------------------------
        DO ik=k1,k2
          DO il=1,il2g
            fisg(il, ik) = fracis(ideep(il), ik, ic)
            xconst(il, ik) = qq(ideep(il), ik, ic)
          END DO
        END DO
! -----------------------------------------
! From now on work only with gathered data.
! -----------------------------------------
! ----------------------------------------------------
! Interpolate environment tracer values to interfaces.
! ----------------------------------------------------
ikloop1:DO ik=k1,k2
          IF (k1 .LT. ik - 1) THEN
            km1 = ik - 1
          ELSE
            km1 = k1
          END IF
          IF (k2 .GT. ik + 1) THEN
            kp1 = ik + 1
          ELSE
            kp1 = k2
          END IF
          edi(:, ik) = mdi(:, ik) - mdi(:, kp1)
  illoop1:DO il=1,il2g
!minc = Min (xconst(il,km1), xconst(il,ik))
!maxc = Max (xconst(il,km1), xconst(il,ik))
!if (minc < 0.0d0) then
!cdifr = 0.0d0
!else
!cdifr = Abs (xconst(il,ik) - xconst(il,km1)) /  &
!        Max (maxc, SMALL)
!end if
!if (cdifr > 1.0d-6) then
!   ! -------------------------------------------------------
!   ! The two layers differ significantly, so use a geometric
!   ! averaging procedure.
!   ! -------------------------------------------------------
!   cabv = Max (xconst(il,km1), (maxc * 1.0d-12))
!   cbel = Max (xconst(il,ik),  (maxc * 1.0d-12))
!   chat(il,ik) = Log (cabv/cbel) / (cabv - cbel) * cabv * cbel
!else
! ---------------------------------------------------
! The two layers have only a small difference, so use
! arithmetic mean.
! ---------------------------------------------------
            chat(il, ik) = 0.5d0*(xconst(il, ik)+xconst(il, km1))
!end if
! -------------------------------------
! Provisional up and down draft values.
! -------------------------------------
            conu(il, ik) = chat(il, ik)
            cond(il, ik) = chat(il, km1)
! ------------------
! Provisional tends.
! ------------------
            dcondt(il, ik) = 0.0d0
          END DO illoop1
        END DO ikloop1
        WHERE (edi(:, :) .LT. 0.0d0) edi(:, :) = 0.0d0
illoop2:DO il=1,il2g
! ----------------------------------------------------------------------
! Find the mixing ratio in the downdraft, top of atmosphere down.
! NOTE: mass flux   in downdraft (mdi) will be zero or negative.
!       entrainment in downdraft (edi) will be zero or positive.
! ----------------------------------------------------------------------
 ikloopdd:DO ik=2,k2
            IF (mdi(il, ik-1) .LT. -xmbsth .OR. edi(il, ik) .GT. xmbsth&
&           ) cond(il, ik) = (cond(il, ik-1)*mdi(il, ik-1)-xconst(il, ik&
&               )*edi(il, ik))/(mdi(il, ik-1)-edi(il, ik))
          END DO ikloopdd
! ------------------------------------------------------
! Calculate updrafts with scavenging from bottom to top.
! Include the downdrafts.
! ------------------------------------------------------
! -------------------------------------
! Do the bottom most levels in the pbl.
! -------------------------------------
          IF (SUM(dpi(il, k2:pbli(il):-1)) .EQ. 0.0d0) THEN
            err_msg = 'Problem in convectiveTransport.'
            PRINT*, err_msg
            STOP
          ELSE
            arg1(:) = xconst(il, k2:pbli(il):-1)*dpi(il, k2:pbli(il):-1)
            avg_pbl = SUM(arg1(:))/SUM(dpi(il, k2:pbli(il):-1))
            sqrt_fisg = SQRT(fisg(il, pbli(il)))
            scav = avg_pbl*(1.0d0-sqrt_fisg)
            conu(il, pbli(il)) = avg_pbl*sqrt_fisg
            IF (chat(il, pbli(il)) .GT. xconst(il, pbli(il)-1)) THEN
              min1 = xconst(il, pbli(il)-1)
            ELSE
              min1 = chat(il, pbli(il))
            END IF
            fluxin = (mui(il, pbli(il))+mdi(il, pbli(il)))*min1 - mdi(il&
&             , pbli(il))*cond(il, pbli(il))
            fluxout = mui(il, pbli(il))*conu(il, pbli(il)) + mui(il, &
&             pbli(il))*scav
            dcondt(il, k2) = (fluxin-fluxout)/SUM(dpi(il, k2:pbli(il):-1&
&             ))
            IF (avg_pbl .GT. 0.0d0) THEN
              DO ik=k2,pbli(il),-1
                qq(ideep(il), ik, ic) = (avg_pbl+dcondt(il, k2)*delt)/&
&                 avg_pbl*xconst(il, ik)
              END DO
            END IF
! ---------------------------
! Loop over all other levels.
! ---------------------------
    ikloop2:DO ik=pbli(il)-1,2,-1
              kp1 = ik + 1
              km1 = ik - 1
! -----------------------------
! Find mixing ratio in updraft.
! -----------------------------
              IF (mui(il, kp1) - dui(il, ik) + eui(il, ik) .GT. xmbsth) &
&             THEN
                sqrt_fisg = SQRT(fisg(il, ik))
                IF (mui(il, kp1) + eui(il, ik) .GE. 0.) THEN
                  abs0 = mui(il, kp1) + eui(il, ik)
                ELSE
                  abs0 = -(mui(il, kp1)+eui(il, ik))
                END IF
                IF (abs0 .GE. xmbsth) THEN
!... mix updraft and entrainment, then detrain this concentration
                  temp_conu = (mui(il, kp1)*conu(il, kp1)+eui(il, ik)*&
&                   xconst(il, ik))/(mui(il, kp1)+eui(il, ik))
!... if updraft and entrainment flux sum to 0.0, then take average concen
                ELSE
                  temp_conu = (xconst(il, ik)+conu(il, kp1))/2.0d0
                END IF
!
                scav = ((mui(il, kp1)*conu(il, kp1)-dui(il, ik)*&
&                 temp_conu)*(1.0d0-fisg(il, ik))+eui(il, ik)*xconst(il&
&                 , ik)*(1.0d0-sqrt_fisg))/(mui(il, kp1)-dui(il, ik)+eui&
&                 (il, ik))
                conu(il, ik) = ((mui(il, kp1)*conu(il, kp1)-dui(il, ik)*&
&                 temp_conu)*fisg(il, ik)+eui(il, ik)*xconst(il, ik)*&
&                 sqrt_fisg)/(mui(il, kp1)-dui(il, ik)+eui(il, ik))
              ELSE
                conu(il, ik) = xconst(il, ik)
                scav = 0.0d0
              END IF
              IF (chat(il, ik) .GT. xconst(il, km1)) THEN
                min2 = xconst(il, km1)
              ELSE
                min2 = chat(il, ik)
              END IF
! -------------------------------------------------------
! Calculate fluxes into and out of box.  With scavenging
! included the net flux for the whole column is no longer
! guaranteed to be zero.
! Include the downdrafts.
! -------------------------------------------------------
              fluxin = mui(il, kp1)*conu(il, kp1) + (mui(il, ik)+mdi(il&
&               , ik))*min2 - mdi(il, ik)*cond(il, ik)
              IF (chat(il, kp1) .GT. xconst(il, ik)) THEN
                min3 = xconst(il, ik)
              ELSE
                min3 = chat(il, kp1)
              END IF
              fluxout = mui(il, ik)*conu(il, ik) + (mui(il, kp1)+mdi(il&
&               , kp1))*min3 + (mui(il, ik)+mui(il, kp1))*0.5d0*scav - &
&               mdi(il, kp1)*cond(il, kp1)
              dcondt(il, ik) = (fluxin-fluxout)/dpi(il, ik)
! --------------------------------------------
! Update and scatter data back to full arrays.
! --------------------------------------------
              qq(ideep(il), ik, ic) = xconst(il, ik) + dcondt(il, ik)*&
&               delt
            END DO ikloop2
          END IF
        END DO illoop2
      END IF
    END DO icloop
    RETURN
  END SUBROUTINE CONVECTIVETRANSPORT
END MODULE CONVECTIVETRANSPORT_MOD_D
