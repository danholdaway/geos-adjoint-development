!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
!-------------------------------------------------------------------------
!         NASA/GSFC, Software Systems Support Office, Code 610.3         !
!-------------------------------------------------------------------------
!BOP
!
! !MODULE: convectiveTransport_mod 
!
! !INTERFACE:
!
MODULE CONVECTIVETRANSPORT_MOD_B
  IMPLICIT NONE
!EOC
!------------------------------------------------------------------------------
  PRIVATE 
  PUBLIC convectivetransport
  PUBLIC convectivetransport_adm

CONTAINS
!  Differentiation of convectivetransport in reverse (adjoint) mode:
!   gradient     of useful results: qq
!   with respect to varying inputs: qq
!
! !DESCRIPTION:
! Module for the convective transport.
!
!EOP
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!BOP
!
! !IROUTINE: convectiveTransport
!
! !INTERFACE:
!
  SUBROUTINE CONVECTIVETRANSPORT_ADM(il2g, delt, xmbsth, ideep, pbli, &
&   dui, eui, mui, mdi, dpi, fracis, qq, qq_ad, isfixedconcentration, i1&
&   , i2, k1, k2, ilong, numspecies)
    IMPLICIT NONE
!
! !INPUT PARAMETERS
    LOGICAL, INTENT(IN) :: isfixedconcentration(:)
    INTEGER, INTENT(IN) :: i1, i2, k1, k2, ilong, numspecies
! gathered max lon indices over which to operate
    INTEGER, INTENT(IN) :: il2g
! convection time step (s)
    REAL*8, INTENT(IN) :: delt
! threshold below which we treat mass fluxes as zero (mb/s)
    REAL*8, INTENT(IN) :: xmbsth
! gathering array
    INTEGER, INTENT(IN) :: ideep(ilong)
! index of planetary boundary layer
    INTEGER, INTENT(IN) :: pbli(ilong)
! mass detraining from updraft
    REAL*8, INTENT(IN) :: dui(ilong, k1:k2)
! mass entraining into updraft
    REAL*8, INTENT(IN) :: eui(ilong, k1:k2)
! mass flux up
    REAL*8, INTENT(IN) :: mui(ilong, k1:k2)
! mass flux down
    REAL*8, INTENT(IN) :: mdi(ilong, k1:k2)
! delta pressure between interfaces
    REAL*8, INTENT(IN) :: dpi(ilong, k1:k2)
! insoluble fraction of tracer
    REAL*8, INTENT(IN) :: fracis(i1:i2, k1:k2, numspecies)
!
! !INPUT/OUTPUT PARAMETERS:
! tracer array including moisture (mixing ratio)
    REAL*8, INTENT(INOUT) :: qq(i1:i2, k1:k2, numspecies)
    REAL*8, INTENT(INOUT) :: qq_ad(i1:i2, k1:k2, numspecies)
!
! !DESCRIPTION:
! This routine performs convective transport of trace species.
! Note that we assume that the tracers are in a moist mixing ratio.
!
! !DEFINED PARAMETERS:
    REAL*8, PARAMETER :: small=1.0d-36
!
!EOP
!-----------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
    CHARACTER(len=75) :: err_msg
    INTEGER :: il, ik, ic
    INTEGER :: km1, kp1
! average mixing ratio in pbl
    REAL*8 :: avg_pbl
    REAL*8 :: avg_pbl_ad
! mix ratio of constituent above
    REAL*8 :: cabv
! mix ratio of constituent below
    REAL*8 :: cbel
! normalized diff. between cabv and cbel
    REAL*8 :: cdifr
! flux coming into  each box at a k level
    REAL*8 :: fluxin
    REAL*8 :: fluxin_ad
! flux going out of each box at a k level
    REAL*8 :: fluxout
    REAL*8 :: fluxout_ad
    REAL*8 :: maxc
    REAL*8 :: minc
! mixing ratio of a scavenged tracer
    REAL*8 :: scav
    REAL*8 :: scav_ad
    REAL*8 :: sqrt_fisg
!.sds - new temp variable for updraft concen calc
    REAL*8 :: temp_conu
    REAL*8 :: temp_conu_ad
! mix ratio in env.      at interfaces
    REAL*8 :: chat(il2g, k1:k2)
    REAL*8 :: chat_ad(il2g, k1:k2)
! mix ratio in updraft   at interfaces
    REAL*8 :: conu(il2g, k1:k2)
    REAL*8 :: conu_ad(il2g, k1:k2)
! mix ratio in downdraft at interfaces
    REAL*8 :: cond(il2g, k1:k2)
    REAL*8 :: cond_ad(il2g, k1:k2)
! gathered tend.  array
    REAL*8 :: dcondt(il2g, k1:k2)
    REAL*8 :: dcondt_ad(il2g, k1:k2)
! gathered downdraft entrainment
    REAL*8 :: edi(il2g, k1:k2)
! gathered insoluble frac. of tracer
    REAL*8 :: fisg(il2g, k1:k2)
! gathered tracer array
    REAL*8 :: xconst(il2g, k1:k2)
    REAL*8 :: xconst_ad(il2g, k1:k2)
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC SUM
    INTRINSIC SQRT
    INTRINSIC ABS
    REAL*8 :: min1
    REAL*8 :: min1_ad
    REAL*8 :: abs0
    REAL*8 :: min2
    REAL*8 :: min2_ad
    REAL*8 :: min3
    REAL*8 :: min3_ad
    LOGICAL, DIMENSION(il2g, k2-k1+1) :: mask
    REAL*8 :: result1
    REAL*8 :: result1_ad
    REAL*8 :: temp_ad
    REAL*8 :: temp_ad0
    REAL*8 :: temp
    REAL*8 :: temp_ad1
    REAL*8 :: temp_ad2
    REAL*8 :: tmp
    REAL*8 :: tmp_ad
    REAL*8 :: temp_ad3
    REAL*8 :: temp_ad4
    REAL*8 :: temp_ad5
    REAL*8 :: temp_ad6
    REAL*8 :: temp_ad7
    INTEGER :: ad_to
    INTEGER :: ad_from
    INTEGER :: ad_to0
    INTEGER :: ad_to1
    INTEGER :: branch
    INTEGER :: ad_from0
    INTEGER :: ad_to2
    INTEGER :: ad_to3
    INTEGER :: ad_from1
    INTEGER :: ad_to4
    INTEGER :: ad_from2
    INTEGER :: ad_count
    INTEGER :: i
    CALL PUSHINTEGER4(ic)
    CALL PUSHCONTROL2B(0)
icloop:DO ic=1,numspecies
      IF (isfixedconcentration(ic)) THEN
        CALL PUSHINTEGER4(ic)
        CALL PUSHCONTROL2B(2)
      ELSE
        ad_from = k1
! ------------------------------------------------
! Gather up the constituent and set tend. to zero.
! ------------------------------------------------
        DO ik=ad_from,k2
          DO il=1,il2g
            CALL PUSHREAL8(fisg(il, ik))
            fisg(il, ik) = fracis(ideep(il), ik, ic)
            CALL PUSHREAL8(xconst(il, ik))
            xconst(il, ik) = qq(ideep(il), ik, ic)
          END DO
          CALL PUSHINTEGER4(il - 1)
        END DO
        CALL PUSHINTEGER4(ik - 1)
        CALL PUSHINTEGER4(ad_from)
        ad_from0 = k1
! -----------------------------------------
! From now on work only with gathered data.
! -----------------------------------------
! ----------------------------------------------------
! Interpolate environment tracer values to interfaces.
! ----------------------------------------------------
ikloop1:DO ik=ad_from0,k2
          IF (k1 .LT. ik - 1) THEN
            CALL PUSHINTEGER4(km1)
            km1 = ik - 1
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHINTEGER4(km1)
            km1 = k1
            CALL PUSHCONTROL1B(1)
          END IF
          IF (k2 .GT. ik + 1) THEN
            kp1 = ik + 1
          ELSE
            kp1 = k2
          END IF
          CALL PUSHREAL8ARRAY(edi(:, ik), il2g)
          edi(:, ik) = mdi(:, ik) - mdi(:, kp1)
  illoop1:DO il=1,il2g
!minc = Min (xconst(il,km1), xconst(il,ik))
!maxc = Max (xconst(il,km1), xconst(il,ik))
!if (minc < 0.0d0) then
!cdifr = 0.0d0
!else
!cdifr = Abs (xconst(il,ik) - xconst(il,km1)) /  &
!        Max (maxc, SMALL)
!end if
!if (cdifr > 1.0d-6) then
!   ! -------------------------------------------------------
!   ! The two layers differ significantly, so use a geometric
!   ! averaging procedure.
!   ! -------------------------------------------------------
!   cabv = Max (xconst(il,km1), (maxc * 1.0d-12))
!   cbel = Max (xconst(il,ik),  (maxc * 1.0d-12))
!   chat(il,ik) = Log (cabv/cbel) / (cabv - cbel) * cabv * cbel
!else
! ---------------------------------------------------
! The two layers have only a small difference, so use
! arithmetic mean.
! ---------------------------------------------------
            chat(il, ik) = 0.5d0*(xconst(il, ik)+xconst(il, km1))
!end if
! -------------------------------------
! Provisional up and down draft values.
! -------------------------------------
            conu(il, ik) = chat(il, ik)
            cond(il, ik) = chat(il, km1)
! ------------------
! Provisional tends.
! ------------------
            CALL PUSHREAL8(dcondt(il, ik))
            dcondt(il, ik) = 0.0d0
          END DO illoop1
          CALL PUSHINTEGER4(il - 1)
        END DO ikloop1
        CALL PUSHINTEGER4(ik - 1)
        CALL PUSHINTEGER4(ad_from0)
        CALL PUSHBOOLEANARRAY(mask, il2g*(k2-k1+1))
        mask(:, :) = edi(:, :) .LT. 0.0d0
        CALL PUSHREAL8ARRAY(edi, il2g*(k2-k1+1))
        WHERE (mask(:, :)) edi(:, :) = 0.0d0
        CALL PUSHINTEGER4(il)
        ad_count = 1
illoop2:DO il=1,il2g
! ----------------------------------------------------------------------
! Find the mixing ratio in the downdraft, top of atmosphere down.
! NOTE: mass flux   in downdraft (mdi) will be zero or negative.
!       entrainment in downdraft (edi) will be zero or positive.
! ----------------------------------------------------------------------
 ikloopdd:DO ik=2,k2
            IF (mdi(il, ik-1) .LT. -xmbsth .OR. edi(il, ik) .GT. xmbsth&
&           ) THEN
              cond(il, ik) = (cond(il, ik-1)*mdi(il, ik-1)-xconst(il, ik&
&               )*edi(il, ik))/(mdi(il, ik-1)-edi(il, ik))
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
          END DO ikloopdd
          CALL PUSHINTEGER4(ik - 1)
! ------------------------------------------------------
! Calculate updrafts with scavenging from bottom to top.
! Include the downdrafts.
! ------------------------------------------------------
! -------------------------------------
! Do the bottom most levels in the pbl.
! -------------------------------------
          IF (SUM(dpi(il, k2:pbli(il):-1)) .EQ. 0.0d0) THEN
            GOTO 120
          ELSE
            result1 = SUM(xconst(il, k2:pbli(il):-1)*dpi(il, k2:pbli(il)&
&             :-1))
            CALL PUSHREAL8(avg_pbl)
            avg_pbl = result1/SUM(dpi(il, k2:pbli(il):-1))
            CALL PUSHREAL8(sqrt_fisg)
            sqrt_fisg = SQRT(fisg(il, pbli(il)))
            scav = avg_pbl*(1.0d0-sqrt_fisg)
            conu(il, pbli(il)) = avg_pbl*sqrt_fisg
            IF (chat(il, pbli(il)) .GT. xconst(il, pbli(il)-1)) THEN
              min1 = xconst(il, pbli(il)-1)
              CALL PUSHCONTROL1B(0)
            ELSE
              min1 = chat(il, pbli(il))
              CALL PUSHCONTROL1B(1)
            END IF
            fluxin = (mui(il, pbli(il))+mdi(il, pbli(il)))*min1 - mdi(il&
&             , pbli(il))*cond(il, pbli(il))
            fluxout = mui(il, pbli(il))*conu(il, pbli(il)) + mui(il, &
&             pbli(il))*scav
            CALL PUSHREAL8(dcondt(il, k2))
            dcondt(il, k2) = (fluxin-fluxout)/SUM(dpi(il, k2:pbli(il):-1&
&             ))
            IF (avg_pbl .GT. 0.0d0) THEN
              ad_from1 = k2
              DO ik=ad_from1,pbli(il),-1
                qq(ideep(il), ik, ic) = (avg_pbl+dcondt(il, k2)*delt)/&
&                 avg_pbl*xconst(il, ik)
              END DO
              CALL PUSHINTEGER4(ik + 1)
              CALL PUSHINTEGER4(ad_from1)
              CALL PUSHCONTROL1B(1)
            ELSE
              CALL PUSHCONTROL1B(0)
            END IF
            ad_from2 = pbli(il) - 1
! ---------------------------
! Loop over all other levels.
! ---------------------------
    ikloop2:DO ik=ad_from2,2,-1
              kp1 = ik + 1
              CALL PUSHINTEGER4(km1)
              km1 = ik - 1
! -----------------------------
! Find mixing ratio in updraft.
! -----------------------------
              IF (mui(il, kp1) - dui(il, ik) + eui(il, ik) .GT. xmbsth) &
&             THEN
                CALL PUSHREAL8(sqrt_fisg)
                sqrt_fisg = SQRT(fisg(il, ik))
                IF (mui(il, kp1) + eui(il, ik) .GE. 0.) THEN
                  abs0 = mui(il, kp1) + eui(il, ik)
                ELSE
                  abs0 = -(mui(il, kp1)+eui(il, ik))
                END IF
                IF (abs0 .GE. xmbsth) THEN
!... mix updraft and entrainment, then detrain this concentration
                  temp_conu = (mui(il, kp1)*conu(il, kp1)+eui(il, ik)*&
&                   xconst(il, ik))/(mui(il, kp1)+eui(il, ik))
!... if updraft and entrainment flux sum to 0.0, then take average concen
                  CALL PUSHCONTROL1B(0)
                ELSE
                  temp_conu = (xconst(il, ik)+conu(il, kp1))/2.0d0
                  CALL PUSHCONTROL1B(1)
                END IF
!
                scav = ((mui(il, kp1)*conu(il, kp1)-dui(il, ik)*&
&                 temp_conu)*(1.0d0-fisg(il, ik))+eui(il, ik)*xconst(il&
&                 , ik)*(1.0d0-sqrt_fisg))/(mui(il, kp1)-dui(il, ik)+eui&
&                 (il, ik))
                tmp = ((mui(il, kp1)*conu(il, kp1)-dui(il, ik)*temp_conu&
&                 )*fisg(il, ik)+eui(il, ik)*xconst(il, ik)*sqrt_fisg)/(&
&                 mui(il, kp1)-dui(il, ik)+eui(il, ik))
                conu(il, ik) = tmp
                CALL PUSHCONTROL1B(1)
              ELSE
                conu(il, ik) = xconst(il, ik)
                scav = 0.0d0
                CALL PUSHCONTROL1B(0)
              END IF
              IF (chat(il, ik) .GT. xconst(il, km1)) THEN
                min2 = xconst(il, km1)
                CALL PUSHCONTROL1B(0)
              ELSE
                min2 = chat(il, ik)
                CALL PUSHCONTROL1B(1)
              END IF
! -------------------------------------------------------
! Calculate fluxes into and out of box.  With scavenging
! included the net flux for the whole column is no longer
! guaranteed to be zero.
! Include the downdrafts.
! -------------------------------------------------------
              fluxin = mui(il, kp1)*conu(il, kp1) + (mui(il, ik)+mdi(il&
&               , ik))*min2 - mdi(il, ik)*cond(il, ik)
              IF (chat(il, kp1) .GT. xconst(il, ik)) THEN
                min3 = xconst(il, ik)
                CALL PUSHCONTROL1B(0)
              ELSE
                min3 = chat(il, kp1)
                CALL PUSHCONTROL1B(1)
              END IF
              fluxout = mui(il, ik)*conu(il, ik) + (mui(il, kp1)+mdi(il&
&               , kp1))*min3 + (mui(il, ik)+mui(il, kp1))*0.5d0*scav - &
&               mdi(il, kp1)*cond(il, kp1)
              CALL PUSHREAL8(dcondt(il, ik))
              dcondt(il, ik) = (fluxin-fluxout)/dpi(il, ik)
! --------------------------------------------
! Update and scatter data back to full arrays.
! --------------------------------------------
              qq(ideep(il), ik, ic) = xconst(il, ik) + dcondt(il, ik)*&
&               delt
            END DO ikloop2
            CALL PUSHINTEGER4(ad_from2)
            CALL PUSHINTEGER4(il)
            ad_count = ad_count + 1
          END IF
        END DO illoop2
        CALL PUSHCONTROL1B(0)
        CALL PUSHINTEGER4(ad_count)
        CALL PUSHINTEGER4(ic)
        CALL PUSHCONTROL2B(1)
      END IF
    END DO icloop
    conu_ad = 0.0_8
    dcondt_ad = 0.0_8
    chat_ad = 0.0_8
    cond_ad = 0.0_8
    xconst_ad = 0.0_8
 100 CALL POPCONTROL2B(branch)
    IF (branch .NE. 0) THEN
      IF (branch .EQ. 1) THEN
        CALL POPINTEGER4(ic)
        CALL POPINTEGER4(ad_count)
        DO i=1,ad_count
          IF (i .EQ. 1) THEN
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              GOTO 110
            ELSE
              qq_ad = 0.0_8
              conu_ad = 0.0_8
              dcondt_ad = 0.0_8
              chat_ad = 0.0_8
              cond_ad = 0.0_8
              xconst_ad = 0.0_8
            END IF
          ELSE
            CALL POPINTEGER4(ad_from2)
            DO ik=2,ad_from2,1
              xconst_ad(il, ik) = xconst_ad(il, ik) + qq_ad(ideep(il), &
&               ik, ic)
              dcondt_ad(il, ik) = dcondt_ad(il, ik) + delt*qq_ad(ideep(&
&               il), ik, ic)
              qq_ad(ideep(il), ik, ic) = 0.0_8
              CALL POPREAL8(dcondt(il, ik))
              temp_ad7 = dcondt_ad(il, ik)/dpi(il, ik)
              fluxin_ad = temp_ad7
              fluxout_ad = -temp_ad7
              dcondt_ad(il, ik) = 0.0_8
              kp1 = ik + 1
              conu_ad(il, ik) = conu_ad(il, ik) + mui(il, ik)*fluxout_ad
              min3_ad = (mui(il, kp1)+mdi(il, kp1))*fluxout_ad
              scav_ad = (mui(il, ik)+mui(il, kp1))*0.5d0*fluxout_ad
              cond_ad(il, kp1) = cond_ad(il, kp1) - mdi(il, kp1)*&
&               fluxout_ad
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                xconst_ad(il, ik) = xconst_ad(il, ik) + min3_ad
              ELSE
                chat_ad(il, kp1) = chat_ad(il, kp1) + min3_ad
              END IF
              conu_ad(il, kp1) = conu_ad(il, kp1) + mui(il, kp1)*&
&               fluxin_ad
              min2_ad = (mui(il, ik)+mdi(il, ik))*fluxin_ad
              cond_ad(il, ik) = cond_ad(il, ik) - mdi(il, ik)*fluxin_ad
              km1 = ik - 1
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                xconst_ad(il, km1) = xconst_ad(il, km1) + min2_ad
              ELSE
                chat_ad(il, ik) = chat_ad(il, ik) + min2_ad
              END IF
              CALL POPCONTROL1B(branch)
              IF (branch .EQ. 0) THEN
                xconst_ad(il, ik) = xconst_ad(il, ik) + conu_ad(il, ik)
                conu_ad(il, ik) = 0.0_8
              ELSE
                temp_ad6 = scav_ad/(mui(il, kp1)-dui(il, ik)+eui(il, ik)&
&                 )
                temp_ad5 = (1.0d0-fisg(il, ik))*temp_ad6
                tmp_ad = conu_ad(il, ik)
                conu_ad(il, ik) = 0.0_8
                temp_ad3 = tmp_ad/(mui(il, kp1)-dui(il, ik)+eui(il, ik))
                temp_ad4 = fisg(il, ik)*temp_ad3
                conu_ad(il, kp1) = conu_ad(il, kp1) + mui(il, kp1)*&
&                 temp_ad5 + mui(il, kp1)*temp_ad4
                temp_conu_ad = -(dui(il, ik)*temp_ad5) - dui(il, ik)*&
&                 temp_ad4
                xconst_ad(il, ik) = xconst_ad(il, ik) + eui(il, ik)*(&
&                 1.0d0-sqrt_fisg)*temp_ad6 + eui(il, ik)*sqrt_fisg*&
&                 temp_ad3
                CALL POPCONTROL1B(branch)
                IF (branch .EQ. 0) THEN
                  temp_ad2 = temp_conu_ad/(mui(il, kp1)+eui(il, ik))
                  conu_ad(il, kp1) = conu_ad(il, kp1) + mui(il, kp1)*&
&                   temp_ad2
                  xconst_ad(il, ik) = xconst_ad(il, ik) + eui(il, ik)*&
&                   temp_ad2
                ELSE
                  xconst_ad(il, ik) = xconst_ad(il, ik) + temp_conu_ad/&
&                   2.0d0
                  conu_ad(il, kp1) = conu_ad(il, kp1) + temp_conu_ad/&
&                   2.0d0
                END IF
                CALL POPREAL8(sqrt_fisg)
              END IF
              CALL POPINTEGER4(km1)
            END DO
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              avg_pbl_ad = 0.0_8
            ELSE
              avg_pbl_ad = 0.0_8
              CALL POPINTEGER4(ad_from1)
              CALL POPINTEGER4(ad_to4)
              DO ik=ad_to4,ad_from1,1
                temp = xconst(il, ik)/avg_pbl
                temp_ad1 = (avg_pbl+delt*dcondt(il, k2))*qq_ad(ideep(il)&
&                 , ik, ic)/avg_pbl
                avg_pbl_ad = avg_pbl_ad + temp*qq_ad(ideep(il), ik, ic) &
&                 - temp*temp_ad1
                dcondt_ad(il, k2) = dcondt_ad(il, k2) + temp*delt*qq_ad(&
&                 ideep(il), ik, ic)
                xconst_ad(il, ik) = xconst_ad(il, ik) + temp_ad1
                qq_ad(ideep(il), ik, ic) = 0.0_8
              END DO
            END IF
            CALL POPREAL8(dcondt(il, k2))
            temp_ad0 = dcondt_ad(il, k2)/SUM(dpi(il, k2:pbli(il):-1))
            fluxin_ad = temp_ad0
            fluxout_ad = -temp_ad0
            dcondt_ad(il, k2) = 0.0_8
            conu_ad(il, pbli(il)) = conu_ad(il, pbli(il)) + mui(il, pbli&
&             (il))*fluxout_ad
            scav_ad = mui(il, pbli(il))*fluxout_ad
            min1_ad = (mui(il, pbli(il))+mdi(il, pbli(il)))*fluxin_ad
            cond_ad(il, pbli(il)) = cond_ad(il, pbli(il)) - mdi(il, pbli&
&             (il))*fluxin_ad
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              xconst_ad(il, pbli(il)-1) = xconst_ad(il, pbli(il)-1) + &
&               min1_ad
            ELSE
              chat_ad(il, pbli(il)) = chat_ad(il, pbli(il)) + min1_ad
            END IF
            avg_pbl_ad = avg_pbl_ad + (1.0d0-sqrt_fisg)*scav_ad + &
&             sqrt_fisg*conu_ad(il, pbli(il))
            conu_ad(il, pbli(il)) = 0.0_8
            CALL POPREAL8(sqrt_fisg)
            CALL POPREAL8(avg_pbl)
            result1_ad = avg_pbl_ad/SUM(dpi(il, k2:pbli(il):-1))
            xconst_ad(il, k2:pbli(il):-1) = xconst_ad(il, k2:pbli(il):-1&
&             ) + dpi(il, k2:pbli(il):-1)*result1_ad
          END IF
          CALL POPINTEGER4(ad_to3)
          DO ik=ad_to3,2,-1
            CALL POPCONTROL1B(branch)
            IF (branch .NE. 0) THEN
              temp_ad = cond_ad(il, ik)/(mdi(il, ik-1)-edi(il, ik))
              cond_ad(il, ik-1) = cond_ad(il, ik-1) + mdi(il, ik-1)*&
&               temp_ad
              xconst_ad(il, ik) = xconst_ad(il, ik) - edi(il, ik)*&
&               temp_ad
              cond_ad(il, ik) = 0.0_8
            END IF
          END DO
 110      CALL POPINTEGER4(il)
        END DO
        CALL POPREAL8ARRAY(edi, il2g*(k2-k1+1))
        CALL POPBOOLEANARRAY(mask, il2g*(k2-k1+1))
        CALL POPINTEGER4(ad_from0)
        CALL POPINTEGER4(ad_to2)
        DO ik=ad_to2,ad_from0,-1
          CALL POPINTEGER4(ad_to1)
          DO il=ad_to1,1,-1
            CALL POPREAL8(dcondt(il, ik))
            dcondt_ad(il, ik) = 0.0_8
            chat_ad(il, km1) = chat_ad(il, km1) + cond_ad(il, ik)
            cond_ad(il, ik) = 0.0_8
            chat_ad(il, ik) = chat_ad(il, ik) + conu_ad(il, ik)
            conu_ad(il, ik) = 0.0_8
            xconst_ad(il, ik) = xconst_ad(il, ik) + 0.5d0*chat_ad(il, ik&
&             )
            xconst_ad(il, km1) = xconst_ad(il, km1) + 0.5d0*chat_ad(il, &
&             ik)
            chat_ad(il, ik) = 0.0_8
          END DO
          CALL POPREAL8ARRAY(edi(:, ik), il2g)
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            CALL POPINTEGER4(km1)
          ELSE
            CALL POPINTEGER4(km1)
          END IF
        END DO
        CALL POPINTEGER4(ad_from)
        CALL POPINTEGER4(ad_to0)
        DO ik=ad_to0,ad_from,-1
          CALL POPINTEGER4(ad_to)
          DO il=ad_to,1,-1
            CALL POPREAL8(xconst(il, ik))
            qq_ad(ideep(il), ik, ic) = qq_ad(ideep(il), ik, ic) + &
&             xconst_ad(il, ik)
            xconst_ad(il, ik) = 0.0_8
            CALL POPREAL8(fisg(il, ik))
          END DO
        END DO
      ELSE
        CALL POPINTEGER4(ic)
      END IF
      GOTO 100
    END IF
    CALL POPINTEGER4(ic)
    GOTO 130
 120 CALL PUSHCONTROL1B(1)
    CALL PUSHINTEGER4(ad_count)
    STOP
 130 CONTINUE
  END SUBROUTINE CONVECTIVETRANSPORT_ADM
!
! !DESCRIPTION:
! Module for the convective transport.
!
!EOP
!-----------------------------------------------------------------------------
!-----------------------------------------------------------------------------
!BOP
!
! !IROUTINE: convectiveTransport
!
! !INTERFACE:
!
  SUBROUTINE CONVECTIVETRANSPORT(il2g, delt, xmbsth, ideep, pbli, dui, &
&   eui, mui, mdi, dpi, fracis, qq, isfixedconcentration, i1, i2, k1, k2&
&   , ilong, numspecies)
    IMPLICIT NONE
!
! !INPUT PARAMETERS
    LOGICAL, INTENT(IN) :: isfixedconcentration(:)
    INTEGER, INTENT(IN) :: i1, i2, k1, k2, ilong, numspecies
! gathered max lon indices over which to operate
    INTEGER, INTENT(IN) :: il2g
! convection time step (s)
    REAL*8, INTENT(IN) :: delt
! threshold below which we treat mass fluxes as zero (mb/s)
    REAL*8, INTENT(IN) :: xmbsth
! gathering array
    INTEGER, INTENT(IN) :: ideep(ilong)
! index of planetary boundary layer
    INTEGER, INTENT(IN) :: pbli(ilong)
! mass detraining from updraft
    REAL*8, INTENT(IN) :: dui(ilong, k1:k2)
! mass entraining into updraft
    REAL*8, INTENT(IN) :: eui(ilong, k1:k2)
! mass flux up
    REAL*8, INTENT(IN) :: mui(ilong, k1:k2)
! mass flux down
    REAL*8, INTENT(IN) :: mdi(ilong, k1:k2)
! delta pressure between interfaces
    REAL*8, INTENT(IN) :: dpi(ilong, k1:k2)
! insoluble fraction of tracer
    REAL*8, INTENT(IN) :: fracis(i1:i2, k1:k2, numspecies)
!
! !INPUT/OUTPUT PARAMETERS:
! tracer array including moisture (mixing ratio)
    REAL*8, INTENT(INOUT) :: qq(i1:i2, k1:k2, numspecies)
!
! !DESCRIPTION:
! This routine performs convective transport of trace species.
! Note that we assume that the tracers are in a moist mixing ratio.
!
! !DEFINED PARAMETERS:
    REAL*8, PARAMETER :: small=1.0d-36
!
!EOP
!-----------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
    CHARACTER(len=75) :: err_msg
    INTEGER :: il, ik, ic
    INTEGER :: km1, kp1
! average mixing ratio in pbl
    REAL*8 :: avg_pbl
! mix ratio of constituent above
    REAL*8 :: cabv
! mix ratio of constituent below
    REAL*8 :: cbel
! normalized diff. between cabv and cbel
    REAL*8 :: cdifr
! flux coming into  each box at a k level
    REAL*8 :: fluxin
! flux going out of each box at a k level
    REAL*8 :: fluxout
    REAL*8 :: maxc
    REAL*8 :: minc
! mixing ratio of a scavenged tracer
    REAL*8 :: scav
    REAL*8 :: sqrt_fisg
!.sds - new temp variable for updraft concen calc
    REAL*8 :: temp_conu
! mix ratio in env.      at interfaces
    REAL*8 :: chat(il2g, k1:k2)
! mix ratio in updraft   at interfaces
    REAL*8 :: conu(il2g, k1:k2)
! mix ratio in downdraft at interfaces
    REAL*8 :: cond(il2g, k1:k2)
! gathered tend.  array
    REAL*8 :: dcondt(il2g, k1:k2)
! gathered downdraft entrainment
    REAL*8 :: edi(il2g, k1:k2)
! gathered insoluble frac. of tracer
    REAL*8 :: fisg(il2g, k1:k2)
! gathered tracer array
    REAL*8 :: xconst(il2g, k1:k2)
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC SUM
    INTRINSIC SQRT
    INTRINSIC ABS
    REAL*8 :: min1
    REAL*8 :: abs0
    REAL*8 :: min2
    REAL*8 :: min3
    LOGICAL, DIMENSION(il2g, k2-k1+1) :: mask
    REAL*8 :: result1
icloop:DO ic=1,numspecies
      IF (.NOT.isfixedconcentration(ic)) THEN
! ------------------------------------------------
! Gather up the constituent and set tend. to zero.
! ------------------------------------------------
        DO ik=k1,k2
          DO il=1,il2g
            fisg(il, ik) = fracis(ideep(il), ik, ic)
            xconst(il, ik) = qq(ideep(il), ik, ic)
          END DO
        END DO
! -----------------------------------------
! From now on work only with gathered data.
! -----------------------------------------
! ----------------------------------------------------
! Interpolate environment tracer values to interfaces.
! ----------------------------------------------------
ikloop1:DO ik=k1,k2
          IF (k1 .LT. ik - 1) THEN
            km1 = ik - 1
          ELSE
            km1 = k1
          END IF
          IF (k2 .GT. ik + 1) THEN
            kp1 = ik + 1
          ELSE
            kp1 = k2
          END IF
          edi(:, ik) = mdi(:, ik) - mdi(:, kp1)
  illoop1:DO il=1,il2g
!minc = Min (xconst(il,km1), xconst(il,ik))
!maxc = Max (xconst(il,km1), xconst(il,ik))
!if (minc < 0.0d0) then
!cdifr = 0.0d0
!else
!cdifr = Abs (xconst(il,ik) - xconst(il,km1)) /  &
!        Max (maxc, SMALL)
!end if
!if (cdifr > 1.0d-6) then
!   ! -------------------------------------------------------
!   ! The two layers differ significantly, so use a geometric
!   ! averaging procedure.
!   ! -------------------------------------------------------
!   cabv = Max (xconst(il,km1), (maxc * 1.0d-12))
!   cbel = Max (xconst(il,ik),  (maxc * 1.0d-12))
!   chat(il,ik) = Log (cabv/cbel) / (cabv - cbel) * cabv * cbel
!else
! ---------------------------------------------------
! The two layers have only a small difference, so use
! arithmetic mean.
! ---------------------------------------------------
            chat(il, ik) = 0.5d0*(xconst(il, ik)+xconst(il, km1))
!end if
! -------------------------------------
! Provisional up and down draft values.
! -------------------------------------
            conu(il, ik) = chat(il, ik)
            cond(il, ik) = chat(il, km1)
! ------------------
! Provisional tends.
! ------------------
            dcondt(il, ik) = 0.0d0
          END DO illoop1
        END DO ikloop1
        mask(:, :) = edi(:, :) .LT. 0.0d0
        WHERE (mask(:, :)) edi(:, :) = 0.0d0
illoop2:DO il=1,il2g
! ----------------------------------------------------------------------
! Find the mixing ratio in the downdraft, top of atmosphere down.
! NOTE: mass flux   in downdraft (mdi) will be zero or negative.
!       entrainment in downdraft (edi) will be zero or positive.
! ----------------------------------------------------------------------
 ikloopdd:DO ik=2,k2
            IF (mdi(il, ik-1) .LT. -xmbsth .OR. edi(il, ik) .GT. xmbsth&
&           ) cond(il, ik) = (cond(il, ik-1)*mdi(il, ik-1)-xconst(il, ik&
&               )*edi(il, ik))/(mdi(il, ik-1)-edi(il, ik))
          END DO ikloopdd
! ------------------------------------------------------
! Calculate updrafts with scavenging from bottom to top.
! Include the downdrafts.
! ------------------------------------------------------
! -------------------------------------
! Do the bottom most levels in the pbl.
! -------------------------------------
          IF (SUM(dpi(il, k2:pbli(il):-1)) .EQ. 0.0d0) THEN
            err_msg = 'Problem in convectiveTransport.'
            PRINT*, err_msg
            STOP
          ELSE
            result1 = SUM(xconst(il, k2:pbli(il):-1)*dpi(il, k2:pbli(il)&
&             :-1))
            avg_pbl = result1/SUM(dpi(il, k2:pbli(il):-1))
            sqrt_fisg = SQRT(fisg(il, pbli(il)))
            scav = avg_pbl*(1.0d0-sqrt_fisg)
            conu(il, pbli(il)) = avg_pbl*sqrt_fisg
            IF (chat(il, pbli(il)) .GT. xconst(il, pbli(il)-1)) THEN
              min1 = xconst(il, pbli(il)-1)
            ELSE
              min1 = chat(il, pbli(il))
            END IF
            fluxin = (mui(il, pbli(il))+mdi(il, pbli(il)))*min1 - mdi(il&
&             , pbli(il))*cond(il, pbli(il))
            fluxout = mui(il, pbli(il))*conu(il, pbli(il)) + mui(il, &
&             pbli(il))*scav
            dcondt(il, k2) = (fluxin-fluxout)/SUM(dpi(il, k2:pbli(il):-1&
&             ))
            IF (avg_pbl .GT. 0.0d0) THEN
              DO ik=k2,pbli(il),-1
                qq(ideep(il), ik, ic) = (avg_pbl+dcondt(il, k2)*delt)/&
&                 avg_pbl*xconst(il, ik)
              END DO
            END IF
! ---------------------------
! Loop over all other levels.
! ---------------------------
    ikloop2:DO ik=pbli(il)-1,2,-1
              kp1 = ik + 1
              km1 = ik - 1
! -----------------------------
! Find mixing ratio in updraft.
! -----------------------------
              IF (mui(il, kp1) - dui(il, ik) + eui(il, ik) .GT. xmbsth) &
&             THEN
                sqrt_fisg = SQRT(fisg(il, ik))
                IF (mui(il, kp1) + eui(il, ik) .GE. 0.) THEN
                  abs0 = mui(il, kp1) + eui(il, ik)
                ELSE
                  abs0 = -(mui(il, kp1)+eui(il, ik))
                END IF
                IF (abs0 .GE. xmbsth) THEN
!... mix updraft and entrainment, then detrain this concentration
                  temp_conu = (mui(il, kp1)*conu(il, kp1)+eui(il, ik)*&
&                   xconst(il, ik))/(mui(il, kp1)+eui(il, ik))
!... if updraft and entrainment flux sum to 0.0, then take average concen
                ELSE
                  temp_conu = (xconst(il, ik)+conu(il, kp1))/2.0d0
                END IF
!
                scav = ((mui(il, kp1)*conu(il, kp1)-dui(il, ik)*&
&                 temp_conu)*(1.0d0-fisg(il, ik))+eui(il, ik)*xconst(il&
&                 , ik)*(1.0d0-sqrt_fisg))/(mui(il, kp1)-dui(il, ik)+eui&
&                 (il, ik))
                conu(il, ik) = ((mui(il, kp1)*conu(il, kp1)-dui(il, ik)*&
&                 temp_conu)*fisg(il, ik)+eui(il, ik)*xconst(il, ik)*&
&                 sqrt_fisg)/(mui(il, kp1)-dui(il, ik)+eui(il, ik))
              ELSE
                conu(il, ik) = xconst(il, ik)
                scav = 0.0d0
              END IF
              IF (chat(il, ik) .GT. xconst(il, km1)) THEN
                min2 = xconst(il, km1)
              ELSE
                min2 = chat(il, ik)
              END IF
! -------------------------------------------------------
! Calculate fluxes into and out of box.  With scavenging
! included the net flux for the whole column is no longer
! guaranteed to be zero.
! Include the downdrafts.
! -------------------------------------------------------
              fluxin = mui(il, kp1)*conu(il, kp1) + (mui(il, ik)+mdi(il&
&               , ik))*min2 - mdi(il, ik)*cond(il, ik)
              IF (chat(il, kp1) .GT. xconst(il, ik)) THEN
                min3 = xconst(il, ik)
              ELSE
                min3 = chat(il, kp1)
              END IF
              fluxout = mui(il, ik)*conu(il, ik) + (mui(il, kp1)+mdi(il&
&               , kp1))*min3 + (mui(il, ik)+mui(il, kp1))*0.5d0*scav - &
&               mdi(il, kp1)*cond(il, kp1)
              dcondt(il, ik) = (fluxin-fluxout)/dpi(il, ik)
! --------------------------------------------
! Update and scatter data back to full arrays.
! --------------------------------------------
              qq(ideep(il), ik, ic) = xconst(il, ik) + dcondt(il, ik)*&
&               delt
            END DO ikloop2
          END IF
        END DO illoop2
      END IF
    END DO icloop
    RETURN
  END SUBROUTINE CONVECTIVETRANSPORT
END MODULE CONVECTIVETRANSPORT_MOD_B
