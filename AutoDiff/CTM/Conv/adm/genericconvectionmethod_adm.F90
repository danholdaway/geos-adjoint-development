!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
!-------------------------------------------------------------------------
!         NASA/GSFC, Software Systems Support Office, Code 610.3         !
!-------------------------------------------------------------------------
!BOP
!
! !MODULE: GenericConvectionMethod_mod 
MODULE GENERICCONVECTIONMETHOD_MOD_B
  USE ESMF
  USE CONVECTIVETRANSPORT_MOD_B
  USE GMIARRAYBUNDLEPOINTER_MOD_B
  IMPLICIT NONE
  PRIVATE 
  PUBLIC dogenericconvectivetransport
  PUBLIC dogenericconvectivetransport_adm

CONTAINS
!  Differentiation of dogenericconvectivetransport in reverse (adjoint) mode:
!   gradient     of useful results: *(concentration.parray3d)
!   with respect to varying inputs: *(concentration.parray3d)
!   RW status of diff variables: *(concentration.parray3d):in-out
!   Plus diff mem management of: concentration.parray3d:in
  SUBROUTINE DOGENERICCONVECTIVETRANSPORT_ADM(det_ent, do_downdraft, pbl&
&   , cldmas, dtrn, eu, ed, md, grid_height, mass, kel, press3e, &
&   concentration, concentration_ad, isfixedconcentration, mcor, tdt, i1&
&   , i2, j1, j2, k1, k2, ilong, ivert, num_species)
    IMPLICIT NONE
!
! !INPUT PARAMETER:
    INTEGER, INTENT(IN) :: i1, i2, j1, j2, k1, k2
    INTEGER, INTENT(IN) :: ilong, ivert, num_species
    LOGICAL, INTENT(IN) :: isfixedconcentration(:)
! flag for doing detrainment then entrainment
    LOGICAL, INTENT(IN) :: det_ent
! flag for doing downdrafts
    LOGICAL, INTENT(IN) :: do_downdraft
! model time step  (s)
    REAL*8, INTENT(IN) :: tdt
! area of each grid box (m^2)
    REAL*8, INTENT(IN) :: mcor(i1:i2, j1:j2)
! planetary boundary layer thickness (m)
    REAL*8, INTENT(IN) :: pbl(i1:i2, j1:j2)
! convective mass flux in     updraft (kg/m^2/s)
    REAL*8, INTENT(IN) :: cldmas(i1:i2, j1:j2, k1:k2)
! detrainment rate (DAO:kg/m^2*s, NCAR:s^-1)
    REAL*8, INTENT(IN) :: dtrn(i1:i2, j1:j2, k1:k2)
! ntrainment into convective updraft (s^-1)
    REAL*8, INTENT(IN) :: eu(i1:i2, j1:j2, k1:k2)
! entrainment into convective downdraft (s^-1)
    REAL*8, INTENT(IN) :: ed(i1:i2, j1:j2, k1:k2)
! convective mass flux in downdraft (kg/m^2/s)
    REAL*8, INTENT(IN) :: md(i1:i2, j1:j2, k1:k2)
! grid box height  (m)
    REAL*8, INTENT(IN) :: grid_height(i1:i2, j1:j2, k1:k2)
! mass of air in each grid box (kg)
    REAL*8, INTENT(IN) :: mass(i1:i2, j1:j2, k1:k2)
! temperature      (degK)
    REAL*8, INTENT(IN) :: kel(i1:i2, j1:j2, k1:k2)
! atmospheric pressure at the edge of each grid box (mb)
    REAL*8, INTENT(IN) :: press3e(i1:i2, j1:j2, k1-1:k2)
!
! !INPUT/OUTPUT PARAMETERS:
! species concentration, known at zone centers (mixing ratio)
    TYPE(T_GMIARRAYBUNDLE), INTENT(INOUT) :: concentration(num_species)
    TYPE(T_GMIARRAYBUNDLE), INTENT(INOUT) :: concentration_ad(&
&   num_species)
!
! !DEFINED PARAMETERS:
! threshold below which we treat 
    REAL*8, PARAMETER :: mbsth=1.0d-15
! mass fluxes as zero (mb/s)
! mean surface gravity accel. (m/s^2)
    REAL*8, PARAMETER :: gmi_g=9.81d0
! pascals  per millibar
    REAL*8, PARAMETER :: paspmb=100.00d0
!
! !DESCRIPTION:
! This is the interface routine to Convective Transport.  
! It formats the gem variables to satisfy the Convective Transport routine.
!
!EOP
!------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
    CHARACTER(len=75) :: err_msg
    INTEGER :: iku
    INTEGER :: il, ij, ik, ic
! gathered index to operate over
    INTEGER :: il2g
    INTEGER :: itdt_conv
    INTEGER :: num_conv_steps
    REAL*8 :: rnum_conv_steps
    REAL*8 :: tdt_conv
    REAL*8 :: xmbsth
! gathering array
    INTEGER :: ideep(ilong)
! index of pbl height
    INTEGER :: pbli(ilong)
! velocity in convective updraft
    REAL*8 :: updraft_velocity(i1:i2)
! (m/s)
! delta pressure between interfaces
    REAL*8 :: dpi(ilong, k1:k2)
! mass detraining from updraft
    REAL*8 :: dui(ilong, k1:k2)
! mass entraining into updraft
    REAL*8 :: eui(ilong, k1:k2)
! mass flux up
    REAL*8 :: mui(ilong, k1:k2)
! mass flux down
    REAL*8 :: mdi(ilong, k1:k2)
! insoluble fraction of tracer
    REAL*8 :: fracis(i1:i2, k1:k2, num_species)
! tracer array including moisture
    REAL*8 :: qq(i1:i2, k1:k2, num_species)
    REAL*8 :: qq_ad(i1:i2, k1:k2, num_species)
    INTRINSIC MAXVAL
    INTRINSIC INT
    INTRINSIC REAL
    INTRINSIC MAX
    INTRINSIC SUM
    INTEGER :: arg1
    REAL*8 :: result1
    REAL*8, DIMENSION(i2-i1+1, j2-j1+1, k2-k1+1) :: arg2
    REAL*8 :: result2
    LOGICAL, DIMENSION((k1-k2+2)/(-1)+1) :: mask
    INTEGER :: ad_from
    INTEGER :: ad_to
    INTEGER :: branch
    INTEGER :: ad_count
    INTEGER :: i
    INTEGER :: ad_count0
    INTEGER :: i0
    INTEGER :: ii1
    INTEGER :: ad_to0
    INTEGER :: ad_to1
    INTEGER :: ad_to2
    ideep(:) = 0
    pbli(:) = 0
    dpi(:, :) = 0.0d0
    dui(:, :) = 0.0d0
    eui(:, :) = 0.0d0
    mui(:, :) = 0.0d0
    mdi(:, :) = 0.0d0
    xmbsth = mbsth
! -----------------------------------------------------------
! Calculate any needed sub-cycling of the convection operator
! by comparing the mass flux over the full time step to the
! mass within the grid box.
! -----------------------------------------------------------
    result1 = SPREAD(mcor(:, :), 3, arg1)
    arg2(:, :, :) = tdt*cldmas(:, :, :)*result1/mass(:, :, :)
    result2 = MAXVAL(arg2(:, :, :))
    num_conv_steps = INT(result2 + 1.0d0)
    rnum_conv_steps = REAL(num_conv_steps, 8)
    tdt_conv = tdt/rnum_conv_steps
    CALL PUSHINTEGER4(ij)
    CALL PUSHCONTROL2B(0)
ijloop:DO ij=j1,j2
      CALL PUSHINTEGER4(il2g)
      il2g = 0
      ad_from = i1
illoop:DO il=ad_from,i2
! ----------------------------------------------------
! Verify that there is convection in the current cell.
! ----------------------------------------------------
        result1 = MAXVAL(cldmas(il, ij, :))
        IF (result1 .GE. 0.0d0) THEN
          il2g = il2g + 1
          CALL PUSHINTEGER4(ideep(il2g))
          ideep(il2g) = il
          CALL PUSHREAL8ARRAY(dpi(il2g, :), k2 - k1 + 1)
          dpi(il2g, :) = (press3e(il, ij, k2-1:k1-1:-1)-press3e(il, ij, &
&           k2:k1:-1))*paspmb
          CALL PUSHREAL8ARRAY(mui(il2g, :), k2 - k1 + 1)
          mui(il2g, :) = cldmas(il, ij, k2:k1:-1)*gmi_g
          CALL PUSHBOOLEANARRAY(mask(k2-1:k1+1:-1), (k1-k2+2)/(-1) + 1)
          mask(k2-1:k1+1:-1) = 0.0d0 .LT. cldmas(il, ij, k2-1:k1+1:-1) -&
&           cldmas(il, ij, k2-2:k1:-1) + dtrn(il, ij, k2-1:k1+1:-1)
          CALL PUSHREAL8ARRAY(eui(il2g, k1+1:k2-1), k2 - k1 - 1)
          WHERE (mask(k2-1:k1+1:-1)) eui(il2g, k1+1:k2-1) = cldmas(il, &
&             ij, k2-1:k1+1:-1) - cldmas(il, ij, k2-2:k1:-1) + dtrn(il, &
&             ij, k2-1:k1+1:-1)
          CALL PUSHREAL8ARRAY(eui(il2g, k1+1:k2-1), k2 - k1 - 1)
          WHERE (.NOT.mask(k2-1:k1+1:-1)) eui(il2g, k1+1:k2-1) = 0.0d0
          CALL PUSHREAL8ARRAY(eui(il2g, :), k2 - k1 + 1)
          eui(il2g, :) = eui(il2g, :)*gmi_g
          IF (det_ent) THEN
            CALL PUSHREAL8ARRAY(dui(il2g, :), k2 - k1 + 1)
            dui(il2g, :) = dtrn(il, ij, k2:k1:-1)*gmi_g
            CALL PUSHCONTROL2B(2)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(0)
        END IF
      END DO illoop
      CALL PUSHINTEGER4(il - 1)
      CALL PUSHINTEGER4(ad_from)
      IF (il2g .NE. 0) THEN
        CALL PUSHREAL8ARRAY(fracis, (i2-i1+1)*(k2-k1+1)*num_species)
        fracis(:, :, :) = 1.0d0
        ad_count0 = 1
! ----------------------------------------------------------------
! Find the index of the top of the planetary boundary layer (pbl).
! Convection will assume well mixed tracers below that level.
! ----------------------------------------------------------------
        DO il=1,il2g
          CALL PUSHINTEGER4(pbli(il))
          pbli(il) = 0
          ad_count = 1
   ikloop:DO ik=k1,k2
            IF (pbl(ideep(il), ij) .LT. SUM(grid_height(ideep(il), ij, &
&               k1:ik))) THEN
              GOTO 100
            ELSE
              ad_count = ad_count + 1
            END IF
          END DO ikloop
          CALL PUSHCONTROL1B(0)
          CALL PUSHINTEGER4(ad_count)
          CALL PUSHCONTROL1B(0)
          GOTO 110
 100      CALL PUSHCONTROL1B(1)
          CALL PUSHINTEGER4(ad_count)
          CALL PUSHINTEGER4(pbli(il))
          pbli(il) = ik
          CALL PUSHCONTROL1B(1)
 110      IF (pbli(il) .EQ. 0) THEN
            GOTO 140
          ELSE
            CALL PUSHINTEGER4(pbli(il))
            pbli(il) = k2 - pbli(il)
            ad_count0 = ad_count0 + 1
          END IF
        END DO
        CALL PUSHCONTROL1B(0)
        CALL PUSHINTEGER4(ad_count0)
itdtcloop:DO itdt_conv=1,num_conv_steps
          DO ic=1,num_species
            qq(:, k2:k1:-1, ic) = concentration(ic)%parray3d(:, ij, k1:&
&             k2)
          END DO
          CALL PUSHINTEGER4(ic - 1)
          CALL PUSHREAL8ARRAY(qq, (i2-i1+1)*(k2-k1+1)*num_species)
          CALL CONVECTIVETRANSPORT(il2g, tdt_conv, xmbsth, ideep, pbli, &
&                            dui, eui, mui, mdi, dpi, fracis, qq, &
&                            isfixedconcentration, i1, i2, k1, k2, ilong&
&                            , num_species)
          DO ic=1,num_species
            concentration(ic)%parray3d(:, ij, k1:k2) = qq(:, k2:k1:-1, &
&             ic)
          END DO
          CALL PUSHINTEGER4(ic - 1)
        END DO itdtcloop
        CALL PUSHINTEGER4(itdt_conv - 1)
        CALL PUSHINTEGER4(ij)
        CALL PUSHCONTROL2B(1)
      ELSE
        CALL PUSHINTEGER4(ij)
        CALL PUSHCONTROL2B(2)
      END IF
    END DO ijloop
    qq_ad = 0.0_8
 120 CALL POPCONTROL2B(branch)
    IF (branch .NE. 0) THEN
      IF (branch .EQ. 1) THEN
        CALL POPINTEGER4(ij)
        CALL POPINTEGER4(ad_to2)
        DO itdt_conv=ad_to2,1,-1
          CALL POPINTEGER4(ad_to1)
          DO ic=ad_to1,1,-1
            qq_ad(:, k2:k1:-1, ic) = qq_ad(:, k2:k1:-1, ic) + &
&             concentration_ad(ic)%parray3d(:, ij, k1:k2)
            concentration_ad(ic)%parray3d(:, ij, k1:k2) = 0.0_8
          END DO
          CALL POPREAL8ARRAY(qq, (i2-i1+1)*(k2-k1+1)*num_species)
          CALL CONVECTIVETRANSPORT_ADM(il2g, tdt_conv, xmbsth, ideep, &
&                                pbli, dui, eui, mui, mdi, dpi, fracis, &
&                                qq, qq_ad, isfixedconcentration, i1, i2&
&                                , k1, k2, ilong, num_species)
          CALL POPINTEGER4(ad_to0)
          DO ic=ad_to0,1,-1
            concentration_ad(ic)%parray3d(:, ij, k1:k2) = &
&             concentration_ad(ic)%parray3d(:, ij, k1:k2) + qq_ad(:, k2:&
&             k1:-1, ic)
            qq_ad(:, k2:k1:-1, ic) = 0.0_8
          END DO
        END DO
        CALL POPINTEGER4(ad_count0)
        DO 130 i0=1,ad_count0
          IF (i0 .EQ. 1) THEN
            CALL POPCONTROL1B(branch)
            IF (branch .EQ. 0) THEN
              GOTO 130
            ELSE
              DO ii1=1,num_species
                concentration_ad(ii1)%parray3d = 0.0_8
              END DO
              qq_ad = 0.0_8
            END IF
          ELSE
            CALL POPINTEGER4(pbli(il))
          END IF
          CALL POPCONTROL1B(branch)
          IF (branch .NE. 0) CALL POPINTEGER4(pbli(il))
          CALL POPINTEGER4(ad_count)
          DO i=1,ad_count
            IF (i .EQ. 1) CALL POPCONTROL1B(branch)
          END DO
          CALL POPINTEGER4(pbli(il))
 130    CONTINUE
        CALL POPREAL8ARRAY(fracis, (i2-i1+1)*(k2-k1+1)*num_species)
      ELSE
        CALL POPINTEGER4(ij)
      END IF
      CALL POPINTEGER4(ad_from)
      CALL POPINTEGER4(ad_to)
      DO il=ad_to,ad_from,-1
        CALL POPCONTROL2B(branch)
        IF (branch .NE. 0) THEN
          IF (branch .NE. 1) CALL POPREAL8ARRAY(dui(il2g, :), k2 - k1 + &
&                                         1)
          CALL POPREAL8ARRAY(eui(il2g, :), k2 - k1 + 1)
          CALL POPREAL8ARRAY(eui(il2g, k1+1:k2-1), k2 - k1 - 1)
          CALL POPREAL8ARRAY(eui(il2g, k1+1:k2-1), k2 - k1 - 1)
          CALL POPBOOLEANARRAY(mask(k2-1:k1+1:-1), (k1-k2+2)/(-1) + 1)
          CALL POPREAL8ARRAY(mui(il2g, :), k2 - k1 + 1)
          CALL POPREAL8ARRAY(dpi(il2g, :), k2 - k1 + 1)
          CALL POPINTEGER4(ideep(il2g))
        END IF
      END DO
      CALL POPINTEGER4(il2g)
      GOTO 120
    END IF
    CALL POPINTEGER4(ij)
    GOTO 150
 140 CALL PUSHCONTROL1B(1)
    CALL PUSHINTEGER4(ad_count0)
    STOP
 150 CONTINUE
  END SUBROUTINE DOGENERICCONVECTIVETRANSPORT_ADM
  SUBROUTINE DOGENERICCONVECTIVETRANSPORT(det_ent, do_downdraft, pbl, &
&   cldmas, dtrn, eu, ed, md, grid_height, mass, kel, press3e, &
&   concentration, isfixedconcentration, mcor, tdt, i1, i2, j1, j2, k1, &
&   k2, ilong, ivert, num_species)
    IMPLICIT NONE
!
! !INPUT PARAMETER:
    INTEGER, INTENT(IN) :: i1, i2, j1, j2, k1, k2
    INTEGER, INTENT(IN) :: ilong, ivert, num_species
    LOGICAL, INTENT(IN) :: isfixedconcentration(:)
! flag for doing detrainment then entrainment
    LOGICAL, INTENT(IN) :: det_ent
! flag for doing downdrafts
    LOGICAL, INTENT(IN) :: do_downdraft
! model time step  (s)
    REAL*8, INTENT(IN) :: tdt
! area of each grid box (m^2)
    REAL*8, INTENT(IN) :: mcor(i1:i2, j1:j2)
! planetary boundary layer thickness (m)
    REAL*8, INTENT(IN) :: pbl(i1:i2, j1:j2)
! convective mass flux in     updraft (kg/m^2/s)
    REAL*8, INTENT(IN) :: cldmas(i1:i2, j1:j2, k1:k2)
! detrainment rate (DAO:kg/m^2*s, NCAR:s^-1)
    REAL*8, INTENT(IN) :: dtrn(i1:i2, j1:j2, k1:k2)
! ntrainment into convective updraft (s^-1)
    REAL*8, INTENT(IN) :: eu(i1:i2, j1:j2, k1:k2)
! entrainment into convective downdraft (s^-1)
    REAL*8, INTENT(IN) :: ed(i1:i2, j1:j2, k1:k2)
! convective mass flux in downdraft (kg/m^2/s)
    REAL*8, INTENT(IN) :: md(i1:i2, j1:j2, k1:k2)
! grid box height  (m)
    REAL*8, INTENT(IN) :: grid_height(i1:i2, j1:j2, k1:k2)
! mass of air in each grid box (kg)
    REAL*8, INTENT(IN) :: mass(i1:i2, j1:j2, k1:k2)
! temperature      (degK)
    REAL*8, INTENT(IN) :: kel(i1:i2, j1:j2, k1:k2)
! atmospheric pressure at the edge of each grid box (mb)
    REAL*8, INTENT(IN) :: press3e(i1:i2, j1:j2, k1-1:k2)
!
! !INPUT/OUTPUT PARAMETERS:
! species concentration, known at zone centers (mixing ratio)
    TYPE(T_GMIARRAYBUNDLE), INTENT(INOUT) :: concentration(num_species)
!
! !DEFINED PARAMETERS:
! threshold below which we treat 
    REAL*8, PARAMETER :: mbsth=1.0d-15
! mass fluxes as zero (mb/s)
! mean surface gravity accel. (m/s^2)
    REAL*8, PARAMETER :: gmi_g=9.81d0
! pascals  per millibar
    REAL*8, PARAMETER :: paspmb=100.00d0
!
! !DESCRIPTION:
! This is the interface routine to Convective Transport.  
! It formats the gem variables to satisfy the Convective Transport routine.
!
!EOP
!------------------------------------------------------------------------
!BOC
!
! !LOCAL VARIABLES:
    CHARACTER(len=75) :: err_msg
    INTEGER :: iku
    INTEGER :: il, ij, ik, ic
! gathered index to operate over
    INTEGER :: il2g
    INTEGER :: itdt_conv
    INTEGER :: num_conv_steps
    REAL*8 :: rnum_conv_steps
    REAL*8 :: tdt_conv
    REAL*8 :: xmbsth
! gathering array
    INTEGER :: ideep(ilong)
! index of pbl height
    INTEGER :: pbli(ilong)
! velocity in convective updraft
    REAL*8 :: updraft_velocity(i1:i2)
! (m/s)
! delta pressure between interfaces
    REAL*8 :: dpi(ilong, k1:k2)
! mass detraining from updraft
    REAL*8 :: dui(ilong, k1:k2)
! mass entraining into updraft
    REAL*8 :: eui(ilong, k1:k2)
! mass flux up
    REAL*8 :: mui(ilong, k1:k2)
! mass flux down
    REAL*8 :: mdi(ilong, k1:k2)
! insoluble fraction of tracer
    REAL*8 :: fracis(i1:i2, k1:k2, num_species)
! tracer array including moisture
    REAL*8 :: qq(i1:i2, k1:k2, num_species)
    INTRINSIC MAXVAL
    INTRINSIC INT
    INTRINSIC REAL
    INTRINSIC MAX
    INTRINSIC SUM
    INTEGER :: arg1
    REAL*8 :: result1
    REAL*8, DIMENSION(i2-i1+1, j2-j1+1, k2-k1+1) :: arg2
    REAL*8 :: result2
    LOGICAL, DIMENSION((k1-k2+2)/(-1)+1) :: mask
    ideep(:) = 0
    pbli(:) = 0
    dpi(:, :) = 0.0d0
    dui(:, :) = 0.0d0
    eui(:, :) = 0.0d0
    mui(:, :) = 0.0d0
    mdi(:, :) = 0.0d0
    fracis(:, :, :) = 0.0d0
    xmbsth = mbsth
    updraft_velocity(:) = 0.0d0
! -----------------------------------------------------------
! Calculate any needed sub-cycling of the convection operator
! by comparing the mass flux over the full time step to the
! mass within the grid box.
! -----------------------------------------------------------
    arg1 = k2 - k1 + 1
    result1 = SPREAD(mcor(:, :), 3, arg1)
    arg2(:, :, :) = tdt*cldmas(:, :, :)*result1/mass(:, :, :)
    result2 = MAXVAL(arg2(:, :, :))
    num_conv_steps = INT(result2 + 1.0d0)
    rnum_conv_steps = REAL(num_conv_steps, 8)
    tdt_conv = tdt/rnum_conv_steps
ijloop:DO ij=j1,j2
      il2g = 0
illoop:DO il=i1,i2
! ----------------------------------------------------
! Verify that there is convection in the current cell.
! ----------------------------------------------------
        result1 = MAXVAL(cldmas(il, ij, :))
        IF (result1 .GE. 0.0d0) THEN
          il2g = il2g + 1
          ideep(il2g) = il
          dpi(il2g, :) = (press3e(il, ij, k2-1:k1-1:-1)-press3e(il, ij, &
&           k2:k1:-1))*paspmb
          mui(il2g, :) = cldmas(il, ij, k2:k1:-1)*gmi_g
          mask(k2-1:k1+1:-1) = 0.0d0 .LT. cldmas(il, ij, k2-1:k1+1:-1) -&
&           cldmas(il, ij, k2-2:k1:-1) + dtrn(il, ij, k2-1:k1+1:-1)
          WHERE (mask(k2-1:k1+1:-1)) 
            eui(il2g, k1+1:k2-1) = cldmas(il, ij, k2-1:k1+1:-1) - cldmas&
&             (il, ij, k2-2:k1:-1) + dtrn(il, ij, k2-1:k1+1:-1)
          ELSEWHERE
            eui(il2g, k1+1:k2-1) = 0.0d0
          END WHERE
          eui(il2g, :) = eui(il2g, :)*gmi_g
          IF (det_ent) dui(il2g, :) = dtrn(il, ij, k2:k1:-1)*gmi_g
        END IF
      END DO illoop
      IF (il2g .NE. 0) THEN
        fracis(:, :, :) = 1.0d0
! ----------------------------------------------------------------
! Find the index of the top of the planetary boundary layer (pbl).
! Convection will assume well mixed tracers below that level.
! ----------------------------------------------------------------
        DO il=1,il2g
          pbli(il) = 0
   ikloop:DO ik=k1,k2
            IF (pbl(ideep(il), ij) .LT. SUM(grid_height(ideep(il), ij, &
&               k1:ik))) THEN
              pbli(il) = ik
              GOTO 100
            END IF
          END DO ikloop
 100      IF (pbli(il) .EQ. 0) THEN
            err_msg = &
&             'Could not find pbl in doGenericConvectiveTransport.'
            PRINT*, err_msg
            STOP
          ELSE
            pbli(il) = k2 - pbli(il)
          END IF
        END DO
itdtcloop:DO itdt_conv=1,num_conv_steps
          DO ic=1,num_species
            qq(:, k2:k1:-1, ic) = concentration(ic)%parray3d(:, ij, k1:&
&             k2)
          END DO
          CALL CONVECTIVETRANSPORT(il2g, tdt_conv, xmbsth, ideep, pbli, &
&                            dui, eui, mui, mdi, dpi, fracis, qq, &
&                            isfixedconcentration, i1, i2, k1, k2, ilong&
&                            , num_species)
          DO ic=1,num_species
            concentration(ic)%parray3d(:, ij, k1:k2) = qq(:, k2:k1:-1, &
&             ic)
          END DO
        END DO itdtcloop
      END IF
    END DO ijloop
    RETURN
  END SUBROUTINE DOGENERICCONVECTIVETRANSPORT
END MODULE GENERICCONVECTIONMETHOD_MOD_B
