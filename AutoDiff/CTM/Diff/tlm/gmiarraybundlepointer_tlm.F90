!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
!-------------------------------------------------------------------------
! Module implements a derived type to support an "array of arrays" in F90.
! The derived type is not opaque - a compromise to minimize the impact on
! legacy code that uses the original data structure (a 4D array).
!-------------------------------------------------------------------------
MODULE GMIARRAYBUNDLEPOINTER_MOD_D
  IMPLICIT NONE
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
  PRIVATE 
! derived type
  PUBLIC t_gmiarraybundle
! constructor
  PUBLIC constructarraybundle
! destructor
  PUBLIC cleanarraypointer
! accessor
  PUBLIC setarraypointer
! accessor
  PUBLIC getarraypointer
! Derived type has public components for ease of use.
! Strong encapsulation would require intrusive changes
! in bothe GEOS and GMI.
  TYPE T_GMIARRAYBUNDLE
      REAL*8, POINTER :: parray3d(:, :, :) => NULL()
  END TYPE T_GMIARRAYBUNDLE
  INTERFACE CLEANARRAYPOINTER
      MODULE PROCEDURE CLEANSCALAR
      MODULE PROCEDURE CLEANVECTOR
  END INTERFACE


CONTAINS
!-------------------------------------------------------------------------
! Initialize a bundle from an already allocated 4D array.
  FUNCTION CONSTRUCTARRAYBUNDLE(oldarray, i1, i2, ju1, j2, k1, k2, &
&   numspecies) RESULT (BUNDLE)
    IMPLICIT NONE
    INTEGER :: i1, i2, ju1, j2, k1, k2
    INTEGER :: numspecies
! I,J,K,species
    REAL*8, TARGET :: oldarray(i1:i2, ju1:j2, k1:k2, numspecies)
    TYPE(T_GMIARRAYBUNDLE), POINTER :: bundle(:)
    INTEGER :: i
    ALLOCATE(bundle(numspecies))
    DO i=1,numspecies
      CALL SETARRAYPOINTER(bundle(i), oldarray(i1, ju1, k1, i), i1, i2, &
&                    ju1, j2, k1, k2)
    END DO
  END FUNCTION CONSTRUCTARRAYBUNDLE
!-------------------------------------------------------------------------
! Establish a link to a specified 3D target
! (pretend that encapsulation is enforced)
  SUBROUTINE SETARRAYPOINTER(this, newtarget, i1, i2, ju1, j2, k1, k2)
    IMPLICIT NONE
    INTEGER :: i1, i2, ju1, j2, k1, k2
    TYPE(T_GMIARRAYBUNDLE) :: this
    REAL*8, TARGET :: newtarget(i1:i2, ju1:j2, k1:k2)
! The following could fail on some compilers if a temporary copy of
! oldArray is generated.  Unlikely in this context, though.
    this%parray3d => newtarget
  END SUBROUTINE SETARRAYPOINTER
!-------------------------------------------------------------------------
! Retrieve pointer (pretend that encapsulation is enforced)
  FUNCTION GETARRAYPOINTER(this) RESULT (PTR)
    IMPLICIT NONE
    TYPE(T_GMIARRAYBUNDLE) :: this
    REAL*8, POINTER :: ptr(:, :, :)
    ptr => this%parray3d
  END FUNCTION GETARRAYPOINTER
!-------------------------------------------------------------------------
! Nullify the internal pointer (pretend encapsulation is enforced)
  SUBROUTINE CLEANSCALAR(this)
    IMPLICIT NONE
    TYPE(T_GMIARRAYBUNDLE) :: this
    NULLIFY(this%parray3d)
  END SUBROUTINE CLEANSCALAR
!-------------------------------------------------------------------------
! Clean an array of derived types. First clean each element, and
! then deallocate the array.
  SUBROUTINE CLEANVECTOR(this, status)
    IMPLICIT NONE
    INTEGER, INTENT(OUT) :: status
    TYPE(T_GMIARRAYBUNDLE), POINTER :: this(:)
    INTEGER :: i
    INTRINSIC SIZE
    DO i=1,SIZE(this)
      DEALLOCATE(this(i)%parray3d)
    END DO
    DEALLOCATE(this, stat=status)
  END SUBROUTINE CLEANVECTOR
END MODULE GMIARRAYBUNDLEPOINTER_MOD_D
