!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
!-------------------------------------------------------------------------
!         NASA/GSFC, Software Systems Support Office, Code 610.3         !
!-------------------------------------------------------------------------
!BOP
!
! !MODULE: updateDiffusion_mod
!
! !INTERFACE:
!
!#include "MAPL_Generic.h"
!
MODULE UPDATEDIFFUSION_MOD_B
!
! !USES:
  USE ESMF
!      use MAPL_Mod
  USE GMIARRAYBUNDLEPOINTER_MOD_B, ONLY : t_gmiarraybundle, &
& t_gmiarraybundle_b
  IMPLICIT NONE
!EOC
!------------------------------------------------------------------------------
!
! !PUBLIC MEMBER FUNCTIONS:
  PRIVATE 
  PUBLIC updatediffusion
  PUBLIC updatediffusion_adm
  PUBLIC update_pbl_mixing

CONTAINS
!  Differentiation of updatediffusion in reverse (adjoint) mode:
!   gradient     of useful results: *(concentration.parray3d)
!   with respect to varying inputs: *(concentration.parray3d)
!   RW status of diff variables: *(concentration.parray3d):in-out
!   Plus diff mem management of: concentration.parray3d:in
!
! !DESCRIPTION:
!
! !AUTHOR:
!
! !REVISION HISTORY:
!
!EOP
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
!BOP
!
! !IROUTINE: updateDiffusion
!
  SUBROUTINE UPDATEDIFFUSION_ADM(tdt, vert_diffu_coef, pbl, tropp, kzz, &
&   press3c, press3e, pctm1, concentration, concentration_ad, &
&   isfixedconcentration, mettype, i1, i2, ju1, j2, k1, k2, ilo, ihi, &
&   julo, jhi, numspecies)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
    INTEGER, INTENT(IN) :: i1, i2, ju1, j2, k1, k2, ilo, ihi, julo, jhi
    INTEGER, INTENT(IN) :: numspecies
! model time step (s)
    REAL*8, INTENT(IN) :: tdt
! scalar vertical diffusion coefficient (m^2/s)
    REAL*8, INTENT(IN) :: vert_diffu_coef
! planetary boundary layer depth (m
    REAL*8, INTENT(IN) :: pbl(i1:i2, ju1:j2)
! tropopause pressure (mb)
    REAL*8, INTENT(IN) :: tropp(i1:i2, ju1:j2)
! atmospheric pressure at the center 
    REAL*8, INTENT(IN) :: press3c(ilo:ihi, julo:jhi, k1:k2)
! of each grid box (mb)
! atmospheric pressure at the edge
    REAL*8, INTENT(IN) :: press3e(ilo:ihi, julo:jhi, k1-1:k2)
! of each grid box (mb)
! surface pressure field at t1, 
    REAL*8, INTENT(IN) :: pctm1(ilo:ihi, julo:jhi)
! known at zone centers (mb)
    LOGICAL, INTENT(IN) :: isfixedconcentration(numspecies)
    CHARACTER(len=esmf_maxstr), INTENT(IN) :: mettype
!
! !INPUT/OUTPUT PARAMETERS:
! array of vertical diffusion coefficients (m^2/s)
    REAL*8, INTENT(INOUT) :: kzz(i1:i2, ju1:j2, k1:k2)
! species concentration (mixing ratio)
    TYPE(T_GMIARRAYBUNDLE), INTENT(INOUT) :: concentration(numspecies)
    TYPE(T_GMIARRAYBUNDLE), INTENT(INOUT) :: concentration_ad(numspecies&
&   )
!
! !DESCRIPTION:
! Updates diffusion.
!
!EOP
!------------------------------------------------------------------------------
!BOC
    CALL ADJUST_KZZ(press3c, tropp, kzz, i1, i2, ju1, j2, k1, k2, ilo, &
&             ihi, julo, jhi)
    CALL DO_VERT_DIFFU_ADM(tdt, vert_diffu_coef, pbl, kzz, press3c, &
&                    press3e, pctm1, concentration, concentration_ad, &
&                    isfixedconcentration, mettype, i1, i2, ju1, j2, k1&
&                    , k2, ilo, ihi, julo, jhi, numspecies)
  END SUBROUTINE UPDATEDIFFUSION_ADM
!
! !DESCRIPTION:
!
! !AUTHOR:
!
! !REVISION HISTORY:
!
!EOP
!-------------------------------------------------------------------------
!-------------------------------------------------------------------------
!BOP
!
! !IROUTINE: updateDiffusion
!
  SUBROUTINE UPDATEDIFFUSION(tdt, vert_diffu_coef, pbl, tropp, kzz, &
&   press3c, press3e, pctm1, concentration, isfixedconcentration, &
&   mettype, i1, i2, ju1, j2, k1, k2, ilo, ihi, julo, jhi, numspecies)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
    INTEGER, INTENT(IN) :: i1, i2, ju1, j2, k1, k2, ilo, ihi, julo, jhi
    INTEGER, INTENT(IN) :: numspecies
! model time step (s)
    REAL*8, INTENT(IN) :: tdt
! scalar vertical diffusion coefficient (m^2/s)
    REAL*8, INTENT(IN) :: vert_diffu_coef
! planetary boundary layer depth (m
    REAL*8, INTENT(IN) :: pbl(i1:i2, ju1:j2)
! tropopause pressure (mb)
    REAL*8, INTENT(IN) :: tropp(i1:i2, ju1:j2)
! atmospheric pressure at the center 
    REAL*8, INTENT(IN) :: press3c(ilo:ihi, julo:jhi, k1:k2)
! of each grid box (mb)
! atmospheric pressure at the edge
    REAL*8, INTENT(IN) :: press3e(ilo:ihi, julo:jhi, k1-1:k2)
! of each grid box (mb)
! surface pressure field at t1, 
    REAL*8, INTENT(IN) :: pctm1(ilo:ihi, julo:jhi)
! known at zone centers (mb)
    LOGICAL, INTENT(IN) :: isfixedconcentration(numspecies)
    CHARACTER(len=esmf_maxstr), INTENT(IN) :: mettype
!
! !INPUT/OUTPUT PARAMETERS:
! array of vertical diffusion coefficients (m^2/s)
    REAL*8, INTENT(INOUT) :: kzz(i1:i2, ju1:j2, k1:k2)
! species concentration (mixing ratio)
    TYPE(T_GMIARRAYBUNDLE), INTENT(INOUT) :: concentration(numspecies)
!
! !DESCRIPTION:
! Updates diffusion.
!
!EOP
!------------------------------------------------------------------------------
!BOC
    CALL ADJUST_KZZ(press3c, tropp, kzz, i1, i2, ju1, j2, k1, k2, ilo, &
&             ihi, julo, jhi)
    CALL DO_VERT_DIFFU(tdt, vert_diffu_coef, pbl, kzz, press3c, press3e&
&                , pctm1, concentration, isfixedconcentration, mettype, &
&                i1, i2, ju1, j2, k1, k2, ilo, ihi, julo, jhi, &
&                numspecies)
    RETURN
  END SUBROUTINE UPDATEDIFFUSION
!
!EOC
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Update_PBL_Mixing
!
! !INTERFACE: 
!
  SUBROUTINE UPDATE_PBL_MIXING(tdt, pbl_mixing_tau, pbl, grid_height, &
&   mass, concentration, i1, i2, ju1, j2, k1, k2, numspecies)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
    INTEGER, INTENT(IN) :: i1, i2, ju1, j2, k1, k2
    INTEGER, INTENT(IN) :: numspecies
! model time step (s)
    REAL*8, INTENT(IN) :: tdt
! time scale for pbl mixing (s)
    REAL*8, INTENT(IN) :: pbl_mixing_tau
! planetary boundary layer depth (m)
    REAL*8, INTENT(IN) :: pbl(i1:i2, ju1:j2)
! height of each grid box (m)
    REAL*8, INTENT(IN) :: grid_height(i1:i2, ju1:j2, k1:k2)
! air mass in each grid box (kg)
    REAL*8, INTENT(IN) :: mass(i1:i2, ju1:j2, k1:k2)
!
! !INPUT/OUTPUT PARAMETERS:
    TYPE(T_GMIARRAYBUNDLE), INTENT(INOUT) :: concentration(numspecies)
!
! !DESCRIPTION:
!   Updates diffusion through a boundary layer mixing model.
!
! !LOCAL VARIABLES:
    INTEGER :: ic, il, ij, ik, kpbl
    REAL*8 :: frac_pbl, height, mass_pbl, mixing_factor, well_mixed
    INTRINSIC EXP
    INTRINSIC SUM
!EOP
!------------------------------------------------------------------------------
!BOC
    mixing_factor = EXP(-(tdt/pbl_mixing_tau))
!---------------------------------------
! Loop over all longitudes and latitudes.
!---------------------------------------
    DO il=i1,i2
      DO ij=ju1,j2
        mass_pbl = 0.0d0
        height = 0.0d0
!-----------------------------------
! Find the total mass within the pbl.
!-----------------------------------
  kloop:DO ik=k1,k2
          height = height + grid_height(il, ij, ik)
          IF (pbl(il, ij) .GE. height) THEN
            mass_pbl = mass_pbl + mass(il, ij, ik)
          ELSE
!-------------------------------------------------------
! This grid box is fractionally in the PBL. Save part of
! its mass also, save the k index, and exit the loop.
!-------------------------------------------------------
            frac_pbl = (pbl(il, ij)-(height-grid_height(il, ij, ik)))/&
&             grid_height(il, ij, ik)
            mass_pbl = mass_pbl + mass(il, ij, ik)*frac_pbl
            kpbl = ik
            GOTO 100
          END IF
        END DO kloop
!--------------------------------------------------------
! Now if a real PBL was found (kpbl > k1) loop over the
! species, calculate a well mixed
! mixing ratio, and apply it to the grids within the pbl
! and then to the grid box
! which is fractionally within the pbl.
!---------------------------------------------------------
 100    IF (kpbl .GT. k1) THEN
          DO ic=1,numspecies
            well_mixed = (SUM(concentration(ic)%parray3d(il, ij, k1:kpbl&
&             -1)*mass(il, ij, k1:kpbl-1))+frac_pbl*concentration(ic)%&
&             parray3d(il, ij, kpbl)*mass(il, ij, kpbl))/mass_pbl
            concentration(ic)%parray3d(il, ij, 1:kpbl-1) = concentration&
&             (ic)%parray3d(il, ij, k1:kpbl-1)*mixing_factor + &
&             well_mixed*(1.0d0-mixing_factor)
            concentration(ic)%parray3d(il, ij, kpbl) = concentration(ic)&
&             %parray3d(il, ij, kpbl) + frac_pbl*(concentration(ic)%&
&             parray3d(il, ij, kpbl)*(mixing_factor-1.0d0)+well_mixed*(&
&             1.0d0-mixing_factor))
          END DO
        END IF
      END DO
    END DO
    RETURN
  END SUBROUTINE UPDATE_PBL_MIXING
!EOC
!------------------------------------------------------------------------------
!BOP
!
! !IROUTINE: Adjust_Kzz
!
! !INTERFACE:
!
  SUBROUTINE ADJUST_KZZ(press3c, tropp, kzz, i1, i2, ju1, j2, k1, k2, &
&   ilo, ihi, julo, jhi)
    IMPLICIT NONE
!
! !INPUT PARAMETERS
    INTEGER, INTENT(IN) :: i1, i2, ju1, j2, k1, k2, ilo, ihi, julo, jhi
! atmospheric pressure at the center 
    REAL*8, INTENT(IN) :: press3c(ilo:ihi, julo:jhi, k1:k2)
! of each grid box (mb)
! tropopause pressure (mb)
    REAL*8, INTENT(IN) :: tropp(i1:i2, ju1:j2)
!
! !INPUT/OUTPUT PARAMETERS:
! vertical diffusion coefficients (m^2/s)
    REAL*8, INTENT(INOUT) :: kzz(i1:i2, ju1:j2, k1:k2)
    INTRINSIC MAXVAL
    REAL*8 :: result1
    LOGICAL, DIMENSION(i2-i1+1, j2-ju1+1, k2-k1+1) :: mask
!
! !DESCRIPTION:
!   Makes the kzz (vertical diffusion) zero above the tropopause.
!
!EOP
!------------------------------------------------------------------------------
!BOC
    result1 = MAXVAL(kzz)
    IF (result1 .GT. 0.0d0) THEN
      mask(1:i2-i1+1, 1:j2-ju1+1, :) = press3c(i1:i2, ju1:j2, :) .LT. &
&       SPREAD(tropp(:, :), 3, k2) + 100.0d0
      WHERE (mask(1:i2-i1+1, 1:j2-ju1+1, :)) kzz(i1:i2, ju1:j2, :) = &
&         0.0d0
    END IF
    RETURN
  END SUBROUTINE ADJUST_KZZ
!  Differentiation of do_vert_diffu in reverse (adjoint) mode:
!   gradient     of useful results: *(concentration.parray3d)
!   with respect to varying inputs: *(concentration.parray3d)
!   Plus diff mem management of: concentration.parray3d:in
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !IROUTINE: Do_Vert_Diffu
!
! !INTERFACE:
!
  SUBROUTINE DO_VERT_DIFFU_ADM(tdt, vert_diffu_coef, pbl, kzz, press3c, &
&   press3e, psf, concentration, concentration_ad, isfixedconcentration&
&   , mettype, i1, i2, ju1, j2, k1, k2, ilo, ihi, julo, jhi, numspecies)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
    INTEGER, INTENT(IN) :: i1, i2, ju1, j2, k1, k2, ilo, ihi, julo, jhi
    INTEGER, INTENT(IN) :: numspecies
! model time step (s)
    REAL*8, INTENT(IN) :: tdt
! scalar vertical diffusion coefficient (m^2/s)
    REAL*8, INTENT(IN) :: vert_diffu_coef
! planetary boundary layer depth (m)
    REAL*8, INTENT(IN) :: pbl(i1:i2, ju1:j2)
! vertical diffusion coefficients (m^2/s)
    REAL*8, INTENT(IN) :: kzz(i1:i2, ju1:j2, k1:k2)
! atmospheric pressure at the center of each grid box (mb)
    REAL*8, INTENT(IN) :: press3c(ilo:ihi, julo:jhi, k1:k2)
! atmospheric pressure at the edge   of each grid box (mb)
    REAL*8, INTENT(IN) :: press3e(ilo:ihi, julo:jhi, k1-1:k2)
! surface pressure field known at zone centers (mb)
    REAL*8, INTENT(IN) :: psf(ilo:ihi, julo:jhi)
    LOGICAL, INTENT(IN) :: isfixedconcentration(numspecies)
    CHARACTER(len=esmf_maxstr), INTENT(IN) :: mettype
!
! !INPUT/OUTPUT PARAMETERS:
    TYPE(T_GMIARRAYBUNDLE), INTENT(INOUT) :: concentration(numspecies)
    TYPE(T_GMIARRAYBUNDLE), INTENT(INOUT) :: concentration_ad(numspecies&
&   )
!
! !DECLARED VARIABLES:
! atmospheric scale height (m)
    REAL*8, PARAMETER :: hzero=8000.0d0
! (m^2)
    REAL*8, PARAMETER :: hzero2=hzero*hzero
!
! !DESCRIPTION:
!   Calculates vertical diffusion using an implicit technique.
!   Note: Constituent mass is conserved during mixing.
!          Constant field should remain constant.
!
! !LOCAL VARIABLES:
    INTEGER :: ik, ic
    REAL*8 :: avdiff(i1:i2, ju1:j2, k1:k2-1)
    REAL*8 :: bvdiff(i1:i2, ju1:j2, k1:k2-1)
    REAL*8 :: cvdiff(i1:i2, ju1:j2, k1:k2-1)
    REAL*8 :: vdiff(i1:i2, ju1:j2, k1:k2-1)
    REAL*8 :: bb(i1:i2, ju1:j2, k1:k2-1)
    REAL*8 :: cc(i1:i2, ju1:j2, k1:k2-1)
    REAL*8 :: rr(i1:i2, ju1:j2, k1:k2-1)
    REAL*8 :: rr_ad(i1:i2, ju1:j2, k1:k2-1)
    INTRINSIC MAXVAL
    INTRINSIC LOG
    INTRINSIC ABS
    INTRINSIC TRIM
    REAL*8, DIMENSION(i1:i2, ju1:j2) :: abs0
    REAL*8 :: result1
    LOGICAL, DIMENSION(i2-i1+1, j2-ju1+1) :: mask
    LOGICAL, DIMENSION(i2-i1+1, j2-ju1+1) :: mask0
    INTEGER :: branch
!
!EOP
!------------------------------------------------------------------------------
!BOC
    avdiff(:, :, :) = 0.0d0
    bvdiff(:, :, :) = 0.0d0
    cvdiff(:, :, :) = 0.0d0
    bb(:, :, :) = 0.0d0
    cc(:, :, :) = 0.0d0
! --------------------------------------------------------
! If there was no kzz in the met file, it was set to < 0.
! In this case calculate a vertical diffusion coefficient,
! otherwise use kzz.
! --------------------------------------------------------
    result1 = MAXVAL(kzz)
    IF (result1 .LT. 0.0d0) THEN
! ------------------------------------------------------
! Set up the vertical diffusion coefficients.
! First put height (m) into vdiff, then put simple
! parameterization for diffusion coefficient into vdiff,
! then put it into units of per mb
! ------------------------------------------------------
      vdiff = 0.0d0
      DO ik=1,10
        vdiff(:, :, ik) = -(hzero*LOG(press3e(i1:i2, ju1:j2, ik)/psf(i1:&
&         i2, ju1:j2)))
        CALL PUSHBOOLEANARRAY(mask, (i2-i1+1)*(j2-ju1+1))
        mask(:, :) = vdiff(:, :, ik) .LT. pbl(:, :)
        CALL PUSHBOOLEANARRAY(mask0, (i2-i1+1)*(j2-ju1+1))
        mask0(:, :) = vdiff(:, :, ik) - pbl(:, :)*0.5d0 .GE. 0.0
        WHERE (mask0(:, :)) 
          abs0 = vdiff(:, :, ik) - pbl(:, :)*0.5d0
        ELSEWHERE
          abs0 = -(vdiff(:, :, ik)-pbl(:, :)*0.5d0)
        END WHERE
        WHERE (mask(:, :)) 
          vdiff(:, :, ik) = vert_diffu_coef*(1.0d0-2.0d0*(abs0/pbl(:, :)&
&           ))
        ELSEWHERE
          vdiff(:, :, ik) = 0.0d0
        END WHERE
        vdiff(:, :, ik) = vdiff(:, :, ik)/hzero2*(press3e(i1:i2, ju1:j2&
&         , ik)*press3e(i1:i2, ju1:j2, ik))/(press3c(i1:i2, ju1:j2, ik)-&
&         press3c(i1:i2, ju1:j2, ik+1))
      END DO
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      vdiff(:, :, k1:k2-1) = kzz(:, :, k1:k2-1)/hzero2*(press3e(i1:i2, &
&       ju1:j2, k1:k2-1)*press3e(i1:i2, ju1:j2, k1:k2-1))/(press3c(i1:i2&
&       , ju1:j2, k1:k2-1)-press3c(i1:i2, ju1:j2, k1+1:k2))
    END IF
! -----------------------------------------------------------
! Construct the tri-diagonal matrix which will be used in the
! implicit vertical diffusion solution.
!   avdiff is the lower band
!   bvdiff is the main diagonal
!   cvdiff is the upper band
! -----------------------------------------------------------
! -----------------------
! First do the top layer.
! -----------------------
    avdiff(:, :, k2-1) = 0.0d0
    bvdiff(:, :, k2-1) = vdiff(:, :, k2-2)
    cvdiff(:, :, k2-1) = -vdiff(:, :, k2-2)
! ----------------------
! Now do all the layers.
! ----------------------
    avdiff(:, :, k1+1:k2-2) = -vdiff(:, :, k1+1:k2-2)
    bvdiff(:, :, k1+1:k2-2) = vdiff(:, :, k1+1:k2-2) + vdiff(:, :, k1:k2&
&     -3)
    cvdiff(:, :, k1+1:k2-2) = -vdiff(:, :, k1:k2-3)
! ------------------------------------
! Now do the layer next to the ground.
! ------------------------------------
    avdiff(:, :, k1) = -vdiff(:, :, k1)
    bvdiff(:, :, k1) = vdiff(:, :, k1)
    cvdiff(:, :, k1) = 0.0d0
! ---------------------------------------------------
! Now convert them to the proper dimensionless units.
! ---------------------------------------------------
    IF (TRIM(mettype) .EQ. 'MERRA2' .OR. TRIM(mettype) .EQ. 'FPIT') THEN
      CALL PUSHCONTROL1B(1)
      avdiff(i1:i2, ju1:j2, k1:k2-1) = avdiff(i1:i2, ju1:j2, k1:k2-1)*&
&       tdt/(press3e(i1:i2, ju1:j2, k1:k2-1)-press3e(i1:i2, ju1:j2, k1+1&
&       :k2))
      bvdiff(i1:i2, ju1:j2, k1:k2-1) = bvdiff(i1:i2, ju1:j2, k1:k2-1)*&
&       tdt/(press3e(i1:i2, ju1:j2, k1:k2-1)-press3e(i1:i2, ju1:j2, k1+1&
&       :k2)) + 1.0d0
      cvdiff(i1:i2, ju1:j2, k1:k2-1) = cvdiff(i1:i2, ju1:j2, k1:k2-1)*&
&       tdt/(press3e(i1:i2, ju1:j2, k1:k2-1)-press3e(i1:i2, ju1:j2, k1+1&
&       :k2))
    ELSE IF (TRIM(mettype) .EQ. 'MERRA1') THEN
      CALL PUSHCONTROL1B(0)
      avdiff(i1:i2, ju1:j2, k1:k2-1) = avdiff(i1:i2, ju1:j2, k1:k2-1)*&
&       tdt/(press3e(i1:i2, ju1:j2, k1-1:k2-2)-press3e(i1:i2, ju1:j2, k1&
&       :k2-1))
      bvdiff(i1:i2, ju1:j2, k1:k2-1) = bvdiff(i1:i2, ju1:j2, k1:k2-1)*&
&       tdt/(press3e(i1:i2, ju1:j2, k1-1:k2-2)-press3e(i1:i2, ju1:j2, k1&
&       :k2-1)) + 1.0d0
      cvdiff(i1:i2, ju1:j2, k1:k2-1) = cvdiff(i1:i2, ju1:j2, k1:k2-1)*&
&       tdt/(press3e(i1:i2, ju1:j2, k1-1:k2-2)-press3e(i1:i2, ju1:j2, k1&
&       :k2-1))
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
! ---------------------
! Now solve the system.
! ---------------------
icloop:DO ic=1,numspecies
!   ======================================
      IF (isfixedconcentration(ic)) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
!   ======================================
! -----------------------------------------
! Set up the right hand side of the system.
! -----------------------------------------
        CALL PUSHREAL8ARRAY(bb(:, :, k2-1), (i2-i1+1)*(j2-ju1+1))
        bb(:, :, k2-1) = bvdiff(:, :, k2-1)
! ---------------------------------
! Eliminate the lower diagonal (a).
! ---------------------------------
        DO ik=k2-1,k1+1,-1
          CALL PUSHREAL8ARRAY(cc(:, :, ik), (i2-i1+1)*(j2-ju1+1))
          cc(:, :, ik) = cvdiff(:, :, ik)/bb(:, :, ik)
          CALL PUSHREAL8ARRAY(bb(:, :, ik-1), (i2-i1+1)*(j2-ju1+1))
          bb(:, :, ik-1) = bvdiff(:, :, ik-1) - avdiff(:, :, ik-1)*cc(:&
&           , :, ik)
        END DO
        CALL PUSHCONTROL1B(1)
      END IF
    END DO icloop
    rr_ad = 0.0_8
    DO ic=numspecies,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        DO ik=k2-1,k1+1,-1
          rr_ad(:, :, ik) = rr_ad(:, :, ik) + concentration_ad(ic)%&
&           parray3d(:, :, ik)
          concentration_ad(ic)%parray3d(:, :, ik-1) = concentration_ad(&
&           ic)%parray3d(:, :, ik-1) - cc(:, :, ik)*concentration_ad(ic)&
&           %parray3d(:, :, ik)
          concentration_ad(ic)%parray3d(:, :, ik) = 0.0_8
        END DO
        rr_ad(:, :, k1) = rr_ad(:, :, k1) + concentration_ad(ic)%&
&         parray3d(:, :, k1)/bb(:, :, k1)
        concentration_ad(ic)%parray3d(:, :, k1) = 0.0_8
        DO ik=k1+1,k2-1,1
          concentration_ad(ic)%parray3d(:, :, ik-1) = concentration_ad(&
&           ic)%parray3d(:, :, ik-1) + rr_ad(:, :, ik-1)
          rr_ad(:, :, ik) = rr_ad(:, :, ik) - avdiff(:, :, ik-1)*rr_ad(:&
&           , :, ik-1)
          rr_ad(:, :, ik-1) = 0.0_8
          CALL POPREAL8ARRAY(bb(:, :, ik-1), (i2-i1+1)*(j2-ju1+1))
          rr_ad(:, :, ik) = rr_ad(:, :, ik)/bb(:, :, ik)
          CALL POPREAL8ARRAY(cc(:, :, ik), (i2-i1+1)*(j2-ju1+1))
        END DO
        concentration_ad(ic)%parray3d(:, :, k2-1) = concentration_ad(ic)&
&         %parray3d(:, :, k2-1) + rr_ad(:, :, k2-1)
        rr_ad(:, :, k2-1) = 0.0_8
        CALL POPREAL8ARRAY(bb(:, :, k2-1), (i2-i1+1)*(j2-ju1+1))
      END IF
    END DO
    CALL POPCONTROL1B(branch)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO ik=10,1,-1
        CALL POPBOOLEANARRAY(mask0, (i2-i1+1)*(j2-ju1+1))
        CALL POPBOOLEANARRAY(mask, (i2-i1+1)*(j2-ju1+1))
      END DO
    END IF
  END SUBROUTINE DO_VERT_DIFFU_ADM
!EOP
!------------------------------------------------------------------------------
!BOC
!
! !IROUTINE: Do_Vert_Diffu
!
! !INTERFACE:
!
  SUBROUTINE DO_VERT_DIFFU(tdt, vert_diffu_coef, pbl, kzz, press3c, &
&   press3e, psf, concentration, isfixedconcentration, mettype, i1, i2, &
&   ju1, j2, k1, k2, ilo, ihi, julo, jhi, numspecies)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
    INTEGER, INTENT(IN) :: i1, i2, ju1, j2, k1, k2, ilo, ihi, julo, jhi
    INTEGER, INTENT(IN) :: numspecies
! model time step (s)
    REAL*8, INTENT(IN) :: tdt
! scalar vertical diffusion coefficient (m^2/s)
    REAL*8, INTENT(IN) :: vert_diffu_coef
! planetary boundary layer depth (m)
    REAL*8, INTENT(IN) :: pbl(i1:i2, ju1:j2)
! vertical diffusion coefficients (m^2/s)
    REAL*8, INTENT(IN) :: kzz(i1:i2, ju1:j2, k1:k2)
! atmospheric pressure at the center of each grid box (mb)
    REAL*8, INTENT(IN) :: press3c(ilo:ihi, julo:jhi, k1:k2)
! atmospheric pressure at the edge   of each grid box (mb)
    REAL*8, INTENT(IN) :: press3e(ilo:ihi, julo:jhi, k1-1:k2)
! surface pressure field known at zone centers (mb)
    REAL*8, INTENT(IN) :: psf(ilo:ihi, julo:jhi)
    LOGICAL, INTENT(IN) :: isfixedconcentration(numspecies)
    CHARACTER(len=esmf_maxstr), INTENT(IN) :: mettype
!
! !INPUT/OUTPUT PARAMETERS:
    TYPE(T_GMIARRAYBUNDLE), INTENT(INOUT) :: concentration(numspecies)
!
! !DECLARED VARIABLES:
! atmospheric scale height (m)
    REAL*8, PARAMETER :: hzero=8000.0d0
! (m^2)
    REAL*8, PARAMETER :: hzero2=hzero*hzero
!
! !DESCRIPTION:
!   Calculates vertical diffusion using an implicit technique.
!   Note: Constituent mass is conserved during mixing.
!          Constant field should remain constant.
!
! !LOCAL VARIABLES:
    INTEGER :: ik, ic
    REAL*8 :: avdiff(i1:i2, ju1:j2, k1:k2-1)
    REAL*8 :: bvdiff(i1:i2, ju1:j2, k1:k2-1)
    REAL*8 :: cvdiff(i1:i2, ju1:j2, k1:k2-1)
    REAL*8 :: vdiff(i1:i2, ju1:j2, k1:k2-1)
    REAL*8 :: bb(i1:i2, ju1:j2, k1:k2-1)
    REAL*8 :: cc(i1:i2, ju1:j2, k1:k2-1)
    REAL*8 :: rr(i1:i2, ju1:j2, k1:k2-1)
    INTRINSIC MAXVAL
    INTRINSIC LOG
    INTRINSIC ABS
    INTRINSIC TRIM
    REAL*8, DIMENSION(i1:i2, ju1:j2) :: abs0
    REAL*8 :: result1
    LOGICAL, DIMENSION(i2-i1+1, j2-ju1+1) :: mask
    LOGICAL, DIMENSION(i2-i1+1, j2-ju1+1) :: mask0
!
!EOP
!------------------------------------------------------------------------------
!BOC
    avdiff(:, :, :) = 0.0d0
    bvdiff(:, :, :) = 0.0d0
    cvdiff(:, :, :) = 0.0d0
    vdiff(:, :, :) = 0.0d0
    bb(:, :, :) = 0.0d0
    cc(:, :, :) = 0.0d0
    rr(:, :, :) = 0.0d0
! --------------------------------------------------------
! If there was no kzz in the met file, it was set to < 0.
! In this case calculate a vertical diffusion coefficient,
! otherwise use kzz.
! --------------------------------------------------------
    result1 = MAXVAL(kzz)
    IF (result1 .LT. 0.0d0) THEN
! ------------------------------------------------------
! Set up the vertical diffusion coefficients.
! First put height (m) into vdiff, then put simple
! parameterization for diffusion coefficient into vdiff,
! then put it into units of per mb
! ------------------------------------------------------
      vdiff = 0.0d0
      DO ik=1,10
        vdiff(:, :, ik) = -(hzero*LOG(press3e(i1:i2, ju1:j2, ik)/psf(i1:&
&         i2, ju1:j2)))
        mask(:, :) = vdiff(:, :, ik) .LT. pbl(:, :)
        mask0(:, :) = vdiff(:, :, ik) - pbl(:, :)*0.5d0 .GE. 0.0
        WHERE (mask0(:, :)) 
          abs0 = vdiff(:, :, ik) - pbl(:, :)*0.5d0
        ELSEWHERE
          abs0 = -(vdiff(:, :, ik)-pbl(:, :)*0.5d0)
        END WHERE
        WHERE (mask(:, :)) 
          vdiff(:, :, ik) = vert_diffu_coef*(1.0d0-2.0d0*(abs0/pbl(:, :)&
&           ))
        ELSEWHERE
          vdiff(:, :, ik) = 0.0d0
        END WHERE
        vdiff(:, :, ik) = vdiff(:, :, ik)/hzero2*(press3e(i1:i2, ju1:j2&
&         , ik)*press3e(i1:i2, ju1:j2, ik))/(press3c(i1:i2, ju1:j2, ik)-&
&         press3c(i1:i2, ju1:j2, ik+1))
      END DO
    ELSE
      vdiff(:, :, k1:k2-1) = kzz(:, :, k1:k2-1)/hzero2*(press3e(i1:i2, &
&       ju1:j2, k1:k2-1)*press3e(i1:i2, ju1:j2, k1:k2-1))/(press3c(i1:i2&
&       , ju1:j2, k1:k2-1)-press3c(i1:i2, ju1:j2, k1+1:k2))
    END IF
! -----------------------------------------------------------
! Construct the tri-diagonal matrix which will be used in the
! implicit vertical diffusion solution.
!   avdiff is the lower band
!   bvdiff is the main diagonal
!   cvdiff is the upper band
! -----------------------------------------------------------
! -----------------------
! First do the top layer.
! -----------------------
    avdiff(:, :, k2-1) = 0.0d0
    bvdiff(:, :, k2-1) = vdiff(:, :, k2-2)
    cvdiff(:, :, k2-1) = -vdiff(:, :, k2-2)
! ----------------------
! Now do all the layers.
! ----------------------
    avdiff(:, :, k1+1:k2-2) = -vdiff(:, :, k1+1:k2-2)
    bvdiff(:, :, k1+1:k2-2) = vdiff(:, :, k1+1:k2-2) + vdiff(:, :, k1:k2&
&     -3)
    cvdiff(:, :, k1+1:k2-2) = -vdiff(:, :, k1:k2-3)
! ------------------------------------
! Now do the layer next to the ground.
! ------------------------------------
    avdiff(:, :, k1) = -vdiff(:, :, k1)
    bvdiff(:, :, k1) = vdiff(:, :, k1)
    cvdiff(:, :, k1) = 0.0d0
! ---------------------------------------------------
! Now convert them to the proper dimensionless units.
! ---------------------------------------------------
    IF (TRIM(mettype) .EQ. 'MERRA2' .OR. TRIM(mettype) .EQ. 'FPIT') THEN
      avdiff(i1:i2, ju1:j2, k1:k2-1) = avdiff(i1:i2, ju1:j2, k1:k2-1)*&
&       tdt/(press3e(i1:i2, ju1:j2, k1:k2-1)-press3e(i1:i2, ju1:j2, k1+1&
&       :k2))
      bvdiff(i1:i2, ju1:j2, k1:k2-1) = bvdiff(i1:i2, ju1:j2, k1:k2-1)*&
&       tdt/(press3e(i1:i2, ju1:j2, k1:k2-1)-press3e(i1:i2, ju1:j2, k1+1&
&       :k2)) + 1.0d0
      cvdiff(i1:i2, ju1:j2, k1:k2-1) = cvdiff(i1:i2, ju1:j2, k1:k2-1)*&
&       tdt/(press3e(i1:i2, ju1:j2, k1:k2-1)-press3e(i1:i2, ju1:j2, k1+1&
&       :k2))
    ELSE IF (TRIM(mettype) .EQ. 'MERRA1') THEN
      avdiff(i1:i2, ju1:j2, k1:k2-1) = avdiff(i1:i2, ju1:j2, k1:k2-1)*&
&       tdt/(press3e(i1:i2, ju1:j2, k1-1:k2-2)-press3e(i1:i2, ju1:j2, k1&
&       :k2-1))
      bvdiff(i1:i2, ju1:j2, k1:k2-1) = bvdiff(i1:i2, ju1:j2, k1:k2-1)*&
&       tdt/(press3e(i1:i2, ju1:j2, k1-1:k2-2)-press3e(i1:i2, ju1:j2, k1&
&       :k2-1)) + 1.0d0
      cvdiff(i1:i2, ju1:j2, k1:k2-1) = cvdiff(i1:i2, ju1:j2, k1:k2-1)*&
&       tdt/(press3e(i1:i2, ju1:j2, k1-1:k2-2)-press3e(i1:i2, ju1:j2, k1&
&       :k2-1))
    END IF
! ---------------------
! Now solve the system.
! ---------------------
icloop:DO ic=1,numspecies
!   ======================================
      IF (.NOT.isfixedconcentration(ic)) THEN
!   ======================================
! -----------------------------------------
! Set up the right hand side of the system.
! -----------------------------------------
        bb(:, :, k2-1) = bvdiff(:, :, k2-1)
        rr(:, :, k2-1) = concentration(ic)%parray3d(:, :, k2-1)
! ---------------------------------
! Eliminate the lower diagonal (a).
! ---------------------------------
        DO ik=k2-1,k1+1,-1
          cc(:, :, ik) = cvdiff(:, :, ik)/bb(:, :, ik)
          rr(:, :, ik) = rr(:, :, ik)/bb(:, :, ik)
          bb(:, :, ik-1) = bvdiff(:, :, ik-1) - avdiff(:, :, ik-1)*cc(:&
&           , :, ik)
          rr(:, :, ik-1) = concentration(ic)%parray3d(:, :, ik-1) - &
&           avdiff(:, :, ik-1)*rr(:, :, ik)
        END DO
! -------------------------------
! Solve for the new mixing ratio.
! -------------------------------
        concentration(ic)%parray3d(:, :, k1) = rr(:, :, k1)/bb(:, :, k1)
        DO ik=k1+1,k2-1
          concentration(ic)%parray3d(:, :, ik) = rr(:, :, ik) - &
&           concentration(ic)%parray3d(:, :, ik-1)*cc(:, :, ik)
        END DO
      END IF
    END DO icloop
    RETURN
  END SUBROUTINE DO_VERT_DIFFU
END MODULE UPDATEDIFFUSION_MOD_B
