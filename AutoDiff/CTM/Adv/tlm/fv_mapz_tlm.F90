!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
MODULE FV_MAPZ_MOD_D
  USE FV_ARRAYS_MOD, ONLY : real8
  IMPLICIT NONE
  REAL(real8), PARAMETER :: r0=0.0, r2=1./2., r3=1./3., r23=2./3., r12=&
&   1./12.
  PRIVATE 
  PUBLIC map1_q2
  PUBLIC map1_q2_tlm

CONTAINS
!  Differentiation of map1_q2 in forward (tangent) mode:
!   variations   of useful results: q2
!   with respect to varying inputs: q1 q2
  SUBROUTINE MAP1_Q2_TLM(km, pe1, q1, q1_tl, kn, pe2, q2, q2_tl, dp2, i1&
&   , i2, iv, kord, j, ibeg, iend, jbeg, jend)
    IMPLICIT NONE
! !INPUT PARAMETERS:
    INTEGER, INTENT(IN) :: j
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ibeg, iend, jbeg, jend
! Mode: 0 ==  constituents 1 == ???
    INTEGER, INTENT(IN) :: iv
    INTEGER, INTENT(IN) :: kord
! Original vertical dimension
    INTEGER, INTENT(IN) :: km
! Target vertical dimension
    INTEGER, INTENT(IN) :: kn
! pressure at layer edges 
    REAL(real8), INTENT(IN) :: pe1(i1:i2, km+1)
! (from model top to bottom surface)
! in the original vertical coordinate
! pressure at layer edges 
    REAL(real8), INTENT(IN) :: pe2(i1:i2, kn+1)
! (from model top to bottom surface)
! in the new vertical coordinate
! Field input
    REAL(real8), INTENT(IN) :: q1(ibeg:iend, jbeg:jend, km)
    REAL(real8), INTENT(IN) :: q1_tl(ibeg:iend, jbeg:jend, km)
    REAL(real8), INTENT(IN) :: dp2(i1:i2, kn)
! !INPUT/OUTPUT PARAMETERS:
! Field output
    REAL(real8), INTENT(INOUT) :: q2(i1:i2, kn)
    REAL(real8), INTENT(INOUT) :: q2_tl(i1:i2, kn)
! !LOCAL VARIABLES:
    REAL(real8) :: dp1(i1:i2, km)
    REAL(real8) :: q4(4, i1:i2, km)
    REAL(real8) :: q4_tl(4, i1:i2, km)
    REAL(real8) :: pl, pr, qsum, dp, esl
    REAL(real8) :: qsum_tl
    INTEGER :: i, k, l, m, k0
    q4_tl = 0.0_8
    DO k=1,km
      DO i=i1,i2
        dp1(i, k) = pe1(i, k+1) - pe1(i, k)
        q4_tl(1, i, k) = q1_tl(i, j, k)
        q4(1, i, k) = q1(i, j, k)
      END DO
    END DO
! Compute vertical subgrid distribution
    IF (kord .GT. 7) THEN
      IF (kord .EQ. 111) THEN
        CALL CS_PROFILE_LINEAR_TLM(q4, q4_tl, dp1, km, i1, i2, iv)
!else
!  call  cs_profile( q4, dp1, km, i1, i2, iv, kord )
        qsum_tl = 0.0_8
      ELSE
        qsum_tl = 0.0_8
      END IF
    ELSE
      qsum_tl = 0.0_8
    END IF
!else
!    call ppm_profile( q4, dp1, km, i1, i2, iv, kord )
! Mapping
    DO i=i1,i2
      k0 = 1
      DO 555 k=1,kn
        DO l=k0,km
! locate the top edge: pe2(i,k)
          IF (pe2(i, k) .GE. pe1(i, l) .AND. pe2(i, k) .LE. pe1(i, l+1)&
&         ) GOTO 110
        END DO
        GOTO 123
 110    pl = (pe2(i, k)-pe1(i, l))/dp1(i, l)
        IF (pe2(i, k+1) .LE. pe1(i, l+1)) THEN
! entire new grid is within the original grid
          pr = (pe2(i, k+1)-pe1(i, l))/dp1(i, l)
          q2_tl(i, k) = q4_tl(2, i, l) + 0.5*(pr+pl)*(q4_tl(4, i, l)+&
&           q4_tl(3, i, l)-q4_tl(2, i, l)) - r3*(pr*(pr+pl)+pl**2)*q4_tl&
&           (4, i, l)
          q2(i, k) = q4(2, i, l) + 0.5*(q4(4, i, l)+q4(3, i, l)-q4(2, i&
&           , l))*(pr+pl) - q4(4, i, l)*r3*(pr*(pr+pl)+pl**2)
          k0 = l
          GOTO 555
        ELSE
! Fractional area...
          qsum_tl = (pe1(i, l+1)-pe2(i, k))*(q4_tl(2, i, l)+0.5*(1.+pl)*&
&           (q4_tl(4, i, l)+q4_tl(3, i, l)-q4_tl(2, i, l))-r3*(1.+pl*(1.&
&           +pl))*q4_tl(4, i, l))
          qsum = (pe1(i, l+1)-pe2(i, k))*(q4(2, i, l)+0.5*(q4(4, i, l)+&
&           q4(3, i, l)-q4(2, i, l))*(1.+pl)-q4(4, i, l)*(r3*(1.+pl*(1.+&
&           pl))))
          DO m=l+1,km
! locate the bottom edge: pe2(i,k+1)
            IF (pe2(i, k+1) .GT. pe1(i, m+1)) THEN
! Whole layer..
              qsum_tl = qsum_tl + dp1(i, m)*q4_tl(1, i, m)
              qsum = qsum + dp1(i, m)*q4(1, i, m)
            ELSE
              GOTO 120
            END IF
          END DO
          GOTO 123
 120      dp = pe2(i, k+1) - pe1(i, m)
          esl = dp/dp1(i, m)
          qsum_tl = qsum_tl + dp*(q4_tl(2, i, m)+0.5*esl*(q4_tl(3, i, m)&
&           -q4_tl(2, i, m)+(1.-r23*esl)*q4_tl(4, i, m)))
          qsum = qsum + dp*(q4(2, i, m)+0.5*esl*(q4(3, i, m)-q4(2, i, m)&
&           +q4(4, i, m)*(1.-r23*esl)))
          k0 = m
        END IF
 123    q2_tl(i, k) = qsum_tl/dp2(i, k)
        q2(i, k) = qsum/dp2(i, k)
 555  CONTINUE
    END DO
  END SUBROUTINE MAP1_Q2_TLM
  SUBROUTINE MAP1_Q2(km, pe1, q1, kn, pe2, q2, dp2, i1, i2, iv, kord, j&
&   , ibeg, iend, jbeg, jend)
    IMPLICIT NONE
! !INPUT PARAMETERS:
    INTEGER, INTENT(IN) :: j
    INTEGER, INTENT(IN) :: i1, i2
    INTEGER, INTENT(IN) :: ibeg, iend, jbeg, jend
! Mode: 0 ==  constituents 1 == ???
    INTEGER, INTENT(IN) :: iv
    INTEGER, INTENT(IN) :: kord
! Original vertical dimension
    INTEGER, INTENT(IN) :: km
! Target vertical dimension
    INTEGER, INTENT(IN) :: kn
! pressure at layer edges 
    REAL(real8), INTENT(IN) :: pe1(i1:i2, km+1)
! (from model top to bottom surface)
! in the original vertical coordinate
! pressure at layer edges 
    REAL(real8), INTENT(IN) :: pe2(i1:i2, kn+1)
! (from model top to bottom surface)
! in the new vertical coordinate
! Field input
    REAL(real8), INTENT(IN) :: q1(ibeg:iend, jbeg:jend, km)
    REAL(real8), INTENT(IN) :: dp2(i1:i2, kn)
! !INPUT/OUTPUT PARAMETERS:
! Field output
    REAL(real8), INTENT(INOUT) :: q2(i1:i2, kn)
! !LOCAL VARIABLES:
    REAL(real8) :: dp1(i1:i2, km)
    REAL(real8) :: q4(4, i1:i2, km)
    REAL(real8) :: pl, pr, qsum, dp, esl
    INTEGER :: i, k, l, m, k0
    DO k=1,km
      DO i=i1,i2
        dp1(i, k) = pe1(i, k+1) - pe1(i, k)
        q4(1, i, k) = q1(i, j, k)
      END DO
    END DO
! Compute vertical subgrid distribution
    IF (kord .GT. 7) THEN
      IF (kord .EQ. 111) CALL CS_PROFILE_LINEAR(q4, dp1, km, i1, i2, iv)
!else
!  call  cs_profile( q4, dp1, km, i1, i2, iv, kord )
    END IF
!else
!    call ppm_profile( q4, dp1, km, i1, i2, iv, kord )
! Mapping
    DO i=i1,i2
      k0 = 1
      DO k=1,kn
        DO l=k0,km
! locate the top edge: pe2(i,k)
          IF (pe2(i, k) .GE. pe1(i, l) .AND. pe2(i, k) .LE. pe1(i, l+1)&
&         ) THEN
            pl = (pe2(i, k)-pe1(i, l))/dp1(i, l)
            IF (pe2(i, k+1) .LE. pe1(i, l+1)) THEN
! entire new grid is within the original grid
              pr = (pe2(i, k+1)-pe1(i, l))/dp1(i, l)
              q2(i, k) = q4(2, i, l) + 0.5*(q4(4, i, l)+q4(3, i, l)-q4(2&
&               , i, l))*(pr+pl) - q4(4, i, l)*r3*(pr*(pr+pl)+pl**2)
              k0 = l
              GOTO 555
            ELSE
! Fractional area...
              qsum = (pe1(i, l+1)-pe2(i, k))*(q4(2, i, l)+0.5*(q4(4, i, &
&               l)+q4(3, i, l)-q4(2, i, l))*(1.+pl)-q4(4, i, l)*(r3*(1.+&
&               pl*(1.+pl))))
              DO m=l+1,km
! locate the bottom edge: pe2(i,k+1)
                IF (pe2(i, k+1) .GT. pe1(i, m+1)) THEN
! Whole layer..
                  qsum = qsum + dp1(i, m)*q4(1, i, m)
                ELSE
                  dp = pe2(i, k+1) - pe1(i, m)
                  esl = dp/dp1(i, m)
                  qsum = qsum + dp*(q4(2, i, m)+0.5*esl*(q4(3, i, m)-q4(&
&                   2, i, m)+q4(4, i, m)*(1.-r23*esl)))
                  k0 = m
                  GOTO 123
                END IF
              END DO
              GOTO 123
            END IF
          END IF
        END DO
 123    q2(i, k) = qsum/dp2(i, k)
 555    CONTINUE
      END DO
    END DO
  END SUBROUTINE MAP1_Q2
!  Differentiation of cs_profile_linear in forward (tangent) mode:
!   variations   of useful results: a4
!   with respect to varying inputs: a4
  SUBROUTINE CS_PROFILE_LINEAR_TLM(a4, a4_tl, delp, km, i1, i2, iv)
    IMPLICIT NONE
! Optimized vertical profile reconstruction:
! Latest: Apr 2008 S.-J. Lin, NOAA/GFDL
    INTEGER, INTENT(IN) :: i1, i2
! vertical dimension
    INTEGER, INTENT(IN) :: km
! iv =-1: winds
    INTEGER, INTENT(IN) :: iv
! iv = 0: positive definite scalars
! iv = 1: others
! layer pressure thickness
    REAL(real8), INTENT(IN) :: delp(i1:i2, km)
! Interpolated values
    REAL(real8), INTENT(INOUT) :: a4(4, i1:i2, km)
    REAL(real8), INTENT(INOUT) :: a4_tl(4, i1:i2, km)
!-----------------------------------------------------------------------
    LOGICAL :: extm(i1:i2, km)
    REAL(real8) :: gam(i1:i2, km)
    REAL(real8) :: q(i1:i2, km+1)
    REAL(real8) :: q_tl(i1:i2, km+1)
    REAL(real8) :: d4(i1:i2)
    REAL(real8) :: bet, a_bot, grat
    REAL(real8) :: pmp_1, lac_1, pmp_2, lac_2
    INTEGER :: i, k, im
    q_tl = 0.0_8
    DO i=i1,i2
! grid ratio
      grat = delp(i, 2)/delp(i, 1)
      bet = grat*(grat+0.5)
      q_tl(i, 1) = ((grat+grat)*(grat+1.)*a4_tl(1, i, 1)+a4_tl(1, i, 2))&
&       /bet
      q(i, 1) = ((grat+grat)*(grat+1.)*a4(1, i, 1)+a4(1, i, 2))/bet
      gam(i, 1) = (1.+grat*(grat+1.5))/bet
    END DO
    DO k=2,km
      DO i=i1,i2
        d4(i) = delp(i, k-1)/delp(i, k)
        bet = 2. + d4(i) + d4(i) - gam(i, k-1)
        q_tl(i, k) = (3.*(a4_tl(1, i, k-1)+d4(i)*a4_tl(1, i, k))-q_tl(i&
&         , k-1))/bet
        q(i, k) = (3.*(a4(1, i, k-1)+d4(i)*a4(1, i, k))-q(i, k-1))/bet
        gam(i, k) = d4(i)/bet
      END DO
    END DO
    DO i=i1,i2
      a_bot = 1. + d4(i)*(d4(i)+1.5)
      q_tl(i, km+1) = (2.*d4(i)*(d4(i)+1.)*a4_tl(1, i, km)+a4_tl(1, i, &
&       km-1)-a_bot*q_tl(i, km))/(d4(i)*(d4(i)+0.5)-a_bot*gam(i, km))
      q(i, km+1) = (2.*d4(i)*(d4(i)+1.)*a4(1, i, km)+a4(1, i, km-1)-&
&       a_bot*q(i, km))/(d4(i)*(d4(i)+0.5)-a_bot*gam(i, km))
    END DO
    DO k=km,1,-1
      DO i=i1,i2
        q_tl(i, k) = q_tl(i, k) - gam(i, k)*q_tl(i, k+1)
        q(i, k) = q(i, k) - gam(i, k)*q(i, k+1)
      END DO
    END DO
    DO k=1,km
      DO i=i1,i2
        a4_tl(2, i, k) = q_tl(i, k)
        a4(2, i, k) = q(i, k)
        a4_tl(3, i, k) = q_tl(i, k+1)
        a4(3, i, k) = q(i, k+1)
        a4_tl(4, i, k) = 3.*(2.*a4_tl(1, i, k)-a4_tl(2, i, k)-a4_tl(3, i&
&         , k))
        a4(4, i, k) = 3.*(2.*a4(1, i, k)-(a4(2, i, k)+a4(3, i, k)))
      END DO
    END DO
  END SUBROUTINE CS_PROFILE_LINEAR_TLM
  SUBROUTINE CS_PROFILE_LINEAR(a4, delp, km, i1, i2, iv)
    IMPLICIT NONE
! Optimized vertical profile reconstruction:
! Latest: Apr 2008 S.-J. Lin, NOAA/GFDL
    INTEGER, INTENT(IN) :: i1, i2
! vertical dimension
    INTEGER, INTENT(IN) :: km
! iv =-1: winds
    INTEGER, INTENT(IN) :: iv
! iv = 0: positive definite scalars
! iv = 1: others
! layer pressure thickness
    REAL(real8), INTENT(IN) :: delp(i1:i2, km)
! Interpolated values
    REAL(real8), INTENT(INOUT) :: a4(4, i1:i2, km)
!-----------------------------------------------------------------------
    LOGICAL :: extm(i1:i2, km)
    REAL(real8) :: gam(i1:i2, km)
    REAL(real8) :: q(i1:i2, km+1)
    REAL(real8) :: d4(i1:i2)
    REAL(real8) :: bet, a_bot, grat
    REAL(real8) :: pmp_1, lac_1, pmp_2, lac_2
    INTEGER :: i, k, im
    DO i=i1,i2
! grid ratio
      grat = delp(i, 2)/delp(i, 1)
      bet = grat*(grat+0.5)
      q(i, 1) = ((grat+grat)*(grat+1.)*a4(1, i, 1)+a4(1, i, 2))/bet
      gam(i, 1) = (1.+grat*(grat+1.5))/bet
    END DO
    DO k=2,km
      DO i=i1,i2
        d4(i) = delp(i, k-1)/delp(i, k)
        bet = 2. + d4(i) + d4(i) - gam(i, k-1)
        q(i, k) = (3.*(a4(1, i, k-1)+d4(i)*a4(1, i, k))-q(i, k-1))/bet
        gam(i, k) = d4(i)/bet
      END DO
    END DO
    DO i=i1,i2
      a_bot = 1. + d4(i)*(d4(i)+1.5)
      q(i, km+1) = (2.*d4(i)*(d4(i)+1.)*a4(1, i, km)+a4(1, i, km-1)-&
&       a_bot*q(i, km))/(d4(i)*(d4(i)+0.5)-a_bot*gam(i, km))
    END DO
    DO k=km,1,-1
      DO i=i1,i2
        q(i, k) = q(i, k) - gam(i, k)*q(i, k+1)
      END DO
    END DO
    DO k=1,km
      DO i=i1,i2
        a4(2, i, k) = q(i, k)
        a4(3, i, k) = q(i, k+1)
        a4(4, i, k) = 3.*(2.*a4(1, i, k)-(a4(2, i, k)+a4(3, i, k)))
      END DO
    END DO
  END SUBROUTINE CS_PROFILE_LINEAR
  SUBROUTINE CS_PROFILE(a4, delp, km, i1, i2, iv, kord)
    IMPLICIT NONE
! Optimized vertical profile reconstruction:
! Latest: Apr 2008 S.-J. Lin, NOAA/GFDL
    INTEGER, INTENT(IN) :: i1, i2
! vertical dimension
    INTEGER, INTENT(IN) :: km
! iv =-1: winds
    INTEGER, INTENT(IN) :: iv
! iv = 0: positive definite scalars
! iv = 1: others
    INTEGER, INTENT(IN) :: kord
! layer pressure thickness
    REAL(real8), INTENT(IN) :: delp(i1:i2, km)
! Interpolated values
    REAL(real8), INTENT(INOUT) :: a4(4, i1:i2, km)
!-----------------------------------------------------------------------
    LOGICAL :: extm(i1:i2, km)
    REAL(real8) :: gam(i1:i2, km)
    REAL(real8) :: q(i1:i2, km+1)
    REAL(real8) :: d4(i1:i2)
    REAL(real8) :: bet, a_bot, grat
    REAL(real8) :: pmp_1, lac_1, pmp_2, lac_2
    INTEGER :: i, k, im
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTEGER :: abs0
    INTEGER :: abs1
    INTEGER :: abs2
    INTEGER :: abs3
    INTEGER :: abs4
    REAL*8 :: abs5
    INTEGER :: abs6
    REAL*8 :: abs7
    REAL*8 :: abs8
    REAL*8 :: abs9
    REAL*8 :: y27
    REAL*8 :: y26
    REAL*8 :: y25
    REAL*8 :: y24
    REAL*8 :: y23
    REAL*8 :: y22
    REAL*8 :: y21
    REAL*8 :: y20
    REAL*8 :: x6
    REAL*8 :: x5
    REAL*8 :: x4
    REAL*8 :: x3
    REAL*8 :: x2
    REAL*8 :: x1
    REAL*8 :: y19
    REAL*8 :: y18
    REAL*8 :: y17
    REAL*8 :: y16
    REAL*8 :: y15
    REAL*8 :: y14
    REAL*8 :: y13
    REAL*8 :: y12
    REAL*8 :: y11
    REAL*8 :: y10
    REAL*8 :: z1
    REAL*8 :: y9
    REAL*8 :: y8
    REAL*8 :: y7
    REAL*8 :: y6
    REAL*8 :: y5
    REAL*8 :: y4
    REAL*8 :: y3
    REAL*8 :: y2
    REAL*8 :: y1
    DO i=i1,i2
! grid ratio
      grat = delp(i, 2)/delp(i, 1)
      bet = grat*(grat+0.5)
      q(i, 1) = ((grat+grat)*(grat+1.)*a4(1, i, 1)+a4(1, i, 2))/bet
      gam(i, 1) = (1.+grat*(grat+1.5))/bet
    END DO
    DO k=2,km
      DO i=i1,i2
        d4(i) = delp(i, k-1)/delp(i, k)
        bet = 2. + d4(i) + d4(i) - gam(i, k-1)
        q(i, k) = (3.*(a4(1, i, k-1)+d4(i)*a4(1, i, k))-q(i, k-1))/bet
        gam(i, k) = d4(i)/bet
      END DO
    END DO
    DO i=i1,i2
      a_bot = 1. + d4(i)*(d4(i)+1.5)
      q(i, km+1) = (2.*d4(i)*(d4(i)+1.)*a4(1, i, km)+a4(1, i, km-1)-&
&       a_bot*q(i, km))/(d4(i)*(d4(i)+0.5)-a_bot*gam(i, km))
    END DO
    DO k=km,1,-1
      DO i=i1,i2
        q(i, k) = q(i, k) - gam(i, k)*q(i, k+1)
      END DO
    END DO
!------------------
! Apply constraints
!------------------
    im = i2 - i1 + 1
! Apply *large-scale* constraints 
    DO i=i1,i2
      IF (a4(1, i, 1) .LT. a4(1, i, 2)) THEN
        y1 = a4(1, i, 2)
      ELSE
        y1 = a4(1, i, 1)
      END IF
      IF (q(i, 2) .GT. y1) THEN
        q(i, 2) = y1
      ELSE
        q(i, 2) = q(i, 2)
      END IF
      IF (a4(1, i, 1) .GT. a4(1, i, 2)) THEN
        y2 = a4(1, i, 2)
      ELSE
        y2 = a4(1, i, 1)
      END IF
      IF (q(i, 2) .LT. y2) THEN
        q(i, 2) = y2
      ELSE
        q(i, 2) = q(i, 2)
      END IF
    END DO
    DO k=2,km
      DO i=i1,i2
        gam(i, k) = a4(1, i, k) - a4(1, i, k-1)
      END DO
    END DO
    IF (kord .GE. 0.) THEN
      abs0 = kord
    ELSE
      abs0 = -kord
    END IF
! Interior:
    IF (abs0 .LT. 11) THEN
      DO k=3,km-1
        DO i=i1,i2
          IF (gam(i, k-1)*gam(i, k+1) .GT. 0.) THEN
            IF (a4(1, i, k-1) .LT. a4(1, i, k)) THEN
              y3 = a4(1, i, k)
            ELSE
              y3 = a4(1, i, k-1)
            END IF
            IF (q(i, k) .GT. y3) THEN
              q(i, k) = y3
            ELSE
              q(i, k) = q(i, k)
            END IF
            IF (a4(1, i, k-1) .GT. a4(1, i, k)) THEN
              y4 = a4(1, i, k)
            ELSE
              y4 = a4(1, i, k-1)
            END IF
            IF (q(i, k) .LT. y4) THEN
              q(i, k) = y4
            ELSE
              q(i, k) = q(i, k)
            END IF
          ELSE IF (gam(i, k-1) .GT. 0.) THEN
            IF (a4(1, i, k-1) .GT. a4(1, i, k)) THEN
              y5 = a4(1, i, k)
            ELSE
              y5 = a4(1, i, k-1)
            END IF
            IF (q(i, k) .LT. y5) THEN
              q(i, k) = y5
            ELSE
              q(i, k) = q(i, k)
            END IF
          ELSE
            IF (a4(1, i, k-1) .LT. a4(1, i, k)) THEN
              y6 = a4(1, i, k)
            ELSE
              y6 = a4(1, i, k-1)
            END IF
            IF (q(i, k) .GT. y6) THEN
              q(i, k) = y6
            ELSE
              q(i, k) = q(i, k)
            END IF
            IF (iv .EQ. 0) THEN
              IF (0. .LT. q(i, k)) THEN
                q(i, k) = q(i, k)
              ELSE
                q(i, k) = 0.
              END IF
            END IF
          END IF
        END DO
      END DO
    ELSE
! abs(kord) >=11
      DO k=3,km-1
        DO i=i1,i2
          IF (gam(i, k-1)*gam(i, k+1) .GT. 0.) THEN
            IF (a4(1, i, k-1) .LT. a4(1, i, k)) THEN
              y7 = a4(1, i, k)
            ELSE
              y7 = a4(1, i, k-1)
            END IF
            IF (q(i, k) .GT. y7) THEN
              q(i, k) = y7
            ELSE
              q(i, k) = q(i, k)
            END IF
            IF (a4(1, i, k-1) .GT. a4(1, i, k)) THEN
              y8 = a4(1, i, k)
            ELSE
              y8 = a4(1, i, k-1)
            END IF
            IF (q(i, k) .LT. y8) THEN
              q(i, k) = y8
            ELSE
              q(i, k) = q(i, k)
            END IF
          ELSE IF (gam(i, k-1) .GT. 0.) THEN
            IF (a4(1, i, k-1) .GT. a4(1, i, k)) THEN
              y9 = a4(1, i, k)
            ELSE
              y9 = a4(1, i, k-1)
            END IF
            IF (q(i, k) .LT. y9) THEN
              q(i, k) = y9
            ELSE
              q(i, k) = q(i, k)
            END IF
            IF (q(i, k) .GT. a4(1, i, k-1) + 0.5*gam(i, k-1)) THEN
              IF (a4(1, i, k-1) + 0.5*gam(i, k-1) .GT. a4(1, i, k) - 0.5&
&                 *gam(i, k+1)) THEN
                q(i, k) = a4(1, i, k) - 0.5*gam(i, k+1)
              ELSE
                q(i, k) = a4(1, i, k-1) + 0.5*gam(i, k-1)
              END IF
            ELSE IF (q(i, k) .GT. a4(1, i, k) - 0.5*gam(i, k+1)) THEN
              q(i, k) = a4(1, i, k) - 0.5*gam(i, k+1)
            ELSE
              q(i, k) = q(i, k)
            END IF
          ELSE IF (iv .EQ. 0) THEN
! There exists a local min
            IF (a4(1, i, k-1) .LT. a4(1, i, k)) THEN
              y10 = a4(1, i, k)
            ELSE
              y10 = a4(1, i, k-1)
            END IF
            IF (q(i, k) .GT. y10) THEN
              q(i, k) = y10
            ELSE
              q(i, k) = q(i, k)
            END IF
            IF (0. .LT. a4(1, i, k) - 0.5*gam(i, k+1)) THEN
              z1 = a4(1, i, k) - 0.5*gam(i, k+1)
            ELSE
              z1 = 0.
            END IF
            IF (q(i, k) .LT. a4(1, i, k-1) + 0.5*gam(i, k-1)) THEN
              IF (a4(1, i, k-1) + 0.5*gam(i, k-1) .LT. z1) THEN
                q(i, k) = z1
              ELSE
                q(i, k) = a4(1, i, k-1) + 0.5*gam(i, k-1)
              END IF
            ELSE IF (q(i, k) .LT. z1) THEN
              q(i, k) = z1
            ELSE
              q(i, k) = q(i, k)
            END IF
          ELSE
            IF (a4(1, i, k-1) .LT. a4(1, i, k)) THEN
              y11 = a4(1, i, k)
            ELSE
              y11 = a4(1, i, k-1)
            END IF
            IF (q(i, k) .GT. y11) THEN
              q(i, k) = y11
            ELSE
              q(i, k) = q(i, k)
            END IF
            IF (q(i, k) .LT. a4(1, i, k-1) + 0.5*gam(i, k-1)) THEN
              IF (a4(1, i, k-1) + 0.5*gam(i, k-1) .LT. a4(1, i, k) - 0.5&
&                 *gam(i, k+1)) THEN
                q(i, k) = a4(1, i, k) - 0.5*gam(i, k+1)
              ELSE
                q(i, k) = a4(1, i, k-1) + 0.5*gam(i, k-1)
              END IF
            ELSE IF (q(i, k) .LT. a4(1, i, k) - 0.5*gam(i, k+1)) THEN
              q(i, k) = a4(1, i, k) - 0.5*gam(i, k+1)
            ELSE
              q(i, k) = q(i, k)
            END IF
          END IF
        END DO
      END DO
    END IF
! Bottom:
    DO i=i1,i2
      IF (a4(1, i, km-1) .LT. a4(1, i, km)) THEN
        y12 = a4(1, i, km)
      ELSE
        y12 = a4(1, i, km-1)
      END IF
      IF (q(i, km) .GT. y12) THEN
        q(i, km) = y12
      ELSE
        q(i, km) = q(i, km)
      END IF
      IF (a4(1, i, km-1) .GT. a4(1, i, km)) THEN
        y13 = a4(1, i, km)
      ELSE
        y13 = a4(1, i, km-1)
      END IF
      IF (q(i, km) .LT. y13) THEN
        q(i, km) = y13
      ELSE
        q(i, km) = q(i, km)
      END IF
    END DO
    DO k=1,km
      DO i=i1,i2
        a4(2, i, k) = q(i, k)
        a4(3, i, k) = q(i, k+1)
      END DO
    END DO
    DO k=2,km-1
      DO i=i1,i2
        IF (gam(i, k)*gam(i, k+1) .GT. 0.0) THEN
          extm(i, k) = .false.
        ELSE
          extm(i, k) = .true.
        END IF
      END DO
    END DO
!---------------------------
! Apply subgrid constraints:
!---------------------------
! f(s) = AL + s*[(AR-AL) + A6*(1-s)]         ( 0 <= s  <= 1 )
! Top 2 and bottom 2 layers always use monotonic mapping
    IF (iv .EQ. 0) THEN
      DO i=i1,i2
        IF (0. .LT. a4(2, i, 1)) THEN
          a4(2, i, 1) = a4(2, i, 1)
        ELSE
          a4(2, i, 1) = 0.
        END IF
      END DO
    ELSE IF (iv .EQ. -1) THEN
      DO i=i1,i2
        IF (a4(2, i, 1)*a4(1, i, 1) .LE. 0.) a4(2, i, 1) = 0.
      END DO
    ELSE
      IF (iv .GE. 0.) THEN
        abs1 = iv
      ELSE
        abs1 = -iv
      END IF
      IF (abs1 .EQ. 2) THEN
        DO i=i1,i2
          a4(2, i, 1) = a4(1, i, 1)
          a4(3, i, 1) = a4(1, i, 1)
          a4(4, i, 1) = 0.
        END DO
      END IF
    END IF
    IF (iv .GE. 0.) THEN
      abs2 = iv
    ELSE
      abs2 = -iv
    END IF
    IF (abs2 .NE. 2) THEN
      DO i=i1,i2
        a4(4, i, 1) = 3.*(2.*a4(1, i, 1)-(a4(2, i, 1)+a4(3, i, 1)))
      END DO
      CALL CS_LIMITERS(im, extm(i1, 1), a4(1, i1, 1), 1)
    END IF
! k=2
    DO i=i1,i2
      a4(4, i, 2) = 3.*(2.*a4(1, i, 2)-(a4(2, i, 2)+a4(3, i, 2)))
    END DO
    CALL CS_LIMITERS(im, extm(i1, 2), a4(1, i1, 2), 2)
!-------------------------------------
! Huynh's 2nd constraint for interior:
!-------------------------------------
    DO k=3,km-2
      IF (kord .GE. 0.) THEN
        abs3 = kord
      ELSE
        abs3 = -kord
      END IF
      IF (abs3 .LT. 9) THEN
        DO i=i1,i2
! Left  edges
          pmp_1 = a4(1, i, k) - 2.*gam(i, k+1)
          lac_1 = pmp_1 + 1.5*gam(i, k+2)
          IF (a4(1, i, k) .GT. pmp_1) THEN
            IF (pmp_1 .GT. lac_1) THEN
              y20 = lac_1
            ELSE
              y20 = pmp_1
            END IF
          ELSE IF (a4(1, i, k) .GT. lac_1) THEN
            y20 = lac_1
          ELSE
            y20 = a4(1, i, k)
          END IF
          IF (a4(2, i, k) .LT. y20) THEN
            x1 = y20
          ELSE
            x1 = a4(2, i, k)
          END IF
          IF (a4(1, i, k) .LT. pmp_1) THEN
            IF (pmp_1 .LT. lac_1) THEN
              y14 = lac_1
            ELSE
              y14 = pmp_1
            END IF
          ELSE IF (a4(1, i, k) .LT. lac_1) THEN
            y14 = lac_1
          ELSE
            y14 = a4(1, i, k)
          END IF
          IF (x1 .GT. y14) THEN
            a4(2, i, k) = y14
          ELSE
            a4(2, i, k) = x1
          END IF
! Right edges
          pmp_2 = a4(1, i, k) + 2.*gam(i, k)
          lac_2 = pmp_2 - 1.5*gam(i, k-1)
          IF (a4(1, i, k) .GT. pmp_2) THEN
            IF (pmp_2 .GT. lac_2) THEN
              y21 = lac_2
            ELSE
              y21 = pmp_2
            END IF
          ELSE IF (a4(1, i, k) .GT. lac_2) THEN
            y21 = lac_2
          ELSE
            y21 = a4(1, i, k)
          END IF
          IF (a4(3, i, k) .LT. y21) THEN
            x2 = y21
          ELSE
            x2 = a4(3, i, k)
          END IF
          IF (a4(1, i, k) .LT. pmp_2) THEN
            IF (pmp_2 .LT. lac_2) THEN
              y15 = lac_2
            ELSE
              y15 = pmp_2
            END IF
          ELSE IF (a4(1, i, k) .LT. lac_2) THEN
            y15 = lac_2
          ELSE
            y15 = a4(1, i, k)
          END IF
          IF (x2 .GT. y15) THEN
            a4(3, i, k) = y15
          ELSE
            a4(3, i, k) = x2
          END IF
          a4(4, i, k) = 3.*(2.*a4(1, i, k)-(a4(2, i, k)+a4(3, i, k)))
        END DO
      ELSE
        IF (kord .GE. 0.) THEN
          abs4 = kord
        ELSE
          abs4 = -kord
        END IF
        IF (abs4 .EQ. 9) THEN
          DO i=i1,i2
            IF (extm(i, k) .AND. (extm(i, k-1) .OR. extm(i, k+1))) THEN
! c90_mp122
! grid-scale 2-delta-z wave detected
              a4(2, i, k) = a4(1, i, k)
              a4(3, i, k) = a4(1, i, k)
              a4(4, i, k) = 0.
            ELSE
              a4(4, i, k) = 6.*a4(1, i, k) - 3.*(a4(2, i, k)+a4(3, i, k)&
&               )
              IF (a4(4, i, k) .GE. 0.) THEN
                abs5 = a4(4, i, k)
              ELSE
                abs5 = -a4(4, i, k)
              END IF
              IF (a4(2, i, k) - a4(3, i, k) .GE. 0.) THEN
                abs8 = a4(2, i, k) - a4(3, i, k)
              ELSE
                abs8 = -(a4(2, i, k)-a4(3, i, k))
              END IF
! Check within the smooth region if subgrid profile is non-monotonic
              IF (abs5 .GT. abs8) THEN
                pmp_1 = a4(1, i, k) - 2.*gam(i, k+1)
                lac_1 = pmp_1 + 1.5*gam(i, k+2)
                IF (a4(1, i, k) .GT. pmp_1) THEN
                  IF (pmp_1 .GT. lac_1) THEN
                    y22 = lac_1
                  ELSE
                    y22 = pmp_1
                  END IF
                ELSE IF (a4(1, i, k) .GT. lac_1) THEN
                  y22 = lac_1
                ELSE
                  y22 = a4(1, i, k)
                END IF
                IF (a4(2, i, k) .LT. y22) THEN
                  x3 = y22
                ELSE
                  x3 = a4(2, i, k)
                END IF
                IF (a4(1, i, k) .LT. pmp_1) THEN
                  IF (pmp_1 .LT. lac_1) THEN
                    y16 = lac_1
                  ELSE
                    y16 = pmp_1
                  END IF
                ELSE IF (a4(1, i, k) .LT. lac_1) THEN
                  y16 = lac_1
                ELSE
                  y16 = a4(1, i, k)
                END IF
                IF (x3 .GT. y16) THEN
                  a4(2, i, k) = y16
                ELSE
                  a4(2, i, k) = x3
                END IF
                pmp_2 = a4(1, i, k) + 2.*gam(i, k)
                lac_2 = pmp_2 - 1.5*gam(i, k-1)
                IF (a4(1, i, k) .GT. pmp_2) THEN
                  IF (pmp_2 .GT. lac_2) THEN
                    y23 = lac_2
                  ELSE
                    y23 = pmp_2
                  END IF
                ELSE IF (a4(1, i, k) .GT. lac_2) THEN
                  y23 = lac_2
                ELSE
                  y23 = a4(1, i, k)
                END IF
                IF (a4(3, i, k) .LT. y23) THEN
                  x4 = y23
                ELSE
                  x4 = a4(3, i, k)
                END IF
                IF (a4(1, i, k) .LT. pmp_2) THEN
                  IF (pmp_2 .LT. lac_2) THEN
                    y17 = lac_2
                  ELSE
                    y17 = pmp_2
                  END IF
                ELSE IF (a4(1, i, k) .LT. lac_2) THEN
                  y17 = lac_2
                ELSE
                  y17 = a4(1, i, k)
                END IF
                IF (x4 .GT. y17) THEN
                  a4(3, i, k) = y17
                ELSE
                  a4(3, i, k) = x4
                END IF
                a4(4, i, k) = 6.*a4(1, i, k) - 3.*(a4(2, i, k)+a4(3, i, &
&                 k))
              END IF
            END IF
          END DO
        ELSE
          IF (kord .GE. 0.) THEN
            abs6 = kord
          ELSE
            abs6 = -kord
          END IF
          IF (abs6 .EQ. 10) THEN
            DO i=i1,i2
              IF (extm(i, k)) THEN
                IF (extm(i, k-1) .OR. extm(i, k+1)) THEN
! grid-scale 2-delta-z wave detected
                  a4(2, i, k) = a4(1, i, k)
                  a4(3, i, k) = a4(1, i, k)
                  a4(4, i, k) = 0.
                ELSE
! True local extremum
                  a4(4, i, k) = 6.*a4(1, i, k) - 3.*(a4(2, i, k)+a4(3, i&
&                   , k))
                END IF
              ELSE
! not a local extremum
                a4(4, i, k) = 6.*a4(1, i, k) - 3.*(a4(2, i, k)+a4(3, i, &
&                 k))
                IF (a4(4, i, k) .GE. 0.) THEN
                  abs7 = a4(4, i, k)
                ELSE
                  abs7 = -a4(4, i, k)
                END IF
                IF (a4(2, i, k) - a4(3, i, k) .GE. 0.) THEN
                  abs9 = a4(2, i, k) - a4(3, i, k)
                ELSE
                  abs9 = -(a4(2, i, k)-a4(3, i, k))
                END IF
! Check within the smooth region if subgrid profile is non-monotonic
                IF (abs7 .GT. abs9) THEN
                  pmp_1 = a4(1, i, k) - 2.*gam(i, k+1)
                  lac_1 = pmp_1 + 1.5*gam(i, k+2)
                  IF (pmp_1 .LT. lac_1) THEN
                    y26 = lac_1
                  ELSE
                    y26 = pmp_1
                  END IF
                  IF (a4(1, i, k) .GT. y26) THEN
                    y24 = y26
                  ELSE
                    y24 = a4(1, i, k)
                  END IF
                  IF (a4(2, i, k) .LT. y24) THEN
                    x5 = y24
                  ELSE
                    x5 = a4(2, i, k)
                  END IF
                  IF (a4(1, i, k) .LT. pmp_1) THEN
                    IF (pmp_1 .LT. lac_1) THEN
                      y18 = lac_1
                    ELSE
                      y18 = pmp_1
                    END IF
                  ELSE IF (a4(1, i, k) .LT. lac_1) THEN
                    y18 = lac_1
                  ELSE
                    y18 = a4(1, i, k)
                  END IF
                  IF (x5 .GT. y18) THEN
                    a4(2, i, k) = y18
                  ELSE
                    a4(2, i, k) = x5
                  END IF
                  pmp_2 = a4(1, i, k) + 2.*gam(i, k)
                  lac_2 = pmp_2 - 1.5*gam(i, k-1)
                  IF (pmp_2 .LT. lac_2) THEN
                    y27 = lac_2
                  ELSE
                    y27 = pmp_2
                  END IF
                  IF (a4(1, i, k) .GT. y27) THEN
                    y25 = y27
                  ELSE
                    y25 = a4(1, i, k)
                  END IF
                  IF (a4(3, i, k) .LT. y25) THEN
                    x6 = y25
                  ELSE
                    x6 = a4(3, i, k)
                  END IF
                  IF (a4(1, i, k) .LT. pmp_2) THEN
                    IF (pmp_2 .LT. lac_2) THEN
                      y19 = lac_2
                    ELSE
                      y19 = pmp_2
                    END IF
                  ELSE IF (a4(1, i, k) .LT. lac_2) THEN
                    y19 = lac_2
                  ELSE
                    y19 = a4(1, i, k)
                  END IF
                  IF (x6 .GT. y19) THEN
                    a4(3, i, k) = y19
                  ELSE
                    a4(3, i, k) = x6
                  END IF
                  a4(4, i, k) = 6.*a4(1, i, k) - 3.*(a4(2, i, k)+a4(3, i&
&                   , k))
                END IF
              END IF
            END DO
          ELSE
! kord = 11, ...
            DO i=i1,i2
              IF (extm(i, k) .AND. (extm(i, k-1) .OR. extm(i, k+1))) &
&             THEN
! Noisy region:
                a4(2, i, k) = a4(1, i, k)
                a4(3, i, k) = a4(1, i, k)
                a4(4, i, k) = 0.
              ELSE
                a4(4, i, k) = 3.*(2.*a4(1, i, k)-(a4(2, i, k)+a4(3, i, k&
&                 )))
              END IF
            END DO
          END IF
        END IF
      END IF
! Additional constraint to ensure positivity
      IF (iv .EQ. 0) CALL CS_LIMITERS(im, extm(i1, k), a4(1, i1, k), 0)
    END DO
! k-loop
!----------------------------------
! Bottom layer subgrid constraints:
!----------------------------------
    IF (iv .EQ. 0) THEN
      DO i=i1,i2
        IF (0. .LT. a4(3, i, km)) THEN
          a4(3, i, km) = a4(3, i, km)
        ELSE
          a4(3, i, km) = 0.
        END IF
      END DO
    ELSE IF (iv .LT. 0) THEN
      DO i=i1,i2
        IF (a4(3, i, km)*a4(1, i, km) .LE. 0.) a4(3, i, km) = 0.
      END DO
    END IF
    DO k=km-1,km
      DO i=i1,i2
        a4(4, i, k) = 3.*(2.*a4(1, i, k)-(a4(2, i, k)+a4(3, i, k)))
      END DO
      IF (k .EQ. km - 1) CALL CS_LIMITERS(im, extm(i1, k), a4(1, i1, k)&
&                                   , 2)
      IF (k .EQ. km) CALL CS_LIMITERS(im, extm(i1, k), a4(1, i1, k), 1)
    END DO
  END SUBROUTINE CS_PROFILE
  SUBROUTINE CS_LIMITERS(im, extm, a4, iv)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: im
    INTEGER, INTENT(IN) :: iv
    LOGICAL, INTENT(IN) :: extm(im)
! PPM array
    REAL(real8), INTENT(INOUT) :: a4(4, im)
! !LOCAL VARIABLES:
    REAL(real8) :: da1, da2, a6da
    INTEGER :: i
    INTRINSIC ABS
    REAL*8 :: abs0
    IF (iv .EQ. 0) THEN
! Positive definite constraint
      DO i=1,im
        IF (a4(1, i) .LE. 0.) THEN
          a4(2, i) = a4(1, i)
          a4(3, i) = a4(1, i)
          a4(4, i) = 0.
        ELSE
          IF (a4(3, i) - a4(2, i) .GE. 0.) THEN
            abs0 = a4(3, i) - a4(2, i)
          ELSE
            abs0 = -(a4(3, i)-a4(2, i))
          END IF
          IF (abs0 .LT. -a4(4, i)) THEN
            IF (a4(1, i) + 0.25*(a4(3, i)-a4(2, i))**2/a4(4, i) + a4(4, &
&               i)*r12 .LT. 0.) THEN
! local minimum is negative
              IF (a4(1, i) .LT. a4(3, i) .AND. a4(1, i) .LT. a4(2, i)) &
&             THEN
                a4(3, i) = a4(1, i)
                a4(2, i) = a4(1, i)
                a4(4, i) = 0.
              ELSE IF (a4(3, i) .GT. a4(2, i)) THEN
                a4(4, i) = 3.*(a4(2, i)-a4(1, i))
                a4(3, i) = a4(2, i) - a4(4, i)
              ELSE
                a4(4, i) = 3.*(a4(3, i)-a4(1, i))
                a4(2, i) = a4(3, i) - a4(4, i)
              END IF
            END IF
          END IF
        END IF
      END DO
    ELSE IF (iv .EQ. 1) THEN
      DO i=1,im
        IF ((a4(1, i)-a4(2, i))*(a4(1, i)-a4(3, i)) .GE. 0.) THEN
          a4(2, i) = a4(1, i)
          a4(3, i) = a4(1, i)
          a4(4, i) = 0.
        ELSE
          da1 = a4(3, i) - a4(2, i)
          da2 = da1**2
          a6da = a4(4, i)*da1
          IF (a6da .LT. -da2) THEN
            a4(4, i) = 3.*(a4(2, i)-a4(1, i))
            a4(3, i) = a4(2, i) - a4(4, i)
          ELSE IF (a6da .GT. da2) THEN
            a4(4, i) = 3.*(a4(3, i)-a4(1, i))
            a4(2, i) = a4(3, i) - a4(4, i)
          END IF
        END IF
      END DO
    ELSE
! Standard PPM constraint
      DO i=1,im
        IF (extm(i)) THEN
          a4(2, i) = a4(1, i)
          a4(3, i) = a4(1, i)
          a4(4, i) = 0.
        ELSE
          da1 = a4(3, i) - a4(2, i)
          da2 = da1**2
          a6da = a4(4, i)*da1
          IF (a6da .LT. -da2) THEN
            a4(4, i) = 3.*(a4(2, i)-a4(1, i))
            a4(3, i) = a4(2, i) - a4(4, i)
          ELSE IF (a6da .GT. da2) THEN
            a4(4, i) = 3.*(a4(3, i)-a4(1, i))
            a4(2, i) = a4(3, i) - a4(4, i)
          END IF
        END IF
      END DO
    END IF
  END SUBROUTINE CS_LIMITERS
  SUBROUTINE PPM_PROFILE(a4, delp, km, i1, i2, iv, kord)
    IMPLICIT NONE
! !INPUT PARAMETERS:
! iv =-1: winds
    INTEGER, INTENT(IN) :: iv
! iv = 0: positive definite scalars
! iv = 1: others
! iv = 2: temp (if remap_t) and w (iv=-2)
! Starting longitude
    INTEGER, INTENT(IN) :: i1
! Finishing longitude
    INTEGER, INTENT(IN) :: i2
! vertical dimension
    INTEGER, INTENT(IN) :: km
! Order (or more accurately method no.):
    INTEGER, INTENT(IN) :: kord
! 
! layer pressure thickness
    REAL(real8), INTENT(IN) :: delp(i1:i2, km)
! !INPUT/OUTPUT PARAMETERS:
! Interpolated values
    REAL(real8), INTENT(INOUT) :: a4(4, i1:i2, km)
! DESCRIPTION:
!
!   Perform the piecewise parabolic reconstruction
! 
! !REVISION HISTORY: 
! S.-J. Lin   revised at GFDL 2007
!-----------------------------------------------------------------------
! local arrays:
    REAL(real8) :: dc(i1:i2, km)
    REAL(real8) :: h2(i1:i2, km)
    REAL(real8) :: delq(i1:i2, km)
    REAL(real8) :: df2(i1:i2, km)
    REAL(real8) :: d4(i1:i2, km)
! local scalars:
    INTEGER :: i, k, km1, lmt, it
    REAL(real8) :: fac
    REAL(real8) :: a1, a2, c1, c2, c3, d1, d2
    REAL(real8) :: qm, dq, lac, qmp, pmp
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC SIGN
    REAL*8 :: min1
    INTEGER :: abs0
    REAL*8 :: max1
    REAL*8 :: min2
    REAL*8 :: x3
    REAL*8 :: x2
    REAL*8 :: x1
    REAL*8 :: z1
    REAL*8 :: y9
    REAL*8 :: y8
    REAL*8 :: y7
    REAL*8 :: y6
    REAL*8 :: y5
    REAL*8 :: y4
    REAL*8 :: y3
    REAL*8 :: y2
    REAL*8 :: y1
    km1 = km - 1
    it = i2 - i1 + 1
    DO k=2,km
      DO i=i1,i2
        delq(i, k-1) = a4(1, i, k) - a4(1, i, k-1)
        d4(i, k) = delp(i, k-1) + delp(i, k)
      END DO
    END DO
    DO k=2,km1
      DO i=i1,i2
        c1 = (delp(i, k-1)+0.5*delp(i, k))/d4(i, k+1)
        c2 = (delp(i, k+1)+0.5*delp(i, k))/d4(i, k)
        df2(i, k) = delp(i, k)*(c1*delq(i, k)+c2*delq(i, k-1))/(d4(i, k)&
&         +delp(i, k+1))
        IF (df2(i, k) .GE. 0.) THEN
          x1 = df2(i, k)
        ELSE
          x1 = -df2(i, k)
        END IF
        IF (a4(1, i, k-1) .LT. a4(1, i, k)) THEN
          IF (a4(1, i, k) .LT. a4(1, i, k+1)) THEN
            max1 = a4(1, i, k+1)
          ELSE
            max1 = a4(1, i, k)
          END IF
        ELSE IF (a4(1, i, k-1) .LT. a4(1, i, k+1)) THEN
          max1 = a4(1, i, k+1)
        ELSE
          max1 = a4(1, i, k-1)
        END IF
        y1 = max1 - a4(1, i, k)
        IF (a4(1, i, k-1) .GT. a4(1, i, k)) THEN
          IF (a4(1, i, k) .GT. a4(1, i, k+1)) THEN
            min2 = a4(1, i, k+1)
          ELSE
            min2 = a4(1, i, k)
          END IF
        ELSE IF (a4(1, i, k-1) .GT. a4(1, i, k+1)) THEN
          min2 = a4(1, i, k+1)
        ELSE
          min2 = a4(1, i, k-1)
        END IF
        z1 = a4(1, i, k) - min2
        IF (x1 .GT. y1) THEN
          IF (y1 .GT. z1) THEN
            min1 = z1
          ELSE
            min1 = y1
          END IF
        ELSE IF (x1 .GT. z1) THEN
          min1 = z1
        ELSE
          min1 = x1
        END IF
        dc(i, k) = SIGN(min1, df2(i, k))
      END DO
    END DO
!-----------------------------------------------------------
! 4th order interpolation of the provisional cell edge value
!-----------------------------------------------------------
    DO k=3,km1
      DO i=i1,i2
        c1 = delq(i, k-1)*delp(i, k-1)/d4(i, k)
        a1 = d4(i, k-1)/(d4(i, k)+delp(i, k-1))
        a2 = d4(i, k+1)/(d4(i, k)+delp(i, k))
        a4(2, i, k) = a4(1, i, k-1) + c1 + 2./(d4(i, k-1)+d4(i, k+1))*(&
&         delp(i, k)*(c1*(a1-a2)+a2*dc(i, k-1))-delp(i, k-1)*a1*dc(i, k)&
&         )
      END DO
    END DO
    IF (km .GT. 8 .AND. kord .GT. 4) CALL STEEPZ(i1, i2, km, a4, df2, dc&
&                                          , delq, delp, d4)
! Area preserving cubic with 2nd deriv. = 0 at the boundaries
! Top
    DO i=i1,i2
      d1 = delp(i, 1)
      d2 = delp(i, 2)
      qm = (d2*a4(1, i, 1)+d1*a4(1, i, 2))/(d1+d2)
      dq = 2.*(a4(1, i, 2)-a4(1, i, 1))/(d1+d2)
      c1 = 4.*(a4(2, i, 3)-qm-d2*dq)/(d2*(2.*d2*d2+d1*(d2+3.*d1)))
      c3 = dq - 0.5*c1*(d2*(5.*d1+d2)-3.*d1*d1)
      a4(2, i, 2) = qm - 0.25*c1*d1*d2*(d2+3.*d1)
! Top edge:
!-------------------------------------------------------
      a4(2, i, 1) = d1*(2.*c1*d1**2-c3) + a4(2, i, 2)
      IF (a4(1, i, 1) .GT. a4(1, i, 2)) THEN
        y2 = a4(1, i, 2)
      ELSE
        y2 = a4(1, i, 1)
      END IF
      IF (a4(2, i, 2) .LT. y2) THEN
        a4(2, i, 2) = y2
      ELSE
        a4(2, i, 2) = a4(2, i, 2)
      END IF
      IF (a4(1, i, 1) .LT. a4(1, i, 2)) THEN
        y3 = a4(1, i, 2)
      ELSE
        y3 = a4(1, i, 1)
      END IF
      IF (a4(2, i, 2) .GT. y3) THEN
        a4(2, i, 2) = y3
      ELSE
        a4(2, i, 2) = a4(2, i, 2)
      END IF
      dc(i, 1) = 0.5*(a4(2, i, 2)-a4(1, i, 1))
    END DO
! Enforce monotonicity  within the top layer
    IF (iv .EQ. 0) THEN
      DO i=i1,i2
        IF (0. .LT. a4(2, i, 1)) THEN
          a4(2, i, 1) = a4(2, i, 1)
        ELSE
          a4(2, i, 1) = 0.
        END IF
        IF (0. .LT. a4(2, i, 2)) THEN
          a4(2, i, 2) = a4(2, i, 2)
        ELSE
          a4(2, i, 2) = 0.
        END IF
      END DO
    ELSE IF (iv .EQ. -1) THEN
      DO i=i1,i2
        IF (a4(2, i, 1)*a4(1, i, 1) .LE. 0.) a4(2, i, 1) = 0.
      END DO
    ELSE
      IF (iv .GE. 0.) THEN
        abs0 = iv
      ELSE
        abs0 = -iv
      END IF
      IF (abs0 .EQ. 2) THEN
        DO i=i1,i2
          a4(2, i, 1) = a4(1, i, 1)
          a4(3, i, 1) = a4(1, i, 1)
        END DO
      END IF
    END IF
! Bottom
! Area preserving cubic with 2nd deriv. = 0 at the surface
    DO i=i1,i2
      d1 = delp(i, km)
      d2 = delp(i, km1)
      qm = (d2*a4(1, i, km)+d1*a4(1, i, km1))/(d1+d2)
      dq = 2.*(a4(1, i, km1)-a4(1, i, km))/(d1+d2)
      c1 = (a4(2, i, km1)-qm-d2*dq)/(d2*(2.*d2*d2+d1*(d2+3.*d1)))
      c3 = dq - 2.0*c1*(d2*(5.*d1+d2)-3.*d1*d1)
      a4(2, i, km) = qm - c1*d1*d2*(d2+3.*d1)
! Bottom edge:
!-----------------------------------------------------
      a4(3, i, km) = d1*(8.*c1*d1**2-c3) + a4(2, i, km)
      IF (a4(1, i, km) .GT. a4(1, i, km1)) THEN
        y4 = a4(1, i, km1)
      ELSE
        y4 = a4(1, i, km)
      END IF
      IF (a4(2, i, km) .LT. y4) THEN
        a4(2, i, km) = y4
      ELSE
        a4(2, i, km) = a4(2, i, km)
      END IF
      IF (a4(1, i, km) .LT. a4(1, i, km1)) THEN
        y5 = a4(1, i, km1)
      ELSE
        y5 = a4(1, i, km)
      END IF
      IF (a4(2, i, km) .GT. y5) THEN
        a4(2, i, km) = y5
      ELSE
        a4(2, i, km) = a4(2, i, km)
      END IF
      dc(i, km) = 0.5*(a4(1, i, km)-a4(2, i, km))
    END DO
! Enforce constraint on the "slope" at the surface
!#ifdef BOT_MONO
!      do i=i1,i2
!         a4(4,i,km) = 0
!         if( a4(3,i,km) * a4(1,i,km) <= 0. ) a4(3,i,km) = 0.
!         d1 = a4(1,i,km) - a4(2,i,km)
!         d2 = a4(3,i,km) - a4(1,i,km)
!         if ( d1*d2 < 0. ) then
!              a4(2,i,km) = a4(1,i,km)
!              a4(3,i,km) = a4(1,i,km)
!         else
!              dq = sign(min(abs(d1),abs(d2),0.5*abs(delq(i,km-1))), d1)
!              a4(2,i,km) = a4(1,i,km) - dq
!              a4(3,i,km) = a4(1,i,km) + dq
!         endif
!      enddo
!#else
    IF (iv .EQ. 0) THEN
      DO i=i1,i2
        IF (0. .LT. a4(2, i, km)) THEN
          a4(2, i, km) = a4(2, i, km)
        ELSE
          a4(2, i, km) = 0.
        END IF
        IF (0. .LT. a4(3, i, km)) THEN
          a4(3, i, km) = a4(3, i, km)
        ELSE
          a4(3, i, km) = 0.
        END IF
      END DO
    ELSE IF (iv .LT. 0) THEN
      DO i=i1,i2
        IF (a4(1, i, km)*a4(3, i, km) .LE. 0.) a4(3, i, km) = 0.
      END DO
    END IF
!#endif
    DO k=1,km1
      DO i=i1,i2
        a4(3, i, k) = a4(2, i, k+1)
      END DO
    END DO
!-----------------------------------------------------------
! f(s) = AL + s*[(AR-AL) + A6*(1-s)]         ( 0 <= s  <= 1 )
!-----------------------------------------------------------
! Top 2 and bottom 2 layers always use monotonic mapping
    DO k=1,2
      DO i=i1,i2
        a4(4, i, k) = 3.*(2.*a4(1, i, k)-(a4(2, i, k)+a4(3, i, k)))
      END DO
      CALL PPM_LIMITERS(dc(i1, k), a4(1, i1, k), it, 0)
    END DO
    IF (kord .GE. 7) THEN
!-----------------------
! Huynh's 2nd constraint
!-----------------------
      DO k=2,km1
        DO i=i1,i2
! Method#1
!           h2(i,k) = delq(i,k) - delq(i,k-1)
! Method#2 - better
          h2(i, k) = 2.*(dc(i, k+1)/delp(i, k+1)-dc(i, k-1)/delp(i, k-1)&
&           )/(delp(i, k)+0.5*(delp(i, k-1)+delp(i, k+1)))*delp(i, k)**2
        END DO
      END DO
! Method#3
!!!            h2(i,k) = dc(i,k+1) - dc(i,k-1)
! original quasi-monotone
      fac = 1.5
      DO k=3,km-2
        DO i=i1,i2
! Right edges
!        qmp   = a4(1,i,k) + 2.0*delq(i,k-1)
!        lac   = a4(1,i,k) + fac*h2(i,k-1) + 0.5*delq(i,k-1)
!
          pmp = 2.*dc(i, k)
          qmp = a4(1, i, k) + pmp
          lac = a4(1, i, k) + fac*h2(i, k-1) + dc(i, k)
          IF (a4(1, i, k) .GT. qmp) THEN
            IF (qmp .GT. lac) THEN
              y8 = lac
            ELSE
              y8 = qmp
            END IF
          ELSE IF (a4(1, i, k) .GT. lac) THEN
            y8 = lac
          ELSE
            y8 = a4(1, i, k)
          END IF
          IF (a4(3, i, k) .LT. y8) THEN
            x2 = y8
          ELSE
            x2 = a4(3, i, k)
          END IF
          IF (a4(1, i, k) .LT. qmp) THEN
            IF (qmp .LT. lac) THEN
              y6 = lac
            ELSE
              y6 = qmp
            END IF
          ELSE IF (a4(1, i, k) .LT. lac) THEN
            y6 = lac
          ELSE
            y6 = a4(1, i, k)
          END IF
          IF (x2 .GT. y6) THEN
            a4(3, i, k) = y6
          ELSE
            a4(3, i, k) = x2
          END IF
! Left  edges
!        qmp   = a4(1,i,k) - 2.0*delq(i,k)
!        lac   = a4(1,i,k) + fac*h2(i,k+1) - 0.5*delq(i,k)
!
          qmp = a4(1, i, k) - pmp
          lac = a4(1, i, k) + fac*h2(i, k+1) - dc(i, k)
          IF (a4(1, i, k) .GT. qmp) THEN
            IF (qmp .GT. lac) THEN
              y9 = lac
            ELSE
              y9 = qmp
            END IF
          ELSE IF (a4(1, i, k) .GT. lac) THEN
            y9 = lac
          ELSE
            y9 = a4(1, i, k)
          END IF
          IF (a4(2, i, k) .LT. y9) THEN
            x3 = y9
          ELSE
            x3 = a4(2, i, k)
          END IF
          IF (a4(1, i, k) .LT. qmp) THEN
            IF (qmp .LT. lac) THEN
              y7 = lac
            ELSE
              y7 = qmp
            END IF
          ELSE IF (a4(1, i, k) .LT. lac) THEN
            y7 = lac
          ELSE
            y7 = a4(1, i, k)
          END IF
          IF (x3 .GT. y7) THEN
            a4(2, i, k) = y7
          ELSE
            a4(2, i, k) = x3
          END IF
!-------------
! Recompute A6
!-------------
          a4(4, i, k) = 3.*(2.*a4(1, i, k)-(a4(2, i, k)+a4(3, i, k)))
        END DO
! Additional constraint to ensure positivity when kord=7
        IF (iv .EQ. 0 .AND. kord .GE. 6) CALL PPM_LIMITERS(dc(i1, k), a4&
&                                                    (1, i1, k), it, 2)
      END DO
    ELSE
      lmt = kord - 3
      IF (0 .LT. lmt) THEN
        lmt = lmt
      ELSE
        lmt = 0
      END IF
      IF (iv .EQ. 0) THEN
        IF (2 .GT. lmt) THEN
          lmt = lmt
        ELSE
          lmt = 2
        END IF
      END IF
      DO k=3,km-2
        IF (kord .NE. 4) THEN
          DO i=i1,i2
            a4(4, i, k) = 3.*(2.*a4(1, i, k)-(a4(2, i, k)+a4(3, i, k)))
          END DO
        END IF
        IF (kord .NE. 6) CALL PPM_LIMITERS(dc(i1, k), a4(1, i1, k), it, &
&                                    lmt)
      END DO
    END IF
    DO k=km1,km
      DO i=i1,i2
        a4(4, i, k) = 3.*(2.*a4(1, i, k)-(a4(2, i, k)+a4(3, i, k)))
      END DO
      CALL PPM_LIMITERS(dc(i1, k), a4(1, i1, k), it, 0)
    END DO
  END SUBROUTINE PPM_PROFILE
  SUBROUTINE PPM_LIMITERS(dm, a4, itot, lmt)
    IMPLICIT NONE
! !INPUT PARAMETERS:
! the linear slope
    REAL(real8), INTENT(IN) :: dm(*)
! Total Longitudes
    INTEGER, INTENT(IN) :: itot
! 0: Standard PPM constraint
    INTEGER, INTENT(IN) :: lmt
! 1: Improved full monotonicity constraint (Lin)
! 2: Positive definite constraint
! 3: do nothing (return immediately)
! !INPUT/OUTPUT PARAMETERS:
! PPM array
    REAL(real8), INTENT(INOUT) :: a4(4, *)
! AA <-- a4(1,i)
! AL <-- a4(2,i)
! AR <-- a4(3,i)
! A6 <-- a4(4,i)
! !LOCAL VARIABLES:
    REAL(real8) :: qmp
    REAL(real8) :: da1, da2, a6da
    REAL(real8) :: fmin
    INTEGER :: i
    INTRINSIC ABS
    INTRINSIC MIN
    INTRINSIC SIGN
    REAL*8 :: min1
    REAL*8 :: min2
    REAL*8 :: abs0
    REAL*8 :: x2
    REAL*8 :: x1
    REAL*8 :: y2
    REAL*8 :: y1
! Developer: S.-J. Lin
    IF (lmt .EQ. 3) THEN
      RETURN
    ELSE IF (lmt .EQ. 0) THEN
! Standard PPM constraint
      DO i=1,itot
        IF (dm(i) .EQ. 0.) THEN
          a4(2, i) = a4(1, i)
          a4(3, i) = a4(1, i)
          a4(4, i) = 0.
        ELSE
          da1 = a4(3, i) - a4(2, i)
          da2 = da1**2
          a6da = a4(4, i)*da1
          IF (a6da .LT. -da2) THEN
            a4(4, i) = 3.*(a4(2, i)-a4(1, i))
            a4(3, i) = a4(2, i) - a4(4, i)
          ELSE IF (a6da .GT. da2) THEN
            a4(4, i) = 3.*(a4(3, i)-a4(1, i))
            a4(2, i) = a4(3, i) - a4(4, i)
          END IF
        END IF
      END DO
    ELSE IF (lmt .EQ. 1) THEN
! Improved full monotonicity constraint (Lin 2004)
! Note: no need to provide first guess of A6 <-- a4(4,i)
      DO i=1,itot
        qmp = 2.*dm(i)
        IF (qmp .GE. 0.) THEN
          x1 = qmp
        ELSE
          x1 = -qmp
        END IF
        IF (a4(2, i) - a4(1, i) .GE. 0.) THEN
          y1 = a4(2, i) - a4(1, i)
        ELSE
          y1 = -(a4(2, i)-a4(1, i))
        END IF
        IF (x1 .GT. y1) THEN
          min1 = y1
        ELSE
          min1 = x1
        END IF
        a4(2, i) = a4(1, i) - SIGN(min1, qmp)
        IF (qmp .GE. 0.) THEN
          x2 = qmp
        ELSE
          x2 = -qmp
        END IF
        IF (a4(3, i) - a4(1, i) .GE. 0.) THEN
          y2 = a4(3, i) - a4(1, i)
        ELSE
          y2 = -(a4(3, i)-a4(1, i))
        END IF
        IF (x2 .GT. y2) THEN
          min2 = y2
        ELSE
          min2 = x2
        END IF
        a4(3, i) = a4(1, i) + SIGN(min2, qmp)
        a4(4, i) = 3.*(2.*a4(1, i)-(a4(2, i)+a4(3, i)))
      END DO
    ELSE IF (lmt .EQ. 2) THEN
! Positive definite constraint
      DO i=1,itot
        IF (a4(3, i) - a4(2, i) .GE. 0.) THEN
          abs0 = a4(3, i) - a4(2, i)
        ELSE
          abs0 = -(a4(3, i)-a4(2, i))
        END IF
        IF (abs0 .LT. -a4(4, i)) THEN
          fmin = a4(1, i) + 0.25*(a4(3, i)-a4(2, i))**2/a4(4, i) + a4(4&
&           , i)*r12
          IF (fmin .LT. 0.) THEN
            IF (a4(1, i) .LT. a4(3, i) .AND. a4(1, i) .LT. a4(2, i)) &
&           THEN
              a4(3, i) = a4(1, i)
              a4(2, i) = a4(1, i)
              a4(4, i) = 0.
            ELSE IF (a4(3, i) .GT. a4(2, i)) THEN
              a4(4, i) = 3.*(a4(2, i)-a4(1, i))
              a4(3, i) = a4(2, i) - a4(4, i)
            ELSE
              a4(4, i) = 3.*(a4(3, i)-a4(1, i))
              a4(2, i) = a4(3, i) - a4(4, i)
            END IF
          END IF
        END IF
      END DO
    END IF
  END SUBROUTINE PPM_LIMITERS
  SUBROUTINE STEEPZ(i1, i2, km, a4, df2, dm, dq, dp, d4)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: km, i1, i2
! grid size
    REAL(real8), INTENT(IN) :: dp(i1:i2, km)
! backward diff of q
    REAL(real8), INTENT(IN) :: dq(i1:i2, km)
! backward sum:  dp(k)+ dp(k-1) 
    REAL(real8), INTENT(IN) :: d4(i1:i2, km)
! first guess mismatch
    REAL(real8), INTENT(IN) :: df2(i1:i2, km)
! monotonic mismatch
    REAL(real8), INTENT(IN) :: dm(i1:i2, km)
! !INPUT/OUTPUT PARAMETERS:
! first guess/steepened
    REAL(real8), INTENT(INOUT) :: a4(4, i1:i2, km)
! !LOCAL VARIABLES:
    INTEGER :: i, k
    REAL(real8) :: alfa(i1:i2, km)
    REAL(real8) :: f(i1:i2, km)
    REAL(real8) :: rat(i1:i2, km)
    REAL(real8) :: dg2
    INTRINSIC MIN
    INTRINSIC MAX
    REAL*8 :: y1
! Compute ratio of dq/dp
    DO k=2,km
      DO i=i1,i2
        rat(i, k) = dq(i, k-1)/d4(i, k)
      END DO
    END DO
! Compute F
    DO k=2,km-1
      DO i=i1,i2
        f(i, k) = (rat(i, k+1)-rat(i, k))/(dp(i, k-1)+dp(i, k)+dp(i, k+1&
&         ))
      END DO
    END DO
    DO k=3,km-2
      DO i=i1,i2
        IF (f(i, k+1)*f(i, k-1) .LT. 0. .AND. df2(i, k) .NE. 0.) THEN
          dg2 = (f(i, k+1)-f(i, k-1))*((dp(i, k+1)-dp(i, k-1))**2+d4(i, &
&           k)*d4(i, k+1))
          IF (0.5 .GT. -(0.1875*dg2/df2(i, k))) THEN
            y1 = -(0.1875*dg2/df2(i, k))
          ELSE
            y1 = 0.5
          END IF
          IF (0. .LT. y1) THEN
            alfa(i, k) = y1
          ELSE
            alfa(i, k) = 0.
          END IF
        ELSE
          alfa(i, k) = 0.
        END IF
      END DO
    END DO
    DO k=4,km-2
      DO i=i1,i2
        a4(2, i, k) = (1.-alfa(i, k-1)-alfa(i, k))*a4(2, i, k) + alfa(i&
&         , k-1)*(a4(1, i, k)-dm(i, k)) + alfa(i, k)*(a4(1, i, k-1)+dm(i&
&         , k-1))
      END DO
    END DO
  END SUBROUTINE STEEPZ
END MODULE FV_MAPZ_MOD_D
