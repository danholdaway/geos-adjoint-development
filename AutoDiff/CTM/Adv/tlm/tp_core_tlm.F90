!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
MODULE TP_CORE_MOD_D
!BOP
!
! !MODULE: tp_core --- A collection of routines to support FV transport
!
  USE FV_ARRAYS_MOD, ONLY : fvprc, real4, real8, cnvt
  USE FV_MP_MOD_D, ONLY : is, js, ie, je, ng, isd, jsd, ied, jed
  USE FV_GRID_UTILS_MOD_D, ONLY : sw_corner, se_corner, ne_corner, &
& nw_corner, sin_sg => sin_sg, da_min => da_min, big_number_r8 => &
& big_number
  USE FV_GRID_TOOLS_MOD_D, ONLY : grid_type, dx => dx, dy => dy, rdxc =>&
& rdxc, rdyc => rdyc, dxa => dxa, dya => dya, area => area, rarea => &
& rarea
  IMPLICIT NONE
  PRIVATE 
  PUBLIC fv_tp_2d, pert_ppm, copy_corners
  PUBLIC fv_tp_2d_tlm, copy_corners_tlm
!#ifdef MAPL_MODE
  LOGICAL, PARAMETER :: nested=.false.
!#endif
  REAL(fvprc), PARAMETER :: r3=1./3.
  REAL(fvprc), PARAMETER :: near_zero=1.e-25
  REAL(fvprc), PARAMETER :: ppm_limiter=2.0
  REAL(fvprc), PARAMETER :: big_number=big_number_r8
!#ifdef WAVE_FORM
!! Suresh & Huynh scheme 2.2 (purtabation form)
!! The wave-form is more diffusive than scheme 2.1
! real(FVPRC), parameter:: b1 =   0.0375
! real(FVPRC), parameter:: b2 =  -7./30.
! real(FVPRC), parameter:: b3 =  -23./120.
! real(FVPRC), parameter:: b4 =  13./30.
! real(FVPRC), parameter:: b5 = -11./240.
!#else
! scheme 2.1: perturbation form
  REAL(fvprc), PARAMETER :: b1=1./30.
  REAL(fvprc), PARAMETER :: b2=-(13./60.)
  REAL(fvprc), PARAMETER :: b3=-(13./60.)
  REAL(fvprc), PARAMETER :: b4=0.45
  REAL(fvprc), PARAMETER :: b5=-0.05
!#endif
  REAL(fvprc), PARAMETER :: t11=27./28., t12=-(13./28.), t13=3./7.
  REAL(fvprc), PARAMETER :: s11=11./14., s14=4./7., s15=3./14.
!----------------------------------------------------
! volume-conserving cubic with 2nd drv=0 at end point:
!----------------------------------------------------
! Non-monotonic
  REAL(fvprc), PARAMETER :: c1=-(2./14.)
  REAL(fvprc), PARAMETER :: c2=11./14.
  REAL(fvprc), PARAMETER :: c3=5./14.
!----------------------
! PPM volume mean form:
!----------------------
! 0.58333333
  REAL(fvprc), PARAMETER :: p1=7./12.
  REAL(fvprc), PARAMETER :: p2=-(1./12.)
!#ifdef SINGLE_FV
!   MODULE PROCEDURE fv_tp_2d_r8
!#endif
  INTERFACE FV_TP_2D
      MODULE PROCEDURE FV_TP_2D_R4
  END INTERFACE

  INTERFACE FV_TP_2D_TLM
      MODULE PROCEDURE FV_TP_2D_R4_TLM
  END INTERFACE

  INTERFACE COPY_CORNERS
      MODULE PROCEDURE COPY_CORNERS_R4
      MODULE PROCEDURE COPY_CORNERS_R8
  END INTERFACE

  INTERFACE COPY_CORNERS_TLM
      MODULE PROCEDURE COPY_CORNERS_R8_TLM
  END INTERFACE


CONTAINS
!  Differentiation of fv_tp_2d_r4 in forward (tangent) mode:
!   variations   of useful results: q fx fy
!   with respect to varying inputs: q fx fy
!
! !DESCRIPTION:
!
! !REVISION HISTORY:
!
!EOP
!-----------------------------------------------------------------------
!#ifdef SINGLE_FV
! subroutine fv_tp_2d_r8(qIN, crx, cry, npx, npy, hord, fx, fy, xfx, yfx,  &
!                     ra_x, ra_y, mfx, mfy, mass, nord, damp_c)
!   integer, intent(in):: npx, npy
!   integer, intent(in)::hord
!
!   real(FVPRC), intent(in)::  crx(is:ie+1,jsd:jed)  !
!   real(FVPRC), intent(in)::  xfx(is:ie+1,jsd:jed)  !
!   real(FVPRC), intent(in)::  cry(isd:ied,js:je+1 )  !
!   real(FVPRC), intent(in)::  yfx(isd:ied,js:je+1 )  !
!   real(FVPRC), intent(in):: ra_x(is:ie,jsd:jed)
!   real(FVPRC), intent(in):: ra_y(isd:ied,js:je)
!   real(REAL8), intent(in)::  qIN(isd:ied,jsd:jed)  ! transported scalar
!   real(FVPRC), intent(out)::fx(is:ie+1 ,js:je)    ! Flux in x ( E )
!   real(FVPRC), intent(out)::fy(is:ie,   js:je+1 )    ! Flux in y ( N )
!! optional Arguments:
!   real(FVPRC), OPTIONAL, intent(in):: mfx(is:ie+1,js:je  )  ! Mass Flux X-Dir
!   real(FVPRC), OPTIONAL, intent(in):: mfy(is:ie  ,js:je+1)  ! Mass Flux Y-Dir
!   real(FVPRC), OPTIONAL, intent(in):: mass(isd:ied,jsd:jed)
!   real(FVPRC), OPTIONAL, intent(in):: damp_c
!   integer, OPTIONAL, intent(in):: nord
!! Local:
!   real(FVPRC)   q(isd:ied,jsd:jed)
!   q = CNVT(qIN)
!   call fv_tp_2d(q, crx, cry, npx, npy, hord, fx, fy, xfx, yfx,  &
!                     ra_x, ra_y, mfx=mfx, mfy=mfy, mass=mass, nord=nord, damp_c=damp_c)
! end subroutine fv_tp_2d_r8
!#endif
  SUBROUTINE FV_TP_2D_R4_TLM(q, q_tl, crx, cry, npx, npy, hord, fx, &
&   fx_tl, fy, fy_tl, xfx, yfx, ra_x, ra_y, mfx, mfy, mass, nord, damp_c&
& )
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy
    INTEGER, INTENT(IN) :: hord
!
    REAL(fvprc), INTENT(IN) :: crx(is:ie+1, jsd:jed)
!
    REAL(fvprc), INTENT(IN) :: xfx(is:ie+1, jsd:jed)
!
    REAL(fvprc), INTENT(IN) :: cry(isd:ied, js:je+1)
!
    REAL(fvprc), INTENT(IN) :: yfx(isd:ied, js:je+1)
    REAL(fvprc), INTENT(IN) :: ra_x(is:ie, jsd:jed)
    REAL(fvprc), INTENT(IN) :: ra_y(isd:ied, js:je)
! transported scalar
    REAL(fvprc), INTENT(INOUT) :: q(isd:ied, jsd:jed)
    REAL(fvprc), INTENT(INOUT) :: q_tl(isd:ied, jsd:jed)
! Flux in x ( E )
    REAL(fvprc), INTENT(OUT) :: fx(is:ie+1, js:je)
    REAL(fvprc), INTENT(OUT) :: fx_tl(is:ie+1, js:je)
! Flux in y ( N )
    REAL(fvprc), INTENT(OUT) :: fy(is:ie, js:je+1)
    REAL(fvprc), INTENT(OUT) :: fy_tl(is:ie, js:je+1)
! optional Arguments:
! Mass Flux X-Dir
    REAL(fvprc), OPTIONAL, INTENT(IN) :: mfx(is:ie+1, js:je)
! Mass Flux Y-Dir
    REAL(fvprc), OPTIONAL, INTENT(IN) :: mfy(is:ie, js:je+1)
    REAL(fvprc), OPTIONAL, INTENT(IN) :: mass(isd:ied, jsd:jed)
    REAL(fvprc), OPTIONAL, INTENT(IN) :: damp_c
    INTEGER, OPTIONAL, INTENT(IN) :: nord
! Local:
    INTEGER :: ord_in, ord_ou
    REAL(fvprc) :: q_i(isd:ied, js:je)
    REAL(fvprc) :: q_i_tl(isd:ied, js:je)
    REAL(fvprc) :: q_j(is:ie, jsd:jed)
    REAL(fvprc) :: q_j_tl(is:ie, jsd:jed)
    REAL(fvprc) :: fx1(is:ie+1, js:je)
    REAL(fvprc) :: fx1_tl(is:ie+1, js:je)
    REAL(fvprc) :: fy1(is:ie, js:je+1)
    REAL(fvprc) :: fy1_tl(is:ie, js:je+1)
    REAL(fvprc) :: fx2(is:ie+1, jsd:jed)
    REAL(fvprc) :: fx2_tl(is:ie+1, jsd:jed)
    REAL(fvprc) :: fy2(isd:ied, js:je+1)
    REAL(fvprc) :: fy2_tl(isd:ied, js:je+1)
    REAL(fvprc) :: fyy(isd:ied, js:je+1)
    REAL(fvprc) :: fyy_tl(isd:ied, js:je+1)
    REAL(fvprc) :: fxx(is:ie+1)
    REAL(fvprc) :: fxx_tl(is:ie+1)
    REAL(fvprc) :: damp
    INTEGER :: i, j
    INTRINSIC PRESENT
    REAL(fvprc) :: pwx1
    INTEGER :: pwy1
    ord_in = hord
    ord_ou = hord
    CALL COPY_CORNERS_TLM(q, q_tl, npx, npy, 2)
    IF (ord_in .LT. 0) THEN
      CALL YPPM0_TLM(fy2, fy2_tl, q, q_tl, cry, ord_in, isd, ied, js, je&
&              , npx, npy)
      fyy_tl = 0.0_8
    ELSE
      CALL YTP_TLM(fy2, fy2_tl, q, q_tl, cry, ord_in, isd, ied, js, je, &
&            npx, npy)
      fyy_tl = 0.0_8
    END IF
    DO j=js,je+1
      DO i=isd,ied
        fyy_tl(i, j) = yfx(i, j)*fy2_tl(i, j)
        fyy(i, j) = yfx(i, j)*fy2(i, j)
      END DO
    END DO
    q_i_tl = 0.0_8
    DO j=js,je
      DO i=isd,ied
        q_i_tl(i, j) = (area(i, j)*q_tl(i, j)+fyy_tl(i, j)-fyy_tl(i, j+1&
&         ))/ra_y(i, j)
        q_i(i, j) = (q(i, j)*area(i, j)+fyy(i, j)-fyy(i, j+1))/ra_y(i, j&
&         )
      END DO
    END DO
    IF (ord_ou .LT. 0) THEN
      CALL XPPM0_TLM(fx1, fx1_tl, q_i, q_i_tl, crx(is, js), ord_ou, is, &
&              ie, js, je, npx, npy)
    ELSE
      CALL XTP_TLM(fx1, fx1_tl, q_i, q_i_tl, crx(is, js), ord_ou, is, ie&
&            , js, je, npx, npy)
    END IF
    CALL COPY_CORNERS_TLM(q, q_tl, npx, npy, 1)
    IF (ord_in .LT. 0) THEN
      CALL XPPM0_TLM(fx2, fx2_tl, q, q_tl, crx, ord_in, is, ie, jsd, jed&
&              , npx, npy)
      q_j_tl = 0.0_8
      fxx_tl = 0.0_8
    ELSE
      CALL XTP_TLM(fx2, fx2_tl, q, q_tl, crx, ord_in, is, ie, jsd, jed, &
&            npx, npy)
      q_j_tl = 0.0_8
      fxx_tl = 0.0_8
    END IF
    DO j=jsd,jed
      DO i=is,ie+1
        fxx_tl(i) = xfx(i, j)*fx2_tl(i, j)
        fxx(i) = xfx(i, j)*fx2(i, j)
      END DO
      DO i=is,ie
        q_j_tl(i, j) = (area(i, j)*q_tl(i, j)+fxx_tl(i)-fxx_tl(i+1))/&
&         ra_x(i, j)
        q_j(i, j) = (q(i, j)*area(i, j)+fxx(i)-fxx(i+1))/ra_x(i, j)
      END DO
    END DO
    IF (ord_ou .LT. 0) THEN
      CALL YPPM0_TLM(fy1, fy1_tl, q_j, q_j_tl, cry, ord_ou, is, ie, js, &
&              je, npx, npy)
    ELSE
      CALL YTP_TLM(fy1, fy1_tl, q_j, q_j_tl, cry, ord_ou, is, ie, js, je&
&            , npx, npy)
    END IF
!----------------
! Flux averaging:
!----------------
    IF (PRESENT(mfx) .AND. PRESENT(mfy)) THEN
!---------------------------------
! For transport of pt and tracers
!---------------------------------
      DO j=js,je
        DO i=is,ie+1
          fx_tl(i, j) = 0.5*mfx(i, j)*(fx1_tl(i, j)+fx2_tl(i, j))
          fx(i, j) = 0.5*(fx1(i, j)+fx2(i, j))*mfx(i, j)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          fy_tl(i, j) = 0.5*mfy(i, j)*(fy1_tl(i, j)+fy2_tl(i, j))
          fy(i, j) = 0.5*(fy1(i, j)+fy2(i, j))*mfy(i, j)
        END DO
      END DO
      IF (PRESENT(nord) .AND. PRESENT(damp_c) .AND. PRESENT(mass)) THEN
        IF (damp_c .GT. 1.e-4) THEN
          pwx1 = damp_c*da_min
          pwy1 = nord + 1
          damp = pwx1**pwy1
          CALL DELN_FLUX_TLM(nord, npx, npy, damp, q, q_tl, fx, fx_tl, &
&                      fy, fy_tl, mass)
        END IF
      END IF
    ELSE
!---------------------------------
! For transport of delp, vorticity
!---------------------------------
      DO j=js,je
        DO i=is,ie+1
          fx_tl(i, j) = 0.5*xfx(i, j)*(fx1_tl(i, j)+fx2_tl(i, j))
          fx(i, j) = 0.5*(fx1(i, j)+fx2(i, j))*xfx(i, j)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          fy_tl(i, j) = 0.5*yfx(i, j)*(fy1_tl(i, j)+fy2_tl(i, j))
          fy(i, j) = 0.5*(fy1(i, j)+fy2(i, j))*yfx(i, j)
        END DO
      END DO
      IF (PRESENT(nord) .AND. PRESENT(damp_c)) THEN
        IF (damp_c .GT. 1.e-4) THEN
          pwx1 = damp_c*da_min
          pwy1 = nord + 1
          damp = pwx1**pwy1
          CALL DELN_FLUX_TLM(nord, npx, npy, damp, q, q_tl, fx, fx_tl, &
&                      fy, fy_tl)
        END IF
      END IF
    END IF
  END SUBROUTINE FV_TP_2D_R4_TLM
!
! !DESCRIPTION:
!
! !REVISION HISTORY:
!
!EOP
!-----------------------------------------------------------------------
!#ifdef SINGLE_FV
! subroutine fv_tp_2d_r8(qIN, crx, cry, npx, npy, hord, fx, fy, xfx, yfx,  &
!                     ra_x, ra_y, mfx, mfy, mass, nord, damp_c)
!   integer, intent(in):: npx, npy
!   integer, intent(in)::hord
!
!   real(FVPRC), intent(in)::  crx(is:ie+1,jsd:jed)  !
!   real(FVPRC), intent(in)::  xfx(is:ie+1,jsd:jed)  !
!   real(FVPRC), intent(in)::  cry(isd:ied,js:je+1 )  !
!   real(FVPRC), intent(in)::  yfx(isd:ied,js:je+1 )  !
!   real(FVPRC), intent(in):: ra_x(is:ie,jsd:jed)
!   real(FVPRC), intent(in):: ra_y(isd:ied,js:je)
!   real(REAL8), intent(in)::  qIN(isd:ied,jsd:jed)  ! transported scalar
!   real(FVPRC), intent(out)::fx(is:ie+1 ,js:je)    ! Flux in x ( E )
!   real(FVPRC), intent(out)::fy(is:ie,   js:je+1 )    ! Flux in y ( N )
!! optional Arguments:
!   real(FVPRC), OPTIONAL, intent(in):: mfx(is:ie+1,js:je  )  ! Mass Flux X-Dir
!   real(FVPRC), OPTIONAL, intent(in):: mfy(is:ie  ,js:je+1)  ! Mass Flux Y-Dir
!   real(FVPRC), OPTIONAL, intent(in):: mass(isd:ied,jsd:jed)
!   real(FVPRC), OPTIONAL, intent(in):: damp_c
!   integer, OPTIONAL, intent(in):: nord
!! Local:
!   real(FVPRC)   q(isd:ied,jsd:jed)
!   q = CNVT(qIN)
!   call fv_tp_2d(q, crx, cry, npx, npy, hord, fx, fy, xfx, yfx,  &
!                     ra_x, ra_y, mfx=mfx, mfy=mfy, mass=mass, nord=nord, damp_c=damp_c)
! end subroutine fv_tp_2d_r8
!#endif
  SUBROUTINE FV_TP_2D_R4(q, crx, cry, npx, npy, hord, fx, fy, xfx, yfx, &
&   ra_x, ra_y, mfx, mfy, mass, nord, damp_c)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy
    INTEGER, INTENT(IN) :: hord
!
    REAL(fvprc), INTENT(IN) :: crx(is:ie+1, jsd:jed)
!
    REAL(fvprc), INTENT(IN) :: xfx(is:ie+1, jsd:jed)
!
    REAL(fvprc), INTENT(IN) :: cry(isd:ied, js:je+1)
!
    REAL(fvprc), INTENT(IN) :: yfx(isd:ied, js:je+1)
    REAL(fvprc), INTENT(IN) :: ra_x(is:ie, jsd:jed)
    REAL(fvprc), INTENT(IN) :: ra_y(isd:ied, js:je)
! transported scalar
    REAL(fvprc), INTENT(INOUT) :: q(isd:ied, jsd:jed)
! Flux in x ( E )
    REAL(fvprc), INTENT(OUT) :: fx(is:ie+1, js:je)
! Flux in y ( N )
    REAL(fvprc), INTENT(OUT) :: fy(is:ie, js:je+1)
! optional Arguments:
! Mass Flux X-Dir
    REAL(fvprc), OPTIONAL, INTENT(IN) :: mfx(is:ie+1, js:je)
! Mass Flux Y-Dir
    REAL(fvprc), OPTIONAL, INTENT(IN) :: mfy(is:ie, js:je+1)
    REAL(fvprc), OPTIONAL, INTENT(IN) :: mass(isd:ied, jsd:jed)
    REAL(fvprc), OPTIONAL, INTENT(IN) :: damp_c
    INTEGER, OPTIONAL, INTENT(IN) :: nord
! Local:
    INTEGER :: ord_in, ord_ou
    REAL(fvprc) :: q_i(isd:ied, js:je)
    REAL(fvprc) :: q_j(is:ie, jsd:jed)
    REAL(fvprc) :: fx1(is:ie+1, js:je)
    REAL(fvprc) :: fy1(is:ie, js:je+1)
    REAL(fvprc) :: fx2(is:ie+1, jsd:jed)
    REAL(fvprc) :: fy2(isd:ied, js:je+1)
    REAL(fvprc) :: fyy(isd:ied, js:je+1)
    REAL(fvprc) :: fxx(is:ie+1)
    REAL(fvprc) :: damp
    INTEGER :: i, j
    INTRINSIC PRESENT
    REAL(fvprc) :: pwx1
    INTEGER :: pwy1
    ord_in = hord
    ord_ou = hord
    CALL COPY_CORNERS(q, npx, npy, 2)
    IF (ord_in .LT. 0) THEN
      CALL YPPM0(fy2, q, cry, ord_in, isd, ied, js, je, npx, npy)
    ELSE
      CALL YTP(fy2, q, cry, ord_in, isd, ied, js, je, npx, npy)
    END IF
    DO j=js,je+1
      DO i=isd,ied
        fyy(i, j) = yfx(i, j)*fy2(i, j)
      END DO
    END DO
    DO j=js,je
      DO i=isd,ied
        q_i(i, j) = (q(i, j)*area(i, j)+fyy(i, j)-fyy(i, j+1))/ra_y(i, j&
&         )
      END DO
    END DO
    IF (ord_ou .LT. 0) THEN
      CALL XPPM0(fx1, q_i, crx(is, js), ord_ou, is, ie, js, je, npx, npy&
&         )
    ELSE
      CALL XTP(fx1, q_i, crx(is, js), ord_ou, is, ie, js, je, npx, npy)
    END IF
    CALL COPY_CORNERS(q, npx, npy, 1)
    IF (ord_in .LT. 0) THEN
      CALL XPPM0(fx2, q, crx, ord_in, is, ie, jsd, jed, npx, npy)
    ELSE
      CALL XTP(fx2, q, crx, ord_in, is, ie, jsd, jed, npx, npy)
    END IF
    DO j=jsd,jed
      DO i=is,ie+1
        fxx(i) = xfx(i, j)*fx2(i, j)
      END DO
      DO i=is,ie
        q_j(i, j) = (q(i, j)*area(i, j)+fxx(i)-fxx(i+1))/ra_x(i, j)
      END DO
    END DO
    IF (ord_ou .LT. 0) THEN
      CALL YPPM0(fy1, q_j, cry, ord_ou, is, ie, js, je, npx, npy)
    ELSE
      CALL YTP(fy1, q_j, cry, ord_ou, is, ie, js, je, npx, npy)
    END IF
!----------------
! Flux averaging:
!----------------
    IF (PRESENT(mfx) .AND. PRESENT(mfy)) THEN
!---------------------------------
! For transport of pt and tracers
!---------------------------------
      DO j=js,je
        DO i=is,ie+1
          fx(i, j) = 0.5*(fx1(i, j)+fx2(i, j))*mfx(i, j)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          fy(i, j) = 0.5*(fy1(i, j)+fy2(i, j))*mfy(i, j)
        END DO
      END DO
      IF (PRESENT(nord) .AND. PRESENT(damp_c) .AND. PRESENT(mass)) THEN
        IF (damp_c .GT. 1.e-4) THEN
          pwx1 = damp_c*da_min
          pwy1 = nord + 1
          damp = pwx1**pwy1
          CALL DELN_FLUX(nord, npx, npy, damp, q, fx, fy, mass)
        END IF
      END IF
    ELSE
!---------------------------------
! For transport of delp, vorticity
!---------------------------------
      DO j=js,je
        DO i=is,ie+1
          fx(i, j) = 0.5*(fx1(i, j)+fx2(i, j))*xfx(i, j)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          fy(i, j) = 0.5*(fy1(i, j)+fy2(i, j))*yfx(i, j)
        END DO
      END DO
      IF (PRESENT(nord) .AND. PRESENT(damp_c)) THEN
        IF (damp_c .GT. 1.e-4) THEN
          pwx1 = damp_c*da_min
          pwy1 = nord + 1
          damp = pwx1**pwy1
          CALL DELN_FLUX(nord, npx, npy, damp, q, fx, fy)
        END IF
      END IF
    END IF
  END SUBROUTINE FV_TP_2D_R4
  SUBROUTINE COPY_CORNERS_R4(q, npx, npy, dir)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, dir
    REAL(real4), INTENT(INOUT) :: q(isd:ied, jsd:jed)
    INTEGER :: i, j
    IF (dir .EQ. 1) THEN
! XDir:
      IF (sw_corner) THEN
        DO j=1-ng,0
          DO i=1-ng,0
            q(i, j) = q(j, 1-i)
          END DO
        END DO
      END IF
      IF (se_corner) THEN
        DO j=1-ng,0
          DO i=npx,npx+ng-1
            q(i, j) = q(npy-j, i-npx+1)
          END DO
        END DO
      END IF
      IF (ne_corner) THEN
        DO j=npy,npy+ng-1
          DO i=npx,npx+ng-1
            q(i, j) = q(j, 2*npx-1-i)
          END DO
        END DO
      END IF
      IF (nw_corner) THEN
        DO j=npy,npy+ng-1
          DO i=1-ng,0
            q(i, j) = q(npy-j, i-1+npx)
          END DO
        END DO
      END IF
    ELSE IF (dir .EQ. 2) THEN
! YDir:
      IF (sw_corner) THEN
        DO j=1-ng,0
          DO i=1-ng,0
            q(i, j) = q(1-j, i)
          END DO
        END DO
      END IF
      IF (se_corner) THEN
        DO j=1-ng,0
          DO i=npx,npx+ng-1
            q(i, j) = q(npy+j-1, npx-i)
          END DO
        END DO
      END IF
      IF (ne_corner) THEN
        DO j=npy,npy+ng-1
          DO i=npx,npx+ng-1
            q(i, j) = q(2*npy-1-j, i)
          END DO
        END DO
      END IF
      IF (nw_corner) THEN
        DO j=npy,npy+ng-1
          DO i=1-ng,0
            q(i, j) = q(j+1-npx, npy-i)
          END DO
        END DO
      END IF
    END IF
  END SUBROUTINE COPY_CORNERS_R4
!  Differentiation of xtp in forward (tangent) mode:
!   variations   of useful results: fx
!   with respect to varying inputs: q
  SUBROUTINE XTP_TLM(fx, fx_tl, q, q_tl, c, iord, ifirst, ilast, jfirst&
&   , jlast, npx, npy)
    IMPLICIT NONE
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: npx, npy
    INTEGER, INTENT(IN) :: iord
! Courant numbers
    REAL(fvprc), INTENT(IN) :: c(is:ie+1, jfirst:jlast)
    REAL(fvprc), INTENT(IN) :: q(isd:ied, jfirst:jlast)
    REAL(fvprc), INTENT(IN) :: q_tl(isd:ied, jfirst:jlast)
    REAL(fvprc), INTENT(OUT) :: fx(ifirst:ilast+1, jfirst:jlast)
    REAL(fvprc), INTENT(OUT) :: fx_tl(ifirst:ilast+1, jfirst:jlast)
! Local:
    REAL(fvprc) :: dm(is-2:ie+2)
    REAL(fvprc) :: x0l, x0r, x1
    INTEGER :: i, j
    IF (iord .EQ. 1) THEN
      fx_tl = 0.0_8
      DO j=jfirst,jlast
        DO i=ifirst,ilast+1
          IF (c(i, j) .GT. 0.) THEN
            fx_tl(i, j) = q_tl(i-1, j)
            fx(i, j) = q(i-1, j)
          ELSE
            fx_tl(i, j) = q_tl(i, j)
            fx(i, j) = q(i, j)
          END IF
        END DO
      END DO
    ELSE IF (iord .EQ. 333) THEN
      fx_tl = 0.0_8
!Advection using third order scheme
      DO j=jfirst,jlast
        DO i=ifirst,ilast+1
          IF (c(i, j) .GT. 0.) THEN
            fx_tl(i, j) = (2.0*q_tl(i, j)+5.0*q_tl(i-1, j)-q_tl(i-2, j))&
&             /6.0 - 0.5*c(i, j)*(q_tl(i, j)-q_tl(i-1, j)) + c(i, j)**2*&
&             (q_tl(i, j)-2.0*q_tl(i-1, j)+q_tl(i-2, j))/6.0
            fx(i, j) = (2.0*q(i, j)+5.0*q(i-1, j)-q(i-2, j))/6.0 - 0.5*c&
&             (i, j)*(q(i, j)-q(i-1, j)) + c(i, j)*c(i, j)/6.0*(q(i, j)-&
&             2.0*q(i-1, j)+q(i-2, j))
          ELSE
            fx_tl(i, j) = (2.0*q_tl(i-1, j)+5.0*q_tl(i, j)-q_tl(i+1, j))&
&             /6.0 - 0.5*c(i, j)*(q_tl(i, j)-q_tl(i-1, j)) + c(i, j)**2*&
&             (q_tl(i+1, j)-2.0*q_tl(i, j)+q_tl(i-1, j))/6.0
            fx(i, j) = (2.0*q(i-1, j)+5.0*q(i, j)-q(i+1, j))/6.0 - 0.5*c&
&             (i, j)*(q(i, j)-q(i-1, j)) + c(i, j)*c(i, j)/6.0*(q(i+1, j&
&             )-2.0*q(i, j)+q(i-1, j))
          END IF
        END DO
      END DO
    ELSE
      CALL FXPPM_TLM(c, q, q_tl, fx, fx_tl, iord, ifirst, ilast, jfirst&
&              , jlast, npx, npy)
    END IF
  END SUBROUTINE XTP_TLM
  SUBROUTINE XTP(fx, q, c, iord, ifirst, ilast, jfirst, jlast, npx, npy)
    IMPLICIT NONE
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: npx, npy
    INTEGER, INTENT(IN) :: iord
! Courant numbers
    REAL(fvprc), INTENT(IN) :: c(is:ie+1, jfirst:jlast)
    REAL(fvprc), INTENT(IN) :: q(isd:ied, jfirst:jlast)
    REAL(fvprc), INTENT(OUT) :: fx(ifirst:ilast+1, jfirst:jlast)
! Local:
    REAL(fvprc) :: dm(is-2:ie+2)
    REAL(fvprc) :: x0l, x0r, x1
    INTEGER :: i, j
    IF (iord .EQ. 1) THEN
      DO j=jfirst,jlast
        DO i=ifirst,ilast+1
          IF (c(i, j) .GT. 0.) THEN
            fx(i, j) = q(i-1, j)
          ELSE
            fx(i, j) = q(i, j)
          END IF
        END DO
      END DO
    ELSE IF (iord .EQ. 333) THEN
!Advection using third order scheme
      DO j=jfirst,jlast
        DO i=ifirst,ilast+1
          IF (c(i, j) .GT. 0.) THEN
            fx(i, j) = (2.0*q(i, j)+5.0*q(i-1, j)-q(i-2, j))/6.0 - 0.5*c&
&             (i, j)*(q(i, j)-q(i-1, j)) + c(i, j)*c(i, j)/6.0*(q(i, j)-&
&             2.0*q(i-1, j)+q(i-2, j))
          ELSE
            fx(i, j) = (2.0*q(i-1, j)+5.0*q(i, j)-q(i+1, j))/6.0 - 0.5*c&
&             (i, j)*(q(i, j)-q(i-1, j)) + c(i, j)*c(i, j)/6.0*(q(i+1, j&
&             )-2.0*q(i, j)+q(i-1, j))
          END IF
        END DO
      END DO
    ELSE
      CALL FXPPM(c, q, fx, iord, ifirst, ilast, jfirst, jlast, npx, npy)
    END IF
  END SUBROUTINE XTP
!  Differentiation of ytp in forward (tangent) mode:
!   variations   of useful results: fy
!   with respect to varying inputs: q
  SUBROUTINE YTP_TLM(fy, fy_tl, q, q_tl, c, jord, ifirst, ilast, jfirst&
&   , jlast, npx, npy)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: jord
    REAL(fvprc), INTENT(IN) :: q(ifirst:ilast, jfirst-ng:jlast+ng)
    REAL(fvprc), INTENT(IN) :: q_tl(ifirst:ilast, jfirst-ng:jlast+ng)
! Courant number
    REAL(fvprc), INTENT(IN) :: c(isd:ied, js:je+1)
!  Flux
    REAL(fvprc), INTENT(OUT) :: fy(ifirst:ilast, jfirst:jlast+1)
    REAL(fvprc), INTENT(OUT) :: fy_tl(ifirst:ilast, jfirst:jlast+1)
! !LOCAL VARIABLES:
    REAL(fvprc) :: dm(ifirst:ilast, jfirst-2:jlast+2)
    REAL(fvprc) :: x0l, x0r, x1
    INTEGER :: i, j
    IF (jord .EQ. 1) THEN
      fy_tl = 0.0_8
      DO j=jfirst,jlast+1
        DO i=ifirst,ilast
          IF (c(i, j) .GT. 0.) THEN
            fy_tl(i, j) = q_tl(i, j-1)
            fy(i, j) = q(i, j-1)
          ELSE
            fy_tl(i, j) = q_tl(i, j)
            fy(i, j) = q(i, j)
          END IF
        END DO
      END DO
    ELSE IF (jord .EQ. 333) THEN
      fy_tl = 0.0_8
!Advected using third order scheme
      DO j=jfirst,jlast+1
        DO i=ifirst,ilast
          IF (c(i, j) .GT. 0.) THEN
            fy_tl(i, j) = (2.0*q_tl(i, j)+5.0*q_tl(i, j-1)-q_tl(i, j-2))&
&             /6.0 - 0.5*c(i, j)*(q_tl(i, j)-q_tl(i, j-1)) + c(i, j)**2*&
&             (q_tl(i, j)-2.0*q_tl(i, j-1)+q_tl(i, j-2))/6.0
            fy(i, j) = (2.0*q(i, j)+5.0*q(i, j-1)-q(i, j-2))/6.0 - 0.5*c&
&             (i, j)*(q(i, j)-q(i, j-1)) + c(i, j)*c(i, j)/6.0*(q(i, j)-&
&             2.0*q(i, j-1)+q(i, j-2))
          ELSE
            fy_tl(i, j) = (2.0*q_tl(i, j-1)+5.0*q_tl(i, j)-q_tl(i, j+1))&
&             /6.0 - 0.5*c(i, j)*(q_tl(i, j)-q_tl(i, j-1)) + c(i, j)**2*&
&             (q_tl(i, j+1)-2.0*q_tl(i, j)+q_tl(i, j-1))/6.0
            fy(i, j) = (2.0*q(i, j-1)+5.0*q(i, j)-q(i, j+1))/6.0 - 0.5*c&
&             (i, j)*(q(i, j)-q(i, j-1)) + c(i, j)*c(i, j)/6.0*(q(i, j+1&
&             )-2.0*q(i, j)+q(i, j-1))
          END IF
        END DO
      END DO
    ELSE
      CALL FYPPM_TLM(c, q, q_tl, fy, fy_tl, jord, ifirst, ilast, jfirst&
&              , jlast, npx, npy)
    END IF
  END SUBROUTINE YTP_TLM
  SUBROUTINE YTP(fy, q, c, jord, ifirst, ilast, jfirst, jlast, npx, npy)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: jord
    REAL(fvprc), INTENT(IN) :: q(ifirst:ilast, jfirst-ng:jlast+ng)
! Courant number
    REAL(fvprc), INTENT(IN) :: c(isd:ied, js:je+1)
!  Flux
    REAL(fvprc), INTENT(OUT) :: fy(ifirst:ilast, jfirst:jlast+1)
! !LOCAL VARIABLES:
    REAL(fvprc) :: dm(ifirst:ilast, jfirst-2:jlast+2)
    REAL(fvprc) :: x0l, x0r, x1
    INTEGER :: i, j
    IF (jord .EQ. 1) THEN
      DO j=jfirst,jlast+1
        DO i=ifirst,ilast
          IF (c(i, j) .GT. 0.) THEN
            fy(i, j) = q(i, j-1)
          ELSE
            fy(i, j) = q(i, j)
          END IF
        END DO
      END DO
    ELSE IF (jord .EQ. 333) THEN
!Advected using third order scheme
      DO j=jfirst,jlast+1
        DO i=ifirst,ilast
          IF (c(i, j) .GT. 0.) THEN
            fy(i, j) = (2.0*q(i, j)+5.0*q(i, j-1)-q(i, j-2))/6.0 - 0.5*c&
&             (i, j)*(q(i, j)-q(i, j-1)) + c(i, j)*c(i, j)/6.0*(q(i, j)-&
&             2.0*q(i, j-1)+q(i, j-2))
          ELSE
            fy(i, j) = (2.0*q(i, j-1)+5.0*q(i, j)-q(i, j+1))/6.0 - 0.5*c&
&             (i, j)*(q(i, j)-q(i, j-1)) + c(i, j)*c(i, j)/6.0*(q(i, j+1&
&             )-2.0*q(i, j)+q(i, j-1))
          END IF
        END DO
      END DO
    ELSE
      CALL FYPPM(c, q, fy, jord, ifirst, ilast, jfirst, jlast, npx, npy)
    END IF
  END SUBROUTINE YTP
!  Differentiation of xppm0 in forward (tangent) mode:
!   variations   of useful results: flux
!   with respect to varying inputs: q
!#ifdef XPPM_2D
! subroutine xppm0(flux, q, c, iord, ifirst, ilast, jfirst, jlast, npx, npy, bd, dxa, nested, grid_type)
! type(fv_grid_bounds_type), intent(IN) :: bd
! integer, INTENT(IN) :: ifirst, ilast               !  X-Dir strip
! integer, INTENT(IN) :: jfirst, jlast               !  Y-Dir strip
! integer, INTENT(IN) :: iord
! integer, INTENT(IN) :: npx, npy
! real   , INTENT(IN) :: q(ifirst-ng:ilast+ng,jfirst:jlast)
! real   , INTENT(IN) :: c(ifirst   :ilast+1 ,jfirst:jlast) ! Courant   N (like FLUX)
! real   , intent(IN) :: dxa(bd%isd:bd%ied,bd%jsd:bd%jed)
! logical, intent(IN) :: nested
! integer, intent(IN) :: grid_type
!! !OUTPUT PARAMETERS:
! real  , INTENT(OUT) :: flux(ifirst:ilast+1,jfirst:jlast) !  Flux
!! Local
! real, dimension(3*jfirst:3*jlast+2) :: q_tmp, bl_tmp, br_tmp
! real, dimension(ifirst-1:ilast+1,jfirst:jlast):: bl, br
! real  al(ifirst-1:ilast+2,jfirst:jlast)
! real  dm(ifirst-2:ilast+2,jfirst:jlast)
! real  dq(ifirst-3:ilast+2,jfirst:jlast)
! logical extm(ifirst-2:ilast+2,jfirst:jlast)
! integer i, j, ie3, is1, ie1
! real xt, pmp_1, lac_1, pmp_2, lac_2
!
! if ( .not. nested .and. grid_type<3 ) then
!    is1 = max(3,is-1);  ie3 = min(npx-2,ie+2)
!                        ie1 = min(npx-3,ie+1)
! else
!    is1 = is-1;         ie3 = ie+2
!                        ie1 = ie+1
! end if
!
! if ( abs(iord) < 8 ) then
!
!    ! ord = -5: linear scheme based on PPM 4th order interpolation
!    ! ord = -6: linear PPM with 2-delta filter
!    ! ord = -7: (-6) with additional Positive definite constraint:
!
!    do j=jfirst,jlast
!       do i=is1, ie3
!          al(i,j) = p1*(q(i-1,j)+q(i,j)) + p2*(q(i-2,j)+q(i+1,j))
!       enddo
!    enddo
!    if ( .not. nested .and. grid_type<3 ) then
!       if ( is==1 ) then
!          do j=jfirst,jlast
!             al(0,j) = c1*q(-2,j) + c2*q(-1,j) + c3*q(0,j)
!             al(1,j) = 0.5*(((2.*dxa(0,j)+dxa(-1,j))*q(0,j)-dxa(0,j)*q(-1,j))/(dxa(-1,j)+dxa(0,j)) &
!                  +      ((2.*dxa(1,j)+dxa( 2,j))*q(1,j)-dxa(1,j)*q(2,j))/(dxa(1, j)+dxa(2,j)))
!             al(2,j) = c3*q(1,j) + c2*q(2,j) +c1*q(3,j)
!          enddo
!          if(iord==-7) then
!             do j=jfirst,jlast
!                al(0,j) = max(0., al(0,j))
!                al(1,j) = max(0., al(1,j))
!                al(2,j) = max(0., al(2,j))
!             enddo
!          endif
!       endif
!       if ( (ie+1)==npx ) then
!          do j=jfirst,jlast
!             al(npx-1,j) = c1*q(npx-3,j) + c2*q(npx-2,j) + c3*q(npx-1,j)
!             al(npx,j) = 0.5*(((2.*dxa(npx-1,j)+dxa(npx-2,j))*q(npx-1,j)-dxa(npx-1,j)*q(npx-2,j))/(dxa(npx-2,j)+dxa(npx-1,j)) &
!                  +      ((2.*dxa(npx,  j)+dxa(npx+1,j))*q(npx,j)-dxa(npx,  j)*q(npx+1,j))/(dxa(npx,  j)+dxa(npx+1,j)))
!             al(npx+1,j) = c3*q(npx,j) + c2*q(npx+1,j) + c1*q(npx+2,j)
!          enddo
!          if(iord==-7) then
!             do j=jfirst,jlast
!                al(npx-1,j) = max(0., al(npx-1,j))
!                al(npx,  j) = max(0., al(npx  ,j))
!                al(npx+1,j) = max(0., al(npx+1,j))
!             enddo
!          endif
!       endif
!    endif
!
!    if ( iord==-5 ) then
!       do j=jfirst,jlast
!          do i=ifirst-1,ilast+1
!             bl(i,j) = al(i,j)   - q(i,j)
!             br(i,j) = al(i+1,j) - q(i,j)
!          enddo
!       enddo
!    else
!       do j=jfirst,jlast
!          do i=ifirst-3,ilast+2
!             dq(i,j) = q(i+1,j) - q(i,j)
!          enddo
!       enddo
!       do j=jfirst,jlast
!          do i=ifirst-2, ilast+2
!             if ( dq(i-1,j)*dq(i,j) > 0. ) then
!                extm(i,j) = .false.
!             else
!                extm(i,j) = .true.
!             endif
!          enddo
!       enddo
!       do j=jfirst,jlast
!          do i=ifirst-1,ilast+1
!             if ( extm(i-1,j).and.extm(i,j).and.extm(i+1,j) ) then
!                bl(i,j) = 0.
!                br(i,j) = 0.
!             else
!                bl(i,j) = al(i,j)   - q(i,j)
!                br(i,j) = al(i+1,j) - q(i,j)
!             endif
!          enddo
!       enddo
!       ! Additional positive definite constraint:
!       if(iord==-7) call pert_ppm(ilast-ifirst+3, q(ifirst-1,j), bl(ifirst-1,j), br(ifirst-1,j), 0)
!    endif
! else
!
!! Monotonic constraints:
!! ord = 8: PPM with Lin's PPM fast monotone constraint
!! ord = 10: PPM with Lin's modification of Huynh 2nd constraint
!! ord = 13: 10 plus positive definite constraint
!    do j=jfirst,jlast
!!DEC$ VECTOR ALWAYS
!       do i=is-2,ie+2
!          xt = 0.25*(q(i+1,j) - q(i-1,j))
!          dm(i,j) = sign(min(abs(xt), max(q(i-1,j), q(i,j), q(i+1,j)) - q(i,j),  &
!               q(i,j) - min(q(i-1,j), q(i,j), q(i+1,j))), xt)
!       enddo
!    enddo
!    do j=jfirst,jlast
!!DEC$ VECTOR ALWAYS
!       do i=is1,ie1+1
!          al(i,j) = 0.5*(q(i-1,j)+q(i,j)) + r3*(dm(i-1,j)-dm(i,j))
!       enddo
!    enddo
!    if ( iord==-8 ) then
!       do j=jfirst,jlast
!!DEC$ VECTOR ALWAYS
!          do i=is1, ie1
!             xt = 2.*dm(i,j)
!             bl(i,j) = -sign(min(abs(xt), abs(al(i,j  )-q(i,j))), xt)
!             br(i,j) =  sign(min(abs(xt), abs(al(i+1,j)-q(i,j))), xt)
!          enddo
!       enddo
!    else
!       do j=jfirst,jlast
!          do i=is1-2, ie1+1
!             dq(i,j) = q(i+1,j) - q(i,j)
!          enddo
!       enddo
!       do j=jfirst,jlast
!          do i=is1, ie1
!             bl(i,j) = al(i,j  ) - q(i,j)
!             br(i,j) = al(i+1,j) - q(i,j)
!             if ( abs(dm(i-1,j))+abs(dm(i,j))+abs(dm(i+1,j)) < near_zero ) then
!                bl(i,j) = 0.
!                br(i,j) = 0.
!             elseif( abs(3.*(bl(i,j)+br(i,j))) > abs(bl(i,j)-br(i,j)) ) then
!                pmp_1 = -(dq(i,j) + dq(i,j))
!                lac_1 = pmp_1 + 1.5*dq(i+1,j)
!                bl(i,j) = min( max(0., pmp_1, lac_1), max(bl(i,j), min(0., pmp_1, lac_1)) )
!                pmp_2 = dq(i-1,j) + dq(i-1,j)
!                lac_2 = pmp_2 - 1.5*dq(i-2,j)
!                br(i,j) = min( max(0., pmp_2, lac_2), max(br(i,j), min(0., pmp_2, lac_2)) )
!             endif
!          enddo
!       enddo
!    endif
!    ! Positive definite constraint:
!    if(iord==-9 .or. iord==-13) call pert_ppm(ie1-is1+1, q(is1,j), bl(is1,j), br(is1,j), 0)
!
!    if (.not. nested .and. grid_type<3) then
!       if ( is==1 ) then
!          do j=jfirst,jlast
!             bl_tmp(3*j) = s14*dm(-1,j) + s11*(q(-1,j)-q(0,j))
!
!             xt = 0.5*(((2.*dxa(0,j)+dxa(-1,j))*q(0,j)-dxa(0,j)*q(-1,j))/(dxa(-1,j)+dxa(0,j)) &
!                  +      ((2.*dxa(1,j)+dxa( 2,j))*q(1,j)-dxa(1,j)*q(2,j))/(dxa(1, j)+dxa(2,j)))
!             br_tmp(3*j) = xt - q(0,j)
!             bl_tmp(3*j+1) = xt - q(1,j)
!             xt = s15*q(1,j) + s11*q(2,j) - s14*dm(2,j)
!             br_tmp(3*j+1) = xt - q(1,j)
!             bl_tmp(3*j+2) = xt - q(2,j)
!             br_tmp(3*j+2) = al(3,j) - q(2,j)
!             q_tmp(j*3:j*3+2) = q(0:2,j)
!          enddo
!          call pert_ppm(3*(jlast-jfirst+1), q_tmp, bl_tmp, br_tmp, 1)
!          do j=jfirst,jlast
!             bl(0:2,j) = bl_tmp(j*3:j*3+2)
!             br(0:2,j) = br_tmp(j*3:j*3+2)
!          enddo
!      endif
!      if ( (ie+1)==npx ) then
!         do j=jfirst,jlast
!            bl_tmp(3*j) = al(npx-2,j) - q(npx-2,j)
!
!            xt = s15*q(npx-1,j) + s11*q(npx-2,j) + s14*dm(npx-2,j)
!            br_tmp(3*j) = xt - q(npx-2,j)
!            bl_tmp(3*j+1) = xt - q(npx-1,j)
!
!            xt = 0.5*(((2.*dxa(npx-1,j)+dxa(npx-2,j))*q(npx-1,j)-dxa(npx-1,j)*q(npx-2,j))/(dxa(npx-2,j)+dxa(npx-1,j)) &
!               +      ((2.*dxa(npx,  j)+dxa(npx+1,j))*q(npx,j  )-dxa(npx,  j)*q(npx+1,j))/(dxa(npx,  j)+dxa(npx+1,j)))
!            br_tmp(3*j+1) = xt - q(npx-1,j)
!            bl_tmp(3*j+2) = xt - q(npx,j  )
!
!            br_tmp(3*j+2) = s11*(q(npx+1,j)-q(npx,j)) - s14*dm(npx+1,j)
!            q_tmp(j*3:j*3+2) = q(npx-2:npx,j)
!         enddo
!         call pert_ppm(3*(jlast-jfirst+1), q_tmp, bl_tmp, br_tmp, 1)
!
!         do j=jfirst,jlast
!            bl(npx-2:npx,j) = bl_tmp(j*3:j*3+2)
!            br(npx-2:npx,j) = br_tmp(j*3:j*3+2)
!         enddo
!      endif
!    endif
!
!  endif
!
!  do j=jfirst,jlast
!!DEC$ VECTOR ALWAYS
!     do i=ifirst,ilast+1
!        if( c(i,j)>0. ) then
!           flux(i,j) = q(i-1,j) + (1.-c(i,j))*(br(i-1,j)-c(i,j)*(bl(i-1,j)+br(i-1,j)))
!        else
!           flux(i,j) = q(i,j  ) + (1.+c(i,j))*(bl(i,j  )+c(i,j)*(bl(i,j  )+br(i,j  )))
!        endif
!     enddo
!  enddo
!
! end subroutine xppm0
!#else
  SUBROUTINE XPPM0_TLM(flux, flux_tl, q, q_tl, c, iord, ifirst, ilast, &
&   jfirst, jlast, npx, npy)
    IMPLICIT NONE
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: iord
    INTEGER, INTENT(IN) :: npx, npy
    REAL, INTENT(IN) :: q(ifirst-ng:ilast+ng, jfirst:jlast)
    REAL, INTENT(IN) :: q_tl(ifirst-ng:ilast+ng, jfirst:jlast)
! Courant   N (like FLUX)
    REAL, INTENT(IN) :: c(ifirst:ilast+1, jfirst:jlast)
! !OUTPUT PARAMETERS:
!  Flux
    REAL, INTENT(OUT) :: flux(ifirst:ilast+1, jfirst:jlast)
    REAL, INTENT(OUT) :: flux_tl(ifirst:ilast+1, jfirst:jlast)
! Local
    REAL, DIMENSION(ifirst-ng:ilast+ng) :: q1
    REAL, DIMENSION(ifirst-ng:ilast+ng) :: q1_tl
    REAL, DIMENSION(ifirst-1:ilast+1) :: bl, br
    REAL, DIMENSION(ifirst-1:ilast+1) :: bl_tl, br_tl
    REAL :: al(ifirst-1:ilast+2)
    REAL :: al_tl(ifirst-1:ilast+2)
    REAL :: dm(ifirst-2:ilast+2)
    REAL :: dq(ifirst-3:ilast+2)
    LOGICAL :: extm(ifirst-2:ilast+2)
    INTEGER :: i, j, ie3, is1, ie1
    REAL :: xt, pmp_1, lac_1, pmp_2, lac_2
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTEGER :: abs0
    IF (.NOT.nested .AND. grid_type .LT. 3) THEN
      IF (3 .LT. is - 1) THEN
        is1 = is - 1
      ELSE
        is1 = 3
      END IF
      IF (npx - 2 .GT. ie + 2) THEN
        ie3 = ie + 2
      ELSE
        ie3 = npx - 2
      END IF
      IF (npx - 3 .GT. ie + 1) THEN
        ie1 = ie + 1
      ELSE
        ie1 = npx - 3
      END IF
      flux_tl = 0.0
      al_tl = 0.0
      bl_tl = 0.0
      br_tl = 0.0
      q1_tl = 0.0
    ELSE
      is1 = is - 1
      ie3 = ie + 2
      ie1 = ie + 1
      flux_tl = 0.0
      al_tl = 0.0
      bl_tl = 0.0
      br_tl = 0.0
      q1_tl = 0.0
    END IF
    DO j=jfirst,jlast
      DO i=ifirst-ng,ilast+ng
        q1_tl(i) = q_tl(i, j)
        q1(i) = q(i, j)
      END DO
      IF (iord .GE. 0.) THEN
        abs0 = iord
      ELSE
        abs0 = -iord
      END IF
      IF (abs0 .LT. 8) THEN
! ord = -5: linear scheme based on PPM 4th order interpolation
! ord = -6: linear PPM with 2-delta filter
! ord = -7: (-6) with additional Positive definite constraint:
        DO i=is1,ie3
          al_tl(i) = p1*(q1_tl(i-1)+q1_tl(i)) + p2*(q1_tl(i-2)+q1_tl(i+1&
&           ))
          al(i) = p1*(q1(i-1)+q1(i)) + p2*(q1(i-2)+q1(i+1))
        END DO
        IF (.NOT.nested .AND. grid_type .LT. 3) THEN
          IF (is .EQ. 1) THEN
            al_tl(0) = c1*q1_tl(-2) + c2*q1_tl(-1) + c3*q1_tl(0)
            al(0) = c1*q1(-2) + c2*q1(-1) + c3*q1(0)
            al_tl(1) = 0.5*(((2.*dxa(0, j)+dxa(-1, j))*q1_tl(0)-dxa(0, j&
&             )*q1_tl(-1))/(dxa(-1, j)+dxa(0, j))+((2.*dxa(1, j)+dxa(2, &
&             j))*q1_tl(1)-dxa(1, j)*q1_tl(2))/(dxa(1, j)+dxa(2, j)))
            al(1) = 0.5*(((2.*dxa(0, j)+dxa(-1, j))*q1(0)-dxa(0, j)*q1(-&
&             1))/(dxa(-1, j)+dxa(0, j))+((2.*dxa(1, j)+dxa(2, j))*q1(1)&
&             -dxa(1, j)*q1(2))/(dxa(1, j)+dxa(2, j)))
            al_tl(2) = c3*q1_tl(1) + c2*q1_tl(2) + c1*q1_tl(3)
            al(2) = c3*q1(1) + c2*q1(2) + c1*q1(3)
          END IF
          IF (ie + 1 .EQ. npx) THEN
            al_tl(npx-1) = c1*q1_tl(npx-3) + c2*q1_tl(npx-2) + c3*q1_tl(&
&             npx-1)
            al(npx-1) = c1*q1(npx-3) + c2*q1(npx-2) + c3*q1(npx-1)
            al_tl(npx) = 0.5*(((2.*dxa(npx-1, j)+dxa(npx-2, j))*q1_tl(&
&             npx-1)-dxa(npx-1, j)*q1_tl(npx-2))/(dxa(npx-2, j)+dxa(npx-&
&             1, j))+((2.*dxa(npx, j)+dxa(npx+1, j))*q1_tl(npx)-dxa(npx&
&             , j)*q1_tl(npx+1))/(dxa(npx, j)+dxa(npx+1, j)))
            al(npx) = 0.5*(((2.*dxa(npx-1, j)+dxa(npx-2, j))*q1(npx-1)-&
&             dxa(npx-1, j)*q1(npx-2))/(dxa(npx-2, j)+dxa(npx-1, j))+((&
&             2.*dxa(npx, j)+dxa(npx+1, j))*q1(npx)-dxa(npx, j)*q1(npx+1&
&             ))/(dxa(npx, j)+dxa(npx+1, j)))
            al_tl(npx+1) = c3*q1_tl(npx) + c2*q1_tl(npx+1) + c1*q1_tl(&
&             npx+2)
            al(npx+1) = c3*q1(npx) + c2*q1(npx+1) + c1*q1(npx+2)
          END IF
        END IF
        IF (iord .EQ. -5) THEN
          DO i=ifirst-1,ilast+1
            bl_tl(i) = al_tl(i) - q1_tl(i)
            bl(i) = al(i) - q1(i)
            br_tl(i) = al_tl(i+1) - q1_tl(i)
            br(i) = al(i+1) - q1(i)
          END DO
        END IF
      END IF
      DO i=ifirst,ilast+1
        IF (c(i, j) .GT. 0.) THEN
          flux_tl(i, j) = q1_tl(i-1) + (1.-c(i, j))*(br_tl(i-1)-c(i, j)*&
&           (bl_tl(i-1)+br_tl(i-1)))
          flux(i, j) = q1(i-1) + (1.-c(i, j))*(br(i-1)-c(i, j)*(bl(i-1)+&
&           br(i-1)))
        ELSE
          flux_tl(i, j) = q1_tl(i) + (1.+c(i, j))*(bl_tl(i)+c(i, j)*(&
&           bl_tl(i)+br_tl(i)))
          flux(i, j) = q1(i) + (1.+c(i, j))*(bl(i)+c(i, j)*(bl(i)+br(i))&
&           )
        END IF
      END DO
    END DO
  END SUBROUTINE XPPM0_TLM
!#ifdef XPPM_2D
! subroutine xppm0(flux, q, c, iord, ifirst, ilast, jfirst, jlast, npx, npy, bd, dxa, nested, grid_type)
! type(fv_grid_bounds_type), intent(IN) :: bd
! integer, INTENT(IN) :: ifirst, ilast               !  X-Dir strip
! integer, INTENT(IN) :: jfirst, jlast               !  Y-Dir strip
! integer, INTENT(IN) :: iord
! integer, INTENT(IN) :: npx, npy
! real   , INTENT(IN) :: q(ifirst-ng:ilast+ng,jfirst:jlast)
! real   , INTENT(IN) :: c(ifirst   :ilast+1 ,jfirst:jlast) ! Courant   N (like FLUX)
! real   , intent(IN) :: dxa(bd%isd:bd%ied,bd%jsd:bd%jed)
! logical, intent(IN) :: nested
! integer, intent(IN) :: grid_type
!! !OUTPUT PARAMETERS:
! real  , INTENT(OUT) :: flux(ifirst:ilast+1,jfirst:jlast) !  Flux
!! Local
! real, dimension(3*jfirst:3*jlast+2) :: q_tmp, bl_tmp, br_tmp
! real, dimension(ifirst-1:ilast+1,jfirst:jlast):: bl, br
! real  al(ifirst-1:ilast+2,jfirst:jlast)
! real  dm(ifirst-2:ilast+2,jfirst:jlast)
! real  dq(ifirst-3:ilast+2,jfirst:jlast)
! logical extm(ifirst-2:ilast+2,jfirst:jlast)
! integer i, j, ie3, is1, ie1
! real xt, pmp_1, lac_1, pmp_2, lac_2
!
! if ( .not. nested .and. grid_type<3 ) then
!    is1 = max(3,is-1);  ie3 = min(npx-2,ie+2)
!                        ie1 = min(npx-3,ie+1)
! else
!    is1 = is-1;         ie3 = ie+2
!                        ie1 = ie+1
! end if
!
! if ( abs(iord) < 8 ) then
!
!    ! ord = -5: linear scheme based on PPM 4th order interpolation
!    ! ord = -6: linear PPM with 2-delta filter
!    ! ord = -7: (-6) with additional Positive definite constraint:
!
!    do j=jfirst,jlast
!       do i=is1, ie3
!          al(i,j) = p1*(q(i-1,j)+q(i,j)) + p2*(q(i-2,j)+q(i+1,j))
!       enddo
!    enddo
!    if ( .not. nested .and. grid_type<3 ) then
!       if ( is==1 ) then
!          do j=jfirst,jlast
!             al(0,j) = c1*q(-2,j) + c2*q(-1,j) + c3*q(0,j)
!             al(1,j) = 0.5*(((2.*dxa(0,j)+dxa(-1,j))*q(0,j)-dxa(0,j)*q(-1,j))/(dxa(-1,j)+dxa(0,j)) &
!                  +      ((2.*dxa(1,j)+dxa( 2,j))*q(1,j)-dxa(1,j)*q(2,j))/(dxa(1, j)+dxa(2,j)))
!             al(2,j) = c3*q(1,j) + c2*q(2,j) +c1*q(3,j)
!          enddo
!          if(iord==-7) then
!             do j=jfirst,jlast
!                al(0,j) = max(0., al(0,j))
!                al(1,j) = max(0., al(1,j))
!                al(2,j) = max(0., al(2,j))
!             enddo
!          endif
!       endif
!       if ( (ie+1)==npx ) then
!          do j=jfirst,jlast
!             al(npx-1,j) = c1*q(npx-3,j) + c2*q(npx-2,j) + c3*q(npx-1,j)
!             al(npx,j) = 0.5*(((2.*dxa(npx-1,j)+dxa(npx-2,j))*q(npx-1,j)-dxa(npx-1,j)*q(npx-2,j))/(dxa(npx-2,j)+dxa(npx-1,j)) &
!                  +      ((2.*dxa(npx,  j)+dxa(npx+1,j))*q(npx,j)-dxa(npx,  j)*q(npx+1,j))/(dxa(npx,  j)+dxa(npx+1,j)))
!             al(npx+1,j) = c3*q(npx,j) + c2*q(npx+1,j) + c1*q(npx+2,j)
!          enddo
!          if(iord==-7) then
!             do j=jfirst,jlast
!                al(npx-1,j) = max(0., al(npx-1,j))
!                al(npx,  j) = max(0., al(npx  ,j))
!                al(npx+1,j) = max(0., al(npx+1,j))
!             enddo
!          endif
!       endif
!    endif
!
!    if ( iord==-5 ) then
!       do j=jfirst,jlast
!          do i=ifirst-1,ilast+1
!             bl(i,j) = al(i,j)   - q(i,j)
!             br(i,j) = al(i+1,j) - q(i,j)
!          enddo
!       enddo
!    else
!       do j=jfirst,jlast
!          do i=ifirst-3,ilast+2
!             dq(i,j) = q(i+1,j) - q(i,j)
!          enddo
!       enddo
!       do j=jfirst,jlast
!          do i=ifirst-2, ilast+2
!             if ( dq(i-1,j)*dq(i,j) > 0. ) then
!                extm(i,j) = .false.
!             else
!                extm(i,j) = .true.
!             endif
!          enddo
!       enddo
!       do j=jfirst,jlast
!          do i=ifirst-1,ilast+1
!             if ( extm(i-1,j).and.extm(i,j).and.extm(i+1,j) ) then
!                bl(i,j) = 0.
!                br(i,j) = 0.
!             else
!                bl(i,j) = al(i,j)   - q(i,j)
!                br(i,j) = al(i+1,j) - q(i,j)
!             endif
!          enddo
!       enddo
!       ! Additional positive definite constraint:
!       if(iord==-7) call pert_ppm(ilast-ifirst+3, q(ifirst-1,j), bl(ifirst-1,j), br(ifirst-1,j), 0)
!    endif
! else
!
!! Monotonic constraints:
!! ord = 8: PPM with Lin's PPM fast monotone constraint
!! ord = 10: PPM with Lin's modification of Huynh 2nd constraint
!! ord = 13: 10 plus positive definite constraint
!    do j=jfirst,jlast
!!DEC$ VECTOR ALWAYS
!       do i=is-2,ie+2
!          xt = 0.25*(q(i+1,j) - q(i-1,j))
!          dm(i,j) = sign(min(abs(xt), max(q(i-1,j), q(i,j), q(i+1,j)) - q(i,j),  &
!               q(i,j) - min(q(i-1,j), q(i,j), q(i+1,j))), xt)
!       enddo
!    enddo
!    do j=jfirst,jlast
!!DEC$ VECTOR ALWAYS
!       do i=is1,ie1+1
!          al(i,j) = 0.5*(q(i-1,j)+q(i,j)) + r3*(dm(i-1,j)-dm(i,j))
!       enddo
!    enddo
!    if ( iord==-8 ) then
!       do j=jfirst,jlast
!!DEC$ VECTOR ALWAYS
!          do i=is1, ie1
!             xt = 2.*dm(i,j)
!             bl(i,j) = -sign(min(abs(xt), abs(al(i,j  )-q(i,j))), xt)
!             br(i,j) =  sign(min(abs(xt), abs(al(i+1,j)-q(i,j))), xt)
!          enddo
!       enddo
!    else
!       do j=jfirst,jlast
!          do i=is1-2, ie1+1
!             dq(i,j) = q(i+1,j) - q(i,j)
!          enddo
!       enddo
!       do j=jfirst,jlast
!          do i=is1, ie1
!             bl(i,j) = al(i,j  ) - q(i,j)
!             br(i,j) = al(i+1,j) - q(i,j)
!             if ( abs(dm(i-1,j))+abs(dm(i,j))+abs(dm(i+1,j)) < near_zero ) then
!                bl(i,j) = 0.
!                br(i,j) = 0.
!             elseif( abs(3.*(bl(i,j)+br(i,j))) > abs(bl(i,j)-br(i,j)) ) then
!                pmp_1 = -(dq(i,j) + dq(i,j))
!                lac_1 = pmp_1 + 1.5*dq(i+1,j)
!                bl(i,j) = min( max(0., pmp_1, lac_1), max(bl(i,j), min(0., pmp_1, lac_1)) )
!                pmp_2 = dq(i-1,j) + dq(i-1,j)
!                lac_2 = pmp_2 - 1.5*dq(i-2,j)
!                br(i,j) = min( max(0., pmp_2, lac_2), max(br(i,j), min(0., pmp_2, lac_2)) )
!             endif
!          enddo
!       enddo
!    endif
!    ! Positive definite constraint:
!    if(iord==-9 .or. iord==-13) call pert_ppm(ie1-is1+1, q(is1,j), bl(is1,j), br(is1,j), 0)
!
!    if (.not. nested .and. grid_type<3) then
!       if ( is==1 ) then
!          do j=jfirst,jlast
!             bl_tmp(3*j) = s14*dm(-1,j) + s11*(q(-1,j)-q(0,j))
!
!             xt = 0.5*(((2.*dxa(0,j)+dxa(-1,j))*q(0,j)-dxa(0,j)*q(-1,j))/(dxa(-1,j)+dxa(0,j)) &
!                  +      ((2.*dxa(1,j)+dxa( 2,j))*q(1,j)-dxa(1,j)*q(2,j))/(dxa(1, j)+dxa(2,j)))
!             br_tmp(3*j) = xt - q(0,j)
!             bl_tmp(3*j+1) = xt - q(1,j)
!             xt = s15*q(1,j) + s11*q(2,j) - s14*dm(2,j)
!             br_tmp(3*j+1) = xt - q(1,j)
!             bl_tmp(3*j+2) = xt - q(2,j)
!             br_tmp(3*j+2) = al(3,j) - q(2,j)
!             q_tmp(j*3:j*3+2) = q(0:2,j)
!          enddo
!          call pert_ppm(3*(jlast-jfirst+1), q_tmp, bl_tmp, br_tmp, 1)
!          do j=jfirst,jlast
!             bl(0:2,j) = bl_tmp(j*3:j*3+2)
!             br(0:2,j) = br_tmp(j*3:j*3+2)
!          enddo
!      endif
!      if ( (ie+1)==npx ) then
!         do j=jfirst,jlast
!            bl_tmp(3*j) = al(npx-2,j) - q(npx-2,j)
!
!            xt = s15*q(npx-1,j) + s11*q(npx-2,j) + s14*dm(npx-2,j)
!            br_tmp(3*j) = xt - q(npx-2,j)
!            bl_tmp(3*j+1) = xt - q(npx-1,j)
!
!            xt = 0.5*(((2.*dxa(npx-1,j)+dxa(npx-2,j))*q(npx-1,j)-dxa(npx-1,j)*q(npx-2,j))/(dxa(npx-2,j)+dxa(npx-1,j)) &
!               +      ((2.*dxa(npx,  j)+dxa(npx+1,j))*q(npx,j  )-dxa(npx,  j)*q(npx+1,j))/(dxa(npx,  j)+dxa(npx+1,j)))
!            br_tmp(3*j+1) = xt - q(npx-1,j)
!            bl_tmp(3*j+2) = xt - q(npx,j  )
!
!            br_tmp(3*j+2) = s11*(q(npx+1,j)-q(npx,j)) - s14*dm(npx+1,j)
!            q_tmp(j*3:j*3+2) = q(npx-2:npx,j)
!         enddo
!         call pert_ppm(3*(jlast-jfirst+1), q_tmp, bl_tmp, br_tmp, 1)
!
!         do j=jfirst,jlast
!            bl(npx-2:npx,j) = bl_tmp(j*3:j*3+2)
!            br(npx-2:npx,j) = br_tmp(j*3:j*3+2)
!         enddo
!      endif
!    endif
!
!  endif
!
!  do j=jfirst,jlast
!!DEC$ VECTOR ALWAYS
!     do i=ifirst,ilast+1
!        if( c(i,j)>0. ) then
!           flux(i,j) = q(i-1,j) + (1.-c(i,j))*(br(i-1,j)-c(i,j)*(bl(i-1,j)+br(i-1,j)))
!        else
!           flux(i,j) = q(i,j  ) + (1.+c(i,j))*(bl(i,j  )+c(i,j)*(bl(i,j  )+br(i,j  )))
!        endif
!     enddo
!  enddo
!
! end subroutine xppm0
!#else
  SUBROUTINE XPPM0(flux, q, c, iord, ifirst, ilast, jfirst, jlast, npx, &
&   npy)
    IMPLICIT NONE
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: iord
    INTEGER, INTENT(IN) :: npx, npy
    REAL, INTENT(IN) :: q(ifirst-ng:ilast+ng, jfirst:jlast)
! Courant   N (like FLUX)
    REAL, INTENT(IN) :: c(ifirst:ilast+1, jfirst:jlast)
! !OUTPUT PARAMETERS:
!  Flux
    REAL, INTENT(OUT) :: flux(ifirst:ilast+1, jfirst:jlast)
! Local
    REAL, DIMENSION(ifirst-ng:ilast+ng) :: q1
    REAL, DIMENSION(ifirst-1:ilast+1) :: bl, br
    REAL :: al(ifirst-1:ilast+2)
    REAL :: dm(ifirst-2:ilast+2)
    REAL :: dq(ifirst-3:ilast+2)
    LOGICAL :: extm(ifirst-2:ilast+2)
    INTEGER :: i, j, ie3, is1, ie1
    REAL :: xt, pmp_1, lac_1, pmp_2, lac_2
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTEGER :: abs0
    IF (.NOT.nested .AND. grid_type .LT. 3) THEN
      IF (3 .LT. is - 1) THEN
        is1 = is - 1
      ELSE
        is1 = 3
      END IF
      IF (npx - 2 .GT. ie + 2) THEN
        ie3 = ie + 2
      ELSE
        ie3 = npx - 2
      END IF
      IF (npx - 3 .GT. ie + 1) THEN
        ie1 = ie + 1
      ELSE
        ie1 = npx - 3
      END IF
    ELSE
      is1 = is - 1
      ie3 = ie + 2
      ie1 = ie + 1
    END IF
    DO j=jfirst,jlast
      DO i=ifirst-ng,ilast+ng
        q1(i) = q(i, j)
      END DO
      IF (iord .GE. 0.) THEN
        abs0 = iord
      ELSE
        abs0 = -iord
      END IF
      IF (abs0 .LT. 8) THEN
! ord = -5: linear scheme based on PPM 4th order interpolation
! ord = -6: linear PPM with 2-delta filter
! ord = -7: (-6) with additional Positive definite constraint:
        DO i=is1,ie3
          al(i) = p1*(q1(i-1)+q1(i)) + p2*(q1(i-2)+q1(i+1))
        END DO
        IF (.NOT.nested .AND. grid_type .LT. 3) THEN
          IF (is .EQ. 1) THEN
            al(0) = c1*q1(-2) + c2*q1(-1) + c3*q1(0)
            al(1) = 0.5*(((2.*dxa(0, j)+dxa(-1, j))*q1(0)-dxa(0, j)*q1(-&
&             1))/(dxa(-1, j)+dxa(0, j))+((2.*dxa(1, j)+dxa(2, j))*q1(1)&
&             -dxa(1, j)*q1(2))/(dxa(1, j)+dxa(2, j)))
            al(2) = c3*q1(1) + c2*q1(2) + c1*q1(3)
          END IF
          IF (ie + 1 .EQ. npx) THEN
            al(npx-1) = c1*q1(npx-3) + c2*q1(npx-2) + c3*q1(npx-1)
            al(npx) = 0.5*(((2.*dxa(npx-1, j)+dxa(npx-2, j))*q1(npx-1)-&
&             dxa(npx-1, j)*q1(npx-2))/(dxa(npx-2, j)+dxa(npx-1, j))+((&
&             2.*dxa(npx, j)+dxa(npx+1, j))*q1(npx)-dxa(npx, j)*q1(npx+1&
&             ))/(dxa(npx, j)+dxa(npx+1, j)))
            al(npx+1) = c3*q1(npx) + c2*q1(npx+1) + c1*q1(npx+2)
          END IF
        END IF
        IF (iord .EQ. -5) THEN
          DO i=ifirst-1,ilast+1
            bl(i) = al(i) - q1(i)
            br(i) = al(i+1) - q1(i)
          END DO
        END IF
      END IF
      DO i=ifirst,ilast+1
        IF (c(i, j) .GT. 0.) THEN
          flux(i, j) = q1(i-1) + (1.-c(i, j))*(br(i-1)-c(i, j)*(bl(i-1)+&
&           br(i-1)))
        ELSE
          flux(i, j) = q1(i) + (1.+c(i, j))*(bl(i)+c(i, j)*(bl(i)+br(i))&
&           )
        END IF
      END DO
    END DO
  END SUBROUTINE XPPM0
!  Differentiation of yppm0 in forward (tangent) mode:
!   variations   of useful results: flux
!   with respect to varying inputs: q
!#endif
  SUBROUTINE YPPM0_TLM(flux, flux_tl, q, q_tl, c, jord, ifirst, ilast, &
&   jfirst, jlast, npx, npy)
    IMPLICIT NONE
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: jord
    INTEGER, INTENT(IN) :: npx, npy
    REAL, INTENT(IN) :: q(ifirst:ilast, jfirst-ng:jlast+ng)
    REAL, INTENT(IN) :: q_tl(ifirst:ilast, jfirst-ng:jlast+ng)
! Courant number
    REAL, INTENT(IN) :: c(isd:ied, js:je+1)
!  Flux
    REAL, INTENT(OUT) :: flux(ifirst:ilast, jfirst:jlast+1)
    REAL, INTENT(OUT) :: flux_tl(ifirst:ilast, jfirst:jlast+1)
! Local:
    REAL :: dm(ifirst:ilast, jfirst-2:jlast+2)
    REAL :: al(ifirst:ilast, jfirst-1:jlast+2)
    REAL :: al_tl(ifirst:ilast, jfirst-1:jlast+2)
    REAL :: bl(ifirst:ilast, jfirst-1:jlast+1)
    REAL :: bl_tl(ifirst:ilast, jfirst-1:jlast+1)
    REAL :: br(ifirst:ilast, jfirst-1:jlast+1)
    REAL :: br_tl(ifirst:ilast, jfirst-1:jlast+1)
    REAL :: dq(ifirst:ilast, jfirst-3:jlast+2)
    LOGICAL :: extm(ifirst:ilast, jfirst-2:jlast+2)
    REAL :: xt, pmp_1, lac_1, pmp_2, lac_2
    INTEGER :: i, j, js1, je3, je1
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTEGER :: abs0
    IF (.NOT.nested .AND. grid_type .LT. 3) THEN
      IF (3 .LT. js - 1) THEN
        js1 = js - 1
      ELSE
        js1 = 3
      END IF
      IF (npy - 2 .GT. je + 2) THEN
        je3 = je + 2
      ELSE
        je3 = npy - 2
      END IF
      IF (npy - 3 .GT. je + 1) THEN
        je1 = je + 1
      ELSE
        je1 = npy - 3
      END IF
    ELSE
! Nested grid OR Doubly periodic domain:
      js1 = js - 1
      je3 = je + 2
      je1 = je + 1
    END IF
    IF (jord .GE. 0.) THEN
      abs0 = jord
    ELSE
      abs0 = -jord
    END IF
    IF (abs0 .LT. 8) THEN
      al_tl = 0.0
! ord = -5: linear scheme based on PPM 4th order interpolation
! ord = -6: linear PPM with 2-delta filter
! ord = -7: (-6) with additional Positive definite constraint:
      DO j=js1,je3
        DO i=ifirst,ilast
          al_tl(i, j) = p1*(q_tl(i, j-1)+q_tl(i, j)) + p2*(q_tl(i, j-2)+&
&           q_tl(i, j+1))
          al(i, j) = p1*(q(i, j-1)+q(i, j)) + p2*(q(i, j-2)+q(i, j+1))
        END DO
      END DO
      IF (.NOT.nested .AND. grid_type .LT. 3) THEN
        IF (js .EQ. 1) THEN
          DO i=ifirst,ilast
            al_tl(i, 0) = c1*q_tl(i, -2) + c2*q_tl(i, -1) + c3*q_tl(i, 0&
&             )
            al(i, 0) = c1*q(i, -2) + c2*q(i, -1) + c3*q(i, 0)
            al_tl(i, 1) = 0.5*(((2.*dya(i, 0)+dya(i, -1))*q_tl(i, 0)-dya&
&             (i, 0)*q_tl(i, -1))/(dya(i, -1)+dya(i, 0))+((2.*dya(i, 1)+&
&             dya(i, 2))*q_tl(i, 1)-dya(i, 1)*q_tl(i, 2))/(dya(i, 1)+dya&
&             (i, 2)))
            al(i, 1) = 0.5*(((2.*dya(i, 0)+dya(i, -1))*q(i, 0)-dya(i, 0)&
&             *q(i, -1))/(dya(i, -1)+dya(i, 0))+((2.*dya(i, 1)+dya(i, 2)&
&             )*q(i, 1)-dya(i, 1)*q(i, 2))/(dya(i, 1)+dya(i, 2)))
            al_tl(i, 2) = c3*q_tl(i, 1) + c2*q_tl(i, 2) + c1*q_tl(i, 3)
            al(i, 2) = c3*q(i, 1) + c2*q(i, 2) + c1*q(i, 3)
          END DO
        END IF
        IF (je + 1 .EQ. npy) THEN
          DO i=ifirst,ilast
            al_tl(i, npy-1) = c1*q_tl(i, npy-3) + c2*q_tl(i, npy-2) + c3&
&             *q_tl(i, npy-1)
            al(i, npy-1) = c1*q(i, npy-3) + c2*q(i, npy-2) + c3*q(i, npy&
&             -1)
            al_tl(i, npy) = 0.5*(((2.*dya(i, npy-1)+dya(i, npy-2))*q_tl(&
&             i, npy-1)-dya(i, npy-1)*q_tl(i, npy-2))/(dya(i, npy-2)+dya&
&             (i, npy-1))+((2.*dya(i, npy)+dya(i, npy+1))*q_tl(i, npy)-&
&             dya(i, npy)*q_tl(i, npy+1))/(dya(i, npy)+dya(i, npy+1)))
            al(i, npy) = 0.5*(((2.*dya(i, npy-1)+dya(i, npy-2))*q(i, npy&
&             -1)-dya(i, npy-1)*q(i, npy-2))/(dya(i, npy-2)+dya(i, npy-1&
&             ))+((2.*dya(i, npy)+dya(i, npy+1))*q(i, npy)-dya(i, npy)*q&
&             (i, npy+1))/(dya(i, npy)+dya(i, npy+1)))
            al_tl(i, npy+1) = c3*q_tl(i, npy) + c2*q_tl(i, npy+1) + c1*&
&             q_tl(i, npy+2)
            al(i, npy+1) = c3*q(i, npy) + c2*q(i, npy+1) + c1*q(i, npy+2&
&             )
          END DO
        END IF
      END IF
      IF (jord .EQ. -5) THEN
        bl_tl = 0.0
        br_tl = 0.0
        DO j=jfirst-1,jlast+1
          DO i=ifirst,ilast
            bl_tl(i, j) = al_tl(i, j) - q_tl(i, j)
            bl(i, j) = al(i, j) - q(i, j)
            br_tl(i, j) = al_tl(i, j+1) - q_tl(i, j)
            br(i, j) = al(i, j+1) - q(i, j)
          END DO
        END DO
        flux_tl = 0.0
      ELSE
        flux_tl = 0.0
        bl_tl = 0.0
        br_tl = 0.0
      END IF
    ELSE
      flux_tl = 0.0
      bl_tl = 0.0
      br_tl = 0.0
    END IF
    DO j=jfirst,jlast+1
      DO i=ifirst,ilast
        IF (c(i, j) .GT. 0.) THEN
          flux_tl(i, j) = q_tl(i, j-1) + (1.-c(i, j))*(br_tl(i, j-1)-c(i&
&           , j)*(bl_tl(i, j-1)+br_tl(i, j-1)))
          flux(i, j) = q(i, j-1) + (1.-c(i, j))*(br(i, j-1)-c(i, j)*(bl(&
&           i, j-1)+br(i, j-1)))
        ELSE
          flux_tl(i, j) = q_tl(i, j) + (1.+c(i, j))*(bl_tl(i, j)+c(i, j)&
&           *(bl_tl(i, j)+br_tl(i, j)))
          flux(i, j) = q(i, j) + (1.+c(i, j))*(bl(i, j)+c(i, j)*(bl(i, j&
&           )+br(i, j)))
        END IF
      END DO
    END DO
  END SUBROUTINE YPPM0_TLM
!#endif
  SUBROUTINE YPPM0(flux, q, c, jord, ifirst, ilast, jfirst, jlast, npx, &
&   npy)
    IMPLICIT NONE
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: jord
    INTEGER, INTENT(IN) :: npx, npy
    REAL, INTENT(IN) :: q(ifirst:ilast, jfirst-ng:jlast+ng)
! Courant number
    REAL, INTENT(IN) :: c(isd:ied, js:je+1)
!  Flux
    REAL, INTENT(OUT) :: flux(ifirst:ilast, jfirst:jlast+1)
! Local:
    REAL :: dm(ifirst:ilast, jfirst-2:jlast+2)
    REAL :: al(ifirst:ilast, jfirst-1:jlast+2)
    REAL :: bl(ifirst:ilast, jfirst-1:jlast+1)
    REAL :: br(ifirst:ilast, jfirst-1:jlast+1)
    REAL :: dq(ifirst:ilast, jfirst-3:jlast+2)
    LOGICAL :: extm(ifirst:ilast, jfirst-2:jlast+2)
    REAL :: xt, pmp_1, lac_1, pmp_2, lac_2
    INTEGER :: i, j, js1, je3, je1
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTEGER :: abs0
    IF (.NOT.nested .AND. grid_type .LT. 3) THEN
      IF (3 .LT. js - 1) THEN
        js1 = js - 1
      ELSE
        js1 = 3
      END IF
      IF (npy - 2 .GT. je + 2) THEN
        je3 = je + 2
      ELSE
        je3 = npy - 2
      END IF
      IF (npy - 3 .GT. je + 1) THEN
        je1 = je + 1
      ELSE
        je1 = npy - 3
      END IF
    ELSE
! Nested grid OR Doubly periodic domain:
      js1 = js - 1
      je3 = je + 2
      je1 = je + 1
    END IF
    IF (jord .GE. 0.) THEN
      abs0 = jord
    ELSE
      abs0 = -jord
    END IF
    IF (abs0 .LT. 8) THEN
! ord = -5: linear scheme based on PPM 4th order interpolation
! ord = -6: linear PPM with 2-delta filter
! ord = -7: (-6) with additional Positive definite constraint:
      DO j=js1,je3
        DO i=ifirst,ilast
          al(i, j) = p1*(q(i, j-1)+q(i, j)) + p2*(q(i, j-2)+q(i, j+1))
        END DO
      END DO
      IF (.NOT.nested .AND. grid_type .LT. 3) THEN
        IF (js .EQ. 1) THEN
          DO i=ifirst,ilast
            al(i, 0) = c1*q(i, -2) + c2*q(i, -1) + c3*q(i, 0)
            al(i, 1) = 0.5*(((2.*dya(i, 0)+dya(i, -1))*q(i, 0)-dya(i, 0)&
&             *q(i, -1))/(dya(i, -1)+dya(i, 0))+((2.*dya(i, 1)+dya(i, 2)&
&             )*q(i, 1)-dya(i, 1)*q(i, 2))/(dya(i, 1)+dya(i, 2)))
            al(i, 2) = c3*q(i, 1) + c2*q(i, 2) + c1*q(i, 3)
          END DO
        END IF
        IF (je + 1 .EQ. npy) THEN
          DO i=ifirst,ilast
            al(i, npy-1) = c1*q(i, npy-3) + c2*q(i, npy-2) + c3*q(i, npy&
&             -1)
            al(i, npy) = 0.5*(((2.*dya(i, npy-1)+dya(i, npy-2))*q(i, npy&
&             -1)-dya(i, npy-1)*q(i, npy-2))/(dya(i, npy-2)+dya(i, npy-1&
&             ))+((2.*dya(i, npy)+dya(i, npy+1))*q(i, npy)-dya(i, npy)*q&
&             (i, npy+1))/(dya(i, npy)+dya(i, npy+1)))
            al(i, npy+1) = c3*q(i, npy) + c2*q(i, npy+1) + c1*q(i, npy+2&
&             )
          END DO
        END IF
      END IF
      IF (jord .EQ. -5) THEN
        DO j=jfirst-1,jlast+1
          DO i=ifirst,ilast
            bl(i, j) = al(i, j) - q(i, j)
            br(i, j) = al(i, j+1) - q(i, j)
          END DO
        END DO
      END IF
    END IF
    DO j=jfirst,jlast+1
      DO i=ifirst,ilast
        IF (c(i, j) .GT. 0.) THEN
          flux(i, j) = q(i, j-1) + (1.-c(i, j))*(br(i, j-1)-c(i, j)*(bl(&
&           i, j-1)+br(i, j-1)))
        ELSE
          flux(i, j) = q(i, j) + (1.+c(i, j))*(bl(i, j)+c(i, j)*(bl(i, j&
&           )+br(i, j)))
        END IF
      END DO
    END DO
  END SUBROUTINE YPPM0
!  Differentiation of fxppm in forward (tangent) mode:
!   variations   of useful results: flux
!   with respect to varying inputs: q
  SUBROUTINE FXPPM_TLM(c, q, q_tl, flux, flux_tl, iord, ifirst, ilast, &
&   jfirst, jlast, npx, npy)
    IMPLICIT NONE
! !INPUT PARAMETERS:
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: iord
    INTEGER, INTENT(IN) :: npx, npy
    REAL(fvprc), INTENT(IN) :: q(ifirst-ng:ilast+ng, jfirst:jlast)
    REAL(fvprc), INTENT(IN) :: q_tl(ifirst-ng:ilast+ng, jfirst:jlast)
! Courant   N (like FLUX)
    REAL(fvprc), INTENT(IN) :: c(ifirst:ilast+1, jfirst:jlast)
! !OUTPUT PARAMETERS:
!  Flux
    REAL(fvprc), INTENT(OUT) :: flux(ifirst:ilast+1, jfirst:jlast)
    REAL(fvprc), INTENT(OUT) :: flux_tl(ifirst:ilast+1, jfirst:jlast)
! Local
    LOGICAL :: extm(ifirst-2:ilast+2)
    REAL(fvprc) :: dm1(ifirst-2:ilast+2)
    REAL(fvprc) :: al(ifirst-1:ilast+2)
    REAL(fvprc) :: bl(ifirst-1:ilast+1)
    REAL(fvprc) :: bl_tl(ifirst-1:ilast+1)
    REAL(fvprc) :: br(ifirst-1:ilast+1)
    REAL(fvprc) :: br_tl(ifirst-1:ilast+1)
    REAL(fvprc) :: dq(ifirst-3:ilast+2)
    REAL(fvprc) :: dl, dr, pmp, lac, ct, qe
    REAL(fvprc) :: pmp_1, lac_1, pmp_2, lac_2
    REAL(fvprc) :: xt, x1, x0, x0l, x0r
    REAL(fvprc) :: xt_tl, x0l_tl, x0r_tl
    INTEGER :: i, j, is3, ie3, it
    INTRINSIC MAX
    INTRINSIC MIN
    x0 = big_number
    IF (3 .LT. is - 1) THEN
      is3 = is - 1
    ELSE
      is3 = 3
    END IF
    IF (npx - 3 .GT. ie + 1) THEN
      ie3 = ie + 1
    ELSE
      ie3 = npx - 3
    END IF
    IF (iord .EQ. 666) THEN
      flux_tl = 0.0_8
      bl_tl = 0.0_8
      br_tl = 0.0_8
!From NCEP dynamics version
      DO j=jfirst,jlast
        DO i=is3,ie3
          bl_tl(i) = b5*q_tl(i-2, j) + b4*q_tl(i-1, j) + b3*q_tl(i, j) +&
&           b2*q_tl(i+1, j) + b1*q_tl(i+2, j)
          bl(i) = b5*q(i-2, j) + b4*q(i-1, j) + b3*q(i, j) + b2*q(i+1, j&
&           ) + b1*q(i+2, j)
          br_tl(i) = b1*q_tl(i-2, j) + b2*q_tl(i-1, j) + b3*q_tl(i, j) +&
&           b4*q_tl(i+1, j) + b5*q_tl(i+2, j)
          br(i) = b1*q(i-2, j) + b2*q(i-1, j) + b3*q(i, j) + b4*q(i+1, j&
&           ) + b5*q(i+2, j)
        END DO
!--------------
! fix the edges
!--------------
        IF (is .EQ. 1) THEN
          x0l_tl = 0.5*((2.*dxa(0, j)+dxa(-1, j))*q_tl(0, j)-dxa(0, j)*&
&           q_tl(-1, j))/(dxa(0, j)+dxa(-1, j))
          x0l = 0.5*((2.*dxa(0, j)+dxa(-1, j))*q(0, j)-dxa(0, j)*q(-1, j&
&           ))/(dxa(0, j)+dxa(-1, j))
          x0r_tl = 0.5*((2.*dxa(1, j)+dxa(2, j))*q_tl(1, j)-dxa(1, j)*&
&           q_tl(2, j))/(dxa(1, j)+dxa(2, j))
          x0r = 0.5*((2.*dxa(1, j)+dxa(2, j))*q(1, j)-dxa(1, j)*q(2, j))&
&           /(dxa(1, j)+dxa(2, j))
          br_tl(2) = p1*(q_tl(2, j)+q_tl(3, j)) + p2*(q_tl(1, j)+q_tl(4&
&           , j)) - q_tl(2, j)
          br(2) = p1*(q(2, j)+q(3, j)) + p2*(q(1, j)+q(4, j)) - q(2, j)
          xt_tl = x0l_tl + x0r_tl
          xt = x0l + x0r
          bl_tl(1) = xt_tl - q_tl(1, j)
          bl(1) = xt - q(1, j)
          br_tl(0) = xt_tl - q_tl(0, j)
          br(0) = xt - q(0, j)
          xt_tl = c1*q_tl(-2, j) + c2*q_tl(-1, j) + c3*q_tl(0, j)
          xt = c1*q(-2, j) + c2*q(-1, j) + c3*q(0, j)
          bl_tl(0) = xt_tl - q_tl(0, j)
          bl(0) = xt - q(0, j)
          xt_tl = c3*q_tl(1, j) + c2*q_tl(2, j) + c1*q_tl(3, j)
          xt = c3*q(1, j) + c2*q(2, j) + c1*q(3, j)
          br_tl(1) = xt_tl - q_tl(1, j)
          br(1) = xt - q(1, j)
          bl_tl(2) = xt_tl - q_tl(2, j)
          bl(2) = xt - q(2, j)
        END IF
        IF (ie + 1 .EQ. npx) THEN
          x0l_tl = 0.5*((2.*dxa(npx-1, j)+dxa(npx-2, j))*q_tl(npx-1, j)-&
&           dxa(npx-1, j)*q_tl(npx-2, j))/(dxa(npx-1, j)+dxa(npx-2, j))
          x0l = 0.5*((2.*dxa(npx-1, j)+dxa(npx-2, j))*q(npx-1, j)-dxa(&
&           npx-1, j)*q(npx-2, j))/(dxa(npx-1, j)+dxa(npx-2, j))
          x0r_tl = 0.5*((2.*dxa(npx, j)+dxa(npx+1, j))*q_tl(npx, j)-dxa(&
&           npx, j)*q_tl(npx+1, j))/(dxa(npx, j)+dxa(npx+1, j))
          x0r = 0.5*((2.*dxa(npx, j)+dxa(npx+1, j))*q(npx, j)-dxa(npx, j&
&           )*q(npx+1, j))/(dxa(npx, j)+dxa(npx+1, j))
          bl_tl(npx-2) = p1*(q_tl(npx-2, j)+q_tl(npx-3, j)) + p2*(q_tl(&
&           npx-4, j)+q_tl(npx-1, j)) - q_tl(npx-2, j)
          bl(npx-2) = p1*(q(npx-2, j)+q(npx-3, j)) + p2*(q(npx-4, j)+q(&
&           npx-1, j)) - q(npx-2, j)
!             xt = x0L*sin_sg(npx-1,j,3) + x0R*sin_sg(npx,j,1)
!             xt = 2.*xt / (sin_sg(npx,j,1) + sin_sg(npx-1,j,3))
          xt_tl = x0l_tl + x0r_tl
          xt = x0l + x0r
          br_tl(npx-1) = xt_tl - q_tl(npx-1, j)
          br(npx-1) = xt - q(npx-1, j)
          bl_tl(npx) = xt_tl - q_tl(npx, j)
          bl(npx) = xt - q(npx, j)
          xt_tl = c3*q_tl(npx, j) + c2*q_tl(npx+1, j) + c1*q_tl(npx+2, j&
&           )
          xt = c3*q(npx, j) + c2*q(npx+1, j) + c1*q(npx+2, j)
          br_tl(npx) = xt_tl - q_tl(npx, j)
          br(npx) = xt - q(npx, j)
          xt_tl = c1*q_tl(npx-3, j) + c2*q_tl(npx-2, j) + c3*q_tl(npx-1&
&           , j)
          xt = c1*q(npx-3, j) + c2*q(npx-2, j) + c3*q(npx-1, j)
          br_tl(npx-2) = xt_tl - q_tl(npx-2, j)
          br(npx-2) = xt - q(npx-2, j)
          bl_tl(npx-1) = xt_tl - q_tl(npx-1, j)
          bl(npx-1) = xt - q(npx-1, j)
        END IF
        DO i=ifirst,ilast+1
          IF (c(i, j) .GT. 0.) THEN
            flux_tl(i, j) = q_tl(i-1, j) + (1.-c(i, j))*(br_tl(i-1)-c(i&
&             , j)*(bl_tl(i-1)+br_tl(i-1)))
            flux(i, j) = q(i-1, j) + (1.-c(i, j))*(br(i-1)-c(i, j)*(bl(i&
&             -1)+br(i-1)))
          ELSE
            flux_tl(i, j) = q_tl(i, j) + (1.+c(i, j))*(bl_tl(i)+c(i, j)*&
&             (bl_tl(i)+br_tl(i)))
            flux(i, j) = q(i, j) + (1.+c(i, j))*(bl(i)+c(i, j)*(bl(i)+br&
&             (i)))
          END IF
        END DO
      END DO
    ELSE
      flux_tl = 0.0_8
    END IF
  END SUBROUTINE FXPPM_TLM
  SUBROUTINE FXPPM(c, q, flux, iord, ifirst, ilast, jfirst, jlast, npx, &
&   npy)
    IMPLICIT NONE
! !INPUT PARAMETERS:
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: iord
    INTEGER, INTENT(IN) :: npx, npy
    REAL(fvprc), INTENT(IN) :: q(ifirst-ng:ilast+ng, jfirst:jlast)
! Courant   N (like FLUX)
    REAL(fvprc), INTENT(IN) :: c(ifirst:ilast+1, jfirst:jlast)
! !OUTPUT PARAMETERS:
!  Flux
    REAL(fvprc), INTENT(OUT) :: flux(ifirst:ilast+1, jfirst:jlast)
! Local
    LOGICAL :: extm(ifirst-2:ilast+2)
    REAL(fvprc) :: dm1(ifirst-2:ilast+2)
    REAL(fvprc) :: al(ifirst-1:ilast+2)
    REAL(fvprc) :: bl(ifirst-1:ilast+1)
    REAL(fvprc) :: br(ifirst-1:ilast+1)
    REAL(fvprc) :: dq(ifirst-3:ilast+2)
    REAL(fvprc) :: dl, dr, pmp, lac, ct, qe
    REAL(fvprc) :: pmp_1, lac_1, pmp_2, lac_2
    REAL(fvprc) :: xt, x1, x0, x0l, x0r
    INTEGER :: i, j, is3, ie3, it
    INTRINSIC MAX
    INTRINSIC MIN
    x0 = big_number
    IF (3 .LT. is - 1) THEN
      is3 = is - 1
    ELSE
      is3 = 3
    END IF
    IF (npx - 3 .GT. ie + 1) THEN
      ie3 = ie + 1
    ELSE
      ie3 = npx - 3
    END IF
    IF (iord .EQ. 666) THEN
!From NCEP dynamics version
      DO j=jfirst,jlast
        DO i=is3,ie3
          bl(i) = b5*q(i-2, j) + b4*q(i-1, j) + b3*q(i, j) + b2*q(i+1, j&
&           ) + b1*q(i+2, j)
          br(i) = b1*q(i-2, j) + b2*q(i-1, j) + b3*q(i, j) + b4*q(i+1, j&
&           ) + b5*q(i+2, j)
        END DO
!--------------
! fix the edges
!--------------
        IF (is .EQ. 1) THEN
          x0l = 0.5*((2.*dxa(0, j)+dxa(-1, j))*q(0, j)-dxa(0, j)*q(-1, j&
&           ))/(dxa(0, j)+dxa(-1, j))
          x0r = 0.5*((2.*dxa(1, j)+dxa(2, j))*q(1, j)-dxa(1, j)*q(2, j))&
&           /(dxa(1, j)+dxa(2, j))
          br(2) = p1*(q(2, j)+q(3, j)) + p2*(q(1, j)+q(4, j)) - q(2, j)
          xt = x0l + x0r
          bl(1) = xt - q(1, j)
          br(0) = xt - q(0, j)
          xt = c1*q(-2, j) + c2*q(-1, j) + c3*q(0, j)
          bl(0) = xt - q(0, j)
          xt = c3*q(1, j) + c2*q(2, j) + c1*q(3, j)
          br(1) = xt - q(1, j)
          bl(2) = xt - q(2, j)
        END IF
        IF (ie + 1 .EQ. npx) THEN
          x0l = 0.5*((2.*dxa(npx-1, j)+dxa(npx-2, j))*q(npx-1, j)-dxa(&
&           npx-1, j)*q(npx-2, j))/(dxa(npx-1, j)+dxa(npx-2, j))
          x0r = 0.5*((2.*dxa(npx, j)+dxa(npx+1, j))*q(npx, j)-dxa(npx, j&
&           )*q(npx+1, j))/(dxa(npx, j)+dxa(npx+1, j))
          bl(npx-2) = p1*(q(npx-2, j)+q(npx-3, j)) + p2*(q(npx-4, j)+q(&
&           npx-1, j)) - q(npx-2, j)
!             xt = x0L*sin_sg(npx-1,j,3) + x0R*sin_sg(npx,j,1)
!             xt = 2.*xt / (sin_sg(npx,j,1) + sin_sg(npx-1,j,3))
          xt = x0l + x0r
          br(npx-1) = xt - q(npx-1, j)
          bl(npx) = xt - q(npx, j)
          xt = c3*q(npx, j) + c2*q(npx+1, j) + c1*q(npx+2, j)
          br(npx) = xt - q(npx, j)
          xt = c1*q(npx-3, j) + c2*q(npx-2, j) + c3*q(npx-1, j)
          br(npx-2) = xt - q(npx-2, j)
          bl(npx-1) = xt - q(npx-1, j)
        END IF
        DO i=ifirst,ilast+1
          IF (c(i, j) .GT. 0.) THEN
            flux(i, j) = q(i-1, j) + (1.-c(i, j))*(br(i-1)-c(i, j)*(bl(i&
&             -1)+br(i-1)))
          ELSE
            flux(i, j) = q(i, j) + (1.+c(i, j))*(bl(i)+c(i, j)*(bl(i)+br&
&             (i)))
          END IF
        END DO
      END DO
    END IF
  END SUBROUTINE FXPPM
!  Differentiation of fyppm in forward (tangent) mode:
!   variations   of useful results: flux
!   with respect to varying inputs: q
  SUBROUTINE FYPPM_TLM(c, q, q_tl, flux, flux_tl, jord, ifirst, ilast, &
&   jfirst, jlast, npx, npy)
    IMPLICIT NONE
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: jord
    INTEGER, INTENT(IN) :: npx, npy
    REAL(fvprc), INTENT(IN) :: q(ifirst:ilast, jfirst-ng:jlast+ng)
    REAL(fvprc), INTENT(IN) :: q_tl(ifirst:ilast, jfirst-ng:jlast+ng)
! Courant number
    REAL(fvprc), INTENT(IN) :: c(isd:ied, js:je+1)
!  Flux
    REAL(fvprc), INTENT(OUT) :: flux(ifirst:ilast, jfirst:jlast+1)
    REAL(fvprc), INTENT(OUT) :: flux_tl(ifirst:ilast, jfirst:jlast+1)
! real(FVPRC)   , INTENT(OUT)::   dm(ifirst:ilast,jfirst-2:jlast+2)
! Local:
    LOGICAL :: extm(ifirst:ilast, jfirst-2:jlast+2)
    REAL(fvprc) :: al(ifirst:ilast, jfirst-1:jlast+2)
    REAL(fvprc) :: bl(ifirst:ilast, jfirst-1:jlast+1)
    REAL(fvprc) :: bl_tl(ifirst:ilast, jfirst-1:jlast+1)
    REAL(fvprc) :: br(ifirst:ilast, jfirst-1:jlast+1)
    REAL(fvprc) :: br_tl(ifirst:ilast, jfirst-1:jlast+1)
    REAL(fvprc) :: dq(ifirst:ilast, jfirst-3:jlast+2)
    REAL(fvprc) :: dl, dr, pmp, lac, ct, qe
    REAL(fvprc) :: pmp_1, lac_1, pmp_2, lac_2
    REAL(fvprc) :: xt, x0, x1, x0l, x0r
    REAL(fvprc) :: xt_tl, x0l_tl, x0r_tl
    INTEGER :: i, j, js3, je3, jt
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: min1
    IF (jord .EQ. 666) THEN
      IF (3 .LT. js - 1) THEN
        max1 = js - 1
      ELSE
        max1 = 3
      END IF
      IF (npy - 3 .GT. je + 1) THEN
        min1 = je + 1
        bl_tl = 0.0_8
        br_tl = 0.0_8
      ELSE
        min1 = npy - 3
        bl_tl = 0.0_8
        br_tl = 0.0_8
      END IF
      DO j=max1,min1
        DO i=ifirst,ilast
          bl_tl(i, j) = b5*q_tl(i, j-2) + b4*q_tl(i, j-1) + b3*q_tl(i, j&
&           ) + b2*q_tl(i, j+1) + b1*q_tl(i, j+2)
          bl(i, j) = b5*q(i, j-2) + b4*q(i, j-1) + b3*q(i, j) + b2*q(i, &
&           j+1) + b1*q(i, j+2)
          br_tl(i, j) = b1*q_tl(i, j-2) + b2*q_tl(i, j-1) + b3*q_tl(i, j&
&           ) + b4*q_tl(i, j+1) + b5*q_tl(i, j+2)
          br(i, j) = b1*q(i, j-2) + b2*q(i, j-1) + b3*q(i, j) + b4*q(i, &
&           j+1) + b5*q(i, j+2)
        END DO
      END DO
      IF (js .EQ. 1) THEN
        DO i=ifirst,ilast
!           br(i,2) = al(i,3) - q(i,2)
          br_tl(i, 2) = p1*(q_tl(i, 2)+q_tl(i, 3)) + p2*(q_tl(i, 1)+q_tl&
&           (i, 4)) - q_tl(i, 2)
          br(i, 2) = p1*(q(i, 2)+q(i, 3)) + p2*(q(i, 1)+q(i, 4)) - q(i, &
&           2)
          x0l_tl = 0.5*((2.*dya(i, 0)+dya(i, -1))*q_tl(i, 0)-dya(i, 0)*&
&           q_tl(i, -1))/(dya(i, 0)+dya(i, -1))
          x0l = 0.5*((2.*dya(i, 0)+dya(i, -1))*q(i, 0)-dya(i, 0)*q(i, -1&
&           ))/(dya(i, 0)+dya(i, -1))
          x0r_tl = 0.5*((2.*dya(i, 1)+dya(i, 2))*q_tl(i, 1)-dya(i, 1)*&
&           q_tl(i, 2))/(dya(i, 1)+dya(i, 2))
          x0r = 0.5*((2.*dya(i, 1)+dya(i, 2))*q(i, 1)-dya(i, 1)*q(i, 2))&
&           /(dya(i, 1)+dya(i, 2))
          xt_tl = x0l_tl + x0r_tl
          xt = x0l + x0r
!            xt = ( x0L*sin_sg(i,0,4) + x0R*sin_sg(i,1,2) ) 
!            xt = 2.*xt / ( sin_sg(i,0,4) + sin_sg(i,1,2) )
          bl_tl(i, 1) = xt_tl - q_tl(i, 1)
          bl(i, 1) = xt - q(i, 1)
          br_tl(i, 0) = xt_tl - q_tl(i, 0)
          br(i, 0) = xt - q(i, 0)
!           xt = s14*0.25*(q(i,0)-q(i,-2)) - s11*(q(i,0)-q(i,-1)) + q(i,0)
          xt_tl = c1*q_tl(i, -2) + c2*q_tl(i, -1) + c3*q_tl(i, 0)
          xt = c1*q(i, -2) + c2*q(i, -1) + c3*q(i, 0)
          bl_tl(i, 0) = xt_tl - q_tl(i, 0)
          bl(i, 0) = xt - q(i, 0)
!           xt = s15*q(i,1) + s11*q(i,2) - s14*0.25*(q(i,3)-q(i,1))
          xt_tl = c3*q_tl(i, 1) + c2*q_tl(i, 2) + c1*q_tl(i, 3)
          xt = c3*q(i, 1) + c2*q(i, 2) + c1*q(i, 3)
          br_tl(i, 1) = xt_tl - q_tl(i, 1)
          br(i, 1) = xt - q(i, 1)
          bl_tl(i, 2) = xt_tl - q_tl(i, 2)
          bl(i, 2) = xt - q(i, 2)
        END DO
      END IF
      IF (je + 1 .EQ. npy) THEN
        DO i=ifirst,ilast
!           bl(i,npy-2) = al(i,npy-2) - q(i,npy-2)
          bl_tl(i, npy-2) = p1*(q_tl(i, npy-3)+q_tl(i, npy-2)) + p2*(&
&           q_tl(i, npy-4)+q_tl(i, npy-1)) - q_tl(i, npy-2)
          bl(i, npy-2) = p1*(q(i, npy-3)+q(i, npy-2)) + p2*(q(i, npy-4)+&
&           q(i, npy-1)) - q(i, npy-2)
          x0l_tl = 0.5*((2.*dya(i, npy-1)+dya(i, npy-2))*q_tl(i, npy-1)-&
&           dya(i, npy-1)*q_tl(i, npy-2))/(dya(i, npy-1)+dya(i, npy-2))
          x0l = 0.5*((2.*dya(i, npy-1)+dya(i, npy-2))*q(i, npy-1)-dya(i&
&           , npy-1)*q(i, npy-2))/(dya(i, npy-1)+dya(i, npy-2))
          x0r_tl = 0.5*((2.*dya(i, npy)+dya(i, npy+1))*q_tl(i, npy)-dya(&
&           i, npy)*q_tl(i, npy+1))/(dya(i, npy)+dya(i, npy+1))
          x0r = 0.5*((2.*dya(i, npy)+dya(i, npy+1))*q(i, npy)-dya(i, npy&
&           )*q(i, npy+1))/(dya(i, npy)+dya(i, npy+1))
          xt_tl = x0l_tl + x0r_tl
          xt = x0l + x0r
!            xt = x0L*sin_sg(i,npy-1,4) + x0R*sin_sg(i,npy,2)
!            xt = 2.*xt /( sin_sg(i,npy-1,4) + sin_sg(i,npy,2) )
          br_tl(i, npy-1) = xt_tl - q_tl(i, npy-1)
          br(i, npy-1) = xt - q(i, npy-1)
          bl_tl(i, npy) = xt_tl - q_tl(i, npy)
          bl(i, npy) = xt - q(i, npy)
!           xt = s11*(q(i,npy+1)-q(i,npy)) - s14*0.25*(q(i,npy+2)-q(i,npy)) + q(i,npy)
          xt_tl = c3*q_tl(i, npy) + c2*q_tl(i, npy+1) + c1*q_tl(i, npy+2&
&           )
          xt = c3*q(i, npy) + c2*q(i, npy+1) + c1*q(i, npy+2)
          br_tl(i, npy) = xt_tl - q_tl(i, npy)
          br(i, npy) = xt - q(i, npy)
!           xt = s15*q(i,npy-1) + s11*q(i,npy-2) + s14*0.25*(q(i,npy-1)-q(i,npy-3))
          xt_tl = c1*q_tl(i, npy-3) + c2*q_tl(i, npy-2) + c3*q_tl(i, npy&
&           -1)
          xt = c1*q(i, npy-3) + c2*q(i, npy-2) + c3*q(i, npy-1)
          br_tl(i, npy-2) = xt_tl - q_tl(i, npy-2)
          br(i, npy-2) = xt - q(i, npy-2)
          bl_tl(i, npy-1) = xt_tl - q_tl(i, npy-1)
          bl(i, npy-1) = xt - q(i, npy-1)
        END DO
        flux_tl = 0.0_8
      ELSE
        flux_tl = 0.0_8
      END IF
      DO j=jfirst,jlast+1
        DO i=ifirst,ilast
          IF (c(i, j) .GT. 0.) THEN
            flux_tl(i, j) = q_tl(i, j-1) + (1.-c(i, j))*(br_tl(i, j-1)-c&
&             (i, j)*(bl_tl(i, j-1)+br_tl(i, j-1)))
            flux(i, j) = q(i, j-1) + (1.-c(i, j))*(br(i, j-1)-c(i, j)*(&
&             bl(i, j-1)+br(i, j-1)))
          ELSE
            flux_tl(i, j) = q_tl(i, j) + (1.+c(i, j))*(bl_tl(i, j)+c(i, &
&             j)*(bl_tl(i, j)+br_tl(i, j)))
            flux(i, j) = q(i, j) + (1.+c(i, j))*(bl(i, j)+c(i, j)*(bl(i&
&             , j)+br(i, j)))
          END IF
        END DO
      END DO
    ELSE
      flux_tl = 0.0_8
    END IF
  END SUBROUTINE FYPPM_TLM
  SUBROUTINE FYPPM(c, q, flux, jord, ifirst, ilast, jfirst, jlast, npx, &
&   npy)
    IMPLICIT NONE
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: jord
    INTEGER, INTENT(IN) :: npx, npy
    REAL(fvprc), INTENT(IN) :: q(ifirst:ilast, jfirst-ng:jlast+ng)
! Courant number
    REAL(fvprc), INTENT(IN) :: c(isd:ied, js:je+1)
!  Flux
    REAL(fvprc), INTENT(OUT) :: flux(ifirst:ilast, jfirst:jlast+1)
! real(FVPRC)   , INTENT(OUT)::   dm(ifirst:ilast,jfirst-2:jlast+2)
! Local:
    LOGICAL :: extm(ifirst:ilast, jfirst-2:jlast+2)
    REAL(fvprc) :: al(ifirst:ilast, jfirst-1:jlast+2)
    REAL(fvprc) :: bl(ifirst:ilast, jfirst-1:jlast+1)
    REAL(fvprc) :: br(ifirst:ilast, jfirst-1:jlast+1)
    REAL(fvprc) :: dq(ifirst:ilast, jfirst-3:jlast+2)
    REAL(fvprc) :: dl, dr, pmp, lac, ct, qe
    REAL(fvprc) :: pmp_1, lac_1, pmp_2, lac_2
    REAL(fvprc) :: xt, x0, x1, x0l, x0r
    INTEGER :: i, j, js3, je3, jt
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: min1
    IF (jord .EQ. 666) THEN
      IF (3 .LT. js - 1) THEN
        max1 = js - 1
      ELSE
        max1 = 3
      END IF
      IF (npy - 3 .GT. je + 1) THEN
        min1 = je + 1
      ELSE
        min1 = npy - 3
      END IF
      DO j=max1,min1
        DO i=ifirst,ilast
          bl(i, j) = b5*q(i, j-2) + b4*q(i, j-1) + b3*q(i, j) + b2*q(i, &
&           j+1) + b1*q(i, j+2)
          br(i, j) = b1*q(i, j-2) + b2*q(i, j-1) + b3*q(i, j) + b4*q(i, &
&           j+1) + b5*q(i, j+2)
        END DO
      END DO
      IF (js .EQ. 1) THEN
        DO i=ifirst,ilast
!           br(i,2) = al(i,3) - q(i,2)
          br(i, 2) = p1*(q(i, 2)+q(i, 3)) + p2*(q(i, 1)+q(i, 4)) - q(i, &
&           2)
          x0l = 0.5*((2.*dya(i, 0)+dya(i, -1))*q(i, 0)-dya(i, 0)*q(i, -1&
&           ))/(dya(i, 0)+dya(i, -1))
          x0r = 0.5*((2.*dya(i, 1)+dya(i, 2))*q(i, 1)-dya(i, 1)*q(i, 2))&
&           /(dya(i, 1)+dya(i, 2))
          xt = x0l + x0r
!            xt = ( x0L*sin_sg(i,0,4) + x0R*sin_sg(i,1,2) ) 
!            xt = 2.*xt / ( sin_sg(i,0,4) + sin_sg(i,1,2) )
          bl(i, 1) = xt - q(i, 1)
          br(i, 0) = xt - q(i, 0)
!           xt = s14*0.25*(q(i,0)-q(i,-2)) - s11*(q(i,0)-q(i,-1)) + q(i,0)
          xt = c1*q(i, -2) + c2*q(i, -1) + c3*q(i, 0)
          bl(i, 0) = xt - q(i, 0)
!           xt = s15*q(i,1) + s11*q(i,2) - s14*0.25*(q(i,3)-q(i,1))
          xt = c3*q(i, 1) + c2*q(i, 2) + c1*q(i, 3)
          br(i, 1) = xt - q(i, 1)
          bl(i, 2) = xt - q(i, 2)
        END DO
      END IF
      IF (je + 1 .EQ. npy) THEN
        DO i=ifirst,ilast
!           bl(i,npy-2) = al(i,npy-2) - q(i,npy-2)
          bl(i, npy-2) = p1*(q(i, npy-3)+q(i, npy-2)) + p2*(q(i, npy-4)+&
&           q(i, npy-1)) - q(i, npy-2)
          x0l = 0.5*((2.*dya(i, npy-1)+dya(i, npy-2))*q(i, npy-1)-dya(i&
&           , npy-1)*q(i, npy-2))/(dya(i, npy-1)+dya(i, npy-2))
          x0r = 0.5*((2.*dya(i, npy)+dya(i, npy+1))*q(i, npy)-dya(i, npy&
&           )*q(i, npy+1))/(dya(i, npy)+dya(i, npy+1))
          xt = x0l + x0r
!            xt = x0L*sin_sg(i,npy-1,4) + x0R*sin_sg(i,npy,2)
!            xt = 2.*xt /( sin_sg(i,npy-1,4) + sin_sg(i,npy,2) )
          br(i, npy-1) = xt - q(i, npy-1)
          bl(i, npy) = xt - q(i, npy)
!           xt = s11*(q(i,npy+1)-q(i,npy)) - s14*0.25*(q(i,npy+2)-q(i,npy)) + q(i,npy)
          xt = c3*q(i, npy) + c2*q(i, npy+1) + c1*q(i, npy+2)
          br(i, npy) = xt - q(i, npy)
!           xt = s15*q(i,npy-1) + s11*q(i,npy-2) + s14*0.25*(q(i,npy-1)-q(i,npy-3))
          xt = c1*q(i, npy-3) + c2*q(i, npy-2) + c3*q(i, npy-1)
          br(i, npy-2) = xt - q(i, npy-2)
          bl(i, npy-1) = xt - q(i, npy-1)
        END DO
      END IF
      DO j=jfirst,jlast+1
        DO i=ifirst,ilast
          IF (c(i, j) .GT. 0.) THEN
            flux(i, j) = q(i, j-1) + (1.-c(i, j))*(br(i, j-1)-c(i, j)*(&
&             bl(i, j-1)+br(i, j-1)))
          ELSE
            flux(i, j) = q(i, j) + (1.+c(i, j))*(bl(i, j)+c(i, j)*(bl(i&
&             , j)+br(i, j)))
          END IF
        END DO
      END DO
    END IF
  END SUBROUTINE FYPPM
  SUBROUTINE MP_GHOST_EW(im, jm, km, nq, ifirst, ilast, jfirst, jlast, &
&   kfirst, klast, ng_w, ng_e, ng_s, ng_n, q_ghst, q)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
    INTEGER, INTENT(IN) :: im, jm, km, nq
    INTEGER, INTENT(IN) :: ifirst, ilast
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: kfirst, klast
! eastern  zones to ghost
    INTEGER, INTENT(IN) :: ng_e
! western  zones to ghost
    INTEGER, INTENT(IN) :: ng_w
! southern zones to ghost
    INTEGER, INTENT(IN) :: ng_s
! northern zones to ghost
    INTEGER, INTENT(IN) :: ng_n
    REAL(fvprc), INTENT(INOUT) :: q_ghst(ifirst-ng_w:ilast+ng_e, jfirst-&
&   ng_s:jlast+ng_n, kfirst:klast, nq)
    REAL(fvprc), OPTIONAL, INTENT(IN) :: q(ifirst:ilast, jfirst:jlast, &
&   kfirst:klast, nq)
!
! !DESCRIPTION:
!
!     Ghost 4d east/west 
!
! !REVISION HISTORY:
!    2005.08.22   Putman
!
!EOP
!------------------------------------------------------------------------------
!BOC
    INTEGER :: i, j, k, n
    INTRINSIC PRESENT
    IF (PRESENT(q)) q_ghst(ifirst:ilast, jfirst:jlast, kfirst:klast, 1:&
&     nq) = q(ifirst:ilast, jfirst:jlast, kfirst:klast, 1:nq)
!      Assume Periodicity in X-dir and not overlapping
    DO n=1,nq
      DO k=kfirst,klast
        DO j=jfirst-ng_s,jlast+ng_n
          DO i=1,ng_w
            q_ghst(ifirst-i, j, k, n) = q_ghst(ilast-i+1, j, k, n)
          END DO
          DO i=1,ng_e
            q_ghst(ilast+i, j, k, n) = q_ghst(ifirst+i-1, j, k, n)
          END DO
        END DO
      END DO
    END DO
  END SUBROUTINE MP_GHOST_EW
  SUBROUTINE PERT_PPM(im, a0, al, ar, iv)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: im
    INTEGER, INTENT(IN) :: iv
    REAL(fvprc), INTENT(IN) :: a0(im)
    REAL(fvprc), INTENT(INOUT) :: al(im), ar(im)
! Local:
    REAL(fvprc) :: a4, da1, da2, a6da, fmin
    INTEGER :: i
    REAL(fvprc), PARAMETER :: r12=1./12.
    INTRINSIC ABS
    REAL*8 :: abs0
!-----------------------------------
! Optimized PPM in perturbation form:
!-----------------------------------
    IF (iv .EQ. 0) THEN
! Positive definite constraint
      DO i=1,im
        IF (a0(i) .LE. 0.) THEN
          al(i) = 0.
          ar(i) = 0.
        ELSE
          a4 = -(3.*(ar(i)+al(i)))
          da1 = ar(i) - al(i)
          IF (da1 .GE. 0.) THEN
            abs0 = da1
          ELSE
            abs0 = -da1
          END IF
          IF (abs0 .LT. -a4) THEN
            fmin = a0(i) + 0.25/a4*da1**2 + a4*r12
            IF (fmin .LT. 0.) THEN
              IF (ar(i) .GT. 0. .AND. al(i) .GT. 0.) THEN
                ar(i) = 0.
                al(i) = 0.
              ELSE IF (da1 .GT. 0.) THEN
                ar(i) = -(2.*al(i))
              ELSE
                al(i) = -(2.*ar(i))
              END IF
            END IF
          END IF
        END IF
      END DO
    ELSE
! Standard PPM constraint
      DO i=1,im
        IF (al(i)*ar(i) .LT. 0.) THEN
          da1 = al(i) - ar(i)
          da2 = da1**2
          a6da = 3.*(al(i)+ar(i))*da1
          IF (a6da .LT. -da2) THEN
            ar(i) = -(2.*al(i))
          ELSE IF (a6da .GT. da2) THEN
            al(i) = -(2.*ar(i))
          END IF
        ELSE
! effect of dm=0 included here
          al(i) = 0.
          ar(i) = 0.
        END IF
      END DO
    END IF
  END SUBROUTINE PERT_PPM
!  Differentiation of deln_flux in forward (tangent) mode:
!   variations   of useful results: fx fy
!   with respect to varying inputs: q fx fy
  SUBROUTINE DELN_FLUX_TLM(nord, npx, npy, damp, q, q_tl, fx, fx_tl, fy&
&   , fy_tl, mass)
    IMPLICIT NONE
! Del-n damping for the cell-mean values (A grid)
!------------------
! nord = 0:   del-2
! nord = 1:   del-4
! nord = 2:   del-6
! nord = 3:   del-8 --> requires more ghosting than current
!------------------
! del-n
    INTEGER, INTENT(IN) :: nord
    INTEGER, INTENT(IN) :: npx, npy
    REAL(fvprc), INTENT(IN) :: damp
! q ghosted on input
    REAL(fvprc), INTENT(IN) :: q(is-ng:ie+ng, js-ng:je+ng)
    REAL(fvprc), INTENT(IN) :: q_tl(is-ng:ie+ng, js-ng:je+ng)
! q ghosted on input
    REAL(fvprc), OPTIONAL, INTENT(IN) :: mass(isd:ied, jsd:jed)
! diffusive fluxes:
    REAL(fvprc), INTENT(INOUT) :: fx(is:ie+1, js:je), fy(is:ie, js:je+1)
    REAL(fvprc), INTENT(INOUT) :: fx_tl(is:ie+1, js:je), fy_tl(is:ie, js&
&   :je+1)
! local:
    REAL(fvprc) :: fx2(isd:ied+1, jsd:jed), fy2(isd:ied, jsd:jed+1)
    REAL(fvprc) :: fx2_tl(isd:ied+1, jsd:jed), fy2_tl(isd:ied, jsd:jed+1&
&   )
    REAL(fvprc) :: d2(isd:ied, jsd:jed)
    REAL(fvprc) :: d2_tl(isd:ied, jsd:jed)
    REAL(fvprc) :: damp2
    INTEGER :: i, j, n, nt, i1, i2, j1, j2
    INTRINSIC PRESENT
    i1 = is - 1 - nord
    i2 = ie + 1 + nord
    j1 = js - 1 - nord
    j2 = je + 1 + nord
    IF (.NOT.PRESENT(mass)) THEN
      d2_tl = 0.0_8
      DO j=j1,j2
        DO i=i1,i2
          d2_tl(i, j) = damp*q_tl(i, j)
          d2(i, j) = damp*q(i, j)
        END DO
      END DO
    ELSE
      d2_tl = 0.0_8
      DO j=j1,j2
        DO i=i1,i2
          d2_tl(i, j) = q_tl(i, j)
          d2(i, j) = q(i, j)
        END DO
      END DO
    END IF
    IF (nord .GT. 0) THEN
      CALL COPY_CORNERS_TLM(d2, d2_tl, npx, npy, 1)
      fx2_tl = 0.0_8
    ELSE
      fx2_tl = 0.0_8
    END IF
    DO j=js-nord,je+nord
      DO i=is-nord,ie+nord+1
        fx2_tl(i, j) = 0.5*(sin_sg(i-1, j, 3)+sin_sg(i, j, 1))*dy(i, j)*&
&         rdxc(i, j)*(d2_tl(i-1, j)-d2_tl(i, j))
        fx2(i, j) = 0.5*(sin_sg(i-1, j, 3)+sin_sg(i, j, 1))*dy(i, j)*(d2&
&         (i-1, j)-d2(i, j))*rdxc(i, j)
      END DO
    END DO
    IF (nord .GT. 0) THEN
      CALL COPY_CORNERS_TLM(d2, d2_tl, npx, npy, 2)
      fy2_tl = 0.0_8
    ELSE
      fy2_tl = 0.0_8
    END IF
    DO j=js-nord,je+nord+1
      DO i=is-nord,ie+nord
        fy2_tl(i, j) = 0.5*(sin_sg(i, j-1, 4)+sin_sg(i, j, 2))*dx(i, j)*&
&         rdyc(i, j)*(d2_tl(i, j-1)-d2_tl(i, j))
        fy2(i, j) = 0.5*(sin_sg(i, j-1, 4)+sin_sg(i, j, 2))*dx(i, j)*(d2&
&         (i, j-1)-d2(i, j))*rdyc(i, j)
      END DO
    END DO
    IF (nord .GT. 0) THEN
!----------
! high-order
!----------
      DO n=1,nord
        nt = nord - n
        DO j=js-nt-1,je+nt+1
          DO i=is-nt-1,ie+nt+1
            d2_tl(i, j) = rarea(i, j)*(fx2_tl(i, j)-fx2_tl(i+1, j)+&
&             fy2_tl(i, j)-fy2_tl(i, j+1))
            d2(i, j) = (fx2(i, j)-fx2(i+1, j)+fy2(i, j)-fy2(i, j+1))*&
&             rarea(i, j)
          END DO
        END DO
        CALL COPY_CORNERS_TLM(d2, d2_tl, npx, npy, 1)
        DO j=js-nt,je+nt
          DO i=is-nt,ie+nt+1
            fx2_tl(i, j) = 0.5*(sin_sg(i-1, j, 3)+sin_sg(i, j, 1))*dy(i&
&             , j)*rdxc(i, j)*(d2_tl(i, j)-d2_tl(i-1, j))
            fx2(i, j) = 0.5*(sin_sg(i-1, j, 3)+sin_sg(i, j, 1))*dy(i, j)&
&             *(d2(i, j)-d2(i-1, j))*rdxc(i, j)
          END DO
        END DO
        CALL COPY_CORNERS_TLM(d2, d2_tl, npx, npy, 2)
        DO j=js-nt,je+nt+1
          DO i=is-nt,ie+nt
            fy2_tl(i, j) = dx(i, j)*rdyc(i, j)*0.5*(sin_sg(i, j-1, 4)+&
&             sin_sg(i, j, 2))*(d2_tl(i, j)-d2_tl(i, j-1))
            fy2(i, j) = dx(i, j)*(d2(i, j)-d2(i, j-1))*rdyc(i, j)*0.5*(&
&             sin_sg(i, j-1, 4)+sin_sg(i, j, 2))
          END DO
        END DO
      END DO
    END IF
!---------------------------------------------
! Add the diffusive fluxes to the flux arrays:
!---------------------------------------------
    IF (PRESENT(mass)) THEN
! Apply mass weighting to diffusive fluxes:
      damp2 = 0.5*damp
      DO j=js,je
        DO i=is,ie+1
          fx_tl(i, j) = fx_tl(i, j) + damp2*(mass(i-1, j)+mass(i, j))*&
&           fx2_tl(i, j)
          fx(i, j) = fx(i, j) + damp2*(mass(i-1, j)+mass(i, j))*fx2(i, j&
&           )
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          fy_tl(i, j) = fy_tl(i, j) + damp2*(mass(i, j-1)+mass(i, j))*&
&           fy2_tl(i, j)
          fy(i, j) = fy(i, j) + damp2*(mass(i, j-1)+mass(i, j))*fy2(i, j&
&           )
        END DO
      END DO
    ELSE
      DO j=js,je
        DO i=is,ie+1
          fx_tl(i, j) = fx_tl(i, j) + fx2_tl(i, j)
          fx(i, j) = fx(i, j) + fx2(i, j)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          fy_tl(i, j) = fy_tl(i, j) + fy2_tl(i, j)
          fy(i, j) = fy(i, j) + fy2(i, j)
        END DO
      END DO
    END IF
  END SUBROUTINE DELN_FLUX_TLM
!  Differentiation of copy_corners_r8 in forward (tangent) mode:
!   variations   of useful results: q
!   with respect to varying inputs: q
  SUBROUTINE COPY_CORNERS_R8_TLM(q, q_tl, npx, npy, dir)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, dir
    REAL(real8), INTENT(INOUT) :: q(isd:ied, jsd:jed)
    REAL(real8), INTENT(INOUT) :: q_tl(isd:ied, jsd:jed)
    INTEGER :: i, j
    IF (dir .EQ. 1) THEN
! XDir:
      IF (sw_corner) THEN
        DO j=1-ng,0
          DO i=1-ng,0
            q_tl(i, j) = q_tl(j, 1-i)
            q(i, j) = q(j, 1-i)
          END DO
        END DO
      END IF
      IF (se_corner) THEN
        DO j=1-ng,0
          DO i=npx,npx+ng-1
            q_tl(i, j) = q_tl(npy-j, i-npx+1)
            q(i, j) = q(npy-j, i-npx+1)
          END DO
        END DO
      END IF
      IF (ne_corner) THEN
        DO j=npy,npy+ng-1
          DO i=npx,npx+ng-1
            q_tl(i, j) = q_tl(j, 2*npx-1-i)
            q(i, j) = q(j, 2*npx-1-i)
          END DO
        END DO
      END IF
      IF (nw_corner) THEN
        DO j=npy,npy+ng-1
          DO i=1-ng,0
            q_tl(i, j) = q_tl(npy-j, i-1+npx)
            q(i, j) = q(npy-j, i-1+npx)
          END DO
        END DO
      END IF
    ELSE IF (dir .EQ. 2) THEN
! YDir:
      IF (sw_corner) THEN
        DO j=1-ng,0
          DO i=1-ng,0
            q_tl(i, j) = q_tl(1-j, i)
            q(i, j) = q(1-j, i)
          END DO
        END DO
      END IF
      IF (se_corner) THEN
        DO j=1-ng,0
          DO i=npx,npx+ng-1
            q_tl(i, j) = q_tl(npy+j-1, npx-i)
            q(i, j) = q(npy+j-1, npx-i)
          END DO
        END DO
      END IF
      IF (ne_corner) THEN
        DO j=npy,npy+ng-1
          DO i=npx,npx+ng-1
            q_tl(i, j) = q_tl(2*npy-1-j, i)
            q(i, j) = q(2*npy-1-j, i)
          END DO
        END DO
      END IF
      IF (nw_corner) THEN
        DO j=npy,npy+ng-1
          DO i=1-ng,0
            q_tl(i, j) = q_tl(j+1-npx, npy-i)
            q(i, j) = q(j+1-npx, npy-i)
          END DO
        END DO
      END IF
    END IF
  END SUBROUTINE COPY_CORNERS_R8_TLM
  SUBROUTINE DELN_FLUX(nord, npx, npy, damp, q, fx, fy, mass)
    IMPLICIT NONE
! Del-n damping for the cell-mean values (A grid)
!------------------
! nord = 0:   del-2
! nord = 1:   del-4
! nord = 2:   del-6
! nord = 3:   del-8 --> requires more ghosting than current
!------------------
! del-n
    INTEGER, INTENT(IN) :: nord
    INTEGER, INTENT(IN) :: npx, npy
    REAL(fvprc), INTENT(IN) :: damp
! q ghosted on input
    REAL(fvprc), INTENT(IN) :: q(is-ng:ie+ng, js-ng:je+ng)
! q ghosted on input
    REAL(fvprc), OPTIONAL, INTENT(IN) :: mass(isd:ied, jsd:jed)
! diffusive fluxes:
    REAL(fvprc), INTENT(INOUT) :: fx(is:ie+1, js:je), fy(is:ie, js:je+1)
! local:
    REAL(fvprc) :: fx2(isd:ied+1, jsd:jed), fy2(isd:ied, jsd:jed+1)
    REAL(fvprc) :: d2(isd:ied, jsd:jed)
    REAL(fvprc) :: damp2
    INTEGER :: i, j, n, nt, i1, i2, j1, j2
    INTRINSIC PRESENT
    i1 = is - 1 - nord
    i2 = ie + 1 + nord
    j1 = js - 1 - nord
    j2 = je + 1 + nord
    IF (.NOT.PRESENT(mass)) THEN
      DO j=j1,j2
        DO i=i1,i2
          d2(i, j) = damp*q(i, j)
        END DO
      END DO
    ELSE
      DO j=j1,j2
        DO i=i1,i2
          d2(i, j) = q(i, j)
        END DO
      END DO
    END IF
    IF (nord .GT. 0) CALL COPY_CORNERS(d2, npx, npy, 1)
    DO j=js-nord,je+nord
      DO i=is-nord,ie+nord+1
        fx2(i, j) = 0.5*(sin_sg(i-1, j, 3)+sin_sg(i, j, 1))*dy(i, j)*(d2&
&         (i-1, j)-d2(i, j))*rdxc(i, j)
      END DO
    END DO
    IF (nord .GT. 0) CALL COPY_CORNERS(d2, npx, npy, 2)
    DO j=js-nord,je+nord+1
      DO i=is-nord,ie+nord
        fy2(i, j) = 0.5*(sin_sg(i, j-1, 4)+sin_sg(i, j, 2))*dx(i, j)*(d2&
&         (i, j-1)-d2(i, j))*rdyc(i, j)
      END DO
    END DO
    IF (nord .GT. 0) THEN
!----------
! high-order
!----------
      DO n=1,nord
        nt = nord - n
        DO j=js-nt-1,je+nt+1
          DO i=is-nt-1,ie+nt+1
            d2(i, j) = (fx2(i, j)-fx2(i+1, j)+fy2(i, j)-fy2(i, j+1))*&
&             rarea(i, j)
          END DO
        END DO
        CALL COPY_CORNERS(d2, npx, npy, 1)
        DO j=js-nt,je+nt
          DO i=is-nt,ie+nt+1
            fx2(i, j) = 0.5*(sin_sg(i-1, j, 3)+sin_sg(i, j, 1))*dy(i, j)&
&             *(d2(i, j)-d2(i-1, j))*rdxc(i, j)
          END DO
        END DO
        CALL COPY_CORNERS(d2, npx, npy, 2)
        DO j=js-nt,je+nt+1
          DO i=is-nt,ie+nt
            fy2(i, j) = dx(i, j)*(d2(i, j)-d2(i, j-1))*rdyc(i, j)*0.5*(&
&             sin_sg(i, j-1, 4)+sin_sg(i, j, 2))
          END DO
        END DO
      END DO
    END IF
!---------------------------------------------
! Add the diffusive fluxes to the flux arrays:
!---------------------------------------------
    IF (PRESENT(mass)) THEN
! Apply mass weighting to diffusive fluxes:
      damp2 = 0.5*damp
      DO j=js,je
        DO i=is,ie+1
          fx(i, j) = fx(i, j) + damp2*(mass(i-1, j)+mass(i, j))*fx2(i, j&
&           )
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          fy(i, j) = fy(i, j) + damp2*(mass(i, j-1)+mass(i, j))*fy2(i, j&
&           )
        END DO
      END DO
    ELSE
      DO j=js,je
        DO i=is,ie+1
          fx(i, j) = fx(i, j) + fx2(i, j)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          fy(i, j) = fy(i, j) + fy2(i, j)
        END DO
      END DO
    END IF
  END SUBROUTINE DELN_FLUX
  SUBROUTINE COPY_CORNERS_R8(q, npx, npy, dir)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, dir
    REAL(real8), INTENT(INOUT) :: q(isd:ied, jsd:jed)
    INTEGER :: i, j
    IF (dir .EQ. 1) THEN
! XDir:
      IF (sw_corner) THEN
        DO j=1-ng,0
          DO i=1-ng,0
            q(i, j) = q(j, 1-i)
          END DO
        END DO
      END IF
      IF (se_corner) THEN
        DO j=1-ng,0
          DO i=npx,npx+ng-1
            q(i, j) = q(npy-j, i-npx+1)
          END DO
        END DO
      END IF
      IF (ne_corner) THEN
        DO j=npy,npy+ng-1
          DO i=npx,npx+ng-1
            q(i, j) = q(j, 2*npx-1-i)
          END DO
        END DO
      END IF
      IF (nw_corner) THEN
        DO j=npy,npy+ng-1
          DO i=1-ng,0
            q(i, j) = q(npy-j, i-1+npx)
          END DO
        END DO
      END IF
    ELSE IF (dir .EQ. 2) THEN
! YDir:
      IF (sw_corner) THEN
        DO j=1-ng,0
          DO i=1-ng,0
            q(i, j) = q(1-j, i)
          END DO
        END DO
      END IF
      IF (se_corner) THEN
        DO j=1-ng,0
          DO i=npx,npx+ng-1
            q(i, j) = q(npy+j-1, npx-i)
          END DO
        END DO
      END IF
      IF (ne_corner) THEN
        DO j=npy,npy+ng-1
          DO i=npx,npx+ng-1
            q(i, j) = q(2*npy-1-j, i)
          END DO
        END DO
      END IF
      IF (nw_corner) THEN
        DO j=npy,npy+ng-1
          DO i=1-ng,0
            q(i, j) = q(j+1-npx, npy-i)
          END DO
        END DO
      END IF
    END IF
  END SUBROUTINE COPY_CORNERS_R8
END MODULE TP_CORE_MOD_D
