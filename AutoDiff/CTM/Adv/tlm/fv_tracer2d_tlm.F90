!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
MODULE FV_TRACER2D_MOD_D
  USE FV_ARRAYS_MOD, ONLY : fvprc, real4, real8
  USE TP_CORE_MOD_D, ONLY : fv_tp_2d, fv_tp_2d_tlm
  USE FV_GRID_TOOLS_MOD_D, ONLY : area, rarea, dxa, dya, dx, dy
  USE FV_GRID_UTILS_MOD_D, ONLY : sina_u, sina_v, sin_sg
  USE FV_MP_MOD_D, ONLY : gid, domain, mp_reduce_max, ng, isd, ied, jsd,&
& jed, is, js, ie, je
  USE MPP_DOMAINS_MOD_D, ONLY : mpp_update_domains, &
& mpp_update_domains_tlm, cgrid_ne, mpp_get_boundary
  USE FV_TIMING_MOD, ONLY : timing_on, timing_off
  IMPLICIT NONE
  PRIVATE 
  PUBLIC tracer_2d, tracer_2d_1l, offline_tracer_advection
  PUBLIC tracer_2d_tlm, tracer_2d_1l_tlm, offline_tracer_advection_tlm

CONTAINS
!  Differentiation of offline_tracer_advection in forward (tangent) mode:
!   variations   of useful results: q
!   with respect to varying inputs: q
!   RW status of diff variables: q:in-out
  SUBROUTINE OFFLINE_TRACER_ADVECTION_TLM(q, q_tl, ple0, ple1, mfx, mfy&
&   , cx, cy, ak, bk, ptop, npx, npy, npz, nq, hord, kord, q_split, dt, &
&   z_tracer, fill)
    USE FV_MAPZ_MOD_D, ONLY : map1_q2, map1_q2_tlm
    USE FV_FILL_MOD_D, ONLY : fillz, fillz_tlm
    IMPLICIT NONE
!do k = 1,npz
!   do j = js,je
!      do i = is,ie
!         q(i,j,k,iq) = q1(i,j,k) * scalingFactors(k)
!      enddo
!   enddo
!enddo
! nq loop
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
! number of tracers to be advected
    INTEGER, INTENT(IN) :: nq
    INTEGER, INTENT(IN) :: hord
    INTEGER, INTENT(IN) :: kord
    INTEGER, INTENT(IN) :: q_split
    LOGICAL, INTENT(IN) :: z_tracer
    LOGICAL, INTENT(IN) :: fill
    REAL(fvprc), INTENT(IN) :: dt
! DELP before dyn_core
    REAL(fvprc), INTENT(IN) :: ple0(is:ie, js:je, npz+1)
! DELP after dyn_core
    REAL(fvprc), INTENT(INOUT) :: ple1(is:ie, js:je, npz+1)
! Courant Number X-Dir
    REAL(fvprc), INTENT(IN) :: cx(is:ie, js:je, npz)
! Courant Number Y-Dir
    REAL(fvprc), INTENT(IN) :: cy(is:ie, js:je, npz)
! Mass Flux X-Dir
    REAL(fvprc), INTENT(IN) :: mfx(is:ie, js:je, npz)
! Mass Flux Y-Dir
    REAL(fvprc), INTENT(IN) :: mfy(is:ie, js:je, npz)
! Tracers
    REAL(fvprc), INTENT(INOUT) :: q(is:ie, js:je, npz, nq)
    REAL(fvprc), INTENT(INOUT) :: q_tl(is:ie, js:je, npz, nq)
! AK for remapping
    REAL(real8), INTENT(IN) :: ak(npz+1)
! BK for remapping
    REAL(real8), INTENT(IN) :: bk(npz+1)
    REAL(real8), INTENT(IN) :: ptop
! Local Arrays
! X-Dir for MPP Updates
    REAL(real8) :: xl(isd:ied+1, jsd:jed, npz)
! Y-Dir for MPP Updates
    REAL(real8) :: yl(isd:ied, jsd:jed+1, npz)
! Courant Number X-Dir
    REAL(fvprc) :: cxl(is:ie+1, jsd:jed, npz)
! Courant Number Y-Dir
    REAL(fvprc) :: cyl(isd:ied, js:je+1, npz)
! Mass Flux X-Dir
    REAL(fvprc) :: mfxl(is:ie+1, js:je, npz)
! Mass Flux Y-Dir
    REAL(fvprc) :: mfyl(is:ie, js:je+1, npz)
! Pressure Thickness
    REAL(real8) :: dpl(is:ie, js:je, npz)
! Pressure Thickness
    REAL(real8) :: dpa(is:ie, js:je, npz)
! Local Tracer Arrays
! 2D Tracers
    REAL(real8) :: q1(is:ie, js:je, npz)
    REAL(real8) :: q1_tl(is:ie, js:je, npz)
! 2D Tracers
    REAL(real8) :: q2(isd:ied, jsd:jed, nq)
    REAL(real8) :: q2_tl(isd:ied, jsd:jed, nq)
! 3D Tracers
    REAL(real8) :: q3(isd:ied, jsd:jed, npz, nq)
    REAL(real8) :: q3_tl(isd:ied, jsd:jed, npz, nq)
! Local Buffer Arrarys
    REAL(real8) :: wbuffer(js:je, npz)
    REAL(real8) :: sbuffer(is:ie, npz)
    REAL(real8) :: ebuffer(js:je, npz)
    REAL(real8) :: nbuffer(is:ie, npz)
! Local Remap Arrays
    REAL(real8) :: pe1(is:ie, npz+1)
    REAL(real8) :: pe2(is:ie, npz+1)
    REAL(real8) :: dp2(is:ie, js:je, npz)
! Local indices
    INTEGER :: i, j, k, n, iq
    REAL(real8) :: dtr8
    REAL(real8) :: scalingfactor
    REAL(real8) :: scalingfactor_tl
!real(REAL8) :: scalingFactors(npz)
! Time-step
    dtr8 = dt
    wbuffer = 0.0
    sbuffer = 0.0
    ebuffer = 0.0
    nbuffer = 0.0
! Fill CX/CY C-Grid boundaries and update ghost regions
    xl(is:ie, js:je, :) = cx(:, :, :)
    yl(is:ie, js:je, :) = cy(:, :, :)
    CALL MPP_GET_BOUNDARY(xl, yl, domain, wbufferx=wbuffer, ebufferx=&
&                   ebuffer, sbuffery=sbuffer, nbuffery=nbuffer, &
&                   gridtype=cgrid_ne)
    xl(ie+1, js:je, :) = ebuffer
    yl(is:ie, je+1, :) = nbuffer
    CALL MPP_UPDATE_DOMAINS(xl, yl, domain, gridtype=cgrid_ne, complete=&
&                     .true.)
    cxl(is:ie+1, jsd:jed, :) = xl(is:ie+1, jsd:jed, :)
    cyl(isd:ied, js:je+1, :) = yl(isd:ied, js:je+1, :)
! Fill MFX/MFY C-Grid boundaries
    xl(is:ie, js:je, :) = mfx(:, :, :)
    yl(is:ie, js:je, :) = mfy(:, :, :)
    CALL MPP_GET_BOUNDARY(xl, yl, domain, wbufferx=wbuffer, ebufferx=&
&                   ebuffer, sbuffery=sbuffer, nbuffery=nbuffer, &
&                   gridtype=cgrid_ne)
    xl(ie+1, js:je, :) = ebuffer
    yl(is:ie, je+1, :) = nbuffer
    mfxl(is:ie+1, js:je, :) = xl(is:ie+1, js:je, :)
    mfyl(is:ie, js:je+1, :) = yl(is:ie, js:je+1, :)
! Fill local tracers and pressure thickness
    dpl(:, :, :) = ple0(:, :, 2:npz+1) - ple0(:, :, 1:npz)
    q3_tl = 0.0_8
    q3_tl(is:ie, js:je, :, :) = q_tl(is:ie, js:je, :, :)
    q3(is:ie, js:je, :, :) = q(is:ie, js:je, :, :)
    IF (z_tracer) THEN
      q2_tl = 0.0_8
!$omp parallel do default(shared) private(q2)
      DO k=1,npz
        DO iq=1,nq
          DO j=js,je
! To_do list:
            DO i=is,ie
! The data copying can be avoided if q is
              q2_tl(i, j, iq) = q3_tl(i, j, k, iq)
              q2(i, j, iq) = q3(i, j, k, iq)
            END DO
          END DO
        END DO
! re-dimensioned as q(i,j,nq,k)
        CALL TRACER_2D_1L_TLM(q2, q2_tl, dpl(is, js, k), mfxl(is, js, k)&
&                       , mfyl(is, js, k), cxl(is, jsd, k), cyl(isd, js&
&                       , k), npx, npy, npz, 1, nq, hord, q_split, k, q3&
&                       , q3_tl, dtr8, 0, dpa=dpa)
      END DO
      q1_tl = 0.0_8
    ELSE
      CALL TRACER_2D_TLM(q3, q3_tl, dpl, mfxl, mfyl, cxl, cyl, npx, npy&
&                  , npz, 1, nq, hord, q_split, dtr8, 0, dpa=dpa)
      q1_tl = 0.0_8
    END IF
!------------------------------------------------------------------
! Re-Map constituents
! Do remapping one tracer at a time; seems to be faster
! It requires less memory than mapn_ppm
!------------------------------------------------------------------
    DO iq=1,nq
      DO j=js,je
! pressures mapping from (dpA is new delp after tracer_2d)
        pe1(:, 1) = ptop
        DO k=2,npz+1
          pe1(:, k) = pe1(:, k-1) + dpa(:, j, k-1)
        END DO
! pressures mapping to
        pe2(:, 1) = ptop
        pe2(:, npz+1) = pe1(:, npz+1)
        DO k=2,npz
          pe2(:, k) = ak(k) + bk(k)*pe1(:, npz+1)
        END DO
        DO k=1,npz
          dp2(:, j, k) = pe2(:, k+1) - pe2(:, k)
        END DO
        CALL MAP1_Q2_TLM(npz, pe1, q3(isd, jsd, 1, iq), q3_tl(isd, jsd, &
&                  1, iq), npz, pe2, q1(:, j, :), q1_tl(:, j, :), dp2(:&
&                  , j, :), is, ie, 0, kord, j, isd, ied, jsd, jed)
!, .true.)
        IF (fill) CALL FILLZ_TLM(ie - is + 1, npz, 1, q1(:, j, :), q1_tl&
&                          (:, j, :), dp2(:, j, :))
      END DO
! Rescale tracers based on ple1 at destination timestep
!------------------------------------------------------
      scalingfactor_tl = CALCSCALINGFACTOR_TLM(q1, q1_tl, dp2, ple1, npx&
&       , npy, npz, is, ie, js, je, scalingfactor)
!scalingFactors = computeScalingFactors(q1, dp2, ple1, npx, npy, npz, is, ie, js, je)
! Return tracers
!---------------
      q_tl(is:ie, js:je, 1:npz, iq) = q1_tl(is:ie, js:je, 1:npz)*&
&       scalingfactor + q1(is:ie, js:je, 1:npz)*scalingfactor_tl
      q(is:ie, js:je, 1:npz, iq) = q1(is:ie, js:je, 1:npz)*scalingfactor
    END DO
  END SUBROUTINE OFFLINE_TRACER_ADVECTION_TLM
!  Differentiation of tracer_2d_1l in forward (tangent) mode:
!   variations   of useful results: q q3
!   with respect to varying inputs: q q3
!-----------------------------------------------------------------------
! !ROUTINE: Perform 2D horizontal-to-lagrangian transport
!-----------------------------------------------------------------------
  SUBROUTINE TRACER_2D_1L_TLM(q, q_tl, dp0, mfx, mfy, cx, cy, npx, npy, &
&   npz, qs, nq, hord, q_split, k, q3, q3_tl, dt, id_divg, dpa)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, npz
    INTEGER, INTENT(IN) :: k
! first tracer to advect
    INTEGER, INTENT(IN) :: qs
! number of tracers to be advected
    INTEGER, INTENT(IN) :: nq
    INTEGER, INTENT(IN) :: hord
    INTEGER, INTENT(IN) :: q_split
    INTEGER, INTENT(IN) :: id_divg
    REAL(real8), INTENT(IN) :: dt
! 2D Tracers
    REAL(real8), INTENT(INOUT) :: q(isd:ied, jsd:jed, nq)
    REAL(real8), INTENT(INOUT) :: q_tl(isd:ied, jsd:jed, nq)
! Tracers
    REAL(real8), INTENT(INOUT) :: q3(isd:ied, jsd:jed, npz, nq)
    REAL(real8), INTENT(INOUT) :: q3_tl(isd:ied, jsd:jed, npz, nq)
! DELP before dyn_core
    REAL(real8), INTENT(INOUT) :: dp0(is:ie, js:je)
! DELP after advection
    REAL(real8), OPTIONAL, INTENT(OUT) :: dpa(is:ie, js:je)
! Courant Number X-Dir
    REAL(fvprc), INTENT(IN) :: cx(is:ie+1, jsd:jed)
! Courant Number Y-Dir
    REAL(fvprc), INTENT(IN) :: cy(isd:ied, js:je+1)
! Mass Flux X-Dir
    REAL(fvprc), INTENT(IN) :: mfx(is:ie+1, js:je)
! Mass Flux Y-Dir
    REAL(fvprc), INTENT(IN) :: mfy(is:ie, js:je+1)
! Local Arrays
    REAL(fvprc) :: fx(is:ie+1, js:je)
    REAL(fvprc) :: fx_tl(is:ie+1, js:je)
    REAL(fvprc) :: fy(is:ie, js:je+1)
    REAL(fvprc) :: fy_tl(is:ie, js:je+1)
    REAL(fvprc) :: mfx2(is:ie+1, js:je)
    REAL(fvprc) :: mfy2(is:ie, js:je+1)
    REAL(fvprc) :: cx2(is:ie+1, jsd:jed)
    REAL(fvprc) :: cy2(isd:ied, js:je+1)
    REAL(real8) :: dp1(is:ie, js:je)
    REAL(real8) :: dp2(is:ie, js:je)
    REAL(fvprc) :: ra_x(is:ie, jsd:jed)
    REAL(fvprc) :: ra_y(isd:ied, js:je)
    REAL(fvprc) :: xfx(is:ie+1, jsd:jed)
    REAL(fvprc) :: yfx(isd:ied, js:je+1)
    REAL(fvprc) :: cmax
    REAL(fvprc) :: frac, rdt
    INTEGER :: nsplt
    INTEGER :: i, j, it, iq
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC INT
    INTRINSIC REAL
    INTRINSIC PRESENT
    REAL*8 :: abs0
    REAL*8 :: abs1
    REAL*8 :: x1
    REAL*8 :: y1
    DO j=jsd,jed
      DO i=is,ie+1
        IF (cx(i, j) .GT. 0.) THEN
          xfx(i, j) = cx(i, j)*dxa(i-1, j)*dy(i, j)*sin_sg(i-1, j, 3)
        ELSE
          xfx(i, j) = cx(i, j)*dxa(i, j)*dy(i, j)*sin_sg(i, j, 1)
        END IF
      END DO
    END DO
    DO j=js,je+1
      DO i=isd,ied
        IF (cy(i, j) .GT. 0.) THEN
          yfx(i, j) = cy(i, j)*dya(i, j-1)*dx(i, j)*sin_sg(i, j-1, 4)
        ELSE
          yfx(i, j) = cy(i, j)*dya(i, j)*dx(i, j)*sin_sg(i, j, 2)
        END IF
      END DO
    END DO
    IF (q_split .EQ. 0) THEN
! Determine nsplt for tracer advection
      cmax = 0.
      DO j=js,je
        DO i=is,ie
          IF (cx(i, j) .GE. 0.) THEN
            abs0 = cx(i, j)
          ELSE
            abs0 = -cx(i, j)
          END IF
          x1 = abs0 + (1.-sina_u(i, j))
          IF (cy(i, j) .GE. 0.) THEN
            abs1 = cy(i, j)
          ELSE
            abs1 = -cy(i, j)
          END IF
          y1 = abs1 + (1.-sina_v(i, j))
          IF (x1 .LT. y1) THEN
            IF (y1 .LT. cmax) THEN
              cmax = cmax
            ELSE
              cmax = y1
            END IF
          ELSE IF (x1 .LT. cmax) THEN
            cmax = cmax
          ELSE
            cmax = x1
          END IF
        END DO
      END DO
      CALL MP_REDUCE_MAX(cmax)
      nsplt = INT(1.01 + cmax)
      IF (gid .EQ. 0 .AND. nsplt .GT. 5) WRITE(6, *) k, &
&                                        'Tracer_2d_split=', nsplt, cmax
    ELSE
      nsplt = q_split
    END IF
    frac = 1./REAL(nsplt)
    DO j=jsd,jed
      DO i=is,ie+1
        cx2(i, j) = cx(i, j)*frac
        xfx(i, j) = xfx(i, j)*frac
      END DO
    END DO
    DO j=js,je
      DO i=is,ie+1
        mfx2(i, j) = mfx(i, j)*frac
      END DO
    END DO
    DO j=js,je+1
      DO i=isd,ied
        cy2(i, j) = cy(i, j)*frac
        yfx(i, j) = yfx(i, j)*frac
      END DO
    END DO
    DO j=js,je+1
      DO i=is,ie
        mfy2(i, j) = mfy(i, j)*frac
      END DO
    END DO
    DO j=jsd,jed
      DO i=is,ie
        ra_x(i, j) = area(i, j) + xfx(i, j) - xfx(i+1, j)
      END DO
    END DO
    DO j=js,je
      DO i=isd,ied
        ra_y(i, j) = area(i, j) + yfx(i, j) - yfx(i, j+1)
      END DO
    END DO
    DO j=js,je
      DO i=is,ie
        dp1(i, j) = dp0(i, j)
      END DO
    END DO
    fx_tl = 0.0_8
    fy_tl = 0.0_8
    DO it=1,nsplt
      DO j=js,je
        DO i=is,ie
          dp2(i, j) = dp1(i, j) + (mfx2(i, j)-mfx2(i+1, j)+mfy2(i, j)-&
&           mfy2(i, j+1))*rarea(i, j)
        END DO
      END DO
      CALL TIMING_ON('COMM_TOTAL')
      CALL TIMING_ON('COMM_TRAC')
      CALL MPP_UPDATE_DOMAINS_TLM(q, q_tl, domain, complete=.true.)
      CALL TIMING_OFF('COMM_TRAC')
      CALL TIMING_OFF('COMM_TOTAL')
      CALL TIMING_ON('fv_tp_2d')
      DO iq=qs,nq
        CALL FV_TP_2D_TLM(q(isd:, jsd:, iq), q_tl(isd:, jsd:, iq), cx2, &
&                   cy2, npx, npy, hord, fx, fx_tl, fy, fy_tl, xfx, yfx&
&                   , ra_x, ra_y, mfx=mfx2, mfy=mfy2)
        IF (it .EQ. nsplt) THEN
          DO j=js,je
            DO i=is,ie
              q3_tl(i, j, k, iq) = (dp1(i, j)*q_tl(i, j, iq)+rarea(i, j)&
&               *(fx_tl(i, j)-fx_tl(i+1, j)+fy_tl(i, j)-fy_tl(i, j+1)))/&
&               dp2(i, j)
              q3(i, j, k, iq) = (q(i, j, iq)*dp1(i, j)+(fx(i, j)-fx(i+1&
&               , j)+fy(i, j)-fy(i, j+1))*rarea(i, j))/dp2(i, j)
            END DO
          END DO
        ELSE
          DO j=js,je
            DO i=is,ie
              q_tl(i, j, iq) = (dp1(i, j)*q_tl(i, j, iq)+rarea(i, j)*(&
&               fx_tl(i, j)-fx_tl(i+1, j)+fy_tl(i, j)-fy_tl(i, j+1)))/&
&               dp2(i, j)
              q(i, j, iq) = (q(i, j, iq)*dp1(i, j)+(fx(i, j)-fx(i+1, j)+&
&               fy(i, j)-fy(i, j+1))*rarea(i, j))/dp2(i, j)
            END DO
          END DO
        END IF
      END DO
      CALL TIMING_OFF('fv_tp_2d')
      IF (it .NE. nsplt) THEN
        DO j=js,je
          DO i=is,ie
            dp1(i, j) = dp2(i, j)
          END DO
        END DO
      END IF
    END DO
! nsplt
    IF (id_divg .GT. 0) THEN
      rdt = 1./(frac*dt)
      DO j=js,je
        DO i=is,ie
          dp0(i, j) = (xfx(i+1, j)-xfx(i, j)+yfx(i, j+1)-yfx(i, j))*&
&           rarea(i, j)*rdt
        END DO
      END DO
    END IF
    IF (PRESENT(dpa)) dpa = dp2
  END SUBROUTINE TRACER_2D_1L_TLM
!  Differentiation of tracer_2d in forward (tangent) mode:
!   variations   of useful results: q
!   with respect to varying inputs: q
  SUBROUTINE TRACER_2D_TLM(q, q_tl, dp1, mfx, mfy, cx, cy, npx, npy, npz&
&   , qs, nq, hord, q_split, dt, id_divg, dpa)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
! first tracer to advect
    INTEGER, INTENT(IN) :: qs
! number of tracers to be advected
    INTEGER, INTENT(IN) :: nq
    INTEGER, INTENT(IN) :: hord
    INTEGER, INTENT(IN) :: q_split
    INTEGER, INTENT(IN) :: id_divg
    REAL(real8), INTENT(IN) :: dt
! Tracers
    REAL(real8), INTENT(INOUT) :: q(isd:ied, jsd:jed, npz, nq)
    REAL(real8), INTENT(INOUT) :: q_tl(isd:ied, jsd:jed, npz, nq)
! DELP before dyn_core
    REAL(real8), INTENT(INOUT) :: dp1(is:ie, js:je, npz)
! DELP after advection
    REAL(real8), OPTIONAL, INTENT(OUT) :: dpa(is:ie, js:je, npz)
! Courant Number X-Dir
    REAL(fvprc), INTENT(INOUT) :: cx(is:ie+1, jsd:jed, npz)
! Courant Number Y-Dir
    REAL(fvprc), INTENT(INOUT) :: cy(isd:ied, js:je+1, npz)
! Mass Flux X-Dir
    REAL(fvprc), INTENT(INOUT) :: mfx(is:ie+1, js:je, npz)
! Mass Flux Y-Dir
    REAL(fvprc), INTENT(INOUT) :: mfy(is:ie, js:je+1, npz)
! Local Arrays
    REAL(fvprc) :: fx(is:ie+1, js:je)
    REAL(fvprc) :: fx_tl(is:ie+1, js:je)
    REAL(fvprc) :: fy(is:ie, js:je+1)
    REAL(fvprc) :: fy_tl(is:ie, js:je+1)
    REAL(real8) :: dp2(is:ie, js:je)
    REAL(fvprc) :: ra_x(is:ie, jsd:jed)
    REAL(fvprc) :: ra_y(isd:ied, js:je)
    REAL(fvprc) :: xfx(is:ie+1, jsd:jed, npz)
    REAL(fvprc) :: yfx(isd:ied, js:je+1, npz)
    REAL(fvprc) :: cmax(npz)
!#ifdef IBM_FIX
!      real(FVPRC) :: cmax_x, cmax_y
!#endif
    REAL(fvprc) :: c_global
    REAL(fvprc) :: frac, rdt
    INTEGER :: nsplt
    INTEGER :: i, j, k, it, iq
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC INT
    INTRINSIC REAL
    INTRINSIC PRESENT
    REAL*8 :: abs0
    REAL*8 :: abs1
    REAL*8 :: x1
    REAL*8 :: y1
!$omp parallel do default(shared)
    DO k=1,npz
      DO j=jsd,jed
        DO i=is,ie+1
          IF (cx(i, j, k) .GT. 0.) THEN
            xfx(i, j, k) = cx(i, j, k)*dxa(i-1, j)*dy(i, j)*sin_sg(i-1, &
&             j, 3)
          ELSE
            xfx(i, j, k) = cx(i, j, k)*dxa(i, j)*dy(i, j)*sin_sg(i, j, 1&
&             )
          END IF
        END DO
      END DO
      DO j=js,je+1
        DO i=isd,ied
          IF (cy(i, j, k) .GT. 0.) THEN
            yfx(i, j, k) = cy(i, j, k)*dya(i, j-1)*dx(i, j)*sin_sg(i, j-&
&             1, 4)
          ELSE
            yfx(i, j, k) = cy(i, j, k)*dya(i, j)*dx(i, j)*sin_sg(i, j, 2&
&             )
          END IF
        END DO
      END DO
    END DO
!--------------------------------------------------------------------------------
    IF (q_split .EQ. 0) THEN
! Determine nsplt
!#ifdef IBM_FIX
!!$omp parallel do default(shared) private(cmax_x, cmax_y)
!      do k=1,npz
!        cmax(k) = 0.
!        do j=js,je
!          do i=is,ie
!            cmax_x  = max(abs(cx(i,j,k))+1.-sina_u(i,j), cmax(k))
!            cmax_y  = max(abs(cy(i,j,k))+1.-sina_v(i,j), cmax(k))
!            cmax(k) = max(cmax_x, cmax_y)
!          enddo
!        enddo
!      enddo
!#else 
!$omp parallel do default(shared) 
      DO k=1,npz
        cmax(k) = 0.
        DO j=js,je
          DO i=is,ie
            IF (cx(i, j, k) .GE. 0.) THEN
              abs0 = cx(i, j, k)
            ELSE
              abs0 = -cx(i, j, k)
            END IF
            x1 = abs0 + 1. - sina_u(i, j)
            IF (cy(i, j, k) .GE. 0.) THEN
              abs1 = cy(i, j, k)
            ELSE
              abs1 = -cy(i, j, k)
            END IF
            y1 = abs1 + 1. - sina_v(i, j)
            IF (x1 .LT. y1) THEN
              IF (y1 .LT. cmax(k)) THEN
                cmax(k) = cmax(k)
              ELSE
                cmax(k) = y1
              END IF
            ELSE IF (x1 .LT. cmax(k)) THEN
              cmax(k) = cmax(k)
            ELSE
              cmax(k) = x1
            END IF
          END DO
        END DO
      END DO
      CALL MP_REDUCE_MAX(cmax, npz)
!#endif
! find global max courant number and define nsplt to scale cx,cy,mfx,mfy
      c_global = cmax(1)
      IF (npz .NE. 1) THEN
! if NOT shallow water test case
        DO k=2,npz
          IF (cmax(k) .LT. c_global) THEN
            c_global = c_global
          ELSE
            c_global = cmax(k)
          END IF
        END DO
      END IF
      nsplt = INT(1. + c_global)
      IF (gid .EQ. 0 .AND. nsplt .GT. 5) WRITE(6, *) 'Tracer_2d_split='&
&                                        , nsplt, c_global
    ELSE
      nsplt = q_split
    END IF
!--------------------------------------------------------------------------------
    frac = 1./REAL(nsplt)
    IF (nsplt .NE. 1) THEN
!$omp parallel do default(shared)
      DO k=1,npz
        DO j=jsd,jed
          DO i=is,ie+1
            cx(i, j, k) = cx(i, j, k)*frac
            xfx(i, j, k) = xfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je
          DO i=is,ie+1
            mfx(i, j, k) = mfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je+1
          DO i=isd,ied
            cy(i, j, k) = cy(i, j, k)*frac
            yfx(i, j, k) = yfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je+1
          DO i=is,ie
            mfy(i, j, k) = mfy(i, j, k)*frac
          END DO
        END DO
      END DO
      fx_tl = 0.0_8
      fy_tl = 0.0_8
    ELSE
      fx_tl = 0.0_8
      fy_tl = 0.0_8
    END IF
    DO it=1,nsplt
      CALL TIMING_ON('COMM_TOTAL')
      CALL TIMING_ON('COMM_TRAC')
      CALL MPP_UPDATE_DOMAINS_TLM(q, q_tl, domain, complete=.true.)
      CALL TIMING_OFF('COMM_TRAC')
      CALL TIMING_OFF('COMM_TOTAL')
!$omp parallel do default(shared) private(ra_x, ra_y, dp2, fx, fy)
      DO k=1,npz
        DO j=jsd,jed
          DO i=is,ie
            ra_x(i, j) = area(i, j) + xfx(i, j, k) - xfx(i+1, j, k)
          END DO
        END DO
        DO j=js,je
          DO i=isd,ied
            ra_y(i, j) = area(i, j) + yfx(i, j, k) - yfx(i, j+1, k)
          END DO
        END DO
        DO j=js,je
          DO i=is,ie
            dp2(i, j) = dp1(i, j, k) + (mfx(i, j, k)-mfx(i+1, j, k)+mfy(&
&             i, j, k)-mfy(i, j+1, k))*rarea(i, j)
          END DO
        END DO
        CALL TIMING_ON('fv_tp_2d')
        DO iq=qs,nq
          CALL FV_TP_2D_TLM(q(isd:, jsd:, k, iq), q_tl(isd:, jsd:, k, iq&
&                     ), cx(is:, jsd:, k), cy(isd:, js:, k), npx, npy, &
&                     hord, fx, fx_tl, fy, fy_tl, xfx(is:, jsd:, k), yfx&
&                     (isd:, js:, k), ra_x, ra_y, mfx=mfx(is:, js:, k), &
&                     mfy=mfy(is:, js:, k))
          DO j=js,je
            DO i=is,ie
              q_tl(i, j, k, iq) = (dp1(i, j, k)*q_tl(i, j, k, iq)+rarea(&
&               i, j)*(fx_tl(i, j)-fx_tl(i+1, j)+fy_tl(i, j)-fy_tl(i, j+&
&               1)))/dp2(i, j)
              q(i, j, k, iq) = (q(i, j, k, iq)*dp1(i, j, k)+(fx(i, j)-fx&
&               (i+1, j)+fy(i, j)-fy(i, j+1))*rarea(i, j))/dp2(i, j)
            END DO
          END DO
        END DO
        CALL TIMING_OFF('fv_tp_2d')
        DO j=js,je
          DO i=is,ie
            dp1(i, j, k) = dp2(i, j)
          END DO
        END DO
      END DO
    END DO
! npz
! nsplt
! rescale mass fluxes back to original
    mfx = mfx/frac
    mfy = mfy/frac
    cx = cx/frac
    cy = cy/frac
    IF (PRESENT(dpa)) dpa = dp1
    IF (id_divg .GT. 0) THEN
      rdt = 1./(frac*dt)
!$omp parallel do default(shared)
      DO k=1,npz
        DO j=js,je
          DO i=is,ie
            dp1(i, j, k) = (xfx(i+1, j, k)-xfx(i, j, k)+yfx(i, j+1, k)-&
&             yfx(i, j, k))*rarea(i, j)*rdt
          END DO
        END DO
      END DO
    END IF
  END SUBROUTINE TRACER_2D_TLM
  SUBROUTINE OFFLINE_TRACER_ADVECTION(q, ple0, ple1, mfx, mfy, cx, cy, &
&   ak, bk, ptop, npx, npy, npz, nq, hord, kord, q_split, dt, z_tracer, &
&   fill)
    USE FV_MAPZ_MOD_D, ONLY : map1_q2
    USE FV_FILL_MOD_D, ONLY : fillz
    IMPLICIT NONE
!do k = 1,npz
!   do j = js,je
!      do i = is,ie
!         q(i,j,k,iq) = q1(i,j,k) * scalingFactors(k)
!      enddo
!   enddo
!enddo
! nq loop
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
! number of tracers to be advected
    INTEGER, INTENT(IN) :: nq
    INTEGER, INTENT(IN) :: hord
    INTEGER, INTENT(IN) :: kord
    INTEGER, INTENT(IN) :: q_split
    LOGICAL, INTENT(IN) :: z_tracer
    LOGICAL, INTENT(IN) :: fill
    REAL(fvprc), INTENT(IN) :: dt
! DELP before dyn_core
    REAL(fvprc), INTENT(IN) :: ple0(is:ie, js:je, npz+1)
! DELP after dyn_core
    REAL(fvprc), INTENT(INOUT) :: ple1(is:ie, js:je, npz+1)
! Courant Number X-Dir
    REAL(fvprc), INTENT(IN) :: cx(is:ie, js:je, npz)
! Courant Number Y-Dir
    REAL(fvprc), INTENT(IN) :: cy(is:ie, js:je, npz)
! Mass Flux X-Dir
    REAL(fvprc), INTENT(IN) :: mfx(is:ie, js:je, npz)
! Mass Flux Y-Dir
    REAL(fvprc), INTENT(IN) :: mfy(is:ie, js:je, npz)
! Tracers
    REAL(fvprc), INTENT(INOUT) :: q(is:ie, js:je, npz, nq)
! AK for remapping
    REAL(real8), INTENT(IN) :: ak(npz+1)
! BK for remapping
    REAL(real8), INTENT(IN) :: bk(npz+1)
    REAL(real8), INTENT(IN) :: ptop
! Local Arrays
! X-Dir for MPP Updates
    REAL(real8) :: xl(isd:ied+1, jsd:jed, npz)
! Y-Dir for MPP Updates
    REAL(real8) :: yl(isd:ied, jsd:jed+1, npz)
! Courant Number X-Dir
    REAL(fvprc) :: cxl(is:ie+1, jsd:jed, npz)
! Courant Number Y-Dir
    REAL(fvprc) :: cyl(isd:ied, js:je+1, npz)
! Mass Flux X-Dir
    REAL(fvprc) :: mfxl(is:ie+1, js:je, npz)
! Mass Flux Y-Dir
    REAL(fvprc) :: mfyl(is:ie, js:je+1, npz)
! Pressure Thickness
    REAL(real8) :: dpl(is:ie, js:je, npz)
! Pressure Thickness
    REAL(real8) :: dpa(is:ie, js:je, npz)
! Local Tracer Arrays
! 2D Tracers
    REAL(real8) :: q1(is:ie, js:je, npz)
! 2D Tracers
    REAL(real8) :: q2(isd:ied, jsd:jed, nq)
! 3D Tracers
    REAL(real8) :: q3(isd:ied, jsd:jed, npz, nq)
! Local Buffer Arrarys
    REAL(real8) :: wbuffer(js:je, npz)
    REAL(real8) :: sbuffer(is:ie, npz)
    REAL(real8) :: ebuffer(js:je, npz)
    REAL(real8) :: nbuffer(is:ie, npz)
! Local Remap Arrays
    REAL(real8) :: pe1(is:ie, npz+1)
    REAL(real8) :: pe2(is:ie, npz+1)
    REAL(real8) :: dp2(is:ie, js:je, npz)
! Local indices
    INTEGER :: i, j, k, n, iq
    REAL(real8) :: dtr8
    REAL(real8) :: scalingfactor
!real(REAL8) :: scalingFactors(npz)
! Time-step
    dtr8 = dt
    wbuffer = 0.0
    sbuffer = 0.0
    ebuffer = 0.0
    nbuffer = 0.0
! Fill CX/CY C-Grid boundaries and update ghost regions
    xl(is:ie, js:je, :) = cx(:, :, :)
    yl(is:ie, js:je, :) = cy(:, :, :)
    CALL MPP_GET_BOUNDARY(xl, yl, domain, wbufferx=wbuffer, ebufferx=&
&                   ebuffer, sbuffery=sbuffer, nbuffery=nbuffer, &
&                   gridtype=cgrid_ne)
    xl(ie+1, js:je, :) = ebuffer
    yl(is:ie, je+1, :) = nbuffer
    CALL MPP_UPDATE_DOMAINS(xl, yl, domain, gridtype=cgrid_ne, complete=&
&                     .true.)
    cxl(is:ie+1, jsd:jed, :) = xl(is:ie+1, jsd:jed, :)
    cyl(isd:ied, js:je+1, :) = yl(isd:ied, js:je+1, :)
! Fill MFX/MFY C-Grid boundaries
    xl(is:ie, js:je, :) = mfx(:, :, :)
    yl(is:ie, js:je, :) = mfy(:, :, :)
    CALL MPP_GET_BOUNDARY(xl, yl, domain, wbufferx=wbuffer, ebufferx=&
&                   ebuffer, sbuffery=sbuffer, nbuffery=nbuffer, &
&                   gridtype=cgrid_ne)
    xl(ie+1, js:je, :) = ebuffer
    yl(is:ie, je+1, :) = nbuffer
    mfxl(is:ie+1, js:je, :) = xl(is:ie+1, js:je, :)
    mfyl(is:ie, js:je+1, :) = yl(is:ie, js:je+1, :)
! Fill local tracers and pressure thickness
    dpl(:, :, :) = ple0(:, :, 2:npz+1) - ple0(:, :, 1:npz)
    q3(is:ie, js:je, :, :) = q(is:ie, js:je, :, :)
    IF (z_tracer) THEN
!$omp parallel do default(shared) private(q2)
      DO k=1,npz
        DO iq=1,nq
          DO j=js,je
! To_do list:
            DO i=is,ie
! The data copying can be avoided if q is
              q2(i, j, iq) = q3(i, j, k, iq)
            END DO
          END DO
        END DO
! re-dimensioned as q(i,j,nq,k)
        CALL TRACER_2D_1L(q2, dpl(is, js, k), mfxl(is, js, k), mfyl(is, &
&                   js, k), cxl(is, jsd, k), cyl(isd, js, k), npx, npy, &
&                   npz, 1, nq, hord, q_split, k, q3, dtr8, 0, dpa)
      END DO
    ELSE
      CALL TRACER_2D(q3, dpl, mfxl, mfyl, cxl, cyl, npx, npy, npz, 1, nq&
&              , hord, q_split, dtr8, 0, dpa)
    END IF
!------------------------------------------------------------------
! Re-Map constituents
! Do remapping one tracer at a time; seems to be faster
! It requires less memory than mapn_ppm
!------------------------------------------------------------------
    DO iq=1,nq
      DO j=js,je
! pressures mapping from (dpA is new delp after tracer_2d)
        pe1(:, 1) = ptop
        DO k=2,npz+1
          pe1(:, k) = pe1(:, k-1) + dpa(:, j, k-1)
        END DO
! pressures mapping to
        pe2(:, 1) = ptop
        pe2(:, npz+1) = pe1(:, npz+1)
        DO k=2,npz
          pe2(:, k) = ak(k) + bk(k)*pe1(:, npz+1)
        END DO
        DO k=1,npz
          dp2(:, j, k) = pe2(:, k+1) - pe2(:, k)
        END DO
        CALL MAP1_Q2(npz, pe1, q3(isd, jsd, 1, iq), npz, pe2, q1(:, j, :&
&              ), dp2(:, j, :), is, ie, 0, kord, j, isd, ied, jsd, jed)
!, .true.)
        IF (fill) CALL FILLZ(ie - is + 1, npz, 1, q1(:, j, :), dp2(:, j&
&                      , :))
      END DO
! Rescale tracers based on ple1 at destination timestep
!------------------------------------------------------
      scalingfactor = CALCSCALINGFACTOR(q1, dp2, ple1, npx, npy, npz, is&
&       , ie, js, je)
!scalingFactors = computeScalingFactors(q1, dp2, ple1, npx, npy, npz, is, ie, js, je)
! Return tracers
!---------------
      q(is:ie, js:je, 1:npz, iq) = q1(is:ie, js:je, 1:npz)*scalingfactor
    END DO
  END SUBROUTINE OFFLINE_TRACER_ADVECTION
!-----------------------------------------------------------------------
! !ROUTINE: Perform 2D horizontal-to-lagrangian transport
!-----------------------------------------------------------------------
  SUBROUTINE TRACER_2D_1L(q, dp0, mfx, mfy, cx, cy, npx, npy, npz, qs, &
&   nq, hord, q_split, k, q3, dt, id_divg, dpa)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, npz
    INTEGER, INTENT(IN) :: k
! first tracer to advect
    INTEGER, INTENT(IN) :: qs
! number of tracers to be advected
    INTEGER, INTENT(IN) :: nq
    INTEGER, INTENT(IN) :: hord
    INTEGER, INTENT(IN) :: q_split
    INTEGER, INTENT(IN) :: id_divg
    REAL(real8), INTENT(IN) :: dt
! 2D Tracers
    REAL(real8), INTENT(INOUT) :: q(isd:ied, jsd:jed, nq)
! Tracers
    REAL(real8), INTENT(INOUT) :: q3(isd:ied, jsd:jed, npz, nq)
! DELP before dyn_core
    REAL(real8), INTENT(INOUT) :: dp0(is:ie, js:je)
! DELP after advection
    REAL(real8), OPTIONAL, INTENT(OUT) :: dpa(is:ie, js:je)
! Courant Number X-Dir
    REAL(fvprc), INTENT(IN) :: cx(is:ie+1, jsd:jed)
! Courant Number Y-Dir
    REAL(fvprc), INTENT(IN) :: cy(isd:ied, js:je+1)
! Mass Flux X-Dir
    REAL(fvprc), INTENT(IN) :: mfx(is:ie+1, js:je)
! Mass Flux Y-Dir
    REAL(fvprc), INTENT(IN) :: mfy(is:ie, js:je+1)
! Local Arrays
    REAL(fvprc) :: fx(is:ie+1, js:je)
    REAL(fvprc) :: fy(is:ie, js:je+1)
    REAL(fvprc) :: mfx2(is:ie+1, js:je)
    REAL(fvprc) :: mfy2(is:ie, js:je+1)
    REAL(fvprc) :: cx2(is:ie+1, jsd:jed)
    REAL(fvprc) :: cy2(isd:ied, js:je+1)
    REAL(real8) :: dp1(is:ie, js:je)
    REAL(real8) :: dp2(is:ie, js:je)
    REAL(fvprc) :: ra_x(is:ie, jsd:jed)
    REAL(fvprc) :: ra_y(isd:ied, js:je)
    REAL(fvprc) :: xfx(is:ie+1, jsd:jed)
    REAL(fvprc) :: yfx(isd:ied, js:je+1)
    REAL(fvprc) :: cmax
    REAL(fvprc) :: frac, rdt
    INTEGER :: nsplt
    INTEGER :: i, j, it, iq
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC INT
    INTRINSIC REAL
    INTRINSIC PRESENT
    REAL*8 :: abs0
    REAL*8 :: abs1
    REAL*8 :: x1
    REAL*8 :: y1
    DO j=jsd,jed
      DO i=is,ie+1
        IF (cx(i, j) .GT. 0.) THEN
          xfx(i, j) = cx(i, j)*dxa(i-1, j)*dy(i, j)*sin_sg(i-1, j, 3)
        ELSE
          xfx(i, j) = cx(i, j)*dxa(i, j)*dy(i, j)*sin_sg(i, j, 1)
        END IF
      END DO
    END DO
    DO j=js,je+1
      DO i=isd,ied
        IF (cy(i, j) .GT. 0.) THEN
          yfx(i, j) = cy(i, j)*dya(i, j-1)*dx(i, j)*sin_sg(i, j-1, 4)
        ELSE
          yfx(i, j) = cy(i, j)*dya(i, j)*dx(i, j)*sin_sg(i, j, 2)
        END IF
      END DO
    END DO
    IF (q_split .EQ. 0) THEN
! Determine nsplt for tracer advection
      cmax = 0.
      DO j=js,je
        DO i=is,ie
          IF (cx(i, j) .GE. 0.) THEN
            abs0 = cx(i, j)
          ELSE
            abs0 = -cx(i, j)
          END IF
          x1 = abs0 + (1.-sina_u(i, j))
          IF (cy(i, j) .GE. 0.) THEN
            abs1 = cy(i, j)
          ELSE
            abs1 = -cy(i, j)
          END IF
          y1 = abs1 + (1.-sina_v(i, j))
          IF (x1 .LT. y1) THEN
            IF (y1 .LT. cmax) THEN
              cmax = cmax
            ELSE
              cmax = y1
            END IF
          ELSE IF (x1 .LT. cmax) THEN
            cmax = cmax
          ELSE
            cmax = x1
          END IF
        END DO
      END DO
      CALL MP_REDUCE_MAX(cmax)
      nsplt = INT(1.01 + cmax)
      IF (gid .EQ. 0 .AND. nsplt .GT. 5) WRITE(6, *) k, &
&                                        'Tracer_2d_split=', nsplt, cmax
    ELSE
      nsplt = q_split
    END IF
    frac = 1./REAL(nsplt)
    DO j=jsd,jed
      DO i=is,ie+1
        cx2(i, j) = cx(i, j)*frac
        xfx(i, j) = xfx(i, j)*frac
      END DO
    END DO
    DO j=js,je
      DO i=is,ie+1
        mfx2(i, j) = mfx(i, j)*frac
      END DO
    END DO
    DO j=js,je+1
      DO i=isd,ied
        cy2(i, j) = cy(i, j)*frac
        yfx(i, j) = yfx(i, j)*frac
      END DO
    END DO
    DO j=js,je+1
      DO i=is,ie
        mfy2(i, j) = mfy(i, j)*frac
      END DO
    END DO
    DO j=jsd,jed
      DO i=is,ie
        ra_x(i, j) = area(i, j) + xfx(i, j) - xfx(i+1, j)
      END DO
    END DO
    DO j=js,je
      DO i=isd,ied
        ra_y(i, j) = area(i, j) + yfx(i, j) - yfx(i, j+1)
      END DO
    END DO
    DO j=js,je
      DO i=is,ie
        dp1(i, j) = dp0(i, j)
      END DO
    END DO
    DO it=1,nsplt
      DO j=js,je
        DO i=is,ie
          dp2(i, j) = dp1(i, j) + (mfx2(i, j)-mfx2(i+1, j)+mfy2(i, j)-&
&           mfy2(i, j+1))*rarea(i, j)
        END DO
      END DO
      CALL TIMING_ON('COMM_TOTAL')
      CALL TIMING_ON('COMM_TRAC')
      CALL MPP_UPDATE_DOMAINS(q, domain, complete=.true.)
      CALL TIMING_OFF('COMM_TRAC')
      CALL TIMING_OFF('COMM_TOTAL')
      CALL TIMING_ON('fv_tp_2d')
      DO iq=qs,nq
        CALL FV_TP_2D(q(isd:, jsd:, iq), cx2, cy2, npx, npy, hord, fx, &
&               fy, xfx, yfx, ra_x, ra_y, mfx=mfx2, mfy=mfy2)
        IF (it .EQ. nsplt) THEN
          DO j=js,je
            DO i=is,ie
              q3(i, j, k, iq) = (q(i, j, iq)*dp1(i, j)+(fx(i, j)-fx(i+1&
&               , j)+fy(i, j)-fy(i, j+1))*rarea(i, j))/dp2(i, j)
            END DO
          END DO
        ELSE
          DO j=js,je
            DO i=is,ie
              q(i, j, iq) = (q(i, j, iq)*dp1(i, j)+(fx(i, j)-fx(i+1, j)+&
&               fy(i, j)-fy(i, j+1))*rarea(i, j))/dp2(i, j)
            END DO
          END DO
        END IF
      END DO
      CALL TIMING_OFF('fv_tp_2d')
      IF (it .NE. nsplt) THEN
        DO j=js,je
          DO i=is,ie
            dp1(i, j) = dp2(i, j)
          END DO
        END DO
      END IF
    END DO
! nsplt
    IF (id_divg .GT. 0) THEN
      rdt = 1./(frac*dt)
      DO j=js,je
        DO i=is,ie
          dp0(i, j) = (xfx(i+1, j)-xfx(i, j)+yfx(i, j+1)-yfx(i, j))*&
&           rarea(i, j)*rdt
        END DO
      END DO
    END IF
    IF (PRESENT(dpa)) dpa = dp2
  END SUBROUTINE TRACER_2D_1L
  SUBROUTINE TRACER_2D(q, dp1, mfx, mfy, cx, cy, npx, npy, npz, qs, nq, &
&   hord, q_split, dt, id_divg, dpa)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
! first tracer to advect
    INTEGER, INTENT(IN) :: qs
! number of tracers to be advected
    INTEGER, INTENT(IN) :: nq
    INTEGER, INTENT(IN) :: hord
    INTEGER, INTENT(IN) :: q_split
    INTEGER, INTENT(IN) :: id_divg
    REAL(real8), INTENT(IN) :: dt
! Tracers
    REAL(real8), INTENT(INOUT) :: q(isd:ied, jsd:jed, npz, nq)
! DELP before dyn_core
    REAL(real8), INTENT(INOUT) :: dp1(is:ie, js:je, npz)
! DELP after advection
    REAL(real8), OPTIONAL, INTENT(OUT) :: dpa(is:ie, js:je, npz)
! Courant Number X-Dir
    REAL(fvprc), INTENT(INOUT) :: cx(is:ie+1, jsd:jed, npz)
! Courant Number Y-Dir
    REAL(fvprc), INTENT(INOUT) :: cy(isd:ied, js:je+1, npz)
! Mass Flux X-Dir
    REAL(fvprc), INTENT(INOUT) :: mfx(is:ie+1, js:je, npz)
! Mass Flux Y-Dir
    REAL(fvprc), INTENT(INOUT) :: mfy(is:ie, js:je+1, npz)
! Local Arrays
    REAL(fvprc) :: fx(is:ie+1, js:je)
    REAL(fvprc) :: fy(is:ie, js:je+1)
    REAL(real8) :: dp2(is:ie, js:je)
    REAL(fvprc) :: ra_x(is:ie, jsd:jed)
    REAL(fvprc) :: ra_y(isd:ied, js:je)
    REAL(fvprc) :: xfx(is:ie+1, jsd:jed, npz)
    REAL(fvprc) :: yfx(isd:ied, js:je+1, npz)
    REAL(fvprc) :: cmax(npz)
!#ifdef IBM_FIX
!      real(FVPRC) :: cmax_x, cmax_y
!#endif
    REAL(fvprc) :: c_global
    REAL(fvprc) :: frac, rdt
    INTEGER :: nsplt
    INTEGER :: i, j, k, it, iq
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC INT
    INTRINSIC REAL
    INTRINSIC PRESENT
    REAL*8 :: abs0
    REAL*8 :: abs1
    REAL*8 :: x1
    REAL*8 :: y1
!$omp parallel do default(shared)
    DO k=1,npz
      DO j=jsd,jed
        DO i=is,ie+1
          IF (cx(i, j, k) .GT. 0.) THEN
            xfx(i, j, k) = cx(i, j, k)*dxa(i-1, j)*dy(i, j)*sin_sg(i-1, &
&             j, 3)
          ELSE
            xfx(i, j, k) = cx(i, j, k)*dxa(i, j)*dy(i, j)*sin_sg(i, j, 1&
&             )
          END IF
        END DO
      END DO
      DO j=js,je+1
        DO i=isd,ied
          IF (cy(i, j, k) .GT. 0.) THEN
            yfx(i, j, k) = cy(i, j, k)*dya(i, j-1)*dx(i, j)*sin_sg(i, j-&
&             1, 4)
          ELSE
            yfx(i, j, k) = cy(i, j, k)*dya(i, j)*dx(i, j)*sin_sg(i, j, 2&
&             )
          END IF
        END DO
      END DO
    END DO
!--------------------------------------------------------------------------------
    IF (q_split .EQ. 0) THEN
! Determine nsplt
!#ifdef IBM_FIX
!!$omp parallel do default(shared) private(cmax_x, cmax_y)
!      do k=1,npz
!        cmax(k) = 0.
!        do j=js,je
!          do i=is,ie
!            cmax_x  = max(abs(cx(i,j,k))+1.-sina_u(i,j), cmax(k))
!            cmax_y  = max(abs(cy(i,j,k))+1.-sina_v(i,j), cmax(k))
!            cmax(k) = max(cmax_x, cmax_y)
!          enddo
!        enddo
!      enddo
!#else 
!$omp parallel do default(shared) 
      DO k=1,npz
        cmax(k) = 0.
        DO j=js,je
          DO i=is,ie
            IF (cx(i, j, k) .GE. 0.) THEN
              abs0 = cx(i, j, k)
            ELSE
              abs0 = -cx(i, j, k)
            END IF
            x1 = abs0 + 1. - sina_u(i, j)
            IF (cy(i, j, k) .GE. 0.) THEN
              abs1 = cy(i, j, k)
            ELSE
              abs1 = -cy(i, j, k)
            END IF
            y1 = abs1 + 1. - sina_v(i, j)
            IF (x1 .LT. y1) THEN
              IF (y1 .LT. cmax(k)) THEN
                cmax(k) = cmax(k)
              ELSE
                cmax(k) = y1
              END IF
            ELSE IF (x1 .LT. cmax(k)) THEN
              cmax(k) = cmax(k)
            ELSE
              cmax(k) = x1
            END IF
          END DO
        END DO
      END DO
      CALL MP_REDUCE_MAX(cmax, npz)
!#endif
! find global max courant number and define nsplt to scale cx,cy,mfx,mfy
      c_global = cmax(1)
      IF (npz .NE. 1) THEN
! if NOT shallow water test case
        DO k=2,npz
          IF (cmax(k) .LT. c_global) THEN
            c_global = c_global
          ELSE
            c_global = cmax(k)
          END IF
        END DO
      END IF
      nsplt = INT(1. + c_global)
      IF (gid .EQ. 0 .AND. nsplt .GT. 5) WRITE(6, *) 'Tracer_2d_split='&
&                                        , nsplt, c_global
    ELSE
      nsplt = q_split
    END IF
!--------------------------------------------------------------------------------
    frac = 1./REAL(nsplt)
    IF (nsplt .NE. 1) THEN
!$omp parallel do default(shared)
      DO k=1,npz
        DO j=jsd,jed
          DO i=is,ie+1
            cx(i, j, k) = cx(i, j, k)*frac
            xfx(i, j, k) = xfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je
          DO i=is,ie+1
            mfx(i, j, k) = mfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je+1
          DO i=isd,ied
            cy(i, j, k) = cy(i, j, k)*frac
            yfx(i, j, k) = yfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je+1
          DO i=is,ie
            mfy(i, j, k) = mfy(i, j, k)*frac
          END DO
        END DO
      END DO
    END IF
    DO it=1,nsplt
      CALL TIMING_ON('COMM_TOTAL')
      CALL TIMING_ON('COMM_TRAC')
      CALL MPP_UPDATE_DOMAINS(q, domain, complete=.true.)
      CALL TIMING_OFF('COMM_TRAC')
      CALL TIMING_OFF('COMM_TOTAL')
!$omp parallel do default(shared) private(ra_x, ra_y, dp2, fx, fy)
      DO k=1,npz
        DO j=jsd,jed
          DO i=is,ie
            ra_x(i, j) = area(i, j) + xfx(i, j, k) - xfx(i+1, j, k)
          END DO
        END DO
        DO j=js,je
          DO i=isd,ied
            ra_y(i, j) = area(i, j) + yfx(i, j, k) - yfx(i, j+1, k)
          END DO
        END DO
        DO j=js,je
          DO i=is,ie
            dp2(i, j) = dp1(i, j, k) + (mfx(i, j, k)-mfx(i+1, j, k)+mfy(&
&             i, j, k)-mfy(i, j+1, k))*rarea(i, j)
          END DO
        END DO
        CALL TIMING_ON('fv_tp_2d')
        DO iq=qs,nq
          CALL FV_TP_2D(q(isd:, jsd:, k, iq), cx(is:, jsd:, k), cy(isd:&
&                 , js:, k), npx, npy, hord, fx, fy, xfx(is:, jsd:, k), &
&                 yfx(isd:, js:, k), ra_x, ra_y, mfx=mfx(is:, js:, k), &
&                 mfy=mfy(is:, js:, k))
          DO j=js,je
            DO i=is,ie
              q(i, j, k, iq) = (q(i, j, k, iq)*dp1(i, j, k)+(fx(i, j)-fx&
&               (i+1, j)+fy(i, j)-fy(i, j+1))*rarea(i, j))/dp2(i, j)
            END DO
          END DO
        END DO
        CALL TIMING_OFF('fv_tp_2d')
        DO j=js,je
          DO i=is,ie
            dp1(i, j, k) = dp2(i, j)
          END DO
        END DO
      END DO
    END DO
! npz
! nsplt
! rescale mass fluxes back to original
    mfx = mfx/frac
    mfy = mfy/frac
    cx = cx/frac
    cy = cy/frac
    IF (PRESENT(dpa)) dpa = dp1
    IF (id_divg .GT. 0) THEN
      rdt = 1./(frac*dt)
!$omp parallel do default(shared)
      DO k=1,npz
        DO j=js,je
          DO i=is,ie
            dp1(i, j, k) = (xfx(i+1, j, k)-xfx(i, j, k)+yfx(i, j+1, k)-&
&             yfx(i, j, k))*rarea(i, j)*rdt
          END DO
        END DO
      END DO
    END IF
  END SUBROUTINE TRACER_2D
!  Differentiation of calcscalingfactor in forward (tangent) mode:
!   variations   of useful results: scaling
!   with respect to varying inputs: q1
!------------------------------------------------------------------------------------
  FUNCTION CALCSCALINGFACTOR_TLM(q1, q1_tl, dp2, ple1, npx, npy, npz, is&
&   , ie, js, je, scaling) RESULT (SCALING_TL)
    USE MPP_MOD_D, ONLY : mpp_sum, mpp_sum_tlm
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, is, ie, js, je
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
    REAL(real8), INTENT(IN) :: q1(is:ie, js:je, npz)
    REAL(real8), INTENT(IN) :: q1_tl(is:ie, js:je, npz)
    REAL(real8), INTENT(IN) :: dp2(is:ie, js:je, npz)
    REAL(real8), INTENT(IN) :: ple1(is:ie, js:je, npz+1)
    REAL(real8) :: scaling
    REAL(real8) :: scaling_tl
    INTEGER :: k
    REAL(real8) :: partialsums(2, npz), globalsums(2)
    REAL(real8) :: partialsums_tl(2, npz), globalsums_tl(2)
    REAL(real8), PARAMETER :: tiny_denominator=1.0e-30
    INTRINSIC SUM
    INTRINSIC REAL
    REAL(real8), DIMENSION(ie-is+1, je-js+1) :: arg1
    REAL(real8), DIMENSION(ie-is+1, je-js+1) :: arg1_tl
    partialsums_tl = 0.0_8
!-------
! Compute partial sum on local array first to minimize communication.
! This algorithm will not be strongly repdroducible under changes do domain
! decomposition, but uses far less communication bandwidth (and memory BW)
! then the preceding implementation.
!-------
    DO k=1,npz
! numerator
      arg1_tl(:, :) = dp2(:, :, k)*area(is:ie, js:je)*q1_tl(:, :, k)
      arg1(:, :) = q1(:, :, k)*dp2(:, :, k)*area(is:ie, js:je)
      partialsums_tl(1, k) = SUM(arg1_tl(:, :))
      partialsums(1, k) = SUM(arg1(:, :))
! denominator
      arg1_tl(:, :) = (ple1(:, :, k+1)-ple1(:, :, k))*area(is:ie, js:je)&
&       *q1_tl(:, :, k)
      arg1(:, :) = q1(:, :, k)*(ple1(:, :, k+1)-ple1(:, :, k))*area(is:&
&       ie, js:je)
      partialsums_tl(2, k) = SUM(arg1_tl(:, :))
      partialsums(2, k) = SUM(arg1(:, :))
    END DO
    globalsums_tl = 0.0_8
    globalsums_tl(1) = SUM(partialsums_tl(1, :))
    globalsums(1) = SUM(partialsums(1, :))
    globalsums_tl(2) = SUM(partialsums_tl(2, :))
    globalsums(2) = SUM(partialsums(2, :))
    CALL MPP_SUM_TLM(globalsums, globalsums_tl, 2)
    IF (globalsums(2) .GT. tiny_denominator) THEN
      scaling_tl = (globalsums_tl(1)*globalsums(2)-globalsums(1)*&
&       globalsums_tl(2))/globalsums(2)**2
      scaling = globalsums(1)/globalsums(2)
!#################################################################
! This line was added to ensure strong reproducibility of the code
!#################################################################
      scaling = REAL(scaling, kind=real4)
    ELSE
      scaling = 1.d0
      scaling_tl = 0.0_8
    END IF
  END FUNCTION CALCSCALINGFACTOR_TLM
!------------------------------------------------------------------------------------
  FUNCTION CALCSCALINGFACTOR(q1, dp2, ple1, npx, npy, npz, is, ie, js, &
&   je) RESULT (SCALING)
    USE MPP_MOD_D, ONLY : mpp_sum
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, is, ie, js, je
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
    REAL(real8), INTENT(IN) :: q1(is:ie, js:je, npz)
    REAL(real8), INTENT(IN) :: dp2(is:ie, js:je, npz)
    REAL(real8), INTENT(IN) :: ple1(is:ie, js:je, npz+1)
    REAL(real8) :: scaling
    INTEGER :: k
    REAL(real8) :: partialsums(2, npz), globalsums(2)
    REAL(real8), PARAMETER :: tiny_denominator=1.0e-30
    INTRINSIC SUM
    INTRINSIC REAL
    REAL(real8), DIMENSION(ie-is+1, je-js+1) :: arg1
!-------
! Compute partial sum on local array first to minimize communication.
! This algorithm will not be strongly repdroducible under changes do domain
! decomposition, but uses far less communication bandwidth (and memory BW)
! then the preceding implementation.
!-------
    DO k=1,npz
! numerator
      arg1(:, :) = q1(:, :, k)*dp2(:, :, k)*area(is:ie, js:je)
      partialsums(1, k) = SUM(arg1(:, :))
! denominator
      arg1(:, :) = q1(:, :, k)*(ple1(:, :, k+1)-ple1(:, :, k))*area(is:&
&       ie, js:je)
      partialsums(2, k) = SUM(arg1(:, :))
    END DO
    globalsums(1) = SUM(partialsums(1, :))
    globalsums(2) = SUM(partialsums(2, :))
    CALL MPP_SUM(globalsums, 2)
    IF (globalsums(2) .GT. tiny_denominator) THEN
      scaling = globalsums(1)/globalsums(2)
!#################################################################
! This line was added to ensure strong reproducibility of the code
!#################################################################
      scaling = REAL(scaling, kind=real4)
    ELSE
      scaling = 1.d0
    END IF
  END FUNCTION CALCSCALINGFACTOR
!------------------------------------------------------------------------------------
  FUNCTION COMPUTESCALINGFACTORS(q1, dp2, ple1, npx, npy, npz, is, ie, &
&   js, je) RESULT (SCALING)
    USE MPP_MOD_D, ONLY : mpp_sum
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, is, ie, js, je
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
    REAL(real8), INTENT(IN) :: q1(is:ie, js:je, npz)
    REAL(real8), INTENT(IN) :: dp2(is:ie, js:je, npz)
    REAL(real8), INTENT(IN) :: ple1(is:ie, js:je, npz+1)
    REAL(real8) :: scaling(npz)
    INTEGER :: k
    REAL(real8) :: partialsums(2, npz), globalsums(2, npz)
    REAL(real8), PARAMETER :: tiny_denominator=1.0e-30
    INTRINSIC SUM
    REAL(real8), DIMENSION(ie-is+1, je-js+1) :: arg1
!-------
! Compute partial sum on local array first to minimize communication.
! This algorithm will not be strongly repdroducible under changes do domain
! decomposition, but uses far less communication bandwidth (and memory BW)
! then the preceding implementation.
!-------
    DO k=1,npz
! numerator
      arg1(:, :) = q1(:, :, k)*dp2(:, :, k)*area(is:ie, js:je)
      partialsums(1, k) = SUM(arg1(:, :))
! denominator
      arg1(:, :) = q1(:, :, k)*(ple1(:, :, k+1)-ple1(:, :, k))*area(is:&
&       ie, js:je)
      partialsums(2, k) = SUM(arg1(:, :))
    END DO
    CALL MPP_SUM(partialsums, 2*npz)
    globalsums = partialsums
    DO k=1,npz
      IF (partialsums(2, k) .GT. tiny_denominator) THEN
        scaling(k) = globalsums(1, k)/globalsums(2, k)
      ELSE
        scaling(k) = 1.d0
      END IF
    END DO
  END FUNCTION COMPUTESCALINGFACTORS
END MODULE FV_TRACER2D_MOD_D
