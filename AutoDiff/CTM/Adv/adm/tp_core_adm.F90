!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
MODULE TP_CORE_MOD_B
!BOP
!
! !MODULE: tp_core --- A collection of routines to support FV transport
!
  USE FV_ARRAYS_MOD, ONLY : fvprc, real4, real8, cnvt
  USE FV_MP_MOD_B, ONLY : is, js, ie, je, ng, isd, jsd, ied, jed
  USE FV_GRID_UTILS_MOD_B, ONLY : sw_corner, se_corner, ne_corner, &
& nw_corner, sin_sg => sin_sg, da_min => da_min, big_number_r8 => &
& big_number
  USE FV_GRID_TOOLS_MOD_B, ONLY : grid_type, dx => dx, dy => dy, rdxc =>&
& rdxc, rdyc => rdyc, dxa => dxa, dya => dya, area => area, rarea => &
& rarea
  IMPLICIT NONE
  PRIVATE 
  PUBLIC fv_tp_2d, pert_ppm, copy_corners
  PUBLIC fv_tp_2d_adm, copy_corners_adm
!#ifdef MAPL_MODE
  LOGICAL, PARAMETER :: nested=.false.
!#endif
  REAL(fvprc), PARAMETER :: r3=1./3.
  REAL(fvprc), PARAMETER :: near_zero=1.e-25
  REAL(fvprc), PARAMETER :: ppm_limiter=2.0
  REAL(fvprc), PARAMETER :: big_number=big_number_r8
!#ifdef WAVE_FORM
!! Suresh & Huynh scheme 2.2 (purtabation form)
!! The wave-form is more diffusive than scheme 2.1
! real(FVPRC), parameter:: b1 =   0.0375
! real(FVPRC), parameter:: b2 =  -7./30.
! real(FVPRC), parameter:: b3 =  -23./120.
! real(FVPRC), parameter:: b4 =  13./30.
! real(FVPRC), parameter:: b5 = -11./240.
!#else
! scheme 2.1: perturbation form
  REAL(fvprc), PARAMETER :: b1=1./30.
  REAL(fvprc), PARAMETER :: b2=-(13./60.)
  REAL(fvprc), PARAMETER :: b3=-(13./60.)
  REAL(fvprc), PARAMETER :: b4=0.45
  REAL(fvprc), PARAMETER :: b5=-0.05
!#endif
  REAL(fvprc), PARAMETER :: t11=27./28., t12=-(13./28.), t13=3./7.
  REAL(fvprc), PARAMETER :: s11=11./14., s14=4./7., s15=3./14.
!----------------------------------------------------
! volume-conserving cubic with 2nd drv=0 at end point:
!----------------------------------------------------
! Non-monotonic
  REAL(fvprc), PARAMETER :: c1=-(2./14.)
  REAL(fvprc), PARAMETER :: c2=11./14.
  REAL(fvprc), PARAMETER :: c3=5./14.
!----------------------
! PPM volume mean form:
!----------------------
! 0.58333333
  REAL(fvprc), PARAMETER :: p1=7./12.
  REAL(fvprc), PARAMETER :: p2=-(1./12.)
!#ifdef SINGLE_FV
!   MODULE PROCEDURE fv_tp_2d_r8
!#endif
  INTERFACE FV_TP_2D
      MODULE PROCEDURE FV_TP_2D_R4
  END INTERFACE

  INTERFACE FV_TP_2D_ADM
      MODULE PROCEDURE FV_TP_2D_R4_ADM
  END INTERFACE

  INTERFACE COPY_CORNERS
      MODULE PROCEDURE COPY_CORNERS_R4
      MODULE PROCEDURE COPY_CORNERS_R8
  END INTERFACE

  INTERFACE COPY_CORNERS_ADM
      MODULE PROCEDURE COPY_CORNERS_R8_ADM
  END INTERFACE


CONTAINS
!  Differentiation of fv_tp_2d_r4 in reverse (adjoint) mode:
!   gradient     of useful results: q fx fy
!   with respect to varying inputs: q fx fy
!
! !DESCRIPTION:
!
! !REVISION HISTORY:
!
!EOP
!-----------------------------------------------------------------------
!#ifdef SINGLE_FV
! subroutine fv_tp_2d_r8(qIN, crx, cry, npx, npy, hord, fx, fy, xfx, yfx,  &
!                     ra_x, ra_y, mfx, mfy, mass, nord, damp_c)
!   integer, intent(in):: npx, npy
!   integer, intent(in)::hord
!
!   real(FVPRC), intent(in)::  crx(is:ie+1,jsd:jed)  !
!   real(FVPRC), intent(in)::  xfx(is:ie+1,jsd:jed)  !
!   real(FVPRC), intent(in)::  cry(isd:ied,js:je+1 )  !
!   real(FVPRC), intent(in)::  yfx(isd:ied,js:je+1 )  !
!   real(FVPRC), intent(in):: ra_x(is:ie,jsd:jed)
!   real(FVPRC), intent(in):: ra_y(isd:ied,js:je)
!   real(REAL8), intent(in)::  qIN(isd:ied,jsd:jed)  ! transported scalar
!   real(FVPRC), intent(out)::fx(is:ie+1 ,js:je)    ! Flux in x ( E )
!   real(FVPRC), intent(out)::fy(is:ie,   js:je+1 )    ! Flux in y ( N )
!! optional Arguments:
!   real(FVPRC), OPTIONAL, intent(in):: mfx(is:ie+1,js:je  )  ! Mass Flux X-Dir
!   real(FVPRC), OPTIONAL, intent(in):: mfy(is:ie  ,js:je+1)  ! Mass Flux Y-Dir
!   real(FVPRC), OPTIONAL, intent(in):: mass(isd:ied,jsd:jed)
!   real(FVPRC), OPTIONAL, intent(in):: damp_c
!   integer, OPTIONAL, intent(in):: nord
!! Local:
!   real(FVPRC)   q(isd:ied,jsd:jed)
!   q = CNVT(qIN)
!   call fv_tp_2d(q, crx, cry, npx, npy, hord, fx, fy, xfx, yfx,  &
!                     ra_x, ra_y, mfx=mfx, mfy=mfy, mass=mass, nord=nord, damp_c=damp_c)
! end subroutine fv_tp_2d_r8
!#endif
  SUBROUTINE FV_TP_2D_R4_ADM(q, q_ad, crx, cry, npx, npy, hord, fx, &
&   fx_ad, fy, fy_ad, xfx, yfx, ra_x, ra_y, mfx, mfy, mass, nord, damp_c&
& )
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy
    INTEGER, INTENT(IN) :: hord
!
    REAL(fvprc), INTENT(IN) :: crx(is:ie+1, jsd:jed)
!
    REAL(fvprc), INTENT(IN) :: xfx(is:ie+1, jsd:jed)
!
    REAL(fvprc), INTENT(IN) :: cry(isd:ied, js:je+1)
!
    REAL(fvprc), INTENT(IN) :: yfx(isd:ied, js:je+1)
    REAL(fvprc), INTENT(IN) :: ra_x(is:ie, jsd:jed)
    REAL(fvprc), INTENT(IN) :: ra_y(isd:ied, js:je)
! transported scalar
    REAL(fvprc), INTENT(INOUT) :: q(isd:ied, jsd:jed)
    REAL(fvprc), INTENT(INOUT) :: q_ad(isd:ied, jsd:jed)
! Flux in x ( E )
    REAL(fvprc) :: fx(is:ie+1, js:je)
    REAL(fvprc) :: fx_ad(is:ie+1, js:je)
! Flux in y ( N )
    REAL(fvprc) :: fy(is:ie, js:je+1)
    REAL(fvprc) :: fy_ad(is:ie, js:je+1)
! optional Arguments:
! Mass Flux X-Dir
    REAL(fvprc), OPTIONAL, INTENT(IN) :: mfx(is:ie+1, js:je)
! Mass Flux Y-Dir
    REAL(fvprc), OPTIONAL, INTENT(IN) :: mfy(is:ie, js:je+1)
    REAL(fvprc), OPTIONAL, INTENT(IN) :: mass(isd:ied, jsd:jed)
    REAL(fvprc), OPTIONAL, INTENT(IN) :: damp_c
    INTEGER, OPTIONAL, INTENT(IN) :: nord
! Local:
    INTEGER :: ord_in, ord_ou
    REAL(fvprc) :: q_i(isd:ied, js:je)
    REAL(fvprc) :: q_i_ad(isd:ied, js:je)
    REAL(fvprc) :: q_j(is:ie, jsd:jed)
    REAL(fvprc) :: q_j_ad(is:ie, jsd:jed)
    REAL(fvprc) :: fx1(is:ie+1, js:je)
    REAL(fvprc) :: fx1_ad(is:ie+1, js:je)
    REAL(fvprc) :: fy1(is:ie, js:je+1)
    REAL(fvprc) :: fy1_ad(is:ie, js:je+1)
    REAL(fvprc) :: fx2(is:ie+1, jsd:jed)
    REAL(fvprc) :: fx2_ad(is:ie+1, jsd:jed)
    REAL(fvprc) :: fy2(isd:ied, js:je+1)
    REAL(fvprc) :: fy2_ad(isd:ied, js:je+1)
    REAL(fvprc) :: fyy(isd:ied, js:je+1)
    REAL(fvprc) :: fyy_ad(isd:ied, js:je+1)
    REAL(fvprc) :: fxx(is:ie+1)
    REAL(fvprc) :: fxx_ad(is:ie+1)
    REAL(fvprc) :: damp
    INTEGER :: i, j
    INTRINSIC PRESENT
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp_ad4
    INTEGER :: branch
    ord_in = hord
    ord_ou = hord
    IF (ord_in .LT. 0) THEN
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (ord_ou .LT. 0) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (ord_in .LT. 0) THEN
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (ord_ou .LT. 0) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
!----------------
! Flux averaging:
!----------------
    IF (PRESENT(mfx) .AND. PRESENT(mfy)) THEN
      IF (PRESENT(nord) .AND. PRESENT(damp_c) .AND. PRESENT(mass)) THEN
        IF (damp_c .GT. 1.e-4) THEN
          damp = (damp_c*da_min)**(nord+1)
          CALL DELN_FLUX_ADM(nord, npx, npy, damp, q, q_ad, fx, fx_ad, &
&                      fy, fy_ad, mass)
        END IF
      END IF
      fy1_ad = 0.0_8
      fy2_ad = 0.0_8
      DO j=je+1,js,-1
        DO i=ie,is,-1
          temp_ad2 = mfy(i, j)*0.5*fy_ad(i, j)
          fy1_ad(i, j) = fy1_ad(i, j) + temp_ad2
          fy2_ad(i, j) = fy2_ad(i, j) + temp_ad2
          fy_ad(i, j) = 0.0_8
        END DO
      END DO
      fx1_ad = 0.0_8
      fx2_ad = 0.0_8
      DO j=je,js,-1
        DO i=ie+1,is,-1
          temp_ad1 = mfx(i, j)*0.5*fx_ad(i, j)
          fx1_ad(i, j) = fx1_ad(i, j) + temp_ad1
          fx2_ad(i, j) = fx2_ad(i, j) + temp_ad1
          fx_ad(i, j) = 0.0_8
        END DO
      END DO
    ELSE
      IF (PRESENT(nord) .AND. PRESENT(damp_c)) THEN
        IF (damp_c .GT. 1.e-4) THEN
          damp = (damp_c*da_min)**(nord+1)
          CALL DELN_FLUX_ADM(nord, npx, npy, damp, q, q_ad, fx, fx_ad, &
&                      fy, fy_ad)
        END IF
      END IF
      fy1_ad = 0.0_8
      fy2_ad = 0.0_8
      DO j=je+1,js,-1
        DO i=ie,is,-1
          temp_ad4 = yfx(i, j)*0.5*fy_ad(i, j)
          fy1_ad(i, j) = fy1_ad(i, j) + temp_ad4
          fy2_ad(i, j) = fy2_ad(i, j) + temp_ad4
          fy_ad(i, j) = 0.0_8
        END DO
      END DO
      fx1_ad = 0.0_8
      fx2_ad = 0.0_8
      DO j=je,js,-1
        DO i=ie+1,is,-1
          temp_ad3 = xfx(i, j)*0.5*fx_ad(i, j)
          fx1_ad(i, j) = fx1_ad(i, j) + temp_ad3
          fx2_ad(i, j) = fx2_ad(i, j) + temp_ad3
          fx_ad(i, j) = 0.0_8
        END DO
      END DO
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      q_j_ad = 0.0_8
      CALL YPPM0_ADM(fy1, fy1_ad, q_j, q_j_ad, cry, ord_ou, is, ie, js, &
&              je, npx, npy)
    ELSE
      q_j_ad = 0.0_8
      CALL YTP_ADM(fy1, fy1_ad, q_j, q_j_ad, cry, ord_ou, is, ie, js, je&
&            , npx, npy)
    END IF
    fxx_ad = 0.0_8
    DO j=jed,jsd,-1
      DO i=ie,is,-1
        temp_ad0 = q_j_ad(i, j)/ra_x(i, j)
        q_ad(i, j) = q_ad(i, j) + area(i, j)*temp_ad0
        fxx_ad(i) = fxx_ad(i) + temp_ad0
        fxx_ad(i+1) = fxx_ad(i+1) - temp_ad0
        q_j_ad(i, j) = 0.0_8
      END DO
      DO i=ie+1,is,-1
        fx2_ad(i, j) = fx2_ad(i, j) + xfx(i, j)*fxx_ad(i)
        fxx_ad(i) = 0.0_8
      END DO
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL XTP_ADM(fx2, fx2_ad, q, q_ad, crx, ord_in, is, ie, jsd, jed, &
&            npx, npy)
    ELSE
      CALL XPPM0_ADM(fx2, fx2_ad, q, q_ad, crx, ord_in, is, ie, jsd, jed&
&              , npx, npy)
    END IF
    CALL COPY_CORNERS_ADM(q, q_ad, npx, npy, 1)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      q_i_ad = 0.0_8
      CALL XPPM0_ADM(fx1, fx1_ad, q_i, q_i_ad, crx(is, js), ord_ou, is, &
&              ie, js, je, npx, npy)
    ELSE
      q_i_ad = 0.0_8
      CALL XTP_ADM(fx1, fx1_ad, q_i, q_i_ad, crx(is, js), ord_ou, is, ie&
&            , js, je, npx, npy)
    END IF
    fyy_ad = 0.0_8
    DO j=je,js,-1
      DO i=ied,isd,-1
        temp_ad = q_i_ad(i, j)/ra_y(i, j)
        q_ad(i, j) = q_ad(i, j) + area(i, j)*temp_ad
        fyy_ad(i, j) = fyy_ad(i, j) + temp_ad
        fyy_ad(i, j+1) = fyy_ad(i, j+1) - temp_ad
        q_i_ad(i, j) = 0.0_8
      END DO
    END DO
    DO j=je+1,js,-1
      DO i=ied,isd,-1
        fy2_ad(i, j) = fy2_ad(i, j) + yfx(i, j)*fyy_ad(i, j)
        fyy_ad(i, j) = 0.0_8
      END DO
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL YTP_ADM(fy2, fy2_ad, q, q_ad, cry, ord_in, isd, ied, js, je, &
&            npx, npy)
    ELSE
      CALL YPPM0_ADM(fy2, fy2_ad, q, q_ad, cry, ord_in, isd, ied, js, je&
&              , npx, npy)
    END IF
    CALL COPY_CORNERS_ADM(q, q_ad, npx, npy, 2)
  END SUBROUTINE FV_TP_2D_R4_ADM
!
! !DESCRIPTION:
!
! !REVISION HISTORY:
!
!EOP
!-----------------------------------------------------------------------
!#ifdef SINGLE_FV
! subroutine fv_tp_2d_r8(qIN, crx, cry, npx, npy, hord, fx, fy, xfx, yfx,  &
!                     ra_x, ra_y, mfx, mfy, mass, nord, damp_c)
!   integer, intent(in):: npx, npy
!   integer, intent(in)::hord
!
!   real(FVPRC), intent(in)::  crx(is:ie+1,jsd:jed)  !
!   real(FVPRC), intent(in)::  xfx(is:ie+1,jsd:jed)  !
!   real(FVPRC), intent(in)::  cry(isd:ied,js:je+1 )  !
!   real(FVPRC), intent(in)::  yfx(isd:ied,js:je+1 )  !
!   real(FVPRC), intent(in):: ra_x(is:ie,jsd:jed)
!   real(FVPRC), intent(in):: ra_y(isd:ied,js:je)
!   real(REAL8), intent(in)::  qIN(isd:ied,jsd:jed)  ! transported scalar
!   real(FVPRC), intent(out)::fx(is:ie+1 ,js:je)    ! Flux in x ( E )
!   real(FVPRC), intent(out)::fy(is:ie,   js:je+1 )    ! Flux in y ( N )
!! optional Arguments:
!   real(FVPRC), OPTIONAL, intent(in):: mfx(is:ie+1,js:je  )  ! Mass Flux X-Dir
!   real(FVPRC), OPTIONAL, intent(in):: mfy(is:ie  ,js:je+1)  ! Mass Flux Y-Dir
!   real(FVPRC), OPTIONAL, intent(in):: mass(isd:ied,jsd:jed)
!   real(FVPRC), OPTIONAL, intent(in):: damp_c
!   integer, OPTIONAL, intent(in):: nord
!! Local:
!   real(FVPRC)   q(isd:ied,jsd:jed)
!   q = CNVT(qIN)
!   call fv_tp_2d(q, crx, cry, npx, npy, hord, fx, fy, xfx, yfx,  &
!                     ra_x, ra_y, mfx=mfx, mfy=mfy, mass=mass, nord=nord, damp_c=damp_c)
! end subroutine fv_tp_2d_r8
!#endif
  SUBROUTINE FV_TP_2D_R4(q, crx, cry, npx, npy, hord, fx, fy, xfx, yfx, &
&   ra_x, ra_y, mfx, mfy, mass, nord, damp_c)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy
    INTEGER, INTENT(IN) :: hord
!
    REAL(fvprc), INTENT(IN) :: crx(is:ie+1, jsd:jed)
!
    REAL(fvprc), INTENT(IN) :: xfx(is:ie+1, jsd:jed)
!
    REAL(fvprc), INTENT(IN) :: cry(isd:ied, js:je+1)
!
    REAL(fvprc), INTENT(IN) :: yfx(isd:ied, js:je+1)
    REAL(fvprc), INTENT(IN) :: ra_x(is:ie, jsd:jed)
    REAL(fvprc), INTENT(IN) :: ra_y(isd:ied, js:je)
! transported scalar
    REAL(fvprc), INTENT(INOUT) :: q(isd:ied, jsd:jed)
! Flux in x ( E )
    REAL(fvprc), INTENT(OUT) :: fx(is:ie+1, js:je)
! Flux in y ( N )
    REAL(fvprc), INTENT(OUT) :: fy(is:ie, js:je+1)
! optional Arguments:
! Mass Flux X-Dir
    REAL(fvprc), OPTIONAL, INTENT(IN) :: mfx(is:ie+1, js:je)
! Mass Flux Y-Dir
    REAL(fvprc), OPTIONAL, INTENT(IN) :: mfy(is:ie, js:je+1)
    REAL(fvprc), OPTIONAL, INTENT(IN) :: mass(isd:ied, jsd:jed)
    REAL(fvprc), OPTIONAL, INTENT(IN) :: damp_c
    INTEGER, OPTIONAL, INTENT(IN) :: nord
! Local:
    INTEGER :: ord_in, ord_ou
    REAL(fvprc) :: q_i(isd:ied, js:je)
    REAL(fvprc) :: q_j(is:ie, jsd:jed)
    REAL(fvprc) :: fx1(is:ie+1, js:je)
    REAL(fvprc) :: fy1(is:ie, js:je+1)
    REAL(fvprc) :: fx2(is:ie+1, jsd:jed)
    REAL(fvprc) :: fy2(isd:ied, js:je+1)
    REAL(fvprc) :: fyy(isd:ied, js:je+1)
    REAL(fvprc) :: fxx(is:ie+1)
    REAL(fvprc) :: damp
    INTEGER :: i, j
    INTRINSIC PRESENT
    ord_in = hord
    ord_ou = hord
    CALL COPY_CORNERS(q, npx, npy, 2)
    IF (ord_in .LT. 0) THEN
      CALL YPPM0(fy2, q, cry, ord_in, isd, ied, js, je, npx, npy)
    ELSE
      CALL YTP(fy2, q, cry, ord_in, isd, ied, js, je, npx, npy)
    END IF
    DO j=js,je+1
      DO i=isd,ied
        fyy(i, j) = yfx(i, j)*fy2(i, j)
      END DO
    END DO
    DO j=js,je
      DO i=isd,ied
        q_i(i, j) = (q(i, j)*area(i, j)+fyy(i, j)-fyy(i, j+1))/ra_y(i, j&
&         )
      END DO
    END DO
    IF (ord_ou .LT. 0) THEN
      CALL XPPM0(fx1, q_i, crx(is, js), ord_ou, is, ie, js, je, npx, npy&
&         )
    ELSE
      CALL XTP(fx1, q_i, crx(is, js), ord_ou, is, ie, js, je, npx, npy)
    END IF
    CALL COPY_CORNERS(q, npx, npy, 1)
    IF (ord_in .LT. 0) THEN
      CALL XPPM0(fx2, q, crx, ord_in, is, ie, jsd, jed, npx, npy)
    ELSE
      CALL XTP(fx2, q, crx, ord_in, is, ie, jsd, jed, npx, npy)
    END IF
    DO j=jsd,jed
      DO i=is,ie+1
        fxx(i) = xfx(i, j)*fx2(i, j)
      END DO
      DO i=is,ie
        q_j(i, j) = (q(i, j)*area(i, j)+fxx(i)-fxx(i+1))/ra_x(i, j)
      END DO
    END DO
    IF (ord_ou .LT. 0) THEN
      CALL YPPM0(fy1, q_j, cry, ord_ou, is, ie, js, je, npx, npy)
    ELSE
      CALL YTP(fy1, q_j, cry, ord_ou, is, ie, js, je, npx, npy)
    END IF
!----------------
! Flux averaging:
!----------------
    IF (PRESENT(mfx) .AND. PRESENT(mfy)) THEN
!---------------------------------
! For transport of pt and tracers
!---------------------------------
      DO j=js,je
        DO i=is,ie+1
          fx(i, j) = 0.5*(fx1(i, j)+fx2(i, j))*mfx(i, j)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          fy(i, j) = 0.5*(fy1(i, j)+fy2(i, j))*mfy(i, j)
        END DO
      END DO
      IF (PRESENT(nord) .AND. PRESENT(damp_c) .AND. PRESENT(mass)) THEN
        IF (damp_c .GT. 1.e-4) THEN
          damp = (damp_c*da_min)**(nord+1)
          CALL DELN_FLUX(nord, npx, npy, damp, q, fx, fy, mass)
        END IF
      END IF
    ELSE
!---------------------------------
! For transport of delp, vorticity
!---------------------------------
      DO j=js,je
        DO i=is,ie+1
          fx(i, j) = 0.5*(fx1(i, j)+fx2(i, j))*xfx(i, j)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          fy(i, j) = 0.5*(fy1(i, j)+fy2(i, j))*yfx(i, j)
        END DO
      END DO
      IF (PRESENT(nord) .AND. PRESENT(damp_c)) THEN
        IF (damp_c .GT. 1.e-4) THEN
          damp = (damp_c*da_min)**(nord+1)
          CALL DELN_FLUX(nord, npx, npy, damp, q, fx, fy)
        END IF
      END IF
    END IF
  END SUBROUTINE FV_TP_2D_R4
  SUBROUTINE COPY_CORNERS_R4(q, npx, npy, dir)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, dir
    REAL(real4), INTENT(INOUT) :: q(isd:ied, jsd:jed)
    INTEGER :: i, j
    IF (dir .EQ. 1) THEN
! XDir:
      IF (sw_corner) THEN
        DO j=1-ng,0
          DO i=1-ng,0
            q(i, j) = q(j, 1-i)
          END DO
        END DO
      END IF
      IF (se_corner) THEN
        DO j=1-ng,0
          DO i=npx,npx+ng-1
            q(i, j) = q(npy-j, i-npx+1)
          END DO
        END DO
      END IF
      IF (ne_corner) THEN
        DO j=npy,npy+ng-1
          DO i=npx,npx+ng-1
            q(i, j) = q(j, 2*npx-1-i)
          END DO
        END DO
      END IF
      IF (nw_corner) THEN
        DO j=npy,npy+ng-1
          DO i=1-ng,0
            q(i, j) = q(npy-j, i-1+npx)
          END DO
        END DO
      END IF
    ELSE IF (dir .EQ. 2) THEN
! YDir:
      IF (sw_corner) THEN
        DO j=1-ng,0
          DO i=1-ng,0
            q(i, j) = q(1-j, i)
          END DO
        END DO
      END IF
      IF (se_corner) THEN
        DO j=1-ng,0
          DO i=npx,npx+ng-1
            q(i, j) = q(npy+j-1, npx-i)
          END DO
        END DO
      END IF
      IF (ne_corner) THEN
        DO j=npy,npy+ng-1
          DO i=npx,npx+ng-1
            q(i, j) = q(2*npy-1-j, i)
          END DO
        END DO
      END IF
      IF (nw_corner) THEN
        DO j=npy,npy+ng-1
          DO i=1-ng,0
            q(i, j) = q(j+1-npx, npy-i)
          END DO
        END DO
      END IF
    END IF
  END SUBROUTINE COPY_CORNERS_R4
!  Differentiation of xtp in reverse (adjoint) mode:
!   gradient     of useful results: q fx
!   with respect to varying inputs: q
  SUBROUTINE XTP_ADM(fx, fx_ad, q, q_ad, c, iord, ifirst, ilast, jfirst&
&   , jlast, npx, npy)
    IMPLICIT NONE
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: npx, npy
    INTEGER, INTENT(IN) :: iord
! Courant numbers
    REAL(fvprc), INTENT(IN) :: c(is:ie+1, jfirst:jlast)
    REAL(fvprc), INTENT(IN) :: q(isd:ied, jfirst:jlast)
    REAL(fvprc) :: q_ad(isd:ied, jfirst:jlast)
    REAL(fvprc) :: fx(ifirst:ilast+1, jfirst:jlast)
    REAL(fvprc) :: fx_ad(ifirst:ilast+1, jfirst:jlast)
! Local:
    REAL(fvprc) :: dm(is-2:ie+2)
    REAL(fvprc) :: x0l, x0r, x1
    INTEGER :: i, j
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp_ad4
    INTEGER :: branch
    IF (iord .EQ. 1) THEN
      DO j=jfirst,jlast
        DO i=ifirst,ilast+1
          IF (c(i, j) .GT. 0.) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      DO j=jlast,jfirst,-1
        DO i=ilast+1,ifirst,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            q_ad(i, j) = q_ad(i, j) + fx_ad(i, j)
            fx_ad(i, j) = 0.0_8
          ELSE
            q_ad(i-1, j) = q_ad(i-1, j) + fx_ad(i, j)
            fx_ad(i, j) = 0.0_8
          END IF
        END DO
      END DO
    ELSE IF (iord .EQ. 333) THEN
!Advection using third order scheme
      DO j=jfirst,jlast
        DO i=ifirst,ilast+1
          IF (c(i, j) .GT. 0.) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      DO j=jlast,jfirst,-1
        DO i=ilast+1,ifirst,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            temp_ad2 = fx_ad(i, j)/6.0
            temp_ad3 = -(c(i, j)*0.5*fx_ad(i, j))
            temp_ad4 = c(i, j)**2*fx_ad(i, j)/6.0
            q_ad(i-1, j) = q_ad(i-1, j) + temp_ad4 - temp_ad3 + 2.0*&
&             temp_ad2
            q_ad(i, j) = q_ad(i, j) + temp_ad3 - 2.0*temp_ad4 + 5.0*&
&             temp_ad2
            q_ad(i+1, j) = q_ad(i+1, j) + temp_ad4 - temp_ad2
            fx_ad(i, j) = 0.0_8
          ELSE
            temp_ad = fx_ad(i, j)/6.0
            temp_ad0 = -(c(i, j)*0.5*fx_ad(i, j))
            temp_ad1 = c(i, j)**2*fx_ad(i, j)/6.0
            q_ad(i, j) = q_ad(i, j) + temp_ad1 + temp_ad0 + 2.0*temp_ad
            q_ad(i-1, j) = q_ad(i-1, j) + 5.0*temp_ad - temp_ad0 - 2.0*&
&             temp_ad1
            q_ad(i-2, j) = q_ad(i-2, j) + temp_ad1 - temp_ad
            fx_ad(i, j) = 0.0_8
          END IF
        END DO
      END DO
    ELSE
      CALL FXPPM_ADM(c, q, q_ad, fx, fx_ad, iord, ifirst, ilast, jfirst&
&              , jlast, npx, npy)
    END IF
  END SUBROUTINE XTP_ADM
  SUBROUTINE XTP(fx, q, c, iord, ifirst, ilast, jfirst, jlast, npx, npy)
    IMPLICIT NONE
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: npx, npy
    INTEGER, INTENT(IN) :: iord
! Courant numbers
    REAL(fvprc), INTENT(IN) :: c(is:ie+1, jfirst:jlast)
    REAL(fvprc), INTENT(IN) :: q(isd:ied, jfirst:jlast)
    REAL(fvprc), INTENT(OUT) :: fx(ifirst:ilast+1, jfirst:jlast)
! Local:
    REAL(fvprc) :: dm(is-2:ie+2)
    REAL(fvprc) :: x0l, x0r, x1
    INTEGER :: i, j
    IF (iord .EQ. 1) THEN
      DO j=jfirst,jlast
        DO i=ifirst,ilast+1
          IF (c(i, j) .GT. 0.) THEN
            fx(i, j) = q(i-1, j)
          ELSE
            fx(i, j) = q(i, j)
          END IF
        END DO
      END DO
    ELSE IF (iord .EQ. 333) THEN
!Advection using third order scheme
      DO j=jfirst,jlast
        DO i=ifirst,ilast+1
          IF (c(i, j) .GT. 0.) THEN
            fx(i, j) = (2.0*q(i, j)+5.0*q(i-1, j)-q(i-2, j))/6.0 - 0.5*c&
&             (i, j)*(q(i, j)-q(i-1, j)) + c(i, j)*c(i, j)/6.0*(q(i, j)-&
&             2.0*q(i-1, j)+q(i-2, j))
          ELSE
            fx(i, j) = (2.0*q(i-1, j)+5.0*q(i, j)-q(i+1, j))/6.0 - 0.5*c&
&             (i, j)*(q(i, j)-q(i-1, j)) + c(i, j)*c(i, j)/6.0*(q(i+1, j&
&             )-2.0*q(i, j)+q(i-1, j))
          END IF
        END DO
      END DO
    ELSE
      CALL FXPPM(c, q, fx, iord, ifirst, ilast, jfirst, jlast, npx, npy)
    END IF
  END SUBROUTINE XTP
!  Differentiation of ytp in reverse (adjoint) mode:
!   gradient     of useful results: q fy
!   with respect to varying inputs: q
  SUBROUTINE YTP_ADM(fy, fy_ad, q, q_ad, c, jord, ifirst, ilast, jfirst&
&   , jlast, npx, npy)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: jord
    REAL(fvprc), INTENT(IN) :: q(ifirst:ilast, jfirst-ng:jlast+ng)
    REAL(fvprc) :: q_ad(ifirst:ilast, jfirst-ng:jlast+ng)
! Courant number
    REAL(fvprc), INTENT(IN) :: c(isd:ied, js:je+1)
!  Flux
    REAL(fvprc) :: fy(ifirst:ilast, jfirst:jlast+1)
    REAL(fvprc) :: fy_ad(ifirst:ilast, jfirst:jlast+1)
! !LOCAL VARIABLES:
    REAL(fvprc) :: dm(ifirst:ilast, jfirst-2:jlast+2)
    REAL(fvprc) :: x0l, x0r, x1
    INTEGER :: i, j
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp_ad4
    INTEGER :: branch
    IF (jord .EQ. 1) THEN
      DO j=jfirst,jlast+1
        DO i=ifirst,ilast
          IF (c(i, j) .GT. 0.) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      DO j=jlast+1,jfirst,-1
        DO i=ilast,ifirst,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            q_ad(i, j) = q_ad(i, j) + fy_ad(i, j)
            fy_ad(i, j) = 0.0_8
          ELSE
            q_ad(i, j-1) = q_ad(i, j-1) + fy_ad(i, j)
            fy_ad(i, j) = 0.0_8
          END IF
        END DO
      END DO
    ELSE IF (jord .EQ. 333) THEN
!Advected using third order scheme
      DO j=jfirst,jlast+1
        DO i=ifirst,ilast
          IF (c(i, j) .GT. 0.) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      DO j=jlast+1,jfirst,-1
        DO i=ilast,ifirst,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            temp_ad2 = fy_ad(i, j)/6.0
            temp_ad3 = -(c(i, j)*0.5*fy_ad(i, j))
            temp_ad4 = c(i, j)**2*fy_ad(i, j)/6.0
            q_ad(i, j-1) = q_ad(i, j-1) + temp_ad4 - temp_ad3 + 2.0*&
&             temp_ad2
            q_ad(i, j) = q_ad(i, j) + temp_ad3 - 2.0*temp_ad4 + 5.0*&
&             temp_ad2
            q_ad(i, j+1) = q_ad(i, j+1) + temp_ad4 - temp_ad2
            fy_ad(i, j) = 0.0_8
          ELSE
            temp_ad = fy_ad(i, j)/6.0
            temp_ad0 = -(c(i, j)*0.5*fy_ad(i, j))
            temp_ad1 = c(i, j)**2*fy_ad(i, j)/6.0
            q_ad(i, j) = q_ad(i, j) + temp_ad1 + temp_ad0 + 2.0*temp_ad
            q_ad(i, j-1) = q_ad(i, j-1) + 5.0*temp_ad - temp_ad0 - 2.0*&
&             temp_ad1
            q_ad(i, j-2) = q_ad(i, j-2) + temp_ad1 - temp_ad
            fy_ad(i, j) = 0.0_8
          END IF
        END DO
      END DO
    ELSE
      CALL FYPPM_ADM(c, q, q_ad, fy, fy_ad, jord, ifirst, ilast, jfirst&
&              , jlast, npx, npy)
    END IF
  END SUBROUTINE YTP_ADM
  SUBROUTINE YTP(fy, q, c, jord, ifirst, ilast, jfirst, jlast, npx, npy)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: jord
    REAL(fvprc), INTENT(IN) :: q(ifirst:ilast, jfirst-ng:jlast+ng)
! Courant number
    REAL(fvprc), INTENT(IN) :: c(isd:ied, js:je+1)
!  Flux
    REAL(fvprc), INTENT(OUT) :: fy(ifirst:ilast, jfirst:jlast+1)
! !LOCAL VARIABLES:
    REAL(fvprc) :: dm(ifirst:ilast, jfirst-2:jlast+2)
    REAL(fvprc) :: x0l, x0r, x1
    INTEGER :: i, j
    IF (jord .EQ. 1) THEN
      DO j=jfirst,jlast+1
        DO i=ifirst,ilast
          IF (c(i, j) .GT. 0.) THEN
            fy(i, j) = q(i, j-1)
          ELSE
            fy(i, j) = q(i, j)
          END IF
        END DO
      END DO
    ELSE IF (jord .EQ. 333) THEN
!Advected using third order scheme
      DO j=jfirst,jlast+1
        DO i=ifirst,ilast
          IF (c(i, j) .GT. 0.) THEN
            fy(i, j) = (2.0*q(i, j)+5.0*q(i, j-1)-q(i, j-2))/6.0 - 0.5*c&
&             (i, j)*(q(i, j)-q(i, j-1)) + c(i, j)*c(i, j)/6.0*(q(i, j)-&
&             2.0*q(i, j-1)+q(i, j-2))
          ELSE
            fy(i, j) = (2.0*q(i, j-1)+5.0*q(i, j)-q(i, j+1))/6.0 - 0.5*c&
&             (i, j)*(q(i, j)-q(i, j-1)) + c(i, j)*c(i, j)/6.0*(q(i, j+1&
&             )-2.0*q(i, j)+q(i, j-1))
          END IF
        END DO
      END DO
    ELSE
      CALL FYPPM(c, q, fy, jord, ifirst, ilast, jfirst, jlast, npx, npy)
    END IF
  END SUBROUTINE YTP
!  Differentiation of xppm0 in reverse (adjoint) mode:
!   gradient     of useful results: q flux
!   with respect to varying inputs: q
!#ifdef XPPM_2D
! subroutine xppm0(flux, q, c, iord, ifirst, ilast, jfirst, jlast, npx, npy, bd, dxa, nested, grid_type)
! type(fv_grid_bounds_type), intent(IN) :: bd
! integer, INTENT(IN) :: ifirst, ilast               !  X-Dir strip
! integer, INTENT(IN) :: jfirst, jlast               !  Y-Dir strip
! integer, INTENT(IN) :: iord
! integer, INTENT(IN) :: npx, npy
! real   , INTENT(IN) :: q(ifirst-ng:ilast+ng,jfirst:jlast)
! real   , INTENT(IN) :: c(ifirst   :ilast+1 ,jfirst:jlast) ! Courant   N (like FLUX)
! real   , intent(IN) :: dxa(bd%isd:bd%ied,bd%jsd:bd%jed)
! logical, intent(IN) :: nested
! integer, intent(IN) :: grid_type
!! !OUTPUT PARAMETERS:
! real  , INTENT(OUT) :: flux(ifirst:ilast+1,jfirst:jlast) !  Flux
!! Local
! real, dimension(3*jfirst:3*jlast+2) :: q_tmp, bl_tmp, br_tmp
! real, dimension(ifirst-1:ilast+1,jfirst:jlast):: bl, br
! real  al(ifirst-1:ilast+2,jfirst:jlast)
! real  dm(ifirst-2:ilast+2,jfirst:jlast)
! real  dq(ifirst-3:ilast+2,jfirst:jlast)
! logical extm(ifirst-2:ilast+2,jfirst:jlast)
! integer i, j, ie3, is1, ie1
! real xt, pmp_1, lac_1, pmp_2, lac_2
!
! if ( .not. nested .and. grid_type<3 ) then
!    is1 = max(3,is-1);  ie3 = min(npx-2,ie+2)
!                        ie1 = min(npx-3,ie+1)
! else
!    is1 = is-1;         ie3 = ie+2
!                        ie1 = ie+1
! end if
!
! if ( abs(iord) < 8 ) then
!
!    ! ord = -5: linear scheme based on PPM 4th order interpolation
!    ! ord = -6: linear PPM with 2-delta filter
!    ! ord = -7: (-6) with additional Positive definite constraint:
!
!    do j=jfirst,jlast
!       do i=is1, ie3
!          al(i,j) = p1*(q(i-1,j)+q(i,j)) + p2*(q(i-2,j)+q(i+1,j))
!       enddo
!    enddo
!    if ( .not. nested .and. grid_type<3 ) then
!       if ( is==1 ) then
!          do j=jfirst,jlast
!             al(0,j) = c1*q(-2,j) + c2*q(-1,j) + c3*q(0,j)
!             al(1,j) = 0.5*(((2.*dxa(0,j)+dxa(-1,j))*q(0,j)-dxa(0,j)*q(-1,j))/(dxa(-1,j)+dxa(0,j)) &
!                  +      ((2.*dxa(1,j)+dxa( 2,j))*q(1,j)-dxa(1,j)*q(2,j))/(dxa(1, j)+dxa(2,j)))
!             al(2,j) = c3*q(1,j) + c2*q(2,j) +c1*q(3,j)
!          enddo
!          if(iord==-7) then
!             do j=jfirst,jlast
!                al(0,j) = max(0., al(0,j))
!                al(1,j) = max(0., al(1,j))
!                al(2,j) = max(0., al(2,j))
!             enddo
!          endif
!       endif
!       if ( (ie+1)==npx ) then
!          do j=jfirst,jlast
!             al(npx-1,j) = c1*q(npx-3,j) + c2*q(npx-2,j) + c3*q(npx-1,j)
!             al(npx,j) = 0.5*(((2.*dxa(npx-1,j)+dxa(npx-2,j))*q(npx-1,j)-dxa(npx-1,j)*q(npx-2,j))/(dxa(npx-2,j)+dxa(npx-1,j)) &
!                  +      ((2.*dxa(npx,  j)+dxa(npx+1,j))*q(npx,j)-dxa(npx,  j)*q(npx+1,j))/(dxa(npx,  j)+dxa(npx+1,j)))
!             al(npx+1,j) = c3*q(npx,j) + c2*q(npx+1,j) + c1*q(npx+2,j)
!          enddo
!          if(iord==-7) then
!             do j=jfirst,jlast
!                al(npx-1,j) = max(0., al(npx-1,j))
!                al(npx,  j) = max(0., al(npx  ,j))
!                al(npx+1,j) = max(0., al(npx+1,j))
!             enddo
!          endif
!       endif
!    endif
!
!    if ( iord==-5 ) then
!       do j=jfirst,jlast
!          do i=ifirst-1,ilast+1
!             bl(i,j) = al(i,j)   - q(i,j)
!             br(i,j) = al(i+1,j) - q(i,j)
!          enddo
!       enddo
!    else
!       do j=jfirst,jlast
!          do i=ifirst-3,ilast+2
!             dq(i,j) = q(i+1,j) - q(i,j)
!          enddo
!       enddo
!       do j=jfirst,jlast
!          do i=ifirst-2, ilast+2
!             if ( dq(i-1,j)*dq(i,j) > 0. ) then
!                extm(i,j) = .false.
!             else
!                extm(i,j) = .true.
!             endif
!          enddo
!       enddo
!       do j=jfirst,jlast
!          do i=ifirst-1,ilast+1
!             if ( extm(i-1,j).and.extm(i,j).and.extm(i+1,j) ) then
!                bl(i,j) = 0.
!                br(i,j) = 0.
!             else
!                bl(i,j) = al(i,j)   - q(i,j)
!                br(i,j) = al(i+1,j) - q(i,j)
!             endif
!          enddo
!       enddo
!       ! Additional positive definite constraint:
!       if(iord==-7) call pert_ppm(ilast-ifirst+3, q(ifirst-1,j), bl(ifirst-1,j), br(ifirst-1,j), 0)
!    endif
! else
!
!! Monotonic constraints:
!! ord = 8: PPM with Lin's PPM fast monotone constraint
!! ord = 10: PPM with Lin's modification of Huynh 2nd constraint
!! ord = 13: 10 plus positive definite constraint
!    do j=jfirst,jlast
!!DEC$ VECTOR ALWAYS
!       do i=is-2,ie+2
!          xt = 0.25*(q(i+1,j) - q(i-1,j))
!          dm(i,j) = sign(min(abs(xt), max(q(i-1,j), q(i,j), q(i+1,j)) - q(i,j),  &
!               q(i,j) - min(q(i-1,j), q(i,j), q(i+1,j))), xt)
!       enddo
!    enddo
!    do j=jfirst,jlast
!!DEC$ VECTOR ALWAYS
!       do i=is1,ie1+1
!          al(i,j) = 0.5*(q(i-1,j)+q(i,j)) + r3*(dm(i-1,j)-dm(i,j))
!       enddo
!    enddo
!    if ( iord==-8 ) then
!       do j=jfirst,jlast
!!DEC$ VECTOR ALWAYS
!          do i=is1, ie1
!             xt = 2.*dm(i,j)
!             bl(i,j) = -sign(min(abs(xt), abs(al(i,j  )-q(i,j))), xt)
!             br(i,j) =  sign(min(abs(xt), abs(al(i+1,j)-q(i,j))), xt)
!          enddo
!       enddo
!    else
!       do j=jfirst,jlast
!          do i=is1-2, ie1+1
!             dq(i,j) = q(i+1,j) - q(i,j)
!          enddo
!       enddo
!       do j=jfirst,jlast
!          do i=is1, ie1
!             bl(i,j) = al(i,j  ) - q(i,j)
!             br(i,j) = al(i+1,j) - q(i,j)
!             if ( abs(dm(i-1,j))+abs(dm(i,j))+abs(dm(i+1,j)) < near_zero ) then
!                bl(i,j) = 0.
!                br(i,j) = 0.
!             elseif( abs(3.*(bl(i,j)+br(i,j))) > abs(bl(i,j)-br(i,j)) ) then
!                pmp_1 = -(dq(i,j) + dq(i,j))
!                lac_1 = pmp_1 + 1.5*dq(i+1,j)
!                bl(i,j) = min( max(0., pmp_1, lac_1), max(bl(i,j), min(0., pmp_1, lac_1)) )
!                pmp_2 = dq(i-1,j) + dq(i-1,j)
!                lac_2 = pmp_2 - 1.5*dq(i-2,j)
!                br(i,j) = min( max(0., pmp_2, lac_2), max(br(i,j), min(0., pmp_2, lac_2)) )
!             endif
!          enddo
!       enddo
!    endif
!    ! Positive definite constraint:
!    if(iord==-9 .or. iord==-13) call pert_ppm(ie1-is1+1, q(is1,j), bl(is1,j), br(is1,j), 0)
!
!    if (.not. nested .and. grid_type<3) then
!       if ( is==1 ) then
!          do j=jfirst,jlast
!             bl_tmp(3*j) = s14*dm(-1,j) + s11*(q(-1,j)-q(0,j))
!
!             xt = 0.5*(((2.*dxa(0,j)+dxa(-1,j))*q(0,j)-dxa(0,j)*q(-1,j))/(dxa(-1,j)+dxa(0,j)) &
!                  +      ((2.*dxa(1,j)+dxa( 2,j))*q(1,j)-dxa(1,j)*q(2,j))/(dxa(1, j)+dxa(2,j)))
!             br_tmp(3*j) = xt - q(0,j)
!             bl_tmp(3*j+1) = xt - q(1,j)
!             xt = s15*q(1,j) + s11*q(2,j) - s14*dm(2,j)
!             br_tmp(3*j+1) = xt - q(1,j)
!             bl_tmp(3*j+2) = xt - q(2,j)
!             br_tmp(3*j+2) = al(3,j) - q(2,j)
!             q_tmp(j*3:j*3+2) = q(0:2,j)
!          enddo
!          call pert_ppm(3*(jlast-jfirst+1), q_tmp, bl_tmp, br_tmp, 1)
!          do j=jfirst,jlast
!             bl(0:2,j) = bl_tmp(j*3:j*3+2)
!             br(0:2,j) = br_tmp(j*3:j*3+2)
!          enddo
!      endif
!      if ( (ie+1)==npx ) then
!         do j=jfirst,jlast
!            bl_tmp(3*j) = al(npx-2,j) - q(npx-2,j)
!
!            xt = s15*q(npx-1,j) + s11*q(npx-2,j) + s14*dm(npx-2,j)
!            br_tmp(3*j) = xt - q(npx-2,j)
!            bl_tmp(3*j+1) = xt - q(npx-1,j)
!
!            xt = 0.5*(((2.*dxa(npx-1,j)+dxa(npx-2,j))*q(npx-1,j)-dxa(npx-1,j)*q(npx-2,j))/(dxa(npx-2,j)+dxa(npx-1,j)) &
!               +      ((2.*dxa(npx,  j)+dxa(npx+1,j))*q(npx,j  )-dxa(npx,  j)*q(npx+1,j))/(dxa(npx,  j)+dxa(npx+1,j)))
!            br_tmp(3*j+1) = xt - q(npx-1,j)
!            bl_tmp(3*j+2) = xt - q(npx,j  )
!
!            br_tmp(3*j+2) = s11*(q(npx+1,j)-q(npx,j)) - s14*dm(npx+1,j)
!            q_tmp(j*3:j*3+2) = q(npx-2:npx,j)
!         enddo
!         call pert_ppm(3*(jlast-jfirst+1), q_tmp, bl_tmp, br_tmp, 1)
!
!         do j=jfirst,jlast
!            bl(npx-2:npx,j) = bl_tmp(j*3:j*3+2)
!            br(npx-2:npx,j) = br_tmp(j*3:j*3+2)
!         enddo
!      endif
!    endif
!
!  endif
!
!  do j=jfirst,jlast
!!DEC$ VECTOR ALWAYS
!     do i=ifirst,ilast+1
!        if( c(i,j)>0. ) then
!           flux(i,j) = q(i-1,j) + (1.-c(i,j))*(br(i-1,j)-c(i,j)*(bl(i-1,j)+br(i-1,j)))
!        else
!           flux(i,j) = q(i,j  ) + (1.+c(i,j))*(bl(i,j  )+c(i,j)*(bl(i,j  )+br(i,j  )))
!        endif
!     enddo
!  enddo
!
! end subroutine xppm0
!#else
  SUBROUTINE XPPM0_ADM(flux, flux_ad, q, q_ad, c, iord, ifirst, ilast, &
&   jfirst, jlast, npx, npy)
    IMPLICIT NONE
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: iord
    INTEGER, INTENT(IN) :: npx, npy
    REAL, INTENT(IN) :: q(ifirst-ng:ilast+ng, jfirst:jlast)
    REAL :: q_ad(ifirst-ng:ilast+ng, jfirst:jlast)
! Courant   N (like FLUX)
    REAL, INTENT(IN) :: c(ifirst:ilast+1, jfirst:jlast)
! !OUTPUT PARAMETERS:
!  Flux
    REAL :: flux(ifirst:ilast+1, jfirst:jlast)
    REAL :: flux_ad(ifirst:ilast+1, jfirst:jlast)
! Local
    REAL, DIMENSION(ifirst-ng:ilast+ng) :: q1
    REAL, DIMENSION(ifirst-ng:ilast+ng) :: q1_ad
    REAL, DIMENSION(ifirst-1:ilast+1) :: bl, br
    REAL, DIMENSION(ifirst-1:ilast+1) :: bl_ad, br_ad
    REAL :: al(ifirst-1:ilast+2)
    REAL :: al_ad(ifirst-1:ilast+2)
    REAL :: dm(ifirst-2:ilast+2)
    REAL :: dq(ifirst-3:ilast+2)
    LOGICAL :: extm(ifirst-2:ilast+2)
    INTEGER :: i, j, ie3, is1, ie1
    REAL :: xt, pmp_1, lac_1, pmp_2, lac_2
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTEGER :: abs0
    REAL*8 :: temp_ad
    REAL*8 :: temp_ad0
    REAL*8 :: temp_ad1
    REAL*8 :: temp_ad2
    REAL :: temp_ad3
    REAL :: temp_ad4
    REAL :: temp_ad5
    REAL :: temp_ad6
    INTEGER :: branch
    IF (.NOT.nested .AND. grid_type .LT. 3) THEN
      IF (3 .LT. is - 1) THEN
        is1 = is - 1
      ELSE
        is1 = 3
      END IF
      IF (npx - 2 .GT. ie + 2) THEN
        CALL PUSHCONTROL1B(1)
        ie3 = ie + 2
      ELSE
        CALL PUSHCONTROL1B(1)
        ie3 = npx - 2
      END IF
    ELSE
      CALL PUSHCONTROL1B(0)
      is1 = is - 1
      ie3 = ie + 2
    END IF
    DO j=jfirst,jlast
      IF (iord .GE. 0.) THEN
        abs0 = iord
      ELSE
        abs0 = -iord
      END IF
      IF (abs0 .LT. 8) THEN
        IF (.NOT.nested .AND. grid_type .LT. 3) THEN
          IF (is .EQ. 1) THEN
            CALL PUSHCONTROL1B(0)
          ELSE
            CALL PUSHCONTROL1B(1)
          END IF
          IF (ie + 1 .EQ. npx) THEN
            CALL PUSHCONTROL2B(0)
          ELSE
            CALL PUSHCONTROL2B(1)
          END IF
        ELSE
          CALL PUSHCONTROL2B(2)
        END IF
        IF (iord .EQ. -5) THEN
          CALL PUSHCONTROL2B(2)
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(0)
      END IF
      DO i=ifirst,ilast+1
        IF (c(i, j) .GT. 0.) THEN
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
    END DO
    al_ad = 0.0
    bl_ad = 0.0
    br_ad = 0.0
    q1_ad = 0.0
    DO j=jlast,jfirst,-1
      DO i=ilast+1,ifirst,-1
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          temp_ad5 = (c(i, j)+1.)*flux_ad(i, j)
          temp_ad6 = c(i, j)*temp_ad5
          q1_ad(i) = q1_ad(i) + flux_ad(i, j)
          bl_ad(i) = bl_ad(i) + temp_ad6 + temp_ad5
          br_ad(i) = br_ad(i) + temp_ad6
          flux_ad(i, j) = 0.0
        ELSE
          temp_ad3 = (1.-c(i, j))*flux_ad(i, j)
          temp_ad4 = -(c(i, j)*temp_ad3)
          q1_ad(i-1) = q1_ad(i-1) + flux_ad(i, j)
          br_ad(i-1) = br_ad(i-1) + temp_ad4 + temp_ad3
          bl_ad(i-1) = bl_ad(i-1) + temp_ad4
          flux_ad(i, j) = 0.0
        END IF
      END DO
      CALL POPCONTROL2B(branch)
      IF (branch .NE. 0) THEN
        IF (branch .NE. 1) THEN
          DO i=ilast+1,ifirst-1,-1
            al_ad(i+1) = al_ad(i+1) + br_ad(i)
            q1_ad(i) = q1_ad(i) - bl_ad(i) - br_ad(i)
            br_ad(i) = 0.0
            al_ad(i) = al_ad(i) + bl_ad(i)
            bl_ad(i) = 0.0
          END DO
        END IF
        CALL POPCONTROL2B(branch)
        IF (branch .EQ. 0) THEN
          q1_ad(npx) = q1_ad(npx) + c3*al_ad(npx+1)
          q1_ad(npx+1) = q1_ad(npx+1) + c2*al_ad(npx+1)
          q1_ad(npx+2) = q1_ad(npx+2) + c1*al_ad(npx+1)
          al_ad(npx+1) = 0.0
          temp_ad1 = 0.5*al_ad(npx)/(dxa(npx-2, j)+dxa(npx-1, j))
          temp_ad2 = 0.5*al_ad(npx)/(dxa(npx, j)+dxa(npx+1, j))
          q1_ad(npx-1) = q1_ad(npx-1) + (dxa(npx-1, j)*2.+dxa(npx-2, j))&
&           *temp_ad1
          q1_ad(npx-2) = q1_ad(npx-2) - dxa(npx-1, j)*temp_ad1
          q1_ad(npx) = q1_ad(npx) + (dxa(npx, j)*2.+dxa(npx+1, j))*&
&           temp_ad2
          q1_ad(npx+1) = q1_ad(npx+1) - dxa(npx, j)*temp_ad2
          al_ad(npx) = 0.0
          q1_ad(npx-3) = q1_ad(npx-3) + c1*al_ad(npx-1)
          q1_ad(npx-2) = q1_ad(npx-2) + c2*al_ad(npx-1)
          q1_ad(npx-1) = q1_ad(npx-1) + c3*al_ad(npx-1)
          al_ad(npx-1) = 0.0
        ELSE IF (branch .NE. 1) THEN
          GOTO 100
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          q1_ad(1) = q1_ad(1) + c3*al_ad(2)
          q1_ad(2) = q1_ad(2) + c2*al_ad(2)
          q1_ad(3) = q1_ad(3) + c1*al_ad(2)
          al_ad(2) = 0.0
          temp_ad = 0.5*al_ad(1)/(dxa(-1, j)+dxa(0, j))
          temp_ad0 = 0.5*al_ad(1)/(dxa(1, j)+dxa(2, j))
          q1_ad(0) = q1_ad(0) + (dxa(0, j)*2.+dxa(-1, j))*temp_ad
          q1_ad(-1) = q1_ad(-1) - dxa(0, j)*temp_ad
          q1_ad(1) = q1_ad(1) + (dxa(1, j)*2.+dxa(2, j))*temp_ad0
          q1_ad(2) = q1_ad(2) - dxa(1, j)*temp_ad0
          al_ad(1) = 0.0
          q1_ad(-2) = q1_ad(-2) + c1*al_ad(0)
          q1_ad(-1) = q1_ad(-1) + c2*al_ad(0)
          q1_ad(0) = q1_ad(0) + c3*al_ad(0)
          al_ad(0) = 0.0
        END IF
 100    DO i=ie3,is1,-1
          q1_ad(i-1) = q1_ad(i-1) + p1*al_ad(i)
          q1_ad(i) = q1_ad(i) + p1*al_ad(i)
          q1_ad(i-2) = q1_ad(i-2) + p2*al_ad(i)
          q1_ad(i+1) = q1_ad(i+1) + p2*al_ad(i)
          al_ad(i) = 0.0
        END DO
      END IF
      DO i=ilast+ng,ifirst-ng,-1
        q_ad(i, j) = q_ad(i, j) + q1_ad(i)
        q1_ad(i) = 0.0
      END DO
    END DO
    CALL POPCONTROL1B(branch)
  END SUBROUTINE XPPM0_ADM
!#ifdef XPPM_2D
! subroutine xppm0(flux, q, c, iord, ifirst, ilast, jfirst, jlast, npx, npy, bd, dxa, nested, grid_type)
! type(fv_grid_bounds_type), intent(IN) :: bd
! integer, INTENT(IN) :: ifirst, ilast               !  X-Dir strip
! integer, INTENT(IN) :: jfirst, jlast               !  Y-Dir strip
! integer, INTENT(IN) :: iord
! integer, INTENT(IN) :: npx, npy
! real   , INTENT(IN) :: q(ifirst-ng:ilast+ng,jfirst:jlast)
! real   , INTENT(IN) :: c(ifirst   :ilast+1 ,jfirst:jlast) ! Courant   N (like FLUX)
! real   , intent(IN) :: dxa(bd%isd:bd%ied,bd%jsd:bd%jed)
! logical, intent(IN) :: nested
! integer, intent(IN) :: grid_type
!! !OUTPUT PARAMETERS:
! real  , INTENT(OUT) :: flux(ifirst:ilast+1,jfirst:jlast) !  Flux
!! Local
! real, dimension(3*jfirst:3*jlast+2) :: q_tmp, bl_tmp, br_tmp
! real, dimension(ifirst-1:ilast+1,jfirst:jlast):: bl, br
! real  al(ifirst-1:ilast+2,jfirst:jlast)
! real  dm(ifirst-2:ilast+2,jfirst:jlast)
! real  dq(ifirst-3:ilast+2,jfirst:jlast)
! logical extm(ifirst-2:ilast+2,jfirst:jlast)
! integer i, j, ie3, is1, ie1
! real xt, pmp_1, lac_1, pmp_2, lac_2
!
! if ( .not. nested .and. grid_type<3 ) then
!    is1 = max(3,is-1);  ie3 = min(npx-2,ie+2)
!                        ie1 = min(npx-3,ie+1)
! else
!    is1 = is-1;         ie3 = ie+2
!                        ie1 = ie+1
! end if
!
! if ( abs(iord) < 8 ) then
!
!    ! ord = -5: linear scheme based on PPM 4th order interpolation
!    ! ord = -6: linear PPM with 2-delta filter
!    ! ord = -7: (-6) with additional Positive definite constraint:
!
!    do j=jfirst,jlast
!       do i=is1, ie3
!          al(i,j) = p1*(q(i-1,j)+q(i,j)) + p2*(q(i-2,j)+q(i+1,j))
!       enddo
!    enddo
!    if ( .not. nested .and. grid_type<3 ) then
!       if ( is==1 ) then
!          do j=jfirst,jlast
!             al(0,j) = c1*q(-2,j) + c2*q(-1,j) + c3*q(0,j)
!             al(1,j) = 0.5*(((2.*dxa(0,j)+dxa(-1,j))*q(0,j)-dxa(0,j)*q(-1,j))/(dxa(-1,j)+dxa(0,j)) &
!                  +      ((2.*dxa(1,j)+dxa( 2,j))*q(1,j)-dxa(1,j)*q(2,j))/(dxa(1, j)+dxa(2,j)))
!             al(2,j) = c3*q(1,j) + c2*q(2,j) +c1*q(3,j)
!          enddo
!          if(iord==-7) then
!             do j=jfirst,jlast
!                al(0,j) = max(0., al(0,j))
!                al(1,j) = max(0., al(1,j))
!                al(2,j) = max(0., al(2,j))
!             enddo
!          endif
!       endif
!       if ( (ie+1)==npx ) then
!          do j=jfirst,jlast
!             al(npx-1,j) = c1*q(npx-3,j) + c2*q(npx-2,j) + c3*q(npx-1,j)
!             al(npx,j) = 0.5*(((2.*dxa(npx-1,j)+dxa(npx-2,j))*q(npx-1,j)-dxa(npx-1,j)*q(npx-2,j))/(dxa(npx-2,j)+dxa(npx-1,j)) &
!                  +      ((2.*dxa(npx,  j)+dxa(npx+1,j))*q(npx,j)-dxa(npx,  j)*q(npx+1,j))/(dxa(npx,  j)+dxa(npx+1,j)))
!             al(npx+1,j) = c3*q(npx,j) + c2*q(npx+1,j) + c1*q(npx+2,j)
!          enddo
!          if(iord==-7) then
!             do j=jfirst,jlast
!                al(npx-1,j) = max(0., al(npx-1,j))
!                al(npx,  j) = max(0., al(npx  ,j))
!                al(npx+1,j) = max(0., al(npx+1,j))
!             enddo
!          endif
!       endif
!    endif
!
!    if ( iord==-5 ) then
!       do j=jfirst,jlast
!          do i=ifirst-1,ilast+1
!             bl(i,j) = al(i,j)   - q(i,j)
!             br(i,j) = al(i+1,j) - q(i,j)
!          enddo
!       enddo
!    else
!       do j=jfirst,jlast
!          do i=ifirst-3,ilast+2
!             dq(i,j) = q(i+1,j) - q(i,j)
!          enddo
!       enddo
!       do j=jfirst,jlast
!          do i=ifirst-2, ilast+2
!             if ( dq(i-1,j)*dq(i,j) > 0. ) then
!                extm(i,j) = .false.
!             else
!                extm(i,j) = .true.
!             endif
!          enddo
!       enddo
!       do j=jfirst,jlast
!          do i=ifirst-1,ilast+1
!             if ( extm(i-1,j).and.extm(i,j).and.extm(i+1,j) ) then
!                bl(i,j) = 0.
!                br(i,j) = 0.
!             else
!                bl(i,j) = al(i,j)   - q(i,j)
!                br(i,j) = al(i+1,j) - q(i,j)
!             endif
!          enddo
!       enddo
!       ! Additional positive definite constraint:
!       if(iord==-7) call pert_ppm(ilast-ifirst+3, q(ifirst-1,j), bl(ifirst-1,j), br(ifirst-1,j), 0)
!    endif
! else
!
!! Monotonic constraints:
!! ord = 8: PPM with Lin's PPM fast monotone constraint
!! ord = 10: PPM with Lin's modification of Huynh 2nd constraint
!! ord = 13: 10 plus positive definite constraint
!    do j=jfirst,jlast
!!DEC$ VECTOR ALWAYS
!       do i=is-2,ie+2
!          xt = 0.25*(q(i+1,j) - q(i-1,j))
!          dm(i,j) = sign(min(abs(xt), max(q(i-1,j), q(i,j), q(i+1,j)) - q(i,j),  &
!               q(i,j) - min(q(i-1,j), q(i,j), q(i+1,j))), xt)
!       enddo
!    enddo
!    do j=jfirst,jlast
!!DEC$ VECTOR ALWAYS
!       do i=is1,ie1+1
!          al(i,j) = 0.5*(q(i-1,j)+q(i,j)) + r3*(dm(i-1,j)-dm(i,j))
!       enddo
!    enddo
!    if ( iord==-8 ) then
!       do j=jfirst,jlast
!!DEC$ VECTOR ALWAYS
!          do i=is1, ie1
!             xt = 2.*dm(i,j)
!             bl(i,j) = -sign(min(abs(xt), abs(al(i,j  )-q(i,j))), xt)
!             br(i,j) =  sign(min(abs(xt), abs(al(i+1,j)-q(i,j))), xt)
!          enddo
!       enddo
!    else
!       do j=jfirst,jlast
!          do i=is1-2, ie1+1
!             dq(i,j) = q(i+1,j) - q(i,j)
!          enddo
!       enddo
!       do j=jfirst,jlast
!          do i=is1, ie1
!             bl(i,j) = al(i,j  ) - q(i,j)
!             br(i,j) = al(i+1,j) - q(i,j)
!             if ( abs(dm(i-1,j))+abs(dm(i,j))+abs(dm(i+1,j)) < near_zero ) then
!                bl(i,j) = 0.
!                br(i,j) = 0.
!             elseif( abs(3.*(bl(i,j)+br(i,j))) > abs(bl(i,j)-br(i,j)) ) then
!                pmp_1 = -(dq(i,j) + dq(i,j))
!                lac_1 = pmp_1 + 1.5*dq(i+1,j)
!                bl(i,j) = min( max(0., pmp_1, lac_1), max(bl(i,j), min(0., pmp_1, lac_1)) )
!                pmp_2 = dq(i-1,j) + dq(i-1,j)
!                lac_2 = pmp_2 - 1.5*dq(i-2,j)
!                br(i,j) = min( max(0., pmp_2, lac_2), max(br(i,j), min(0., pmp_2, lac_2)) )
!             endif
!          enddo
!       enddo
!    endif
!    ! Positive definite constraint:
!    if(iord==-9 .or. iord==-13) call pert_ppm(ie1-is1+1, q(is1,j), bl(is1,j), br(is1,j), 0)
!
!    if (.not. nested .and. grid_type<3) then
!       if ( is==1 ) then
!          do j=jfirst,jlast
!             bl_tmp(3*j) = s14*dm(-1,j) + s11*(q(-1,j)-q(0,j))
!
!             xt = 0.5*(((2.*dxa(0,j)+dxa(-1,j))*q(0,j)-dxa(0,j)*q(-1,j))/(dxa(-1,j)+dxa(0,j)) &
!                  +      ((2.*dxa(1,j)+dxa( 2,j))*q(1,j)-dxa(1,j)*q(2,j))/(dxa(1, j)+dxa(2,j)))
!             br_tmp(3*j) = xt - q(0,j)
!             bl_tmp(3*j+1) = xt - q(1,j)
!             xt = s15*q(1,j) + s11*q(2,j) - s14*dm(2,j)
!             br_tmp(3*j+1) = xt - q(1,j)
!             bl_tmp(3*j+2) = xt - q(2,j)
!             br_tmp(3*j+2) = al(3,j) - q(2,j)
!             q_tmp(j*3:j*3+2) = q(0:2,j)
!          enddo
!          call pert_ppm(3*(jlast-jfirst+1), q_tmp, bl_tmp, br_tmp, 1)
!          do j=jfirst,jlast
!             bl(0:2,j) = bl_tmp(j*3:j*3+2)
!             br(0:2,j) = br_tmp(j*3:j*3+2)
!          enddo
!      endif
!      if ( (ie+1)==npx ) then
!         do j=jfirst,jlast
!            bl_tmp(3*j) = al(npx-2,j) - q(npx-2,j)
!
!            xt = s15*q(npx-1,j) + s11*q(npx-2,j) + s14*dm(npx-2,j)
!            br_tmp(3*j) = xt - q(npx-2,j)
!            bl_tmp(3*j+1) = xt - q(npx-1,j)
!
!            xt = 0.5*(((2.*dxa(npx-1,j)+dxa(npx-2,j))*q(npx-1,j)-dxa(npx-1,j)*q(npx-2,j))/(dxa(npx-2,j)+dxa(npx-1,j)) &
!               +      ((2.*dxa(npx,  j)+dxa(npx+1,j))*q(npx,j  )-dxa(npx,  j)*q(npx+1,j))/(dxa(npx,  j)+dxa(npx+1,j)))
!            br_tmp(3*j+1) = xt - q(npx-1,j)
!            bl_tmp(3*j+2) = xt - q(npx,j  )
!
!            br_tmp(3*j+2) = s11*(q(npx+1,j)-q(npx,j)) - s14*dm(npx+1,j)
!            q_tmp(j*3:j*3+2) = q(npx-2:npx,j)
!         enddo
!         call pert_ppm(3*(jlast-jfirst+1), q_tmp, bl_tmp, br_tmp, 1)
!
!         do j=jfirst,jlast
!            bl(npx-2:npx,j) = bl_tmp(j*3:j*3+2)
!            br(npx-2:npx,j) = br_tmp(j*3:j*3+2)
!         enddo
!      endif
!    endif
!
!  endif
!
!  do j=jfirst,jlast
!!DEC$ VECTOR ALWAYS
!     do i=ifirst,ilast+1
!        if( c(i,j)>0. ) then
!           flux(i,j) = q(i-1,j) + (1.-c(i,j))*(br(i-1,j)-c(i,j)*(bl(i-1,j)+br(i-1,j)))
!        else
!           flux(i,j) = q(i,j  ) + (1.+c(i,j))*(bl(i,j  )+c(i,j)*(bl(i,j  )+br(i,j  )))
!        endif
!     enddo
!  enddo
!
! end subroutine xppm0
!#else
  SUBROUTINE XPPM0(flux, q, c, iord, ifirst, ilast, jfirst, jlast, npx, &
&   npy)
    IMPLICIT NONE
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: iord
    INTEGER, INTENT(IN) :: npx, npy
    REAL, INTENT(IN) :: q(ifirst-ng:ilast+ng, jfirst:jlast)
! Courant   N (like FLUX)
    REAL, INTENT(IN) :: c(ifirst:ilast+1, jfirst:jlast)
! !OUTPUT PARAMETERS:
!  Flux
    REAL, INTENT(OUT) :: flux(ifirst:ilast+1, jfirst:jlast)
! Local
    REAL, DIMENSION(ifirst-ng:ilast+ng) :: q1
    REAL, DIMENSION(ifirst-1:ilast+1) :: bl, br
    REAL :: al(ifirst-1:ilast+2)
    REAL :: dm(ifirst-2:ilast+2)
    REAL :: dq(ifirst-3:ilast+2)
    LOGICAL :: extm(ifirst-2:ilast+2)
    INTEGER :: i, j, ie3, is1, ie1
    REAL :: xt, pmp_1, lac_1, pmp_2, lac_2
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTEGER :: abs0
    IF (.NOT.nested .AND. grid_type .LT. 3) THEN
      IF (3 .LT. is - 1) THEN
        is1 = is - 1
      ELSE
        is1 = 3
      END IF
      IF (npx - 2 .GT. ie + 2) THEN
        ie3 = ie + 2
      ELSE
        ie3 = npx - 2
      END IF
      IF (npx - 3 .GT. ie + 1) THEN
        ie1 = ie + 1
      ELSE
        ie1 = npx - 3
      END IF
    ELSE
      is1 = is - 1
      ie3 = ie + 2
      ie1 = ie + 1
    END IF
    DO j=jfirst,jlast
      DO i=ifirst-ng,ilast+ng
        q1(i) = q(i, j)
      END DO
      IF (iord .GE. 0.) THEN
        abs0 = iord
      ELSE
        abs0 = -iord
      END IF
      IF (abs0 .LT. 8) THEN
! ord = -5: linear scheme based on PPM 4th order interpolation
! ord = -6: linear PPM with 2-delta filter
! ord = -7: (-6) with additional Positive definite constraint:
        DO i=is1,ie3
          al(i) = p1*(q1(i-1)+q1(i)) + p2*(q1(i-2)+q1(i+1))
        END DO
        IF (.NOT.nested .AND. grid_type .LT. 3) THEN
          IF (is .EQ. 1) THEN
            al(0) = c1*q1(-2) + c2*q1(-1) + c3*q1(0)
            al(1) = 0.5*(((2.*dxa(0, j)+dxa(-1, j))*q1(0)-dxa(0, j)*q1(-&
&             1))/(dxa(-1, j)+dxa(0, j))+((2.*dxa(1, j)+dxa(2, j))*q1(1)&
&             -dxa(1, j)*q1(2))/(dxa(1, j)+dxa(2, j)))
            al(2) = c3*q1(1) + c2*q1(2) + c1*q1(3)
          END IF
          IF (ie + 1 .EQ. npx) THEN
            al(npx-1) = c1*q1(npx-3) + c2*q1(npx-2) + c3*q1(npx-1)
            al(npx) = 0.5*(((2.*dxa(npx-1, j)+dxa(npx-2, j))*q1(npx-1)-&
&             dxa(npx-1, j)*q1(npx-2))/(dxa(npx-2, j)+dxa(npx-1, j))+((&
&             2.*dxa(npx, j)+dxa(npx+1, j))*q1(npx)-dxa(npx, j)*q1(npx+1&
&             ))/(dxa(npx, j)+dxa(npx+1, j)))
            al(npx+1) = c3*q1(npx) + c2*q1(npx+1) + c1*q1(npx+2)
          END IF
        END IF
        IF (iord .EQ. -5) THEN
          DO i=ifirst-1,ilast+1
            bl(i) = al(i) - q1(i)
            br(i) = al(i+1) - q1(i)
          END DO
        END IF
      END IF
      DO i=ifirst,ilast+1
        IF (c(i, j) .GT. 0.) THEN
          flux(i, j) = q1(i-1) + (1.-c(i, j))*(br(i-1)-c(i, j)*(bl(i-1)+&
&           br(i-1)))
        ELSE
          flux(i, j) = q1(i) + (1.+c(i, j))*(bl(i)+c(i, j)*(bl(i)+br(i))&
&           )
        END IF
      END DO
    END DO
  END SUBROUTINE XPPM0
!  Differentiation of yppm0 in reverse (adjoint) mode:
!   gradient     of useful results: q flux
!   with respect to varying inputs: q
!#endif
  SUBROUTINE YPPM0_ADM(flux, flux_ad, q, q_ad, c, jord, ifirst, ilast, &
&   jfirst, jlast, npx, npy)
    IMPLICIT NONE
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: jord
    INTEGER, INTENT(IN) :: npx, npy
    REAL, INTENT(IN) :: q(ifirst:ilast, jfirst-ng:jlast+ng)
    REAL :: q_ad(ifirst:ilast, jfirst-ng:jlast+ng)
! Courant number
    REAL, INTENT(IN) :: c(isd:ied, js:je+1)
!  Flux
    REAL :: flux(ifirst:ilast, jfirst:jlast+1)
    REAL :: flux_ad(ifirst:ilast, jfirst:jlast+1)
! Local:
    REAL :: dm(ifirst:ilast, jfirst-2:jlast+2)
    REAL :: al(ifirst:ilast, jfirst-1:jlast+2)
    REAL :: al_ad(ifirst:ilast, jfirst-1:jlast+2)
    REAL :: bl(ifirst:ilast, jfirst-1:jlast+1)
    REAL :: bl_ad(ifirst:ilast, jfirst-1:jlast+1)
    REAL :: br(ifirst:ilast, jfirst-1:jlast+1)
    REAL :: br_ad(ifirst:ilast, jfirst-1:jlast+1)
    REAL :: dq(ifirst:ilast, jfirst-3:jlast+2)
    LOGICAL :: extm(ifirst:ilast, jfirst-2:jlast+2)
    REAL :: xt, pmp_1, lac_1, pmp_2, lac_2
    INTEGER :: i, j, js1, je3, je1
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTEGER :: abs0
    REAL*8 :: temp_ad
    REAL*8 :: temp_ad0
    REAL*8 :: temp_ad1
    REAL*8 :: temp_ad2
    REAL :: temp_ad3
    REAL :: temp_ad4
    REAL :: temp_ad5
    REAL :: temp_ad6
    INTEGER :: branch
    IF (.NOT.nested .AND. grid_type .LT. 3) THEN
      IF (3 .LT. js - 1) THEN
        js1 = js - 1
      ELSE
        js1 = 3
      END IF
      IF (npy - 2 .GT. je + 2) THEN
        CALL PUSHCONTROL1B(1)
        je3 = je + 2
      ELSE
        CALL PUSHCONTROL1B(1)
        je3 = npy - 2
      END IF
    ELSE
      CALL PUSHCONTROL1B(0)
! Nested grid OR Doubly periodic domain:
      js1 = js - 1
      je3 = je + 2
    END IF
    IF (jord .GE. 0.) THEN
      abs0 = jord
    ELSE
      abs0 = -jord
    END IF
    IF (abs0 .LT. 8) THEN
      IF (.NOT.nested .AND. grid_type .LT. 3) THEN
        IF (js .EQ. 1) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (je + 1 .EQ. npy) THEN
          CALL PUSHCONTROL2B(0)
        ELSE
          CALL PUSHCONTROL2B(1)
        END IF
      ELSE
        CALL PUSHCONTROL2B(2)
      END IF
      IF (jord .EQ. -5) THEN
        CALL PUSHCONTROL2B(2)
      ELSE
        CALL PUSHCONTROL2B(1)
      END IF
    ELSE
      CALL PUSHCONTROL2B(0)
    END IF
    DO j=jfirst,jlast+1
      DO i=ifirst,ilast
        IF (c(i, j) .GT. 0.) THEN
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
    END DO
    bl_ad = 0.0
    br_ad = 0.0
    DO j=jlast+1,jfirst,-1
      DO i=ilast,ifirst,-1
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          temp_ad5 = (c(i, j)+1.)*flux_ad(i, j)
          temp_ad6 = c(i, j)*temp_ad5
          q_ad(i, j) = q_ad(i, j) + flux_ad(i, j)
          bl_ad(i, j) = bl_ad(i, j) + temp_ad6 + temp_ad5
          br_ad(i, j) = br_ad(i, j) + temp_ad6
          flux_ad(i, j) = 0.0
        ELSE
          temp_ad3 = (1.-c(i, j))*flux_ad(i, j)
          temp_ad4 = -(c(i, j)*temp_ad3)
          q_ad(i, j-1) = q_ad(i, j-1) + flux_ad(i, j)
          br_ad(i, j-1) = br_ad(i, j-1) + temp_ad4 + temp_ad3
          bl_ad(i, j-1) = bl_ad(i, j-1) + temp_ad4
          flux_ad(i, j) = 0.0
        END IF
      END DO
    END DO
    CALL POPCONTROL2B(branch)
    IF (branch .NE. 0) THEN
      IF (branch .EQ. 1) THEN
        al_ad = 0.0
      ELSE
        al_ad = 0.0
        DO j=jlast+1,jfirst-1,-1
          DO i=ilast,ifirst,-1
            al_ad(i, j+1) = al_ad(i, j+1) + br_ad(i, j)
            q_ad(i, j) = q_ad(i, j) - bl_ad(i, j) - br_ad(i, j)
            br_ad(i, j) = 0.0
            al_ad(i, j) = al_ad(i, j) + bl_ad(i, j)
            bl_ad(i, j) = 0.0
          END DO
        END DO
      END IF
      CALL POPCONTROL2B(branch)
      IF (branch .EQ. 0) THEN
        DO i=ilast,ifirst,-1
          q_ad(i, npy) = q_ad(i, npy) + c3*al_ad(i, npy+1)
          q_ad(i, npy+1) = q_ad(i, npy+1) + c2*al_ad(i, npy+1)
          q_ad(i, npy+2) = q_ad(i, npy+2) + c1*al_ad(i, npy+1)
          al_ad(i, npy+1) = 0.0
          temp_ad1 = 0.5*al_ad(i, npy)/(dya(i, npy-2)+dya(i, npy-1))
          temp_ad2 = 0.5*al_ad(i, npy)/(dya(i, npy)+dya(i, npy+1))
          q_ad(i, npy-1) = q_ad(i, npy-1) + (dya(i, npy-1)*2.+dya(i, npy&
&           -2))*temp_ad1
          q_ad(i, npy-2) = q_ad(i, npy-2) - dya(i, npy-1)*temp_ad1
          q_ad(i, npy) = q_ad(i, npy) + (dya(i, npy)*2.+dya(i, npy+1))*&
&           temp_ad2
          q_ad(i, npy+1) = q_ad(i, npy+1) - dya(i, npy)*temp_ad2
          al_ad(i, npy) = 0.0
          q_ad(i, npy-3) = q_ad(i, npy-3) + c1*al_ad(i, npy-1)
          q_ad(i, npy-2) = q_ad(i, npy-2) + c2*al_ad(i, npy-1)
          q_ad(i, npy-1) = q_ad(i, npy-1) + c3*al_ad(i, npy-1)
          al_ad(i, npy-1) = 0.0
        END DO
      ELSE IF (branch .NE. 1) THEN
        GOTO 100
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO i=ilast,ifirst,-1
          q_ad(i, 1) = q_ad(i, 1) + c3*al_ad(i, 2)
          q_ad(i, 2) = q_ad(i, 2) + c2*al_ad(i, 2)
          q_ad(i, 3) = q_ad(i, 3) + c1*al_ad(i, 2)
          al_ad(i, 2) = 0.0
          temp_ad = 0.5*al_ad(i, 1)/(dya(i, -1)+dya(i, 0))
          temp_ad0 = 0.5*al_ad(i, 1)/(dya(i, 1)+dya(i, 2))
          q_ad(i, 0) = q_ad(i, 0) + (dya(i, 0)*2.+dya(i, -1))*temp_ad
          q_ad(i, -1) = q_ad(i, -1) - dya(i, 0)*temp_ad
          q_ad(i, 1) = q_ad(i, 1) + (dya(i, 1)*2.+dya(i, 2))*temp_ad0
          q_ad(i, 2) = q_ad(i, 2) - dya(i, 1)*temp_ad0
          al_ad(i, 1) = 0.0
          q_ad(i, -2) = q_ad(i, -2) + c1*al_ad(i, 0)
          q_ad(i, -1) = q_ad(i, -1) + c2*al_ad(i, 0)
          q_ad(i, 0) = q_ad(i, 0) + c3*al_ad(i, 0)
          al_ad(i, 0) = 0.0
        END DO
      END IF
 100  DO j=je3,js1,-1
        DO i=ilast,ifirst,-1
          q_ad(i, j-1) = q_ad(i, j-1) + p1*al_ad(i, j)
          q_ad(i, j) = q_ad(i, j) + p1*al_ad(i, j)
          q_ad(i, j-2) = q_ad(i, j-2) + p2*al_ad(i, j)
          q_ad(i, j+1) = q_ad(i, j+1) + p2*al_ad(i, j)
          al_ad(i, j) = 0.0
        END DO
      END DO
    END IF
    CALL POPCONTROL1B(branch)
  END SUBROUTINE YPPM0_ADM
!#endif
  SUBROUTINE YPPM0(flux, q, c, jord, ifirst, ilast, jfirst, jlast, npx, &
&   npy)
    IMPLICIT NONE
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: jord
    INTEGER, INTENT(IN) :: npx, npy
    REAL, INTENT(IN) :: q(ifirst:ilast, jfirst-ng:jlast+ng)
! Courant number
    REAL, INTENT(IN) :: c(isd:ied, js:je+1)
!  Flux
    REAL, INTENT(OUT) :: flux(ifirst:ilast, jfirst:jlast+1)
! Local:
    REAL :: dm(ifirst:ilast, jfirst-2:jlast+2)
    REAL :: al(ifirst:ilast, jfirst-1:jlast+2)
    REAL :: bl(ifirst:ilast, jfirst-1:jlast+1)
    REAL :: br(ifirst:ilast, jfirst-1:jlast+1)
    REAL :: dq(ifirst:ilast, jfirst-3:jlast+2)
    LOGICAL :: extm(ifirst:ilast, jfirst-2:jlast+2)
    REAL :: xt, pmp_1, lac_1, pmp_2, lac_2
    INTEGER :: i, j, js1, je3, je1
    INTRINSIC MAX
    INTRINSIC MIN
    INTRINSIC ABS
    INTEGER :: abs0
    IF (.NOT.nested .AND. grid_type .LT. 3) THEN
      IF (3 .LT. js - 1) THEN
        js1 = js - 1
      ELSE
        js1 = 3
      END IF
      IF (npy - 2 .GT. je + 2) THEN
        je3 = je + 2
      ELSE
        je3 = npy - 2
      END IF
      IF (npy - 3 .GT. je + 1) THEN
        je1 = je + 1
      ELSE
        je1 = npy - 3
      END IF
    ELSE
! Nested grid OR Doubly periodic domain:
      js1 = js - 1
      je3 = je + 2
      je1 = je + 1
    END IF
    IF (jord .GE. 0.) THEN
      abs0 = jord
    ELSE
      abs0 = -jord
    END IF
    IF (abs0 .LT. 8) THEN
! ord = -5: linear scheme based on PPM 4th order interpolation
! ord = -6: linear PPM with 2-delta filter
! ord = -7: (-6) with additional Positive definite constraint:
      DO j=js1,je3
        DO i=ifirst,ilast
          al(i, j) = p1*(q(i, j-1)+q(i, j)) + p2*(q(i, j-2)+q(i, j+1))
        END DO
      END DO
      IF (.NOT.nested .AND. grid_type .LT. 3) THEN
        IF (js .EQ. 1) THEN
          DO i=ifirst,ilast
            al(i, 0) = c1*q(i, -2) + c2*q(i, -1) + c3*q(i, 0)
            al(i, 1) = 0.5*(((2.*dya(i, 0)+dya(i, -1))*q(i, 0)-dya(i, 0)&
&             *q(i, -1))/(dya(i, -1)+dya(i, 0))+((2.*dya(i, 1)+dya(i, 2)&
&             )*q(i, 1)-dya(i, 1)*q(i, 2))/(dya(i, 1)+dya(i, 2)))
            al(i, 2) = c3*q(i, 1) + c2*q(i, 2) + c1*q(i, 3)
          END DO
        END IF
        IF (je + 1 .EQ. npy) THEN
          DO i=ifirst,ilast
            al(i, npy-1) = c1*q(i, npy-3) + c2*q(i, npy-2) + c3*q(i, npy&
&             -1)
            al(i, npy) = 0.5*(((2.*dya(i, npy-1)+dya(i, npy-2))*q(i, npy&
&             -1)-dya(i, npy-1)*q(i, npy-2))/(dya(i, npy-2)+dya(i, npy-1&
&             ))+((2.*dya(i, npy)+dya(i, npy+1))*q(i, npy)-dya(i, npy)*q&
&             (i, npy+1))/(dya(i, npy)+dya(i, npy+1)))
            al(i, npy+1) = c3*q(i, npy) + c2*q(i, npy+1) + c1*q(i, npy+2&
&             )
          END DO
        END IF
      END IF
      IF (jord .EQ. -5) THEN
        DO j=jfirst-1,jlast+1
          DO i=ifirst,ilast
            bl(i, j) = al(i, j) - q(i, j)
            br(i, j) = al(i, j+1) - q(i, j)
          END DO
        END DO
      END IF
    END IF
    DO j=jfirst,jlast+1
      DO i=ifirst,ilast
        IF (c(i, j) .GT. 0.) THEN
          flux(i, j) = q(i, j-1) + (1.-c(i, j))*(br(i, j-1)-c(i, j)*(bl(&
&           i, j-1)+br(i, j-1)))
        ELSE
          flux(i, j) = q(i, j) + (1.+c(i, j))*(bl(i, j)+c(i, j)*(bl(i, j&
&           )+br(i, j)))
        END IF
      END DO
    END DO
  END SUBROUTINE YPPM0
!  Differentiation of fxppm in reverse (adjoint) mode:
!   gradient     of useful results: q flux
!   with respect to varying inputs: q
  SUBROUTINE FXPPM_ADM(c, q, q_ad, flux, flux_ad, iord, ifirst, ilast, &
&   jfirst, jlast, npx, npy)
    IMPLICIT NONE
! !INPUT PARAMETERS:
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: iord
    INTEGER, INTENT(IN) :: npx, npy
    REAL(fvprc), INTENT(IN) :: q(ifirst-ng:ilast+ng, jfirst:jlast)
    REAL(fvprc) :: q_ad(ifirst-ng:ilast+ng, jfirst:jlast)
! Courant   N (like FLUX)
    REAL(fvprc), INTENT(IN) :: c(ifirst:ilast+1, jfirst:jlast)
! !OUTPUT PARAMETERS:
!  Flux
    REAL(fvprc) :: flux(ifirst:ilast+1, jfirst:jlast)
    REAL(fvprc) :: flux_ad(ifirst:ilast+1, jfirst:jlast)
! Local
    LOGICAL :: extm(ifirst-2:ilast+2)
    REAL(fvprc) :: dm1(ifirst-2:ilast+2)
    REAL(fvprc) :: al(ifirst-1:ilast+2)
    REAL(fvprc) :: bl(ifirst-1:ilast+1)
    REAL(fvprc) :: bl_ad(ifirst-1:ilast+1)
    REAL(fvprc) :: br(ifirst-1:ilast+1)
    REAL(fvprc) :: br_ad(ifirst-1:ilast+1)
    REAL(fvprc) :: dq(ifirst-3:ilast+2)
    REAL(fvprc) :: dl, dr, pmp, lac, ct, qe
    REAL(fvprc) :: pmp_1, lac_1, pmp_2, lac_2
    REAL(fvprc) :: xt, x1, x0, x0l, x0r
    REAL(fvprc) :: xt_ad, x0l_ad, x0r_ad
    INTEGER :: i, j, is3, ie3, it
    INTRINSIC MAX
    INTRINSIC MIN
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp_ad4
    REAL(fvprc) :: temp_ad5
    REAL(fvprc) :: temp_ad6
    INTEGER :: branch
    IF (3 .LT. is - 1) THEN
      is3 = is - 1
    ELSE
      is3 = 3
    END IF
    IF (npx - 3 .GT. ie + 1) THEN
      ie3 = ie + 1
    ELSE
      ie3 = npx - 3
    END IF
    IF (iord .EQ. 666) THEN
!From NCEP dynamics version
      DO j=jfirst,jlast
!--------------
! fix the edges
!--------------
        IF (is .EQ. 1) THEN
          CALL PUSHCONTROL1B(0)
        ELSE
          CALL PUSHCONTROL1B(1)
        END IF
        IF (ie + 1 .EQ. npx) THEN
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
        DO i=ifirst,ilast+1
          IF (c(i, j) .GT. 0.) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      bl_ad = 0.0_8
      br_ad = 0.0_8
      DO j=jlast,jfirst,-1
        DO i=ilast+1,ifirst,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            temp_ad5 = (c(i, j)+1.)*flux_ad(i, j)
            temp_ad6 = c(i, j)*temp_ad5
            q_ad(i, j) = q_ad(i, j) + flux_ad(i, j)
            bl_ad(i) = bl_ad(i) + temp_ad6 + temp_ad5
            br_ad(i) = br_ad(i) + temp_ad6
            flux_ad(i, j) = 0.0_8
          ELSE
            temp_ad3 = (1.-c(i, j))*flux_ad(i, j)
            temp_ad4 = -(c(i, j)*temp_ad3)
            q_ad(i-1, j) = q_ad(i-1, j) + flux_ad(i, j)
            br_ad(i-1) = br_ad(i-1) + temp_ad4 + temp_ad3
            bl_ad(i-1) = bl_ad(i-1) + temp_ad4
            flux_ad(i, j) = 0.0_8
          END IF
        END DO
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          xt_ad = br_ad(npx-2) + bl_ad(npx-1)
          q_ad(npx-1, j) = q_ad(npx-1, j) - bl_ad(npx-1)
          bl_ad(npx-1) = 0.0_8
          q_ad(npx-2, j) = q_ad(npx-2, j) - br_ad(npx-2)
          br_ad(npx-2) = 0.0_8
          q_ad(npx-3, j) = q_ad(npx-3, j) + c1*xt_ad
          q_ad(npx-2, j) = q_ad(npx-2, j) + c2*xt_ad
          q_ad(npx-1, j) = q_ad(npx-1, j) + c3*xt_ad
          xt_ad = br_ad(npx)
          q_ad(npx, j) = q_ad(npx, j) + c3*xt_ad - br_ad(npx)
          br_ad(npx) = 0.0_8
          q_ad(npx+1, j) = q_ad(npx+1, j) + c2*xt_ad
          q_ad(npx+2, j) = q_ad(npx+2, j) + c1*xt_ad
          xt_ad = br_ad(npx-1) + bl_ad(npx)
          q_ad(npx, j) = q_ad(npx, j) - bl_ad(npx)
          bl_ad(npx) = 0.0_8
          q_ad(npx-1, j) = q_ad(npx-1, j) - br_ad(npx-1)
          br_ad(npx-1) = 0.0_8
          x0l_ad = xt_ad
          x0r_ad = xt_ad
          q_ad(npx-2, j) = q_ad(npx-2, j) + (p1-1.0)*bl_ad(npx-2)
          q_ad(npx-3, j) = q_ad(npx-3, j) + p1*bl_ad(npx-2)
          q_ad(npx-4, j) = q_ad(npx-4, j) + p2*bl_ad(npx-2)
          q_ad(npx-1, j) = q_ad(npx-1, j) + p2*bl_ad(npx-2)
          bl_ad(npx-2) = 0.0_8
          temp_ad1 = 0.5*x0r_ad/(dxa(npx, j)+dxa(npx+1, j))
          q_ad(npx, j) = q_ad(npx, j) + (dxa(npx, j)*2.+dxa(npx+1, j))*&
&           temp_ad1
          q_ad(npx+1, j) = q_ad(npx+1, j) - dxa(npx, j)*temp_ad1
          temp_ad2 = 0.5*x0l_ad/(dxa(npx-1, j)+dxa(npx-2, j))
          q_ad(npx-1, j) = q_ad(npx-1, j) + (dxa(npx-1, j)*2.+dxa(npx-2&
&           , j))*temp_ad2
          q_ad(npx-2, j) = q_ad(npx-2, j) - dxa(npx-1, j)*temp_ad2
        END IF
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          xt_ad = br_ad(1) + bl_ad(2)
          q_ad(2, j) = q_ad(2, j) - bl_ad(2)
          bl_ad(2) = 0.0_8
          q_ad(1, j) = q_ad(1, j) + c3*xt_ad - br_ad(1)
          br_ad(1) = 0.0_8
          q_ad(2, j) = q_ad(2, j) + c2*xt_ad
          q_ad(3, j) = q_ad(3, j) + c1*xt_ad
          xt_ad = bl_ad(0)
          q_ad(0, j) = q_ad(0, j) - bl_ad(0)
          bl_ad(0) = 0.0_8
          q_ad(-2, j) = q_ad(-2, j) + c1*xt_ad
          q_ad(-1, j) = q_ad(-1, j) + c2*xt_ad
          q_ad(0, j) = q_ad(0, j) + c3*xt_ad - br_ad(0)
          xt_ad = bl_ad(1) + br_ad(0)
          br_ad(0) = 0.0_8
          q_ad(1, j) = q_ad(1, j) - bl_ad(1)
          bl_ad(1) = 0.0_8
          x0l_ad = xt_ad
          x0r_ad = xt_ad
          q_ad(2, j) = q_ad(2, j) + (p1-1.0)*br_ad(2)
          q_ad(3, j) = q_ad(3, j) + p1*br_ad(2)
          q_ad(1, j) = q_ad(1, j) + p2*br_ad(2)
          q_ad(4, j) = q_ad(4, j) + p2*br_ad(2)
          br_ad(2) = 0.0_8
          temp_ad = 0.5*x0r_ad/(dxa(1, j)+dxa(2, j))
          q_ad(1, j) = q_ad(1, j) + (dxa(1, j)*2.+dxa(2, j))*temp_ad
          q_ad(2, j) = q_ad(2, j) - dxa(1, j)*temp_ad
          temp_ad0 = 0.5*x0l_ad/(dxa(0, j)+dxa(-1, j))
          q_ad(0, j) = q_ad(0, j) + (dxa(0, j)*2.+dxa(-1, j))*temp_ad0
          q_ad(-1, j) = q_ad(-1, j) - dxa(0, j)*temp_ad0
        END IF
        DO i=ie3,is3,-1
          q_ad(i-2, j) = q_ad(i-2, j) + b1*br_ad(i)
          q_ad(i-1, j) = q_ad(i-1, j) + b2*br_ad(i)
          q_ad(i, j) = q_ad(i, j) + b3*br_ad(i)
          q_ad(i+1, j) = q_ad(i+1, j) + b4*br_ad(i)
          q_ad(i+2, j) = q_ad(i+2, j) + b5*br_ad(i)
          br_ad(i) = 0.0_8
          q_ad(i-2, j) = q_ad(i-2, j) + b5*bl_ad(i)
          q_ad(i-1, j) = q_ad(i-1, j) + b4*bl_ad(i)
          q_ad(i, j) = q_ad(i, j) + b3*bl_ad(i)
          q_ad(i+1, j) = q_ad(i+1, j) + b2*bl_ad(i)
          q_ad(i+2, j) = q_ad(i+2, j) + b1*bl_ad(i)
          bl_ad(i) = 0.0_8
        END DO
      END DO
    END IF
  END SUBROUTINE FXPPM_ADM
  SUBROUTINE FXPPM(c, q, flux, iord, ifirst, ilast, jfirst, jlast, npx, &
&   npy)
    IMPLICIT NONE
! !INPUT PARAMETERS:
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: iord
    INTEGER, INTENT(IN) :: npx, npy
    REAL(fvprc), INTENT(IN) :: q(ifirst-ng:ilast+ng, jfirst:jlast)
! Courant   N (like FLUX)
    REAL(fvprc), INTENT(IN) :: c(ifirst:ilast+1, jfirst:jlast)
! !OUTPUT PARAMETERS:
!  Flux
    REAL(fvprc), INTENT(OUT) :: flux(ifirst:ilast+1, jfirst:jlast)
! Local
    LOGICAL :: extm(ifirst-2:ilast+2)
    REAL(fvprc) :: dm1(ifirst-2:ilast+2)
    REAL(fvprc) :: al(ifirst-1:ilast+2)
    REAL(fvprc) :: bl(ifirst-1:ilast+1)
    REAL(fvprc) :: br(ifirst-1:ilast+1)
    REAL(fvprc) :: dq(ifirst-3:ilast+2)
    REAL(fvprc) :: dl, dr, pmp, lac, ct, qe
    REAL(fvprc) :: pmp_1, lac_1, pmp_2, lac_2
    REAL(fvprc) :: xt, x1, x0, x0l, x0r
    INTEGER :: i, j, is3, ie3, it
    INTRINSIC MAX
    INTRINSIC MIN
    x0 = big_number
    IF (3 .LT. is - 1) THEN
      is3 = is - 1
    ELSE
      is3 = 3
    END IF
    IF (npx - 3 .GT. ie + 1) THEN
      ie3 = ie + 1
    ELSE
      ie3 = npx - 3
    END IF
    IF (iord .EQ. 666) THEN
!From NCEP dynamics version
      DO j=jfirst,jlast
        DO i=is3,ie3
          bl(i) = b5*q(i-2, j) + b4*q(i-1, j) + b3*q(i, j) + b2*q(i+1, j&
&           ) + b1*q(i+2, j)
          br(i) = b1*q(i-2, j) + b2*q(i-1, j) + b3*q(i, j) + b4*q(i+1, j&
&           ) + b5*q(i+2, j)
        END DO
!--------------
! fix the edges
!--------------
        IF (is .EQ. 1) THEN
          x0l = 0.5*((2.*dxa(0, j)+dxa(-1, j))*q(0, j)-dxa(0, j)*q(-1, j&
&           ))/(dxa(0, j)+dxa(-1, j))
          x0r = 0.5*((2.*dxa(1, j)+dxa(2, j))*q(1, j)-dxa(1, j)*q(2, j))&
&           /(dxa(1, j)+dxa(2, j))
          br(2) = p1*(q(2, j)+q(3, j)) + p2*(q(1, j)+q(4, j)) - q(2, j)
          xt = x0l + x0r
          bl(1) = xt - q(1, j)
          br(0) = xt - q(0, j)
          xt = c1*q(-2, j) + c2*q(-1, j) + c3*q(0, j)
          bl(0) = xt - q(0, j)
          xt = c3*q(1, j) + c2*q(2, j) + c1*q(3, j)
          br(1) = xt - q(1, j)
          bl(2) = xt - q(2, j)
        END IF
        IF (ie + 1 .EQ. npx) THEN
          x0l = 0.5*((2.*dxa(npx-1, j)+dxa(npx-2, j))*q(npx-1, j)-dxa(&
&           npx-1, j)*q(npx-2, j))/(dxa(npx-1, j)+dxa(npx-2, j))
          x0r = 0.5*((2.*dxa(npx, j)+dxa(npx+1, j))*q(npx, j)-dxa(npx, j&
&           )*q(npx+1, j))/(dxa(npx, j)+dxa(npx+1, j))
          bl(npx-2) = p1*(q(npx-2, j)+q(npx-3, j)) + p2*(q(npx-4, j)+q(&
&           npx-1, j)) - q(npx-2, j)
!             xt = x0L*sin_sg(npx-1,j,3) + x0R*sin_sg(npx,j,1)
!             xt = 2.*xt / (sin_sg(npx,j,1) + sin_sg(npx-1,j,3))
          xt = x0l + x0r
          br(npx-1) = xt - q(npx-1, j)
          bl(npx) = xt - q(npx, j)
          xt = c3*q(npx, j) + c2*q(npx+1, j) + c1*q(npx+2, j)
          br(npx) = xt - q(npx, j)
          xt = c1*q(npx-3, j) + c2*q(npx-2, j) + c3*q(npx-1, j)
          br(npx-2) = xt - q(npx-2, j)
          bl(npx-1) = xt - q(npx-1, j)
        END IF
        DO i=ifirst,ilast+1
          IF (c(i, j) .GT. 0.) THEN
            flux(i, j) = q(i-1, j) + (1.-c(i, j))*(br(i-1)-c(i, j)*(bl(i&
&             -1)+br(i-1)))
          ELSE
            flux(i, j) = q(i, j) + (1.+c(i, j))*(bl(i)+c(i, j)*(bl(i)+br&
&             (i)))
          END IF
        END DO
      END DO
    END IF
  END SUBROUTINE FXPPM
!  Differentiation of fyppm in reverse (adjoint) mode:
!   gradient     of useful results: q flux
!   with respect to varying inputs: q
  SUBROUTINE FYPPM_ADM(c, q, q_ad, flux, flux_ad, jord, ifirst, ilast, &
&   jfirst, jlast, npx, npy)
    IMPLICIT NONE
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: jord
    INTEGER, INTENT(IN) :: npx, npy
    REAL(fvprc), INTENT(IN) :: q(ifirst:ilast, jfirst-ng:jlast+ng)
    REAL(fvprc) :: q_ad(ifirst:ilast, jfirst-ng:jlast+ng)
! Courant number
    REAL(fvprc), INTENT(IN) :: c(isd:ied, js:je+1)
!  Flux
    REAL(fvprc) :: flux(ifirst:ilast, jfirst:jlast+1)
    REAL(fvprc) :: flux_ad(ifirst:ilast, jfirst:jlast+1)
! real(FVPRC)   , INTENT(OUT)::   dm(ifirst:ilast,jfirst-2:jlast+2)
! Local:
    LOGICAL :: extm(ifirst:ilast, jfirst-2:jlast+2)
    REAL(fvprc) :: al(ifirst:ilast, jfirst-1:jlast+2)
    REAL(fvprc) :: bl(ifirst:ilast, jfirst-1:jlast+1)
    REAL(fvprc) :: bl_ad(ifirst:ilast, jfirst-1:jlast+1)
    REAL(fvprc) :: br(ifirst:ilast, jfirst-1:jlast+1)
    REAL(fvprc) :: br_ad(ifirst:ilast, jfirst-1:jlast+1)
    REAL(fvprc) :: dq(ifirst:ilast, jfirst-3:jlast+2)
    REAL(fvprc) :: dl, dr, pmp, lac, ct, qe
    REAL(fvprc) :: pmp_1, lac_1, pmp_2, lac_2
    REAL(fvprc) :: xt, x0, x1, x0l, x0r
    REAL(fvprc) :: xt_ad, x0l_ad, x0r_ad
    INTEGER :: i, j, js3, je3, jt
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: min1
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    REAL(fvprc) :: temp_ad4
    REAL(fvprc) :: temp_ad5
    REAL(fvprc) :: temp_ad6
    INTEGER :: branch
    IF (jord .EQ. 666) THEN
      IF (3 .LT. js - 1) THEN
        max1 = js - 1
      ELSE
        max1 = 3
      END IF
      IF (npy - 3 .GT. je + 1) THEN
        min1 = je + 1
      ELSE
        min1 = npy - 3
      END IF
      IF (js .EQ. 1) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (je + 1 .EQ. npy) THEN
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      DO j=jfirst,jlast+1
        DO i=ifirst,ilast
          IF (c(i, j) .GT. 0.) THEN
            CALL PUSHCONTROL1B(1)
          ELSE
            CALL PUSHCONTROL1B(0)
          END IF
        END DO
      END DO
      bl_ad = 0.0_8
      br_ad = 0.0_8
      DO j=jlast+1,jfirst,-1
        DO i=ilast,ifirst,-1
          CALL POPCONTROL1B(branch)
          IF (branch .EQ. 0) THEN
            temp_ad5 = (c(i, j)+1.)*flux_ad(i, j)
            temp_ad6 = c(i, j)*temp_ad5
            q_ad(i, j) = q_ad(i, j) + flux_ad(i, j)
            bl_ad(i, j) = bl_ad(i, j) + temp_ad6 + temp_ad5
            br_ad(i, j) = br_ad(i, j) + temp_ad6
            flux_ad(i, j) = 0.0_8
          ELSE
            temp_ad3 = (1.-c(i, j))*flux_ad(i, j)
            temp_ad4 = -(c(i, j)*temp_ad3)
            q_ad(i, j-1) = q_ad(i, j-1) + flux_ad(i, j)
            br_ad(i, j-1) = br_ad(i, j-1) + temp_ad4 + temp_ad3
            bl_ad(i, j-1) = bl_ad(i, j-1) + temp_ad4
            flux_ad(i, j) = 0.0_8
          END IF
        END DO
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        DO i=ilast,ifirst,-1
          xt_ad = br_ad(i, npy-2) + bl_ad(i, npy-1)
          q_ad(i, npy-1) = q_ad(i, npy-1) - bl_ad(i, npy-1)
          bl_ad(i, npy-1) = 0.0_8
          q_ad(i, npy-2) = q_ad(i, npy-2) - br_ad(i, npy-2)
          br_ad(i, npy-2) = 0.0_8
          q_ad(i, npy-3) = q_ad(i, npy-3) + c1*xt_ad
          q_ad(i, npy-2) = q_ad(i, npy-2) + c2*xt_ad
          q_ad(i, npy-1) = q_ad(i, npy-1) + c3*xt_ad
          xt_ad = br_ad(i, npy)
          q_ad(i, npy) = q_ad(i, npy) + c3*xt_ad - br_ad(i, npy)
          br_ad(i, npy) = 0.0_8
          q_ad(i, npy+1) = q_ad(i, npy+1) + c2*xt_ad
          q_ad(i, npy+2) = q_ad(i, npy+2) + c1*xt_ad
          xt_ad = br_ad(i, npy-1) + bl_ad(i, npy)
          q_ad(i, npy) = q_ad(i, npy) - bl_ad(i, npy)
          bl_ad(i, npy) = 0.0_8
          q_ad(i, npy-1) = q_ad(i, npy-1) - br_ad(i, npy-1)
          br_ad(i, npy-1) = 0.0_8
          x0l_ad = xt_ad
          x0r_ad = xt_ad
          temp_ad1 = 0.5*x0r_ad/(dya(i, npy)+dya(i, npy+1))
          q_ad(i, npy) = q_ad(i, npy) + (dya(i, npy)*2.+dya(i, npy+1))*&
&           temp_ad1
          q_ad(i, npy+1) = q_ad(i, npy+1) - dya(i, npy)*temp_ad1
          temp_ad2 = 0.5*x0l_ad/(dya(i, npy-1)+dya(i, npy-2))
          q_ad(i, npy-1) = q_ad(i, npy-1) + (dya(i, npy-1)*2.+dya(i, npy&
&           -2))*temp_ad2
          q_ad(i, npy-2) = q_ad(i, npy-2) - dya(i, npy-1)*temp_ad2
          q_ad(i, npy-3) = q_ad(i, npy-3) + p1*bl_ad(i, npy-2)
          q_ad(i, npy-2) = q_ad(i, npy-2) + (p1-1.0)*bl_ad(i, npy-2)
          q_ad(i, npy-4) = q_ad(i, npy-4) + p2*bl_ad(i, npy-2)
          q_ad(i, npy-1) = q_ad(i, npy-1) + p2*bl_ad(i, npy-2)
          bl_ad(i, npy-2) = 0.0_8
        END DO
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO i=ilast,ifirst,-1
          xt_ad = br_ad(i, 1) + bl_ad(i, 2)
          q_ad(i, 2) = q_ad(i, 2) - bl_ad(i, 2)
          bl_ad(i, 2) = 0.0_8
          q_ad(i, 1) = q_ad(i, 1) + c3*xt_ad - br_ad(i, 1)
          br_ad(i, 1) = 0.0_8
          q_ad(i, 2) = q_ad(i, 2) + c2*xt_ad
          q_ad(i, 3) = q_ad(i, 3) + c1*xt_ad
          xt_ad = bl_ad(i, 0)
          q_ad(i, 0) = q_ad(i, 0) - bl_ad(i, 0)
          bl_ad(i, 0) = 0.0_8
          q_ad(i, -2) = q_ad(i, -2) + c1*xt_ad
          q_ad(i, -1) = q_ad(i, -1) + c2*xt_ad
          q_ad(i, 0) = q_ad(i, 0) + c3*xt_ad - br_ad(i, 0)
          xt_ad = bl_ad(i, 1) + br_ad(i, 0)
          br_ad(i, 0) = 0.0_8
          x0l_ad = xt_ad
          x0r_ad = xt_ad
          temp_ad = 0.5*x0r_ad/(dya(i, 1)+dya(i, 2))
          q_ad(i, 1) = q_ad(i, 1) + (dya(i, 1)*2.+dya(i, 2))*temp_ad - &
&           bl_ad(i, 1)
          bl_ad(i, 1) = 0.0_8
          q_ad(i, 2) = q_ad(i, 2) - dya(i, 1)*temp_ad
          temp_ad0 = 0.5*x0l_ad/(dya(i, 0)+dya(i, -1))
          q_ad(i, 0) = q_ad(i, 0) + (dya(i, 0)*2.+dya(i, -1))*temp_ad0
          q_ad(i, -1) = q_ad(i, -1) - dya(i, 0)*temp_ad0
          q_ad(i, 2) = q_ad(i, 2) + (p1-1.0)*br_ad(i, 2)
          q_ad(i, 3) = q_ad(i, 3) + p1*br_ad(i, 2)
          q_ad(i, 1) = q_ad(i, 1) + p2*br_ad(i, 2)
          q_ad(i, 4) = q_ad(i, 4) + p2*br_ad(i, 2)
          br_ad(i, 2) = 0.0_8
        END DO
      END IF
      DO j=min1,max1,-1
        DO i=ilast,ifirst,-1
          q_ad(i, j-2) = q_ad(i, j-2) + b1*br_ad(i, j)
          q_ad(i, j-1) = q_ad(i, j-1) + b2*br_ad(i, j)
          q_ad(i, j) = q_ad(i, j) + b3*br_ad(i, j)
          q_ad(i, j+1) = q_ad(i, j+1) + b4*br_ad(i, j)
          q_ad(i, j+2) = q_ad(i, j+2) + b5*br_ad(i, j)
          br_ad(i, j) = 0.0_8
          q_ad(i, j-2) = q_ad(i, j-2) + b5*bl_ad(i, j)
          q_ad(i, j-1) = q_ad(i, j-1) + b4*bl_ad(i, j)
          q_ad(i, j) = q_ad(i, j) + b3*bl_ad(i, j)
          q_ad(i, j+1) = q_ad(i, j+1) + b2*bl_ad(i, j)
          q_ad(i, j+2) = q_ad(i, j+2) + b1*bl_ad(i, j)
          bl_ad(i, j) = 0.0_8
        END DO
      END DO
    END IF
  END SUBROUTINE FYPPM_ADM
  SUBROUTINE FYPPM(c, q, flux, jord, ifirst, ilast, jfirst, jlast, npx, &
&   npy)
    IMPLICIT NONE
!  X-Dir strip
    INTEGER, INTENT(IN) :: ifirst, ilast
!  Y-Dir strip
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: jord
    INTEGER, INTENT(IN) :: npx, npy
    REAL(fvprc), INTENT(IN) :: q(ifirst:ilast, jfirst-ng:jlast+ng)
! Courant number
    REAL(fvprc), INTENT(IN) :: c(isd:ied, js:je+1)
!  Flux
    REAL(fvprc), INTENT(OUT) :: flux(ifirst:ilast, jfirst:jlast+1)
! real(FVPRC)   , INTENT(OUT)::   dm(ifirst:ilast,jfirst-2:jlast+2)
! Local:
    LOGICAL :: extm(ifirst:ilast, jfirst-2:jlast+2)
    REAL(fvprc) :: al(ifirst:ilast, jfirst-1:jlast+2)
    REAL(fvprc) :: bl(ifirst:ilast, jfirst-1:jlast+1)
    REAL(fvprc) :: br(ifirst:ilast, jfirst-1:jlast+1)
    REAL(fvprc) :: dq(ifirst:ilast, jfirst-3:jlast+2)
    REAL(fvprc) :: dl, dr, pmp, lac, ct, qe
    REAL(fvprc) :: pmp_1, lac_1, pmp_2, lac_2
    REAL(fvprc) :: xt, x0, x1, x0l, x0r
    INTEGER :: i, j, js3, je3, jt
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: min1
    IF (jord .EQ. 666) THEN
      IF (3 .LT. js - 1) THEN
        max1 = js - 1
      ELSE
        max1 = 3
      END IF
      IF (npy - 3 .GT. je + 1) THEN
        min1 = je + 1
      ELSE
        min1 = npy - 3
      END IF
      DO j=max1,min1
        DO i=ifirst,ilast
          bl(i, j) = b5*q(i, j-2) + b4*q(i, j-1) + b3*q(i, j) + b2*q(i, &
&           j+1) + b1*q(i, j+2)
          br(i, j) = b1*q(i, j-2) + b2*q(i, j-1) + b3*q(i, j) + b4*q(i, &
&           j+1) + b5*q(i, j+2)
        END DO
      END DO
      IF (js .EQ. 1) THEN
        DO i=ifirst,ilast
!           br(i,2) = al(i,3) - q(i,2)
          br(i, 2) = p1*(q(i, 2)+q(i, 3)) + p2*(q(i, 1)+q(i, 4)) - q(i, &
&           2)
          x0l = 0.5*((2.*dya(i, 0)+dya(i, -1))*q(i, 0)-dya(i, 0)*q(i, -1&
&           ))/(dya(i, 0)+dya(i, -1))
          x0r = 0.5*((2.*dya(i, 1)+dya(i, 2))*q(i, 1)-dya(i, 1)*q(i, 2))&
&           /(dya(i, 1)+dya(i, 2))
          xt = x0l + x0r
!            xt = ( x0L*sin_sg(i,0,4) + x0R*sin_sg(i,1,2) ) 
!            xt = 2.*xt / ( sin_sg(i,0,4) + sin_sg(i,1,2) )
          bl(i, 1) = xt - q(i, 1)
          br(i, 0) = xt - q(i, 0)
!           xt = s14*0.25*(q(i,0)-q(i,-2)) - s11*(q(i,0)-q(i,-1)) + q(i,0)
          xt = c1*q(i, -2) + c2*q(i, -1) + c3*q(i, 0)
          bl(i, 0) = xt - q(i, 0)
!           xt = s15*q(i,1) + s11*q(i,2) - s14*0.25*(q(i,3)-q(i,1))
          xt = c3*q(i, 1) + c2*q(i, 2) + c1*q(i, 3)
          br(i, 1) = xt - q(i, 1)
          bl(i, 2) = xt - q(i, 2)
        END DO
      END IF
      IF (je + 1 .EQ. npy) THEN
        DO i=ifirst,ilast
!           bl(i,npy-2) = al(i,npy-2) - q(i,npy-2)
          bl(i, npy-2) = p1*(q(i, npy-3)+q(i, npy-2)) + p2*(q(i, npy-4)+&
&           q(i, npy-1)) - q(i, npy-2)
          x0l = 0.5*((2.*dya(i, npy-1)+dya(i, npy-2))*q(i, npy-1)-dya(i&
&           , npy-1)*q(i, npy-2))/(dya(i, npy-1)+dya(i, npy-2))
          x0r = 0.5*((2.*dya(i, npy)+dya(i, npy+1))*q(i, npy)-dya(i, npy&
&           )*q(i, npy+1))/(dya(i, npy)+dya(i, npy+1))
          xt = x0l + x0r
!            xt = x0L*sin_sg(i,npy-1,4) + x0R*sin_sg(i,npy,2)
!            xt = 2.*xt /( sin_sg(i,npy-1,4) + sin_sg(i,npy,2) )
          br(i, npy-1) = xt - q(i, npy-1)
          bl(i, npy) = xt - q(i, npy)
!           xt = s11*(q(i,npy+1)-q(i,npy)) - s14*0.25*(q(i,npy+2)-q(i,npy)) + q(i,npy)
          xt = c3*q(i, npy) + c2*q(i, npy+1) + c1*q(i, npy+2)
          br(i, npy) = xt - q(i, npy)
!           xt = s15*q(i,npy-1) + s11*q(i,npy-2) + s14*0.25*(q(i,npy-1)-q(i,npy-3))
          xt = c1*q(i, npy-3) + c2*q(i, npy-2) + c3*q(i, npy-1)
          br(i, npy-2) = xt - q(i, npy-2)
          bl(i, npy-1) = xt - q(i, npy-1)
        END DO
      END IF
      DO j=jfirst,jlast+1
        DO i=ifirst,ilast
          IF (c(i, j) .GT. 0.) THEN
            flux(i, j) = q(i, j-1) + (1.-c(i, j))*(br(i, j-1)-c(i, j)*(&
&             bl(i, j-1)+br(i, j-1)))
          ELSE
            flux(i, j) = q(i, j) + (1.+c(i, j))*(bl(i, j)+c(i, j)*(bl(i&
&             , j)+br(i, j)))
          END IF
        END DO
      END DO
    END IF
  END SUBROUTINE FYPPM
  SUBROUTINE MP_GHOST_EW(im, jm, km, nq, ifirst, ilast, jfirst, jlast, &
&   kfirst, klast, ng_w, ng_e, ng_s, ng_n, q_ghst, q)
    IMPLICIT NONE
!
! !INPUT PARAMETERS:
    INTEGER, INTENT(IN) :: im, jm, km, nq
    INTEGER, INTENT(IN) :: ifirst, ilast
    INTEGER, INTENT(IN) :: jfirst, jlast
    INTEGER, INTENT(IN) :: kfirst, klast
! eastern  zones to ghost
    INTEGER, INTENT(IN) :: ng_e
! western  zones to ghost
    INTEGER, INTENT(IN) :: ng_w
! southern zones to ghost
    INTEGER, INTENT(IN) :: ng_s
! northern zones to ghost
    INTEGER, INTENT(IN) :: ng_n
    REAL(fvprc), INTENT(INOUT) :: q_ghst(ifirst-ng_w:ilast+ng_e, jfirst-&
&   ng_s:jlast+ng_n, kfirst:klast, nq)
    REAL(fvprc), OPTIONAL, INTENT(IN) :: q(ifirst:ilast, jfirst:jlast, &
&   kfirst:klast, nq)
!
! !DESCRIPTION:
!
!     Ghost 4d east/west 
!
! !REVISION HISTORY:
!    2005.08.22   Putman
!
!EOP
!------------------------------------------------------------------------------
!BOC
    INTEGER :: i, j, k, n
    INTRINSIC PRESENT
    IF (PRESENT(q)) q_ghst(ifirst:ilast, jfirst:jlast, kfirst:klast, 1:&
&     nq) = q(ifirst:ilast, jfirst:jlast, kfirst:klast, 1:nq)
!      Assume Periodicity in X-dir and not overlapping
    DO n=1,nq
      DO k=kfirst,klast
        DO j=jfirst-ng_s,jlast+ng_n
          DO i=1,ng_w
            q_ghst(ifirst-i, j, k, n) = q_ghst(ilast-i+1, j, k, n)
          END DO
          DO i=1,ng_e
            q_ghst(ilast+i, j, k, n) = q_ghst(ifirst+i-1, j, k, n)
          END DO
        END DO
      END DO
    END DO
  END SUBROUTINE MP_GHOST_EW
  SUBROUTINE PERT_PPM(im, a0, al, ar, iv)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: im
    INTEGER, INTENT(IN) :: iv
    REAL(fvprc), INTENT(IN) :: a0(im)
    REAL(fvprc), INTENT(INOUT) :: al(im), ar(im)
! Local:
    REAL(fvprc) :: a4, da1, da2, a6da, fmin
    INTEGER :: i
    REAL(fvprc), PARAMETER :: r12=1./12.
    INTRINSIC ABS
    REAL*8 :: abs0
!-----------------------------------
! Optimized PPM in perturbation form:
!-----------------------------------
    IF (iv .EQ. 0) THEN
! Positive definite constraint
      DO i=1,im
        IF (a0(i) .LE. 0.) THEN
          al(i) = 0.
          ar(i) = 0.
        ELSE
          a4 = -(3.*(ar(i)+al(i)))
          da1 = ar(i) - al(i)
          IF (da1 .GE. 0.) THEN
            abs0 = da1
          ELSE
            abs0 = -da1
          END IF
          IF (abs0 .LT. -a4) THEN
            fmin = a0(i) + 0.25/a4*da1**2 + a4*r12
            IF (fmin .LT. 0.) THEN
              IF (ar(i) .GT. 0. .AND. al(i) .GT. 0.) THEN
                ar(i) = 0.
                al(i) = 0.
              ELSE IF (da1 .GT. 0.) THEN
                ar(i) = -(2.*al(i))
              ELSE
                al(i) = -(2.*ar(i))
              END IF
            END IF
          END IF
        END IF
      END DO
    ELSE
! Standard PPM constraint
      DO i=1,im
        IF (al(i)*ar(i) .LT. 0.) THEN
          da1 = al(i) - ar(i)
          da2 = da1**2
          a6da = 3.*(al(i)+ar(i))*da1
          IF (a6da .LT. -da2) THEN
            ar(i) = -(2.*al(i))
          ELSE IF (a6da .GT. da2) THEN
            al(i) = -(2.*ar(i))
          END IF
        ELSE
! effect of dm=0 included here
          al(i) = 0.
          ar(i) = 0.
        END IF
      END DO
    END IF
  END SUBROUTINE PERT_PPM
!  Differentiation of deln_flux in reverse (adjoint) mode:
!   gradient     of useful results: q fx fy
!   with respect to varying inputs: q fx fy
  SUBROUTINE DELN_FLUX_ADM(nord, npx, npy, damp, q, q_ad, fx, fx_ad, fy&
&   , fy_ad, mass)
    IMPLICIT NONE
! Del-n damping for the cell-mean values (A grid)
!------------------
! nord = 0:   del-2
! nord = 1:   del-4
! nord = 2:   del-6
! nord = 3:   del-8 --> requires more ghosting than current
!------------------
! del-n
    INTEGER, INTENT(IN) :: nord
    INTEGER, INTENT(IN) :: npx, npy
    REAL(fvprc), INTENT(IN) :: damp
! q ghosted on input
    REAL(fvprc), INTENT(IN) :: q(is-ng:ie+ng, js-ng:je+ng)
    REAL(fvprc) :: q_ad(is-ng:ie+ng, js-ng:je+ng)
! q ghosted on input
    REAL(fvprc), OPTIONAL, INTENT(IN) :: mass(isd:ied, jsd:jed)
! diffusive fluxes:
    REAL(fvprc), INTENT(INOUT) :: fx(is:ie+1, js:je), fy(is:ie, js:je+1)
    REAL(fvprc), INTENT(INOUT) :: fx_ad(is:ie+1, js:je), fy_ad(is:ie, js&
&   :je+1)
! local:
    REAL(fvprc) :: fx2(isd:ied+1, jsd:jed), fy2(isd:ied, jsd:jed+1)
    REAL(fvprc) :: fx2_ad(isd:ied+1, jsd:jed), fy2_ad(isd:ied, jsd:jed+1&
&   )
    REAL(fvprc) :: d2(isd:ied, jsd:jed)
    REAL(fvprc) :: d2_ad(isd:ied, jsd:jed)
    REAL(fvprc) :: damp2
    INTEGER :: i, j, n, nt, i1, i2, j1, j2
    INTRINSIC PRESENT
    REAL(fvprc) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(fvprc) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    REAL(fvprc) :: temp_ad3
    INTEGER :: ad_from
    INTEGER :: ad_to
    INTEGER :: ad_from0
    INTEGER :: ad_to0
    INTEGER :: ad_from1
    INTEGER :: ad_to1
    INTEGER :: ad_from2
    INTEGER :: ad_to2
    INTEGER :: ad_from3
    INTEGER :: ad_to3
    INTEGER :: ad_from4
    INTEGER :: ad_to4
    INTEGER :: branch
    i1 = is - 1 - nord
    i2 = ie + 1 + nord
    j1 = js - 1 - nord
    j2 = je + 1 + nord
    IF (.NOT.PRESENT(mass)) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (nord .GT. 0) THEN
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (nord .GT. 0) THEN
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (nord .GT. 0) THEN
!----------
! high-order
!----------
      DO n=1,nord
        nt = nord - n
        ad_from0 = js - nt - 1
        DO j=ad_from0,je+nt+1
          ad_from = is - nt - 1
          i = ie + nt + 2
          CALL PUSHINTEGER4(i - 1)
          CALL PUSHINTEGER4(ad_from)
        END DO
        CALL PUSHINTEGER4(j - 1)
        CALL PUSHINTEGER4(ad_from0)
        ad_from2 = js - nt
        DO j=ad_from2,je+nt
          ad_from1 = is - nt
          i = ie + nt + 2
          CALL PUSHINTEGER4(i - 1)
          CALL PUSHINTEGER4(ad_from1)
        END DO
        CALL PUSHINTEGER4(j - 1)
        CALL PUSHINTEGER4(ad_from2)
        ad_from4 = js - nt
        DO j=ad_from4,je+nt+1
          ad_from3 = is - nt
          i = ie + nt + 1
          CALL PUSHINTEGER4(i - 1)
          CALL PUSHINTEGER4(ad_from3)
        END DO
        CALL PUSHINTEGER4(j - 1)
        CALL PUSHINTEGER4(ad_from4)
      END DO
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
!---------------------------------------------
! Add the diffusive fluxes to the flux arrays:
!---------------------------------------------
    IF (PRESENT(mass)) THEN
! Apply mass weighting to diffusive fluxes:
      damp2 = 0.5*damp
      fy2_ad = 0.0_8
      DO j=je+1,js,-1
        DO i=ie,is,-1
          fy2_ad(i, j) = fy2_ad(i, j) + (mass(i, j-1)+mass(i, j))*damp2*&
&           fy_ad(i, j)
        END DO
      END DO
      fx2_ad = 0.0_8
      DO j=je,js,-1
        DO i=ie+1,is,-1
          fx2_ad(i, j) = fx2_ad(i, j) + (mass(i-1, j)+mass(i, j))*damp2*&
&           fx_ad(i, j)
        END DO
      END DO
    ELSE
      fy2_ad = 0.0_8
      DO j=je+1,js,-1
        DO i=ie,is,-1
          fy2_ad(i, j) = fy2_ad(i, j) + fy_ad(i, j)
        END DO
      END DO
      fx2_ad = 0.0_8
      DO j=je,js,-1
        DO i=ie+1,is,-1
          fx2_ad(i, j) = fx2_ad(i, j) + fx_ad(i, j)
        END DO
      END DO
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      d2_ad = 0.0_8
      DO n=nord,1,-1
        CALL POPINTEGER4(ad_from4)
        CALL POPINTEGER4(ad_to4)
        DO j=ad_to4,ad_from4,-1
          CALL POPINTEGER4(ad_from3)
          CALL POPINTEGER4(ad_to3)
          DO i=ad_to3,ad_from3,-1
            temp_ad3 = dx(i, j)*0.5*rdyc(i, j)*(sin_sg(i, j-1, 4)+sin_sg&
&             (i, j, 2))*fy2_ad(i, j)
            d2_ad(i, j) = d2_ad(i, j) + temp_ad3
            d2_ad(i, j-1) = d2_ad(i, j-1) - temp_ad3
            fy2_ad(i, j) = 0.0_8
          END DO
        END DO
        CALL COPY_CORNERS_ADM(d2, d2_ad, npx, npy, 2)
        CALL POPINTEGER4(ad_from2)
        CALL POPINTEGER4(ad_to2)
        DO j=ad_to2,ad_from2,-1
          CALL POPINTEGER4(ad_from1)
          CALL POPINTEGER4(ad_to1)
          DO i=ad_to1,ad_from1,-1
            temp_ad2 = dy(i, j)*0.5*rdxc(i, j)*(sin_sg(i-1, j, 3)+sin_sg&
&             (i, j, 1))*fx2_ad(i, j)
            d2_ad(i, j) = d2_ad(i, j) + temp_ad2
            d2_ad(i-1, j) = d2_ad(i-1, j) - temp_ad2
            fx2_ad(i, j) = 0.0_8
          END DO
        END DO
        CALL COPY_CORNERS_ADM(d2, d2_ad, npx, npy, 1)
        CALL POPINTEGER4(ad_from0)
        CALL POPINTEGER4(ad_to0)
        DO j=ad_to0,ad_from0,-1
          CALL POPINTEGER4(ad_from)
          CALL POPINTEGER4(ad_to)
          DO i=ad_to,ad_from,-1
            temp_ad1 = rarea(i, j)*d2_ad(i, j)
            fx2_ad(i, j) = fx2_ad(i, j) + temp_ad1
            fx2_ad(i+1, j) = fx2_ad(i+1, j) - temp_ad1
            fy2_ad(i, j) = fy2_ad(i, j) + temp_ad1
            fy2_ad(i, j+1) = fy2_ad(i, j+1) - temp_ad1
            d2_ad(i, j) = 0.0_8
          END DO
        END DO
      END DO
    ELSE
      d2_ad = 0.0_8
    END IF
    DO j=je+nord+1,js-nord,-1
      DO i=ie+nord,is-nord,-1
        temp_ad0 = dx(i, j)*0.5*rdyc(i, j)*(sin_sg(i, j-1, 4)+sin_sg(i, &
&         j, 2))*fy2_ad(i, j)
        d2_ad(i, j-1) = d2_ad(i, j-1) + temp_ad0
        d2_ad(i, j) = d2_ad(i, j) - temp_ad0
        fy2_ad(i, j) = 0.0_8
      END DO
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) CALL COPY_CORNERS_ADM(d2, d2_ad, npx, npy, 2)
    DO j=je+nord,js-nord,-1
      DO i=ie+nord+1,is-nord,-1
        temp_ad = dy(i, j)*0.5*rdxc(i, j)*(sin_sg(i-1, j, 3)+sin_sg(i, j&
&         , 1))*fx2_ad(i, j)
        d2_ad(i-1, j) = d2_ad(i-1, j) + temp_ad
        d2_ad(i, j) = d2_ad(i, j) - temp_ad
        fx2_ad(i, j) = 0.0_8
      END DO
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) CALL COPY_CORNERS_ADM(d2, d2_ad, npx, npy, 1)
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO j=j2,j1,-1
        DO i=i2,i1,-1
          q_ad(i, j) = q_ad(i, j) + damp*d2_ad(i, j)
          d2_ad(i, j) = 0.0_8
        END DO
      END DO
    ELSE
      DO j=j2,j1,-1
        DO i=i2,i1,-1
          q_ad(i, j) = q_ad(i, j) + d2_ad(i, j)
          d2_ad(i, j) = 0.0_8
        END DO
      END DO
    END IF
  END SUBROUTINE DELN_FLUX_ADM
!  Differentiation of copy_corners_r8 in reverse (adjoint) mode:
!   gradient     of useful results: q
!   with respect to varying inputs: q
  SUBROUTINE COPY_CORNERS_R8_ADM(q, q_ad, npx, npy, dir)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, dir
    REAL(real8), INTENT(INOUT) :: q(isd:ied, jsd:jed)
    REAL(real8), INTENT(INOUT) :: q_ad(isd:ied, jsd:jed)
    INTEGER :: i, j
    REAL(real8) :: tmp
    REAL(real8) :: tmp_ad
    REAL(real8) :: tmp0
    REAL(real8) :: tmp_ad0
    REAL(real8) :: tmp1
    REAL(real8) :: tmp_ad1
    REAL(real8) :: tmp2
    REAL(real8) :: tmp_ad2
    REAL(real8) :: tmp3
    REAL(real8) :: tmp_ad3
    REAL(real8) :: tmp4
    REAL(real8) :: tmp_ad4
    REAL(real8) :: tmp5
    REAL(real8) :: tmp_ad5
    REAL(real8) :: tmp6
    REAL(real8) :: tmp_ad6
    INTEGER :: branch
    IF (dir .EQ. 1) THEN
! XDir:
      IF (sw_corner) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (se_corner) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (ne_corner) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (nw_corner) THEN
        DO j=npy+ng-1,npy,-1
          DO i=0,1-ng,-1
            tmp_ad2 = q_ad(i, j)
            q_ad(i, j) = 0.0_8
            q_ad(npy-j, i-1+npx) = q_ad(npy-j, i-1+npx) + tmp_ad2
          END DO
        END DO
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO j=npy+ng-1,npy,-1
          DO i=npx+ng-1,npx,-1
            tmp_ad1 = q_ad(i, j)
            q_ad(i, j) = 0.0_8
            q_ad(j, 2*npx-1-i) = q_ad(j, 2*npx-1-i) + tmp_ad1
          END DO
        END DO
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO j=0,1-ng,-1
          DO i=npx+ng-1,npx,-1
            tmp_ad0 = q_ad(i, j)
            q_ad(i, j) = 0.0_8
            q_ad(npy-j, i-npx+1) = q_ad(npy-j, i-npx+1) + tmp_ad0
          END DO
        END DO
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO j=0,1-ng,-1
          DO i=0,1-ng,-1
            tmp_ad = q_ad(i, j)
            q_ad(i, j) = 0.0_8
            q_ad(j, 1-i) = q_ad(j, 1-i) + tmp_ad
          END DO
        END DO
      END IF
    ELSE IF (dir .EQ. 2) THEN
! YDir:
      IF (sw_corner) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (se_corner) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (ne_corner) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (nw_corner) THEN
        DO j=npy+ng-1,npy,-1
          DO i=0,1-ng,-1
            tmp_ad6 = q_ad(i, j)
            q_ad(i, j) = 0.0_8
            q_ad(j+1-npx, npy-i) = q_ad(j+1-npx, npy-i) + tmp_ad6
          END DO
        END DO
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO j=npy+ng-1,npy,-1
          DO i=npx+ng-1,npx,-1
            tmp_ad5 = q_ad(i, j)
            q_ad(i, j) = 0.0_8
            q_ad(2*npy-1-j, i) = q_ad(2*npy-1-j, i) + tmp_ad5
          END DO
        END DO
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO j=0,1-ng,-1
          DO i=npx+ng-1,npx,-1
            tmp_ad4 = q_ad(i, j)
            q_ad(i, j) = 0.0_8
            q_ad(npy+j-1, npx-i) = q_ad(npy+j-1, npx-i) + tmp_ad4
          END DO
        END DO
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO j=0,1-ng,-1
          DO i=0,1-ng,-1
            tmp_ad3 = q_ad(i, j)
            q_ad(i, j) = 0.0_8
            q_ad(1-j, i) = q_ad(1-j, i) + tmp_ad3
          END DO
        END DO
      END IF
    END IF
  END SUBROUTINE COPY_CORNERS_R8_ADM
  SUBROUTINE DELN_FLUX(nord, npx, npy, damp, q, fx, fy, mass)
    IMPLICIT NONE
! Del-n damping for the cell-mean values (A grid)
!------------------
! nord = 0:   del-2
! nord = 1:   del-4
! nord = 2:   del-6
! nord = 3:   del-8 --> requires more ghosting than current
!------------------
! del-n
    INTEGER, INTENT(IN) :: nord
    INTEGER, INTENT(IN) :: npx, npy
    REAL(fvprc), INTENT(IN) :: damp
! q ghosted on input
    REAL(fvprc), INTENT(IN) :: q(is-ng:ie+ng, js-ng:je+ng)
! q ghosted on input
    REAL(fvprc), OPTIONAL, INTENT(IN) :: mass(isd:ied, jsd:jed)
! diffusive fluxes:
    REAL(fvprc), INTENT(INOUT) :: fx(is:ie+1, js:je), fy(is:ie, js:je+1)
! local:
    REAL(fvprc) :: fx2(isd:ied+1, jsd:jed), fy2(isd:ied, jsd:jed+1)
    REAL(fvprc) :: d2(isd:ied, jsd:jed)
    REAL(fvprc) :: damp2
    INTEGER :: i, j, n, nt, i1, i2, j1, j2
    INTRINSIC PRESENT
    i1 = is - 1 - nord
    i2 = ie + 1 + nord
    j1 = js - 1 - nord
    j2 = je + 1 + nord
    IF (.NOT.PRESENT(mass)) THEN
      DO j=j1,j2
        DO i=i1,i2
          d2(i, j) = damp*q(i, j)
        END DO
      END DO
    ELSE
      DO j=j1,j2
        DO i=i1,i2
          d2(i, j) = q(i, j)
        END DO
      END DO
    END IF
    IF (nord .GT. 0) CALL COPY_CORNERS(d2, npx, npy, 1)
    DO j=js-nord,je+nord
      DO i=is-nord,ie+nord+1
        fx2(i, j) = 0.5*(sin_sg(i-1, j, 3)+sin_sg(i, j, 1))*dy(i, j)*(d2&
&         (i-1, j)-d2(i, j))*rdxc(i, j)
      END DO
    END DO
    IF (nord .GT. 0) CALL COPY_CORNERS(d2, npx, npy, 2)
    DO j=js-nord,je+nord+1
      DO i=is-nord,ie+nord
        fy2(i, j) = 0.5*(sin_sg(i, j-1, 4)+sin_sg(i, j, 2))*dx(i, j)*(d2&
&         (i, j-1)-d2(i, j))*rdyc(i, j)
      END DO
    END DO
    IF (nord .GT. 0) THEN
!----------
! high-order
!----------
      DO n=1,nord
        nt = nord - n
        DO j=js-nt-1,je+nt+1
          DO i=is-nt-1,ie+nt+1
            d2(i, j) = (fx2(i, j)-fx2(i+1, j)+fy2(i, j)-fy2(i, j+1))*&
&             rarea(i, j)
          END DO
        END DO
        CALL COPY_CORNERS(d2, npx, npy, 1)
        DO j=js-nt,je+nt
          DO i=is-nt,ie+nt+1
            fx2(i, j) = 0.5*(sin_sg(i-1, j, 3)+sin_sg(i, j, 1))*dy(i, j)&
&             *(d2(i, j)-d2(i-1, j))*rdxc(i, j)
          END DO
        END DO
        CALL COPY_CORNERS(d2, npx, npy, 2)
        DO j=js-nt,je+nt+1
          DO i=is-nt,ie+nt
            fy2(i, j) = dx(i, j)*(d2(i, j)-d2(i, j-1))*rdyc(i, j)*0.5*(&
&             sin_sg(i, j-1, 4)+sin_sg(i, j, 2))
          END DO
        END DO
      END DO
    END IF
!---------------------------------------------
! Add the diffusive fluxes to the flux arrays:
!---------------------------------------------
    IF (PRESENT(mass)) THEN
! Apply mass weighting to diffusive fluxes:
      damp2 = 0.5*damp
      DO j=js,je
        DO i=is,ie+1
          fx(i, j) = fx(i, j) + damp2*(mass(i-1, j)+mass(i, j))*fx2(i, j&
&           )
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          fy(i, j) = fy(i, j) + damp2*(mass(i, j-1)+mass(i, j))*fy2(i, j&
&           )
        END DO
      END DO
    ELSE
      DO j=js,je
        DO i=is,ie+1
          fx(i, j) = fx(i, j) + fx2(i, j)
        END DO
      END DO
      DO j=js,je+1
        DO i=is,ie
          fy(i, j) = fy(i, j) + fy2(i, j)
        END DO
      END DO
    END IF
  END SUBROUTINE DELN_FLUX
  SUBROUTINE COPY_CORNERS_R8(q, npx, npy, dir)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, dir
    REAL(real8), INTENT(INOUT) :: q(isd:ied, jsd:jed)
    INTEGER :: i, j
    IF (dir .EQ. 1) THEN
! XDir:
      IF (sw_corner) THEN
        DO j=1-ng,0
          DO i=1-ng,0
            q(i, j) = q(j, 1-i)
          END DO
        END DO
      END IF
      IF (se_corner) THEN
        DO j=1-ng,0
          DO i=npx,npx+ng-1
            q(i, j) = q(npy-j, i-npx+1)
          END DO
        END DO
      END IF
      IF (ne_corner) THEN
        DO j=npy,npy+ng-1
          DO i=npx,npx+ng-1
            q(i, j) = q(j, 2*npx-1-i)
          END DO
        END DO
      END IF
      IF (nw_corner) THEN
        DO j=npy,npy+ng-1
          DO i=1-ng,0
            q(i, j) = q(npy-j, i-1+npx)
          END DO
        END DO
      END IF
    ELSE IF (dir .EQ. 2) THEN
! YDir:
      IF (sw_corner) THEN
        DO j=1-ng,0
          DO i=1-ng,0
            q(i, j) = q(1-j, i)
          END DO
        END DO
      END IF
      IF (se_corner) THEN
        DO j=1-ng,0
          DO i=npx,npx+ng-1
            q(i, j) = q(npy+j-1, npx-i)
          END DO
        END DO
      END IF
      IF (ne_corner) THEN
        DO j=npy,npy+ng-1
          DO i=npx,npx+ng-1
            q(i, j) = q(2*npy-1-j, i)
          END DO
        END DO
      END IF
      IF (nw_corner) THEN
        DO j=npy,npy+ng-1
          DO i=1-ng,0
            q(i, j) = q(j+1-npx, npy-i)
          END DO
        END DO
      END IF
    END IF
  END SUBROUTINE COPY_CORNERS_R8
END MODULE TP_CORE_MOD_B
