!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.12 (r6213) - 13 Oct 2016 10:30
!
MODULE FV_TRACER2D_MOD_B
  USE FV_ARRAYS_MOD, ONLY : fvprc, real4, real8
  USE TP_CORE_MOD_B, ONLY : fv_tp_2d, fv_tp_2d_adm
  USE FV_GRID_TOOLS_MOD_B, ONLY : area, rarea, dxa, dya, dx, dy
  USE FV_GRID_UTILS_MOD_B, ONLY : sina_u, sina_v, sin_sg
  USE FV_MP_MOD_B, ONLY : gid, domain, mp_reduce_max, ng, isd, ied, jsd,&
& jed, is, js, ie, je
  USE MPP_DOMAINS_MOD_B, ONLY : mpp_update_domains, &
& mpp_update_domains_adm, cgrid_ne, mpp_get_boundary
  USE FV_TIMING_MOD, ONLY : timing_on, timing_off
  IMPLICIT NONE
  PRIVATE 
  PUBLIC tracer_2d, tracer_2d_1l, offline_tracer_advection
  PUBLIC tracer_2d_adm, tracer_2d_1l_adm, offline_tracer_advection_adm

CONTAINS
!  Differentiation of offline_tracer_advection in reverse (adjoint) mode:
!   gradient     of useful results: q
!   with respect to varying inputs: q
!   RW status of diff variables: q:in-out
  SUBROUTINE OFFLINE_TRACER_ADVECTION_ADM(q, q_ad, ple0, ple1, mfx, mfy&
&   , cx, cy, ak, bk, ptop, npx, npy, npz, nq, hord, kord, q_split, dt, &
&   z_tracer, fill)
    USE FV_MAPZ_MOD_B, ONLY : map1_q2, map1_q2_adm
    USE FV_FILL_MOD_B, ONLY : fillz, fillz_adm
    IMPLICIT NONE
!do k = 1,npz
!   do j = js,je
!      do i = is,ie
!         q(i,j,k,iq) = q1(i,j,k) * scalingFactors(k)
!      enddo
!   enddo
!enddo
! nq loop
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
! number of tracers to be advected
    INTEGER, INTENT(IN) :: nq
    INTEGER, INTENT(IN) :: hord
    INTEGER, INTENT(IN) :: kord
    INTEGER, INTENT(IN) :: q_split
    LOGICAL, INTENT(IN) :: z_tracer
    LOGICAL, INTENT(IN) :: fill
    REAL(fvprc), INTENT(IN) :: dt
! DELP before dyn_core
    REAL(fvprc), INTENT(IN) :: ple0(is:ie, js:je, npz+1)
! DELP after dyn_core
    REAL(fvprc), INTENT(INOUT) :: ple1(is:ie, js:je, npz+1)
! Courant Number X-Dir
    REAL(fvprc), INTENT(IN) :: cx(is:ie, js:je, npz)
! Courant Number Y-Dir
    REAL(fvprc), INTENT(IN) :: cy(is:ie, js:je, npz)
! Mass Flux X-Dir
    REAL(fvprc), INTENT(IN) :: mfx(is:ie, js:je, npz)
! Mass Flux Y-Dir
    REAL(fvprc), INTENT(IN) :: mfy(is:ie, js:je, npz)
! Tracers
    REAL(fvprc), INTENT(INOUT) :: q(is:ie, js:je, npz, nq)
    REAL(fvprc), INTENT(INOUT) :: q_ad(is:ie, js:je, npz, nq)
! AK for remapping
    REAL(real8), INTENT(IN) :: ak(npz+1)
! BK for remapping
    REAL(real8), INTENT(IN) :: bk(npz+1)
    REAL(real8), INTENT(IN) :: ptop
! Local Arrays
! X-Dir for MPP Updates
    REAL(real8) :: xl(isd:ied+1, jsd:jed, npz)
! Y-Dir for MPP Updates
    REAL(real8) :: yl(isd:ied, jsd:jed+1, npz)
! Courant Number X-Dir
    REAL(fvprc) :: cxl(is:ie+1, jsd:jed, npz)
! Courant Number Y-Dir
    REAL(fvprc) :: cyl(isd:ied, js:je+1, npz)
! Mass Flux X-Dir
    REAL(fvprc) :: mfxl(is:ie+1, js:je, npz)
! Mass Flux Y-Dir
    REAL(fvprc) :: mfyl(is:ie, js:je+1, npz)
! Pressure Thickness
    REAL(real8) :: dpl(is:ie, js:je, npz)
! Pressure Thickness
    REAL(real8) :: dpa(is:ie, js:je, npz)
! Local Tracer Arrays
! 2D Tracers
    REAL(real8) :: q1(is:ie, js:je, npz)
    REAL(real8) :: q1_ad(is:ie, js:je, npz)
! 2D Tracers
    REAL(real8) :: q2(isd:ied, jsd:jed, nq)
    REAL(real8) :: q2_ad(isd:ied, jsd:jed, nq)
! 3D Tracers
    REAL(real8) :: q3(isd:ied, jsd:jed, npz, nq)
    REAL(real8) :: q3_ad(isd:ied, jsd:jed, npz, nq)
! Local Buffer Arrarys
    REAL(real8) :: wbuffer(js:je, npz)
    REAL(real8) :: sbuffer(is:ie, npz)
    REAL(real8) :: ebuffer(js:je, npz)
    REAL(real8) :: nbuffer(is:ie, npz)
! Local Remap Arrays
    REAL(real8) :: pe1(is:ie, npz+1)
    REAL(real8) :: pe2(is:ie, npz+1)
    REAL(real8) :: dp2(is:ie, js:je, npz)
! Local indices
    INTEGER :: i, j, k, n, iq
    REAL(real8) :: dtr8
    REAL(real8) :: scalingfactor
    REAL(real8) :: scalingfactor_ad
    INTEGER :: arg1
    INTEGER :: branch
!real(REAL8) :: scalingFactors(npz)
! Time-step
    dtr8 = dt
    ebuffer = 0.0
    nbuffer = 0.0
! Fill CX/CY C-Grid boundaries and update ghost regions
    xl(is:ie, js:je, :) = cx(:, :, :)
    yl(is:ie, js:je, :) = cy(:, :, :)
    CALL MPP_GET_BOUNDARY(xl, yl, domain, wbufferx=wbuffer, ebufferx=&
&                   ebuffer, sbuffery=sbuffer, nbuffery=nbuffer, &
&                   gridtype=cgrid_ne)
    xl(ie+1, js:je, :) = ebuffer
    yl(is:ie, je+1, :) = nbuffer
    CALL MPP_UPDATE_DOMAINS(xl, yl, domain, gridtype=cgrid_ne, complete=&
&                     .true.)
    cxl(is:ie+1, jsd:jed, :) = xl(is:ie+1, jsd:jed, :)
    cyl(isd:ied, js:je+1, :) = yl(isd:ied, js:je+1, :)
! Fill MFX/MFY C-Grid boundaries
    xl(is:ie, js:je, :) = mfx(:, :, :)
    yl(is:ie, js:je, :) = mfy(:, :, :)
    CALL MPP_GET_BOUNDARY(xl, yl, domain, wbufferx=wbuffer, ebufferx=&
&                   ebuffer, sbuffery=sbuffer, nbuffery=nbuffer, &
&                   gridtype=cgrid_ne)
    xl(ie+1, js:je, :) = ebuffer
    yl(is:ie, je+1, :) = nbuffer
    mfxl(is:ie+1, js:je, :) = xl(is:ie+1, js:je, :)
    mfyl(is:ie, js:je+1, :) = yl(is:ie, js:je+1, :)
! Fill local tracers and pressure thickness
    dpl(:, :, :) = ple0(:, :, 2:npz+1) - ple0(:, :, 1:npz)
    q3(is:ie, js:je, :, :) = q(is:ie, js:je, :, :)
    IF (z_tracer) THEN
!$omp parallel do default(shared) private(q2)
      DO k=1,npz
        DO iq=1,nq
          DO j=js,je
! To_do list:
            DO i=is,ie
! The data copying can be avoided if q is
              q2(i, j, iq) = q3(i, j, k, iq)
            END DO
          END DO
        END DO
! re-dimensioned as q(i,j,nq,k)
        CALL PUSHREAL8ARRAY(dpl(is, js, k), ie - is + 1)
        CALL TRACER_2D_1L(q2, dpl(is, js, k), mfxl(is, js, k), mfyl(is, &
&                   js, k), cxl(is, jsd, k), cyl(isd, js, k), npx, npy, &
&                   npz, 1, nq, hord, q_split, k, q3, dtr8, 0, dpa=dpa)
      END DO
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHREAL8ARRAY(cyl, (ied-isd+1)*(je-js+2)*npz)
      CALL PUSHREAL8ARRAY(cxl, (ie-is+2)*(jed-jsd+1)*npz)
      CALL PUSHREAL8ARRAY(mfyl, (ie-is+1)*(je-js+2)*npz)
      CALL PUSHREAL8ARRAY(mfxl, (ie-is+2)*(je-js+1)*npz)
      CALL PUSHREAL8ARRAY(dpl, (ie-is+1)*(je-js+1)*npz)
      CALL TRACER_2D(q3, dpl, mfxl, mfyl, cxl, cyl, npx, npy, npz, 1, nq&
&              , hord, q_split, dtr8, 0, dpa=dpa)
      CALL PUSHCONTROL1B(0)
    END IF
!------------------------------------------------------------------
! Re-Map constituents
! Do remapping one tracer at a time; seems to be faster
! It requires less memory than mapn_ppm
!------------------------------------------------------------------
    DO iq=1,nq
      DO j=js,je
! pressures mapping from (dpA is new delp after tracer_2d)
        CALL PUSHREAL8ARRAY(pe1(:, 1), ie - is + 1)
        pe1(:, 1) = ptop
        DO k=2,npz+1
          CALL PUSHREAL8ARRAY(pe1(:, k), ie - is + 1)
          pe1(:, k) = pe1(:, k-1) + dpa(:, j, k-1)
        END DO
! pressures mapping to
        CALL PUSHREAL8ARRAY(pe2(:, 1), ie - is + 1)
        pe2(:, 1) = ptop
        CALL PUSHREAL8ARRAY(pe2(:, npz+1), ie - is + 1)
        pe2(:, npz+1) = pe1(:, npz+1)
        DO k=2,npz
          CALL PUSHREAL8ARRAY(pe2(:, k), ie - is + 1)
          pe2(:, k) = ak(k) + bk(k)*pe1(:, npz+1)
        END DO
        DO k=1,npz
          CALL PUSHREAL8ARRAY(dp2(:, j, k), ie - is + 1)
          dp2(:, j, k) = pe2(:, k+1) - pe2(:, k)
        END DO
        CALL PUSHREAL8ARRAY(q1(:, j, :), (ie-is+1)*npz)
        CALL MAP1_Q2(npz, pe1, q3(isd, jsd, 1, iq), npz, pe2, q1(:, j, :&
&              ), dp2(:, j, :), is, ie, 0, kord, j, isd, ied, jsd, jed)
!, .true.)
        IF (fill) THEN
          arg1 = ie - is + 1
          CALL PUSHREAL8ARRAY(q1(:, j, :), (ie-is+1)*npz)
          CALL FILLZ(arg1, npz, 1, q1(:, j, :), dp2(:, j, :))
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
! Rescale tracers based on ple1 at destination timestep
!------------------------------------------------------
      CALL PUSHREAL8(scalingfactor)
      scalingfactor = CALCSCALINGFACTOR(q1, dp2, ple1, npx, npy, npz, is&
&       , ie, js, je)
!scalingFactors = computeScalingFactors(q1, dp2, ple1, npx, npy, npz, is, ie, js, je)
! Return tracers
!---------------
    END DO
    q1_ad = 0.0_8
    q3_ad = 0.0_8
    DO iq=nq,1,-1
      q1_ad = q1_ad + scalingfactor*q_ad(:, :, :, iq)
      scalingfactor_ad = SUM(q1(is:ie, js:je, 1:npz)*q_ad(is:ie, js:je, &
&       1:npz, iq))
      q_ad(:, :, :, iq) = 0.0_8
      CALL POPREAL8(scalingfactor)
      CALL CALCSCALINGFACTOR_ADM(q1, q1_ad, dp2, ple1, npx, npy, npz, is&
&                          , ie, js, je, scalingfactor_ad)
      DO j=je,js,-1
        CALL POPCONTROL1B(branch)
        IF (branch .NE. 0) THEN
          arg1 = ie - is + 1
          CALL POPREAL8ARRAY(q1(:, j, :), (ie-is+1)*npz)
          CALL FILLZ_ADM(arg1, npz, 1, q1(:, j, :), q1_ad(:, j, :), dp2(&
&                  :, j, :))
        END IF
        CALL POPREAL8ARRAY(q1(:, j, :), (ie-is+1)*npz)
        CALL MAP1_Q2_ADM(npz, pe1, q3(isd, jsd, 1, iq), q3_ad(isd, jsd, &
&                  1, iq), npz, pe2, q1(:, j, :), q1_ad(:, j, :), dp2(:&
&                  , j, :), is, ie, 0, kord, j, isd, ied, jsd, jed)
        DO k=npz,1,-1
          CALL POPREAL8ARRAY(dp2(:, j, k), ie - is + 1)
        END DO
        DO k=npz,2,-1
          CALL POPREAL8ARRAY(pe2(:, k), ie - is + 1)
        END DO
        CALL POPREAL8ARRAY(pe2(:, npz+1), ie - is + 1)
        CALL POPREAL8ARRAY(pe2(:, 1), ie - is + 1)
        DO k=npz+1,2,-1
          CALL POPREAL8ARRAY(pe1(:, k), ie - is + 1)
        END DO
        CALL POPREAL8ARRAY(pe1(:, 1), ie - is + 1)
      END DO
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPREAL8ARRAY(dpl, (ie-is+1)*(je-js+1)*npz)
      CALL POPREAL8ARRAY(mfxl, (ie-is+2)*(je-js+1)*npz)
      CALL POPREAL8ARRAY(mfyl, (ie-is+1)*(je-js+2)*npz)
      CALL POPREAL8ARRAY(cxl, (ie-is+2)*(jed-jsd+1)*npz)
      CALL POPREAL8ARRAY(cyl, (ied-isd+1)*(je-js+2)*npz)
      CALL TRACER_2D_ADM(q3, q3_ad, dpl, mfxl, mfyl, cxl, cyl, npx, npy&
&                  , npz, 1, nq, hord, q_split, dtr8, 0, dpa=dpa)
    ELSE
      q2_ad = 0.0_8
      DO k=npz,1,-1
        CALL POPREAL8ARRAY(dpl(is, js, k), ie - is + 1)
        CALL TRACER_2D_1L_ADM(q2, q2_ad, dpl(is:, js, k), mfxl(is, js, k&
&                       ), mfyl(is, js, k), cxl(is, jsd, k), cyl(isd, js&
&                       , k), npx, npy, npz, 1, nq, hord, q_split, k, q3&
&                       , q3_ad, dtr8, 0, dpa=dpa)
        DO iq=nq,1,-1
          DO j=je,js,-1
            DO i=ie,is,-1
              q3_ad(i, j, k, iq) = q3_ad(i, j, k, iq) + q2_ad(i, j, iq)
              q2_ad(i, j, iq) = 0.0_8
            END DO
          END DO
        END DO
      END DO
    END IF
    q_ad = q_ad + q3_ad(is:ie, js:je, :, :)
  END SUBROUTINE OFFLINE_TRACER_ADVECTION_ADM
!  Differentiation of tracer_2d_1l in reverse (adjoint) mode:
!   gradient     of useful results: q q3
!   with respect to varying inputs: q q3
!-----------------------------------------------------------------------
! !ROUTINE: Perform 2D horizontal-to-lagrangian transport
!-----------------------------------------------------------------------
  SUBROUTINE TRACER_2D_1L_ADM(q, q_ad, dp0, mfx, mfy, cx, cy, npx, npy, &
&   npz, qs, nq, hord, q_split, k, q3, q3_ad, dt, id_divg, dpa)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, npz
    INTEGER, INTENT(IN) :: k
! first tracer to advect
    INTEGER, INTENT(IN) :: qs
! number of tracers to be advected
    INTEGER, INTENT(IN) :: nq
    INTEGER, INTENT(IN) :: hord
    INTEGER, INTENT(IN) :: q_split
    INTEGER, INTENT(IN) :: id_divg
    REAL(real8), INTENT(IN) :: dt
! 2D Tracers
    REAL(real8), INTENT(INOUT) :: q(isd:ied, jsd:jed, nq)
    REAL(real8), INTENT(INOUT) :: q_ad(isd:ied, jsd:jed, nq)
! Tracers
    REAL(real8), INTENT(INOUT) :: q3(isd:ied, jsd:jed, npz, nq)
    REAL(real8), INTENT(INOUT) :: q3_ad(isd:ied, jsd:jed, npz, nq)
! DELP before dyn_core
    REAL(real8), INTENT(INOUT) :: dp0(is:ie, js:je)
! DELP after advection
    REAL(real8), OPTIONAL, INTENT(OUT) :: dpa(is:ie, js:je)
! Courant Number X-Dir
    REAL(fvprc), INTENT(IN) :: cx(is:ie+1, jsd:jed)
! Courant Number Y-Dir
    REAL(fvprc), INTENT(IN) :: cy(isd:ied, js:je+1)
! Mass Flux X-Dir
    REAL(fvprc), INTENT(IN) :: mfx(is:ie+1, js:je)
! Mass Flux Y-Dir
    REAL(fvprc), INTENT(IN) :: mfy(is:ie, js:je+1)
! Local Arrays
    REAL(fvprc) :: fx(is:ie+1, js:je)
    REAL(fvprc) :: fx_ad(is:ie+1, js:je)
    REAL(fvprc) :: fy(is:ie, js:je+1)
    REAL(fvprc) :: fy_ad(is:ie, js:je+1)
    REAL(fvprc) :: mfx2(is:ie+1, js:je)
    REAL(fvprc) :: mfy2(is:ie, js:je+1)
    REAL(fvprc) :: cx2(is:ie+1, jsd:jed)
    REAL(fvprc) :: cy2(isd:ied, js:je+1)
    REAL(real8) :: dp1(is:ie, js:je)
    REAL(real8) :: dp2(is:ie, js:je)
    REAL(fvprc) :: ra_x(is:ie, jsd:jed)
    REAL(fvprc) :: ra_y(isd:ied, js:je)
    REAL(fvprc) :: xfx(is:ie+1, jsd:jed)
    REAL(fvprc) :: yfx(isd:ied, js:je+1)
    REAL(fvprc) :: cmax
    REAL(fvprc) :: frac, rdt
    INTEGER :: nsplt
    INTEGER :: i, j, it, iq
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC INT
    INTRINSIC REAL
    INTRINSIC PRESENT
    REAL*8 :: abs0
    REAL*8 :: abs1
    REAL(real8) :: temp_ad
    REAL(fvprc) :: temp_ad0
    REAL(real8) :: temp_ad1
    REAL(fvprc) :: temp_ad2
    INTEGER :: branch
    REAL*8 :: x1
    REAL*8 :: y1
    DO j=jsd,jed
      DO i=is,ie+1
        IF (cx(i, j) .GT. 0.) THEN
          CALL PUSHCONTROL1B(1)
          xfx(i, j) = cx(i, j)*dxa(i-1, j)*dy(i, j)*sin_sg(i-1, j, 3)
        ELSE
          CALL PUSHCONTROL1B(0)
          xfx(i, j) = cx(i, j)*dxa(i, j)*dy(i, j)*sin_sg(i, j, 1)
        END IF
      END DO
    END DO
    DO j=js,je+1
      DO i=isd,ied
        IF (cy(i, j) .GT. 0.) THEN
          CALL PUSHCONTROL1B(1)
          yfx(i, j) = cy(i, j)*dya(i, j-1)*dx(i, j)*sin_sg(i, j-1, 4)
        ELSE
          CALL PUSHCONTROL1B(0)
          yfx(i, j) = cy(i, j)*dya(i, j)*dx(i, j)*sin_sg(i, j, 2)
        END IF
      END DO
    END DO
    IF (q_split .EQ. 0) THEN
! Determine nsplt for tracer advection
      cmax = 0.
      DO j=js,je
        DO i=is,ie
          IF (cx(i, j) .GE. 0.) THEN
            abs0 = cx(i, j)
          ELSE
            abs0 = -cx(i, j)
          END IF
          x1 = abs0 + (1.-sina_u(i, j))
          IF (cy(i, j) .GE. 0.) THEN
            abs1 = cy(i, j)
          ELSE
            abs1 = -cy(i, j)
          END IF
          y1 = abs1 + (1.-sina_v(i, j))
          IF (x1 .LT. y1) THEN
            IF (y1 .LT. cmax) THEN
              CALL PUSHCONTROL2B(0)
              cmax = cmax
            ELSE
              CALL PUSHCONTROL2B(1)
              cmax = y1
            END IF
          ELSE IF (x1 .LT. cmax) THEN
            CALL PUSHCONTROL2B(2)
            cmax = cmax
          ELSE
            CALL PUSHCONTROL2B(3)
            cmax = x1
          END IF
        END DO
      END DO
      CALL MP_REDUCE_MAX(cmax)
      nsplt = INT(1.01 + cmax)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      nsplt = q_split
    END IF
    frac = 1./REAL(nsplt)
    DO j=jsd,jed
      DO i=is,ie+1
        cx2(i, j) = cx(i, j)*frac
        xfx(i, j) = xfx(i, j)*frac
      END DO
    END DO
    DO j=js,je
      DO i=is,ie+1
        mfx2(i, j) = mfx(i, j)*frac
      END DO
    END DO
    DO j=js,je+1
      DO i=isd,ied
        cy2(i, j) = cy(i, j)*frac
        yfx(i, j) = yfx(i, j)*frac
      END DO
    END DO
    DO j=js,je+1
      DO i=is,ie
        mfy2(i, j) = mfy(i, j)*frac
      END DO
    END DO
    DO j=jsd,jed
      DO i=is,ie
        ra_x(i, j) = area(i, j) + xfx(i, j) - xfx(i+1, j)
      END DO
    END DO
    DO j=js,je
      DO i=isd,ied
        ra_y(i, j) = area(i, j) + yfx(i, j) - yfx(i, j+1)
      END DO
    END DO
    DO j=js,je
      DO i=is,ie
        dp1(i, j) = dp0(i, j)
      END DO
    END DO
    DO it=1,nsplt
      DO j=js,je
        DO i=is,ie
          CALL PUSHREAL8(dp2(i, j))
          dp2(i, j) = dp1(i, j) + (mfx2(i, j)-mfx2(i+1, j)+mfy2(i, j)-&
&           mfy2(i, j+1))*rarea(i, j)
        END DO
      END DO
      DO iq=qs,nq
        IF (it .EQ. nsplt) THEN
          CALL PUSHCONTROL1B(1)
        ELSE
          CALL PUSHCONTROL1B(0)
        END IF
      END DO
      IF (it .NE. nsplt) THEN
        DO j=js,je
          DO i=is,ie
            CALL PUSHREAL8(dp1(i, j))
            dp1(i, j) = dp2(i, j)
          END DO
        END DO
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
    END DO
    fx_ad = 0.0_8
    fy_ad = 0.0_8
    DO it=nsplt,1,-1
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        DO j=je,js,-1
          DO i=ie,is,-1
            CALL POPREAL8(dp1(i, j))
          END DO
        END DO
      END IF
      DO iq=nq,qs,-1
        CALL POPCONTROL1B(branch)
        IF (branch .EQ. 0) THEN
          DO j=je,js,-1
            DO i=ie,is,-1
              temp_ad1 = q_ad(i, j, iq)/dp2(i, j)
              temp_ad2 = rarea(i, j)*temp_ad1
              fx_ad(i, j) = fx_ad(i, j) + temp_ad2
              fx_ad(i+1, j) = fx_ad(i+1, j) - temp_ad2
              fy_ad(i, j) = fy_ad(i, j) + temp_ad2
              fy_ad(i, j+1) = fy_ad(i, j+1) - temp_ad2
              q_ad(i, j, iq) = dp1(i, j)*temp_ad1
            END DO
          END DO
        ELSE
          DO j=je,js,-1
            DO i=ie,is,-1
              temp_ad = q3_ad(i, j, k, iq)/dp2(i, j)
              temp_ad0 = rarea(i, j)*temp_ad
              q_ad(i, j, iq) = q_ad(i, j, iq) + dp1(i, j)*temp_ad
              fx_ad(i, j) = fx_ad(i, j) + temp_ad0
              fx_ad(i+1, j) = fx_ad(i+1, j) - temp_ad0
              fy_ad(i, j) = fy_ad(i, j) + temp_ad0
              fy_ad(i, j+1) = fy_ad(i, j+1) - temp_ad0
              q3_ad(i, j, k, iq) = 0.0_8
            END DO
          END DO
        END IF
        CALL FV_TP_2D_ADM(q(isd:, jsd:, iq), q_ad(isd:, jsd:, iq), cx2, &
&                   cy2, npx, npy, hord, fx, fx_ad, fy, fy_ad, xfx, yfx&
&                   , ra_x, ra_y, mfx=mfx2, mfy=mfy2)
      END DO
      CALL MPP_UPDATE_DOMAINS_ADM(q, q_ad, domain, complete=.true.)
      DO j=je,js,-1
        DO i=ie,is,-1
          CALL POPREAL8(dp2(i, j))
        END DO
      END DO
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO j=je,js,-1
        DO i=ie,is,-1
          CALL POPCONTROL2B(branch)
        END DO
      END DO
    END IF
    DO j=je+1,js,-1
      DO i=ied,isd,-1
        CALL POPCONTROL1B(branch)
      END DO
    END DO
    DO j=jed,jsd,-1
      DO i=ie+1,is,-1
        CALL POPCONTROL1B(branch)
      END DO
    END DO
  END SUBROUTINE TRACER_2D_1L_ADM
!  Differentiation of tracer_2d in reverse (adjoint) mode:
!   gradient     of useful results: q
!   with respect to varying inputs: q
  SUBROUTINE TRACER_2D_ADM(q, q_ad, dp1, mfx, mfy, cx, cy, npx, npy, npz&
&   , qs, nq, hord, q_split, dt, id_divg, dpa)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
! first tracer to advect
    INTEGER, INTENT(IN) :: qs
! number of tracers to be advected
    INTEGER, INTENT(IN) :: nq
    INTEGER, INTENT(IN) :: hord
    INTEGER, INTENT(IN) :: q_split
    INTEGER, INTENT(IN) :: id_divg
    REAL(real8), INTENT(IN) :: dt
! Tracers
    REAL(real8), INTENT(INOUT) :: q(isd:ied, jsd:jed, npz, nq)
    REAL(real8), INTENT(INOUT) :: q_ad(isd:ied, jsd:jed, npz, nq)
! DELP before dyn_core
    REAL(real8), INTENT(INOUT) :: dp1(is:ie, js:je, npz)
! DELP after advection
    REAL(real8), OPTIONAL, INTENT(OUT) :: dpa(is:ie, js:je, npz)
! Courant Number X-Dir
    REAL(fvprc), INTENT(INOUT) :: cx(is:ie+1, jsd:jed, npz)
! Courant Number Y-Dir
    REAL(fvprc), INTENT(INOUT) :: cy(isd:ied, js:je+1, npz)
! Mass Flux X-Dir
    REAL(fvprc), INTENT(INOUT) :: mfx(is:ie+1, js:je, npz)
! Mass Flux Y-Dir
    REAL(fvprc), INTENT(INOUT) :: mfy(is:ie, js:je+1, npz)
! Local Arrays
    REAL(fvprc) :: fx(is:ie+1, js:je)
    REAL(fvprc) :: fx_ad(is:ie+1, js:je)
    REAL(fvprc) :: fy(is:ie, js:je+1)
    REAL(fvprc) :: fy_ad(is:ie, js:je+1)
    REAL(real8) :: dp2(is:ie, js:je)
    REAL(fvprc) :: ra_x(is:ie, jsd:jed)
    REAL(fvprc) :: ra_y(isd:ied, js:je)
    REAL(fvprc) :: xfx(is:ie+1, jsd:jed, npz)
    REAL(fvprc) :: yfx(isd:ied, js:je+1, npz)
    REAL(fvprc) :: cmax(npz)
!#ifdef IBM_FIX
!      real(FVPRC) :: cmax_x, cmax_y
!#endif
    REAL(fvprc) :: c_global
    REAL(fvprc) :: frac, rdt
    INTEGER :: nsplt
    INTEGER :: i, j, k, it, iq
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC INT
    INTRINSIC REAL
    INTRINSIC PRESENT
    REAL*8 :: abs0
    REAL*8 :: abs1
    REAL(real8) :: temp_ad
    REAL(fvprc) :: temp_ad0
    INTEGER :: branch
    REAL*8 :: x1
    REAL*8 :: y1
!$omp parallel do default(shared)
    DO k=1,npz
      DO j=jsd,jed
        DO i=is,ie+1
          IF (cx(i, j, k) .GT. 0.) THEN
            CALL PUSHCONTROL1B(1)
            xfx(i, j, k) = cx(i, j, k)*dxa(i-1, j)*dy(i, j)*sin_sg(i-1, &
&             j, 3)
          ELSE
            CALL PUSHCONTROL1B(0)
            xfx(i, j, k) = cx(i, j, k)*dxa(i, j)*dy(i, j)*sin_sg(i, j, 1&
&             )
          END IF
        END DO
      END DO
      DO j=js,je+1
        DO i=isd,ied
          IF (cy(i, j, k) .GT. 0.) THEN
            CALL PUSHCONTROL1B(1)
            yfx(i, j, k) = cy(i, j, k)*dya(i, j-1)*dx(i, j)*sin_sg(i, j-&
&             1, 4)
          ELSE
            CALL PUSHCONTROL1B(0)
            yfx(i, j, k) = cy(i, j, k)*dya(i, j)*dx(i, j)*sin_sg(i, j, 2&
&             )
          END IF
        END DO
      END DO
    END DO
!--------------------------------------------------------------------------------
    IF (q_split .EQ. 0) THEN
! Determine nsplt
!#ifdef IBM_FIX
!!$omp parallel do default(shared) private(cmax_x, cmax_y)
!      do k=1,npz
!        cmax(k) = 0.
!        do j=js,je
!          do i=is,ie
!            cmax_x  = max(abs(cx(i,j,k))+1.-sina_u(i,j), cmax(k))
!            cmax_y  = max(abs(cy(i,j,k))+1.-sina_v(i,j), cmax(k))
!            cmax(k) = max(cmax_x, cmax_y)
!          enddo
!        enddo
!      enddo
!#else 
!$omp parallel do default(shared) 
      DO k=1,npz
        cmax(k) = 0.
        DO j=js,je
          DO i=is,ie
            IF (cx(i, j, k) .GE. 0.) THEN
              abs0 = cx(i, j, k)
            ELSE
              abs0 = -cx(i, j, k)
            END IF
            x1 = abs0 + 1. - sina_u(i, j)
            IF (cy(i, j, k) .GE. 0.) THEN
              abs1 = cy(i, j, k)
            ELSE
              abs1 = -cy(i, j, k)
            END IF
            y1 = abs1 + 1. - sina_v(i, j)
            IF (x1 .LT. y1) THEN
              IF (y1 .LT. cmax(k)) THEN
                CALL PUSHCONTROL2B(0)
                cmax(k) = cmax(k)
              ELSE
                CALL PUSHCONTROL2B(1)
                cmax(k) = y1
              END IF
            ELSE IF (x1 .LT. cmax(k)) THEN
              CALL PUSHCONTROL2B(2)
              cmax(k) = cmax(k)
            ELSE
              CALL PUSHCONTROL2B(3)
              cmax(k) = x1
            END IF
          END DO
        END DO
      END DO
      CALL MP_REDUCE_MAX(cmax, npz)
!#endif
! find global max courant number and define nsplt to scale cx,cy,mfx,mfy
      c_global = cmax(1)
      IF (npz .NE. 1) THEN
! if NOT shallow water test case
        DO k=2,npz
          IF (cmax(k) .LT. c_global) THEN
            CALL PUSHCONTROL1B(0)
            c_global = c_global
          ELSE
            CALL PUSHCONTROL1B(1)
            c_global = cmax(k)
          END IF
        END DO
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      nsplt = INT(1. + c_global)
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
      nsplt = q_split
    END IF
!--------------------------------------------------------------------------------
    frac = 1./REAL(nsplt)
    IF (nsplt .NE. 1) THEN
!$omp parallel do default(shared)
      DO k=1,npz
        DO j=jsd,jed
          DO i=is,ie+1
            cx(i, j, k) = cx(i, j, k)*frac
            xfx(i, j, k) = xfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je
          DO i=is,ie+1
            mfx(i, j, k) = mfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je+1
          DO i=isd,ied
            cy(i, j, k) = cy(i, j, k)*frac
            yfx(i, j, k) = yfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je+1
          DO i=is,ie
            mfy(i, j, k) = mfy(i, j, k)*frac
          END DO
        END DO
      END DO
    END IF
    DO it=1,nsplt
!$omp parallel do default(shared) private(ra_x, ra_y, dp2, fx, fy)
      DO k=1,npz
        DO j=jsd,jed
          DO i=is,ie
            CALL PUSHREAL8(ra_x(i, j))
            ra_x(i, j) = area(i, j) + xfx(i, j, k) - xfx(i+1, j, k)
          END DO
        END DO
        DO j=js,je
          DO i=isd,ied
            CALL PUSHREAL8(ra_y(i, j))
            ra_y(i, j) = area(i, j) + yfx(i, j, k) - yfx(i, j+1, k)
          END DO
        END DO
        DO j=js,je
          DO i=is,ie
            CALL PUSHREAL8(dp2(i, j))
            dp2(i, j) = dp1(i, j, k) + (mfx(i, j, k)-mfx(i+1, j, k)+mfy(&
&             i, j, k)-mfy(i, j+1, k))*rarea(i, j)
          END DO
        END DO
        DO j=js,je
          DO i=is,ie
            CALL PUSHREAL8(dp1(i, j, k))
            dp1(i, j, k) = dp2(i, j)
          END DO
        END DO
      END DO
    END DO
    fx_ad = 0.0_8
    fy_ad = 0.0_8
    DO it=nsplt,1,-1
      DO k=npz,1,-1
        DO j=je,js,-1
          DO i=ie,is,-1
            CALL POPREAL8(dp1(i, j, k))
          END DO
        END DO
        DO iq=nq,qs,-1
          DO j=je,js,-1
            DO i=ie,is,-1
              temp_ad = q_ad(i, j, k, iq)/dp2(i, j)
              temp_ad0 = rarea(i, j)*temp_ad
              fx_ad(i, j) = fx_ad(i, j) + temp_ad0
              fx_ad(i+1, j) = fx_ad(i+1, j) - temp_ad0
              fy_ad(i, j) = fy_ad(i, j) + temp_ad0
              fy_ad(i, j+1) = fy_ad(i, j+1) - temp_ad0
              q_ad(i, j, k, iq) = dp1(i, j, k)*temp_ad
            END DO
          END DO
          CALL FV_TP_2D_ADM(q(isd:, jsd:, k, iq), q_ad(isd:, jsd:, k, iq&
&                     ), cx(is:, jsd:, k), cy(isd:, js:, k), npx, npy, &
&                     hord, fx, fx_ad, fy, fy_ad, xfx(is:, jsd:, k), yfx&
&                     (isd:, js:, k), ra_x, ra_y, mfx(is:, js:, k), mfy(&
&                     is:, js:, k))
        END DO
        DO j=je,js,-1
          DO i=ie,is,-1
            CALL POPREAL8(dp2(i, j))
          END DO
        END DO
        DO j=je,js,-1
          DO i=ied,isd,-1
            CALL POPREAL8(ra_y(i, j))
          END DO
        END DO
        DO j=jed,jsd,-1
          DO i=ie,is,-1
            CALL POPREAL8(ra_x(i, j))
          END DO
        END DO
      END DO
      CALL MPP_UPDATE_DOMAINS_ADM(q, q_ad, domain, complete=.true.)
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        DO k=npz,2,-1
          CALL POPCONTROL1B(branch)
        END DO
      END IF
      DO k=npz,1,-1
        DO j=je,js,-1
          DO i=ie,is,-1
            CALL POPCONTROL2B(branch)
          END DO
        END DO
      END DO
    END IF
    DO k=npz,1,-1
      DO j=je+1,js,-1
        DO i=ied,isd,-1
          CALL POPCONTROL1B(branch)
        END DO
      END DO
      DO j=jed,jsd,-1
        DO i=ie+1,is,-1
          CALL POPCONTROL1B(branch)
        END DO
      END DO
    END DO
  END SUBROUTINE TRACER_2D_ADM
  SUBROUTINE OFFLINE_TRACER_ADVECTION(q, ple0, ple1, mfx, mfy, cx, cy, &
&   ak, bk, ptop, npx, npy, npz, nq, hord, kord, q_split, dt, z_tracer, &
&   fill)
    USE FV_MAPZ_MOD_B, ONLY : map1_q2
    USE FV_FILL_MOD_B, ONLY : fillz
    IMPLICIT NONE
!do k = 1,npz
!   do j = js,je
!      do i = is,ie
!         q(i,j,k,iq) = q1(i,j,k) * scalingFactors(k)
!      enddo
!   enddo
!enddo
! nq loop
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
! number of tracers to be advected
    INTEGER, INTENT(IN) :: nq
    INTEGER, INTENT(IN) :: hord
    INTEGER, INTENT(IN) :: kord
    INTEGER, INTENT(IN) :: q_split
    LOGICAL, INTENT(IN) :: z_tracer
    LOGICAL, INTENT(IN) :: fill
    REAL(fvprc), INTENT(IN) :: dt
! DELP before dyn_core
    REAL(fvprc), INTENT(IN) :: ple0(is:ie, js:je, npz+1)
! DELP after dyn_core
    REAL(fvprc), INTENT(INOUT) :: ple1(is:ie, js:je, npz+1)
! Courant Number X-Dir
    REAL(fvprc), INTENT(IN) :: cx(is:ie, js:je, npz)
! Courant Number Y-Dir
    REAL(fvprc), INTENT(IN) :: cy(is:ie, js:je, npz)
! Mass Flux X-Dir
    REAL(fvprc), INTENT(IN) :: mfx(is:ie, js:je, npz)
! Mass Flux Y-Dir
    REAL(fvprc), INTENT(IN) :: mfy(is:ie, js:je, npz)
! Tracers
    REAL(fvprc), INTENT(INOUT) :: q(is:ie, js:je, npz, nq)
! AK for remapping
    REAL(real8), INTENT(IN) :: ak(npz+1)
! BK for remapping
    REAL(real8), INTENT(IN) :: bk(npz+1)
    REAL(real8), INTENT(IN) :: ptop
! Local Arrays
! X-Dir for MPP Updates
    REAL(real8) :: xl(isd:ied+1, jsd:jed, npz)
! Y-Dir for MPP Updates
    REAL(real8) :: yl(isd:ied, jsd:jed+1, npz)
! Courant Number X-Dir
    REAL(fvprc) :: cxl(is:ie+1, jsd:jed, npz)
! Courant Number Y-Dir
    REAL(fvprc) :: cyl(isd:ied, js:je+1, npz)
! Mass Flux X-Dir
    REAL(fvprc) :: mfxl(is:ie+1, js:je, npz)
! Mass Flux Y-Dir
    REAL(fvprc) :: mfyl(is:ie, js:je+1, npz)
! Pressure Thickness
    REAL(real8) :: dpl(is:ie, js:je, npz)
! Pressure Thickness
    REAL(real8) :: dpa(is:ie, js:je, npz)
! Local Tracer Arrays
! 2D Tracers
    REAL(real8) :: q1(is:ie, js:je, npz)
! 2D Tracers
    REAL(real8) :: q2(isd:ied, jsd:jed, nq)
! 3D Tracers
    REAL(real8) :: q3(isd:ied, jsd:jed, npz, nq)
! Local Buffer Arrarys
    REAL(real8) :: wbuffer(js:je, npz)
    REAL(real8) :: sbuffer(is:ie, npz)
    REAL(real8) :: ebuffer(js:je, npz)
    REAL(real8) :: nbuffer(is:ie, npz)
! Local Remap Arrays
    REAL(real8) :: pe1(is:ie, npz+1)
    REAL(real8) :: pe2(is:ie, npz+1)
    REAL(real8) :: dp2(is:ie, js:je, npz)
! Local indices
    INTEGER :: i, j, k, n, iq
    REAL(real8) :: dtr8
    REAL(real8) :: scalingfactor
    INTEGER :: arg1
!real(REAL8) :: scalingFactors(npz)
! Time-step
    dtr8 = dt
    wbuffer = 0.0
    sbuffer = 0.0
    ebuffer = 0.0
    nbuffer = 0.0
! Fill CX/CY C-Grid boundaries and update ghost regions
    xl(is:ie, js:je, :) = cx(:, :, :)
    yl(is:ie, js:je, :) = cy(:, :, :)
    CALL MPP_GET_BOUNDARY(xl, yl, domain, wbufferx=wbuffer, ebufferx=&
&                   ebuffer, sbuffery=sbuffer, nbuffery=nbuffer, &
&                   gridtype=cgrid_ne)
    xl(ie+1, js:je, :) = ebuffer
    yl(is:ie, je+1, :) = nbuffer
    CALL MPP_UPDATE_DOMAINS(xl, yl, domain, gridtype=cgrid_ne, complete=&
&                     .true.)
    cxl(is:ie+1, jsd:jed, :) = xl(is:ie+1, jsd:jed, :)
    cyl(isd:ied, js:je+1, :) = yl(isd:ied, js:je+1, :)
! Fill MFX/MFY C-Grid boundaries
    xl(is:ie, js:je, :) = mfx(:, :, :)
    yl(is:ie, js:je, :) = mfy(:, :, :)
    CALL MPP_GET_BOUNDARY(xl, yl, domain, wbufferx=wbuffer, ebufferx=&
&                   ebuffer, sbuffery=sbuffer, nbuffery=nbuffer, &
&                   gridtype=cgrid_ne)
    xl(ie+1, js:je, :) = ebuffer
    yl(is:ie, je+1, :) = nbuffer
    mfxl(is:ie+1, js:je, :) = xl(is:ie+1, js:je, :)
    mfyl(is:ie, js:je+1, :) = yl(is:ie, js:je+1, :)
! Fill local tracers and pressure thickness
    dpl(:, :, :) = ple0(:, :, 2:npz+1) - ple0(:, :, 1:npz)
    q3(is:ie, js:je, :, :) = q(is:ie, js:je, :, :)
    IF (z_tracer) THEN
!$omp parallel do default(shared) private(q2)
      DO k=1,npz
        DO iq=1,nq
          DO j=js,je
! To_do list:
            DO i=is,ie
! The data copying can be avoided if q is
              q2(i, j, iq) = q3(i, j, k, iq)
            END DO
          END DO
        END DO
! re-dimensioned as q(i,j,nq,k)
        CALL TRACER_2D_1L(q2, dpl(is, js, k), mfxl(is, js, k), mfyl(is, &
&                   js, k), cxl(is, jsd, k), cyl(isd, js, k), npx, npy, &
&                   npz, 1, nq, hord, q_split, k, q3, dtr8, 0, dpa)
      END DO
    ELSE
      CALL TRACER_2D(q3, dpl, mfxl, mfyl, cxl, cyl, npx, npy, npz, 1, nq&
&              , hord, q_split, dtr8, 0, dpa)
    END IF
!------------------------------------------------------------------
! Re-Map constituents
! Do remapping one tracer at a time; seems to be faster
! It requires less memory than mapn_ppm
!------------------------------------------------------------------
    DO iq=1,nq
      DO j=js,je
! pressures mapping from (dpA is new delp after tracer_2d)
        pe1(:, 1) = ptop
        DO k=2,npz+1
          pe1(:, k) = pe1(:, k-1) + dpa(:, j, k-1)
        END DO
! pressures mapping to
        pe2(:, 1) = ptop
        pe2(:, npz+1) = pe1(:, npz+1)
        DO k=2,npz
          pe2(:, k) = ak(k) + bk(k)*pe1(:, npz+1)
        END DO
        DO k=1,npz
          dp2(:, j, k) = pe2(:, k+1) - pe2(:, k)
        END DO
        CALL MAP1_Q2(npz, pe1, q3(isd, jsd, 1, iq), npz, pe2, q1(:, j, :&
&              ), dp2(:, j, :), is, ie, 0, kord, j, isd, ied, jsd, jed)
!, .true.)
        IF (fill) THEN
          arg1 = ie - is + 1
          CALL FILLZ(arg1, npz, 1, q1(:, j, :), dp2(:, j, :))
        END IF
      END DO
! Rescale tracers based on ple1 at destination timestep
!------------------------------------------------------
      scalingfactor = CALCSCALINGFACTOR(q1, dp2, ple1, npx, npy, npz, is&
&       , ie, js, je)
!scalingFactors = computeScalingFactors(q1, dp2, ple1, npx, npy, npz, is, ie, js, je)
! Return tracers
!---------------
      q(is:ie, js:je, 1:npz, iq) = q1(is:ie, js:je, 1:npz)*scalingfactor
    END DO
  END SUBROUTINE OFFLINE_TRACER_ADVECTION
!-----------------------------------------------------------------------
! !ROUTINE: Perform 2D horizontal-to-lagrangian transport
!-----------------------------------------------------------------------
  SUBROUTINE TRACER_2D_1L(q, dp0, mfx, mfy, cx, cy, npx, npy, npz, qs, &
&   nq, hord, q_split, k, q3, dt, id_divg, dpa)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, npz
    INTEGER, INTENT(IN) :: k
! first tracer to advect
    INTEGER, INTENT(IN) :: qs
! number of tracers to be advected
    INTEGER, INTENT(IN) :: nq
    INTEGER, INTENT(IN) :: hord
    INTEGER, INTENT(IN) :: q_split
    INTEGER, INTENT(IN) :: id_divg
    REAL(real8), INTENT(IN) :: dt
! 2D Tracers
    REAL(real8), INTENT(INOUT) :: q(isd:ied, jsd:jed, nq)
! Tracers
    REAL(real8), INTENT(INOUT) :: q3(isd:ied, jsd:jed, npz, nq)
! DELP before dyn_core
    REAL(real8), INTENT(INOUT) :: dp0(is:ie, js:je)
! DELP after advection
    REAL(real8), OPTIONAL, INTENT(OUT) :: dpa(is:ie, js:je)
! Courant Number X-Dir
    REAL(fvprc), INTENT(IN) :: cx(is:ie+1, jsd:jed)
! Courant Number Y-Dir
    REAL(fvprc), INTENT(IN) :: cy(isd:ied, js:je+1)
! Mass Flux X-Dir
    REAL(fvprc), INTENT(IN) :: mfx(is:ie+1, js:je)
! Mass Flux Y-Dir
    REAL(fvprc), INTENT(IN) :: mfy(is:ie, js:je+1)
! Local Arrays
    REAL(fvprc) :: fx(is:ie+1, js:je)
    REAL(fvprc) :: fy(is:ie, js:je+1)
    REAL(fvprc) :: mfx2(is:ie+1, js:je)
    REAL(fvprc) :: mfy2(is:ie, js:je+1)
    REAL(fvprc) :: cx2(is:ie+1, jsd:jed)
    REAL(fvprc) :: cy2(isd:ied, js:je+1)
    REAL(real8) :: dp1(is:ie, js:je)
    REAL(real8) :: dp2(is:ie, js:je)
    REAL(fvprc) :: ra_x(is:ie, jsd:jed)
    REAL(fvprc) :: ra_y(isd:ied, js:je)
    REAL(fvprc) :: xfx(is:ie+1, jsd:jed)
    REAL(fvprc) :: yfx(isd:ied, js:je+1)
    REAL(fvprc) :: cmax
    REAL(fvprc) :: frac, rdt
    INTEGER :: nsplt
    INTEGER :: i, j, it, iq
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC INT
    INTRINSIC REAL
    INTRINSIC PRESENT
    REAL*8 :: abs0
    REAL*8 :: abs1
    REAL*8 :: x1
    REAL*8 :: y1
    DO j=jsd,jed
      DO i=is,ie+1
        IF (cx(i, j) .GT. 0.) THEN
          xfx(i, j) = cx(i, j)*dxa(i-1, j)*dy(i, j)*sin_sg(i-1, j, 3)
        ELSE
          xfx(i, j) = cx(i, j)*dxa(i, j)*dy(i, j)*sin_sg(i, j, 1)
        END IF
      END DO
    END DO
    DO j=js,je+1
      DO i=isd,ied
        IF (cy(i, j) .GT. 0.) THEN
          yfx(i, j) = cy(i, j)*dya(i, j-1)*dx(i, j)*sin_sg(i, j-1, 4)
        ELSE
          yfx(i, j) = cy(i, j)*dya(i, j)*dx(i, j)*sin_sg(i, j, 2)
        END IF
      END DO
    END DO
    IF (q_split .EQ. 0) THEN
! Determine nsplt for tracer advection
      cmax = 0.
      DO j=js,je
        DO i=is,ie
          IF (cx(i, j) .GE. 0.) THEN
            abs0 = cx(i, j)
          ELSE
            abs0 = -cx(i, j)
          END IF
          x1 = abs0 + (1.-sina_u(i, j))
          IF (cy(i, j) .GE. 0.) THEN
            abs1 = cy(i, j)
          ELSE
            abs1 = -cy(i, j)
          END IF
          y1 = abs1 + (1.-sina_v(i, j))
          IF (x1 .LT. y1) THEN
            IF (y1 .LT. cmax) THEN
              cmax = cmax
            ELSE
              cmax = y1
            END IF
          ELSE IF (x1 .LT. cmax) THEN
            cmax = cmax
          ELSE
            cmax = x1
          END IF
        END DO
      END DO
      CALL MP_REDUCE_MAX(cmax)
      nsplt = INT(1.01 + cmax)
      IF (gid .EQ. 0 .AND. nsplt .GT. 5) WRITE(6, *) k, &
&                                        'Tracer_2d_split=', nsplt, cmax
    ELSE
      nsplt = q_split
    END IF
    frac = 1./REAL(nsplt)
    DO j=jsd,jed
      DO i=is,ie+1
        cx2(i, j) = cx(i, j)*frac
        xfx(i, j) = xfx(i, j)*frac
      END DO
    END DO
    DO j=js,je
      DO i=is,ie+1
        mfx2(i, j) = mfx(i, j)*frac
      END DO
    END DO
    DO j=js,je+1
      DO i=isd,ied
        cy2(i, j) = cy(i, j)*frac
        yfx(i, j) = yfx(i, j)*frac
      END DO
    END DO
    DO j=js,je+1
      DO i=is,ie
        mfy2(i, j) = mfy(i, j)*frac
      END DO
    END DO
    DO j=jsd,jed
      DO i=is,ie
        ra_x(i, j) = area(i, j) + xfx(i, j) - xfx(i+1, j)
      END DO
    END DO
    DO j=js,je
      DO i=isd,ied
        ra_y(i, j) = area(i, j) + yfx(i, j) - yfx(i, j+1)
      END DO
    END DO
    DO j=js,je
      DO i=is,ie
        dp1(i, j) = dp0(i, j)
      END DO
    END DO
    DO it=1,nsplt
      DO j=js,je
        DO i=is,ie
          dp2(i, j) = dp1(i, j) + (mfx2(i, j)-mfx2(i+1, j)+mfy2(i, j)-&
&           mfy2(i, j+1))*rarea(i, j)
        END DO
      END DO
      CALL TIMING_ON('COMM_TOTAL')
      CALL TIMING_ON('COMM_TRAC')
      CALL MPP_UPDATE_DOMAINS(q, domain, complete=.true.)
      CALL TIMING_OFF('COMM_TRAC')
      CALL TIMING_OFF('COMM_TOTAL')
      CALL TIMING_ON('fv_tp_2d')
      DO iq=qs,nq
        CALL FV_TP_2D(q(isd:, jsd:, iq), cx2, cy2, npx, npy, hord, fx, &
&               fy, xfx, yfx, ra_x, ra_y, mfx=mfx2, mfy=mfy2)
        IF (it .EQ. nsplt) THEN
          DO j=js,je
            DO i=is,ie
              q3(i, j, k, iq) = (q(i, j, iq)*dp1(i, j)+(fx(i, j)-fx(i+1&
&               , j)+fy(i, j)-fy(i, j+1))*rarea(i, j))/dp2(i, j)
            END DO
          END DO
        ELSE
          DO j=js,je
            DO i=is,ie
              q(i, j, iq) = (q(i, j, iq)*dp1(i, j)+(fx(i, j)-fx(i+1, j)+&
&               fy(i, j)-fy(i, j+1))*rarea(i, j))/dp2(i, j)
            END DO
          END DO
        END IF
      END DO
      CALL TIMING_OFF('fv_tp_2d')
      IF (it .NE. nsplt) THEN
        DO j=js,je
          DO i=is,ie
            dp1(i, j) = dp2(i, j)
          END DO
        END DO
      END IF
    END DO
! nsplt
    IF (id_divg .GT. 0) THEN
      rdt = 1./(frac*dt)
      DO j=js,je
        DO i=is,ie
          dp0(i, j) = (xfx(i+1, j)-xfx(i, j)+yfx(i, j+1)-yfx(i, j))*&
&           rarea(i, j)*rdt
        END DO
      END DO
    END IF
    IF (PRESENT(dpa)) dpa = dp2
  END SUBROUTINE TRACER_2D_1L
  SUBROUTINE TRACER_2D(q, dp1, mfx, mfy, cx, cy, npx, npy, npz, qs, nq, &
&   hord, q_split, dt, id_divg, dpa)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
! first tracer to advect
    INTEGER, INTENT(IN) :: qs
! number of tracers to be advected
    INTEGER, INTENT(IN) :: nq
    INTEGER, INTENT(IN) :: hord
    INTEGER, INTENT(IN) :: q_split
    INTEGER, INTENT(IN) :: id_divg
    REAL(real8), INTENT(IN) :: dt
! Tracers
    REAL(real8), INTENT(INOUT) :: q(isd:ied, jsd:jed, npz, nq)
! DELP before dyn_core
    REAL(real8), INTENT(INOUT) :: dp1(is:ie, js:je, npz)
! DELP after advection
    REAL(real8), OPTIONAL, INTENT(OUT) :: dpa(is:ie, js:je, npz)
! Courant Number X-Dir
    REAL(fvprc), INTENT(INOUT) :: cx(is:ie+1, jsd:jed, npz)
! Courant Number Y-Dir
    REAL(fvprc), INTENT(INOUT) :: cy(isd:ied, js:je+1, npz)
! Mass Flux X-Dir
    REAL(fvprc), INTENT(INOUT) :: mfx(is:ie+1, js:je, npz)
! Mass Flux Y-Dir
    REAL(fvprc), INTENT(INOUT) :: mfy(is:ie, js:je+1, npz)
! Local Arrays
    REAL(fvprc) :: fx(is:ie+1, js:je)
    REAL(fvprc) :: fy(is:ie, js:je+1)
    REAL(real8) :: dp2(is:ie, js:je)
    REAL(fvprc) :: ra_x(is:ie, jsd:jed)
    REAL(fvprc) :: ra_y(isd:ied, js:je)
    REAL(fvprc) :: xfx(is:ie+1, jsd:jed, npz)
    REAL(fvprc) :: yfx(isd:ied, js:je+1, npz)
    REAL(fvprc) :: cmax(npz)
!#ifdef IBM_FIX
!      real(FVPRC) :: cmax_x, cmax_y
!#endif
    REAL(fvprc) :: c_global
    REAL(fvprc) :: frac, rdt
    INTEGER :: nsplt
    INTEGER :: i, j, k, it, iq
    INTRINSIC ABS
    INTRINSIC MAX
    INTRINSIC INT
    INTRINSIC REAL
    INTRINSIC PRESENT
    REAL*8 :: abs0
    REAL*8 :: abs1
    REAL*8 :: x1
    REAL*8 :: y1
!$omp parallel do default(shared)
    DO k=1,npz
      DO j=jsd,jed
        DO i=is,ie+1
          IF (cx(i, j, k) .GT. 0.) THEN
            xfx(i, j, k) = cx(i, j, k)*dxa(i-1, j)*dy(i, j)*sin_sg(i-1, &
&             j, 3)
          ELSE
            xfx(i, j, k) = cx(i, j, k)*dxa(i, j)*dy(i, j)*sin_sg(i, j, 1&
&             )
          END IF
        END DO
      END DO
      DO j=js,je+1
        DO i=isd,ied
          IF (cy(i, j, k) .GT. 0.) THEN
            yfx(i, j, k) = cy(i, j, k)*dya(i, j-1)*dx(i, j)*sin_sg(i, j-&
&             1, 4)
          ELSE
            yfx(i, j, k) = cy(i, j, k)*dya(i, j)*dx(i, j)*sin_sg(i, j, 2&
&             )
          END IF
        END DO
      END DO
    END DO
!--------------------------------------------------------------------------------
    IF (q_split .EQ. 0) THEN
! Determine nsplt
!#ifdef IBM_FIX
!!$omp parallel do default(shared) private(cmax_x, cmax_y)
!      do k=1,npz
!        cmax(k) = 0.
!        do j=js,je
!          do i=is,ie
!            cmax_x  = max(abs(cx(i,j,k))+1.-sina_u(i,j), cmax(k))
!            cmax_y  = max(abs(cy(i,j,k))+1.-sina_v(i,j), cmax(k))
!            cmax(k) = max(cmax_x, cmax_y)
!          enddo
!        enddo
!      enddo
!#else 
!$omp parallel do default(shared) 
      DO k=1,npz
        cmax(k) = 0.
        DO j=js,je
          DO i=is,ie
            IF (cx(i, j, k) .GE. 0.) THEN
              abs0 = cx(i, j, k)
            ELSE
              abs0 = -cx(i, j, k)
            END IF
            x1 = abs0 + 1. - sina_u(i, j)
            IF (cy(i, j, k) .GE. 0.) THEN
              abs1 = cy(i, j, k)
            ELSE
              abs1 = -cy(i, j, k)
            END IF
            y1 = abs1 + 1. - sina_v(i, j)
            IF (x1 .LT. y1) THEN
              IF (y1 .LT. cmax(k)) THEN
                cmax(k) = cmax(k)
              ELSE
                cmax(k) = y1
              END IF
            ELSE IF (x1 .LT. cmax(k)) THEN
              cmax(k) = cmax(k)
            ELSE
              cmax(k) = x1
            END IF
          END DO
        END DO
      END DO
      CALL MP_REDUCE_MAX(cmax, npz)
!#endif
! find global max courant number and define nsplt to scale cx,cy,mfx,mfy
      c_global = cmax(1)
      IF (npz .NE. 1) THEN
! if NOT shallow water test case
        DO k=2,npz
          IF (cmax(k) .LT. c_global) THEN
            c_global = c_global
          ELSE
            c_global = cmax(k)
          END IF
        END DO
      END IF
      nsplt = INT(1. + c_global)
      IF (gid .EQ. 0 .AND. nsplt .GT. 5) WRITE(6, *) 'Tracer_2d_split='&
&                                        , nsplt, c_global
    ELSE
      nsplt = q_split
    END IF
!--------------------------------------------------------------------------------
    frac = 1./REAL(nsplt)
    IF (nsplt .NE. 1) THEN
!$omp parallel do default(shared)
      DO k=1,npz
        DO j=jsd,jed
          DO i=is,ie+1
            cx(i, j, k) = cx(i, j, k)*frac
            xfx(i, j, k) = xfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je
          DO i=is,ie+1
            mfx(i, j, k) = mfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je+1
          DO i=isd,ied
            cy(i, j, k) = cy(i, j, k)*frac
            yfx(i, j, k) = yfx(i, j, k)*frac
          END DO
        END DO
        DO j=js,je+1
          DO i=is,ie
            mfy(i, j, k) = mfy(i, j, k)*frac
          END DO
        END DO
      END DO
    END IF
    DO it=1,nsplt
      CALL TIMING_ON('COMM_TOTAL')
      CALL TIMING_ON('COMM_TRAC')
      CALL MPP_UPDATE_DOMAINS(q, domain, complete=.true.)
      CALL TIMING_OFF('COMM_TRAC')
      CALL TIMING_OFF('COMM_TOTAL')
!$omp parallel do default(shared) private(ra_x, ra_y, dp2, fx, fy)
      DO k=1,npz
        DO j=jsd,jed
          DO i=is,ie
            ra_x(i, j) = area(i, j) + xfx(i, j, k) - xfx(i+1, j, k)
          END DO
        END DO
        DO j=js,je
          DO i=isd,ied
            ra_y(i, j) = area(i, j) + yfx(i, j, k) - yfx(i, j+1, k)
          END DO
        END DO
        DO j=js,je
          DO i=is,ie
            dp2(i, j) = dp1(i, j, k) + (mfx(i, j, k)-mfx(i+1, j, k)+mfy(&
&             i, j, k)-mfy(i, j+1, k))*rarea(i, j)
          END DO
        END DO
        CALL TIMING_ON('fv_tp_2d')
        DO iq=qs,nq
          CALL FV_TP_2D(q(isd:, jsd:, k, iq), cx(is:, jsd:, k), cy(isd:&
&                 , js:, k), npx, npy, hord, fx, fy, xfx(is:, jsd:, k), &
&                 yfx(isd:, js:, k), ra_x, ra_y, mfx=mfx(is:, js:, k), &
&                 mfy=mfy(is:, js:, k))
          DO j=js,je
            DO i=is,ie
              q(i, j, k, iq) = (q(i, j, k, iq)*dp1(i, j, k)+(fx(i, j)-fx&
&               (i+1, j)+fy(i, j)-fy(i, j+1))*rarea(i, j))/dp2(i, j)
            END DO
          END DO
        END DO
        CALL TIMING_OFF('fv_tp_2d')
        DO j=js,je
          DO i=is,ie
            dp1(i, j, k) = dp2(i, j)
          END DO
        END DO
      END DO
    END DO
! npz
! nsplt
! rescale mass fluxes back to original
    mfx = mfx/frac
    mfy = mfy/frac
    cx = cx/frac
    cy = cy/frac
    IF (PRESENT(dpa)) dpa = dp1
    IF (id_divg .GT. 0) THEN
      rdt = 1./(frac*dt)
!$omp parallel do default(shared)
      DO k=1,npz
        DO j=js,je
          DO i=is,ie
            dp1(i, j, k) = (xfx(i+1, j, k)-xfx(i, j, k)+yfx(i, j+1, k)-&
&             yfx(i, j, k))*rarea(i, j)*rdt
          END DO
        END DO
      END DO
    END IF
  END SUBROUTINE TRACER_2D
!  Differentiation of calcscalingfactor in reverse (adjoint) mode:
!   gradient     of useful results: scaling q1
!   with respect to varying inputs: q1
!------------------------------------------------------------------------------------
  SUBROUTINE CALCSCALINGFACTOR_ADM(q1, q1_ad, dp2, ple1, npx, npy, npz, &
&   is, ie, js, je, scaling_ad)
    USE MPP_MOD_B, ONLY : mpp_sum, mpp_sum_adm
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, is, ie, js, je
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
    REAL(real8), INTENT(IN) :: q1(is:ie, js:je, npz)
    REAL(real8) :: q1_ad(is:ie, js:je, npz)
    REAL(real8), INTENT(IN) :: dp2(is:ie, js:je, npz)
    REAL(real8), INTENT(IN) :: ple1(is:ie, js:je, npz+1)
    REAL(real8) :: scaling
    REAL(real8) :: scaling_ad
    INTEGER :: k
    REAL(real8) :: partialsums(2, npz), globalsums(2)
    REAL(real8) :: partialsums_ad(2, npz), globalsums_ad(2)
    REAL(real8), PARAMETER :: tiny_denominator=1.0e-30
    INTRINSIC SUM
    INTRINSIC REAL
    REAL(real8) :: temp_ad
!-------
! Compute partial sum on local array first to minimize communication.
! This algorithm will not be strongly repdroducible under changes do domain
! decomposition, but uses far less communication bandwidth (and memory BW)
! then the preceding implementation.
!-------
    DO k=1,npz
! numerator
      partialsums(1, k) = SUM(q1(:, :, k)*dp2(:, :, k)*area(is:ie, js:je&
&       ))
! denominator
      partialsums(2, k) = SUM(q1(:, :, k)*(ple1(:, :, k+1)-ple1(:, :, k)&
&       )*area(is:ie, js:je))
    END DO
    globalsums(1) = SUM(partialsums(1, :))
    globalsums(2) = SUM(partialsums(2, :))
    CALL PUSHREAL8ARRAY(globalsums, 2)
    CALL MPP_SUM(globalsums, 2)
    IF (globalsums(2) .GT. tiny_denominator) THEN
      scaling = globalsums(1)/globalsums(2)
!#################################################################
! This line was added to ensure strong reproducibility of the code
!#################################################################
      globalsums_ad = 0.0_8
      temp_ad = scaling_ad/globalsums(2)
      globalsums_ad(1) = globalsums_ad(1) + temp_ad
      globalsums_ad(2) = globalsums_ad(2) - globalsums(1)*temp_ad/&
&       globalsums(2)
    ELSE
      globalsums_ad = 0.0_8
    END IF
    CALL POPREAL8ARRAY(globalsums, 2)
    CALL MPP_SUM_ADM(globalsums, globalsums_ad, 2)
    partialsums_ad = 0.0_8
    partialsums_ad(2, :) = partialsums_ad(2, :) + globalsums_ad(2)
    globalsums_ad(2) = 0.0_8
    partialsums_ad(1, :) = partialsums_ad(1, :) + globalsums_ad(1)
    DO k=npz,1,-1
      q1_ad(:, :, k) = q1_ad(:, :, k) + area(is:ie, js:je)*(ple1(:, :, k&
&       +1)-ple1(:, :, k))*partialsums_ad(2, k)
      partialsums_ad(2, k) = 0.0_8
      q1_ad(:, :, k) = q1_ad(:, :, k) + dp2(:, :, k)*area(is:ie, js:je)*&
&       partialsums_ad(1, k)
      partialsums_ad(1, k) = 0.0_8
    END DO
  END SUBROUTINE CALCSCALINGFACTOR_ADM
!------------------------------------------------------------------------------------
  FUNCTION CALCSCALINGFACTOR(q1, dp2, ple1, npx, npy, npz, is, ie, js, &
&   je) RESULT (SCALING)
    USE MPP_MOD_B, ONLY : mpp_sum
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, is, ie, js, je
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
    REAL(real8), INTENT(IN) :: q1(is:ie, js:je, npz)
    REAL(real8), INTENT(IN) :: dp2(is:ie, js:je, npz)
    REAL(real8), INTENT(IN) :: ple1(is:ie, js:je, npz+1)
    REAL(real8) :: scaling
    INTEGER :: k
    REAL(real8) :: partialsums(2, npz), globalsums(2)
    REAL(real8), PARAMETER :: tiny_denominator=1.0e-30
    INTRINSIC SUM
    INTRINSIC REAL
!-------
! Compute partial sum on local array first to minimize communication.
! This algorithm will not be strongly repdroducible under changes do domain
! decomposition, but uses far less communication bandwidth (and memory BW)
! then the preceding implementation.
!-------
    DO k=1,npz
! numerator
      partialsums(1, k) = SUM(q1(:, :, k)*dp2(:, :, k)*area(is:ie, js:je&
&       ))
! denominator
      partialsums(2, k) = SUM(q1(:, :, k)*(ple1(:, :, k+1)-ple1(:, :, k)&
&       )*area(is:ie, js:je))
    END DO
    globalsums(1) = SUM(partialsums(1, :))
    globalsums(2) = SUM(partialsums(2, :))
    CALL MPP_SUM(globalsums, 2)
    IF (globalsums(2) .GT. tiny_denominator) THEN
      scaling = globalsums(1)/globalsums(2)
!#################################################################
! This line was added to ensure strong reproducibility of the code
!#################################################################
      scaling = REAL(scaling, kind=real4)
    ELSE
      scaling = 1.d0
    END IF
  END FUNCTION CALCSCALINGFACTOR
!------------------------------------------------------------------------------------
  FUNCTION COMPUTESCALINGFACTORS(q1, dp2, ple1, npx, npy, npz, is, ie, &
&   js, je) RESULT (SCALING)
    USE MPP_MOD_B, ONLY : mpp_sum
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, is, ie, js, je
    INTEGER, INTENT(IN) :: npy
    INTEGER, INTENT(IN) :: npz
    REAL(real8), INTENT(IN) :: q1(is:ie, js:je, npz)
    REAL(real8), INTENT(IN) :: dp2(is:ie, js:je, npz)
    REAL(real8), INTENT(IN) :: ple1(is:ie, js:je, npz+1)
    REAL(real8) :: scaling(npz)
    INTEGER :: k
    REAL(real8) :: partialsums(2, npz), globalsums(2, npz)
    REAL(real8), PARAMETER :: tiny_denominator=1.0e-30
    INTRINSIC SUM
    INTEGER :: arg1
!-------
! Compute partial sum on local array first to minimize communication.
! This algorithm will not be strongly repdroducible under changes do domain
! decomposition, but uses far less communication bandwidth (and memory BW)
! then the preceding implementation.
!-------
    DO k=1,npz
! numerator
      partialsums(1, k) = SUM(q1(:, :, k)*dp2(:, :, k)*area(is:ie, js:je&
&       ))
! denominator
      partialsums(2, k) = SUM(q1(:, :, k)*(ple1(:, :, k+1)-ple1(:, :, k)&
&       )*area(is:ie, js:je))
    END DO
    arg1 = 2*npz
    CALL MPP_SUM(partialsums, arg1)
    globalsums = partialsums
    DO k=1,npz
      IF (partialsums(2, k) .GT. tiny_denominator) THEN
        scaling(k) = globalsums(1, k)/globalsums(2, k)
      ELSE
        scaling(k) = 1.d0
      END IF
    END DO
  END FUNCTION COMPUTESCALINGFACTORS
END MODULE FV_TRACER2D_MOD_B
