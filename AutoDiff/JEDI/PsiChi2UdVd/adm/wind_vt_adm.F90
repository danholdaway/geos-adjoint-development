!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.13 (r6666) - 27 Nov 2017 17:09
!
! (C) Copyright 2018 UCAR
! 
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0. 
!> Variable transforms on wind variables for fv3-jedi 
!> Daniel Holdaway, NASA/JCSDA
MODULE WIND_VT_MOD_DIFF
  USE FV3JEDI_GEOM_MOD_DIFF
  USE MPP_DOMAINS_MOD_DIFF
  IMPLICIT NONE
!----------------------------------------------------------------------------
  PRIVATE 
  PUBLIC psichi_to_udvd
  PUBLIC psichi_to_udvd_adm

CONTAINS
!  Differentiation of psichi_to_udvd in reverse (adjoint) mode:
!   gradient     of useful results: psi u v chi
!   with respect to varying inputs: psi u v chi
!   RW status of diff variables: psi:in-out u:in-out v:in-out chi:in-out
!----------------------------------------------------------------------------
  SUBROUTINE PSICHI_TO_UDVD_ADM(geom, psi, psi_ad, chi, chi_ad, u, u_ad&
&   , v, v_ad)
    IMPLICIT NONE
    TYPE(FV3JEDI_GEOM), INTENT(INOUT) :: geom
!Stream function
    REAL(kind=kind_real), INTENT(INOUT) :: psi(geom%bd%isd:geom%bd%ied, &
&   geom%bd%jsd:geom%bd%jed, geom%npz)
    REAL(kind=kind_real), INTENT(INOUT) :: psi_ad(geom%bd%isd:geom%bd%&
&   ied, geom%bd%jsd:geom%bd%jed, geom%npz)
!Velocity potential
    REAL(kind=kind_real), INTENT(INOUT) :: chi(geom%bd%isd:geom%bd%ied, &
&   geom%bd%jsd:geom%bd%jed, geom%npz)
    REAL(kind=kind_real), INTENT(INOUT) :: chi_ad(geom%bd%isd:geom%bd%&
&   ied, geom%bd%jsd:geom%bd%jed, geom%npz)
!Dgrid winds (u)
    REAL(kind=kind_real) :: u(geom%bd%isd:geom%bd%ied, geom%bd%jsd:geom%&
&   bd%jed+1, geom%npz)
    REAL(kind=kind_real) :: u_ad(geom%bd%isd:geom%bd%ied, geom%bd%jsd:&
&   geom%bd%jed+1, geom%npz)
!Dgrid winds (v)
    REAL(kind=kind_real) :: v(geom%bd%isd:geom%bd%ied+1, geom%bd%jsd:&
&   geom%bd%jed, geom%npz)
    REAL(kind=kind_real) :: v_ad(geom%bd%isd:geom%bd%ied+1, geom%bd%jsd:&
&   geom%bd%jed, geom%npz)
    INTEGER :: i, j, k
    REAL(kind=kind_real) :: chib(geom%bd%isd:geom%bd%ied, geom%bd%jsd:&
&   geom%bd%jed, geom%npz)
    REAL(kind=kind_real) :: chib_ad(geom%bd%isd:geom%bd%ied, geom%bd%jsd&
&   :geom%bd%jed, geom%npz)
!       x-----------------x
!       |                 |
!       |                 |
!       |                 |
!     vd|        x        |
!       |     psi,chi     |
!       |                 |
!       |                 |
!       |                 |
!       x-----------------x
!               ud
!Fill halos of psi and chi
!Interpolate chi to the B grid
    REAL(kind=kind_real) :: temp_ad
    REAL(kind=kind_real) :: temp_ad0
    REAL(kind=kind_real) :: temp_ad1
    REAL(kind=kind_real) :: temp_ad2
    chib_ad = 0.0_8
    DO k=geom%npz,1,-1
      DO j=geom%bd%jec,geom%bd%jsc,-1
        DO i=geom%bd%iec,geom%bd%isc,-1
          temp_ad = v_ad(i, j, k)/geom%dy(i, j)
          temp_ad0 = -(v_ad(i, j, k)/geom%dxc(i, j))
          chib_ad(i, j+1, k) = chib_ad(i, j+1, k) + temp_ad
          chib_ad(i, j, k) = chib_ad(i, j, k) - temp_ad
          psi_ad(i+1, j, k) = psi_ad(i+1, j, k) + temp_ad0
          psi_ad(i, j, k) = psi_ad(i, j, k) - temp_ad0
          v_ad(i, j, k) = 0.0_8
          temp_ad1 = u_ad(i, j, k)/geom%dyc(i, j)
          temp_ad2 = u_ad(i, j, k)/geom%dx(i, j)
          psi_ad(i, j+1, k) = psi_ad(i, j+1, k) + temp_ad1
          psi_ad(i, j, k) = psi_ad(i, j, k) - temp_ad1
          chib_ad(i+1, j, k) = chib_ad(i+1, j, k) + temp_ad2
          chib_ad(i, j, k) = chib_ad(i, j, k) - temp_ad2
          u_ad(i, j, k) = 0.0_8
        END DO
      END DO
    END DO
    CALL A2B_ORD4_ADM(chi, chi_ad, chib, chib_ad, geom, geom%npx, geom%&
&               npy, geom%bd%isc, geom%bd%iec, geom%bd%jsc, geom%bd%jec&
&               , geom%halo)
    CALL MPP_UPDATE_DOMAINS_ADM(chi, chi_ad, geom%domain, complete=&
&                         .true.)
    CALL MPP_UPDATE_DOMAINS_ADM(psi, psi_ad, geom%domain, complete=&
&                         .true.)
  END SUBROUTINE PSICHI_TO_UDVD_ADM
!----------------------------------------------------------------------------
  SUBROUTINE PSICHI_TO_UDVD(geom, psi, chi, u, v)
    IMPLICIT NONE
    TYPE(FV3JEDI_GEOM), INTENT(INOUT) :: geom
!Stream function
    REAL(kind=kind_real), INTENT(INOUT) :: psi(geom%bd%isd:geom%bd%ied, &
&   geom%bd%jsd:geom%bd%jed, geom%npz)
!Velocity potential
    REAL(kind=kind_real), INTENT(INOUT) :: chi(geom%bd%isd:geom%bd%ied, &
&   geom%bd%jsd:geom%bd%jed, geom%npz)
!Dgrid winds (u)
    REAL(kind=kind_real), INTENT(OUT) :: u(geom%bd%isd:geom%bd%ied, geom&
&   %bd%jsd:geom%bd%jed+1, geom%npz)
!Dgrid winds (v)
    REAL(kind=kind_real), INTENT(OUT) :: v(geom%bd%isd:geom%bd%ied+1, &
&   geom%bd%jsd:geom%bd%jed, geom%npz)
    INTEGER :: i, j, k
    REAL(kind=kind_real) :: chib(geom%bd%isd:geom%bd%ied, geom%bd%jsd:&
&   geom%bd%jed, geom%npz)
!       x-----------------x
!       |                 |
!       |                 |
!       |                 |
!     vd|        x        |
!       |     psi,chi     |
!       |                 |
!       |                 |
!       |                 |
!       x-----------------x
!               ud
!Fill halos of psi and chi
    CALL MPP_UPDATE_DOMAINS(psi, geom%domain, complete=.true.)
    CALL MPP_UPDATE_DOMAINS(chi, geom%domain, complete=.true.)
!Interpolate chi to the B grid
    CALL A2B_ORD4(chi, chib, geom, geom%npx, geom%npy, geom%bd%isc, geom&
&           %bd%iec, geom%bd%jsc, geom%bd%jec, geom%halo)
    DO k=1,geom%npz
      DO j=geom%bd%jsc,geom%bd%jec
        DO i=geom%bd%isc,geom%bd%iec
          u(i, j, k) = (psi(i, j+1, k)-psi(i, j, k))/geom%dyc(i, j) + (&
&           chib(i+1, j, k)-chib(i, j, k))/geom%dx(i, j)
          v(i, j, k) = -((psi(i+1, j, k)-psi(i, j, k))/geom%dxc(i, j)) +&
&           (chib(i, j+1, k)-chib(i, j, k))/geom%dy(i, j)
        END DO
      END DO
    END DO
  END SUBROUTINE PSICHI_TO_UDVD
!  Differentiation of a2b_ord4 in reverse (adjoint) mode:
!   gradient     of useful results: qin qout
!   with respect to varying inputs: qin
!----------------------------------------------------------------------------
  SUBROUTINE A2B_ORD4_ADM(qin, qin_ad, qout, qout_ad, geom, npx, npy, is&
&   , ie, js, je, ng)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, is, ie, js, je, ng
! A-grid field
    REAL(kind=kind_real), INTENT(IN) :: qin(is-ng:ie+ng, js-ng:je+ng)
    REAL(kind=kind_real) :: qin_ad(is-ng:ie+ng, js-ng:je+ng)
! Output  B-grid field
    REAL(kind=kind_real) :: qout(is-ng:ie+ng, js-ng:je+ng)
    REAL(kind=kind_real) :: qout_ad(is-ng:ie+ng, js-ng:je+ng)
    TYPE(FV3JEDI_GEOM), INTENT(IN), TARGET :: geom
    REAL(kind=kind_real) :: qx(is:ie+1, js-ng:je+ng)
    REAL(kind=kind_real) :: qx_ad(is:ie+1, js-ng:je+ng)
    REAL(kind=kind_real) :: qy(is-ng:ie+ng, js:je+1)
    REAL(kind=kind_real) :: qy_ad(is-ng:ie+ng, js:je+1)
    REAL(kind=kind_real) :: qxx(is-ng:ie+ng, js-ng:je+ng)
    REAL(kind=kind_real) :: qxx_ad(is-ng:ie+ng, js-ng:je+ng)
    REAL(kind=kind_real) :: qyy(is-ng:ie+ng, js-ng:je+ng)
    REAL(kind=kind_real) :: qyy_ad(is-ng:ie+ng, js-ng:je+ng)
    REAL(kind=kind_real) :: g_in, g_ou
    REAL(kind=kind_real) :: p0(2)
    REAL(kind=kind_real) :: q1(is-1:ie+1), q2(js-1:je+1)
    REAL(kind=kind_real) :: q1_ad(is-1:ie+1), q2_ad(js-1:je+1)
    INTEGER :: i, j, is1, js1, is2, js2, ie1, je1
    REAL(kind=kind_real), PARAMETER :: c1=2./3.
    REAL(kind=kind_real), PARAMETER :: c2=-(1./6.)
    REAL(kind=kind_real), PARAMETER :: r3=1./3.
!  9/16
    REAL(kind=kind_real), PARAMETER :: a1=0.5625
! -1/16
    REAL(kind=kind_real), PARAMETER :: a2=-0.0625
! 0.58333333
    REAL(kind=kind_real), PARAMETER :: b1=7./12.
    REAL(kind=kind_real), PARAMETER :: b2=-(1./12.)
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: max5
    INTEGER :: max6
    INTEGER :: max7
    INTEGER :: max8
    INTEGER :: max9
    INTEGER :: max10
    INTEGER :: max11
    INTEGER :: max12
    INTEGER :: max13
    INTEGER :: max14
    INTEGER :: max15
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    INTEGER :: min5
    INTEGER :: min6
    INTEGER :: min7
    INTEGER :: min8
    INTEGER :: min9
    INTEGER :: min10
    INTEGER :: min11
    INTEGER :: min12
    INTEGER :: min13
    INTEGER :: min14
    INTEGER :: min15
    REAL(kind=kind_real) :: result1
    REAL(kind=kind_real) :: result1_ad
    REAL(kind=kind_real) :: result2
    REAL(kind=kind_real) :: result2_ad
    REAL(kind=kind_real) :: result3
    REAL(kind=kind_real) :: result3_ad
    REAL(kind=kind_real) :: temp_ad
    REAL(kind=kind_real) :: temp_ad0
    REAL(kind=kind_real) :: temp_ad1
    REAL(kind=kind_real) :: temp_ad2
    REAL(kind=kind_real) :: temp_ad3
    REAL*8 :: temp_ad4
    REAL*8 :: temp_ad5
    REAL*8 :: temp_ad6
    REAL*8 :: temp_ad7
    REAL(kind=kind_real) :: temp_ad8
    REAL*8 :: temp_ad9
    REAL*8 :: temp_ad10
    REAL*8 :: temp_ad11
    REAL*8 :: temp_ad12
    REAL(kind=kind_real) :: temp_ad13
    REAL*8 :: temp_ad14
    REAL*8 :: temp_ad15
    REAL*8 :: temp_ad16
    REAL*8 :: temp_ad17
    REAL(kind=kind_real) :: temp_ad18
    REAL*8 :: temp_ad19
    REAL*8 :: temp_ad20
    REAL*8 :: temp_ad21
    REAL*8 :: temp_ad22
    INTEGER :: ad_from
    INTEGER :: ad_to
    INTEGER :: ad_from0
    INTEGER :: ad_to0
    INTEGER :: ad_from1
    INTEGER :: ad_to1
    INTEGER :: ad_from2
    INTEGER :: ad_to2
    INTEGER :: ad_from3
    INTEGER :: ad_to3
    INTEGER :: branch
    IF (1 .LT. is - 1) THEN
      is1 = is - 1
    ELSE
      is1 = 1
    END IF
    IF (1 .LT. js - 1) THEN
      js1 = js - 1
    ELSE
      js1 = 1
    END IF
    IF (2 .LT. is) THEN
      is2 = is
    ELSE
      is2 = 2
    END IF
    IF (2 .LT. js) THEN
      js2 = js
    ELSE
      js2 = 2
    END IF
    IF (npx - 1 .GT. ie + 1) THEN
      ie1 = ie + 1
    ELSE
      ie1 = npx - 1
    END IF
    IF (npy - 1 .GT. je + 1) THEN
      je1 = je + 1
    ELSE
      je1 = npy - 1
    END IF
! Corners:
! 3-way extrapolation
    IF (geom%sw_corner) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (geom%se_corner) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (geom%ne_corner) THEN
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (geom%nw_corner) THEN
      p0(1:2) = geom%grid(1, npy, 1:2)
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (1 .LT. js - 2) THEN
      max1 = js - 2
    ELSE
      max1 = 1
    END IF
    IF (npy - 1 .GT. je + 2) THEN
      min1 = je + 2
    ELSE
      min1 = npy - 1
    END IF
!------------
! X-Interior:
!------------
    DO j=max1,min1
      IF (3 .LT. is) THEN
        max2 = is
      ELSE
        max2 = 3
      END IF
      IF (npx - 2 .GT. ie + 1) THEN
        min2 = ie + 1
      ELSE
        min2 = npx - 2
      END IF
      ad_from = max2
      i = min2 + 1
      CALL PUSHINTEGER4(i - 1)
      CALL PUSHINTEGER4(ad_from)
    END DO
! *** West Edges:
    IF (is .EQ. 1) THEN
      IF (1 .LT. js - 2) THEN
        max3 = js - 2
      ELSE
        max3 = 1
      END IF
      IF (npy - 1 .GT. je + 2) THEN
        min3 = je + 2
      ELSE
        min3 = npy - 1
      END IF
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! East Edges:
    IF (ie + 1 .EQ. npx) THEN
      IF (1 .LT. js - 2) THEN
        max4 = js - 2
      ELSE
        max4 = 1
      END IF
      IF (npy - 1 .GT. je + 2) THEN
        min4 = je + 2
      ELSE
        min4 = npy - 1
      END IF
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (3 .LT. js) THEN
      max5 = js
    ELSE
      max5 = 3
    END IF
    IF (npy - 2 .GT. je + 1) THEN
      min5 = je + 1
    ELSE
      min5 = npy - 2
    END IF
!------------
! Y-Interior:
!------------
    DO j=max5,min5
      IF (1 .LT. is - 2) THEN
        max6 = is - 2
      ELSE
        max6 = 1
      END IF
      IF (npx - 1 .GT. ie + 2) THEN
        min6 = ie + 2
      ELSE
        min6 = npx - 1
      END IF
      ad_from0 = max6
      i = min6 + 1
      CALL PUSHINTEGER4(i - 1)
      CALL PUSHINTEGER4(ad_from0)
    END DO
! South Edges:
    IF (js .EQ. 1) THEN
      IF (1 .LT. is - 2) THEN
        max7 = is - 2
      ELSE
        max7 = 1
      END IF
      IF (npx - 1 .GT. ie + 2) THEN
        min7 = ie + 2
      ELSE
        min7 = npx - 1
      END IF
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
! North Edges:
    IF (je + 1 .EQ. npy) THEN
      IF (1 .LT. is - 2) THEN
        max8 = is - 2
      ELSE
        max8 = 1
      END IF
      IF (npx - 1 .GT. ie + 2) THEN
        min8 = ie + 2
      ELSE
        min8 = npx - 1
      END IF
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (3 .LT. js) THEN
      max9 = js
    ELSE
      max9 = 3
    END IF
    IF (npy - 2 .GT. je + 1) THEN
      min9 = je + 1
    ELSE
      min9 = npy - 2
    END IF
!--------------------------------------
    DO j=max9,min9
      IF (2 .LT. is) THEN
        max10 = is
      ELSE
        max10 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        min10 = ie + 1
      ELSE
        min10 = npx - 1
      END IF
      ad_from1 = max10
      i = min10 + 1
      CALL PUSHINTEGER4(i - 1)
      CALL PUSHINTEGER4(ad_from1)
    END DO
    IF (js .EQ. 1) THEN
      IF (2 .LT. is) THEN
        max11 = is
      ELSE
        max11 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        min11 = ie + 1
      ELSE
        min11 = npx - 1
      END IF
      CALL PUSHCONTROL1B(0)
    ELSE
      CALL PUSHCONTROL1B(1)
    END IF
    IF (je + 1 .EQ. npy) THEN
      IF (2 .LT. is) THEN
        max12 = is
      ELSE
        max12 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        min12 = ie + 1
      ELSE
        min12 = npx - 1
      END IF
      CALL PUSHCONTROL1B(1)
    ELSE
      CALL PUSHCONTROL1B(0)
    END IF
    IF (2 .LT. js) THEN
      max13 = js
    ELSE
      max13 = 2
    END IF
    IF (npy - 1 .GT. je + 1) THEN
      min13 = je + 1
    ELSE
      min13 = npy - 1
    END IF
    DO j=max13,min13
      IF (3 .LT. is) THEN
        max14 = is
      ELSE
        max14 = 3
      END IF
      IF (npx - 2 .GT. ie + 1) THEN
        min14 = ie + 1
      ELSE
        min14 = npx - 2
      END IF
      ad_from2 = max14
      i = min14 + 1
      CALL PUSHINTEGER4(i - 1)
      CALL PUSHINTEGER4(ad_from2)
      IF (is .EQ. 1) THEN
        CALL PUSHCONTROL1B(0)
      ELSE
        CALL PUSHCONTROL1B(1)
      END IF
      IF (ie + 1 .EQ. npx) THEN
        CALL PUSHCONTROL1B(1)
      ELSE
        CALL PUSHCONTROL1B(0)
      END IF
      IF (2 .LT. is) THEN
        max15 = is
      ELSE
        max15 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        min15 = ie + 1
      ELSE
        min15 = npx - 1
      END IF
      ad_from3 = max15
      i = min15 + 1
      CALL PUSHINTEGER4(i - 1)
      CALL PUSHINTEGER4(ad_from3)
    END DO
    qy_ad = 0.0_8
    qxx_ad = 0.0_8
    qyy_ad = 0.0_8
    DO j=min13,max13,-1
      CALL POPINTEGER4(ad_from3)
      CALL POPINTEGER4(ad_to3)
      DO i=ad_to3,ad_from3,-1
        qxx_ad(i, j) = qxx_ad(i, j) + 0.5*qout_ad(i, j)
        qyy_ad(i, j) = qyy_ad(i, j) + 0.5*qout_ad(i, j)
        qout_ad(i, j) = 0.0_8
      END DO
      CALL POPCONTROL1B(branch)
      IF (branch .NE. 0) THEN
        qy_ad(npx-2, j) = qy_ad(npx-2, j) + c1*qyy_ad(npx-1, j)
        qy_ad(npx-1, j) = qy_ad(npx-1, j) + c1*qyy_ad(npx-1, j)
        qout_ad(npx, j) = qout_ad(npx, j) + c2*qyy_ad(npx-1, j)
        qyy_ad(npx-2, j) = qyy_ad(npx-2, j) + c2*qyy_ad(npx-1, j)
        qyy_ad(npx-1, j) = 0.0_8
      END IF
      CALL POPCONTROL1B(branch)
      IF (branch .EQ. 0) THEN
        qy_ad(1, j) = qy_ad(1, j) + c1*qyy_ad(2, j)
        qy_ad(2, j) = qy_ad(2, j) + c1*qyy_ad(2, j)
        qout_ad(1, j) = qout_ad(1, j) + c2*qyy_ad(2, j)
        qyy_ad(3, j) = qyy_ad(3, j) + c2*qyy_ad(2, j)
        qyy_ad(2, j) = 0.0_8
      END IF
      CALL POPINTEGER4(ad_from2)
      CALL POPINTEGER4(ad_to2)
      DO i=ad_to2,ad_from2,-1
        qy_ad(i-2, j) = qy_ad(i-2, j) + a2*qyy_ad(i, j)
        qy_ad(i+1, j) = qy_ad(i+1, j) + a2*qyy_ad(i, j)
        qy_ad(i-1, j) = qy_ad(i-1, j) + a1*qyy_ad(i, j)
        qy_ad(i, j) = qy_ad(i, j) + a1*qyy_ad(i, j)
        qyy_ad(i, j) = 0.0_8
      END DO
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      qx_ad = 0.0_8
    ELSE
      qx_ad = 0.0_8
      DO i=min12,max12,-1
        qx_ad(i, npy-2) = qx_ad(i, npy-2) + c1*qxx_ad(i, npy-1)
        qx_ad(i, npy-1) = qx_ad(i, npy-1) + c1*qxx_ad(i, npy-1)
        qout_ad(i, npy) = qout_ad(i, npy) + c2*qxx_ad(i, npy-1)
        qxx_ad(i, npy-2) = qxx_ad(i, npy-2) + c2*qxx_ad(i, npy-1)
        qxx_ad(i, npy-1) = 0.0_8
      END DO
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO i=min11,max11,-1
        qx_ad(i, 1) = qx_ad(i, 1) + c1*qxx_ad(i, 2)
        qx_ad(i, 2) = qx_ad(i, 2) + c1*qxx_ad(i, 2)
        qout_ad(i, 1) = qout_ad(i, 1) + c2*qxx_ad(i, 2)
        qxx_ad(i, 3) = qxx_ad(i, 3) + c2*qxx_ad(i, 2)
        qxx_ad(i, 2) = 0.0_8
      END DO
    END IF
    DO j=min9,max9,-1
      CALL POPINTEGER4(ad_from1)
      CALL POPINTEGER4(ad_to1)
      DO i=ad_to1,ad_from1,-1
        qx_ad(i, j-2) = qx_ad(i, j-2) + a2*qxx_ad(i, j)
        qx_ad(i, j+1) = qx_ad(i, j+1) + a2*qxx_ad(i, j)
        qx_ad(i, j-1) = qx_ad(i, j-1) + a1*qxx_ad(i, j)
        qx_ad(i, j) = qx_ad(i, j) + a1*qxx_ad(i, j)
        qxx_ad(i, j) = 0.0_8
      END DO
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      q1_ad = 0.0_8
    ELSE
      DO i=min8,max8,-1
        g_in = geom%dya(i, npy-2)/geom%dya(i, npy-1)
        temp_ad19 = qy_ad(i, npy-1)/(g_in*2.+2.)
        qin_ad(i, npy-2) = qin_ad(i, npy-2) + 3.*temp_ad19
        qy_ad(i, npy) = qy_ad(i, npy) - g_in*temp_ad19
        qy_ad(i, npy-2) = qy_ad(i, npy-2) - temp_ad19
        qy_ad(i, npy-1) = 0.0_8
        g_ou = geom%dya(i, npy+1)/geom%dya(i, npy)
        temp_ad21 = 0.5*qy_ad(i, npy)
        temp_ad20 = temp_ad21/(g_in+1.)
        qin_ad(i, npy-1) = qin_ad(i, npy-1) + (g_in+2.)*temp_ad20 + 3.*&
&         g_in*temp_ad19
        temp_ad22 = temp_ad21/(g_ou+1.)
        qin_ad(i, npy-2) = qin_ad(i, npy-2) - temp_ad20
        qin_ad(i, npy) = qin_ad(i, npy) + (g_ou+2.)*temp_ad22
        qin_ad(i, npy+1) = qin_ad(i, npy+1) - temp_ad22
        qy_ad(i, npy) = 0.0_8
      END DO
      q1_ad = 0.0_8
      DO i=ie1,is2,-1
        q1_ad(i-1) = q1_ad(i-1) + geom%edge_n(i)*qout_ad(i, npy)
        q1_ad(i) = q1_ad(i) + (1.-geom%edge_n(i))*qout_ad(i, npy)
        qout_ad(i, npy) = 0.0_8
      END DO
      DO i=ie1,is1,-1
        temp_ad18 = q1_ad(i)/(geom%dya(i, npy-1)+geom%dya(i, npy))
        qin_ad(i, npy-1) = qin_ad(i, npy-1) + geom%dya(i, npy)*temp_ad18
        qin_ad(i, npy) = qin_ad(i, npy) + geom%dya(i, npy-1)*temp_ad18
        q1_ad(i) = 0.0_8
      END DO
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO i=min7,max7,-1
        g_in = geom%dya(i, 2)/geom%dya(i, 1)
        temp_ad14 = qy_ad(i, 2)/(g_in*2.+2.)
        qin_ad(i, 1) = qin_ad(i, 1) + 3.*g_in*temp_ad14
        qin_ad(i, 2) = qin_ad(i, 2) + 3.*temp_ad14
        qy_ad(i, 1) = qy_ad(i, 1) - g_in*temp_ad14
        qy_ad(i, 3) = qy_ad(i, 3) - temp_ad14
        qy_ad(i, 2) = 0.0_8
        g_ou = geom%dya(i, -1)/geom%dya(i, 0)
        temp_ad15 = 0.5*qy_ad(i, 1)
        temp_ad16 = temp_ad15/(g_in+1.)
        temp_ad17 = temp_ad15/(g_ou+1.)
        qin_ad(i, 1) = qin_ad(i, 1) + (g_in+2.)*temp_ad16
        qin_ad(i, 2) = qin_ad(i, 2) - temp_ad16
        qin_ad(i, 0) = qin_ad(i, 0) + (g_ou+2.)*temp_ad17
        qin_ad(i, -1) = qin_ad(i, -1) - temp_ad17
        qy_ad(i, 1) = 0.0_8
      END DO
      DO i=ie1,is2,-1
        q1_ad(i-1) = q1_ad(i-1) + geom%edge_s(i)*qout_ad(i, 1)
        q1_ad(i) = q1_ad(i) + (1.-geom%edge_s(i))*qout_ad(i, 1)
        qout_ad(i, 1) = 0.0_8
      END DO
      DO i=ie1,is1,-1
        temp_ad13 = q1_ad(i)/(geom%dya(i, 0)+geom%dya(i, 1))
        qin_ad(i, 0) = qin_ad(i, 0) + geom%dya(i, 1)*temp_ad13
        qin_ad(i, 1) = qin_ad(i, 1) + geom%dya(i, 0)*temp_ad13
        q1_ad(i) = 0.0_8
      END DO
    END IF
    DO j=min5,max5,-1
      CALL POPINTEGER4(ad_from0)
      CALL POPINTEGER4(ad_to0)
      DO i=ad_to0,ad_from0,-1
        qin_ad(i, j-2) = qin_ad(i, j-2) + b2*qy_ad(i, j)
        qin_ad(i, j+1) = qin_ad(i, j+1) + b2*qy_ad(i, j)
        qin_ad(i, j-1) = qin_ad(i, j-1) + b1*qy_ad(i, j)
        qin_ad(i, j) = qin_ad(i, j) + b1*qy_ad(i, j)
        qy_ad(i, j) = 0.0_8
      END DO
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      q2_ad = 0.0_8
    ELSE
      DO j=min4,max4,-1
        g_in = geom%dxa(npx-2, j)/geom%dxa(npx-1, j)
        temp_ad9 = qx_ad(npx-1, j)/(g_in*2.+2.)
        qin_ad(npx-2, j) = qin_ad(npx-2, j) + 3.*temp_ad9
        qx_ad(npx, j) = qx_ad(npx, j) - g_in*temp_ad9
        qx_ad(npx-2, j) = qx_ad(npx-2, j) - temp_ad9
        qx_ad(npx-1, j) = 0.0_8
        g_ou = geom%dxa(npx+1, j)/geom%dxa(npx, j)
        temp_ad11 = 0.5*qx_ad(npx, j)
        temp_ad10 = temp_ad11/(g_in+1.)
        qin_ad(npx-1, j) = qin_ad(npx-1, j) + (g_in+2.)*temp_ad10 + 3.*&
&         g_in*temp_ad9
        temp_ad12 = temp_ad11/(g_ou+1.)
        qin_ad(npx-2, j) = qin_ad(npx-2, j) - temp_ad10
        qin_ad(npx, j) = qin_ad(npx, j) + (g_ou+2.)*temp_ad12
        qin_ad(npx+1, j) = qin_ad(npx+1, j) - temp_ad12
        qx_ad(npx, j) = 0.0_8
      END DO
      q2_ad = 0.0_8
      DO j=je1,js2,-1
        q2_ad(j-1) = q2_ad(j-1) + geom%edge_e(j)*qout_ad(npx, j)
        q2_ad(j) = q2_ad(j) + (1.-geom%edge_e(j))*qout_ad(npx, j)
        qout_ad(npx, j) = 0.0_8
      END DO
      DO j=je1,js1,-1
        temp_ad8 = q2_ad(j)/(geom%dxa(npx-1, j)+geom%dxa(npx, j))
        qin_ad(npx-1, j) = qin_ad(npx-1, j) + geom%dxa(npx, j)*temp_ad8
        qin_ad(npx, j) = qin_ad(npx, j) + geom%dxa(npx-1, j)*temp_ad8
        q2_ad(j) = 0.0_8
      END DO
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      DO j=min3,max3,-1
        g_in = geom%dxa(2, j)/geom%dxa(1, j)
        temp_ad4 = qx_ad(2, j)/(g_in*2.+2.)
        qin_ad(1, j) = qin_ad(1, j) + 3.*g_in*temp_ad4
        qin_ad(2, j) = qin_ad(2, j) + 3.*temp_ad4
        qx_ad(1, j) = qx_ad(1, j) - g_in*temp_ad4
        qx_ad(3, j) = qx_ad(3, j) - temp_ad4
        qx_ad(2, j) = 0.0_8
        g_ou = geom%dxa(-1, j)/geom%dxa(0, j)
        temp_ad5 = 0.5*qx_ad(1, j)
        temp_ad6 = temp_ad5/(g_in+1.)
        temp_ad7 = temp_ad5/(g_ou+1.)
        qin_ad(1, j) = qin_ad(1, j) + (g_in+2.)*temp_ad6
        qin_ad(2, j) = qin_ad(2, j) - temp_ad6
        qin_ad(0, j) = qin_ad(0, j) + (g_ou+2.)*temp_ad7
        qin_ad(-1, j) = qin_ad(-1, j) - temp_ad7
        qx_ad(1, j) = 0.0_8
      END DO
      DO j=je1,js2,-1
        q2_ad(j-1) = q2_ad(j-1) + geom%edge_w(j)*qout_ad(1, j)
        q2_ad(j) = q2_ad(j) + (1.-geom%edge_w(j))*qout_ad(1, j)
        qout_ad(1, j) = 0.0_8
      END DO
      DO j=je1,js1,-1
        temp_ad3 = q2_ad(j)/(geom%dxa(0, j)+geom%dxa(1, j))
        qin_ad(0, j) = qin_ad(0, j) + geom%dxa(1, j)*temp_ad3
        qin_ad(1, j) = qin_ad(1, j) + geom%dxa(0, j)*temp_ad3
        q2_ad(j) = 0.0_8
      END DO
    END IF
    DO j=min1,max1,-1
      CALL POPINTEGER4(ad_from)
      CALL POPINTEGER4(ad_to)
      DO i=ad_to,ad_from,-1
        qin_ad(i-2, j) = qin_ad(i-2, j) + b2*qx_ad(i, j)
        qin_ad(i+1, j) = qin_ad(i+1, j) + b2*qx_ad(i, j)
        qin_ad(i-1, j) = qin_ad(i-1, j) + b1*qx_ad(i, j)
        qin_ad(i, j) = qin_ad(i, j) + b1*qx_ad(i, j)
        qx_ad(i, j) = 0.0_8
      END DO
    END DO
    CALL POPCONTROL1B(branch)
    IF (branch .NE. 0) THEN
      temp_ad2 = r3*qout_ad(1, npy)
      result1_ad = temp_ad2
      result2_ad = temp_ad2
      result3_ad = temp_ad2
      qout_ad(1, npy) = 0.0_8
      CALL EXTRAP_CORNER_ADM(p0, geom%agrid(1, npy, 1:2), geom%agrid(2, &
&                      npy+1, 1:2), qin(1, npy), qin_ad(1, npy), qin(2, &
&                      npy+1), qin_ad(2, npy+1), result3_ad)
      CALL EXTRAP_CORNER_ADM(p0, geom%agrid(0, npy-1, 1:2), geom%agrid(-&
&                      1, npy-2, 1:2), qin(0, npy-1), qin_ad(0, npy-1), &
&                      qin(-1, npy-2), qin_ad(-1, npy-2), result2_ad)
      CALL EXTRAP_CORNER_ADM(p0, geom%agrid(1, npy-1, 1:2), geom%agrid(2&
&                      , npy-2, 1:2), qin(1, npy-1), qin_ad(1, npy-1), &
&                      qin(2, npy-2), qin_ad(2, npy-2), result1_ad)
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      temp_ad1 = r3*qout_ad(npx, npy)
      result1_ad = temp_ad1
      result2_ad = temp_ad1
      result3_ad = temp_ad1
      qout_ad(npx, npy) = 0.0_8
      p0(1:2) = geom%grid(npx, npy, 1:2)
      CALL EXTRAP_CORNER_ADM(p0, geom%agrid(npx-1, npy, 1:2), geom%agrid&
&                      (npx-2, npy+1, 1:2), qin(npx-1, npy), qin_ad(npx-&
&                      1, npy), qin(npx-2, npy+1), qin_ad(npx-2, npy+1)&
&                      , result3_ad)
      CALL EXTRAP_CORNER_ADM(p0, geom%agrid(npx, npy-1, 1:2), geom%agrid&
&                      (npx+1, npy-2, 1:2), qin(npx, npy-1), qin_ad(npx&
&                      , npy-1), qin(npx+1, npy-2), qin_ad(npx+1, npy-2)&
&                      , result2_ad)
      CALL EXTRAP_CORNER_ADM(p0, geom%agrid(npx-1, npy-1, 1:2), geom%&
&                      agrid(npx-2, npy-2, 1:2), qin(npx-1, npy-1), &
&                      qin_ad(npx-1, npy-1), qin(npx-2, npy-2), qin_ad(&
&                      npx-2, npy-2), result1_ad)
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      temp_ad0 = r3*qout_ad(npx, 1)
      result1_ad = temp_ad0
      result2_ad = temp_ad0
      result3_ad = temp_ad0
      qout_ad(npx, 1) = 0.0_8
      p0(1:2) = geom%grid(npx, 1, 1:2)
      CALL EXTRAP_CORNER_ADM(p0, geom%agrid(npx, 1, 1:2), geom%agrid(npx&
&                      +1, 2, 1:2), qin(npx, 1), qin_ad(npx, 1), qin(npx&
&                      +1, 2), qin_ad(npx+1, 2), result3_ad)
      CALL EXTRAP_CORNER_ADM(p0, geom%agrid(npx-1, 0, 1:2), geom%agrid(&
&                      npx-2, -1, 1:2), qin(npx-1, 0), qin_ad(npx-1, 0)&
&                      , qin(npx-2, -1), qin_ad(npx-2, -1), result2_ad)
      CALL EXTRAP_CORNER_ADM(p0, geom%agrid(npx-1, 1, 1:2), geom%agrid(&
&                      npx-2, 2, 1:2), qin(npx-1, 1), qin_ad(npx-1, 1), &
&                      qin(npx-2, 2), qin_ad(npx-2, 2), result1_ad)
    END IF
    CALL POPCONTROL1B(branch)
    IF (branch .EQ. 0) THEN
      temp_ad = r3*qout_ad(1, 1)
      result1_ad = temp_ad
      result2_ad = temp_ad
      result3_ad = temp_ad
      p0(1:2) = geom%grid(1, 1, 1:2)
      CALL EXTRAP_CORNER_ADM(p0, geom%agrid(1, 0, 1:2), geom%agrid(2, -1&
&                      , 1:2), qin(1, 0), qin_ad(1, 0), qin(2, -1), &
&                      qin_ad(2, -1), result3_ad)
      CALL EXTRAP_CORNER_ADM(p0, geom%agrid(0, 1, 1:2), geom%agrid(-1, 2&
&                      , 1:2), qin(0, 1), qin_ad(0, 1), qin(-1, 2), &
&                      qin_ad(-1, 2), result2_ad)
      CALL EXTRAP_CORNER_ADM(p0, geom%agrid(1, 1, 1:2), geom%agrid(2, 2&
&                      , 1:2), qin(1, 1), qin_ad(1, 1), qin(2, 2), &
&                      qin_ad(2, 2), result1_ad)
    END IF
  END SUBROUTINE A2B_ORD4_ADM
!----------------------------------------------------------------------------
  SUBROUTINE A2B_ORD4(qin, qout, geom, npx, npy, is, ie, js, je, ng)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, is, ie, js, je, ng
! A-grid field
    REAL(kind=kind_real), INTENT(IN) :: qin(is-ng:ie+ng, js-ng:je+ng)
! Output  B-grid field
    REAL(kind=kind_real), INTENT(OUT) :: qout(is-ng:ie+ng, js-ng:je+ng)
    TYPE(FV3JEDI_GEOM), INTENT(IN), TARGET :: geom
    REAL(kind=kind_real) :: qx(is:ie+1, js-ng:je+ng)
    REAL(kind=kind_real) :: qy(is-ng:ie+ng, js:je+1)
    REAL(kind=kind_real) :: qxx(is-ng:ie+ng, js-ng:je+ng)
    REAL(kind=kind_real) :: qyy(is-ng:ie+ng, js-ng:je+ng)
    REAL(kind=kind_real) :: g_in, g_ou
    REAL(kind=kind_real) :: p0(2)
    REAL(kind=kind_real) :: q1(is-1:ie+1), q2(js-1:je+1)
    INTEGER :: i, j, is1, js1, is2, js2, ie1, je1
    REAL(kind=kind_real), PARAMETER :: c1=2./3.
    REAL(kind=kind_real), PARAMETER :: c2=-(1./6.)
    REAL(kind=kind_real), PARAMETER :: r3=1./3.
!  9/16
    REAL(kind=kind_real), PARAMETER :: a1=0.5625
! -1/16
    REAL(kind=kind_real), PARAMETER :: a2=-0.0625
! 0.58333333
    REAL(kind=kind_real), PARAMETER :: b1=7./12.
    REAL(kind=kind_real), PARAMETER :: b2=-(1./12.)
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: max5
    INTEGER :: max6
    INTEGER :: max7
    INTEGER :: max8
    INTEGER :: max9
    INTEGER :: max10
    INTEGER :: max11
    INTEGER :: max12
    INTEGER :: max13
    INTEGER :: max14
    INTEGER :: max15
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    INTEGER :: min5
    INTEGER :: min6
    INTEGER :: min7
    INTEGER :: min8
    INTEGER :: min9
    INTEGER :: min10
    INTEGER :: min11
    INTEGER :: min12
    INTEGER :: min13
    INTEGER :: min14
    INTEGER :: min15
    REAL(kind=kind_real) :: result1
    REAL(kind=kind_real) :: result2
    REAL(kind=kind_real) :: result3
    IF (1 .LT. is - 1) THEN
      is1 = is - 1
    ELSE
      is1 = 1
    END IF
    IF (1 .LT. js - 1) THEN
      js1 = js - 1
    ELSE
      js1 = 1
    END IF
    IF (2 .LT. is) THEN
      is2 = is
    ELSE
      is2 = 2
    END IF
    IF (2 .LT. js) THEN
      js2 = js
    ELSE
      js2 = 2
    END IF
    IF (npx - 1 .GT. ie + 1) THEN
      ie1 = ie + 1
    ELSE
      ie1 = npx - 1
    END IF
    IF (npy - 1 .GT. je + 1) THEN
      je1 = je + 1
    ELSE
      je1 = npy - 1
    END IF
! Corners:
! 3-way extrapolation
    IF (geom%sw_corner) THEN
      p0(1:2) = geom%grid(1, 1, 1:2)
      result1 = EXTRAP_CORNER(p0, geom%agrid(1, 1, 1:2), geom%agrid(2, 2&
&       , 1:2), qin(1, 1), qin(2, 2))
      result2 = EXTRAP_CORNER(p0, geom%agrid(0, 1, 1:2), geom%agrid(-1, &
&       2, 1:2), qin(0, 1), qin(-1, 2))
      result3 = EXTRAP_CORNER(p0, geom%agrid(1, 0, 1:2), geom%agrid(2, -&
&       1, 1:2), qin(1, 0), qin(2, -1))
      qout(1, 1) = (result1+result2+result3)*r3
    END IF
    IF (geom%se_corner) THEN
      p0(1:2) = geom%grid(npx, 1, 1:2)
      result1 = EXTRAP_CORNER(p0, geom%agrid(npx-1, 1, 1:2), geom%agrid(&
&       npx-2, 2, 1:2), qin(npx-1, 1), qin(npx-2, 2))
      result2 = EXTRAP_CORNER(p0, geom%agrid(npx-1, 0, 1:2), geom%agrid(&
&       npx-2, -1, 1:2), qin(npx-1, 0), qin(npx-2, -1))
      result3 = EXTRAP_CORNER(p0, geom%agrid(npx, 1, 1:2), geom%agrid(&
&       npx+1, 2, 1:2), qin(npx, 1), qin(npx+1, 2))
      qout(npx, 1) = (result1+result2+result3)*r3
    END IF
    IF (geom%ne_corner) THEN
      p0(1:2) = geom%grid(npx, npy, 1:2)
      result1 = EXTRAP_CORNER(p0, geom%agrid(npx-1, npy-1, 1:2), geom%&
&       agrid(npx-2, npy-2, 1:2), qin(npx-1, npy-1), qin(npx-2, npy-2))
      result2 = EXTRAP_CORNER(p0, geom%agrid(npx, npy-1, 1:2), geom%&
&       agrid(npx+1, npy-2, 1:2), qin(npx, npy-1), qin(npx+1, npy-2))
      result3 = EXTRAP_CORNER(p0, geom%agrid(npx-1, npy, 1:2), geom%&
&       agrid(npx-2, npy+1, 1:2), qin(npx-1, npy), qin(npx-2, npy+1))
      qout(npx, npy) = (result1+result2+result3)*r3
    END IF
    IF (geom%nw_corner) THEN
      p0(1:2) = geom%grid(1, npy, 1:2)
      result1 = EXTRAP_CORNER(p0, geom%agrid(1, npy-1, 1:2), geom%agrid(&
&       2, npy-2, 1:2), qin(1, npy-1), qin(2, npy-2))
      result2 = EXTRAP_CORNER(p0, geom%agrid(0, npy-1, 1:2), geom%agrid(&
&       -1, npy-2, 1:2), qin(0, npy-1), qin(-1, npy-2))
      result3 = EXTRAP_CORNER(p0, geom%agrid(1, npy, 1:2), geom%agrid(2&
&       , npy+1, 1:2), qin(1, npy), qin(2, npy+1))
      qout(1, npy) = (result1+result2+result3)*r3
    END IF
    IF (1 .LT. js - 2) THEN
      max1 = js - 2
    ELSE
      max1 = 1
    END IF
    IF (npy - 1 .GT. je + 2) THEN
      min1 = je + 2
    ELSE
      min1 = npy - 1
    END IF
!------------
! X-Interior:
!------------
    DO j=max1,min1
      IF (3 .LT. is) THEN
        max2 = is
      ELSE
        max2 = 3
      END IF
      IF (npx - 2 .GT. ie + 1) THEN
        min2 = ie + 1
      ELSE
        min2 = npx - 2
      END IF
      DO i=max2,min2
        qx(i, j) = b2*(qin(i-2, j)+qin(i+1, j)) + b1*(qin(i-1, j)+qin(i&
&         , j))
      END DO
    END DO
! *** West Edges:
    IF (is .EQ. 1) THEN
      DO j=js1,je1
        q2(j) = (qin(0, j)*geom%dxa(1, j)+qin(1, j)*geom%dxa(0, j))/(&
&         geom%dxa(0, j)+geom%dxa(1, j))
      END DO
      DO j=js2,je1
        qout(1, j) = geom%edge_w(j)*q2(j-1) + (1.-geom%edge_w(j))*q2(j)
      END DO
      IF (1 .LT. js - 2) THEN
        max3 = js - 2
      ELSE
        max3 = 1
      END IF
      IF (npy - 1 .GT. je + 2) THEN
        min3 = je + 2
      ELSE
        min3 = npy - 1
      END IF
!
      DO j=max3,min3
        g_in = geom%dxa(2, j)/geom%dxa(1, j)
        g_ou = geom%dxa(-1, j)/geom%dxa(0, j)
        qx(1, j) = 0.5*(((2.+g_in)*qin(1, j)-qin(2, j))/(1.+g_in)+((2.+&
&         g_ou)*qin(0, j)-qin(-1, j))/(1.+g_ou))
        qx(2, j) = (3.*(g_in*qin(1, j)+qin(2, j))-(g_in*qx(1, j)+qx(3, j&
&         )))/(2.+2.*g_in)
      END DO
    END IF
! East Edges:
    IF (ie + 1 .EQ. npx) THEN
      DO j=js1,je1
        q2(j) = (qin(npx-1, j)*geom%dxa(npx, j)+qin(npx, j)*geom%dxa(npx&
&         -1, j))/(geom%dxa(npx-1, j)+geom%dxa(npx, j))
      END DO
      DO j=js2,je1
        qout(npx, j) = geom%edge_e(j)*q2(j-1) + (1.-geom%edge_e(j))*q2(j&
&         )
      END DO
      IF (1 .LT. js - 2) THEN
        max4 = js - 2
      ELSE
        max4 = 1
      END IF
      IF (npy - 1 .GT. je + 2) THEN
        min4 = je + 2
      ELSE
        min4 = npy - 1
      END IF
!
      DO j=max4,min4
        g_in = geom%dxa(npx-2, j)/geom%dxa(npx-1, j)
        g_ou = geom%dxa(npx+1, j)/geom%dxa(npx, j)
        qx(npx, j) = 0.5*(((2.+g_in)*qin(npx-1, j)-qin(npx-2, j))/(1.+&
&         g_in)+((2.+g_ou)*qin(npx, j)-qin(npx+1, j))/(1.+g_ou))
        qx(npx-1, j) = (3.*(qin(npx-2, j)+g_in*qin(npx-1, j))-(g_in*qx(&
&         npx, j)+qx(npx-2, j)))/(2.+2.*g_in)
      END DO
    END IF
    IF (3 .LT. js) THEN
      max5 = js
    ELSE
      max5 = 3
    END IF
    IF (npy - 2 .GT. je + 1) THEN
      min5 = je + 1
    ELSE
      min5 = npy - 2
    END IF
!------------
! Y-Interior:
!------------
    DO j=max5,min5
      IF (1 .LT. is - 2) THEN
        max6 = is - 2
      ELSE
        max6 = 1
      END IF
      IF (npx - 1 .GT. ie + 2) THEN
        min6 = ie + 2
      ELSE
        min6 = npx - 1
      END IF
      DO i=max6,min6
        qy(i, j) = b2*(qin(i, j-2)+qin(i, j+1)) + b1*(qin(i, j-1)+qin(i&
&         , j))
      END DO
    END DO
! South Edges:
    IF (js .EQ. 1) THEN
      DO i=is1,ie1
        q1(i) = (qin(i, 0)*geom%dya(i, 1)+qin(i, 1)*geom%dya(i, 0))/(&
&         geom%dya(i, 0)+geom%dya(i, 1))
      END DO
      DO i=is2,ie1
        qout(i, 1) = geom%edge_s(i)*q1(i-1) + (1.-geom%edge_s(i))*q1(i)
      END DO
      IF (1 .LT. is - 2) THEN
        max7 = is - 2
      ELSE
        max7 = 1
      END IF
      IF (npx - 1 .GT. ie + 2) THEN
        min7 = ie + 2
      ELSE
        min7 = npx - 1
      END IF
!
      DO i=max7,min7
        g_in = geom%dya(i, 2)/geom%dya(i, 1)
        g_ou = geom%dya(i, -1)/geom%dya(i, 0)
        qy(i, 1) = 0.5*(((2.+g_in)*qin(i, 1)-qin(i, 2))/(1.+g_in)+((2.+&
&         g_ou)*qin(i, 0)-qin(i, -1))/(1.+g_ou))
        qy(i, 2) = (3.*(g_in*qin(i, 1)+qin(i, 2))-(g_in*qy(i, 1)+qy(i, 3&
&         )))/(2.+2.*g_in)
      END DO
    END IF
! North Edges:
    IF (je + 1 .EQ. npy) THEN
      DO i=is1,ie1
        q1(i) = (qin(i, npy-1)*geom%dya(i, npy)+qin(i, npy)*geom%dya(i, &
&         npy-1))/(geom%dya(i, npy-1)+geom%dya(i, npy))
      END DO
      DO i=is2,ie1
        qout(i, npy) = geom%edge_n(i)*q1(i-1) + (1.-geom%edge_n(i))*q1(i&
&         )
      END DO
      IF (1 .LT. is - 2) THEN
        max8 = is - 2
      ELSE
        max8 = 1
      END IF
      IF (npx - 1 .GT. ie + 2) THEN
        min8 = ie + 2
      ELSE
        min8 = npx - 1
      END IF
!
      DO i=max8,min8
        g_in = geom%dya(i, npy-2)/geom%dya(i, npy-1)
        g_ou = geom%dya(i, npy+1)/geom%dya(i, npy)
        qy(i, npy) = 0.5*(((2.+g_in)*qin(i, npy-1)-qin(i, npy-2))/(1.+&
&         g_in)+((2.+g_ou)*qin(i, npy)-qin(i, npy+1))/(1.+g_ou))
        qy(i, npy-1) = (3.*(qin(i, npy-2)+g_in*qin(i, npy-1))-(g_in*qy(i&
&         , npy)+qy(i, npy-2)))/(2.+2.*g_in)
      END DO
    END IF
    IF (3 .LT. js) THEN
      max9 = js
    ELSE
      max9 = 3
    END IF
    IF (npy - 2 .GT. je + 1) THEN
      min9 = je + 1
    ELSE
      min9 = npy - 2
    END IF
!--------------------------------------
    DO j=max9,min9
      IF (2 .LT. is) THEN
        max10 = is
      ELSE
        max10 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        min10 = ie + 1
      ELSE
        min10 = npx - 1
      END IF
      DO i=max10,min10
        qxx(i, j) = a2*(qx(i, j-2)+qx(i, j+1)) + a1*(qx(i, j-1)+qx(i, j)&
&         )
      END DO
    END DO
    IF (js .EQ. 1) THEN
      IF (2 .LT. is) THEN
        max11 = is
      ELSE
        max11 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        min11 = ie + 1
      ELSE
        min11 = npx - 1
      END IF
      DO i=max11,min11
        qxx(i, 2) = c1*(qx(i, 1)+qx(i, 2)) + c2*(qout(i, 1)+qxx(i, 3))
      END DO
    END IF
    IF (je + 1 .EQ. npy) THEN
      IF (2 .LT. is) THEN
        max12 = is
      ELSE
        max12 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        min12 = ie + 1
      ELSE
        min12 = npx - 1
      END IF
      DO i=max12,min12
        qxx(i, npy-1) = c1*(qx(i, npy-2)+qx(i, npy-1)) + c2*(qout(i, npy&
&         )+qxx(i, npy-2))
      END DO
    END IF
    IF (2 .LT. js) THEN
      max13 = js
    ELSE
      max13 = 2
    END IF
    IF (npy - 1 .GT. je + 1) THEN
      min13 = je + 1
    ELSE
      min13 = npy - 1
    END IF
    DO j=max13,min13
      IF (3 .LT. is) THEN
        max14 = is
      ELSE
        max14 = 3
      END IF
      IF (npx - 2 .GT. ie + 1) THEN
        min14 = ie + 1
      ELSE
        min14 = npx - 2
      END IF
      DO i=max14,min14
        qyy(i, j) = a2*(qy(i-2, j)+qy(i+1, j)) + a1*(qy(i-1, j)+qy(i, j)&
&         )
      END DO
      IF (is .EQ. 1) qyy(2, j) = c1*(qy(1, j)+qy(2, j)) + c2*(qout(1, j)&
&         +qyy(3, j))
      IF (ie + 1 .EQ. npx) qyy(npx-1, j) = c1*(qy(npx-2, j)+qy(npx-1, j)&
&         ) + c2*(qout(npx, j)+qyy(npx-2, j))
      IF (2 .LT. is) THEN
        max15 = is
      ELSE
        max15 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        min15 = ie + 1
      ELSE
        min15 = npx - 1
      END IF
      DO i=max15,min15
! averaging
        qout(i, j) = 0.5*(qxx(i, j)+qyy(i, j))
      END DO
    END DO
  END SUBROUTINE A2B_ORD4
!  Differentiation of extrap_corner in reverse (adjoint) mode:
!   gradient     of useful results: extrap_corner q1 q2
!   with respect to varying inputs: q1 q2
!----------------------------------------------------------------------------
  SUBROUTINE EXTRAP_CORNER_ADM(p0, p1, p2, q1, q1_ad, q2, q2_ad, &
&   extrap_corner_ad)
    IMPLICIT NONE
    REAL(kind=kind_real), DIMENSION(2), INTENT(IN) :: p0, p1, p2
    REAL(kind=kind_real), INTENT(IN) :: q1, q2
    REAL(kind=kind_real) :: q1_ad, q2_ad
    REAL(kind=kind_real) :: x1, x2
    REAL(kind=kind_real) :: temp_ad
    REAL(kind=kind_real) :: extrap_corner_ad
    REAL(kind=kind_real) :: extrap_corner
    x1 = GREAT_CIRCLE_DIST(p1, p0)
    x2 = GREAT_CIRCLE_DIST(p2, p0)
    temp_ad = x1*extrap_corner_ad/(x2-x1)
    q1_ad = q1_ad + temp_ad + extrap_corner_ad
    q2_ad = q2_ad - temp_ad
  END SUBROUTINE EXTRAP_CORNER_ADM
!----------------------------------------------------------------------------
  REAL(kind=kind_real) FUNCTION EXTRAP_CORNER(p0, p1, p2, q1, q2)
    IMPLICIT NONE
    REAL(kind=kind_real), DIMENSION(2), INTENT(IN) :: p0, p1, p2
    REAL(kind=kind_real), INTENT(IN) :: q1, q2
    REAL(kind=kind_real) :: x1, x2
    x1 = GREAT_CIRCLE_DIST(p1, p0)
    x2 = GREAT_CIRCLE_DIST(p2, p0)
    extrap_corner = q1 + x1/(x2-x1)*(q1-q2)
  END FUNCTION EXTRAP_CORNER
!----------------------------------------------------------------------------
  REAL(kind=kind_real) FUNCTION GREAT_CIRCLE_DIST(q1, q2)
    IMPLICIT NONE
    REAL(kind=kind_real), INTENT(IN) :: q1(2), q2(2)
    REAL(kind=kind_real) :: p1(2), p2(2)
    INTEGER :: n
    INTRINSIC SIN
    INTRINSIC COS
    INTRINSIC SQRT
    INTRINSIC ASIN
    DO n=1,2
      p1(n) = q1(n)
      p2(n) = q2(n)
    END DO
    great_circle_dist = ASIN(SQRT(SIN((p1(2)-p2(2))/2.)**2+COS(p1(2))*&
&     COS(p2(2))*SIN((p1(1)-p2(1))/2.)**2))*2.
  END FUNCTION GREAT_CIRCLE_DIST
END MODULE WIND_VT_MOD_DIFF
