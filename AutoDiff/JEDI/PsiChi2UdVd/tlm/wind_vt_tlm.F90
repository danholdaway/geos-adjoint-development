!        Generated by TAPENADE     (INRIA, Ecuador team)
!  Tapenade 3.13 (r6666) - 27 Nov 2017 17:09
!
! (C) Copyright 2018 UCAR
! 
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0. 
!> Variable transforms on wind variables for fv3-jedi 
!> Daniel Holdaway, NASA/JCSDA
MODULE WIND_VT_MOD_DIFF
  USE FV3JEDI_GEOM_MOD_DIFF
  USE MPP_DOMAINS_MOD_DIFF
  IMPLICIT NONE
!----------------------------------------------------------------------------
  PRIVATE 
  PUBLIC psichi_to_udvd
  PUBLIC psichi_to_udvd_tlm

CONTAINS
!  Differentiation of psichi_to_udvd in forward (tangent) mode:
!   variations   of useful results: psi u v chi
!   with respect to varying inputs: psi u v chi
!   RW status of diff variables: psi:in-out u:in-out v:in-out chi:in-out
!----------------------------------------------------------------------------
  SUBROUTINE PSICHI_TO_UDVD_TLM(geom, psi, psi_tl, chi, chi_tl, u, u_tl&
&   , v, v_tl)
    IMPLICIT NONE
    TYPE(FV3JEDI_GEOM), INTENT(INOUT) :: geom
!Stream function
    REAL(kind=kind_real), INTENT(INOUT) :: psi(geom%bd%isd:geom%bd%ied, &
&   geom%bd%jsd:geom%bd%jed, geom%npz)
    REAL(kind=kind_real), INTENT(INOUT) :: psi_tl(geom%bd%isd:geom%bd%&
&   ied, geom%bd%jsd:geom%bd%jed, geom%npz)
!Velocity potential
    REAL(kind=kind_real), INTENT(INOUT) :: chi(geom%bd%isd:geom%bd%ied, &
&   geom%bd%jsd:geom%bd%jed, geom%npz)
    REAL(kind=kind_real), INTENT(INOUT) :: chi_tl(geom%bd%isd:geom%bd%&
&   ied, geom%bd%jsd:geom%bd%jed, geom%npz)
!Dgrid winds (u)
    REAL(kind=kind_real), INTENT(OUT) :: u(geom%bd%isd:geom%bd%ied, geom&
&   %bd%jsd:geom%bd%jed+1, geom%npz)
    REAL(kind=kind_real), INTENT(OUT) :: u_tl(geom%bd%isd:geom%bd%ied, &
&   geom%bd%jsd:geom%bd%jed+1, geom%npz)
!Dgrid winds (v)
    REAL(kind=kind_real), INTENT(OUT) :: v(geom%bd%isd:geom%bd%ied+1, &
&   geom%bd%jsd:geom%bd%jed, geom%npz)
    REAL(kind=kind_real), INTENT(OUT) :: v_tl(geom%bd%isd:geom%bd%ied+1&
&   , geom%bd%jsd:geom%bd%jed, geom%npz)
    INTEGER :: i, j, k
    REAL(kind=kind_real) :: chib(geom%bd%isd:geom%bd%ied, geom%bd%jsd:&
&   geom%bd%jed, geom%npz)
    REAL(kind=kind_real) :: chib_tl(geom%bd%isd:geom%bd%ied, geom%bd%jsd&
&   :geom%bd%jed, geom%npz)
!       x-----------------x
!       |                 |
!       |                 |
!       |                 |
!     vd|        x        |
!       |     psi,chi     |
!       |                 |
!       |                 |
!       |                 |
!       x-----------------x
!               ud
!Fill halos of psi and chi
    CALL MPP_UPDATE_DOMAINS_TLM(psi, psi_tl, geom%domain, complete=&
&                         .true.)
    CALL MPP_UPDATE_DOMAINS_TLM(chi, chi_tl, geom%domain, complete=&
&                         .true.)
!Interpolate chi to the B grid
    CALL A2B_ORD4_TLM(chi, chi_tl, chib, chib_tl, geom, geom%npx, geom%&
&               npy, geom%bd%isc, geom%bd%iec, geom%bd%jsc, geom%bd%jec&
&               , geom%halo)
    DO k=1,geom%npz
      DO j=geom%bd%jsc,geom%bd%jec
        DO i=geom%bd%isc,geom%bd%iec
          u_tl(i, j, k) = (psi_tl(i, j+1, k)-psi_tl(i, j, k))/geom%dyc(i&
&           , j) + (chib_tl(i+1, j, k)-chib_tl(i, j, k))/geom%dx(i, j)
          u(i, j, k) = (psi(i, j+1, k)-psi(i, j, k))/geom%dyc(i, j) + (&
&           chib(i+1, j, k)-chib(i, j, k))/geom%dx(i, j)
          v_tl(i, j, k) = (chib_tl(i, j+1, k)-chib_tl(i, j, k))/geom%dy(&
&           i, j) - (psi_tl(i+1, j, k)-psi_tl(i, j, k))/geom%dxc(i, j)
          v(i, j, k) = -((psi(i+1, j, k)-psi(i, j, k))/geom%dxc(i, j)) +&
&           (chib(i, j+1, k)-chib(i, j, k))/geom%dy(i, j)
        END DO
      END DO
    END DO
  END SUBROUTINE PSICHI_TO_UDVD_TLM
!----------------------------------------------------------------------------
  SUBROUTINE PSICHI_TO_UDVD(geom, psi, chi, u, v)
    IMPLICIT NONE
    TYPE(FV3JEDI_GEOM), INTENT(INOUT) :: geom
!Stream function
    REAL(kind=kind_real), INTENT(INOUT) :: psi(geom%bd%isd:geom%bd%ied, &
&   geom%bd%jsd:geom%bd%jed, geom%npz)
!Velocity potential
    REAL(kind=kind_real), INTENT(INOUT) :: chi(geom%bd%isd:geom%bd%ied, &
&   geom%bd%jsd:geom%bd%jed, geom%npz)
!Dgrid winds (u)
    REAL(kind=kind_real), INTENT(OUT) :: u(geom%bd%isd:geom%bd%ied, geom&
&   %bd%jsd:geom%bd%jed+1, geom%npz)
!Dgrid winds (v)
    REAL(kind=kind_real), INTENT(OUT) :: v(geom%bd%isd:geom%bd%ied+1, &
&   geom%bd%jsd:geom%bd%jed, geom%npz)
    INTEGER :: i, j, k
    REAL(kind=kind_real) :: chib(geom%bd%isd:geom%bd%ied, geom%bd%jsd:&
&   geom%bd%jed, geom%npz)
!       x-----------------x
!       |                 |
!       |                 |
!       |                 |
!     vd|        x        |
!       |     psi,chi     |
!       |                 |
!       |                 |
!       |                 |
!       x-----------------x
!               ud
!Fill halos of psi and chi
    CALL MPP_UPDATE_DOMAINS(psi, geom%domain, complete=.true.)
    CALL MPP_UPDATE_DOMAINS(chi, geom%domain, complete=.true.)
!Interpolate chi to the B grid
    CALL A2B_ORD4(chi, chib, geom, geom%npx, geom%npy, geom%bd%isc, geom&
&           %bd%iec, geom%bd%jsc, geom%bd%jec, geom%halo)
    DO k=1,geom%npz
      DO j=geom%bd%jsc,geom%bd%jec
        DO i=geom%bd%isc,geom%bd%iec
          u(i, j, k) = (psi(i, j+1, k)-psi(i, j, k))/geom%dyc(i, j) + (&
&           chib(i+1, j, k)-chib(i, j, k))/geom%dx(i, j)
          v(i, j, k) = -((psi(i+1, j, k)-psi(i, j, k))/geom%dxc(i, j)) +&
&           (chib(i, j+1, k)-chib(i, j, k))/geom%dy(i, j)
        END DO
      END DO
    END DO
  END SUBROUTINE PSICHI_TO_UDVD
!  Differentiation of a2b_ord4 in forward (tangent) mode:
!   variations   of useful results: qout
!   with respect to varying inputs: qin
!----------------------------------------------------------------------------
  SUBROUTINE A2B_ORD4_TLM(qin, qin_tl, qout, qout_tl, geom, npx, npy, is&
&   , ie, js, je, ng)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, is, ie, js, je, ng
! A-grid field
    REAL(kind=kind_real), INTENT(IN) :: qin(is-ng:ie+ng, js-ng:je+ng)
    REAL(kind=kind_real), INTENT(IN) :: qin_tl(is-ng:ie+ng, js-ng:je+ng)
! Output  B-grid field
    REAL(kind=kind_real), INTENT(OUT) :: qout(is-ng:ie+ng, js-ng:je+ng)
    REAL(kind=kind_real), INTENT(OUT) :: qout_tl(is-ng:ie+ng, js-ng:je+&
&   ng)
    TYPE(FV3JEDI_GEOM), INTENT(IN), TARGET :: geom
    REAL(kind=kind_real) :: qx(is:ie+1, js-ng:je+ng)
    REAL(kind=kind_real) :: qx_tl(is:ie+1, js-ng:je+ng)
    REAL(kind=kind_real) :: qy(is-ng:ie+ng, js:je+1)
    REAL(kind=kind_real) :: qy_tl(is-ng:ie+ng, js:je+1)
    REAL(kind=kind_real) :: qxx(is-ng:ie+ng, js-ng:je+ng)
    REAL(kind=kind_real) :: qxx_tl(is-ng:ie+ng, js-ng:je+ng)
    REAL(kind=kind_real) :: qyy(is-ng:ie+ng, js-ng:je+ng)
    REAL(kind=kind_real) :: qyy_tl(is-ng:ie+ng, js-ng:je+ng)
    REAL(kind=kind_real) :: g_in, g_ou
    REAL(kind=kind_real) :: p0(2)
    REAL(kind=kind_real) :: q1(is-1:ie+1), q2(js-1:je+1)
    REAL(kind=kind_real) :: q1_tl(is-1:ie+1), q2_tl(js-1:je+1)
    INTEGER :: i, j, is1, js1, is2, js2, ie1, je1
    REAL(kind=kind_real), PARAMETER :: c1=2./3.
    REAL(kind=kind_real), PARAMETER :: c2=-(1./6.)
    REAL(kind=kind_real), PARAMETER :: r3=1./3.
!  9/16
    REAL(kind=kind_real), PARAMETER :: a1=0.5625
! -1/16
    REAL(kind=kind_real), PARAMETER :: a2=-0.0625
! 0.58333333
    REAL(kind=kind_real), PARAMETER :: b1=7./12.
    REAL(kind=kind_real), PARAMETER :: b2=-(1./12.)
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: max5
    INTEGER :: max6
    INTEGER :: max7
    INTEGER :: max8
    INTEGER :: max9
    INTEGER :: max10
    INTEGER :: max11
    INTEGER :: max12
    INTEGER :: max13
    INTEGER :: max14
    INTEGER :: max15
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    INTEGER :: min5
    INTEGER :: min6
    INTEGER :: min7
    INTEGER :: min8
    INTEGER :: min9
    INTEGER :: min10
    INTEGER :: min11
    INTEGER :: min12
    INTEGER :: min13
    INTEGER :: min14
    INTEGER :: min15
    REAL(kind=kind_real) :: result1
    REAL(kind=kind_real) :: result1_tl
    REAL(kind=kind_real) :: result2
    REAL(kind=kind_real) :: result2_tl
    REAL(kind=kind_real) :: result3
    REAL(kind=kind_real) :: result3_tl
    IF (1 .LT. is - 1) THEN
      is1 = is - 1
    ELSE
      is1 = 1
    END IF
    IF (1 .LT. js - 1) THEN
      js1 = js - 1
    ELSE
      js1 = 1
    END IF
    IF (2 .LT. is) THEN
      is2 = is
    ELSE
      is2 = 2
    END IF
    IF (2 .LT. js) THEN
      js2 = js
    ELSE
      js2 = 2
    END IF
    IF (npx - 1 .GT. ie + 1) THEN
      ie1 = ie + 1
    ELSE
      ie1 = npx - 1
    END IF
    IF (npy - 1 .GT. je + 1) THEN
      je1 = je + 1
    ELSE
      je1 = npy - 1
    END IF
! Corners:
! 3-way extrapolation
    IF (geom%sw_corner) THEN
      p0(1:2) = geom%grid(1, 1, 1:2)
      result1_tl = EXTRAP_CORNER_TLM(p0, geom%agrid(1, 1, 1:2), geom%&
&       agrid(2, 2, 1:2), qin(1, 1), qin_tl(1, 1), qin(2, 2), qin_tl(2, &
&       2), result1)
      result2_tl = EXTRAP_CORNER_TLM(p0, geom%agrid(0, 1, 1:2), geom%&
&       agrid(-1, 2, 1:2), qin(0, 1), qin_tl(0, 1), qin(-1, 2), qin_tl(-&
&       1, 2), result2)
      result3_tl = EXTRAP_CORNER_TLM(p0, geom%agrid(1, 0, 1:2), geom%&
&       agrid(2, -1, 1:2), qin(1, 0), qin_tl(1, 0), qin(2, -1), qin_tl(2&
&       , -1), result3)
      qout_tl = 0.0_8
      qout_tl(1, 1) = r3*(result1_tl+result2_tl+result3_tl)
      qout(1, 1) = (result1+result2+result3)*r3
    ELSE
      qout_tl = 0.0_8
    END IF
    IF (geom%se_corner) THEN
      p0(1:2) = geom%grid(npx, 1, 1:2)
      result1_tl = EXTRAP_CORNER_TLM(p0, geom%agrid(npx-1, 1, 1:2), geom&
&       %agrid(npx-2, 2, 1:2), qin(npx-1, 1), qin_tl(npx-1, 1), qin(npx-&
&       2, 2), qin_tl(npx-2, 2), result1)
      result2_tl = EXTRAP_CORNER_TLM(p0, geom%agrid(npx-1, 0, 1:2), geom&
&       %agrid(npx-2, -1, 1:2), qin(npx-1, 0), qin_tl(npx-1, 0), qin(npx&
&       -2, -1), qin_tl(npx-2, -1), result2)
      result3_tl = EXTRAP_CORNER_TLM(p0, geom%agrid(npx, 1, 1:2), geom%&
&       agrid(npx+1, 2, 1:2), qin(npx, 1), qin_tl(npx, 1), qin(npx+1, 2)&
&       , qin_tl(npx+1, 2), result3)
      qout_tl(npx, 1) = r3*(result1_tl+result2_tl+result3_tl)
      qout(npx, 1) = (result1+result2+result3)*r3
    END IF
    IF (geom%ne_corner) THEN
      p0(1:2) = geom%grid(npx, npy, 1:2)
      result1_tl = EXTRAP_CORNER_TLM(p0, geom%agrid(npx-1, npy-1, 1:2), &
&       geom%agrid(npx-2, npy-2, 1:2), qin(npx-1, npy-1), qin_tl(npx-1, &
&       npy-1), qin(npx-2, npy-2), qin_tl(npx-2, npy-2), result1)
      result2_tl = EXTRAP_CORNER_TLM(p0, geom%agrid(npx, npy-1, 1:2), &
&       geom%agrid(npx+1, npy-2, 1:2), qin(npx, npy-1), qin_tl(npx, npy-&
&       1), qin(npx+1, npy-2), qin_tl(npx+1, npy-2), result2)
      result3_tl = EXTRAP_CORNER_TLM(p0, geom%agrid(npx-1, npy, 1:2), &
&       geom%agrid(npx-2, npy+1, 1:2), qin(npx-1, npy), qin_tl(npx-1, &
&       npy), qin(npx-2, npy+1), qin_tl(npx-2, npy+1), result3)
      qout_tl(npx, npy) = r3*(result1_tl+result2_tl+result3_tl)
      qout(npx, npy) = (result1+result2+result3)*r3
    END IF
    IF (geom%nw_corner) THEN
      p0(1:2) = geom%grid(1, npy, 1:2)
      result1_tl = EXTRAP_CORNER_TLM(p0, geom%agrid(1, npy-1, 1:2), geom&
&       %agrid(2, npy-2, 1:2), qin(1, npy-1), qin_tl(1, npy-1), qin(2, &
&       npy-2), qin_tl(2, npy-2), result1)
      result2_tl = EXTRAP_CORNER_TLM(p0, geom%agrid(0, npy-1, 1:2), geom&
&       %agrid(-1, npy-2, 1:2), qin(0, npy-1), qin_tl(0, npy-1), qin(-1&
&       , npy-2), qin_tl(-1, npy-2), result2)
      result3_tl = EXTRAP_CORNER_TLM(p0, geom%agrid(1, npy, 1:2), geom%&
&       agrid(2, npy+1, 1:2), qin(1, npy), qin_tl(1, npy), qin(2, npy+1)&
&       , qin_tl(2, npy+1), result3)
      qout_tl(1, npy) = r3*(result1_tl+result2_tl+result3_tl)
      qout(1, npy) = (result1+result2+result3)*r3
    END IF
    IF (1 .LT. js - 2) THEN
      max1 = js - 2
    ELSE
      max1 = 1
    END IF
    IF (npy - 1 .GT. je + 2) THEN
      min1 = je + 2
      qx_tl = 0.0_8
    ELSE
      min1 = npy - 1
      qx_tl = 0.0_8
    END IF
!------------
! X-Interior:
!------------
    DO j=max1,min1
      IF (3 .LT. is) THEN
        max2 = is
      ELSE
        max2 = 3
      END IF
      IF (npx - 2 .GT. ie + 1) THEN
        min2 = ie + 1
      ELSE
        min2 = npx - 2
      END IF
      DO i=max2,min2
        qx_tl(i, j) = b2*(qin_tl(i-2, j)+qin_tl(i+1, j)) + b1*(qin_tl(i-&
&         1, j)+qin_tl(i, j))
        qx(i, j) = b2*(qin(i-2, j)+qin(i+1, j)) + b1*(qin(i-1, j)+qin(i&
&         , j))
      END DO
    END DO
! *** West Edges:
    IF (is .EQ. 1) THEN
      q2_tl = 0.0_8
      DO j=js1,je1
        q2_tl(j) = (geom%dxa(1, j)*qin_tl(0, j)+geom%dxa(0, j)*qin_tl(1&
&         , j))/(geom%dxa(0, j)+geom%dxa(1, j))
        q2(j) = (qin(0, j)*geom%dxa(1, j)+qin(1, j)*geom%dxa(0, j))/(&
&         geom%dxa(0, j)+geom%dxa(1, j))
      END DO
      DO j=js2,je1
        qout_tl(1, j) = geom%edge_w(j)*q2_tl(j-1) + (1.-geom%edge_w(j))*&
&         q2_tl(j)
        qout(1, j) = geom%edge_w(j)*q2(j-1) + (1.-geom%edge_w(j))*q2(j)
      END DO
      IF (1 .LT. js - 2) THEN
        max3 = js - 2
      ELSE
        max3 = 1
      END IF
      IF (npy - 1 .GT. je + 2) THEN
        min3 = je + 2
      ELSE
        min3 = npy - 1
      END IF
!
      DO j=max3,min3
        g_in = geom%dxa(2, j)/geom%dxa(1, j)
        g_ou = geom%dxa(-1, j)/geom%dxa(0, j)
        qx_tl(1, j) = 0.5*(((2.+g_in)*qin_tl(1, j)-qin_tl(2, j))/(1.+&
&         g_in)+((2.+g_ou)*qin_tl(0, j)-qin_tl(-1, j))/(1.+g_ou))
        qx(1, j) = 0.5*(((2.+g_in)*qin(1, j)-qin(2, j))/(1.+g_in)+((2.+&
&         g_ou)*qin(0, j)-qin(-1, j))/(1.+g_ou))
        qx_tl(2, j) = (3.*(g_in*qin_tl(1, j)+qin_tl(2, j))-g_in*qx_tl(1&
&         , j)-qx_tl(3, j))/(2.+2.*g_in)
        qx(2, j) = (3.*(g_in*qin(1, j)+qin(2, j))-(g_in*qx(1, j)+qx(3, j&
&         )))/(2.+2.*g_in)
      END DO
    ELSE
      q2_tl = 0.0_8
    END IF
! East Edges:
    IF (ie + 1 .EQ. npx) THEN
      DO j=js1,je1
        q2_tl(j) = (geom%dxa(npx, j)*qin_tl(npx-1, j)+geom%dxa(npx-1, j)&
&         *qin_tl(npx, j))/(geom%dxa(npx-1, j)+geom%dxa(npx, j))
        q2(j) = (qin(npx-1, j)*geom%dxa(npx, j)+qin(npx, j)*geom%dxa(npx&
&         -1, j))/(geom%dxa(npx-1, j)+geom%dxa(npx, j))
      END DO
      DO j=js2,je1
        qout_tl(npx, j) = geom%edge_e(j)*q2_tl(j-1) + (1.-geom%edge_e(j)&
&         )*q2_tl(j)
        qout(npx, j) = geom%edge_e(j)*q2(j-1) + (1.-geom%edge_e(j))*q2(j&
&         )
      END DO
      IF (1 .LT. js - 2) THEN
        max4 = js - 2
      ELSE
        max4 = 1
      END IF
      IF (npy - 1 .GT. je + 2) THEN
        min4 = je + 2
      ELSE
        min4 = npy - 1
      END IF
!
      DO j=max4,min4
        g_in = geom%dxa(npx-2, j)/geom%dxa(npx-1, j)
        g_ou = geom%dxa(npx+1, j)/geom%dxa(npx, j)
        qx_tl(npx, j) = 0.5*(((2.+g_in)*qin_tl(npx-1, j)-qin_tl(npx-2, j&
&         ))/(1.+g_in)+((2.+g_ou)*qin_tl(npx, j)-qin_tl(npx+1, j))/(1.+&
&         g_ou))
        qx(npx, j) = 0.5*(((2.+g_in)*qin(npx-1, j)-qin(npx-2, j))/(1.+&
&         g_in)+((2.+g_ou)*qin(npx, j)-qin(npx+1, j))/(1.+g_ou))
        qx_tl(npx-1, j) = (3.*(qin_tl(npx-2, j)+g_in*qin_tl(npx-1, j))-&
&         g_in*qx_tl(npx, j)-qx_tl(npx-2, j))/(2.+2.*g_in)
        qx(npx-1, j) = (3.*(qin(npx-2, j)+g_in*qin(npx-1, j))-(g_in*qx(&
&         npx, j)+qx(npx-2, j)))/(2.+2.*g_in)
      END DO
    END IF
    IF (3 .LT. js) THEN
      max5 = js
    ELSE
      max5 = 3
    END IF
    IF (npy - 2 .GT. je + 1) THEN
      min5 = je + 1
      qy_tl = 0.0_8
    ELSE
      min5 = npy - 2
      qy_tl = 0.0_8
    END IF
!------------
! Y-Interior:
!------------
    DO j=max5,min5
      IF (1 .LT. is - 2) THEN
        max6 = is - 2
      ELSE
        max6 = 1
      END IF
      IF (npx - 1 .GT. ie + 2) THEN
        min6 = ie + 2
      ELSE
        min6 = npx - 1
      END IF
      DO i=max6,min6
        qy_tl(i, j) = b2*(qin_tl(i, j-2)+qin_tl(i, j+1)) + b1*(qin_tl(i&
&         , j-1)+qin_tl(i, j))
        qy(i, j) = b2*(qin(i, j-2)+qin(i, j+1)) + b1*(qin(i, j-1)+qin(i&
&         , j))
      END DO
    END DO
! South Edges:
    IF (js .EQ. 1) THEN
      q1_tl = 0.0_8
      DO i=is1,ie1
        q1_tl(i) = (geom%dya(i, 1)*qin_tl(i, 0)+geom%dya(i, 0)*qin_tl(i&
&         , 1))/(geom%dya(i, 0)+geom%dya(i, 1))
        q1(i) = (qin(i, 0)*geom%dya(i, 1)+qin(i, 1)*geom%dya(i, 0))/(&
&         geom%dya(i, 0)+geom%dya(i, 1))
      END DO
      DO i=is2,ie1
        qout_tl(i, 1) = geom%edge_s(i)*q1_tl(i-1) + (1.-geom%edge_s(i))*&
&         q1_tl(i)
        qout(i, 1) = geom%edge_s(i)*q1(i-1) + (1.-geom%edge_s(i))*q1(i)
      END DO
      IF (1 .LT. is - 2) THEN
        max7 = is - 2
      ELSE
        max7 = 1
      END IF
      IF (npx - 1 .GT. ie + 2) THEN
        min7 = ie + 2
      ELSE
        min7 = npx - 1
      END IF
!
      DO i=max7,min7
        g_in = geom%dya(i, 2)/geom%dya(i, 1)
        g_ou = geom%dya(i, -1)/geom%dya(i, 0)
        qy_tl(i, 1) = 0.5*(((2.+g_in)*qin_tl(i, 1)-qin_tl(i, 2))/(1.+&
&         g_in)+((2.+g_ou)*qin_tl(i, 0)-qin_tl(i, -1))/(1.+g_ou))
        qy(i, 1) = 0.5*(((2.+g_in)*qin(i, 1)-qin(i, 2))/(1.+g_in)+((2.+&
&         g_ou)*qin(i, 0)-qin(i, -1))/(1.+g_ou))
        qy_tl(i, 2) = (3.*(g_in*qin_tl(i, 1)+qin_tl(i, 2))-g_in*qy_tl(i&
&         , 1)-qy_tl(i, 3))/(2.+2.*g_in)
        qy(i, 2) = (3.*(g_in*qin(i, 1)+qin(i, 2))-(g_in*qy(i, 1)+qy(i, 3&
&         )))/(2.+2.*g_in)
      END DO
    ELSE
      q1_tl = 0.0_8
    END IF
! North Edges:
    IF (je + 1 .EQ. npy) THEN
      DO i=is1,ie1
        q1_tl(i) = (geom%dya(i, npy)*qin_tl(i, npy-1)+geom%dya(i, npy-1)&
&         *qin_tl(i, npy))/(geom%dya(i, npy-1)+geom%dya(i, npy))
        q1(i) = (qin(i, npy-1)*geom%dya(i, npy)+qin(i, npy)*geom%dya(i, &
&         npy-1))/(geom%dya(i, npy-1)+geom%dya(i, npy))
      END DO
      DO i=is2,ie1
        qout_tl(i, npy) = geom%edge_n(i)*q1_tl(i-1) + (1.-geom%edge_n(i)&
&         )*q1_tl(i)
        qout(i, npy) = geom%edge_n(i)*q1(i-1) + (1.-geom%edge_n(i))*q1(i&
&         )
      END DO
      IF (1 .LT. is - 2) THEN
        max8 = is - 2
      ELSE
        max8 = 1
      END IF
      IF (npx - 1 .GT. ie + 2) THEN
        min8 = ie + 2
      ELSE
        min8 = npx - 1
      END IF
!
      DO i=max8,min8
        g_in = geom%dya(i, npy-2)/geom%dya(i, npy-1)
        g_ou = geom%dya(i, npy+1)/geom%dya(i, npy)
        qy_tl(i, npy) = 0.5*(((2.+g_in)*qin_tl(i, npy-1)-qin_tl(i, npy-2&
&         ))/(1.+g_in)+((2.+g_ou)*qin_tl(i, npy)-qin_tl(i, npy+1))/(1.+&
&         g_ou))
        qy(i, npy) = 0.5*(((2.+g_in)*qin(i, npy-1)-qin(i, npy-2))/(1.+&
&         g_in)+((2.+g_ou)*qin(i, npy)-qin(i, npy+1))/(1.+g_ou))
        qy_tl(i, npy-1) = (3.*(qin_tl(i, npy-2)+g_in*qin_tl(i, npy-1))-&
&         g_in*qy_tl(i, npy)-qy_tl(i, npy-2))/(2.+2.*g_in)
        qy(i, npy-1) = (3.*(qin(i, npy-2)+g_in*qin(i, npy-1))-(g_in*qy(i&
&         , npy)+qy(i, npy-2)))/(2.+2.*g_in)
      END DO
    END IF
    IF (3 .LT. js) THEN
      max9 = js
    ELSE
      max9 = 3
    END IF
    IF (npy - 2 .GT. je + 1) THEN
      min9 = je + 1
      qxx_tl = 0.0_8
    ELSE
      min9 = npy - 2
      qxx_tl = 0.0_8
    END IF
!--------------------------------------
    DO j=max9,min9
      IF (2 .LT. is) THEN
        max10 = is
      ELSE
        max10 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        min10 = ie + 1
      ELSE
        min10 = npx - 1
      END IF
      DO i=max10,min10
        qxx_tl(i, j) = a2*(qx_tl(i, j-2)+qx_tl(i, j+1)) + a1*(qx_tl(i, j&
&         -1)+qx_tl(i, j))
        qxx(i, j) = a2*(qx(i, j-2)+qx(i, j+1)) + a1*(qx(i, j-1)+qx(i, j)&
&         )
      END DO
    END DO
    IF (js .EQ. 1) THEN
      IF (2 .LT. is) THEN
        max11 = is
      ELSE
        max11 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        min11 = ie + 1
      ELSE
        min11 = npx - 1
      END IF
      DO i=max11,min11
        qxx_tl(i, 2) = c1*(qx_tl(i, 1)+qx_tl(i, 2)) + c2*(qout_tl(i, 1)+&
&         qxx_tl(i, 3))
        qxx(i, 2) = c1*(qx(i, 1)+qx(i, 2)) + c2*(qout(i, 1)+qxx(i, 3))
      END DO
    END IF
    IF (je + 1 .EQ. npy) THEN
      IF (2 .LT. is) THEN
        max12 = is
      ELSE
        max12 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        min12 = ie + 1
      ELSE
        min12 = npx - 1
      END IF
      DO i=max12,min12
        qxx_tl(i, npy-1) = c1*(qx_tl(i, npy-2)+qx_tl(i, npy-1)) + c2*(&
&         qout_tl(i, npy)+qxx_tl(i, npy-2))
        qxx(i, npy-1) = c1*(qx(i, npy-2)+qx(i, npy-1)) + c2*(qout(i, npy&
&         )+qxx(i, npy-2))
      END DO
    END IF
    IF (2 .LT. js) THEN
      max13 = js
    ELSE
      max13 = 2
    END IF
    IF (npy - 1 .GT. je + 1) THEN
      min13 = je + 1
      qyy_tl = 0.0_8
    ELSE
      min13 = npy - 1
      qyy_tl = 0.0_8
    END IF
    DO j=max13,min13
      IF (3 .LT. is) THEN
        max14 = is
      ELSE
        max14 = 3
      END IF
      IF (npx - 2 .GT. ie + 1) THEN
        min14 = ie + 1
      ELSE
        min14 = npx - 2
      END IF
      DO i=max14,min14
        qyy_tl(i, j) = a2*(qy_tl(i-2, j)+qy_tl(i+1, j)) + a1*(qy_tl(i-1&
&         , j)+qy_tl(i, j))
        qyy(i, j) = a2*(qy(i-2, j)+qy(i+1, j)) + a1*(qy(i-1, j)+qy(i, j)&
&         )
      END DO
      IF (is .EQ. 1) THEN
        qyy_tl(2, j) = c1*(qy_tl(1, j)+qy_tl(2, j)) + c2*(qout_tl(1, j)+&
&         qyy_tl(3, j))
        qyy(2, j) = c1*(qy(1, j)+qy(2, j)) + c2*(qout(1, j)+qyy(3, j))
      END IF
      IF (ie + 1 .EQ. npx) THEN
        qyy_tl(npx-1, j) = c1*(qy_tl(npx-2, j)+qy_tl(npx-1, j)) + c2*(&
&         qout_tl(npx, j)+qyy_tl(npx-2, j))
        qyy(npx-1, j) = c1*(qy(npx-2, j)+qy(npx-1, j)) + c2*(qout(npx, j&
&         )+qyy(npx-2, j))
      END IF
      IF (2 .LT. is) THEN
        max15 = is
      ELSE
        max15 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        min15 = ie + 1
      ELSE
        min15 = npx - 1
      END IF
      DO i=max15,min15
! averaging
        qout_tl(i, j) = 0.5*(qxx_tl(i, j)+qyy_tl(i, j))
        qout(i, j) = 0.5*(qxx(i, j)+qyy(i, j))
      END DO
    END DO
  END SUBROUTINE A2B_ORD4_TLM
!----------------------------------------------------------------------------
  SUBROUTINE A2B_ORD4(qin, qout, geom, npx, npy, is, ie, js, je, ng)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: npx, npy, is, ie, js, je, ng
! A-grid field
    REAL(kind=kind_real), INTENT(IN) :: qin(is-ng:ie+ng, js-ng:je+ng)
! Output  B-grid field
    REAL(kind=kind_real), INTENT(OUT) :: qout(is-ng:ie+ng, js-ng:je+ng)
    TYPE(FV3JEDI_GEOM), INTENT(IN), TARGET :: geom
    REAL(kind=kind_real) :: qx(is:ie+1, js-ng:je+ng)
    REAL(kind=kind_real) :: qy(is-ng:ie+ng, js:je+1)
    REAL(kind=kind_real) :: qxx(is-ng:ie+ng, js-ng:je+ng)
    REAL(kind=kind_real) :: qyy(is-ng:ie+ng, js-ng:je+ng)
    REAL(kind=kind_real) :: g_in, g_ou
    REAL(kind=kind_real) :: p0(2)
    REAL(kind=kind_real) :: q1(is-1:ie+1), q2(js-1:je+1)
    INTEGER :: i, j, is1, js1, is2, js2, ie1, je1
    REAL(kind=kind_real), PARAMETER :: c1=2./3.
    REAL(kind=kind_real), PARAMETER :: c2=-(1./6.)
    REAL(kind=kind_real), PARAMETER :: r3=1./3.
!  9/16
    REAL(kind=kind_real), PARAMETER :: a1=0.5625
! -1/16
    REAL(kind=kind_real), PARAMETER :: a2=-0.0625
! 0.58333333
    REAL(kind=kind_real), PARAMETER :: b1=7./12.
    REAL(kind=kind_real), PARAMETER :: b2=-(1./12.)
    INTRINSIC MAX
    INTRINSIC MIN
    INTEGER :: max1
    INTEGER :: max2
    INTEGER :: max3
    INTEGER :: max4
    INTEGER :: max5
    INTEGER :: max6
    INTEGER :: max7
    INTEGER :: max8
    INTEGER :: max9
    INTEGER :: max10
    INTEGER :: max11
    INTEGER :: max12
    INTEGER :: max13
    INTEGER :: max14
    INTEGER :: max15
    INTEGER :: min1
    INTEGER :: min2
    INTEGER :: min3
    INTEGER :: min4
    INTEGER :: min5
    INTEGER :: min6
    INTEGER :: min7
    INTEGER :: min8
    INTEGER :: min9
    INTEGER :: min10
    INTEGER :: min11
    INTEGER :: min12
    INTEGER :: min13
    INTEGER :: min14
    INTEGER :: min15
    REAL(kind=kind_real) :: result1
    REAL(kind=kind_real) :: result2
    REAL(kind=kind_real) :: result3
    IF (1 .LT. is - 1) THEN
      is1 = is - 1
    ELSE
      is1 = 1
    END IF
    IF (1 .LT. js - 1) THEN
      js1 = js - 1
    ELSE
      js1 = 1
    END IF
    IF (2 .LT. is) THEN
      is2 = is
    ELSE
      is2 = 2
    END IF
    IF (2 .LT. js) THEN
      js2 = js
    ELSE
      js2 = 2
    END IF
    IF (npx - 1 .GT. ie + 1) THEN
      ie1 = ie + 1
    ELSE
      ie1 = npx - 1
    END IF
    IF (npy - 1 .GT. je + 1) THEN
      je1 = je + 1
    ELSE
      je1 = npy - 1
    END IF
! Corners:
! 3-way extrapolation
    IF (geom%sw_corner) THEN
      p0(1:2) = geom%grid(1, 1, 1:2)
      result1 = EXTRAP_CORNER(p0, geom%agrid(1, 1, 1:2), geom%agrid(2, 2&
&       , 1:2), qin(1, 1), qin(2, 2))
      result2 = EXTRAP_CORNER(p0, geom%agrid(0, 1, 1:2), geom%agrid(-1, &
&       2, 1:2), qin(0, 1), qin(-1, 2))
      result3 = EXTRAP_CORNER(p0, geom%agrid(1, 0, 1:2), geom%agrid(2, -&
&       1, 1:2), qin(1, 0), qin(2, -1))
      qout(1, 1) = (result1+result2+result3)*r3
    END IF
    IF (geom%se_corner) THEN
      p0(1:2) = geom%grid(npx, 1, 1:2)
      result1 = EXTRAP_CORNER(p0, geom%agrid(npx-1, 1, 1:2), geom%agrid(&
&       npx-2, 2, 1:2), qin(npx-1, 1), qin(npx-2, 2))
      result2 = EXTRAP_CORNER(p0, geom%agrid(npx-1, 0, 1:2), geom%agrid(&
&       npx-2, -1, 1:2), qin(npx-1, 0), qin(npx-2, -1))
      result3 = EXTRAP_CORNER(p0, geom%agrid(npx, 1, 1:2), geom%agrid(&
&       npx+1, 2, 1:2), qin(npx, 1), qin(npx+1, 2))
      qout(npx, 1) = (result1+result2+result3)*r3
    END IF
    IF (geom%ne_corner) THEN
      p0(1:2) = geom%grid(npx, npy, 1:2)
      result1 = EXTRAP_CORNER(p0, geom%agrid(npx-1, npy-1, 1:2), geom%&
&       agrid(npx-2, npy-2, 1:2), qin(npx-1, npy-1), qin(npx-2, npy-2))
      result2 = EXTRAP_CORNER(p0, geom%agrid(npx, npy-1, 1:2), geom%&
&       agrid(npx+1, npy-2, 1:2), qin(npx, npy-1), qin(npx+1, npy-2))
      result3 = EXTRAP_CORNER(p0, geom%agrid(npx-1, npy, 1:2), geom%&
&       agrid(npx-2, npy+1, 1:2), qin(npx-1, npy), qin(npx-2, npy+1))
      qout(npx, npy) = (result1+result2+result3)*r3
    END IF
    IF (geom%nw_corner) THEN
      p0(1:2) = geom%grid(1, npy, 1:2)
      result1 = EXTRAP_CORNER(p0, geom%agrid(1, npy-1, 1:2), geom%agrid(&
&       2, npy-2, 1:2), qin(1, npy-1), qin(2, npy-2))
      result2 = EXTRAP_CORNER(p0, geom%agrid(0, npy-1, 1:2), geom%agrid(&
&       -1, npy-2, 1:2), qin(0, npy-1), qin(-1, npy-2))
      result3 = EXTRAP_CORNER(p0, geom%agrid(1, npy, 1:2), geom%agrid(2&
&       , npy+1, 1:2), qin(1, npy), qin(2, npy+1))
      qout(1, npy) = (result1+result2+result3)*r3
    END IF
    IF (1 .LT. js - 2) THEN
      max1 = js - 2
    ELSE
      max1 = 1
    END IF
    IF (npy - 1 .GT. je + 2) THEN
      min1 = je + 2
    ELSE
      min1 = npy - 1
    END IF
!------------
! X-Interior:
!------------
    DO j=max1,min1
      IF (3 .LT. is) THEN
        max2 = is
      ELSE
        max2 = 3
      END IF
      IF (npx - 2 .GT. ie + 1) THEN
        min2 = ie + 1
      ELSE
        min2 = npx - 2
      END IF
      DO i=max2,min2
        qx(i, j) = b2*(qin(i-2, j)+qin(i+1, j)) + b1*(qin(i-1, j)+qin(i&
&         , j))
      END DO
    END DO
! *** West Edges:
    IF (is .EQ. 1) THEN
      DO j=js1,je1
        q2(j) = (qin(0, j)*geom%dxa(1, j)+qin(1, j)*geom%dxa(0, j))/(&
&         geom%dxa(0, j)+geom%dxa(1, j))
      END DO
      DO j=js2,je1
        qout(1, j) = geom%edge_w(j)*q2(j-1) + (1.-geom%edge_w(j))*q2(j)
      END DO
      IF (1 .LT. js - 2) THEN
        max3 = js - 2
      ELSE
        max3 = 1
      END IF
      IF (npy - 1 .GT. je + 2) THEN
        min3 = je + 2
      ELSE
        min3 = npy - 1
      END IF
!
      DO j=max3,min3
        g_in = geom%dxa(2, j)/geom%dxa(1, j)
        g_ou = geom%dxa(-1, j)/geom%dxa(0, j)
        qx(1, j) = 0.5*(((2.+g_in)*qin(1, j)-qin(2, j))/(1.+g_in)+((2.+&
&         g_ou)*qin(0, j)-qin(-1, j))/(1.+g_ou))
        qx(2, j) = (3.*(g_in*qin(1, j)+qin(2, j))-(g_in*qx(1, j)+qx(3, j&
&         )))/(2.+2.*g_in)
      END DO
    END IF
! East Edges:
    IF (ie + 1 .EQ. npx) THEN
      DO j=js1,je1
        q2(j) = (qin(npx-1, j)*geom%dxa(npx, j)+qin(npx, j)*geom%dxa(npx&
&         -1, j))/(geom%dxa(npx-1, j)+geom%dxa(npx, j))
      END DO
      DO j=js2,je1
        qout(npx, j) = geom%edge_e(j)*q2(j-1) + (1.-geom%edge_e(j))*q2(j&
&         )
      END DO
      IF (1 .LT. js - 2) THEN
        max4 = js - 2
      ELSE
        max4 = 1
      END IF
      IF (npy - 1 .GT. je + 2) THEN
        min4 = je + 2
      ELSE
        min4 = npy - 1
      END IF
!
      DO j=max4,min4
        g_in = geom%dxa(npx-2, j)/geom%dxa(npx-1, j)
        g_ou = geom%dxa(npx+1, j)/geom%dxa(npx, j)
        qx(npx, j) = 0.5*(((2.+g_in)*qin(npx-1, j)-qin(npx-2, j))/(1.+&
&         g_in)+((2.+g_ou)*qin(npx, j)-qin(npx+1, j))/(1.+g_ou))
        qx(npx-1, j) = (3.*(qin(npx-2, j)+g_in*qin(npx-1, j))-(g_in*qx(&
&         npx, j)+qx(npx-2, j)))/(2.+2.*g_in)
      END DO
    END IF
    IF (3 .LT. js) THEN
      max5 = js
    ELSE
      max5 = 3
    END IF
    IF (npy - 2 .GT. je + 1) THEN
      min5 = je + 1
    ELSE
      min5 = npy - 2
    END IF
!------------
! Y-Interior:
!------------
    DO j=max5,min5
      IF (1 .LT. is - 2) THEN
        max6 = is - 2
      ELSE
        max6 = 1
      END IF
      IF (npx - 1 .GT. ie + 2) THEN
        min6 = ie + 2
      ELSE
        min6 = npx - 1
      END IF
      DO i=max6,min6
        qy(i, j) = b2*(qin(i, j-2)+qin(i, j+1)) + b1*(qin(i, j-1)+qin(i&
&         , j))
      END DO
    END DO
! South Edges:
    IF (js .EQ. 1) THEN
      DO i=is1,ie1
        q1(i) = (qin(i, 0)*geom%dya(i, 1)+qin(i, 1)*geom%dya(i, 0))/(&
&         geom%dya(i, 0)+geom%dya(i, 1))
      END DO
      DO i=is2,ie1
        qout(i, 1) = geom%edge_s(i)*q1(i-1) + (1.-geom%edge_s(i))*q1(i)
      END DO
      IF (1 .LT. is - 2) THEN
        max7 = is - 2
      ELSE
        max7 = 1
      END IF
      IF (npx - 1 .GT. ie + 2) THEN
        min7 = ie + 2
      ELSE
        min7 = npx - 1
      END IF
!
      DO i=max7,min7
        g_in = geom%dya(i, 2)/geom%dya(i, 1)
        g_ou = geom%dya(i, -1)/geom%dya(i, 0)
        qy(i, 1) = 0.5*(((2.+g_in)*qin(i, 1)-qin(i, 2))/(1.+g_in)+((2.+&
&         g_ou)*qin(i, 0)-qin(i, -1))/(1.+g_ou))
        qy(i, 2) = (3.*(g_in*qin(i, 1)+qin(i, 2))-(g_in*qy(i, 1)+qy(i, 3&
&         )))/(2.+2.*g_in)
      END DO
    END IF
! North Edges:
    IF (je + 1 .EQ. npy) THEN
      DO i=is1,ie1
        q1(i) = (qin(i, npy-1)*geom%dya(i, npy)+qin(i, npy)*geom%dya(i, &
&         npy-1))/(geom%dya(i, npy-1)+geom%dya(i, npy))
      END DO
      DO i=is2,ie1
        qout(i, npy) = geom%edge_n(i)*q1(i-1) + (1.-geom%edge_n(i))*q1(i&
&         )
      END DO
      IF (1 .LT. is - 2) THEN
        max8 = is - 2
      ELSE
        max8 = 1
      END IF
      IF (npx - 1 .GT. ie + 2) THEN
        min8 = ie + 2
      ELSE
        min8 = npx - 1
      END IF
!
      DO i=max8,min8
        g_in = geom%dya(i, npy-2)/geom%dya(i, npy-1)
        g_ou = geom%dya(i, npy+1)/geom%dya(i, npy)
        qy(i, npy) = 0.5*(((2.+g_in)*qin(i, npy-1)-qin(i, npy-2))/(1.+&
&         g_in)+((2.+g_ou)*qin(i, npy)-qin(i, npy+1))/(1.+g_ou))
        qy(i, npy-1) = (3.*(qin(i, npy-2)+g_in*qin(i, npy-1))-(g_in*qy(i&
&         , npy)+qy(i, npy-2)))/(2.+2.*g_in)
      END DO
    END IF
    IF (3 .LT. js) THEN
      max9 = js
    ELSE
      max9 = 3
    END IF
    IF (npy - 2 .GT. je + 1) THEN
      min9 = je + 1
    ELSE
      min9 = npy - 2
    END IF
!--------------------------------------
    DO j=max9,min9
      IF (2 .LT. is) THEN
        max10 = is
      ELSE
        max10 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        min10 = ie + 1
      ELSE
        min10 = npx - 1
      END IF
      DO i=max10,min10
        qxx(i, j) = a2*(qx(i, j-2)+qx(i, j+1)) + a1*(qx(i, j-1)+qx(i, j)&
&         )
      END DO
    END DO
    IF (js .EQ. 1) THEN
      IF (2 .LT. is) THEN
        max11 = is
      ELSE
        max11 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        min11 = ie + 1
      ELSE
        min11 = npx - 1
      END IF
      DO i=max11,min11
        qxx(i, 2) = c1*(qx(i, 1)+qx(i, 2)) + c2*(qout(i, 1)+qxx(i, 3))
      END DO
    END IF
    IF (je + 1 .EQ. npy) THEN
      IF (2 .LT. is) THEN
        max12 = is
      ELSE
        max12 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        min12 = ie + 1
      ELSE
        min12 = npx - 1
      END IF
      DO i=max12,min12
        qxx(i, npy-1) = c1*(qx(i, npy-2)+qx(i, npy-1)) + c2*(qout(i, npy&
&         )+qxx(i, npy-2))
      END DO
    END IF
    IF (2 .LT. js) THEN
      max13 = js
    ELSE
      max13 = 2
    END IF
    IF (npy - 1 .GT. je + 1) THEN
      min13 = je + 1
    ELSE
      min13 = npy - 1
    END IF
    DO j=max13,min13
      IF (3 .LT. is) THEN
        max14 = is
      ELSE
        max14 = 3
      END IF
      IF (npx - 2 .GT. ie + 1) THEN
        min14 = ie + 1
      ELSE
        min14 = npx - 2
      END IF
      DO i=max14,min14
        qyy(i, j) = a2*(qy(i-2, j)+qy(i+1, j)) + a1*(qy(i-1, j)+qy(i, j)&
&         )
      END DO
      IF (is .EQ. 1) qyy(2, j) = c1*(qy(1, j)+qy(2, j)) + c2*(qout(1, j)&
&         +qyy(3, j))
      IF (ie + 1 .EQ. npx) qyy(npx-1, j) = c1*(qy(npx-2, j)+qy(npx-1, j)&
&         ) + c2*(qout(npx, j)+qyy(npx-2, j))
      IF (2 .LT. is) THEN
        max15 = is
      ELSE
        max15 = 2
      END IF
      IF (npx - 1 .GT. ie + 1) THEN
        min15 = ie + 1
      ELSE
        min15 = npx - 1
      END IF
      DO i=max15,min15
! averaging
        qout(i, j) = 0.5*(qxx(i, j)+qyy(i, j))
      END DO
    END DO
  END SUBROUTINE A2B_ORD4
!  Differentiation of extrap_corner in forward (tangent) mode:
!   variations   of useful results: extrap_corner
!   with respect to varying inputs: q1 q2
!----------------------------------------------------------------------------
  REAL(kind=kind_real) FUNCTION EXTRAP_CORNER_TLM(p0, p1, p2, q1, q1_tl&
&   , q2, q2_tl, extrap_corner)
    IMPLICIT NONE
    REAL(kind=kind_real), DIMENSION(2), INTENT(IN) :: p0, p1, p2
    REAL(kind=kind_real), INTENT(IN) :: q1, q2
    REAL(kind=kind_real), INTENT(IN) :: q1_tl, q2_tl
    REAL(kind=kind_real) :: x1, x2
    REAL(kind=kind_real) :: extrap_corner
    x1 = GREAT_CIRCLE_DIST(p1, p0)
    x2 = GREAT_CIRCLE_DIST(p2, p0)
    extrap_corner_tlm = q1_tl + x1*(q1_tl-q2_tl)/(x2-x1)
    extrap_corner = q1 + x1/(x2-x1)*(q1-q2)
  END FUNCTION EXTRAP_CORNER_TLM
!----------------------------------------------------------------------------
  REAL(kind=kind_real) FUNCTION EXTRAP_CORNER(p0, p1, p2, q1, q2)
    IMPLICIT NONE
    REAL(kind=kind_real), DIMENSION(2), INTENT(IN) :: p0, p1, p2
    REAL(kind=kind_real), INTENT(IN) :: q1, q2
    REAL(kind=kind_real) :: x1, x2
    x1 = GREAT_CIRCLE_DIST(p1, p0)
    x2 = GREAT_CIRCLE_DIST(p2, p0)
    extrap_corner = q1 + x1/(x2-x1)*(q1-q2)
  END FUNCTION EXTRAP_CORNER
!----------------------------------------------------------------------------
  REAL(kind=kind_real) FUNCTION GREAT_CIRCLE_DIST(q1, q2)
    IMPLICIT NONE
    REAL(kind=kind_real), INTENT(IN) :: q1(2), q2(2)
    REAL(kind=kind_real) :: p1(2), p2(2)
    INTEGER :: n
    INTRINSIC SIN
    INTRINSIC COS
    INTRINSIC SQRT
    INTRINSIC ASIN
    REAL*8 :: arg1
    REAL*8 :: arg2
    REAL(kind=kind_real) :: arg3
    REAL(kind=kind_real) :: result1
    REAL(kind=kind_real) :: result2
    DO n=1,2
      p1(n) = q1(n)
      p2(n) = q2(n)
    END DO
    arg1 = (p1(2)-p2(2))/2.
    arg2 = (p1(1)-p2(1))/2.
    arg3 = SIN(arg1)**2 + COS(p1(2))*COS(p2(2))*SIN(arg2)**2
    result1 = SQRT(arg3)
    result2 = ASIN(result1)
    great_circle_dist = result2*2.
  END FUNCTION GREAT_CIRCLE_DIST
END MODULE WIND_VT_MOD_DIFF
